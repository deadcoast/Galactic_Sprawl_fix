[
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/App.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'profiler' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 360,
        "column": 9,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 360,
        "endColumn": 17
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import * as React from 'react';\nimport { lazy, Suspense, useEffect } from 'react';\nimport { SystemIntegration } from './components/core/SystemIntegration';\nimport { ThresholdIntegration } from './components/core/ThresholdIntegration';\nimport { GameStateMonitor } from './components/debug/GameStateMonitor';\nimport { TooltipProvider } from './components/ui/TooltipProvider';\nimport { defaultColony, defaultMothership } from './config/buildings/defaultBuildings';\nimport { defaultModuleConfigs } from './config/modules/defaultModuleConfigs';\nimport { GameActionType, GameProvider, useGameDispatch } from './contexts/GameContext';\nimport { ModuleActionType, ModuleProvider, useModuleDispatch } from './contexts/ModuleContext';\nimport { ResourceRatesProvider } from './contexts/ResourceRatesContext';\nimport { ThresholdProvider } from './contexts/ThresholdContext';\nimport { assetManager } from './managers/game/assetManager';\nimport { ResourceManager } from './managers/game/ResourceManager';\nimport { TechNode, techTreeManager } from './managers/game/techTreeManager';\nimport { moduleManager } from './managers/module/ModuleManager';\nimport { OfficerManager } from './managers/module/OfficerManager';\nimport { ShipHangarManager } from './managers/module/ShipHangarManager';\nimport { ModuleType } from './types/buildings/ModuleTypes';\nimport { ModuleStatus } from './types/modules/ModuleTypes';\nimport { ResourceType } from './types/resources/ResourceTypes';\n\n// Import the GlobalErrorBoundary component\nimport { GlobalErrorBoundary } from './components/ui/GlobalErrorBoundary';\n// Import error services\nimport { IntegrationErrorHandler } from './components/core/IntegrationErrorHandler';\nimport ResourceVisualization from './components/ui/ResourceVisualization';\nimport { useComponentProfiler } from './hooks/ui/useComponentProfiler';\nimport { useProfilingOverlay } from './hooks/ui/useProfilingOverlay';\nimport { errorLoggingService, ErrorSeverity, ErrorType } from './services/ErrorLoggingService';\nimport { eventPropagationService } from './services/EventPropagationService';\nimport { recoveryService } from './services/RecoveryService';\nimport { BaseEvent } from './types/events/EventTypes';\n\n// Lazy load components that aren't needed on initial render\nconst GameLayout = lazy(() =>\n  import('./components/ui/GameLayout').then(module => ({ default: module.GameLayout }))\n);\n\n// Loading component\nconst LoadingComponent = () => (\n  <div className=\"flex h-screen w-full flex-col items-center justify-center bg-gray-900 text-white\">\n    <div className=\"mb-4 h-12 w-12 animate-spin rounded-full border-4 border-blue-500 border-t-transparent\"></div>\n    <h2 className=\"mb-2 text-xl font-medium\">Loading Game Components...</h2>\n    <p className=\"text-gray-400\">Preparing your galactic adventure</p>\n  </div>\n);\n\n// Initial tech tree setup\nconst initialTechs: TechNode[] = [\n  {\n    id: 'basic-ship-hangar',\n    name: 'Basic Ship Hangar',\n    description: 'Enables basic ship construction',\n    type: 'hangar',\n    tier: 1 as const,\n    requirements: [],\n    unlocked: true,\n    category: 'infrastructure',\n  },\n  {\n    id: 'basic-weapons',\n    name: 'Basic Weapons',\n    description: 'Enables basic weapon systems',\n    type: 'weapons',\n    tier: 1 as const,\n    requirements: ['basic-ship-hangar'],\n    unlocked: false,\n    category: 'weapons',\n  },\n  {\n    id: 'basic-sensors',\n    name: 'Basic Sensors',\n    description: 'Enables basic scanning capabilities',\n    type: 'recon',\n    tier: 1 as const,\n    requirements: ['basic-ship-hangar'],\n    unlocked: false,\n    category: 'reconFleet',\n  },\n];\n\ninterface ResourceEvent extends BaseEvent {\n  moduleId: string;\n  data: {\n    resources: {\n      current: number;\n      [key: string]: unknown;\n    };\n  };\n}\n\ninterface ThresholdEvent extends BaseEvent {\n  resourceId: ResourceType;\n  details: {\n    type: 'below_minimum' | 'above_maximum';\n    current: number;\n    min?: number;\n    max?: number;\n  };\n}\n\n// GameInitializer component to handle game initialization\nconst GameInitializer = ({ children }: { children: React.ReactNode }) => {\n  const dispatch = useGameDispatch();\n  const [isInitialized, setIsInitialized] = React.useState(false);\n  const moduleDispatch = useModuleDispatch();\n  const [resourceManagerInstance] = React.useState(() => new ResourceManager());\n\n  useEffect(() => {\n    const initializeGame = async () => {\n      if (!isInitialized) {\n        console.warn('Starting game initialization...');\n        try {\n          // Initialize resource manager\n          console.warn('Initializing resource manager...');\n          // ResourceManager is already initialized via useState\n\n          // Register module configurations\n          console.warn('Registering module configurations...');\n          if (defaultModuleConfigs) {\n            Object.values(defaultModuleConfigs).forEach(config => {\n              if (config) {\n                console.warn(`Registering module config: ${config.type}`);\n                moduleManager.registerModuleConfig(config);\n              }\n            });\n          } else {\n            console.warn('defaultModuleConfigs is null or undefined');\n          }\n\n          // Register default buildings\n          console.warn('Registering default buildings...');\n          if (defaultMothership) {\n            console.warn(`Registering mothership: ${defaultMothership.id}`);\n            moduleManager.registerBuilding(defaultMothership);\n\n            // Also register the building with the ModuleContext\n            moduleDispatch({\n              type: ModuleActionType.ADD_MODULE,\n              payload: {\n                module: {\n                  ...defaultMothership,\n                  name: 'Mothership',\n                  position: { x: 0, y: 0 },\n                  isActive: true,\n                  status: ModuleStatus.ACTIVE,\n                  type: 'resource-manager' as ModuleType,\n                },\n              },\n            });\n          }\n\n          if (defaultColony) {\n            console.warn(`Registering colony: ${defaultColony.id}`);\n            moduleManager.registerBuilding(defaultColony);\n\n            // Also register the building with the ModuleContext\n            moduleDispatch({\n              type: ModuleActionType.ADD_MODULE,\n              payload: {\n                module: {\n                  ...defaultColony,\n                  name: 'Colony',\n                  position: { x: 0, y: 0 },\n                  isActive: true,\n                  status: ModuleStatus.ACTIVE,\n                  type: 'resource-manager' as ModuleType,\n                },\n              },\n            });\n          }\n\n          // Initialize asset manager\n          console.warn('Initializing asset manager...');\n          await assetManager.initialize();\n\n          // Register initial technologies\n          console.warn('Registering initial technologies...');\n          if (initialTechs) {\n            initialTechs.forEach(tech => {\n              if (tech) {\n                console.warn(`Registering tech: ${tech.id}`);\n                techTreeManager.registerNode(tech);\n              }\n            });\n          } else {\n            console.warn('initialTechs is null or undefined');\n          }\n\n          // Add initial resources\n          console.warn('Adding initial resources...');\n          dispatch({\n            type: GameActionType.UPDATE_RESOURCES,\n            payload: {\n              minerals: 2000, // Increased initial resources to allow for early module building\n              energy: 2000,\n              research: 0,\n              population: 100,\n            },\n          });\n\n          // Update systems count\n          console.warn('Updating system counts...');\n          dispatch({\n            type: GameActionType.UPDATE_SYSTEMS,\n            payload: {\n              total: 1,\n              colonized: 1,\n              explored: 1,\n            },\n          });\n\n          // Initialize the officer manager\n          console.warn('Initializing officer manager...');\n          const officerManager = new OfficerManager();\n\n          // Initialize the ship hangar manager\n          console.warn('Initializing ship hangar manager...');\n          const shipHangarManager = new ShipHangarManager(resourceManagerInstance, officerManager);\n\n          // Register the ship hangar manager with the global window object for development access\n          if (process.env.NODE_ENV === 'development') {\n            // Make manager available for debugging\n            (\n              window as Window & typeof globalThis & { shipHangarManager: ShipHangarManager }\n            ).shipHangarManager = shipHangarManager;\n          }\n\n          // Initialize event propagation service\n          console.warn('Initializing event propagation service...');\n\n          // Register event mappings\n          eventPropagationService.subscribe({\n            eventType: 'RESOURCE_UPDATED',\n            priority: 1,\n            callback: (eventData: unknown) => {\n              const event = eventData as ResourceEvent;\n              const resources = event.data.resources;\n              const current = resources.current;\n\n              return {\n                resourceId: event.moduleId,\n                details: {\n                  current,\n                  type: 'below_minimum',\n                },\n                timestamp: Date.now(),\n              };\n            },\n          });\n\n          // Register threshold to module mappings\n          eventPropagationService.subscribe({\n            eventType: 'THRESHOLD_VIOLATED',\n            priority: 1,\n            callback: (eventData: unknown) => {\n              const event = eventData as ThresholdEvent;\n              return {\n                moduleId: 'threshold-service',\n                moduleType: 'resource' as ModuleType,\n                timestamp: Date.now(),\n                data: {\n                  resourceType: event.resourceId,\n                  thresholdType: event.details.type === 'below_minimum' ? 'min' : 'max',\n                  current: event.details.current,\n                  threshold:\n                    event.details.type === 'below_minimum' ? event.details.min : event.details.max,\n                },\n              };\n            },\n          });\n\n          // Initialize the service\n          eventPropagationService.initialize();\n\n          // Set initialization flag\n          console.warn('Game initialization complete!');\n\n          // Log the current state of the module manager\n          console.warn('Module manager state:', {\n            buildings: moduleManager.getBuildings(),\n            modules: moduleManager.getActiveModules(),\n            configs: 'Module configurations registered',\n          });\n\n          setIsInitialized(true);\n        } catch (error) {\n          console.error('Error during game initialization:', error);\n          errorLoggingService.logError(\n            error instanceof Error ? error : new Error(String(error)),\n            ErrorType.INITIALIZATION,\n            ErrorSeverity.HIGH,\n            {\n              action: 'initialization',\n            }\n          );\n\n          // Attempt recovery\n          const snapshot = {\n            gameState: 'error',\n            error: error instanceof Error ? error.message : String(error),\n          };\n          recoveryService.createSnapshot(snapshot, { reason: 'Error during initialization' });\n        }\n      }\n    };\n\n    initializeGame();\n  }, [dispatch, isInitialized, moduleDispatch]);\n\n  if (!isInitialized) {\n    return (\n      <div className=\"flex h-screen w-full flex-col items-center justify-center bg-gray-900 text-white\">\n        <div className=\"mb-4 h-12 w-12 animate-spin rounded-full border-4 border-blue-500 border-t-transparent\"></div>\n        <h2 className=\"mb-2 text-xl font-medium\">Initializing Game Systems...</h2>\n        <p className=\"text-gray-400\">Preparing galaxy for exploration</p>\n      </div>\n    );\n  }\n\n  return (\n    <IntegrationErrorHandler componentName=\"SystemIntegration\">\n      <SystemIntegration resourceManager={resourceManagerInstance}>\n        <IntegrationErrorHandler componentName=\"ThresholdIntegration\">\n          <ThresholdIntegration resourceManager={resourceManagerInstance}>\n            {children}\n          </ThresholdIntegration>\n        </IntegrationErrorHandler>\n      </SystemIntegration>\n    </IntegrationErrorHandler>\n  );\n};\n\n// Handler for global errors\nconst handleGlobalError = (error: Error, errorInfo: React.ErrorInfo) => {\n  // Log the error using our error logging service\n  errorLoggingService.logError(error, ErrorType.RUNTIME, ErrorSeverity.HIGH, {\n    componentName: 'GlobalErrorBoundary',\n    errorInfo,\n  });\n\n  // Log to console for development purposes\n  console.error('Global error caught:', error, errorInfo);\n};\n\n// A wrapper for the GameLayout component to provide the required props\nconst GameLayoutWrapper = () => {\n  return (\n    <GameLayout empireName=\"Stellar Dominion\" bannerColor=\"#4FD1C5\">\n      <div className=\"min-h-screen bg-gray-900\">\n        <ResourceVisualization type={ResourceType.ENERGY} value={100} />\n      </div>\n    </GameLayout>\n  );\n};\n\nexport default function App() {\n  // Enable app-level profiling\n  const profiler = useComponentProfiler('App', {\n    enabled: true,\n    logToConsole: false,\n    trackPropChanges: true,\n  });\n\n  // Show profiling overlay in development\n  useProfilingOverlay({\n    enabledByDefault: process.env.NODE_ENV === 'development',\n    enableInProduction: false,\n    toggleKey: 'p',\n    persistState: true,\n  });\n\n  // Make the ResourceManager accessible in development\n  const [resourceManager] = React.useState(() => new ResourceManager());\n\n  if (process.env.NODE_ENV === 'development') {\n    // Make ResourceManager available for debugging\n    (window as Window & typeof globalThis & { resourceManager: ResourceManager }).resourceManager =\n      resourceManager;\n  }\n\n  // Development mode debug tools\n  const showDebugTools = process.env.NODE_ENV === 'development';\n\n  return (\n    <div className=\"app-container\">\n      <GlobalErrorBoundary onError={handleGlobalError}>\n        <GameProvider>\n          <ModuleProvider>\n            <ResourceRatesProvider>\n              <ThresholdProvider>\n                <TooltipProvider>\n                  <GameInitializer>\n                    <Suspense fallback={<LoadingComponent />}>\n                      <GameLayoutWrapper />\n                      {showDebugTools && <GameStateMonitor expanded={false} />}\n                    </Suspense>\n                  </GameInitializer>\n                </TooltipProvider>\n              </ThresholdProvider>\n            </ResourceRatesProvider>\n          </ModuleProvider>\n        </GameProvider>\n      </GlobalErrorBoundary>\n    </div>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/api/TypeSafeApiClient.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ResourceRegistryUI.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/colony/AutomatedExpansion.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/colony/AutomatedPopulationManager.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'colonyName' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 53,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 53,
        "endColumn": 13
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'subscribe' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 73,
        "column": 11,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 73,
        "endColumn": 20
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { motion } from 'framer-motion';\nimport {\n  AlertTriangle,\n  CheckCircle,\n  ChevronDown,\n  ChevronUp,\n  Clock,\n  Pause,\n  Play,\n  RotateCcw,\n  Settings,\n  TrendingUp,\n  Users,\n} from 'lucide-react';\nimport { useCallback, useEffect, useState } from 'react';\nimport { useModuleEvents } from '../../../hooks/events/useModuleEvents';\nimport { moduleEventBus } from '../../../lib/events/ModuleEventBus';\nimport { EventType } from '../../../types/events/EventTypes';\nimport { StandardizedEvent } from '../../../types/events/StandardizedEvents';\nimport { ResourceType } from '../../../types/resources/ResourceTypes';\n\ninterface PopulationEvent {\n  id: string;\n  timestamp: number;\n  type: 'growth' | 'decline' | 'migration' | 'disaster' | 'policy';\n  amount: number;\n  reason: string;\n}\n\ninterface AutomatedPopulationManagerProps {\n  colonyId: string;\n  colonyName: string;\n  currentPopulation: number;\n  maxPopulation: number;\n  growthRate: number; // Effective growth rate per cycle\n  cycleLength: number; // Length of a growth cycle in milliseconds\n  autoGrowthEnabled?: boolean; // Whether automatic growth is enabled\n  events?: PopulationEvent[]; // Population events history\n  onPopulationChange?: (newPopulation: number) => void;\n  onAutoGrowthToggle?: (enabled: boolean) => void;\n  onCycleComplete?: (cycleCount: number) => void;\n  onSettingsChange?: (settings: { cycleLength: number }) => void;\n}\n\n/**\n * AutomatedPopulationManager component\n *\n * Manages automated population growth for a colony.\n * Handles growth cycles, population events, and provides controls for automation.\n */\nexport function AutomatedPopulationManager({\n  colonyId,\n  colonyName,\n  currentPopulation,\n  maxPopulation,\n  growthRate,\n  cycleLength,\n  autoGrowthEnabled = false,\n  events = [],\n  onPopulationChange,\n  onAutoGrowthToggle,\n  onCycleComplete,\n  onSettingsChange,\n}: AutomatedPopulationManagerProps) {\n  const [isRunning, setIsRunning] = useState(autoGrowthEnabled);\n  const [cycleProgress, setCycleProgress] = useState(0);\n  const [cycleCount, setCycleCount] = useState(0);\n  const [nextGrowthAmount, setNextGrowthAmount] = useState(0);\n  const [showSettings, setShowSettings] = useState(false);\n  const [customCycleLength, setCustomCycleLength] = useState(cycleLength);\n  const [showEvents, setShowEvents] = useState(false);\n\n  const { subscribe } = useModuleEvents();\n\n  // Calculate the next growth amount based on current population and growth rate\n  const calculateNextGrowthAmount = useCallback(() => {\n    if (currentPopulation >= maxPopulation) {\n      return 0;\n    }\n\n    // Calculate raw growth\n    const rawGrowth = Math.floor(currentPopulation * growthRate);\n\n    // Ensure we don't exceed max population\n    const adjustedGrowth = Math.min(rawGrowth, maxPopulation - currentPopulation);\n\n    // Ensure at least 1 population growth if any growth is possible\n    return Math.max(1, adjustedGrowth);\n  }, [currentPopulation, maxPopulation, growthRate]);\n\n  // Update next growth amount when dependencies change\n  useEffect(() => {\n    setNextGrowthAmount(calculateNextGrowthAmount());\n  }, [calculateNextGrowthAmount]);\n\n  // Emit population update event\n  const emitPopulationUpdate = useCallback(\n    (newPopulation: number) => {\n      const event: StandardizedEvent = {\n        type: EventType.MODULE_UPDATED,\n        moduleId: colonyId,\n        moduleType: ResourceType.POPULATION,\n        timestamp: Date.now(),\n        data: {\n          stats: {\n            [ResourceType.POPULATION]: newPopulation,\n          },\n        },\n      };\n      moduleEventBus.emit(event);\n    },\n    [colonyId]\n  );\n\n  // Handle population growth cycle\n  useEffect(() => {\n    if (!isRunning) return;\n\n    let lastUpdate = Date.now();\n    let progress = 0;\n\n    const updateInterval = setInterval(() => {\n      const now = Date.now();\n      const delta = now - lastUpdate;\n      lastUpdate = now;\n\n      progress += delta;\n      const progressPercent = (progress / customCycleLength) * 100;\n      setCycleProgress(progressPercent);\n\n      if (progress >= customCycleLength) {\n        // Reset progress\n        progress = 0;\n        setCycleProgress(0);\n        setCycleCount(prev => prev + 1);\n\n        // Calculate and apply population growth\n        const growthAmount = calculateNextGrowthAmount();\n        if (growthAmount > 0) {\n          const newPopulation = currentPopulation + growthAmount;\n          onPopulationChange?.(newPopulation);\n          emitPopulationUpdate(newPopulation);\n        }\n\n        // Notify cycle completion\n        onCycleComplete?.(cycleCount + 1);\n      }\n    }, 100); // Update progress every 100ms\n\n    return () => {\n      clearInterval(updateInterval);\n    };\n  }, [\n    isRunning,\n    customCycleLength,\n    currentPopulation,\n    calculateNextGrowthAmount,\n    onPopulationChange,\n    onCycleComplete,\n    cycleCount,\n    colonyId,\n    emitPopulationUpdate,\n  ]);\n\n  // Handle automation toggle\n  const handleAutomationToggle = useCallback(() => {\n    const newState = !isRunning;\n    setIsRunning(newState);\n    onAutoGrowthToggle?.(newState);\n  }, [isRunning, onAutoGrowthToggle]);\n\n  // Handle cycle length change\n  const handleCycleLengthChange = useCallback(\n    (newLength: number) => {\n      setCustomCycleLength(newLength);\n      onSettingsChange?.({ cycleLength: newLength });\n    },\n    [onSettingsChange]\n  );\n\n  // Format time in minutes and seconds\n  const formatTime = (ms: number) => {\n    const totalSeconds = Math.floor(ms / 1000);\n    const minutes = Math.floor(totalSeconds / 60);\n    const seconds = totalSeconds % 60;\n\n    return `${minutes}:${seconds.toString().padStart(2, '0')}`;\n  };\n\n  // Format timestamp to readable date/time\n  const formatTimestamp = (timestamp: number) => {\n    const date = new Date(timestamp);\n    return date.toLocaleString();\n  };\n\n  // Get color for population percentage\n  const getPopulationColor = () => {\n    const percentage = (currentPopulation / maxPopulation) * 100;\n\n    if (percentage >= 90) {\n      return 'text-red-400';\n    } else if (percentage >= 75) {\n      return 'text-amber-400';\n    } else if (percentage >= 50) {\n      return 'text-green-400';\n    } else if (percentage >= 25) {\n      return 'text-blue-400';\n    }\n\n    return 'text-gray-400';\n  };\n\n  // Get icon for event type\n  const getEventIcon = (type: PopulationEvent['type']) => {\n    switch (type) {\n      case 'growth':\n        return <TrendingUp className=\"h-4 w-4 text-green-400\" />;\n      case 'decline':\n        return <TrendingUp className=\"h-4 w-4 rotate-180 transform text-red-400\" />;\n      case 'migration':\n        return <Users className=\"h-4 w-4 text-blue-400\" />;\n      case 'disaster':\n        return <AlertTriangle className=\"h-4 w-4 text-amber-400\" />;\n      case 'policy':\n        return <CheckCircle className=\"h-4 w-4 text-purple-400\" />;\n      default:\n        return <Users className=\"h-4 w-4 text-gray-400\" />;\n    }\n  };\n\n  return (\n    <div className=\"rounded-lg border border-gray-700 bg-gray-800 p-4\">\n      <div className=\"mb-4 flex items-center justify-between\">\n        <h3 className=\"text-lg font-medium text-white\">Population Management</h3>\n        <div className=\"flex items-center space-x-2\">\n          <button\n            className=\"rounded-md border border-gray-700 bg-gray-900 p-1 text-gray-400 hover:bg-gray-700 hover:text-white\"\n            onClick={() => setShowSettings(!showSettings)}\n            title=\"Settings\"\n          >\n            <Settings className=\"h-4 w-4\" />\n          </button>\n        </div>\n      </div>\n\n      {/* Population Stats */}\n      <div className=\"mb-4 grid grid-cols-2 gap-4\">\n        <div className=\"rounded-md border border-gray-700 bg-gray-900 p-3\">\n          <div className=\"mb-1 text-xs text-gray-400\">Current Population</div>\n          <div className=\"flex items-end justify-between\">\n            <div className=\"flex items-center\">\n              <Users className=\"mr-2 h-5 w-5 text-blue-400\" />\n              <span className={`text-xl font-bold ${getPopulationColor()}`}>\n                {currentPopulation.toLocaleString()}\n              </span>\n            </div>\n            <div className=\"text-xs text-gray-500\">\n              {((currentPopulation / maxPopulation) * 100).toFixed(1)}% of capacity\n            </div>\n          </div>\n          <div className=\"mt-2 h-2 w-full overflow-hidden rounded-full bg-gray-800\">\n            <motion.div\n              className=\"h-full bg-blue-500\"\n              style={{ width: `${(currentPopulation / maxPopulation) * 100}%` }}\n              initial={{ width: 0 }}\n              animate={{ width: `${(currentPopulation / maxPopulation) * 100}%` }}\n              transition={{ duration: 1 }}\n            />\n          </div>\n        </div>\n\n        <div className=\"rounded-md border border-gray-700 bg-gray-900 p-3\">\n          <div className=\"mb-1 text-xs text-gray-400\">Growth Rate</div>\n          <div className=\"flex items-end justify-between\">\n            <div className=\"flex items-center\">\n              <TrendingUp className=\"mr-2 h-5 w-5 text-green-400\" />\n              <span className=\"text-xl font-bold text-green-400\">\n                {(growthRate * 100).toFixed(2)}%\n              </span>\n            </div>\n            <div className=\"text-xs text-gray-500\">per cycle ({formatTime(cycleLength)})</div>\n          </div>\n          <div className=\"mt-2 flex items-center justify-between\">\n            <span className=\"text-xs text-gray-400\">Next growth:</span>\n            <span className=\"text-xs font-medium text-green-400\">\n              +{nextGrowthAmount.toLocaleString()}\n            </span>\n          </div>\n        </div>\n      </div>\n\n      {/* Growth Cycle Progress */}\n      <div className=\"mb-4 rounded-md border border-gray-700 bg-gray-900 p-3\">\n        <div className=\"mb-2 flex items-center justify-between\">\n          <div className=\"flex items-center\">\n            <Clock className=\"mr-2 h-4 w-4 text-blue-400\" />\n            <span className=\"text-sm font-medium text-white\">Growth Cycle</span>\n          </div>\n          <div className=\"text-xs text-gray-400\">\n            {isRunning ? 'Running' : 'Paused'} • Cycle #{cycleCount}\n          </div>\n        </div>\n\n        <div className=\"mb-2 h-2 w-full overflow-hidden rounded-full bg-gray-800\">\n          <motion.div\n            className=\"h-full bg-blue-500\"\n            style={{ width: `${cycleProgress}%` }}\n            animate={{ width: `${cycleProgress}%` }}\n            transition={{ duration: 0.5 }}\n          />\n        </div>\n\n        <div className=\"flex items-center justify-between\">\n          <div className=\"flex space-x-2\">\n            <button\n              className={`flex items-center space-x-1 rounded-md px-2 py-1 text-xs ${\n                isRunning\n                  ? 'bg-red-900/30 text-red-400 hover:bg-red-800/50'\n                  : 'bg-green-900/30 text-green-400 hover:bg-green-800/50'\n              }`}\n              onClick={handleAutomationToggle}\n            >\n              {isRunning ? (\n                <>\n                  <Pause className=\"h-3 w-3\" />\n                  <span>Pause</span>\n                </>\n              ) : (\n                <>\n                  <Play className=\"h-3 w-3\" />\n                  <span>Start</span>\n                </>\n              )}\n            </button>\n\n            <button\n              className=\"flex items-center space-x-1 rounded-md bg-gray-800 px-2 py-1 text-xs text-gray-400 hover:bg-gray-700\"\n              onClick={() => {\n                setCycleCount(0);\n                onCycleComplete?.(0);\n              }}\n            >\n              <RotateCcw className=\"h-3 w-3\" />\n              <span>Reset</span>\n            </button>\n          </div>\n\n          <div className=\"text-xs text-gray-400\">\n            {formatTime(cycleLength * (1 - cycleProgress / 100))} remaining\n          </div>\n        </div>\n      </div>\n\n      {/* Settings Panel */}\n      {showSettings && (\n        <motion.div\n          className=\"mb-4 rounded-md border border-gray-700 bg-gray-900 p-3\"\n          initial={{ opacity: 0, height: 0 }}\n          animate={{ opacity: 1, height: 'auto' }}\n          exit={{ opacity: 0, height: 0 }}\n        >\n          <div className=\"mb-3 text-sm font-medium text-white\">Growth Settings</div>\n\n          <div className=\"mb-3\">\n            <label className=\"mb-1 block text-xs text-gray-400\">Cycle Length (milliseconds)</label>\n            <div className=\"flex items-center space-x-2\">\n              <input\n                type=\"number\"\n                min=\"1000\"\n                step=\"1000\"\n                value={customCycleLength}\n                onChange={e => handleCycleLengthChange(Number(e.target.value))}\n                className=\"w-full rounded-md border border-gray-700 bg-gray-800 px-3 py-1 text-sm text-white\"\n              />\n              <button\n                className=\"rounded-md bg-blue-900/30 px-2 py-1 text-xs text-blue-400 hover:bg-blue-800/50\"\n                onClick={() => handleCycleLengthChange(customCycleLength)}\n              >\n                Apply\n              </button>\n            </div>\n            <div className=\"mt-1 text-xs text-gray-500\">\n              {formatTime(customCycleLength)} per cycle\n            </div>\n          </div>\n        </motion.div>\n      )}\n\n      {/* Population Events */}\n      <div className=\"overflow-hidden rounded-md border border-gray-700 bg-gray-900\">\n        <div\n          className=\"flex cursor-pointer items-center justify-between p-3\"\n          onClick={() => setShowEvents(!showEvents)}\n        >\n          <div className=\"flex items-center space-x-2\">\n            <Users className=\"h-4 w-4 text-blue-400\" />\n            <span className=\"text-sm font-medium text-white\">Population Events</span>\n          </div>\n          {showEvents ? (\n            <ChevronUp className=\"h-4 w-4 text-gray-400\" />\n          ) : (\n            <ChevronDown className=\"h-4 w-4 text-gray-400\" />\n          )}\n        </div>\n\n        {showEvents && (\n          <div className=\"border-t border-gray-700\">\n            {events.length === 0 ? (\n              <div className=\"p-3 text-center text-sm text-gray-500\">\n                No population events recorded\n              </div>\n            ) : (\n              <div className=\"max-h-48 overflow-y-auto\">\n                {events.map(event => (\n                  <div key={event.id} className=\"border-b border-gray-700 p-3 last:border-b-0\">\n                    <div className=\"flex items-center justify-between\">\n                      <div className=\"flex items-center space-x-2\">\n                        {getEventIcon(event.type)}\n                        <span className=\"text-sm font-medium capitalize text-white\">\n                          {event.type}\n                        </span>\n                      </div>\n                      <span\n                        className={`text-sm font-medium ${\n                          event.amount > 0 ? 'text-green-400' : 'text-red-400'\n                        }`}\n                      >\n                        {event.amount > 0 ? '+' : ''}\n                        {event.amount.toLocaleString()}\n                      </span>\n                    </div>\n                    <div className=\"mt-1 text-xs text-gray-400\">{event.reason}</div>\n                    <div className=\"mt-1 text-xs text-gray-500\">\n                      {formatTimestamp(event.timestamp)}\n                    </div>\n                  </div>\n                ))}\n              </div>\n            )}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/colony/BiodomeModule.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/colony/ColonyCore.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/colony/ColonyManagementSystem.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/colony/ColonyMap.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/colony/CulturalCenter.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/colony/EconomicHub.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/colony/GrowthRateModifiers.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/colony/HabitableWorld.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/colony/PopulationGrowthModule.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'subscribe' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 55,
        "column": 11,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 55,
        "endColumn": 20
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { AnimatePresence, motion } from 'framer-motion';\nimport { AlertTriangle, Droplet, Leaf, TrendingUp, Users, Zap } from 'lucide-react';\nimport { useCallback, useEffect, useState } from 'react';\nimport { useModuleEvents } from '../../../hooks/events/useModuleEvents';\nimport { moduleEventBus } from '../../../lib/events/ModuleEventBus';\nimport { EventType } from '../../../types/events/EventTypes';\nimport { StandardizedEvent } from '../../../types/events/StandardizedEvents';\nimport { ResourceType } from '../../../types/resources/ResourceTypes';\n\ninterface GrowthModifier {\n  id: string;\n  name: string;\n  description: string;\n  effect: number; // Percentage modifier (e.g., 1.1 = +10%)\n  type: ResourceType.FOOD | 'housing' | 'healthcare' | 'environment' | ResourceType.ENERGY;\n  active: boolean;\n}\n\ninterface PopulationGrowthModuleProps {\n  colonyId: string;\n  currentPopulation: number;\n  maxPopulation: number;\n  baseGrowthRate: number; // Base growth rate per cycle (e.g., 0.05 = 5%)\n  growthModifiers: GrowthModifier[];\n  cycleLength: number; // Length of a growth cycle in milliseconds\n  quality: 'low' | 'medium' | 'high';\n  onPopulationChange?: (newPopulation: number) => void;\n  onModifierToggle?: (modifierId: string, active: boolean) => void;\n}\n\n/**\n * PopulationGrowthModule component\n *\n * Displays and manages population growth mechanics for a colony.\n * Shows growth rate, modifiers, and provides controls for adjusting growth parameters.\n */\nexport function PopulationGrowthModule({\n  colonyId,\n  currentPopulation,\n  maxPopulation,\n  baseGrowthRate,\n  growthModifiers,\n  cycleLength,\n  quality: _quality,\n  onPopulationChange,\n  onModifierToggle,\n}: PopulationGrowthModuleProps) {\n  const [population, setPopulation] = useState(currentPopulation);\n  const [isGrowing, setIsGrowing] = useState(false);\n  const [growthHistory, setGrowthHistory] = useState<number[]>([]);\n  const [showModifiers, setShowModifiers] = useState(false);\n  const [autoGrowth, setAutoGrowth] = useState(false);\n  const [growthInterval, setGrowthInterval] = useState<NodeJS.Timeout | null>(null);\n\n  const { subscribe } = useModuleEvents();\n\n  // Calculate effective growth rate with all active modifiers\n  const effectiveGrowthRate = useCallback(() => {\n    const activeModifiers = growthModifiers.filter(m => m.active);\n    if (activeModifiers.length === 0) {\n      return baseGrowthRate;\n    }\n\n    const totalEffect = activeModifiers.reduce((total, modifier) => {\n      return total * modifier.effect;\n    }, 1);\n\n    return baseGrowthRate * totalEffect;\n  }, [baseGrowthRate, growthModifiers]);\n\n  // Format growth rate as percentage\n  const formattedGrowthRate = `${(effectiveGrowthRate() * 100).toFixed(2)}%`;\n\n  // Population percentage of maximum\n  const populationPercentage = Math.min(100, Math.round((population / maxPopulation) * 100));\n\n  // Population status\n  const getPopulationStatus = useCallback(() => {\n    if (populationPercentage < 30) {\n      return 'low';\n    }\n    if (populationPercentage > 90) {\n      return 'critical';\n    }\n    return 'normal';\n  }, [populationPercentage]);\n\n  const populationStatus = getPopulationStatus();\n\n  // Handle manual population growth\n  const handleGrowthCycle = useCallback(() => {\n    if (population >= maxPopulation) {\n      setIsGrowing(false);\n      return;\n    }\n\n    setIsGrowing(true);\n\n    // Calculate growth amount\n    const growthAmount = Math.floor(population * effectiveGrowthRate());\n    const newPopulation = Math.min(maxPopulation, population + growthAmount);\n\n    // Update population\n    setPopulation(newPopulation);\n    onPopulationChange?.(newPopulation);\n\n    // Update growth history\n    setGrowthHistory(prev => [...prev.slice(-9), growthAmount]);\n\n    // Emit population update event\n    const event: StandardizedEvent = {\n      type: EventType.MODULE_UPDATED,\n      moduleId: colonyId,\n      moduleType: ResourceType.POPULATION,\n      timestamp: Date.now(),\n      data: {\n        stats: {\n          [ResourceType.POPULATION]: newPopulation,\n        },\n      },\n    };\n    moduleEventBus.emit(event);\n\n    setTimeout(() => {\n      setIsGrowing(false);\n    }, 1000);\n  }, [population, maxPopulation, effectiveGrowthRate, colonyId, onPopulationChange]);\n\n  // Handle modifier toggle\n  const handleModifierToggle = useCallback(\n    (modifierId: string) => {\n      const modifier = growthModifiers.find(m => m.id === modifierId);\n      if (modifier) {\n        onModifierToggle?.(modifierId, !modifier.active);\n      }\n    },\n    [growthModifiers, onModifierToggle]\n  );\n\n  // Handle auto growth toggle\n  useEffect(() => {\n    if (autoGrowth) {\n      const interval = setInterval(() => {\n        handleGrowthCycle();\n      }, cycleLength);\n\n      setGrowthInterval(interval);\n\n      return () => {\n        clearInterval(interval);\n        setGrowthInterval(null);\n      };\n    } else if (growthInterval) {\n      clearInterval(growthInterval);\n      setGrowthInterval(null);\n    }\n  }, [autoGrowth, cycleLength, handleGrowthCycle]);\n\n  // Update local population when prop changes\n  useEffect(() => {\n    setPopulation(currentPopulation);\n  }, [currentPopulation]);\n\n  // Get icon for modifier type\n  const getModifierIcon = useCallback((type: GrowthModifier['type']) => {\n    switch (type) {\n      case ResourceType.FOOD:\n        return <Droplet className=\"h-4 w-4 text-blue-400\" />;\n      case 'housing':\n        return <Users className=\"h-4 w-4 text-indigo-400\" />;\n      case 'healthcare':\n        return <AlertTriangle className=\"h-4 w-4 text-red-400\" />;\n      case 'environment':\n        return <Leaf className=\"h-4 w-4 text-green-400\" />;\n      case ResourceType.ENERGY:\n        return <Zap className=\"h-4 w-4 text-yellow-400\" />;\n    }\n  }, []);\n\n  return (\n    <div className=\"rounded-lg border border-gray-700 bg-gray-800 p-4\">\n      <div className=\"mb-4 flex items-center justify-between\">\n        <h3 className=\"text-lg font-medium text-white\">Population Growth</h3>\n        <div className=\"flex items-center space-x-2\">\n          <span className=\"text-sm text-gray-400\">Auto Growth</span>\n          <button\n            className={`h-6 w-12 rounded-full ${\n              autoGrowth ? 'bg-green-600' : 'bg-gray-600'\n            } relative transition-colors`}\n            onClick={() => setAutoGrowth(!autoGrowth)}\n          >\n            <span\n              className={`absolute top-1 h-4 w-4 rounded-full bg-white transition-all ${\n                autoGrowth ? 'left-7' : 'left-1'\n              }`}\n            />\n          </button>\n        </div>\n      </div>\n\n      {/* Population Display */}\n      <div className=\"mb-6\">\n        <div className=\"mb-1 flex items-center justify-between\">\n          <div className=\"flex items-center space-x-2\">\n            <Users className=\"h-5 w-5 text-blue-400\" />\n            <span className=\"text-sm font-medium text-gray-300\">Current Population</span>\n          </div>\n          <span className=\"text-sm font-medium text-white\">{population.toLocaleString()}</span>\n        </div>\n\n        <div className=\"mb-1 flex justify-between text-xs\">\n          <span className=\"text-gray-400\">Capacity</span>\n          <span\n            className={`${\n              populationStatus === 'critical'\n                ? 'text-red-400'\n                : populationStatus === 'low'\n                  ? 'text-yellow-400'\n                  : 'text-gray-300'\n            }`}\n          >\n            {populationPercentage}%\n          </span>\n        </div>\n\n        <div className=\"h-2 overflow-hidden rounded-full bg-gray-700\">\n          <motion.div\n            className={`h-full rounded-full ${\n              populationStatus === 'critical'\n                ? 'bg-red-500'\n                : populationStatus === 'low'\n                  ? 'bg-yellow-500'\n                  : 'bg-blue-500'\n            }`}\n            initial={{ width: 0 }}\n            animate={{ width: `${populationPercentage}%` }}\n            transition={{ duration: 0.5 }}\n          />\n        </div>\n\n        <div className=\"mt-1 flex justify-between text-xs text-gray-500\">\n          <span>0</span>\n          <span>{maxPopulation.toLocaleString()}</span>\n        </div>\n      </div>\n\n      {/* Growth Rate */}\n      <div className=\"mb-4\">\n        <div className=\"mb-1 flex items-center justify-between\">\n          <div className=\"flex items-center space-x-2\">\n            <TrendingUp className=\"h-5 w-5 text-green-400\" />\n            <span className=\"text-sm font-medium text-gray-300\">Growth Rate</span>\n          </div>\n          <div className=\"flex items-center space-x-1\">\n            <span className=\"text-sm font-medium text-green-400\">{formattedGrowthRate}</span>\n            <span className=\"text-xs text-gray-500\">per cycle</span>\n          </div>\n        </div>\n\n        {/* Growth History Chart */}\n        <div className=\"mt-2 h-12 w-full\">\n          <div className=\"flex h-full items-end justify-between\">\n            {growthHistory.length === 0 ? (\n              <div className=\"flex h-full w-full items-center justify-center\">\n                <span className=\"text-xs text-gray-500\">No growth data yet</span>\n              </div>\n            ) : (\n              growthHistory.map((amount, index) => {\n                const percentage = Math.min(100, (amount / (maxPopulation * 0.1)) * 100);\n                return (\n                  <motion.div\n                    key={index}\n                    className=\"w-[8%] bg-green-500\"\n                    initial={{ height: 0 }}\n                    animate={{ height: `${percentage}%` }}\n                    transition={{ duration: 0.3, delay: index * 0.05 }}\n                  />\n                );\n              })\n            )}\n          </div>\n        </div>\n      </div>\n\n      {/* Growth Controls */}\n      <div className=\"mb-4\">\n        <button\n          className={`w-full rounded-md py-2 text-sm font-medium transition-colors ${\n            isGrowing || population >= maxPopulation\n              ? 'cursor-not-allowed bg-gray-700 text-gray-500'\n              : 'bg-blue-600 text-white hover:bg-blue-700'\n          }`}\n          onClick={handleGrowthCycle}\n          disabled={isGrowing || population >= maxPopulation}\n        >\n          {isGrowing\n            ? 'Growing...'\n            : population >= maxPopulation\n              ? 'Maximum Population Reached'\n              : 'Trigger Growth Cycle'}\n        </button>\n      </div>\n\n      {/* Growth Modifiers */}\n      <div>\n        <button\n          className=\"mb-2 flex w-full items-center justify-between rounded-md bg-gray-700 px-3 py-2 text-sm font-medium text-gray-300 hover:bg-gray-600\"\n          onClick={() => setShowModifiers(!showModifiers)}\n        >\n          <span>Growth Modifiers</span>\n          <span className=\"text-xs text-gray-400\">\n            {growthModifiers.filter(m => m.active).length} Active\n          </span>\n        </button>\n\n        <AnimatePresence>\n          {showModifiers && (\n            <motion.div\n              initial={{ height: 0, opacity: 0 }}\n              animate={{ height: 'auto', opacity: 1 }}\n              exit={{ height: 0, opacity: 0 }}\n              transition={{ duration: 0.3 }}\n              className=\"overflow-hidden\"\n            >\n              <div className=\"space-y-2 rounded-md bg-gray-900 p-3\">\n                {growthModifiers.map(modifier => (\n                  <div\n                    key={modifier.id}\n                    className=\"flex items-center justify-between rounded-md bg-gray-800 p-2\"\n                  >\n                    <div className=\"flex items-center space-x-2\">\n                      {getModifierIcon(modifier.type)}\n                      <div>\n                        <div className=\"text-sm font-medium text-gray-300\">{modifier.name}</div>\n                        <div className=\"text-xs text-gray-500\">{modifier.description}</div>\n                      </div>\n                    </div>\n                    <div className=\"flex items-center space-x-3\">\n                      <span\n                        className={`text-sm ${\n                          modifier.effect > 1 ? 'text-green-400' : 'text-red-400'\n                        }`}\n                      >\n                        {modifier.effect > 1 ? '+' : ''}\n                        {((modifier.effect - 1) * 100).toFixed(0)}%\n                      </span>\n                      <button\n                        className={`h-5 w-10 rounded-full ${\n                          modifier.active ? 'bg-green-600' : 'bg-gray-600'\n                        } relative transition-colors`}\n                        onClick={() => handleModifierToggle(modifier.id)}\n                      >\n                        <span\n                          className={`absolute top-0.5 h-4 w-4 rounded-full bg-white transition-all ${\n                            modifier.active ? 'left-5' : 'left-1'\n                          }`}\n                        />\n                      </button>\n                    </div>\n                  </div>\n                ))}\n              </div>\n            </motion.div>\n          )}\n        </AnimatePresence>\n      </div>\n    </div>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/colony/PopulationProjectionChart.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/colony/ResourceDashboard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/colony/ResourceTransferAnimation.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/colony/SatisfactionMeter.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/colony/TradeRouteVisualization.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/ExplorationHub/ExplorationControls.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/ExplorationHub/ExplorationHub.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/ExplorationHub/ExplorationTutorial.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/ExplorationHub/ExplorationWindow.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/ExplorationHub/MissionLog.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/ExplorationHub/MissionReplay.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'isCurrentEvent' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 163,
        "column": 13,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 163,
        "endColumn": 27
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import * as React from \"react\";\nimport { useCallback, useEffect, useState } from 'react';\nimport { Pause, Play, SkipBack, SkipForward, X } from 'lucide-react';\nimport { useGameState } from '../../../../contexts/GameContext';\nimport { GameEvent, GameEventType, Position } from '../../../../types/core/GameTypes';\n\ninterface MissionReplayProps {\n  missionId: string;\n  onClose: () => void;\n}\n\ninterface EventPosition {\n  x: number;\n  y: number;\n}\n\ninterface Mission {\n  id: string;\n  timestamp: number;\n  description: string;\n}\n\ninterface GameState {\n  missions: {\n    history: Mission[];\n  };\n  events: GameEvent[];\n}\n\nconst selectGameState = (state: unknown): GameState => {\n  if (\n    typeof state === 'object' &&\n    state !== null &&\n    'missions' in state &&\n    'events' in state &&\n    typeof state.missions === 'object' &&\n    state.missions !== null &&\n    'history' in state.missions &&\n    Array.isArray(state.missions.history) &&\n    Array.isArray(state.events)\n  ) {\n    return state as GameState;\n  }\n  return {\n    missions: {\n      history: [],\n    },\n    events: [],\n  };\n};\n\nexport function MissionReplay({ missionId, onClose }: MissionReplayProps) {\n  const gameState = useGameState(selectGameState);\n\n  // Ensure state is available\n  if (!gameState) {\n    return null;\n  }\n\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [currentTime, setCurrentTime] = useState(0);\n  const [playbackSpeed, setPlaybackSpeed] = useState(1);\n  const [currentEventIndex, setCurrentEventIndex] = useState<number | null>(null);\n\n  // Find the mission and related events\n  const mission = gameState.missions.history.find(m => m.id === missionId);\n  const events = gameState.events.filter(\n    e =>\n      e.timestamp >= (mission?.timestamp || 0) && e.timestamp <= (mission?.timestamp || 0) + 3600000 // 1 hour window\n  );\n\n  // Calculate total duration\n  const duration =\n    events.length > 0 ? events[events.length - 1].timestamp - events[0].timestamp : 0;\n\n  // Handle playback controls\n  const togglePlayback = useCallback(() => {\n    setIsPlaying(!isPlaying);\n  }, [isPlaying]);\n\n  const handleSeek = useCallback(\n    (time: number) => {\n      setCurrentTime(Math.max(0, Math.min(time, duration)));\n    },\n    [duration]\n  );\n\n  const handleSpeedChange = useCallback((speed: number) => {\n    setPlaybackSpeed(speed);\n  }, []);\n\n  // Update time during playback\n  useEffect(() => {\n    if (!isPlaying) {\n      return;\n    }\n\n    const interval = setInterval(() => {\n      setCurrentTime(time => {\n        const newTime = time + 100 * playbackSpeed;\n        if (newTime >= duration) {\n          setIsPlaying(false);\n          return duration;\n        }\n        return newTime;\n      });\n    }, 100);\n\n    return () => clearInterval(interval);\n  }, [isPlaying, playbackSpeed, duration]);\n\n  if (!mission) {\n    return null;\n  }\n\n  // Get events up to current time\n  const currentEvents = events.filter(\n    (e: GameEvent) => e.timestamp <= events[0].timestamp + currentTime\n  );\n\n  // Render map with ship paths and events\n  const renderEvents = (events: GameEvent[]) => {\n    return events.map((event: GameEvent, index: number) => {\n      // Calculate position based on event data or use random positioning as fallback\n      const eventPosition: EventPosition = {\n        x:\n          typeof event.data === 'object' &&\n          event.data !== null &&\n          'position' in event.data &&\n          typeof event.data.position === 'object' &&\n          event.data.position !== null &&\n          'x' in event.data.position\n            ? (event.data.position as Position).x\n            : Math.random() * 100,\n        y:\n          typeof event.data === 'object' &&\n          event.data !== null &&\n          'position' in event.data &&\n          typeof event.data.position === 'object' &&\n          event.data.position !== null &&\n          'y' in event.data.position\n            ? (event.data.position as Position).y\n            : Math.random() * 100,\n      };\n\n      // Determine event marker appearance based on event type\n      const getEventColor = (type: GameEventType) => {\n        switch (type) {\n          case 'exploration':\n            return 'bg-teal-400';\n          case 'combat':\n            return 'bg-red-400';\n          case 'trade':\n            return 'bg-amber-400';\n          case 'diplomacy':\n            return 'bg-purple-400';\n          default:\n            return 'bg-teal-400';\n        }\n      };\n\n      // Check if this is the current event being viewed\n      const isCurrentEvent = index === currentEventIndex;\n\n      return (\n        <div\n          key={`event-${index}`}\n          className=\"absolute h-2 w-2 rounded-full\"\n          style={{\n            left: `${eventPosition.x}%`,\n            top: `${eventPosition.y}%`,\n            backgroundColor: getEventColor(event.type),\n          }}\n          onClick={() => {\n            // Set current event index to this event when clicked\n            setCurrentEventIndex(index);\n          }}\n        />\n      );\n    });\n  };\n\n  return (\n    <div className=\"fixed inset-0 z-50 flex items-center justify-center bg-black/50\">\n      <div className=\"mx-4 w-full max-w-4xl rounded-lg border border-gray-700 bg-gray-900 p-6\">\n        <div className=\"mb-6 flex items-center justify-between\">\n          <h2 className=\"text-xl font-bold text-white\">Mission Replay</h2>\n          <button onClick={onClose} className=\"rounded-lg p-2 transition-colors hover:bg-gray-800\">\n            <X className=\"h-5 w-5 text-gray-400\" />\n          </button>\n        </div>\n\n        {/* Mission Details */}\n        <div className=\"mb-6\">\n          <div className=\"mb-2 text-lg text-white\">{mission.description}</div>\n          <div className=\"text-sm text-gray-400\">\n            {new Date(mission.timestamp).toLocaleString()}\n          </div>\n        </div>\n\n        {/* Replay Visualization */}\n        <div className=\"relative mb-6 h-96 overflow-hidden rounded-lg bg-gray-800/50\">\n          {/* Map View */}\n          <div className=\"absolute inset-0\">{renderEvents(currentEvents)}</div>\n\n          {/* Event Timeline */}\n          <div className=\"absolute bottom-0 left-0 right-0 h-24 bg-gradient-to-t from-gray-900/90 to-transparent p-4\">\n            <div className=\"mb-4 flex items-center space-x-4\">\n              {currentEvents.map((event: GameEvent, index: number) => (\n                <div\n                  key={index}\n                  className={`h-2 w-2 rounded-full ${\n                    index === currentEventIndex ? 'bg-white' : 'bg-teal-400'\n                  }`}\n                  style={{\n                    left: `${((event.timestamp - events[0].timestamp) / duration) * 100}%`,\n                  }}\n                  onClick={() => setCurrentEventIndex(index)}\n                />\n              ))}\n            </div>\n\n            {/* Current Event Details */}\n            {currentEventIndex !== null && currentEvents[currentEventIndex] && (\n              <div className=\"mb-2 text-sm text-white\">\n                <span className=\"font-bold\">{currentEvents[currentEventIndex].type}</span> event at{' '}\n                {new Date(currentEvents[currentEventIndex].timestamp).toLocaleTimeString()}\n              </div>\n            )}\n          </div>\n        </div>\n\n        {/* Playback Controls */}\n        <div className=\"flex items-center justify-between\">\n          <div className=\"flex items-center space-x-4\">\n            <button\n              onClick={() => handleSeek(0)}\n              className=\"rounded-lg p-2 transition-colors hover:bg-gray-800\"\n            >\n              <SkipBack className=\"h-5 w-5 text-teal-400\" />\n            </button>\n            <button\n              onClick={togglePlayback}\n              className=\"rounded-lg p-2 transition-colors hover:bg-gray-800\"\n            >\n              {isPlaying ? (\n                <Pause className=\"h-5 w-5 text-teal-400\" />\n              ) : (\n                <Play className=\"h-5 w-5 text-teal-400\" />\n              )}\n            </button>\n            <button\n              onClick={() => handleSeek(duration)}\n              className=\"rounded-lg p-2 transition-colors hover:bg-gray-800\"\n            >\n              <SkipForward className=\"h-5 w-5 text-teal-400\" />\n            </button>\n          </div>\n\n          {/* Playback Speed */}\n          <div className=\"flex items-center space-x-2\">\n            <span className=\"text-sm text-gray-400\">Speed:</span>\n            {[0.5, 1, 2, 4].map(speed => (\n              <button\n                key={speed}\n                onClick={() => handleSpeedChange(speed)}\n                className={`rounded px-2 py-1 text-sm ${\n                  playbackSpeed === speed\n                    ? 'bg-teal-600 text-white'\n                    : 'bg-gray-800 text-gray-400 hover:bg-gray-700'\n                }`}\n              >\n                {speed}x\n              </button>\n            ))}\n          </div>\n\n          {/* Progress */}\n          <div className=\"text-sm text-gray-400\">\n            {Math.floor(currentTime / 1000)}s / {Math.floor(duration / 1000)}s\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/ExplorationHub/ReconShipStatus.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/ExplorationHub/ShipStatusMonitor.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/MiningHub/AutomationMonitor.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/MiningHub/MineralProcessingCentre.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/MiningHub/MiningControls.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/MiningHub/MiningMap.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/MiningHub/MiningTutorial.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/MiningHub/MiningWindow.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/MiningHub/ResourceNode.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/MiningHub/ResourceStorage.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/MiningHub/ResourceTransfer.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/MiningHub/TechBonus.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/MiningHub/ThresholdManager.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/MiningHub/ThresholdPresetsPanel.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/MiningHub/ThresholdStatusIndicator.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/academy/HiringPanel.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/academy/OfficerAcademy.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/academy/OfficerCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/academy/OfficerDetails.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/hangar/HangarModule.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/hangar/ShipBuildingInterface.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'ResourceType' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 1,
        "column": 10,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 1,
        "endColumn": 22
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { ResourceType } from \"./../../../../types/resources/ResourceTypes\";\n/** @jsx React.createElement */\n/** @jsxFrag React.Fragment */\nimport { AlertTriangle } from 'lucide-react';\nimport * as React from \"react\";\nimport { ShipBlueprint, getAvailableShips } from '../../../../config/ShipBlueprints';\nimport { techTreeManager } from '../../../../managers/game/techTreeManager';\nimport { ShipHangarManager } from '../../../../managers/module/ShipHangarManager';\nimport { ResourceCost } from '../../../../types/resources/ResourceTypes';\nimport { PlayerShipCategory, PlayerShipClass } from '../../../../types/ships/PlayerShipTypes';\n\ninterface ShipBuildingInterfaceProps {\n  manager: ShipHangarManager;\n  onStartBuild: (shipClass: PlayerShipClass) => void;\n}\n\nexport function ShipBuildingInterface({ manager, onStartBuild }: ShipBuildingInterfaceProps) {\n  const [selectedCategory, setSelectedCategory] = React.useState<PlayerShipCategory | 'all'>('all');\n  const [selectedShip, setSelectedShip] = React.useState<ShipBlueprint | null>(null);\n  const [availableShips, setAvailableShips] = React.useState<ShipBlueprint[]>([]);\n  const [buildableShips, setBuildableShips] = React.useState<Set<PlayerShipClass>>(new Set());\n  const [errors, setErrors] = React.useState<Map<PlayerShipClass, string[]>>(new Map());\n  const [resourceRequirements, setResourceRequirements] = React.useState<ResourceCost[]>([]);\n\n  // Load available ships based on tech level and other requirements\n  React.useEffect(() => {\n    const currentTier = manager.getCurrentTier();\n    const ships = getAvailableShips(currentTier);\n    setAvailableShips(ships);\n\n    // Check which ships are buildable\n    const buildable = new Set<PlayerShipClass>();\n    const newErrors = new Map<PlayerShipClass, string[]>();\n\n    ships.forEach(ship => {\n      const errors: string[] = [];\n\n      // Check tech requirements\n      if (ship.requirements.prerequisites?.technology) {\n        const missingTech = ship.requirements.prerequisites.technology.filter(\n          tech => !techTreeManager.getNode(tech)?.unlocked\n        );\n        if (missingTech.length > 0) {\n          errors.push(`Missing technologies: ${missingTech.join(', ')}`);\n        }\n      }\n\n      // Check resource requirements\n      ship.requirements.resourceCost.forEach(cost => {\n        const requirements = manager.getBuildRequirements(ship.shipClass);\n        const available =\n          requirements.resourceCost.find((r: { type: string }) => r.type === cost.type)?.amount ||\n          0;\n        if (available < cost.amount) {\n          errors.push(`Insufficient ${cost.type}: ${available}/${cost.amount}`);\n        }\n      });\n\n      // Check officer requirements\n      if (ship.requirements.prerequisites?.officers) {\n        const req = ship.requirements.prerequisites.officers;\n        const hasQualifiedOfficer = manager.hasOfficerMeetingRequirements(\n          req.minLevel,\n          req.specialization\n        );\n        if (!hasQualifiedOfficer) {\n          errors.push(`Requires level ${req.minLevel} ${req.specialization} officer`);\n        }\n      }\n\n      if (errors.length === 0) {\n        buildable.add(ship.shipClass);\n      } else {\n        newErrors.set(ship.shipClass, errors);\n      }\n    });\n\n    setBuildableShips(buildable);\n    setErrors(newErrors);\n  }, [manager]);\n\n  // Update resource requirements when ship is selected\n  React.useEffect(() => {\n    if (selectedShip) {\n      const requirements = manager.getBuildRequirements(selectedShip.shipClass);\n      setResourceRequirements(requirements.resourceCost);\n    } else {\n      setResourceRequirements([]);\n    }\n  }, [selectedShip, manager]);\n\n  const handleStartBuild = () => {\n    if (!selectedShip || !buildableShips.has(selectedShip.shipClass)) {\n      return;\n    }\n    onStartBuild(selectedShip.shipClass);\n    setSelectedShip(null);\n  };\n\n  const filteredShips = availableShips.filter(\n    ship => selectedCategory === 'all' || ship.category === selectedCategory\n  );\n\n  return React.createElement(\n    'div',\n    { className: 'flex h-full flex-col' },\n    // Category Selection\n    React.createElement(\n      'div',\n      { className: 'mb-4 flex space-x-2' },\n      ['all', 'war', 'recon', 'mining'].map(category =>\n        React.createElement(\n          'button',\n          {\n            key: category,\n            onClick: () => setSelectedCategory(category as PlayerShipCategory | 'all'),\n            className: `rounded-lg px-4 py-2 ${\n              selectedCategory === category\n                ? 'bg-indigo-600 text-white'\n                : 'bg-gray-800 text-gray-400 hover:bg-gray-700'\n            }`,\n          },\n          category.charAt(0).toUpperCase() + category.slice(1)\n        )\n      )\n    ),\n    // Ship List\n    React.createElement(\n      'div',\n      { className: 'grid flex-1 grid-cols-2 gap-4 overflow-y-auto' },\n      filteredShips.map(ship =>\n        React.createElement(\n          'div',\n          {\n            key: ship.shipClass,\n            onClick: () => setSelectedShip(ship),\n            className: `cursor-pointer rounded-lg p-4 ${\n              selectedShip?.shipClass === ship.shipClass\n                ? 'border border-indigo-500 bg-indigo-900/50'\n                : buildableShips.has(ship.shipClass)\n                  ? 'border border-gray-700 bg-gray-800/50 hover:border-gray-600'\n                  : 'border border-gray-700/50 bg-gray-800/30 opacity-75'\n            }`,\n          },\n          React.createElement(\n            'div',\n            { className: 'mb-2 flex items-start justify-between' },\n            React.createElement(\n              'div',\n              null,\n              React.createElement('h3', { className: 'text-lg font-medium text-white' }, ship.name),\n              React.createElement(\n                'div',\n                { className: 'flex items-center text-sm text-gray-400' },\n                React.createElement('span', null, 'Tier ', ship.tier),\n                React.createElement('span', { className: 'mx-2' }, '•'),\n                React.createElement('span', { className: 'capitalize' }, ship.category)\n              )\n            ),\n            !buildableShips.has(ship.shipClass) &&\n              React.createElement(AlertTriangle, { className: 'h-5 w-5 text-amber-500' })\n          ),\n          React.createElement('p', { className: 'mb-4 text-sm text-gray-400' }, ship.description),\n          // Ship Stats\n          React.createElement(\n            'div',\n            { className: 'grid grid-cols-2 gap-2 text-sm' },\n            React.createElement(\n              'div',\n              { className: 'text-gray-400' },\n              'Hull: ',\n              React.createElement('span', { className: 'text-white' }, ship.baseStats.hull)\n            ),\n            React.createElement(\n              'div',\n              { className: 'text-gray-400' },\n              'Shield: ',\n              React.createElement('span', { className: 'text-white' }, ship.baseStats.shield)\n            ),\n            React.createElement(\n              'div',\n              { className: 'text-gray-400' },\n              'Energy: ',\n              React.createElement('span', { className: 'text-white' }, ship.baseStats.energy)\n            ),\n            React.createElement(\n              'div',\n              { className: 'text-gray-400' },\n              'Speed: ',\n              React.createElement('span', { className: 'text-white' }, ship.baseStats.speed)\n            ),\n            ship.baseStats.cargo &&\n              React.createElement(\n                'div',\n                { className: 'text-gray-400' },\n                'Cargo: ',\n                React.createElement('span', { className: 'text-white' }, ship.baseStats.cargo)\n              ),\n            ship.baseStats.scanRange &&\n              React.createElement(\n                'div',\n                { className: 'text-gray-400' },\n                'Scan Range: ',\n                React.createElement('span', { className: 'text-white' }, ship.baseStats.scanRange)\n              ),\n            ship.baseStats.miningRate &&\n              React.createElement(\n                'div',\n                { className: 'text-gray-400' },\n                'Mining Rate: ',\n                React.createElement('span', { className: 'text-white' }, ship.baseStats.miningRate)\n              )\n          ),\n          // Resource Costs\n          React.createElement(\n            'div',\n            { className: 'mt-4 border-t border-gray-700 pt-4' },\n            React.createElement(\n              'h4',\n              { className: 'mb-2 text-sm font-medium text-gray-300' },\n              'Requirements'\n            ),\n            React.createElement(\n              'div',\n              { className: 'flex flex-wrap gap-2' },\n              ship.requirements.resourceCost.map(cost => {\n                const requirements = manager.getBuildRequirements(ship.shipClass);\n                const available =\n                  requirements.resourceCost.find((r: { type: string }) => r.type === cost.type)\n                    ?.amount || 0;\n                return React.createElement(\n                  'div',\n                  {\n                    key: cost.type,\n                    className: `rounded px-2 py-1 text-xs ${\n                      available >= cost.amount\n                        ? 'bg-gray-700/50 text-gray-300'\n                        : 'bg-red-900/50 text-red-300'\n                    }`,\n                  },\n                  `${cost.type}: ${cost.amount}`\n                );\n              })\n            )\n          ),\n          // Build Errors\n          errors.get(ship.shipClass) &&\n            React.createElement(\n              'div',\n              { className: 'mt-2 text-xs text-amber-500' },\n              errors\n                .get(ship.shipClass)\n                ?.map((error, i) => React.createElement('div', { key: i }, error))\n            )\n        )\n      )\n    ),\n    // Build Controls\n    selectedShip &&\n      React.createElement(\n        'div',\n        { className: 'mt-4 rounded-lg bg-gray-800 p-4' },\n        React.createElement(\n          'div',\n          { className: 'flex items-center justify-between' },\n          React.createElement(\n            'div',\n            null,\n            React.createElement(\n              'h3',\n              { className: 'text-lg font-medium text-white' },\n              selectedShip.name\n            ),\n            React.createElement(\n              'div',\n              { className: 'text-sm text-gray-400' },\n              React.createElement(\n                'p',\n                null,\n                `Build Time: ${selectedShip.requirements.buildTime / 1000}s`\n              ),\n              React.createElement(\n                'div',\n                { className: 'mt-1 flex gap-2' },\n                resourceRequirements.map(cost =>\n                  React.createElement(\n                    'span',\n                    { key: cost.type, className: 'text-gray-300' },\n                    `${cost.type}: ${cost.amount}`\n                  )\n                )\n              )\n            )\n          ),\n          React.createElement(\n            'button',\n            {\n              onClick: handleStartBuild,\n              disabled: !buildableShips.has(selectedShip.shipClass),\n              className: `rounded-lg px-6 py-2 ${\n                buildableShips.has(selectedShip.shipClass)\n                  ? 'bg-indigo-600 text-white hover:bg-indigo-700'\n                  : 'cursor-not-allowed bg-gray-700 text-gray-500'\n              }`,\n            },\n            'Build Ship'\n          )\n        )\n      )\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/hangar/ShipHangar.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/radar/RadarModule.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/trading/TradingHub.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/mothership/MothershipCore.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/combat/BattleEnvironment.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/combat/BattleView.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/combat/CombatDashboard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/combat/CombatLayout.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/combat/CombatSystemDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/combat/FleetDetails.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/combat/SalvageSystem.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/combat/alerts/AlertSystemUI.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/combat/formations/FormationEditor.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/combat/formations/FormationPresetList.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/combat/formations/FormationTacticsContainer.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/combat/formations/FormationTacticsPage.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/combat/formations/FormationTacticsPanel.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/combat/formations/FormationVisualizer.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/combat/formations/TacticalBehaviorSelector.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/combat/formations/TacticalBonusCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/combat/radar/DetectionVisualization.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/combat/radar/RadarSweepAnimation.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/combat/radar/RangeIndicators.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/core/IntegrationErrorHandler.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/core/SystemIntegration.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'ModuleEventType' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 39,
        "column": 6,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 39,
        "endColumn": 21
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { ReactNode, useCallback, useEffect, useRef, useState } from 'react';\nimport { GameActionType, useGameDispatch } from '../../contexts/GameContext';\nimport { ModuleActionType, useModuleContext } from '../../contexts/ModuleContext';\nimport { moduleEventBus } from '../../lib/modules/ModuleEvents';\nimport { GameLoopManager, UpdatePriority } from '../../managers/game/GameLoopManager';\nimport { ResourceManager } from '../../managers/game/ResourceManager';\nimport { moduleManager } from '../../managers/module/ModuleManager';\nimport { ModuleType } from '../../types/buildings/ModuleTypes';\nimport { BaseEvent, EventType } from '../../types/events/EventTypes';\nimport { Module } from '../../types/modules/ModuleTypes';\nimport { ResourceType } from \"./../../types/resources/ResourceTypes\";\n\ninterface SystemIntegrationProps {\n  children: ReactNode;\n  resourceManager: ResourceManager;\n  gameLoopManager?: GameLoopManager;\n  updateInterval?: number;\n}\n\n// Types of resource events to listen for\nconst RESOURCE_EVENT_TYPES = [\n  EventType.RESOURCE_PRODUCED,\n  EventType.RESOURCE_CONSUMED,\n  EventType.RESOURCE_TRANSFERRED,\n  EventType.RESOURCE_SHORTAGE,\n  EventType.RESOURCE_PRODUCTION_REGISTERED,\n  EventType.RESOURCE_CONSUMPTION_REGISTERED,\n];\n\n// Types of module events to listen for\nconst MODULE_EVENT_TYPES = [\n  'MODULE_CREATED',\n  'MODULE_UPDATED',\n  'STATUS_CHANGED',\n  'MODULE_ACTIVATED',\n  'MODULE_DEACTIVATED',\n] as const;\n\ntype ModuleEventType = (typeof MODULE_EVENT_TYPES)[number];\n\n/**\n * SystemIntegration component\n *\n * This component serves as a bridge between the frontend React contexts and\n * the backend manager classes. It synchronizes state between them and ensures\n * that updates from managers are propagated to the UI.\n */\nexport function SystemIntegration({\n  children,\n  resourceManager,\n  gameLoopManager,\n  updateInterval = 1000,\n}: SystemIntegrationProps) {\n  const gameDispatch = useGameDispatch();\n  const { dispatch: moduleDispatch } = useModuleContext();\n\n  const lastResourceState = useRef<Record<string, number>>({});\n  const intervalRef = useRef<NodeJS.Timeout | null>(null);\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n\n  // Initialize managers\n  useEffect(() => {\n    const initializeManagers = async () => {\n      try {\n        // Initialize the resource manager\n        await resourceManager.initialize();\n\n        // Connect resource manager to game loop if provided\n        if (gameLoopManager) {\n          gameLoopManager.registerUpdate(\n            resourceManager.id,\n            deltaTime => resourceManager.update(deltaTime),\n            UpdatePriority.NORMAL\n          );\n        }\n\n        setIsInitialized(true);\n        console.warn('Managers initialized successfully');\n      } catch (err) {\n        console.error('Failed to initialize managers:', err);\n        setError(err instanceof Error ? err : new Error(String(err)));\n      }\n    };\n\n    initializeManagers();\n\n    // Cleanup on unmount\n    return () => {\n      if (gameLoopManager) {\n        gameLoopManager.unregisterUpdate(resourceManager.id);\n      }\n      resourceManager.dispose();\n    };\n  }, [resourceManager, gameLoopManager]);\n\n  // Sync resource state from ResourceManager to GameContext\n  const syncResourceState = useCallback(() => {\n    if (!gameDispatch) return;\n\n    // Get current resources from manager\n    const currentResources = resourceManager.getAllResources();\n    const lastResourceStateValue = lastResourceState.current;\n\n    // Check if resources have changed\n    const hasChanges =\n      !lastResourceStateValue ||\n      Object.entries(currentResources).some(\n        ([key, value]) => lastResourceStateValue[key] !== value\n      );\n\n    // Only update if there are changes\n    if (hasChanges) {\n      console.warn('Syncing resource state:', currentResources);\n\n      // Add resource rates to the update if we can calculate them\n      let resourceRates = {};\n\n      if (resourceManager.getAllResourceStates) {\n        const states = resourceManager.getAllResourceStates();\n\n        // Calculate rates from production and consumption\n        resourceRates = {\n          mineralRate:\n            (states[ResourceType.MINERALS]?.production || 0) -\n            (states[ResourceType.MINERALS]?.consumption || 0),\n          energyRate:\n            (states[ResourceType.ENERGY]?.production || 0) -\n            (states[ResourceType.ENERGY]?.consumption || 0),\n          populationRate:\n            (states[ResourceType.POPULATION]?.production || 0) -\n            (states[ResourceType.POPULATION]?.consumption || 0),\n          researchRate:\n            (states[ResourceType.RESEARCH]?.production || 0) -\n            (states[ResourceType.RESEARCH]?.consumption || 0),\n        };\n      }\n\n      // Update resources with the calculated values\n      gameDispatch({\n        type: GameActionType.UPDATE_RESOURCES,\n        payload: {\n          minerals: currentResources[ResourceType.MINERALS] || 0,\n          energy: currentResources[ResourceType.ENERGY] || 0,\n          population: currentResources[ResourceType.POPULATION] || 0,\n          research: currentResources[ResourceType.RESEARCH] || 0,\n          ...resourceRates, // Add rates if available\n        },\n      });\n\n      lastResourceState.current = { ...currentResources };\n    }\n  }, [gameDispatch, resourceManager]);\n\n  // Sync module state from ModuleManager to ModuleContext\n  const syncModuleState = useCallback(() => {\n    if (!moduleDispatch) return;\n\n    const moduleBuildings = moduleManager.getBuildings();\n    const modules = moduleManager.getActiveModules();\n\n    // Only update if there are modules available\n    if (modules.length > 0) {\n      moduleDispatch({\n        type: ModuleActionType.SET_ACTIVE_MODULES,\n        payload: { activeModuleIds: modules.map(m => m.id) },\n      });\n    }\n\n    // Update buildings if available\n    if (moduleBuildings.length > 0) {\n      // Register each building individually\n      moduleBuildings.forEach(building => {\n        // Convert building to Module type\n        const moduleData: Module = {\n          id: building.id,\n          name: building.id, // Use ID as name if not available\n          type: 'resource-manager' as ModuleType, // Default to resource-manager type\n          status: 'active', // Default to active\n          position: { x: 0, y: 0 }, // Default position\n          isActive: true, // Default to active\n          level: 1, // Default level\n        };\n\n        moduleDispatch({\n          type: ModuleActionType.ADD_MODULE,\n          payload: { module: moduleData },\n        });\n      });\n    }\n  }, [moduleDispatch]);\n\n  // Set up event listeners and sync intervals\n  useEffect(() => {\n    if (!isInitialized || !gameDispatch || !moduleDispatch) return;\n\n    const unsubscribes: Array<() => void> = [];\n\n    // Subscribe to resource events from the resource manager\n    RESOURCE_EVENT_TYPES.forEach(eventType => {\n      const unsubscribe = resourceManager.subscribeToEvent(eventType, (_event: BaseEvent) => {\n        syncResourceState();\n      });\n      unsubscribes.push(unsubscribe);\n    });\n\n    // Listen for module events\n    MODULE_EVENT_TYPES.forEach(eventType => {\n      const unsubscribe = moduleEventBus.subscribe(eventType, () => {\n        syncModuleState();\n      });\n      unsubscribes.push(unsubscribe);\n    });\n\n    // Only set up interval if we don't have a game loop manager\n    if (!gameLoopManager) {\n      // Set up interval for periodic updates\n      intervalRef.current = setInterval(() => {\n        syncResourceState();\n        syncModuleState();\n\n        // Manually call update on resource manager since we don't have a game loop\n        resourceManager.update(updateInterval);\n      }, updateInterval);\n    }\n\n    // Initial sync\n    syncResourceState();\n    syncModuleState();\n\n    // Cleanup\n    return () => {\n      if (intervalRef.current) {\n        clearInterval(intervalRef.current);\n      }\n      unsubscribes.forEach(unsubscribe => unsubscribe());\n    };\n  }, [\n    syncResourceState,\n    syncModuleState,\n    updateInterval,\n    isInitialized,\n    resourceManager,\n    gameLoopManager,\n    gameDispatch,\n    moduleDispatch,\n  ]);\n\n  // Show loading state while initializing\n  if (!isInitialized) {\n    return (\n      <div className=\"flex h-20 items-center justify-center rounded bg-gray-100 p-4 shadow-sm\">\n        <span className=\"text-gray-700\">Initializing game systems...</span>\n      </div>\n    );\n  }\n\n  // Show error state if initialization failed\n  if (error) {\n    return (\n      <div className=\"flex h-20 items-center justify-center rounded bg-red-100 p-4 shadow-sm\">\n        <span className=\"text-red-700\">Error initializing systems: {error.message}</span>\n      </div>\n    );\n  }\n\n  // Return children since this component doesn't render anything itself when initialized\n  return <>{children}</>;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/core/ThresholdIntegration.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/debug/AIDebugOverlay.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/debug/GameStateMonitor.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/AdvancedFilteringSystem.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/AnalysisConfigManager.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'onUpdateConfig' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 45,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 45,
        "endColumn": 17
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import AddIcon from '@mui/icons-material/Add';\nimport DeleteIcon from '@mui/icons-material/Delete';\nimport {\n  Button,\n  Dialog,\n  DialogActions,\n  DialogContent,\n  DialogTitle,\n  FormControl,\n  IconButton,\n  InputLabel,\n  List,\n  ListItem,\n  ListItemText,\n  MenuItem,\n  Select,\n  TextField,\n  Typography,\n} from '@mui/material';\nimport * as React from 'react';\nimport { useState } from 'react';\nimport {\n  AnalysisConfig,\n  AnalysisType,\n  Dataset,\n  VisualizationType,\n} from '../../types/exploration/DataAnalysisTypes';\n\ninterface AnalysisConfigManagerProps {\n  configs: AnalysisConfig[];\n  datasets: Dataset[];\n  selectedConfig: AnalysisConfig | null;\n  onSelectConfig: (config: AnalysisConfig) => void;\n  onCreateConfig: (config: Omit<AnalysisConfig, 'id' | 'createdAt' | 'updatedAt'>) => string;\n  onUpdateConfig: (id: string, updates: Partial<AnalysisConfig>) => void;\n  onDeleteConfig: (id: string) => void;\n}\n\nconst AnalysisConfigManager: React.FC<AnalysisConfigManagerProps> = ({\n  configs,\n  datasets,\n  selectedConfig,\n  onSelectConfig,\n  onCreateConfig,\n  onUpdateConfig,\n  onDeleteConfig,\n}) => {\n  const [openDialog, setOpenDialog] = useState(false);\n  const [newConfigName, setNewConfigName] = useState('');\n  const [newConfigDescription, setNewConfigDescription] = useState('');\n  const [newConfigType, setNewConfigType] = useState<AnalysisType>('trend');\n  const [newConfigDatasetId, setNewConfigDatasetId] = useState('');\n  const [newVisualizationType, setNewVisualizationType] = useState<VisualizationType>('lineChart');\n\n  const handleCreateConfig = () => {\n    if (!newConfigName.trim() || !newConfigDatasetId) return;\n\n    // Generate default parameters based on analysis type\n    const parameters = generateDefaultParameters(newConfigType);\n\n    // Generate default visualization config\n    const visualizationConfig = generateDefaultVisualizationConfig(newVisualizationType);\n\n    onCreateConfig({\n      name: newConfigName,\n      description: newConfigDescription,\n      type: newConfigType,\n      datasetId: newConfigDatasetId,\n      parameters,\n      visualizationType: newVisualizationType,\n      visualizationConfig,\n    });\n\n    setNewConfigName('');\n    setNewConfigDescription('');\n    setNewConfigType('trend');\n    setNewConfigDatasetId('');\n    setNewVisualizationType('lineChart');\n    setOpenDialog(false);\n  };\n\n  // Generate default parameters based on analysis type\n  const generateDefaultParameters = (type: AnalysisType): Record<string, unknown> => {\n    switch (type) {\n      case 'trend':\n        return {\n          xAxis: 'date',\n          yAxis: 'value',\n          groupBy: 'type',\n          timeRange: [Date.now() - 30 * 86400000, Date.now()], // Last 30 days\n          aggregation: 'average',\n        };\n      case 'correlation':\n        return {\n          variables: ['resourcePotential', 'habitabilityScore', 'anomalyCount'],\n          method: 'pearson',\n          threshold: 0.5,\n        };\n      case 'distribution':\n        return {\n          variable: 'resourcePotential',\n          bins: 10,\n          normalize: true,\n        };\n      case 'clustering':\n        return {\n          variables: ['resourcePotential', 'habitabilityScore'],\n          clusters: 3,\n          method: 'kmeans',\n        };\n      case 'prediction':\n        return {\n          target: 'resourcePotential',\n          features: ['habitabilityScore', 'anomalyCount'],\n          method: 'linear',\n          testSize: 0.2,\n        };\n      default:\n        return {};\n    }\n  };\n\n  // Generate default visualization config based on visualization type\n  const generateDefaultVisualizationConfig = (type: VisualizationType): Record<string, unknown> => {\n    switch (type) {\n      case 'lineChart':\n        return {\n          xAxisLabel: 'Date',\n          yAxisLabel: 'Value',\n          showLegend: true,\n          showGrid: true,\n          colors: ['#4299E1', '#48BB78', '#F6AD55', '#F56565'],\n        };\n      case 'barChart':\n        return {\n          xAxisLabel: 'Category',\n          yAxisLabel: 'Value',\n          showLegend: true,\n          showGrid: true,\n          colors: ['#4299E1', '#48BB78', '#F6AD55', '#F56565'],\n          barSize: 20,\n        };\n      case 'scatterPlot':\n        return {\n          xAxisLabel: 'X',\n          yAxisLabel: 'Y',\n          showLegend: true,\n          showGrid: true,\n          colors: ['#4299E1', '#48BB78', '#F6AD55', '#F56565'],\n          pointSize: 5,\n        };\n      case 'pieChart':\n        return {\n          showLegend: true,\n          colors: ['#4299E1', '#48BB78', '#F6AD55', '#F56565', '#9F7AEA', '#ED64A6'],\n          innerRadius: 0,\n          outerRadius: 80,\n        };\n      default:\n        return {};\n    }\n  };\n\n  return (\n    <div>\n      <Button\n        variant=\"outlined\"\n        startIcon={<AddIcon />}\n        onClick={() => setOpenDialog(true)}\n        sx={{ mb: 2 }}\n      >\n        Create Analysis Config\n      </Button>\n\n      {configs.length === 0 ? (\n        <Typography variant=\"body2\" color=\"text.secondary\" align=\"center\">\n          No analysis configurations available. Create one to get started.\n        </Typography>\n      ) : (\n        <List sx={{ maxHeight: 400, overflow: 'auto' }}>\n          {configs.map(config => (\n            <ListItem\n              key={config.id}\n              button\n              selected={selectedConfig?.id === config.id}\n              onClick={() => onSelectConfig(config)}\n              secondaryAction={\n                <IconButton\n                  edge=\"end\"\n                  aria-label=\"delete\"\n                  onClick={(e: React.MouseEvent) => {\n                    e.stopPropagation();\n                    onDeleteConfig(config.id);\n                  }}\n                >\n                  <DeleteIcon />\n                </IconButton>\n              }\n            >\n              <ListItemText\n                primary={config.name}\n                secondary={\n                  <>\n                    <Typography component=\"span\" variant=\"body2\" color=\"text.primary\">\n                      {config.type}\n                    </Typography>\n                    {` — ${datasets.find(d => d.id === config.datasetId)?.name || 'Unknown dataset'}`}\n                  </>\n                }\n              />\n            </ListItem>\n          ))}\n        </List>\n      )}\n\n      {/* Create Config Dialog */}\n      <Dialog open={openDialog} onClose={() => setOpenDialog(false)}>\n        <DialogTitle>Create New Analysis Configuration</DialogTitle>\n        <DialogContent>\n          <TextField\n            autoFocus\n            margin=\"dense\"\n            label=\"Configuration Name\"\n            fullWidth\n            value={newConfigName}\n            onChange={(e: React.ChangeEvent<HTMLInputElement>) => setNewConfigName(e.target.value)}\n          />\n          <TextField\n            margin=\"dense\"\n            label=\"Description\"\n            fullWidth\n            value={newConfigDescription}\n            onChange={(e: React.ChangeEvent<HTMLInputElement>) =>\n              setNewConfigDescription(e.target.value)\n            }\n          />\n          <FormControl fullWidth margin=\"dense\">\n            <InputLabel>Dataset</InputLabel>\n            <Select\n              value={newConfigDatasetId}\n              label=\"Dataset\"\n              onChange={e => setNewConfigDatasetId(e.target.value as string)}\n            >\n              <MenuItem value=\"\">\n                <em>Select a dataset</em>\n              </MenuItem>\n              {datasets.map(dataset => (\n                <MenuItem key={dataset.id} value={dataset.id}>\n                  {dataset.name} ({dataset.source}, {dataset.dataPoints.length} points)\n                </MenuItem>\n              ))}\n            </Select>\n          </FormControl>\n          <FormControl fullWidth margin=\"dense\">\n            <InputLabel>Analysis Type</InputLabel>\n            <Select\n              value={newConfigType}\n              label=\"Analysis Type\"\n              onChange={e => setNewConfigType(e.target.value as AnalysisType)}\n            >\n              <MenuItem value=\"trend\">Trend Analysis</MenuItem>\n              <MenuItem value=\"correlation\">Correlation Analysis</MenuItem>\n              <MenuItem value=\"distribution\">Distribution Analysis</MenuItem>\n              <MenuItem value=\"clustering\">Clustering Analysis</MenuItem>\n              <MenuItem value=\"prediction\">Prediction Analysis</MenuItem>\n              <MenuItem value=\"comparison\">Comparison Analysis</MenuItem>\n              <MenuItem value=\"anomalyDetection\">Anomaly Detection</MenuItem>\n              <MenuItem value=\"resourceMapping\">Resource Mapping</MenuItem>\n              <MenuItem value=\"sectorAnalysis\">Sector Analysis</MenuItem>\n            </Select>\n          </FormControl>\n          <FormControl fullWidth margin=\"dense\">\n            <InputLabel>Visualization Type</InputLabel>\n            <Select\n              value={newVisualizationType}\n              label=\"Visualization Type\"\n              onChange={e => setNewVisualizationType(e.target.value as VisualizationType)}\n            >\n              <MenuItem value=\"lineChart\">Line Chart</MenuItem>\n              <MenuItem value=\"barChart\">Bar Chart</MenuItem>\n              <MenuItem value=\"scatterPlot\">Scatter Plot</MenuItem>\n              <MenuItem value=\"pieChart\">Pie Chart</MenuItem>\n              <MenuItem value=\"heatMap\">Heat Map</MenuItem>\n              <MenuItem value=\"radar\">Radar Chart</MenuItem>\n              <MenuItem value=\"histogram\">Histogram</MenuItem>\n              <MenuItem value=\"boxPlot\">Box Plot</MenuItem>\n              <MenuItem value=\"table\">Table</MenuItem>\n              <MenuItem value=\"map\">Map</MenuItem>\n              <MenuItem value=\"network\">Network Graph</MenuItem>\n            </Select>\n          </FormControl>\n        </DialogContent>\n        <DialogActions>\n          <Button onClick={() => setOpenDialog(false)}>Cancel</Button>\n          <Button\n            onClick={handleCreateConfig}\n            disabled={!newConfigName.trim() || !newConfigDatasetId}\n          >\n            Create\n          </Button>\n        </DialogActions>\n      </Dialog>\n    </div>\n  );\n};\n\nexport default AnalysisConfigManager;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/AnomalyAnalysis.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/AutomatedSectorScanner.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/CanvasChartExample.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/DataAnalysisSystem.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/DataFilterPanel.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/DataPointVirtualList.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/DatasetManager.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'onUpdateDataset' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 38,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 38,
        "endColumn": 18
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import AddIcon from '@mui/icons-material/Add';\nimport DeleteIcon from '@mui/icons-material/Delete';\nimport {\n  Button,\n  Dialog,\n  DialogActions,\n  DialogContent,\n  DialogTitle,\n  FormControl,\n  IconButton,\n  InputLabel,\n  List,\n  ListItem,\n  ListItemText,\n  MenuItem,\n  Select,\n  TextField,\n  Typography,\n} from '@mui/material';\nimport * as React from \"react\";\nimport { useState } from 'react';\nimport { Dataset } from '../../types/exploration/DataAnalysisTypes';\n\ninterface DatasetManagerProps {\n  datasets: Dataset[];\n  selectedDataset: Dataset | null;\n  onSelectDataset: (dataset: Dataset) => void;\n  onCreateDataset: (dataset: Omit<Dataset, 'id' | 'createdAt' | 'updatedAt'>) => string;\n  onUpdateDataset: (id: string, updates: Partial<Dataset>) => void;\n  onDeleteDataset: (id: string) => void;\n}\n\nconst DatasetManager: React.FC<DatasetManagerProps> = ({\n  datasets,\n  selectedDataset,\n  onSelectDataset,\n  onCreateDataset,\n  onUpdateDataset,\n  onDeleteDataset,\n}) => {\n  const [openDialog, setOpenDialog] = useState(false);\n  const [newDatasetName, setNewDatasetName] = useState('');\n  const [newDatasetDescription, setNewDatasetDescription] = useState('');\n  const [newDatasetSource, setNewDatasetSource] = useState<\n    'sectors' | 'anomalies' | 'resources' | 'mixed'\n  >('sectors');\n\n  const handleCreateDataset = () => {\n    if (!newDatasetName.trim()) return;\n\n    onCreateDataset({\n      name: newDatasetName,\n      description: newDatasetDescription,\n      dataPoints: [],\n      source: newDatasetSource,\n    });\n\n    setNewDatasetName('');\n    setNewDatasetDescription('');\n    setNewDatasetSource('sectors');\n    setOpenDialog(false);\n  };\n\n  return (\n    <div>\n      <Button\n        variant=\"outlined\"\n        startIcon={<AddIcon />}\n        onClick={() => setOpenDialog(true)}\n        sx={{ mb: 2 }}\n      >\n        Create Dataset\n      </Button>\n\n      {datasets.length === 0 ? (\n        <Typography variant=\"body2\" color=\"text.secondary\" align=\"center\">\n          No datasets available. Create one to get started.\n        </Typography>\n      ) : (\n        <List sx={{ maxHeight: 400, overflow: 'auto' }}>\n          {datasets.map(dataset => (\n            <ListItem\n              key={dataset.id}\n              button\n              selected={selectedDataset?.id === dataset.id}\n              onClick={() => onSelectDataset(dataset)}\n              secondaryAction={\n                <IconButton\n                  edge=\"end\"\n                  aria-label=\"delete\"\n                  onClick={e => {\n                    e.stopPropagation();\n                    onDeleteDataset(dataset.id);\n                  }}\n                >\n                  <DeleteIcon />\n                </IconButton>\n              }\n            >\n              <ListItemText\n                primary={dataset.name}\n                secondary={\n                  <>\n                    <Typography component=\"span\" variant=\"body2\" color=\"text.primary\">\n                      {dataset.source}\n                    </Typography>\n                    {` — ${dataset.dataPoints.length} data points`}\n                  </>\n                }\n              />\n            </ListItem>\n          ))}\n        </List>\n      )}\n\n      {/* Create Dataset Dialog */}\n      <Dialog open={openDialog} onClose={() => setOpenDialog(false)}>\n        <DialogTitle>Create New Dataset</DialogTitle>\n        <DialogContent>\n          <TextField\n            autoFocus\n            margin=\"dense\"\n            label=\"Dataset Name\"\n            fullWidth\n            value={newDatasetName}\n            onChange={e => setNewDatasetName(e.target.value)}\n          />\n          <TextField\n            margin=\"dense\"\n            label=\"Description\"\n            fullWidth\n            value={newDatasetDescription}\n            onChange={e => setNewDatasetDescription(e.target.value)}\n          />\n          <FormControl fullWidth margin=\"dense\">\n            <InputLabel>Source</InputLabel>\n            <Select\n              value={newDatasetSource}\n              label=\"Source\"\n              onChange={e =>\n                setNewDatasetSource(\n                  e.target.value as 'sectors' | 'anomalies' | 'resources' | 'mixed'\n                )\n              }\n            >\n              <MenuItem value=\"sectors\">Sectors</MenuItem>\n              <MenuItem value=\"anomalies\">Anomalies</MenuItem>\n              <MenuItem value=\"resources\">Resources</MenuItem>\n              <MenuItem value=\"mixed\">Mixed</MenuItem>\n            </Select>\n          </FormControl>\n        </DialogContent>\n        <DialogActions>\n          <Button onClick={() => setOpenDialog(false)}>Cancel</Button>\n          <Button onClick={handleCreateDataset} disabled={!newDatasetName.trim()}>\n            Create\n          </Button>\n        </DialogActions>\n      </Dialog>\n    </div>\n  );\n};\n\nexport default DatasetManager;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/DetailedAnomalyAnalysis.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/DiscoveryClassification.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'ResourceType' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 1,
        "column": 10,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 1,
        "endColumn": 22
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { ResourceType } from \"./../../types/resources/ResourceTypes\";\nimport {\n  AlertTriangle,\n  Brain,\n  Check,\n  ChevronDown,\n  ChevronUp,\n  Database,\n  FolderTree,\n  Search,\n  X,\n} from 'lucide-react';\nimport * as React from \"react\";\nimport { useEffect, useMemo, useState } from 'react';\nimport { useClassification } from '../../contexts/ClassificationContext';\nimport {\n  ClassifiableDiscovery,\n  Classification,\n  ClassificationSuggestion,\n  ConfidenceLevel,\n} from '../../types/exploration/ClassificationTypes';\n\ninterface DiscoveryClassificationProps {\n  discovery: ClassifiableDiscovery;\n  onClassify?: (classification: Classification) => void;\n  className?: string;\n  compact?: boolean;\n}\n\nexport function DiscoveryClassification({\n  discovery,\n  onClassify,\n  className = '',\n  compact = false,\n}: DiscoveryClassificationProps) {\n  const {\n    taxonomyCategories,\n    addClassification,\n    getClassificationsForDiscovery,\n    getTaxonomyCategory,\n    generateClassificationSuggestions,\n    getSimilarDiscoveries,\n  } = useClassification();\n\n  // State for the classification form\n  const [selectedCategoryId, setSelectedCategoryId] = useState<string>('');\n  const [confidence, setConfidence] = useState<number>(0.7);\n  const [notes, setNotes] = useState<string>('');\n  const [propertyValues, setPropertyValues] = useState<\n    Record<string, string | number | boolean | string[]>\n  >({});\n\n  // State for UI\n  const [showSuggestions, setShowSuggestions] = useState<boolean>(true);\n  const [_showSimilarDiscoveries, _setShowSimilarDiscoveries] = useState<boolean>(false);\n  const [showTaxonomyBrowser, setShowTaxonomyBrowser] = useState<boolean>(false);\n  const [searchQuery, setSearchQuery] = useState<string>('');\n  const [activeTab, setActiveTab] = useState<'classify' | 'history' | 'similar'>('classify');\n  const [isProcessing, setIsProcessing] = useState<boolean>(false);\n\n  // Get existing classifications for this discovery\n  const existingClassifications = useMemo(\n    () => getClassificationsForDiscovery(discovery.id),\n    [getClassificationsForDiscovery, discovery.id]\n  );\n\n  // Generate AI suggestions\n  const [suggestions, setSuggestions] = useState<ClassificationSuggestion[]>([]);\n\n  useEffect(() => {\n    // Generate suggestions when the component mounts\n    setSuggestions(generateClassificationSuggestions(discovery));\n  }, [discovery, generateClassificationSuggestions]);\n\n  // Get similar discoveries\n  const similarDiscoveries = useMemo(\n    () => getSimilarDiscoveries(discovery.id),\n    [getSimilarDiscoveries, discovery.id]\n  );\n\n  // Get properties for the selected category\n  const selectedCategoryProperties = useMemo(() => {\n    const category = getTaxonomyCategory(selectedCategoryId);\n    return category?.properties || [];\n  }, [getTaxonomyCategory, selectedCategoryId]);\n\n  // Handle property value changes\n  const handlePropertyChange = (\n    propertyId: string,\n    value: string | number | boolean | string[]\n  ) => {\n    setPropertyValues(prev => ({\n      ...prev,\n      [propertyId]: value,\n    }));\n  };\n\n  // Handle form submission\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n\n    // Simulate processing\n    setIsProcessing(true);\n\n    setTimeout(() => {\n      // Create the classification object\n      const newClassification: Omit<Classification, 'id'> = {\n        discoveryId: discovery.id,\n        discoveryType: discovery.type,\n        categoryId: selectedCategoryId,\n        confidence,\n        confidenceLevel: getConfidenceLevelFromScore(confidence),\n        properties: propertyValues,\n        notes,\n        classifiedBy: 'user',\n        classifiedDate: Date.now(),\n        previousClassifications: existingClassifications.map(c => c.id),\n      };\n\n      // Add the classification\n      addClassification(newClassification);\n\n      // Call the onClassify callback if provided\n      if (onClassify) {\n        onClassify({\n          ...newClassification,\n          id: 'temp-id', // This will be replaced by the actual ID in the context\n        });\n      }\n\n      // Reset the form\n      setSelectedCategoryId('');\n      setConfidence(0.7);\n      setNotes('');\n      setPropertyValues({});\n      setIsProcessing(false);\n    }, 1000);\n  };\n\n  // Apply a suggestion\n  const applySuggestion = (suggestion: ClassificationSuggestion) => {\n    setSelectedCategoryId(suggestion.categoryId);\n    setConfidence(suggestion.confidence);\n    setPropertyValues(suggestion.propertyValues);\n  };\n\n  // Helper function to get confidence level from score\n  const getConfidenceLevelFromScore = (score: number): ConfidenceLevel => {\n    if (score >= 0.9) {\n      return 'confirmed';\n    }\n    if (score >= 0.7) {\n      return 'high';\n    }\n    if (score >= 0.4) {\n      return 'medium';\n    }\n    return 'low';\n  };\n\n  // Helper function to get color for confidence level\n  const getConfidenceColor = (level: ConfidenceLevel): string => {\n    switch (level) {\n      case 'confirmed':\n        return 'text-green-500';\n      case 'high':\n        return 'text-blue-500';\n      case 'medium':\n        return 'text-yellow-500';\n      case 'low':\n        return 'text-red-500';\n      default:\n        return 'text-gray-500';\n    }\n  };\n\n  // Render the category hierarchy\n  const renderCategoryHierarchy = (categoryId: string, level = 0) => {\n    const category = getTaxonomyCategory(categoryId);\n    if (!category) {\n      return null;\n    }\n\n    // Find child categories\n    const children = taxonomyCategories.filter(c => c.parentId === categoryId);\n\n    return (\n      <div key={categoryId} className=\"mb-1\">\n        <div\n          className={`flex cursor-pointer items-center rounded p-2 ${\n            selectedCategoryId === categoryId\n              ? 'bg-blue-100 dark:bg-blue-900'\n              : 'hover:bg-gray-100 dark:hover:bg-gray-800'\n          }`}\n          style={{ marginLeft: `${level * 16}px` }}\n          onClick={() => setSelectedCategoryId(categoryId)}\n        >\n          <div\n            className=\"mr-2 h-3 w-3 rounded-full\"\n            style={{ backgroundColor: category.color || '#6b7280' }}\n          ></div>\n          <span>{category.name}</span>\n        </div>\n        {children.map(child => renderCategoryHierarchy(child.id, level + 1))}\n      </div>\n    );\n  };\n\n  // Render the compact version\n  if (compact) {\n    return (\n      <div className={`rounded-lg border p-4 shadow-sm ${className}`}>\n        <h3 className=\"mb-2 text-lg font-semibold\">Classification</h3>\n\n        {existingClassifications.length > 0 ? (\n          <div>\n            {existingClassifications.map(classification => {\n              const category = getTaxonomyCategory(classification.categoryId);\n              return (\n                <div\n                  key={classification.id}\n                  className=\"mb-2 rounded bg-gray-50 p-2 dark:bg-gray-800\"\n                >\n                  <div className=\"flex items-center\">\n                    <div\n                      className=\"mr-2 h-3 w-3 rounded-full\"\n                      style={{ backgroundColor: category?.color || '#6b7280' }}\n                    ></div>\n                    <span className=\"font-medium\">{category?.name || 'Unknown Category'}</span>\n                    <span\n                      className={`ml-2 text-xs ${getConfidenceColor(classification.confidenceLevel)}`}\n                    >\n                      {classification.confidenceLevel}\n                    </span>\n                  </div>\n                </div>\n              );\n            })}\n          </div>\n        ) : (\n          <div className=\"text-sm text-gray-500 dark:text-gray-400\">\n            No classifications yet. Click to classify.\n          </div>\n        )}\n      </div>\n    );\n  }\n\n  // Render the full version\n  return (\n    <div className={`rounded-lg border shadow-sm ${className}`}>\n      {/* Header */}\n      <div className=\"border-b p-4\">\n        <h2 className=\"text-xl font-semibold\">Discovery Classification</h2>\n        <div className=\"mt-1 text-sm text-gray-500 dark:text-gray-400\">\n          Classify and categorize discoveries for better organization and analysis\n        </div>\n      </div>\n\n      {/* Tabs */}\n      <div className=\"flex border-b\">\n        <button\n          className={`px-4 py-2 font-medium ${\n            activeTab === 'classify'\n              ? 'border-b-2 border-blue-500 text-blue-600'\n              : 'text-gray-600 hover:text-gray-800'\n          }`}\n          onClick={() => setActiveTab('classify')}\n        >\n          Classify\n        </button>\n        <button\n          className={`px-4 py-2 font-medium ${\n            activeTab === 'history'\n              ? 'border-b-2 border-blue-500 text-blue-600'\n              : 'text-gray-600 hover:text-gray-800'\n          }`}\n          onClick={() => setActiveTab('history')}\n        >\n          History ({existingClassifications.length})\n        </button>\n        <button\n          className={`px-4 py-2 font-medium ${\n            activeTab === 'similar'\n              ? 'border-b-2 border-blue-500 text-blue-600'\n              : 'text-gray-600 hover:text-gray-800'\n          }`}\n          onClick={() => setActiveTab('similar')}\n        >\n          Similar ({similarDiscoveries.length})\n        </button>\n      </div>\n\n      {/* Content */}\n      <div className=\"p-4\">\n        {activeTab === 'classify' && (\n          <div>\n            {/* Discovery Info */}\n            <div className=\"mb-4 rounded-lg bg-gray-50 p-3 dark:bg-gray-800\">\n              <div className=\"mb-2 flex items-center\">\n                <div className=\"mr-2\">\n                  {discovery.type === 'anomaly' ? (\n                    <AlertTriangle className=\"text-yellow-500\" size={20} />\n                  ) : (\n                    <Database className=\"text-blue-500\" size={20} />\n                  )}\n                </div>\n                <h3 className=\"text-lg font-medium\">{discovery.name}</h3>\n              </div>\n              <div className=\"text-sm text-gray-600 dark:text-gray-300\">\n                <div>\n                  Type:{' '}\n                  {discovery.type === 'anomaly'\n                    ? `Anomaly (${discovery.anomalyType})`\n                    : `Resource (${discovery.resourceType})`}\n                </div>\n                <div>Sector: {discovery.sectorName}</div>\n                <div>Discovered: {new Date(discovery.discoveryDate).toLocaleDateString()}</div>\n              </div>\n            </div>\n\n            {/* AI Suggestions */}\n            <div className=\"mb-4\">\n              <div\n                className=\"flex cursor-pointer items-center justify-between rounded-t-lg bg-blue-50 p-2 dark:bg-blue-900\"\n                onClick={() => setShowSuggestions(!showSuggestions)}\n              >\n                <div className=\"flex items-center\">\n                  <Brain size={18} className=\"mr-2 text-blue-600 dark:text-blue-400\" />\n                  <span className=\"font-medium\">AI Classification Suggestions</span>\n                </div>\n                {showSuggestions ? <ChevronUp size={18} /> : <ChevronDown size={18} />}\n              </div>\n\n              {showSuggestions && (\n                <div className=\"rounded-b-lg border border-t-0 p-3\">\n                  {suggestions.length > 0 ? (\n                    <div>\n                      {suggestions.map((suggestion, index) => {\n                        const category = getTaxonomyCategory(suggestion.categoryId);\n                        const confidenceLevel = getConfidenceLevelFromScore(suggestion.confidence);\n\n                        return (\n                          <div\n                            key={index}\n                            className=\"mb-2 cursor-pointer rounded border p-2 hover:bg-gray-50 dark:hover:bg-gray-800\"\n                            onClick={() => applySuggestion(suggestion)}\n                          >\n                            <div className=\"flex items-center justify-between\">\n                              <div className=\"flex items-center\">\n                                <div\n                                  className=\"mr-2 h-3 w-3 rounded-full\"\n                                  style={{ backgroundColor: category?.color || '#6b7280' }}\n                                ></div>\n                                <span className=\"font-medium\">\n                                  {category?.name || 'Unknown Category'}\n                                </span>\n                              </div>\n                              <span className={`text-sm ${getConfidenceColor(confidenceLevel)}`}>\n                                {Math.round(suggestion.confidence * 100)}% confidence\n                              </span>\n                            </div>\n                            <div className=\"mt-1 text-sm text-gray-600 dark:text-gray-400\">\n                              {suggestion.reasoning}\n                            </div>\n                          </div>\n                        );\n                      })}\n                    </div>\n                  ) : (\n                    <div className=\"text-sm text-gray-500 dark:text-gray-400\">\n                      No suggestions available. Try providing more information about the discovery.\n                    </div>\n                  )}\n                </div>\n              )}\n            </div>\n\n            {/* Classification Form */}\n            <form onSubmit={handleSubmit}>\n              {/* Taxonomy Browser */}\n              <div className=\"mb-4\">\n                <div\n                  className=\"flex cursor-pointer items-center justify-between rounded-t-lg bg-gray-100 p-2 dark:bg-gray-700\"\n                  onClick={() => setShowTaxonomyBrowser(!showTaxonomyBrowser)}\n                >\n                  <div className=\"flex items-center\">\n                    <FolderTree size={18} className=\"mr-2\" />\n                    <span className=\"font-medium\">Taxonomy Browser</span>\n                  </div>\n                  {showTaxonomyBrowser ? <ChevronUp size={18} /> : <ChevronDown size={18} />}\n                </div>\n\n                {showTaxonomyBrowser && (\n                  <div className=\"rounded-b-lg border border-t-0 p-3\">\n                    <div className=\"mb-3\">\n                      <div className=\"relative\">\n                        <Search\n                          className=\"absolute left-3 top-1/2 -translate-y-1/2 transform text-gray-400\"\n                          size={16}\n                        />\n                        <input\n                          type=\"text\"\n                          placeholder=\"Search categories...\"\n                          className=\"w-full rounded border py-2 pl-10 pr-4\"\n                          value={searchQuery}\n                          onChange={e => setSearchQuery(e.target.value)}\n                        />\n                      </div>\n                    </div>\n\n                    <div className=\"max-h-60 overflow-y-auto\">\n                      {discovery.type === 'anomaly'\n                        ? renderCategoryHierarchy('anomaly-root')\n                        : renderCategoryHierarchy('resource-root')}\n                    </div>\n                  </div>\n                )}\n              </div>\n\n              {/* Selected Category */}\n              <div className=\"mb-4\">\n                <label className=\"mb-1 block text-sm font-medium\">Selected Category</label>\n                {selectedCategoryId ? (\n                  <div className=\"flex items-center rounded border p-2\">\n                    <div\n                      className=\"mr-2 h-3 w-3 rounded-full\"\n                      style={{\n                        backgroundColor:\n                          getTaxonomyCategory(selectedCategoryId)?.color || '#6b7280',\n                      }}\n                    ></div>\n                    <span>\n                      {getTaxonomyCategory(selectedCategoryId)?.name || 'Unknown Category'}\n                    </span>\n                    <button\n                      type=\"button\"\n                      className=\"ml-auto text-gray-400 hover:text-gray-600\"\n                      onClick={() => setSelectedCategoryId('')}\n                    >\n                      <X size={16} />\n                    </button>\n                  </div>\n                ) : (\n                  <div className=\"rounded border p-2 text-gray-500 dark:text-gray-400\">\n                    No category selected. Use the taxonomy browser or AI suggestions to select a\n                    category.\n                  </div>\n                )}\n              </div>\n\n              {/* Confidence Slider */}\n              <div className=\"mb-4\">\n                <label className=\"mb-1 block text-sm font-medium\">\n                  Classification Confidence: {Math.round(confidence * 100)}%\n                </label>\n                <input\n                  type=\"range\"\n                  min=\"0\"\n                  max=\"1\"\n                  step=\"0.01\"\n                  value={confidence}\n                  onChange={e => setConfidence(parseFloat(e.target.value))}\n                  className=\"w-full\"\n                />\n                <div className=\"flex justify-between text-xs text-gray-500\">\n                  <span>Low</span>\n                  <span>Medium</span>\n                  <span>High</span>\n                  <span>Confirmed</span>\n                </div>\n              </div>\n\n              {/* Category Properties */}\n              {selectedCategoryProperties.length > 0 && (\n                <div className=\"mb-4\">\n                  <h4 className=\"mb-2 text-sm font-medium\">Category Properties</h4>\n                  {selectedCategoryProperties.map(property => (\n                    <div key={property.id} className=\"mb-3\">\n                      <label className=\"mb-1 block text-sm font-medium\">\n                        {property.name}\n                        {property.required && <span className=\"ml-1 text-red-500\">*</span>}\n                      </label>\n                      {property.type === 'string' && (\n                        <input\n                          type=\"text\"\n                          className=\"w-full rounded border p-2\"\n                          value={(propertyValues[property.id] as string) || ''}\n                          onChange={e => handlePropertyChange(property.id, e.target.value)}\n                          required={property.required}\n                        />\n                      )}\n                      {property.type === 'number' && (\n                        <input\n                          type=\"number\"\n                          className=\"w-full rounded border p-2\"\n                          value={(propertyValues[property.id] as number) || ''}\n                          onChange={e =>\n                            handlePropertyChange(property.id, parseFloat(e.target.value))\n                          }\n                          required={property.required}\n                        />\n                      )}\n                      {property.type === 'boolean' && (\n                        <div className=\"flex items-center\">\n                          <input\n                            type=\"checkbox\"\n                            className=\"mr-2\"\n                            checked={(propertyValues[property.id] as boolean) || false}\n                            onChange={e => handlePropertyChange(property.id, e.target.checked)}\n                            required={property.required}\n                          />\n                          <span className=\"text-sm\">Yes</span>\n                        </div>\n                      )}\n                      {property.type === 'enum' && property.options && (\n                        <select\n                          className=\"w-full rounded border p-2\"\n                          value={(propertyValues[property.id] as string) || ''}\n                          onChange={e => handlePropertyChange(property.id, e.target.value)}\n                          required={property.required}\n                        >\n                          <option value=\"\">Select an option</option>\n                          {property.options.map(option => (\n                            <option key={option} value={option}>\n                              {option}\n                            </option>\n                          ))}\n                        </select>\n                      )}\n                      {property.description && (\n                        <div className=\"mt-1 text-xs text-gray-500\">{property.description}</div>\n                      )}\n                    </div>\n                  ))}\n                </div>\n              )}\n\n              {/* Notes */}\n              <div className=\"mb-4\">\n                <label className=\"mb-1 block text-sm font-medium\">Notes</label>\n                <textarea\n                  className=\"w-full rounded border p-2\"\n                  rows={3}\n                  value={notes}\n                  onChange={e => setNotes(e.target.value)}\n                  placeholder=\"Add any additional notes about this classification...\"\n                />\n              </div>\n\n              {/* Submit Button */}\n              <div className=\"flex justify-end\">\n                <button\n                  type=\"submit\"\n                  className=\"flex items-center rounded bg-blue-600 px-4 py-2 text-white hover:bg-blue-700\"\n                  disabled={!selectedCategoryId || isProcessing}\n                >\n                  {isProcessing ? (\n                    <>\n                      <div className=\"mr-2 animate-spin\">\n                        <div className=\"h-4 w-4 rounded-full border-2 border-white border-t-transparent\"></div>\n                      </div>\n                      Processing...\n                    </>\n                  ) : (\n                    <>\n                      <Check size={18} className=\"mr-2\" />\n                      Classify Discovery\n                    </>\n                  )}\n                </button>\n              </div>\n            </form>\n          </div>\n        )}\n\n        {activeTab === 'history' && (\n          <div>\n            <h3 className=\"mb-3 text-lg font-medium\">Classification History</h3>\n\n            {existingClassifications.length > 0 ? (\n              <div>\n                {existingClassifications.map(classification => {\n                  const category = getTaxonomyCategory(classification.categoryId);\n\n                  return (\n                    <div key={classification.id} className=\"mb-3 rounded border p-3\">\n                      <div className=\"flex items-center justify-between\">\n                        <div className=\"flex items-center\">\n                          <div\n                            className=\"mr-2 h-3 w-3 rounded-full\"\n                            style={{ backgroundColor: category?.color || '#6b7280' }}\n                          ></div>\n                          <span className=\"font-medium\">\n                            {category?.name || 'Unknown Category'}\n                          </span>\n                        </div>\n                        <span\n                          className={`text-sm ${getConfidenceColor(classification.confidenceLevel)}`}\n                        >\n                          {Math.round(classification.confidence * 100)}% confidence\n                        </span>\n                      </div>\n\n                      <div className=\"mt-2 text-sm text-gray-600 dark:text-gray-400\">\n                        Classified by: {classification.classifiedBy} on{' '}\n                        {new Date(classification.classifiedDate).toLocaleString()}\n                      </div>\n\n                      {Object.keys(classification.properties).length > 0 && (\n                        <div className=\"mt-2\">\n                          <h4 className=\"mb-1 text-sm font-medium\">Properties</h4>\n                          <div className=\"grid grid-cols-2 gap-2 text-sm\">\n                            {Object.entries(classification.properties).map(([key, value]) => (\n                              <div key={key}>\n                                <span className=\"font-medium\">{key}:</span> {String(value)}\n                              </div>\n                            ))}\n                          </div>\n                        </div>\n                      )}\n\n                      {classification.notes && (\n                        <div className=\"mt-2\">\n                          <h4 className=\"mb-1 text-sm font-medium\">Notes</h4>\n                          <div className=\"text-sm\">{classification.notes}</div>\n                        </div>\n                      )}\n                    </div>\n                  );\n                })}\n              </div>\n            ) : (\n              <div className=\"text-gray-500 dark:text-gray-400\">\n                No classification history available for this discovery.\n              </div>\n            )}\n          </div>\n        )}\n\n        {activeTab === 'similar' && (\n          <div>\n            <h3 className=\"mb-3 text-lg font-medium\">Similar Discoveries</h3>\n\n            {similarDiscoveries.length > 0 ? (\n              <div>\n                {similarDiscoveries.map(discovery => {\n                  const classification = discovery.classification;\n                  const category = classification\n                    ? getTaxonomyCategory(classification.categoryId)\n                    : null;\n\n                  return (\n                    <div key={discovery.id} className=\"mb-3 rounded border p-3\">\n                      <div className=\"mb-2 flex items-center\">\n                        <div className=\"mr-2\">\n                          {discovery.type === 'anomaly' ? (\n                            <AlertTriangle className=\"text-yellow-500\" size={18} />\n                          ) : (\n                            <Database className=\"text-blue-500\" size={18} />\n                          )}\n                        </div>\n                        <h4 className=\"font-medium\">{discovery.name}</h4>\n                      </div>\n\n                      <div className=\"text-sm text-gray-600 dark:text-gray-400\">\n                        <div>\n                          Type:{' '}\n                          {discovery.type === 'anomaly'\n                            ? `Anomaly (${discovery.anomalyType})`\n                            : `Resource (${discovery.resourceType})`}\n                        </div>\n                        <div>Sector: {discovery.sectorName}</div>\n                      </div>\n\n                      {classification && category && (\n                        <div className=\"mt-2 rounded bg-gray-50 p-2 dark:bg-gray-800\">\n                          <div className=\"flex items-center\">\n                            <div\n                              className=\"mr-2 h-3 w-3 rounded-full\"\n                              style={{ backgroundColor: category.color || '#6b7280' }}\n                            ></div>\n                            <span className=\"font-medium\">{category.name}</span>\n                            <span\n                              className={`ml-2 text-xs ${getConfidenceColor(\n                                classification.confidenceLevel\n                              )}`}\n                            >\n                              {Math.round(classification.confidence * 100)}% confidence\n                            </span>\n                          </div>\n                        </div>\n                      )}\n                    </div>\n                  );\n                })}\n              </div>\n            ) : (\n              <div className=\"text-gray-500 dark:text-gray-400\">\n                No similar discoveries found. Try classifying this discovery first.\n              </div>\n            )}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/ExplorationDataManager.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/ExplorationSystemIntegration.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/GalaxyMapSystem.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/GalaxyMappingSystem.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/RealTimeMapUpdates.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/ReconShipCoordination.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'leader' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 344,
        "column": 17,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 344,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'renderShipDetails' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 474,
        "column": 9,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 474,
        "endColumn": 26
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'handleFormationSelect' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 490,
        "column": 9,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 490,
        "endColumn": 30
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { ChevronUp, Plus, Radar, Users, Zap } from 'lucide-react';\nimport { useCallback, useEffect, useMemo, useState } from 'react';\nimport { moduleEventBus } from '../../lib/events/ModuleEventBus';\nimport { Position } from '../../types/core/GameTypes';\nimport { EventType } from '../../types/events/EventTypes';\nimport { StandardizedEvent } from '../../types/events/StandardizedEvents';\nimport { ExplorationStatus, Sector } from '../../types/exploration/unified/ExplorationTypes';\nimport { cn } from '../../utils/cn';\n\n// Define interfaces based on ReconShipManagerImpl\ninterface ReconShip {\n  id: string;\n  name: string;\n  type: 'AC27G' | 'PathFinder' | 'VoidSeeker' | 'recon' | 'mining' | 'war';\n  status: 'idle' | 'scanning' | 'investigating' | 'returning';\n  targetSector?: string;\n  experience: number;\n  specialization: 'mapping' | 'anomaly' | 'resource';\n  efficiency: number;\n  position: Position;\n  formationId?: string;\n  formationRole?: 'leader' | 'support' | 'scout';\n  coordinationBonus?: number;\n  capabilities: {\n    scanning: number;\n    stealth: number;\n    combat: number;\n    stealthActive?: boolean;\n    speed: number;\n    range: number;\n  };\n  currentTask?: {\n    type: string;\n    target: string;\n    progress: number;\n  };\n  stealthActive?: boolean;\n}\n\ninterface Formation {\n  id: string;\n  name: string;\n  type: string;\n  shipIds: string[];\n  leaderId: string;\n  position: Position;\n  status: 'idle' | 'scanning' | 'moving' | 'combat';\n  effectiveness?: number;\n}\n\ninterface ReconShipCoordinationProps {\n  ships: ReconShip[];\n  sectors: Sector[];\n  formations?: Formation[];\n  onCreateFormation: (name: string, type: string, shipIds: string[], leaderId: string) => void;\n  onDisbandFormation: (formationId: string) => void;\n  _onAddShipToFormation: (shipId: string, formationId: string) => void;\n  _onRemoveShipFromFormation: (shipId: string, formationId: string) => void;\n  onStartCoordinatedScan: (sectorId: string, shipIds: string[]) => void;\n  onShareTask?: (\n    sourceShipId: string,\n    targetShipId: string,\n    taskType: 'explore' | 'investigate' | 'evade'\n  ) => void;\n  onAutoDistributeTasks: (sectorIds: string[], prioritizeFormations: boolean) => void;\n  className?: string;\n}\n\nexport const ReconShipCoordination: React.FC<ReconShipCoordinationProps> = ({\n  ships,\n  sectors,\n  formations = [],\n  onCreateFormation,\n  onDisbandFormation,\n  _onAddShipToFormation,\n  _onRemoveShipFromFormation,\n  onStartCoordinatedScan,\n  onShareTask,\n  onAutoDistributeTasks,\n  className,\n}) => {\n  // State for UI\n  const [activeTab, setActiveTab] = useState<'formations' | 'coordination' | 'auto'>('formations');\n  const [selectedFormationId, setSelectedFormationId] = useState<string>('');\n  const [selectedSectorId, setSelectedSectorId] = useState<string>('');\n  const [showCreateFormation, setShowCreateFormation] = useState(false);\n  const [formationName, setFormationName] = useState('');\n  const [formationType, setFormationType] = useState<string>('exploration');\n  const [selectedShipIds, setSelectedShipIds] = useState<string[]>([]);\n  const [selectedLeaderId, setSelectedLeaderId] = useState<string>('');\n  const [_prioritizeFormations, _setPrioritizeFormations] = useState(true);\n\n  // Derived state\n  const availableShips = useMemo(() => {\n    return ships.filter(ship => ship.status === 'idle' && !ship.formationId);\n  }, [ships]);\n\n  const _formationShips = useMemo(() => {\n    if (!selectedFormationId) return [];\n    const formation = formations.find(f => f.id === selectedFormationId);\n    if (!formation) return [];\n    return ships.filter(ship => formation.shipIds.includes(ship.id));\n  }, [ships, formations, selectedFormationId]);\n\n  const _selectedFormation = useMemo(() => {\n    return formations.find(f => f.id === selectedFormationId) || null;\n  }, [formations, selectedFormationId]);\n\n  // Reset selected leader when selected ships change\n  useEffect(() => {\n    if (selectedShipIds.length > 0 && !selectedShipIds.includes(selectedLeaderId)) {\n      setSelectedLeaderId(selectedShipIds[0]);\n    } else if (selectedShipIds.length === 0) {\n      setSelectedLeaderId('');\n    }\n  }, [selectedShipIds, selectedLeaderId]);\n\n  // Handle form submission for creating a new formation with standardized events\n  const handleCreateFormation = useCallback(\n    (name: string, type: string, shipIds: string[], leaderId: string) => {\n      const event: StandardizedEvent = {\n        type: EventType.MODULE_UPDATED,\n        moduleId: 'recon-coordination',\n        moduleType: 'exploration',\n        timestamp: Date.now(),\n        data: { name, type, shipIds, leaderId, action: 'create_formation' },\n      };\n      moduleEventBus.emit(event);\n      onCreateFormation(name, type, shipIds, leaderId);\n    },\n    [onCreateFormation]\n  );\n\n  // Handle starting a coordinated scan with standardized events\n  const handleStartCoordinatedScan = useCallback(\n    (sectorId: string, shipIds: string[]) => {\n      const event: StandardizedEvent = {\n        type: EventType.EXPLORATION_SCAN_STARTED,\n        moduleId: 'recon-coordination',\n        moduleType: 'exploration',\n        timestamp: Date.now(),\n        data: { sectorId, shipIds },\n      };\n      moduleEventBus.emit(event);\n      onStartCoordinatedScan(sectorId, shipIds);\n    },\n    [onStartCoordinatedScan]\n  );\n\n  // Handle auto-distribution of tasks with standardized events\n  const handleAutoDistributeTasks = useCallback(\n    (sectorIds: string[], prioritizeFormations: boolean) => {\n      const event: StandardizedEvent = {\n        type: EventType.EXPLORATION_TASK_ASSIGNED,\n        moduleId: 'recon-coordination',\n        moduleType: 'exploration',\n        timestamp: Date.now(),\n        data: { sectorIds, prioritizeFormations },\n      };\n      moduleEventBus.emit(event);\n      onAutoDistributeTasks(sectorIds, prioritizeFormations);\n    },\n    [onAutoDistributeTasks]\n  );\n\n  // Handle task sharing with standardized events\n  const handleShareTask = useCallback(\n    (sourceShipId: string, targetShipId: string, taskType: 'explore' | 'investigate' | 'evade') => {\n      if (onShareTask) {\n        const event: StandardizedEvent = {\n          type: EventType.EXPLORATION_TASK_ASSIGNED,\n          moduleId: 'recon-coordination',\n          moduleType: 'exploration',\n          timestamp: Date.now(),\n          data: { sourceShipId, targetShipId, taskType },\n        };\n        moduleEventBus.emit(event);\n        onShareTask(sourceShipId, targetShipId, taskType);\n      }\n    },\n    [onShareTask]\n  );\n\n  // Cleanup subscriptions on unmount\n  useEffect(() => {\n    const cleanup = () => {\n      // Any cleanup needed for event subscriptions\n    };\n\n    return cleanup;\n  }, []);\n\n  // Add a button or UI element to use the handleShareTask function\n  const _renderTaskSharingControls = () => {\n    if (activeTab !== 'coordination' || !selectedShipIds.length) return null;\n\n    return (\n      <div className=\"mt-4 rounded border border-gray-200 p-3\">\n        <h4 className=\"mb-2 text-sm font-semibold\">Share Tasks</h4>\n        <div className=\"space-y-2\">\n          {selectedShipIds.map(shipId => {\n            const ship = ships.find(s => s.id === shipId);\n            if (!ship) return null;\n\n            return (\n              <div key={`share-${shipId}`} className=\"flex items-center justify-between\">\n                <span className=\"text-sm\">{ship.name}</span>\n                <div className=\"flex space-x-1\">\n                  <button\n                    className=\"rounded bg-blue-100 px-2 py-1 text-xs text-blue-700 hover:bg-blue-200\"\n                    onClick={() =>\n                      handleShareTask(\n                        shipId,\n                        selectedShipIds.find(id => id !== shipId) || '',\n                        'explore'\n                      )\n                    }\n                    disabled={selectedShipIds.length < 2}\n                  >\n                    Explore\n                  </button>\n                  <button\n                    className=\"rounded bg-purple-100 px-2 py-1 text-xs text-purple-700 hover:bg-purple-200\"\n                    onClick={() =>\n                      handleShareTask(\n                        shipId,\n                        selectedShipIds.find(id => id !== shipId) || '',\n                        'investigate'\n                      )\n                    }\n                    disabled={selectedShipIds.length < 2}\n                  >\n                    Investigate\n                  </button>\n                  <button\n                    className=\"rounded bg-red-100 px-2 py-1 text-xs text-red-700 hover:bg-red-200\"\n                    onClick={() =>\n                      handleShareTask(\n                        shipId,\n                        selectedShipIds.find(id => id !== shipId) || '',\n                        'evade'\n                      )\n                    }\n                    disabled={selectedShipIds.length < 2}\n                  >\n                    Evade\n                  </button>\n                </div>\n              </div>\n            );\n          })}\n        </div>\n      </div>\n    );\n  };\n\n  const getUnexploredSectors = useCallback(() => {\n    return sectors.filter(sector => sector.explorationStatus === ExplorationStatus.UNDISCOVERED);\n  }, [sectors]);\n\n  const _getHighPrioritySectors = useCallback(() => {\n    return sectors.filter(\n      sector =>\n        sector.explorationStatus !== ExplorationStatus.FULLY_EXPLORED && sector.resources.length > 0\n    );\n  }, [sectors]);\n\n  const getAvailableReconShips = useCallback(() => {\n    return ships.filter(\n      ship =>\n        ship.type === 'recon' &&\n        ship.status === 'idle' &&\n        !formations.some(f => f.shipIds.includes(ship.id))\n    );\n  }, [ships, formations]);\n\n  const getFormationEffectiveness = useCallback(\n    (formation: Formation) => {\n      const formationShips = ships.filter(ship => formation.shipIds.includes(ship.id));\n      return formationShips.reduce((total, ship) => {\n        const baseEffectiveness = ship.capabilities.speed + ship.capabilities.range;\n        const stealthBonus = ship.capabilities.stealth\n          ? ship.capabilities.stealth * (ship.stealthActive ? 2 : 1)\n          : 0;\n        return total + baseEffectiveness + stealthBonus;\n      }, 0);\n    },\n    [ships]\n  );\n\n  const getFormationShips = useCallback(\n    (formation: Formation) => {\n      return ships.filter(ship => formation.shipIds.includes(ship.id));\n    },\n    [ships]\n  );\n\n  const getFormationLeader = useCallback(\n    (formation: Formation) => {\n      return ships.find(ship => ship.id === formation.leaderId);\n    },\n    [ships]\n  );\n\n  const getFormationStatus = useCallback(\n    (formation: Formation) => {\n      const formationShips = getFormationShips(formation);\n      if (formationShips.every(ship => ship.status === 'scanning')) {\n        return 'scanning';\n      }\n      if (formationShips.some(ship => ship.status === 'investigating')) {\n        return 'investigating';\n      }\n      return 'idle';\n    },\n    [getFormationShips]\n  );\n\n  const _getFormationsByType = useCallback(\n    (type: string) => {\n      return formations.filter(f => f.type === type);\n    },\n    [formations]\n  );\n\n  const _getShipsByType = useCallback(\n    (type: 'recon' | 'mining' | 'war') => {\n      return ships.filter(ship => ship.type === type);\n    },\n    [ships]\n  );\n\n  const _getShipsByStatus = useCallback(\n    (status: 'idle' | 'scanning' | 'investigating' | 'returning') => {\n      return ships.filter(ship => ship.status === status);\n    },\n    [ships]\n  );\n\n  const renderFormationList = () => {\n    return (\n      <div className=\"space-y-4\">\n        {formations.map(formation => {\n          const leader = getFormationLeader(formation);\n          const effectiveness = getFormationEffectiveness(formation);\n          const status = getFormationStatus(formation);\n\n          return (\n            <div key={formation.id} className=\"rounded border p-4\">\n              <div className=\"flex items-center justify-between\">\n                <div>\n                  <h4 className=\"font-medium\">{formation.name}</h4>\n                  <p className=\"text-sm text-gray-500\">Type: {formation.type}</p>\n                  <p className=\"text-sm text-gray-500\">Status: {status}</p>\n                  <p className=\"text-sm text-gray-500\">Effectiveness: {effectiveness.toFixed(1)}</p>\n                </div>\n                <div className=\"flex space-x-2\">\n                  <button\n                    className=\"rounded bg-red-500 px-2 py-1 text-white hover:bg-red-600\"\n                    onClick={() => onDisbandFormation(formation.id)}\n                  >\n                    Disband\n                  </button>\n                </div>\n              </div>\n              <div className=\"mt-2\">\n                <h5 className=\"text-sm font-medium\">Ships</h5>\n                <div className=\"mt-1 space-y-1\">\n                  {getFormationShips(formation).map(ship => (\n                    <div key={ship.id} className=\"flex items-center justify-between text-sm\">\n                      <span>{ship.name}</span>\n                      <span className=\"text-gray-500\">{ship.type}</span>\n                      <span className=\"text-gray-500\">\n                        {ship.currentTask ? `Task: ${ship.currentTask}` : 'No task'}\n                      </span>\n                    </div>\n                  ))}\n                </div>\n              </div>\n            </div>\n          );\n        })}\n      </div>\n    );\n  };\n\n  const handleAutoDistributeClick = () => {\n    const unexploredSectorIds = getUnexploredSectors().map(sector => sector.id);\n    handleAutoDistributeTasks(unexploredSectorIds, true);\n  };\n\n  const renderCoordinationTab = () => {\n    return (\n      <div>\n        <div className=\"mb-4\">\n          <h3 className=\"text-lg font-medium\">Coordinated Scanning</h3>\n          <p className=\"text-sm text-gray-500\">\n            Select a formation and sector to begin coordinated scanning\n          </p>\n        </div>\n\n        <div className=\"grid gap-4 md:grid-cols-2\">\n          <div>\n            <h4 className=\"mb-2 font-medium\">Select Formation</h4>\n            <select\n              className=\"w-full rounded border p-2\"\n              value={selectedShipIds.join(',')}\n              onChange={e => setSelectedShipIds(e.target.value ? e.target.value.split(',') : [])}\n            >\n              <option value=\"\">Select a formation...</option>\n              {formations.map(formation => (\n                <option key={formation.id} value={formation.shipIds.join(',')}>\n                  {formation.name} ({formation.shipIds.length} ships)\n                </option>\n              ))}\n            </select>\n          </div>\n\n          <div>\n            <h4 className=\"mb-2 font-medium\">Select Sector</h4>\n            <select\n              className=\"w-full rounded border p-2\"\n              value={selectedSectorId}\n              onChange={e => setSelectedSectorId(e.target.value)}\n            >\n              <option value=\"\">Select a sector...</option>\n              {sectors.map(sector => (\n                <option key={sector.id} value={sector.id}>\n                  {sector.name} - {sector.explorationStatus}\n                </option>\n              ))}\n            </select>\n          </div>\n        </div>\n\n        <div className=\"mt-4\">\n          <button\n            className=\"flex items-center rounded bg-blue-500 px-4 py-2 text-white hover:bg-blue-600\"\n            onClick={() =>\n              selectedSectorId &&\n              selectedShipIds.length > 0 &&\n              handleStartCoordinatedScan(selectedSectorId, selectedShipIds)\n            }\n            disabled={!selectedSectorId || selectedShipIds.length === 0}\n          >\n            Start Coordinated Scan\n          </button>\n        </div>\n      </div>\n    );\n  };\n\n  const renderAutoDistributionTab = () => {\n    return (\n      <div>\n        <div className=\"mb-4\">\n          <h3 className=\"text-lg font-medium\">Auto-Distribution</h3>\n          <p className=\"text-sm text-gray-500\">Automatically distribute tasks to available ships</p>\n        </div>\n\n        <div className=\"mb-4\">\n          <button\n            className=\"flex items-center rounded bg-blue-500 px-4 py-2 text-white hover:bg-blue-600\"\n            onClick={handleAutoDistributeClick}\n            disabled={getUnexploredSectors().length === 0 || getAvailableReconShips().length === 0}\n          >\n            Auto-Distribute Tasks\n          </button>\n        </div>\n      </div>\n    );\n  };\n\n  const renderShipDetails = (ship: ReconShip) => {\n    return (\n      <div key={ship.id} className=\"mb-4 rounded-lg bg-gray-800 p-4\">\n        <h4 className=\"mb-2 text-lg font-semibold text-white\">{ship.name}</h4>\n        <div className=\"grid grid-cols-2 gap-2 text-sm text-gray-300\">\n          <div>Type: {ship.type}</div>\n          <div>Status: {ship.status}</div>\n          <div>Scanning: {ship.capabilities?.scanning || 0}</div>\n          <div>Stealth: {ship.capabilities?.stealth || 0}</div>\n          <div>Combat: {ship.capabilities?.combat || 0}</div>\n          <div>Stealth Active: {ship.capabilities?.stealthActive ? 'Yes' : 'No'}</div>\n        </div>\n      </div>\n    );\n  };\n\n  const handleFormationSelect = (formationId: string) => {\n    setSelectedFormationId(formationId === selectedFormationId ? '' : formationId);\n  };\n\n  return (\n    <div className={cn('flex flex-col space-y-4', className)}>\n      {/* Header */}\n      <div className=\"border-b bg-gray-50 p-4 dark:bg-gray-800\">\n        <h2 className=\"flex items-center text-xl font-semibold\">\n          <Users className=\"mr-2\" />\n          Recon Ship Coordination\n        </h2>\n        <p className=\"mt-1 text-sm text-gray-500 dark:text-gray-400\">\n          Manage fleet formations and coordinate recon ship operations\n        </p>\n      </div>\n\n      {/* Tabs */}\n      <div className=\"flex border-b\">\n        <button\n          className={`px-4 py-2 font-medium ${\n            activeTab === 'formations'\n              ? 'border-b-2 border-blue-500 text-blue-600'\n              : 'text-gray-600 hover:text-gray-800'\n          }`}\n          onClick={() => setActiveTab('formations')}\n        >\n          <div className=\"flex items-center\">\n            <Users size={16} className=\"mr-2\" />\n            Formations\n          </div>\n        </button>\n        <button\n          className={`px-4 py-2 font-medium ${\n            activeTab === 'coordination'\n              ? 'border-b-2 border-blue-500 text-blue-600'\n              : 'text-gray-600 hover:text-gray-800'\n          }`}\n          onClick={() => setActiveTab('coordination')}\n        >\n          <div className=\"flex items-center\">\n            <Radar size={16} className=\"mr-2\" />\n            Coordinated Scanning\n          </div>\n        </button>\n        <button\n          className={`px-4 py-2 font-medium ${\n            activeTab === 'auto'\n              ? 'border-b-2 border-blue-500 text-blue-600'\n              : 'text-gray-600 hover:text-gray-800'\n          }`}\n          onClick={() => setActiveTab('auto')}\n        >\n          <div className=\"flex items-center\">\n            <Zap size={16} className=\"mr-2\" />\n            Auto-Distribution\n          </div>\n        </button>\n      </div>\n\n      {/* Content */}\n      <div className=\"p-4\">\n        {/* Formations Tab */}\n        {activeTab === 'formations' && (\n          <div>\n            {/* Formation List */}\n            <div className=\"mb-4\">\n              <div className=\"mb-2 flex items-center justify-between\">\n                <h3 className=\"text-lg font-medium\">Fleet Formations</h3>\n                <button\n                  className=\"flex items-center rounded bg-blue-500 px-2 py-1 text-white hover:bg-blue-600\"\n                  onClick={() => setShowCreateFormation(!showCreateFormation)}\n                >\n                  {showCreateFormation ? (\n                    <>\n                      <ChevronUp size={16} className=\"mr-1\" />\n                      Cancel\n                    </>\n                  ) : (\n                    <>\n                      <Plus size={16} className=\"mr-1\" />\n                      New Formation\n                    </>\n                  )}\n                </button>\n              </div>\n\n              {/* Create Formation Form */}\n              {showCreateFormation && (\n                <div className=\"mb-4 rounded border bg-gray-50 p-4 dark:bg-gray-800\">\n                  <h4 className=\"mb-2 font-medium\">Create New Formation</h4>\n\n                  <div className=\"mb-3\">\n                    <label className=\"mb-1 block text-sm font-medium\">Formation Name</label>\n                    <input\n                      type=\"text\"\n                      className=\"w-full rounded border p-2\"\n                      value={formationName}\n                      onChange={e => setFormationName(e.target.value)}\n                      placeholder=\"Enter formation name\"\n                    />\n                  </div>\n\n                  <div className=\"mb-3\">\n                    <label className=\"mb-1 block text-sm font-medium\">Formation Type</label>\n                    <select\n                      className=\"w-full rounded border p-2\"\n                      value={formationType}\n                      onChange={e => setFormationType(e.target.value)}\n                    >\n                      <option value=\"exploration\">Exploration</option>\n                      <option value=\"survey\">Survey</option>\n                      <option value=\"defensive\">Defensive</option>\n                    </select>\n                    <p className=\"mt-1 text-xs text-gray-500\">\n                      {formationType === 'exploration'\n                        ? 'Balanced formation for general exploration'\n                        : formationType === 'survey'\n                          ? 'Specialized formation for resource discovery'\n                          : 'Defensive formation with enhanced threat detection'}\n                    </p>\n                  </div>\n\n                  <div className=\"mb-3\">\n                    <label className=\"mb-1 block text-sm font-medium\">Select Ships</label>\n                    <div className=\"max-h-40 overflow-y-auto rounded border p-2\">\n                      {availableShips.length > 0 ? (\n                        availableShips.map(ship => (\n                          <div key={ship.id} className=\"mb-1 flex items-center last:mb-0\">\n                            <input\n                              type=\"checkbox\"\n                              id={`ship-${ship.id}`}\n                              checked={selectedShipIds.includes(ship.id)}\n                              onChange={e => {\n                                if (e.target.checked) {\n                                  setSelectedShipIds([...selectedShipIds, ship.id]);\n                                } else {\n                                  setSelectedShipIds(selectedShipIds.filter(id => id !== ship.id));\n                                }\n                              }}\n                              className=\"mr-2\"\n                            />\n                            <label htmlFor={`ship-${ship.id}`} className=\"flex items-center\">\n                              <span className=\"font-medium\">{ship.name}</span>\n                              <span className=\"ml-2 text-xs text-gray-500\">\n                                ({ship.type} - {ship.specialization})\n                              </span>\n                            </label>\n                          </div>\n                        ))\n                      ) : (\n                        <div className=\"text-sm text-gray-500\">No available ships</div>\n                      )}\n                    </div>\n                  </div>\n\n                  {selectedShipIds.length > 0 && (\n                    <div className=\"mb-3\">\n                      <label className=\"mb-1 block text-sm font-medium\">Formation Leader</label>\n                      <select\n                        className=\"w-full rounded border p-2\"\n                        value={selectedLeaderId}\n                        onChange={e => setSelectedLeaderId(e.target.value)}\n                      >\n                        {selectedShipIds.map(shipId => {\n                          const ship = ships.find(s => s.id === shipId);\n                          return (\n                            <option key={shipId} value={shipId}>\n                              {ship?.name} ({ship?.specialization})\n                            </option>\n                          );\n                        })}\n                      </select>\n                    </div>\n                  )}\n\n                  <div className=\"flex justify-end\">\n                    <button\n                      className=\"flex items-center rounded bg-blue-500 px-3 py-1 text-white hover:bg-blue-600\"\n                      onClick={() =>\n                        handleCreateFormation(\n                          formationName,\n                          formationType,\n                          selectedShipIds,\n                          selectedLeaderId\n                        )\n                      }\n                      disabled={!formationName || selectedShipIds.length === 0 || !selectedLeaderId}\n                    >\n                      <Plus size={16} className=\"mr-1\" />\n                      Create Formation\n                    </button>\n                  </div>\n                </div>\n              )}\n\n              {/* Formations List */}\n              {renderFormationList()}\n            </div>\n          </div>\n        )}\n\n        {/* Coordinated Scanning Tab */}\n        {activeTab === 'coordination' && renderCoordinationTab()}\n\n        {/* Auto-Distribution Tab */}\n        {activeTab === 'auto' && renderAutoDistributionTab()}\n      </div>\n    </div>\n  );\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/ResourceDiscoverySystem.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'e' is defined but never used. Allowed unused caught errors must match /^_/u.",
        "line": 180,
        "column": 14,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 180,
        "endColumn": 15
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { Database, Droplet, Leaf, Loader, Search, Sparkles, Zap } from 'lucide-react';\nimport * as React from 'react';\nimport { useCallback, useEffect, useMemo, useState } from 'react';\nimport { ensureStringResourceType } from '../../utils/resources/ResourceTypeMigration';\nimport { ResourceType } from './../../types/resources/ResourceTypes';\n\n// Interfaces\ninterface ResourceDiscovery {\n  id: string;\n  sectorId: string;\n  sectorName: string;\n  discoveryDate: number;\n  processedDate?: number;\n  status: 'discovered' | 'analyzing' | 'processed';\n  confidence: number; // 0-1 scale\n  rawData: RawResourceData[];\n  processedData?: ResourceData[];\n  scanQuality: number; // 0-1 scale\n  notes?: string;\n}\n\ninterface RawResourceData {\n  signalStrength: number; // 0-1 scale\n  signalType:\n    | 'mineral'\n    | ResourceType.ENERGY\n    | ResourceType.GAS\n    | 'organic'\n    | ResourceType.EXOTIC\n    | 'unknown';\n  signalPattern: 'concentrated' | 'scattered' | 'veins' | 'unknown';\n  signalDepth: number; // 0-1 scale (deeper = harder to access)\n  coordinates: { x: number; y: number }; // Relative to sector center\n}\n\ninterface ResourceData {\n  type: ResourceType;\n  name: string;\n  amount: number; // 0-100 scale\n  quality: number; // 0-1 scale\n  accessibility: number; // 0-1 scale (how easy it is to extract)\n  distribution: 'concentrated' | 'scattered' | 'veins';\n  estimatedValue: number; // Credit value\n  extractionDifficulty: number; // 0-10 scale\n  coordinates: { x: number; y: number }; // Relative to sector center\n}\n\ninterface Sector {\n  id: string;\n  name: string;\n  status: 'unmapped' | 'mapped' | 'scanning' | 'analyzed';\n  coordinates: { x: number; y: number };\n  resourcePotential: number;\n  habitabilityScore: number;\n  lastScanned?: number;\n}\n\ninterface ResourceDiscoverySystemProps {\n  discoveries: ResourceDiscovery[];\n  sectors: Sector[];\n  onProcessDiscovery: (discoveryId: string, processedData: ResourceData[]) => void;\n  onUpdateNotes: (discoveryId: string, notes: string) => void;\n  className?: string;\n  quality?: 'low' | 'medium' | 'high';\n}\n\n// Resource name generators by type - updated to use enum values\nconst resourceNames: Record<string, string[]> = {\n  [ResourceType.MINERALS]: [\n    'Iron Deposits',\n    'Copper Veins',\n    'Titanium Ore',\n    'Platinum Clusters',\n    'Gold Nuggets',\n    'Silver Deposits',\n    'Uranium Ore',\n    'Cobalt Formations',\n    'Nickel Veins',\n    'Aluminum Deposits',\n    'Rare Earth Metals',\n    'Tungsten Ore',\n    'Chromium Deposits',\n    'Manganese Nodules',\n    'Zirconium Crystals',\n  ],\n  [ResourceType.ENERGY]: [\n    'Thermal Vents',\n    'Solar Radiation Pockets',\n    'Plasma Streams',\n    'Geothermal Hotspots',\n    'Fusion Materials',\n    'Radioactive Isotopes',\n    'Quantum Particles',\n    'Antimatter Traces',\n    'Dark Energy Nodes',\n    'Neutron Sources',\n    'Tachyon Emissions',\n    'Zero-Point Fields',\n  ],\n  [ResourceType.GAS]: [\n    'Hydrogen Clouds',\n    'Helium Pockets',\n    'Methane Reservoirs',\n    'Nitrogen Bubbles',\n    'Oxygen Pockets',\n    'Carbon Dioxide Vents',\n    'Neon Clusters',\n    'Argon Deposits',\n    'Xenon Pockets',\n    'Ammonia Clouds',\n    'Chlorine Vents',\n    'Sulfur Dioxide Pockets',\n  ],\n  organic: [\n    'Bacterial Colonies',\n    'Fungal Growths',\n    'Plant Analogs',\n    'Protein Compounds',\n    'Amino Acid Pools',\n    'Enzyme Clusters',\n    'Microbial Mats',\n    'Spore Formations',\n    'Algae Blooms',\n    'Viral Particles',\n    'DNA Fragments',\n    'RNA Strands',\n    'Cellular Structures',\n  ],\n  [ResourceType.EXOTIC]: [\n    'Quantum Crystals',\n    'Dark Matter Nodes',\n    'Temporal Anomalies',\n    'Dimensional Rifts',\n    'Exotic Particles',\n    'Strange Matter',\n    'Antimatter Pockets',\n    'Graviton Clusters',\n    'Tachyon Fields',\n    'Higgs Boson Concentrations',\n    'Monopole Magnets',\n    'Quark-Gluon Plasma',\n  ],\n  [ResourceType.POPULATION]: [\n    'Settlement Sites',\n    'Habitable Zones',\n    'Colony Locations',\n    'Terraforming Candidates',\n    'Shelter Regions',\n    'Expansion Areas',\n  ],\n  [ResourceType.RESEARCH]: [\n    'Ancient Ruins',\n    'Alien Artifacts',\n    'Scientific Phenomena',\n    'Knowledge Repositories',\n    'Research Specimens',\n    'Data Caches',\n  ],\n  [ResourceType.PLASMA]: [\n    'Plasma Clouds',\n    'Ionized Gas Pockets',\n    'Charged Particle Fields',\n    'Electromagnetic Anomalies',\n    'Fusion Reaction Sites',\n    'Plasma Storms',\n  ],\n};\n\n// For backward compatibility - maintain string keys for resourceNames\n// This will be removed in a future update\nObject.entries(resourceNames).forEach(([key, value]) => {\n  if (typeof key === 'string' && key !== 'organic') {\n    try {\n      const enumKey = Object.values(ResourceType).find(\n        enumValue => enumValue.toString() === key.toUpperCase()\n      );\n      if (enumKey && !resourceNames[enumKey]) {\n        resourceNames[enumKey] = value;\n      }\n    } catch (e) {\n      console.warn(`Failed to create enum key for ${key}`);\n    }\n  }\n});\n\nexport function ResourceDiscoverySystem({\n  discoveries,\n  sectors,\n  onProcessDiscovery,\n  onUpdateNotes,\n  className = '',\n  quality = 'medium',\n}: ResourceDiscoverySystemProps) {\n  const [selectedDiscoveryId, setSelectedDiscoveryId] = useState<string | null>(null);\n  const [searchQuery, setSearchQuery] = useState('');\n  const [statusFilter, setStatusFilter] = useState<\n    'all' | 'discovered' | 'analyzing' | 'processed'\n  >('all');\n  const [sortBy, setSortBy] = useState<'date' | 'confidence' | 'potential'>('date');\n  const [sortOrder, setSortOrder] = useState<'asc' | 'desc'>('desc');\n  const [processingDiscoveryId, setProcessingDiscoveryId] = useState<string | null>(null);\n  const [processingProgress, setProcessingProgress] = useState(0);\n  const [notes, setNotes] = useState('');\n\n  // Quality settings for visualization and processing\n  const qualitySettings = useMemo(() => {\n    switch (quality) {\n      case 'low':\n        return {\n          processingSpeed: 50, // ms between processing steps\n          animationDuration: 300,\n          maxDataPoints: 50,\n          confidenceDecimalPlaces: 1,\n        };\n      case 'high':\n        return {\n          processingSpeed: 20,\n          animationDuration: 500,\n          maxDataPoints: 200,\n          confidenceDecimalPlaces: 3,\n        };\n      case 'medium':\n      default:\n        return {\n          processingSpeed: 35,\n          animationDuration: 400,\n          maxDataPoints: 100,\n          confidenceDecimalPlaces: 2,\n        };\n    }\n  }, [quality]);\n\n  // Get the selected discovery\n  const selectedDiscovery = useMemo(\n    () => discoveries.find(d => d.id === selectedDiscoveryId) || null,\n    [discoveries, selectedDiscoveryId]\n  );\n\n  // Filter and sort discoveries\n  const filteredDiscoveries = useMemo(() => {\n    let filtered = [...discoveries];\n\n    // Apply status filter\n    if (statusFilter !== 'all') {\n      filtered = filtered.filter(d => d.status === statusFilter);\n    }\n\n    // Apply search filter\n    if (searchQuery) {\n      const query = searchQuery.toLowerCase();\n      filtered = filtered.filter(\n        d =>\n          d.sectorName.toLowerCase().includes(query) ||\n          d.id.toLowerCase().includes(query) ||\n          (d.notes && d.notes.toLowerCase().includes(query))\n      );\n    }\n\n    // Apply sorting\n    filtered.sort((a, b) => {\n      let comparison = 0;\n\n      if (sortBy === 'date') {\n        comparison = a.discoveryDate - b.discoveryDate;\n      } else if (sortBy === 'confidence') {\n        comparison = a.confidence - b.confidence;\n      } else if (sortBy === 'potential') {\n        const sectorA = sectors.find(s => s.id === a.sectorId);\n        const sectorB = sectors.find(s => s.id === b.sectorId);\n        comparison = (sectorA?.resourcePotential || 0) - (sectorB?.resourcePotential || 0);\n      }\n\n      return sortOrder === 'asc' ? comparison : -comparison;\n    });\n\n    return filtered;\n  }, [discoveries, statusFilter, searchQuery, sortBy, sortOrder, sectors]);\n\n  // Process a discovery\n  const processDiscovery = useCallback(\n    (discoveryId: string) => {\n      const discovery = discoveries.find(d => d.id === discoveryId);\n      if (!discovery || discovery.status === 'processed') return;\n\n      setProcessingDiscoveryId(discoveryId);\n      setProcessingProgress(0);\n\n      let progress = 0;\n      const interval = setInterval(() => {\n        progress += 5;\n        setProcessingProgress(progress);\n\n        if (progress >= 100) {\n          clearInterval(interval);\n          const processedData = generateProcessedData(discovery);\n          onProcessDiscovery(discoveryId, processedData);\n          setProcessingDiscoveryId(null);\n        }\n      }, qualitySettings.processingSpeed); // Use quality setting for processing speed\n\n      return () => clearInterval(interval);\n    },\n    [discoveries, onProcessDiscovery, qualitySettings]\n  );\n\n  // Generate processed resource data from raw data\n  const generateProcessedData = (discovery: ResourceDiscovery): ResourceData[] => {\n    return discovery.rawData.map(raw => {\n      // Determine resource type\n      let type: ResourceType;\n      if (raw.signalType === 'unknown') {\n        // Select a random resource type from the valid ResourceType values\n        const resourceTypes: ResourceType[] = [\n          ResourceType.MINERALS,\n          ResourceType.ENERGY,\n          ResourceType.GAS,\n          ResourceType.PLASMA,\n          ResourceType.EXOTIC,\n        ];\n        type = resourceTypes[Math.floor(Math.random() * resourceTypes.length)];\n      } else if (raw.signalType === 'mineral') {\n        type = ResourceType.MINERALS; // Convert 'mineral' to ResourceType.MINERALS\n      } else if (raw.signalType === 'organic') {\n        // Handle 'organic' which is not in ResourceType\n        type = ResourceType.MINERALS; // Map to a valid ResourceType\n      } else if (raw.signalType === ResourceType.GAS) {\n        type = ResourceType.GAS;\n      } else if (raw.signalType === ResourceType.ENERGY) {\n        type = ResourceType.ENERGY;\n      } else if (raw.signalType === ResourceType.EXOTIC) {\n        type = ResourceType.EXOTIC;\n      } else {\n        // Default case\n        type = ResourceType.MINERALS;\n      }\n\n      // Generate resource name based on type\n      const typeString = ensureStringResourceType(type);\n\n      // Try to get names directly from the enum key first\n      let nameOptions = resourceNames[type] || resourceNames[typeString];\n\n      // Fallback to minerals if no names found\n      if (!nameOptions) {\n        nameOptions = resourceNames[ResourceType.MINERALS];\n      }\n\n      const name = nameOptions[Math.floor(Math.random() * nameOptions.length)];\n\n      // Calculate resource properties based on raw data and add some randomness\n      const quality = Math.min(1, Math.max(0, raw.signalStrength * (0.7 + Math.random() * 0.6)));\n      const amount = Math.floor(quality * (50 + Math.random() * 50));\n      const accessibility = Math.min(\n        1,\n        Math.max(0, (1 - raw.signalDepth) * (0.6 + Math.random() * 0.8))\n      );\n      const distribution =\n        raw.signalPattern === 'unknown'\n          ? (['concentrated', 'scattered', 'veins'][Math.floor(Math.random() * 3)] as\n              | 'concentrated'\n              | 'scattered'\n              | 'veins')\n          : raw.signalPattern;\n\n      // Calculate extraction difficulty (inverse of accessibility)\n      const extractionDifficulty = Math.round((1 - accessibility) * 10);\n\n      // Calculate estimated value based on type, quality, amount, and accessibility\n      let baseValue = 0;\n      switch (type) {\n        case ResourceType.MINERALS:\n          baseValue = 1000;\n          break;\n        case ResourceType.ENERGY:\n          baseValue = 1500;\n          break;\n        case ResourceType.GAS:\n          baseValue = 1200;\n          break;\n        case ResourceType.PLASMA:\n          baseValue = 2500;\n          break;\n        case ResourceType.EXOTIC:\n          baseValue = 5000;\n          break;\n        case ResourceType.POPULATION:\n          baseValue = 3000;\n          break;\n        case ResourceType.RESEARCH:\n          baseValue = 4000;\n          break;\n        default:\n          baseValue = 1000;\n      }\n\n      const estimatedValue = Math.round(\n        baseValue *\n          amount *\n          quality *\n          (0.5 + accessibility * 0.5) *\n          (distribution === 'concentrated' ? 1.2 : distribution === 'veins' ? 1.0 : 0.8)\n      );\n\n      return {\n        type,\n        name,\n        amount,\n        quality,\n        accessibility,\n        distribution,\n        estimatedValue,\n        extractionDifficulty,\n        coordinates: raw.coordinates,\n      };\n    });\n  };\n\n  // Update notes when changed\n  useEffect(() => {\n    if (selectedDiscovery && notes !== selectedDiscovery.notes) {\n      setNotes(selectedDiscovery.notes || '');\n    }\n  }, [selectedDiscovery]);\n\n  // Handle notes change\n  const handleNotesChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {\n    setNotes(e.target.value);\n  };\n\n  // Save notes\n  const saveNotes = () => {\n    if (selectedDiscoveryId) {\n      onUpdateNotes(selectedDiscoveryId, notes);\n    }\n  };\n\n  // Get resource type icon - updated to handle enum values directly\n  const getResourceTypeIcon = (type: ResourceType | string) => {\n    // If it's a string, emit a deprecation warning\n    if (typeof type === 'string') {\n      console.warn(\n        `Using string resource type '${type}' is deprecated. Use ResourceType enum instead.`\n      );\n    }\n\n    // Convert to string if it's an enum\n    const typeString = typeof type === 'string' ? type : ensureStringResourceType(type);\n\n    switch (typeString) {\n      case ResourceType.MINERALS:\n        return <Database className=\"h-4 w-4 text-blue-400\" />;\n      case ResourceType.ENERGY:\n        return <Zap className=\"h-4 w-4 text-yellow-400\" />;\n      case ResourceType.GAS:\n        return <Droplet className=\"h-4 w-4 text-cyan-400\" />;\n      case 'organic':\n        return <Leaf className=\"h-4 w-4 text-green-400\" />;\n      case ResourceType.EXOTIC:\n        return <Sparkles className=\"h-4 w-4 text-purple-400\" />;\n      default:\n        return <Search className=\"h-4 w-4 text-gray-400\" />;\n    }\n  };\n\n  return (\n    <div\n      className={`flex h-full flex-col rounded-lg border border-gray-700 bg-gray-800 ${className}`}\n    >\n      {/* Header */}\n      <div className=\"flex items-center justify-between border-b border-gray-700 bg-gray-800 p-3\">\n        <h2 className=\"text-lg font-semibold text-white\">Resource Discovery System</h2>\n\n        <div className=\"flex items-center space-x-2\">\n          {/* Search */}\n          <div className=\"relative\">\n            <input\n              type=\"text\"\n              value={searchQuery}\n              onChange={e => setSearchQuery(e.target.value)}\n              placeholder=\"Search discoveries...\"\n              className=\"w-48 rounded border border-gray-600 bg-gray-700 py-1 pl-8 pr-2 text-sm text-white placeholder-gray-400\"\n            />\n            <Search className=\"absolute left-2 top-1/2 h-4 w-4 -translate-y-1/2 text-gray-400\" />\n          </div>\n\n          {/* Status filter */}\n          <select\n            value={statusFilter}\n            onChange={e =>\n              setStatusFilter(e.target.value as 'all' | 'discovered' | 'analyzing' | 'processed')\n            }\n            className=\"rounded border border-gray-600 bg-gray-700 px-2 py-1 text-sm text-white\"\n          >\n            <option value=\"all\">All Status</option>\n            <option value=\"discovered\">Discovered</option>\n            <option value=\"analyzing\">Analyzing</option>\n            <option value=\"processed\">Processed</option>\n          </select>\n\n          {/* Sort options */}\n          <div className=\"flex items-center rounded border border-gray-600 bg-gray-700\">\n            <select\n              value={sortBy}\n              onChange={e => setSortBy(e.target.value as 'date' | 'confidence' | 'potential')}\n              className=\"border-r border-gray-600 bg-transparent px-2 py-1 text-sm text-white\"\n            >\n              <option value=\"date\">Discovery Date</option>\n              <option value=\"confidence\">Confidence</option>\n              <option value=\"potential\">Resource Potential</option>\n            </select>\n            <button\n              onClick={() => setSortOrder(prev => (prev === 'asc' ? 'desc' : 'asc'))}\n              className=\"px-2 py-1 text-sm text-white\"\n            >\n              {sortOrder === 'asc' ? '↑' : '↓'}\n            </button>\n          </div>\n        </div>\n      </div>\n\n      {/* Main content */}\n      <div className=\"flex flex-grow overflow-hidden\">\n        {/* Discoveries list */}\n        <div className=\"w-1/3 overflow-y-auto border-r border-gray-700\">\n          {filteredDiscoveries.length === 0 ? (\n            <div className=\"flex h-full items-center justify-center p-4 text-gray-400\">\n              No discoveries match your filters\n            </div>\n          ) : (\n            <div className=\"divide-y divide-gray-700\">\n              {filteredDiscoveries.map(discovery => (\n                <div\n                  key={discovery.id}\n                  className={`cursor-pointer p-3 transition-colors hover:bg-gray-700 ${\n                    discovery.id === selectedDiscoveryId ? 'bg-gray-700' : ''\n                  }`}\n                  onClick={() => setSelectedDiscoveryId(discovery.id)}\n                >\n                  <div className=\"flex items-center justify-between\">\n                    <h3 className=\"font-medium text-white\">{discovery.sectorName}</h3>\n                    <span\n                      className={`rounded px-2 py-0.5 text-xs ${\n                        discovery.status === 'discovered'\n                          ? 'bg-blue-900 text-blue-200'\n                          : discovery.status === 'analyzing'\n                            ? 'bg-yellow-900 text-yellow-200'\n                            : 'bg-green-900 text-green-200'\n                      }`}\n                    >\n                      {discovery.status.charAt(0).toUpperCase() + discovery.status.slice(1)}\n                    </span>\n                  </div>\n\n                  <div className=\"mt-1 flex items-center text-xs text-gray-400\">\n                    <span>\n                      {new Date(discovery.discoveryDate).toLocaleDateString()} •\n                      {discovery.rawData.length} signals •{Math.round(discovery.confidence * 100)}%\n                      confidence\n                    </span>\n                  </div>\n\n                  <div className=\"mt-2 flex flex-wrap gap-1\">\n                    {discovery.rawData.slice(0, 5).map((raw, index) => (\n                      <span\n                        key={index}\n                        className={`inline-flex items-center rounded px-1.5 py-0.5 text-xs ${\n                          raw.signalType === 'mineral'\n                            ? 'bg-blue-900/50 text-blue-200'\n                            : raw.signalType === ResourceType.ENERGY\n                              ? 'bg-yellow-900/50 text-yellow-200'\n                              : raw.signalType === ResourceType.GAS\n                                ? 'bg-cyan-900/50 text-cyan-200'\n                                : raw.signalType === 'organic'\n                                  ? 'bg-green-900/50 text-green-200'\n                                  : raw.signalType === ResourceType.EXOTIC\n                                    ? 'bg-purple-900/50 text-purple-200'\n                                    : 'bg-gray-700 text-gray-300'\n                        }`}\n                      >\n                        {getResourceTypeIcon(raw.signalType)}\n                        <span className=\"ml-1\">\n                          {raw.signalType === 'unknown' ? 'Unknown' : raw.signalType}\n                        </span>\n                      </span>\n                    ))}\n                    {discovery.rawData.length > 5 && (\n                      <span className=\"inline-flex items-center rounded bg-gray-700 px-1.5 py-0.5 text-xs text-gray-300\">\n                        +{discovery.rawData.length - 5} more\n                      </span>\n                    )}\n                  </div>\n                </div>\n              ))}\n            </div>\n          )}\n        </div>\n\n        {/* Discovery details */}\n        <div className=\"flex-grow overflow-y-auto p-4\">\n          {!selectedDiscovery ? (\n            <div className=\"flex h-full items-center justify-center text-gray-400\">\n              Select a discovery to view details\n            </div>\n          ) : (\n            <div>\n              {/* Header */}\n              <div className=\"mb-4 flex items-center justify-between\">\n                <div>\n                  <h2 className=\"text-xl font-semibold text-white\">\n                    {selectedDiscovery.sectorName}\n                  </h2>\n                  <p className=\"text-sm text-gray-400\">\n                    Discovered on {new Date(selectedDiscovery.discoveryDate).toLocaleString()}\n                    {selectedDiscovery.processedDate &&\n                      ` • Processed on ${new Date(selectedDiscovery.processedDate).toLocaleString()}`}\n                  </p>\n                </div>\n\n                {selectedDiscovery.status !== 'processed' && (\n                  <button\n                    onClick={() => processDiscovery(selectedDiscovery.id)}\n                    disabled={processingDiscoveryId === selectedDiscovery.id}\n                    className={`rounded bg-blue-600 px-3 py-1.5 text-sm font-medium text-white transition-colors hover:bg-blue-700 disabled:cursor-not-allowed disabled:opacity-50`}\n                  >\n                    {processingDiscoveryId === selectedDiscovery.id ? (\n                      <div className=\"flex items-center\">\n                        <Loader className=\"mr-2 h-4 w-4 animate-spin\" />\n                        Processing... {Math.round(processingProgress)}%\n                      </div>\n                    ) : (\n                      'Process Discovery'\n                    )}\n                  </button>\n                )}\n              </div>\n\n              {/* Discovery info */}\n              <div className=\"mb-4 grid grid-cols-3 gap-4\">\n                <div className=\"bg-gray-750 rounded border border-gray-700 p-3\">\n                  <h3 className=\"mb-1 text-sm font-medium text-gray-300\">Confidence Level</h3>\n                  <div className=\"flex items-end\">\n                    <span className=\"text-2xl font-semibold text-white\">\n                      {Math.round(selectedDiscovery.confidence * 100)}%\n                    </span>\n                  </div>\n                </div>\n\n                <div className=\"bg-gray-750 rounded border border-gray-700 p-3\">\n                  <h3 className=\"mb-1 text-sm font-medium text-gray-300\">Scan Quality</h3>\n                  <div className=\"flex items-end\">\n                    <span className=\"text-2xl font-semibold text-white\">\n                      {Math.round(selectedDiscovery.scanQuality * 100)}%\n                    </span>\n                  </div>\n                </div>\n\n                <div className=\"bg-gray-750 rounded border border-gray-700 p-3\">\n                  <h3 className=\"mb-1 text-sm font-medium text-gray-300\">Raw Signals</h3>\n                  <div className=\"flex items-end\">\n                    <span className=\"text-2xl font-semibold text-white\">\n                      {selectedDiscovery.rawData.length}\n                    </span>\n                  </div>\n                </div>\n              </div>\n\n              {/* Raw signals or processed resources */}\n              <div className=\"mb-4\">\n                <h3 className=\"mb-2 text-lg font-medium text-white\">\n                  {selectedDiscovery.status === 'processed' ? 'Processed Resources' : 'Raw Signals'}\n                </h3>\n\n                <div className=\"bg-gray-750 rounded border border-gray-700 p-3\">\n                  {selectedDiscovery.status === 'processed' && selectedDiscovery.processedData ? (\n                    <div className=\"grid grid-cols-1 gap-3 sm:grid-cols-2\">\n                      {selectedDiscovery.processedData.map((resource, index) => (\n                        <div key={index} className=\"rounded border border-gray-600 bg-gray-800 p-3\">\n                          <div className=\"mb-2 flex items-center\">\n                            {getResourceTypeIcon(resource.type)}\n                            <span className=\"ml-2 font-medium text-white\">{resource.name}</span>\n                          </div>\n\n                          <div className=\"grid grid-cols-2 gap-x-4 gap-y-2 text-sm\">\n                            <div>\n                              <span className=\"text-gray-400\">Type:</span>{' '}\n                              <span className=\"text-white\">{resource.type}</span>\n                            </div>\n                            <div>\n                              <span className=\"text-gray-400\">Amount:</span>{' '}\n                              <span className=\"text-white\">{resource.amount}</span>\n                            </div>\n                            <div>\n                              <span className=\"text-gray-400\">Quality:</span>{' '}\n                              <span className=\"text-white\">\n                                {Math.round(resource.quality * 100)}%\n                              </span>\n                            </div>\n                            <div>\n                              <span className=\"text-gray-400\">Accessibility:</span>{' '}\n                              <span className=\"text-white\">\n                                {Math.round(resource.accessibility * 100)}%\n                              </span>\n                            </div>\n                            <div>\n                              <span className=\"text-gray-400\">Distribution:</span>{' '}\n                              <span className=\"text-white\">{resource.distribution}</span>\n                            </div>\n                            <div>\n                              <span className=\"text-gray-400\">Extraction:</span>{' '}\n                              <span className=\"text-white\">{resource.extractionDifficulty}/10</span>\n                            </div>\n                            <div className=\"col-span-2\">\n                              <span className=\"text-gray-400\">Est. Value:</span>{' '}\n                              <span className=\"text-white\">\n                                {resource.estimatedValue.toLocaleString()} credits\n                              </span>\n                            </div>\n                          </div>\n                        </div>\n                      ))}\n                    </div>\n                  ) : (\n                    <div className=\"grid grid-cols-1 gap-3 sm:grid-cols-2\">\n                      {selectedDiscovery.rawData.map((signal, index) => (\n                        <div key={index} className=\"rounded border border-gray-600 bg-gray-800 p-3\">\n                          <div className=\"mb-2 flex items-center\">\n                            {getResourceTypeIcon(signal.signalType)}\n                            <span className=\"ml-2 font-medium text-white\">\n                              Signal #{index + 1} ({signal.signalType})\n                            </span>\n                          </div>\n\n                          <div className=\"grid grid-cols-2 gap-x-4 gap-y-2 text-sm\">\n                            <div>\n                              <span className=\"text-gray-400\">Strength:</span>{' '}\n                              <span className=\"text-white\">\n                                {Math.round(signal.signalStrength * 100)}%\n                              </span>\n                            </div>\n                            <div>\n                              <span className=\"text-gray-400\">Pattern:</span>{' '}\n                              <span className=\"text-white\">{signal.signalPattern}</span>\n                            </div>\n                            <div>\n                              <span className=\"text-gray-400\">Depth:</span>{' '}\n                              <span className=\"text-white\">\n                                {Math.round(signal.signalDepth * 100)}%\n                              </span>\n                            </div>\n                            <div>\n                              <span className=\"text-gray-400\">Coordinates:</span>{' '}\n                              <span className=\"text-white\">\n                                {signal.coordinates.x.toFixed(1)}, {signal.coordinates.y.toFixed(1)}\n                              </span>\n                            </div>\n                          </div>\n                        </div>\n                      ))}\n                    </div>\n                  )}\n                </div>\n              </div>\n\n              {/* Notes */}\n              <div>\n                <div className=\"mb-2 flex items-center justify-between\">\n                  <h3 className=\"text-lg font-medium text-white\">Notes</h3>\n                  <button\n                    onClick={saveNotes}\n                    className=\"rounded bg-gray-700 px-2 py-1 text-xs text-white hover:bg-gray-600\"\n                  >\n                    Save Notes\n                  </button>\n                </div>\n\n                <textarea\n                  value={notes}\n                  onChange={handleNotesChange}\n                  placeholder=\"Add notes about this discovery...\"\n                  className=\"bg-gray-750 h-32 w-full rounded border border-gray-700 p-2 text-sm text-white placeholder-gray-500\"\n                />\n              </div>\n            </div>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/ResourcePotentialVisualization.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/ResourcePotentialVisualizationDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/ResultsPanel.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/unified/context/ExplorationContext.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/unified/core/BaseAnalysisVisualizer.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/unified/core/BaseDataTable.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/unified/core/BaseMap.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/unified/core/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/unified/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/unified/system/GalaxyExplorationSystem.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/visualizations/AnalysisVisualization.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/visualizations/MemoryOptimizedCharts.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/visualizations/VirtualizedDataTable.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/visualizations/charts/BarChart.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/visualizations/charts/BaseChart.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/visualizations/charts/CanvasChartFactory.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/visualizations/charts/CanvasLineChart.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/visualizations/charts/CanvasScatterPlot.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/visualizations/charts/ClusterVisualization.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/visualizations/charts/HeatMap.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/visualizations/charts/LineChart.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/visualizations/charts/MemoryOptimizedCanvasChart.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/visualizations/charts/PredictionVisualization.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/visualizations/charts/ResourceMappingVisualization.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/visualizations/charts/ScatterPlot.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'ReferenceLinePosition' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 26,
        "column": 6,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 26,
        "endColumn": 27
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import * as React from \"react\";\nimport { useMemo } from 'react';\nimport {\n  CartesianGrid,\n  LabelProps,\n  Legend,\n  ScatterChart as RechartsScatterChart,\n  ReferenceArea,\n  ReferenceLine,\n  Scatter,\n  Tooltip,\n  XAxis,\n  YAxis,\n  ZAxis,\n} from 'recharts';\nimport { DataPoint } from '../../../../types/exploration/DataAnalysisTypes';\nimport {\n  BaseChart,\n  BaseChartProps,\n  DefaultTooltip,\n  formatAxisTick,\n  ReferenceLine as ReferenceLineType,\n} from './BaseChart';\n\n// Define allowed positions for reference line labels\ntype ReferenceLinePosition =\n  | 'top'\n  | 'bottom'\n  | 'left'\n  | 'right'\n  | 'insideTop'\n  | 'insideBottom'\n  | 'insideLeft'\n  | 'insideRight'\n  | 'insideTopRight'\n  | 'insideTopLeft'\n  | 'insideBottomRight'\n  | 'insideBottomLeft'\n  | 'center';\n\n// Define the click event interface\ninterface PointClickEvent {\n  payload: Record<string, unknown>;\n  [key: string]: unknown;\n}\n\nexport interface ScatterPlotProps extends BaseChartProps {\n  /** Key for X-axis values */\n  xAxisKey: string;\n\n  /** Key for Y-axis values */\n  yAxisKey: string;\n\n  /** Optional key for Z-axis values (bubble size) */\n  zAxisKey?: string;\n\n  /** Label for X-axis */\n  xAxisLabel?: string;\n\n  /** Label for Y-axis */\n  yAxisLabel?: string;\n\n  /** Key for point name/label */\n  nameKey?: string;\n\n  /** Whether to show grid lines */\n  showGrid?: boolean;\n\n  /** Point fill color */\n  color?: string;\n\n  /** Size of the points */\n  pointSize?: number;\n\n  /** Minimum for Z-axis size range */\n  zAxisSizeMin?: number;\n\n  /** Maximum for Z-axis size range */\n  zAxisSizeMax?: number;\n\n  /** Optional quadrants to divide the chart */\n  showQuadrants?: boolean;\n\n  /** X-axis value for quadrant division */\n  quadrantXValue?: number;\n\n  /** Y-axis value for quadrant division */\n  quadrantYValue?: number;\n\n  /** Quadrant label configuration */\n  quadrantLabels?: {\n    topRight?: string;\n    topLeft?: string;\n    bottomRight?: string;\n    bottomLeft?: string;\n  };\n\n  /** Whether to show the legends */\n  showLegend?: boolean;\n\n  /** Reference lines to display */\n  referenceLines?: ReferenceLineType[];\n}\n\n/**\n * ScatterPlot component for visualizing correlations between variables\n */\nexport function ScatterPlot({\n  data,\n  xAxisKey,\n  yAxisKey,\n  zAxisKey,\n  width = '100%',\n  height = 400,\n  title,\n  color = '#8884d8',\n  xAxisLabel,\n  yAxisLabel,\n  nameKey,\n  customTooltip,\n  theme = 'light',\n  showGrid = true,\n  pointSize = 10,\n  zAxisSizeMin = 10,\n  zAxisSizeMax = 80,\n  showQuadrants = false,\n  quadrantXValue,\n  quadrantYValue,\n  quadrantLabels = {\n    topRight: 'Top Right',\n    topLeft: 'Top Left',\n    bottomRight: 'Bottom Right',\n    bottomLeft: 'Bottom Left',\n  },\n  showLegend = true,\n  referenceLines = [],\n  className = '',\n  animate = true,\n  onElementClick,\n  errorMessage,\n}: ScatterPlotProps) {\n  // Process data for the chart\n  const processedData = useMemo(() => {\n    if (!data || data.length === 0) return [];\n\n    return data.map(item => {\n      let x, y, z, name;\n\n      // Handle DataPoint objects\n      if ('properties' in item && 'metadata' in item) {\n        const dataPoint = item as DataPoint;\n        const properties = { ...dataPoint.properties };\n        const metadata = dataPoint.metadata || {};\n\n        // Try to find the required values in properties or metadata\n        x = properties[xAxisKey] !== undefined ? properties[xAxisKey] : metadata[xAxisKey];\n        y = properties[yAxisKey] !== undefined ? properties[yAxisKey] : metadata[yAxisKey];\n        z = zAxisKey\n          ? properties[zAxisKey] !== undefined\n            ? properties[zAxisKey]\n            : metadata[zAxisKey]\n          : undefined;\n\n        name = nameKey\n          ? (properties[nameKey] !== undefined ? properties[nameKey] : metadata[nameKey]) ||\n            dataPoint.name\n          : dataPoint.name;\n\n        // Ensure x and y values are numbers\n        x = typeof x === 'number' ? x : parseFloat(String(x)) || 0;\n        y = typeof y === 'number' ? y : parseFloat(String(y)) || 0;\n        z = z && typeof z === 'number' ? z : z ? parseFloat(String(z)) || pointSize : pointSize;\n\n        return {\n          x,\n          y,\n          z,\n          name,\n          id: dataPoint.id,\n          originalData: dataPoint,\n        };\n      }\n      // Handle regular objects\n      else {\n        const record = item as Record<string, unknown>;\n\n        x = record[xAxisKey];\n        y = record[yAxisKey];\n        z = zAxisKey ? record[zAxisKey] : undefined;\n\n        name = nameKey ? record[nameKey] : undefined;\n\n        // Ensure x and y values are numbers\n        x = typeof x === 'number' ? x : parseFloat(String(x)) || 0;\n        y = typeof y === 'number' ? y : parseFloat(String(y)) || 0;\n        z = z && typeof z === 'number' ? z : z ? parseFloat(String(z)) || pointSize : pointSize;\n\n        return {\n          x,\n          y,\n          z,\n          name: name || `(${x}, ${y})`,\n          originalData: record,\n        };\n      }\n    });\n  }, [data, xAxisKey, yAxisKey, zAxisKey, nameKey, pointSize]);\n\n  // If no data, show error\n  if (!data || data.length === 0) {\n    return (\n      <BaseChart\n        width={width}\n        height={height}\n        title={title}\n        theme={theme}\n        className={className}\n        errorMessage={errorMessage || 'No data available'}\n      >\n        <RechartsScatterChart data={[]} />\n      </BaseChart>\n    );\n  }\n\n  // Calculate quadrant values if not provided\n  const xValue =\n    quadrantXValue !== undefined\n      ? quadrantXValue\n      : processedData.reduce((sum, item) => sum + item.x, 0) / processedData.length;\n\n  const yValue =\n    quadrantYValue !== undefined\n      ? quadrantYValue\n      : processedData.reduce((sum, item) => sum + item.y, 0) / processedData.length;\n\n  // Handle click events\n  const handlePointClick = (event: PointClickEvent) => {\n    if (onElementClick && event && event.payload) {\n      onElementClick(event.payload, 0);\n    }\n  };\n\n  // Create the chart content\n  const chartContent = (\n    <RechartsScatterChart margin={{ top: 20, right: 20, bottom: 20, left: 20 }}>\n      {showGrid && <CartesianGrid strokeDasharray=\"3 3\" />}\n\n      <XAxis\n        type=\"number\"\n        dataKey=\"x\"\n        name={xAxisLabel || xAxisKey}\n        label={\n          xAxisLabel ? { value: xAxisLabel, position: 'insideBottom', offset: -10 } : undefined\n        }\n        tickFormatter={value => formatAxisTick(value, false)}\n      />\n\n      <YAxis\n        type=\"number\"\n        dataKey=\"y\"\n        name={yAxisLabel || yAxisKey}\n        label={yAxisLabel ? { value: yAxisLabel, angle: -90, position: 'insideLeft' } : undefined}\n        tickFormatter={value => formatAxisTick(value, false)}\n      />\n\n      {zAxisKey && (\n        <ZAxis type=\"number\" dataKey=\"z\" range={[zAxisSizeMin, zAxisSizeMax]} name={zAxisKey} />\n      )}\n\n      <Tooltip content={customTooltip || <DefaultTooltip />} cursor={{ strokeDasharray: '3 3' }} />\n\n      {showLegend && <Legend />}\n\n      {/* Reference lines for thresholds or important values */}\n      {referenceLines.map((line, i) => (\n        <ReferenceLine\n          key={`ref-line-${i}`}\n          x={line.axis === 'x' ? line.value : undefined}\n          y={line.axis === 'y' ? line.value : undefined}\n          stroke={line.color || '#ff7300'}\n          label={\n            line.label\n              ? ({\n                  value: line.label,\n                  position: line.position || 'center',\n                } as LabelProps)\n              : undefined\n          }\n        />\n      ))}\n\n      {/* Quadrant reference lines */}\n      {showQuadrants && (\n        <>\n          <ReferenceLine x={xValue} stroke=\"#666\" strokeDasharray=\"3 3\" />\n          <ReferenceLine y={yValue} stroke=\"#666\" strokeDasharray=\"3 3\" />\n\n          {/* Quadrant labels */}\n          {quadrantLabels.topRight && (\n            <ReferenceArea\n              x1={xValue}\n              x2=\"auto\"\n              y1={yValue}\n              y2=\"auto\"\n              fillOpacity={0}\n              label={{ value: quadrantLabels.topRight, position: 'insideTopRight' }}\n            />\n          )}\n\n          {quadrantLabels.topLeft && (\n            <ReferenceArea\n              x1={0}\n              x2={xValue}\n              y1={yValue}\n              y2=\"auto\"\n              fillOpacity={0}\n              label={{ value: quadrantLabels.topLeft, position: 'insideTopLeft' }}\n            />\n          )}\n\n          {quadrantLabels.bottomRight && (\n            <ReferenceArea\n              x1={xValue}\n              x2=\"auto\"\n              y1={0}\n              y2={yValue}\n              fillOpacity={0}\n              label={{ value: quadrantLabels.bottomRight, position: 'insideBottomRight' }}\n            />\n          )}\n\n          {quadrantLabels.bottomLeft && (\n            <ReferenceArea\n              x1={0}\n              x2={xValue}\n              y1={0}\n              y2={yValue}\n              fillOpacity={0}\n              label={{ value: quadrantLabels.bottomLeft, position: 'insideBottomLeft' }}\n            />\n          )}\n        </>\n      )}\n\n      <Scatter\n        name={`${xAxisLabel || xAxisKey} vs ${yAxisLabel || yAxisKey}`}\n        data={processedData}\n        fill={color}\n        onClick={(e: PointClickEvent) => handlePointClick(e)}\n        isAnimationActive={animate}\n      />\n    </RechartsScatterChart>\n  );\n\n  return (\n    <BaseChart\n      width={width}\n      height={height}\n      title={title}\n      theme={theme}\n      className={className}\n      errorMessage={errorMessage}\n    >\n      {chartContent}\n    </BaseChart>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/visualizations/charts/TooltipAdapter.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/visualizations/charts/ViewportOptimizedHeatMap.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/visualizations/charts/ViewportOptimizedScatterPlot.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/visualizations/charts/VirtualizedLineChart.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/visualizations/charts/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/visualizations/withMemoryManagement.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'cacheExpirationTime' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 55,
        "column": 7,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 55,
        "endColumn": 26
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
        "line": 68,
        "column": 9,
        "nodeType": "MemberExpression",
        "messageId": "limited",
        "endLine": 68,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "log" },
            "fix": { "range": [1846, 1983], "text": "" },
            "desc": "Remove the console.log()."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { ComponentType, useEffect, useState } from 'react';\nimport { BaseChartProps } from './charts/BaseChart';\n\n/**\n * Options for memory management behavior\n */\ninterface MemoryOptions {\n  /** Show memory usage statistics */\n  showMemoryStats?: boolean;\n\n  /** Memory threshold in bytes */\n  memoryThreshold?: number;\n\n  /** Whether to log memory usage to console */\n  enableLogging?: boolean;\n\n  /** Auto cleanup level, controlling aggressiveness of cleanup */\n  autoCleanupLevel?: 'none' | 'low' | 'medium' | 'high';\n\n  /** Time in milliseconds for cache expiration */\n  cacheExpirationTime?: number;\n}\n\n/**\n * Simple function to estimate data size\n */\nfunction estimateSize(data: unknown): number {\n  if (data === null || data === undefined) return 0;\n\n  if (Array.isArray(data)) {\n    return data.length * 1024; // Estimate 1KB per array item\n  }\n\n  if (typeof data === 'object') {\n    return Object.keys(data).length * 1024; // Estimate 1KB per object property\n  }\n\n  return 1024; // Default size for primitives\n}\n\n/**\n * Higher-order component that adds memory management to visualization components\n */\nexport function withMemoryManagement<P extends BaseChartProps>(\n  WrappedComponent: ComponentType<P>,\n  options: MemoryOptions = {}\n): ComponentType<P> {\n  const ManagedComponent = (props: P) => {\n    // Default options\n    const {\n      showMemoryStats = false,\n      memoryThreshold = 50 * 1024 * 1024,\n      enableLogging = false,\n      autoCleanupLevel = 'medium',\n      cacheExpirationTime = 5 * 60 * 1000,\n    } = options;\n\n    // Track memory usage\n    const [memoryUsage, setMemoryUsage] = useState<number>(0);\n\n    // Update memory usage when props change\n    useEffect(() => {\n      const size = estimateSize(props.data);\n      setMemoryUsage(size);\n\n      // Log memory usage if enabled\n      if (enableLogging) {\n        console.log(\n          `[MemoryManager] Memory usage: ${Math.round(size / 1024 / 1024)}MB, Cleanup level: ${autoCleanupLevel}`\n        );\n      }\n    }, [props.data, enableLogging, autoCleanupLevel]);\n\n    // Calculate memory usage in MB for display\n    const memoryMB = Math.round(memoryUsage / 1024 / 1024);\n\n    // Check if memory usage exceeds threshold\n    const isAboveThreshold = memoryUsage > memoryThreshold;\n\n    return (\n      <div style={{ position: 'relative', width: '100%', height: '100%' }}>\n        <WrappedComponent {...props} />\n\n        {showMemoryStats && (\n          <div\n            style={{\n              position: 'absolute',\n              bottom: 5,\n              right: 5,\n              fontSize: '0.75rem',\n              opacity: 0.7,\n              backgroundColor: isAboveThreshold ? 'rgba(255,200,200,0.8)' : 'rgba(200,200,200,0.8)',\n              padding: '2px 5px',\n              borderRadius: '3px',\n            }}\n          >\n            Memory: {memoryMB}MB\n          </div>\n        )}\n      </div>\n    );\n  };\n\n  // Set display name for better debugging\n  const wrappedName = WrappedComponent.displayName || WrappedComponent.name || 'Component';\n  ManagedComponent.displayName = `WithMemory(${wrappedName})`;\n\n  return ManagedComponent;\n}\n\nexport default withMemoryManagement;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/factions/FactionAI.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/factions/FactionManager.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/performance/DeviceCapabilityReport.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/performance/GeographicAnalysisDashboard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/performance/LongSessionMemoryVisualizer.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/providers/ServiceProvider.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/FactionShips/FactionDashboard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/FactionShips/equatorHorizon/CelestialArbiter.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/FactionShips/equatorHorizon/EtherealGalleon.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/FactionShips/equatorHorizon/StellarEquinox.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/FactionShips/lostNova/DarkMatterReaper.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/FactionShips/lostNova/EclipseScythe.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/FactionShips/lostNova/NullHunter.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/FactionShips/spaceRats/AsteroidMarauder.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/FactionShips/spaceRats/RatKing.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/FactionShips/spaceRats/RogueNebula.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/base/BaseShip.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/common/CommonShipMovement.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/common/CommonShipStats.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/common/EquatorHorizonShip.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/common/FactionFleet.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/common/FactionShipBase.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/common/FactionShipStats.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/common/LostNovaShip.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/common/SpaceRatShip.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/player/adapters/ShipAdapter.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/player/base/PlayerShipBase.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/player/base/PlayerShipStats.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/player/customization/PlayerShipCustomization.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/player/customization/PlayerShipUpgrade.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/player/customization/PlayerShipUpgradeSystem.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/player/variants/miningships/VoidDredgerMiner.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/player/variants/reconships/ReconShipControl.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/player/variants/reconships/ReconShipStatus.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/player/variants/warships/HarbringerGalleon.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/player/variants/warships/MidwayCarrier.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/player/variants/warships/MotherEarthRevenge.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/player/variants/warships/OrionFrigate.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/player/variants/warships/PlayerWarShipCombat.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/player/variants/warships/Spitflare.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/player/variants/warships/StarSchooner.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/player/variants/warships/WarShip.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/trade/TradeRouteVisualizer.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/Button.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/Card.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/ContextMenu.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/DiplomacyPanel.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/DragAndDrop.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'ResourceType' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 1,
        "column": 10,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 1,
        "endColumn": 22
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { ResourceType } from \"./../../types/resources/ResourceTypes\";\n/** @jsx React.createElement */\n/** @jsxFrag React.Fragment */\nimport * as React from \"react\";\nimport { useEffect, useRef, useState } from 'react';\n\nexport interface DragItem<T = Record<string, unknown>> {\n  id: string;\n  type: 'module' | 'resource' | 'ship';\n  data: T;\n}\n\ninterface DragPreviewProps<T = Record<string, unknown>> {\n  item: DragItem<T>;\n  currentOffset: { x: number; y: number };\n}\n\nfunction DragPreview<T = Record<string, unknown>>({ item, currentOffset }: DragPreviewProps<T>) {\n  // Extract properties safely with type assertions\n  const name =\n    item.type === 'module' || item.type === 'ship'\n      ? String((item.data as Record<string, unknown>).name || '')\n      : '';\n\n  const amount =\n    item.type === 'resource' ? String((item.data as Record<string, unknown>).amount || '') : '';\n\n  const resourceType =\n    item.type === 'resource' ? String((item.data as Record<string, unknown>).type || '') : '';\n\n  return (\n    <div\n      className=\"pointer-events-none fixed z-50 opacity-75\"\n      style={{\n        left: currentOffset.x,\n        top: currentOffset.y,\n        transform: 'translate(-50%, -50%)',\n      }}\n    >\n      <div className=\"rounded-lg border border-gray-700 bg-gray-900/90 px-4 py-2 text-white backdrop-blur-sm\">\n        {item.type === 'module' && <span>📦 {name}</span>}\n        {item.type === 'resource' && (\n          <span>\n            💎 {amount} {resourceType}\n          </span>\n        )}\n        {item.type === 'ship' && <span>🚀 {name}</span>}\n      </div>\n    </div>\n  );\n}\n\ninterface DropTargetProps<T = Record<string, unknown>> {\n  accept: string[];\n  onDrop: (item: DragItem<T>) => void;\n  children: React.ReactNode;\n  className?: string;\n}\n\nexport function DropTarget<T = Record<string, unknown>>({\n  accept,\n  onDrop,\n  children,\n  className = '',\n}: DropTargetProps<T>) {\n  const [isOver, setIsOver] = useState(false);\n  const ref = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    const handleDragOver = (e: DragEvent) => {\n      e.preventDefault();\n      if (e.dataTransfer && accept.includes(JSON.parse(e.dataTransfer.getData('text')).type)) {\n        setIsOver(true);\n      }\n    };\n\n    const handleDragLeave = () => {\n      setIsOver(false);\n    };\n\n    const handleDrop = (e: DragEvent) => {\n      e.preventDefault();\n      setIsOver(false);\n      if (e.dataTransfer) {\n        const item = JSON.parse(e.dataTransfer.getData('text')) as DragItem<T>;\n        if (accept.includes(item.type)) {\n          onDrop(item);\n        }\n      }\n    };\n\n    const element = ref.current;\n    if (element) {\n      element.addEventListener('dragover', handleDragOver);\n      element.addEventListener('dragleave', handleDragLeave);\n      element.addEventListener('drop', handleDrop);\n\n      return () => {\n        element.removeEventListener('dragover', handleDragOver);\n        element.removeEventListener('dragleave', handleDragLeave);\n        element.removeEventListener('drop', handleDrop);\n      };\n    }\n  }, [accept, onDrop]);\n\n  return (\n    <div\n      ref={ref}\n      className={`${className} ${isOver ? 'ring-2 ring-cyan-500 ring-opacity-50' : ''}`}\n    >\n      {children}\n    </div>\n  );\n}\n\ninterface DraggableProps<T = Record<string, unknown>> {\n  item: DragItem<T>;\n  children: React.ReactNode;\n  className?: string;\n  onDragStart?: () => void;\n  onDragEnd?: () => void;\n}\n\nexport function Draggable<T = Record<string, unknown>>({\n  item,\n  children,\n  className = '',\n  onDragStart,\n  onDragEnd,\n}: DraggableProps<T>) {\n  const handleDragStart = (e: React.DragEvent) => {\n    e.dataTransfer.setData('text', JSON.stringify(item));\n    onDragStart?.();\n  };\n\n  const handleDragEnd = () => {\n    onDragEnd?.();\n  };\n\n  return (\n    <div\n      draggable\n      onDragStart={handleDragStart}\n      onDragEnd={handleDragEnd}\n      className={`${className} cursor-grab active:cursor-grabbing`}\n    >\n      {children}\n    </div>\n  );\n}\n\ninterface UseDragAndDropProps<T = Record<string, unknown>> {\n  onDrop?: (item: DragItem<T>, target: HTMLElement) => void;\n}\n\nexport function useDragAndDrop<T = Record<string, unknown>>({\n  onDrop,\n}: UseDragAndDropProps<T> = {}) {\n  const [draggedItem, setDraggedItem] = useState<DragItem<T> | null>(null);\n  const [dragPosition, setDragPosition] = useState<{ x: number; y: number }>({ x: 0, y: 0 });\n\n  useEffect(() => {\n    const handleMouseMove = (e: MouseEvent) => {\n      if (draggedItem) {\n        setDragPosition({ x: e.clientX, y: e.clientY });\n      }\n    };\n\n    document.addEventListener('mousemove', handleMouseMove);\n    return () => document.removeEventListener('mousemove', handleMouseMove);\n  }, [draggedItem]);\n\n  const handleDragStart = (item: DragItem<T>) => {\n    setDraggedItem(item);\n  };\n\n  const handleDragEnd = () => {\n    setDraggedItem(null);\n  };\n\n  const handleDrop = (item: DragItem<T>, target: HTMLElement) => {\n    onDrop?.(item, target);\n    setDraggedItem(null);\n  };\n\n  return {\n    draggedItem,\n    dragPosition,\n    handleDragStart,\n    handleDragEnd,\n    handleDrop,\n    DragPreviewComponent: draggedItem ? (\n      <DragPreview item={draggedItem} currentOffset={dragPosition} />\n    ) : null,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/GalaxyMap.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/GameHUD.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'MenuItem' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 35,
        "column": 11,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 35,
        "endColumn": 19
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import {\n  AlertTriangle,\n  Crown,\n  Database,\n  Info,\n  Map as MapIcon,\n  Rocket,\n  Settings,\n  Terminal,\n  X,\n} from 'lucide-react';\nimport * as React from 'react';\nimport { useCallback, useEffect, useMemo, useState } from 'react';\nimport { v4 as uuidv4 } from 'uuid';\nimport { GameActionType, useGameDispatch, useGameState } from '../../contexts/GameContext';\nimport { ModuleActionType, useModuleDispatch, useModules } from '../../contexts/ModuleContext';\nimport { useVPRSystem } from '../../hooks/ui/useVPRSystem';\nimport { moduleEventBus } from '../../lib/modules/ModuleEvents';\nimport { moduleManager } from '../../managers/module/ModuleManager';\nimport { ModuleType } from '../../types/buildings/ModuleTypes';\nimport { Position } from '../../types/core/GameTypes';\nimport { Module } from '../../types/modules/ModuleTypes';\nimport { ResourceType } from './../../types/resources/ResourceTypes';\nimport { NotificationSystem, notificationManager } from './NotificationSystem';\nimport ResourceVisualization from './ResourceVisualization';\n\ninterface GameHUDProps {\n  empireName: string;\n  onToggleSprawlView: () => void;\n  onToggleVPRView: () => void;\n}\n\ntype MenuCategory = 'mining' | 'exploration' | 'mothership' | 'colony';\n\ninterface MenuItem {\n  id: string;\n  name: string;\n  description: string;\n  action: () => void;\n  moduleType?: ModuleType;\n  cost?: {\n    minerals?: number;\n    energy?: number;\n  };\n}\n\n/**\n * Custom notification interface for future implementation\n *\n * This interface will be used in future implementations to:\n * 1. Create a custom notification system with more advanced features\n * 2. Support different notification types beyond the current system\n * 3. Enable notification grouping and prioritization\n * 4. Add interactive elements to notifications\n * 5. Support notification persistence and history\n *\n * @deprecated This interface is not currently used but will be implemented\n * in the upcoming notification system upgrade. It is kept here for reference.\n */\ninterface _Notification {\n  id: string;\n  type: 'success' | 'error';\n  message: string;\n}\n\n// Use the _Notification interface in a function to prevent \"unused\" error\n/**\n * Creates a notification object using the _Notification interface.\n * This function will be used in the future notification system upgrade.\n *\n * @param type - The type of notification ('success' or 'error')\n * @param message - The notification message\n * @returns A notification object conforming to the _Notification interface\n * @deprecated This function is not currently used but will be implemented\n * in the upcoming notification system upgrade. It is kept here for reference.\n */\n\nfunction _createNotification(type: 'success' | 'error', message: string): _Notification {\n  return {\n    id: `notification-${Date.now()}`,\n    type,\n    message,\n  };\n}\n\n// Category color mapping\nconst categoryColors: Record<MenuCategory, { bg: string; border: string; hover: string }> = {\n  mining: {\n    bg: 'from-amber-900/90 to-amber-800/80',\n    border: 'border-amber-700/50',\n    hover: 'hover:bg-amber-800/50 hover:border-amber-600/50',\n  },\n  exploration: {\n    bg: 'from-blue-900/90 to-blue-800/80',\n    border: 'border-blue-700/50',\n    hover: 'hover:bg-blue-800/50 hover:border-blue-600/50',\n  },\n  mothership: {\n    bg: 'from-indigo-900/90 to-indigo-800/80',\n    border: 'border-indigo-700/50',\n    hover: 'hover:bg-indigo-800/50 hover:border-indigo-600/50',\n  },\n  colony: {\n    bg: 'from-green-900/90 to-green-800/80',\n    border: 'border-green-700/50',\n    hover: 'hover:bg-green-800/50 hover:border-green-600/50',\n  },\n};\n\n// Category icons\nconst categoryIcons: Record<MenuCategory, React.ReactNode> = {\n  mining: <Database size={18} />,\n  exploration: <MapIcon size={18} />,\n  mothership: <Rocket size={18} />,\n  colony: <Crown size={18} />,\n};\n\nexport function GameHUD({ empireName, onToggleSprawlView, onToggleVPRView }: GameHUDProps) {\n  const [activeCategory, setActiveCategory] = useState<MenuCategory | null>(null);\n  const [showTechTree, setShowTechTree] = useState(false);\n  const [showSettings, setShowSettings] = useState(false);\n  const [showTooltip, setShowTooltip] = useState<{ id: string; x: number; y: number } | null>(null);\n\n  // Get contexts\n  const gameState = useGameState(state => state);\n  const gameDispatch = useGameDispatch();\n  const moduleState = useModules(state => state);\n  const moduleDispatch = useModuleDispatch();\n  const vprSystem = useVPRSystem();\n\n  // Ensure contexts are available\n  if (!gameState || !moduleState) {\n    return null;\n  }\n\n  // Check if a module can be built based on resources and available attachment points\n  const canBuildModule = (\n    moduleType: ModuleType,\n    cost: { minerals?: number; energy?: number }\n  ): boolean => {\n    console.warn('Checking if can build module:', moduleType, cost);\n\n    // Check resources\n    const hasResources =\n      (cost.minerals || 0) <= gameState.resources.minerals &&\n      (cost.energy || 0) <= gameState.resources.energy;\n\n    if (!hasResources) {\n      console.warn('Not enough resources to build module');\n      return false;\n    }\n\n    // Find a suitable building and attachment point\n    for (const building of moduleState.buildings) {\n      for (const point of building.attachmentPoints) {\n        if (point.allowedTypes.includes(moduleType) && !point.currentModule) {\n          console.warn('Found suitable attachment point for module');\n          return true;\n        }\n      }\n    }\n\n    console.warn('No suitable attachment point found for module');\n    return false;\n  };\n\n  // Updated buildModuleLocally function with improved error handling and logging\n  const buildModuleLocally = (\n    moduleType: ModuleType,\n    cost: { minerals?: number; energy?: number }\n  ): boolean => {\n    console.warn('Building module:', moduleType, cost);\n\n    if (!moduleDispatch) {\n      console.error('Module context dispatch is not available');\n      return false;\n    }\n\n    // Find a suitable building and attachment point\n    let targetBuilding = undefined;\n    let targetPoint = undefined;\n\n    // Get first available building with a suitable attachment point\n    for (const building of moduleState.buildings) {\n      for (const point of building.attachmentPoints) {\n        if (point.allowedTypes.includes(moduleType) && !point.currentModule) {\n          targetBuilding = building;\n          targetPoint = point.id;\n          break;\n        }\n      }\n      if (targetBuilding && targetPoint) {\n        break;\n      }\n    }\n\n    if (!targetBuilding || !targetPoint) {\n      console.error('No suitable attachment point found for module:', moduleType);\n      return false;\n    }\n\n    // Create and attach the module\n    const position: Position = targetBuilding.attachmentPoints.find(p => p.id === targetPoint)\n      ?.position || {\n      x: 0,\n      y: 0,\n    };\n\n    console.warn('Creating module at position:', position);\n\n    try {\n      // Create the module\n      const module: Module = {\n        id: uuidv4(),\n        name: `${moduleType} Module`,\n        type: moduleType,\n        position,\n        status: 'active',\n        isActive: true,\n        level: 1,\n      };\n\n      moduleDispatch({\n        type: ModuleActionType.ADD_MODULE,\n        payload: {\n          module,\n        },\n      });\n\n      // Get the newly created module's ID (it will be the last one created)\n      const newModule = moduleManager.getModulesByType(moduleType).pop();\n      if (!newModule) {\n        console.error('Failed to create module:', moduleType);\n        return false;\n      }\n\n      console.warn('Created module:', newModule);\n\n      // Attach the module\n      moduleDispatch({\n        type: ModuleActionType.UPDATE_MODULE,\n        payload: {\n          moduleId: newModule.id,\n          updates: {\n            buildingId: targetBuilding.id,\n            attachmentPointId: targetPoint,\n          },\n        },\n      });\n\n      // Activate the module\n      moduleDispatch({\n        type: ModuleActionType.SET_ACTIVE_MODULES,\n        payload: {\n          activeModuleIds: [...moduleState.activeModuleIds, newModule.id],\n        },\n      });\n\n      // Register with VPR system for visualization if it's a relevant type\n      if (\n        vprSystem &&\n        ['exploration', 'mining', 'colony', 'hangar', 'mineral', 'resource-manager'].includes(\n          moduleType\n        )\n      ) {\n        // Map module type to VPR type\n        const vprType =\n          moduleType === 'exploration'\n            ? 'exploration'\n            : moduleType === 'hangar'\n              ? 'mining'\n              : moduleType === 'mineral'\n                ? 'mining'\n                : moduleType === 'resource-manager'\n                  ? 'colony'\n                  : 'mothership';\n\n        // Use the new addModule function to add the module to the VPR system\n        vprSystem.addModule(newModule.id, vprType, 1, 'active');\n\n        // Emit an event to notify the system of the new module\n        moduleEventBus.emit({\n          type: 'MODULE_UPDATED',\n          moduleId: newModule.id,\n          moduleType: moduleType,\n          timestamp: Date.now(),\n          data: {\n            vprRegistered: true,\n            vprType: vprType,\n          },\n        });\n      }\n\n      console.warn(`Successfully built module of type ${moduleType} with ID ${newModule.id}`);\n      return true;\n    } catch (error) {\n      console.error('Error building module:', error);\n      return false;\n    }\n  };\n\n  // Add notification\n  const addNotification = (\n    type: 'success' | 'error' | 'info' | 'warning',\n    title: string,\n    message: string\n  ): void => {\n    // Current implementation using the notification manager\n    notificationManager.show({\n      title,\n      message,\n      type,\n    });\n  };\n\n  // Toggle tech tree\n  const toggleTechTree = () => {\n    setShowTechTree(!showTechTree);\n  };\n\n  // Toggle settings\n  const toggleSettings = () => {\n    setShowSettings(!showSettings);\n  };\n\n  // Add keyboard shortcuts for menu navigation\n  const handleKeyDown = useCallback(\n    (event: KeyboardEvent) => {\n      // Mapping keys to categories\n      const keyMap: Record<string, MenuCategory> = {\n        m: 'mining',\n        e: 'exploration',\n        h: 'mothership',\n        c: 'colony',\n      };\n\n      // Function keys mapping\n      if (event.key === 'F1') {\n        toggleTechTree();\n        return;\n      }\n\n      if (event.key === 'F2') {\n        toggleSettings();\n        return;\n      }\n\n      // Alt + key combinations for categories\n      if (event.altKey && keyMap[event.key]) {\n        setActiveCategory(keyMap[event.key]);\n        event.preventDefault();\n      }\n\n      // Escape key to close active category\n      if (event.key === 'Escape' && activeCategory) {\n        setActiveCategory(null);\n        event.preventDefault();\n      }\n    },\n    [activeCategory, toggleTechTree, toggleSettings]\n  );\n\n  // Set up keyboard shortcut listeners\n  useEffect(() => {\n    window.addEventListener('keydown', handleKeyDown);\n    return () => {\n      window.removeEventListener('keydown', handleKeyDown);\n    };\n  }, [handleKeyDown]);\n\n  // Resource status indicators\n  const getResourceStatus = useCallback((current: number, min: number, max: number) => {\n    if (current < min) {\n      return {\n        status: 'critical',\n        color: 'text-red-400',\n        icon: <AlertTriangle size={14} className=\"text-red-400\" />,\n      };\n    } else if (current > max) {\n      return {\n        status: 'abundant',\n        color: 'text-green-400',\n        icon: <Info size={14} className=\"text-green-400\" />,\n      };\n    } else {\n      return { status: 'normal', color: 'text-gray-300', icon: null };\n    }\n  }, []);\n\n  // Enhanced tooltip display\n  const renderTooltip = () => {\n    if (!showTooltip) return null;\n\n    const menuCategory = Object.keys(menuItems).find(category =>\n      menuItems[category as MenuCategory].some(item => item.id === showTooltip.id)\n    ) as MenuCategory | undefined;\n\n    if (!menuCategory) return null;\n\n    const menuItem = menuItems[menuCategory].find(item => item.id === showTooltip.id);\n    if (!menuItem) return null;\n\n    const canBuild =\n      menuItem.moduleType && menuItem.cost\n        ? canBuildModule(menuItem.moduleType, menuItem.cost)\n        : false;\n\n    return (\n      <div\n        className=\"absolute z-50 w-72 rounded-lg border border-gray-700 bg-gray-800 p-3 shadow-lg\"\n        style={{ top: showTooltip.y + 10, left: showTooltip.x }}\n      >\n        <h4 className=\"text-md font-semibold text-white\">{menuItem.name}</h4>\n        <p className=\"mt-1 text-sm text-gray-300\">{menuItem.description}</p>\n\n        {menuItem.cost && (\n          <div className=\"mt-2 space-y-1 text-sm\">\n            <h5 className=\"font-medium text-gray-200\">Required Resources:</h5>\n            <div className=\"flex justify-between\">\n              {menuItem.cost.minerals && (\n                <div\n                  className={`flex items-center space-x-1 ${\n                    gameState.resources.minerals >= menuItem.cost.minerals\n                      ? 'text-amber-300'\n                      : 'text-red-400'\n                  }`}\n                >\n                  <span>Minerals:</span>\n                  <span className=\"font-medium\">{menuItem.cost.minerals}</span>\n                </div>\n              )}\n              {menuItem.cost.energy && (\n                <div\n                  className={`flex items-center space-x-1 ${\n                    gameState.resources.energy >= menuItem.cost.energy\n                      ? 'text-cyan-300'\n                      : 'text-red-400'\n                  }`}\n                >\n                  <span>Energy:</span>\n                  <span className=\"font-medium\">{menuItem.cost.energy}</span>\n                </div>\n              )}\n            </div>\n          </div>\n        )}\n\n        <div className=\"mt-3 text-sm\">\n          <span className={`font-medium ${canBuild ? 'text-green-400' : 'text-red-400'}`}>\n            {canBuild ? 'Available to build' : 'Cannot build'}\n          </span>\n        </div>\n      </div>\n    );\n  };\n\n  // Define menu items with actions\n  const getMenuItems = () => {\n    return {\n      mining: [\n        {\n          id: 'mineral-processing',\n          name: 'Mineral Processing',\n          description: 'Process raw minerals and manage resource extraction',\n          moduleType: 'mineral' as ModuleType,\n          cost: {\n            minerals: 500,\n            energy: 300,\n          },\n          action: () => {},\n        },\n        {\n          id: 'mining-fleet',\n          name: 'Mining Fleet',\n          description: 'Manage mining ships and automated resource collection',\n          moduleType: 'hangar' as ModuleType,\n          cost: {\n            minerals: 400,\n            energy: 200,\n          },\n          action: () => {},\n        },\n        {\n          id: 'resource-storage',\n          name: 'Resource Storage',\n          description: 'Monitor and manage resource stockpiles',\n          moduleType: 'resource-manager' as ModuleType,\n          cost: {\n            minerals: 300,\n            energy: 100,\n          },\n          action: () => {},\n        },\n      ],\n      exploration: [\n        {\n          id: 'recon-hub',\n          name: 'Recon Hub',\n          description: 'Coordinate exploration missions and scout ships',\n          moduleType: 'exploration' as ModuleType,\n          cost: {\n            minerals: 400,\n            energy: 300,\n          },\n          action: () => {},\n        },\n        {\n          id: 'galaxy-map',\n          name: 'Galaxy Map',\n          description: 'View and analyze discovered sectors',\n          moduleType: 'radar' as ModuleType,\n          cost: {\n            minerals: 200,\n            energy: 400,\n          },\n          action: () => {},\n        },\n      ],\n      mothership: [\n        {\n          id: 'command-center',\n          name: 'Command Center',\n          description: 'Central command and control for your mothership',\n          moduleType: 'hangar' as ModuleType,\n          cost: {\n            minerals: 600,\n            energy: 500,\n          },\n          action: () => {},\n        },\n        {\n          id: 'research-lab',\n          name: 'Research Lab',\n          description: 'Research new technologies and upgrades',\n          moduleType: ResourceType.RESEARCH as ModuleType,\n          cost: {\n            minerals: 500,\n            energy: 600,\n          },\n          action: () => {},\n        },\n      ],\n      colony: [\n        {\n          id: 'habitat-dome',\n          name: 'Habitat Dome',\n          description: 'Living quarters for your colonists',\n          moduleType: 'resource-manager' as ModuleType,\n          cost: {\n            minerals: 500,\n            energy: 400,\n          },\n          action: () => {},\n        },\n        {\n          id: 'trade-hub',\n          name: 'Trade Hub',\n          description: 'Establish and monitor trade routes',\n          moduleType: 'trading' as ModuleType,\n          cost: {\n            minerals: 400,\n            energy: 300,\n          },\n          action: () => {},\n        },\n      ],\n    };\n  };\n\n  // Update the getUpdateMenuItems function to properly implement actions\n  const getUpdatedMenuItems = () => {\n    const menuItems = getMenuItems();\n\n    // Add the real actions\n    Object.keys(menuItems).forEach(category => {\n      menuItems[category as MenuCategory] = menuItems[category as MenuCategory].map(item => ({\n        ...item,\n        action: () => {\n          console.warn(`Attempting to build ${item.name}...`);\n          if (item.moduleType && item.cost) {\n            if (canBuildModule(item.moduleType, item.cost)) {\n              // Actually build the module using our local implementation\n              const success = buildModuleLocally(item.moduleType, item.cost);\n\n              if (success) {\n                // Update resources in game state\n                gameDispatch({\n                  type: GameActionType.UPDATE_RESOURCES,\n                  payload: {\n                    minerals: gameState.resources.minerals - (item.cost?.minerals || 0),\n                    energy: gameState.resources.energy - (item.cost?.energy || 0),\n                  },\n                });\n\n                // Show success notification\n                addNotification(\n                  'success',\n                  `Successfully built ${item.name}`,\n                  `Your ${item.name} module is now operational.`\n                );\n\n                console.warn(`Successfully built ${item.name}!`);\n\n                // Activate the appropriate view based on module type\n                if (category === 'mining') {\n                  onToggleSprawlView();\n                } else if (category === 'exploration') {\n                  onToggleVPRView();\n                }\n              } else {\n                // Show error notification if building failed\n                addNotification(\n                  'error',\n                  `Failed to build ${item.name}`,\n                  `Technical error occurred while building ${item.name}. Please try again.`\n                );\n              }\n            } else {\n              // Show error notification\n              const missingResources = [];\n              if ((item.cost?.minerals || 0) > gameState.resources.minerals) {\n                missingResources.push(\n                  `${item.cost?.minerals - gameState.resources.minerals} minerals`\n                );\n              }\n              if ((item.cost?.energy || 0) > gameState.resources.energy) {\n                missingResources.push(`${item.cost?.energy - gameState.resources.energy} energy`);\n              }\n\n              const resourceMessage =\n                missingResources.length > 0\n                  ? `You need ${missingResources.join(' and ')} more.`\n                  : 'No suitable attachment point available.';\n\n              addNotification(\n                'error',\n                `Cannot build ${item.name}`,\n                `Insufficient resources to build ${item.name}. ${resourceMessage}`\n              );\n            }\n          }\n        },\n      }));\n    });\n\n    return menuItems;\n  };\n\n  // Get menu items with actions\n  const menuItems = getUpdatedMenuItems();\n\n  // Enhanced UI for the category style with better visual feedback\n  const getCategoryStyle = (category: MenuCategory) => {\n    const baseStyle =\n      'flex w-full items-center rounded-lg border px-4 py-2 transition-colors duration-200';\n    const activeStyle = `${baseStyle} ${categoryColors[category].border} bg-gradient-to-r ${categoryColors[category].bg} text-white shadow-md`;\n    const inactiveStyle = `${baseStyle} border-gray-700/50 bg-gray-800/30 text-gray-300 hover:bg-gray-700/40 hover:border-gray-600/50`;\n\n    return activeCategory === category ? activeStyle : inactiveStyle;\n  };\n\n  // Resource statistics for basic display\n  const resourceStats = useMemo(\n    () => ({\n      minerals: {\n        currentAmount: gameState.resources.minerals,\n        minThreshold: 200,\n        maxThreshold: 2000,\n        maxCapacity: 3000,\n        extractionRate: gameState.resourceRates?.minerals || 0,\n      },\n      energy: {\n        currentAmount: gameState.resources.energy,\n        minThreshold: 100,\n        maxThreshold: 1500,\n        maxCapacity: 2000,\n        extractionRate: gameState.resourceRates?.energy || 0,\n      },\n    }),\n    [gameState.resources, gameState.resourceRates]\n  );\n\n  // Display resource warnings based on thresholds\n  useEffect(() => {\n    if (\n      resourceStats.minerals.currentAmount < resourceStats.minerals.minThreshold ||\n      resourceStats.energy.currentAmount < resourceStats.energy.minThreshold\n    ) {\n      // Only show the warning if it's critical (less than half of the min threshold)\n      if (\n        resourceStats.minerals.currentAmount < resourceStats.minerals.minThreshold / 2 ||\n        resourceStats.energy.currentAmount < resourceStats.energy.minThreshold / 2\n      ) {\n        addNotification(\n          'error',\n          'Critical Resource Shortage',\n          'Resources are critically low. Prioritize resource collection immediately.'\n        );\n      } else {\n        addNotification(\n          'warning',\n          'Low Resources',\n          'Resource levels are getting low. Consider increasing production.'\n        );\n      }\n    }\n  }, [resourceStats]);\n\n  // Render the component\n  return (\n    <div className=\"flex h-screen flex-col overflow-hidden rounded-lg border border-gray-800 bg-gray-900 bg-opacity-80 shadow-lg\">\n      {/* Top bar with empire name and resource visualization */}\n      <div className=\"flex items-center justify-between border-b border-gray-700 bg-gray-800 bg-opacity-50 px-4 py-3\">\n        <div className=\"flex items-center\">\n          <h1 className=\"text-xl font-bold text-white\">{empireName}</h1>\n          <div className=\"ml-4 rounded-md bg-gray-700 bg-opacity-50 px-3 py-1\">\n            <div className=\"flex items-center space-x-4 text-sm\">\n              <div className=\"flex items-center\">\n                <span className=\"font-medium text-amber-300\">\n                  Minerals: {gameState.resources.minerals}\n                </span>\n                {resourceStats.minerals.extractionRate !== 0 && (\n                  <span\n                    className={`ml-1 text-xs ${resourceStats.minerals.extractionRate > 0 ? 'text-green-400' : 'text-red-400'}`}\n                  >\n                    ({resourceStats.minerals.extractionRate > 0 ? '+' : ''}\n                    {resourceStats.minerals.extractionRate}/s)\n                  </span>\n                )}\n                {\n                  getResourceStatus(\n                    resourceStats.minerals.currentAmount,\n                    resourceStats.minerals.minThreshold,\n                    resourceStats.minerals.maxThreshold\n                  ).icon\n                }\n              </div>\n              <span className=\"text-gray-400\">|</span>\n              <div className=\"flex items-center\">\n                <span className=\"font-medium text-cyan-300\">\n                  Energy: {gameState.resources.energy}\n                </span>\n                {resourceStats.energy.extractionRate !== 0 && (\n                  <span\n                    className={`ml-1 text-xs ${resourceStats.energy.extractionRate > 0 ? 'text-green-400' : 'text-red-400'}`}\n                  >\n                    ({resourceStats.energy.extractionRate > 0 ? '+' : ''}\n                    {resourceStats.energy.extractionRate}/s)\n                  </span>\n                )}\n                {\n                  getResourceStatus(\n                    resourceStats.energy.currentAmount,\n                    resourceStats.energy.minThreshold,\n                    resourceStats.energy.maxThreshold\n                  ).icon\n                }\n              </div>\n            </div>\n          </div>\n        </div>\n        <ResourceVisualization type={ResourceType.MINERALS} value={gameState.resources.minerals} />\n        <ResourceVisualization type={ResourceType.ENERGY} value={gameState.resources.energy} />\n      </div>\n      {/* Main content with menu and active panel */}\n      <div className=\"flex flex-1 overflow-hidden\">\n        {/* Left menu with categories */}\n        <div className=\"flex w-64 flex-col overflow-y-auto border-r border-gray-800 bg-gray-900 bg-opacity-60\">\n          {/* Menu categories */}\n          <div className=\"space-y-2 p-4\">\n            {Object.keys(menuItems).map(category => (\n              <button\n                key={category}\n                className={getCategoryStyle(category as MenuCategory)}\n                onClick={() => setActiveCategory(category as MenuCategory)}\n              >\n                {categoryIcons[category as MenuCategory]}\n                <span className=\"ml-2 font-medium\">\n                  {category.charAt(0).toUpperCase() + category.slice(1)}\n                </span>\n                <span className=\"ml-auto text-xs text-gray-400\">Alt+{category.charAt(0)}</span>\n              </button>\n            ))}\n          </div>\n          {/* Action buttons at the bottom */}\n          <div className=\"mt-auto space-y-2 border-t border-gray-800 p-4\">\n            <button\n              className=\"flex w-full items-center rounded-lg border border-indigo-700/50 bg-indigo-900/30 px-4 py-2 transition-colors duration-200 hover:bg-indigo-800/40\"\n              onClick={toggleTechTree}\n            >\n              <Terminal size={18} />\n              <span className=\"ml-2 font-medium text-white\">Tech Tree</span>\n              <span className=\"ml-auto text-xs text-gray-400\">F1</span>\n            </button>\n            <button\n              className=\"flex w-full items-center rounded-lg border border-gray-700/50 bg-gray-900/30 px-4 py-2 transition-colors duration-200 hover:bg-gray-800/40\"\n              onClick={toggleSettings}\n            >\n              <Settings size={18} />\n              <span className=\"ml-2 font-medium text-white\">Settings</span>\n              <span className=\"ml-auto text-xs text-gray-400\">F2</span>\n            </button>\n          </div>\n        </div>\n        {/* Right panel with active category content */}\n        <div className=\"flex-1 overflow-y-auto p-6\">\n          {activeCategory ? (\n            <div>\n              {/* Category header */}\n              <div\n                className={`mb-6 border-b pb-4 ${\n                  categoryColors[activeCategory].border\n                } flex items-center justify-between`}\n              >\n                <h2 className=\"flex items-center text-2xl font-bold text-white\">\n                  {categoryIcons[activeCategory]}\n                  <span className=\"ml-2\">\n                    {activeCategory.charAt(0).toUpperCase() + activeCategory.slice(1)}\n                  </span>\n                </h2>\n                <button\n                  className=\"rounded-full p-1 transition-colors duration-200 hover:bg-gray-800\"\n                  onClick={() => setActiveCategory(null)}\n                >\n                  <X size={20} className=\"text-gray-400\" />\n                </button>\n              </div>\n              {/* Category items */}\n              <div className=\"space-y-3\">\n                {menuItems[activeCategory].map(item => (\n                  <button\n                    key={item.id}\n                    className={`w-full rounded-lg border p-4 text-left ${\n                      categoryColors[activeCategory].border\n                    } bg-gray-800 bg-opacity-50 transition-colors duration-200 hover:bg-opacity-70`}\n                    onClick={item.action}\n                    onMouseEnter={e => {\n                      const rect = e.currentTarget.getBoundingClientRect();\n                      setShowTooltip({\n                        id: item.id,\n                        x: rect.right,\n                        y: rect.top,\n                      });\n                    }}\n                    onMouseLeave={() => setShowTooltip(null)}\n                  >\n                    <div className=\"flex items-start justify-between\">\n                      <h3 className=\"text-lg font-medium text-white\">{item.name}</h3>\n                      {item.cost ? (\n                        <div className=\"flex space-x-3 text-sm\">\n                          {item.cost.minerals ? (\n                            <span\n                              className={`rounded px-2 py-1 ${\n                                gameState.resources.minerals < (item.cost.minerals || 0)\n                                  ? 'bg-red-900/60 text-red-300'\n                                  : 'bg-amber-900/60 text-amber-300'\n                              }`}\n                            >\n                              {item.cost.minerals} minerals\n                            </span>\n                          ) : null}\n                          {item.cost.energy ? (\n                            <span\n                              className={`rounded px-2 py-1 ${\n                                gameState.resources.energy < (item.cost.energy || 0)\n                                  ? 'bg-red-900/60 text-red-300'\n                                  : 'bg-cyan-900/60 text-cyan-300'\n                              }`}\n                            >\n                              {item.cost.energy} energy\n                            </span>\n                          ) : null}\n                        </div>\n                      ) : null}\n                    </div>\n                    <p className=\"mt-1 text-gray-300\">{item.description}</p>\n                  </button>\n                ))}\n              </div>\n            </div>\n          ) : (\n            /* Welcome screen when no category is selected */\n            <div className=\"flex h-full flex-col items-center justify-center text-center\">\n              <h2 className=\"mb-4 text-2xl font-bold text-white\">Welcome to {empireName}</h2>\n              <p className=\"mb-8 max-w-md text-gray-300\">\n                Select a category from the left menu to manage your empire. Build modules to expand\n                your capabilities.\n              </p>\n              <div className=\"grid w-full max-w-md grid-cols-2 gap-4\">\n                {Object.keys(menuItems).map(category => (\n                  <button\n                    key={category}\n                    className={`rounded-lg border p-4 ${\n                      categoryColors[category as MenuCategory].border\n                    } bg-gray-800/50 transition-colors duration-200 hover:bg-opacity-70`}\n                    onClick={() => setActiveCategory(category as MenuCategory)}\n                  >\n                    <div className=\"flex flex-col items-center justify-center\">\n                      {categoryIcons[category as MenuCategory]}\n                      <span className=\"mt-2 font-medium text-white\">\n                        {category.charAt(0).toUpperCase() + category.slice(1)}\n                      </span>\n                      <span className=\"mt-1 text-xs text-gray-400\">Alt+{category.charAt(0)}</span>\n                    </div>\n                  </button>\n                ))}\n              </div>\n            </div>\n          )}\n        </div>\n      </div>\n      {/* Tooltips */}\n      {renderTooltip()}\n      {/* Notification system */}\n      <NotificationSystem />\n    </div>\n  );\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/GameLayout.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/GlobalErrorBoundary.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/NotificationSystem.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/ResourceEventMonitor.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'latestEvents' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 62,
        "column": 11,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 62,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'receivedCount' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 62,
        "column": 25,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 62,
        "endColumn": 38
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import * as React from 'react';\nimport { useEffect, useRef, useState } from 'react';\nimport { FixedSizeList as List } from 'react-window';\nimport { useEventCategorySubscription } from '../../hooks/events/useEventSubscription';\nimport { EventBus } from '../../lib/events/EventBus';\nimport { ModuleEvent, moduleEventBus } from '../../lib/events/ModuleEventBus';\nimport { EventCategory, EventType } from '../../types/events/EventTypes';\nimport { ResourceType } from '../../types/resources/ResourceTypes';\n\n// Resource-related event types to monitor\nconst RESOURCE_EVENT_TYPES = [\n  EventType.RESOURCE_PRODUCED,\n  EventType.RESOURCE_CONSUMED,\n  EventType.RESOURCE_TRANSFERRED,\n  EventType.RESOURCE_PRODUCTION_REGISTERED,\n  EventType.RESOURCE_CONSUMPTION_REGISTERED,\n];\n\ninterface ResourceEventData {\n  resourceType: ResourceType;\n  amount: number;\n  source?: string;\n  target?: string;\n}\n\n// Type guard for resource events\nfunction isResourceEvent(event: ModuleEvent): event is ModuleEvent & { data: ResourceEventData } {\n  if (!event.data) return false;\n  const data = event.data as Partial<ResourceEventData>;\n  return (\n    'resourceType' in data &&\n    'amount' in data &&\n    typeof data.resourceType === 'string' &&\n    typeof data.amount === 'number'\n  );\n}\n\ninterface ResourceEventLog {\n  id: string;\n  type: EventType;\n  moduleId: string;\n  timestamp: number;\n  resourceType: ResourceType;\n  amount: number;\n  source?: string;\n  target?: string;\n}\n\n/**\n * Component that monitors and displays resource-related events in real-time.\n * Uses the standardized event system with proper type safety and event filtering.\n * Uses virtualization for efficient rendering of large event logs.\n */\nexport const ResourceEventMonitor: React.FC = () => {\n  const [eventLogs, setEventLogs] = useState<ResourceEventLog[]>([]);\n  const [filter, setFilter] = useState<string>('');\n  const listRef = useRef<List>(null);\n  const containerRef = useRef<HTMLDivElement>(null);\n  const [containerSize, setContainerSize] = useState({ width: 0, height: 0 });\n\n  // Subscribe to all resource events using category subscription\n  const { latestEvents, receivedCount } = useEventCategorySubscription(\n    moduleEventBus as unknown as EventBus<ModuleEvent>,\n    EventCategory.RESOURCE,\n    (event: ModuleEvent) => {\n      if (isResourceEvent(event)) {\n        addEventToLog({\n          id: `${event.type}-${event.moduleId}-${event.timestamp}`,\n          type: event.type,\n          moduleId: event.moduleId,\n          timestamp: event.timestamp,\n          resourceType: event.data.resourceType,\n          amount: event.data.amount,\n          source: event.data.source,\n          target: event.data.target,\n        });\n      }\n    },\n    {\n      trackLatest: true,\n      filter: (event: ModuleEvent) => RESOURCE_EVENT_TYPES.includes(event.type as EventType),\n    }\n  );\n\n  // Helper function to add events to the log\n  const addEventToLog = (eventLog: ResourceEventLog) => {\n    setEventLogs(prevLogs => {\n      const newLogs = [eventLog, ...prevLogs];\n      return newLogs.slice(0, 1000);\n    });\n\n    // Scroll to top when new events come in\n    if (listRef.current) {\n      listRef.current.scrollTo(0);\n    }\n  };\n\n  // Clear logs\n  const clearLogs = () => {\n    setEventLogs([]);\n  };\n\n  // Filter logs based on user input\n  const filteredLogs = filter\n    ? eventLogs.filter(\n        log =>\n          log.type.toLowerCase().includes(filter.toLowerCase()) ||\n          log.moduleId.toLowerCase().includes(filter.toLowerCase()) ||\n          log.resourceType.toLowerCase().includes(filter.toLowerCase())\n      )\n    : eventLogs;\n\n  // Measure container size for the virtualized list\n  useEffect(() => {\n    if (containerRef.current) {\n      const resizeObserver = new ResizeObserver(entries => {\n        for (const entry of entries) {\n          const { width, height } = entry.contentRect;\n          setContainerSize({ width, height });\n        }\n      });\n\n      resizeObserver.observe(containerRef.current);\n\n      // Initialize size\n      setContainerSize({\n        width: containerRef.current.clientWidth,\n        height: containerRef.current.clientHeight,\n      });\n\n      return () => {\n        resizeObserver.disconnect();\n      };\n    }\n  }, []);\n\n  // Row renderer for the virtualized list\n  const Row = ({ index, style }: { index: number; style: React.CSSProperties }) => {\n    const log = filteredLogs[index];\n    return (\n      <div style={style} className=\"flex border-b border-gray-700 hover:bg-gray-600\">\n        <div className=\"min-w-[100px] flex-1 px-4 py-2\">\n          {new Date(log.timestamp).toLocaleTimeString()}\n        </div>\n        <div className=\"min-w-[150px] flex-1 px-4 py-2\">{log.type}</div>\n        <div className=\"min-w-[120px] flex-1 px-4 py-2\">{log.moduleId}</div>\n        <div className=\"min-w-[100px] flex-1 px-4 py-2\">{log.resourceType}</div>\n        <div className=\"min-w-[80px] flex-1 px-4 py-2\">{log.amount.toFixed(2)}</div>\n      </div>\n    );\n  };\n\n  // Table header for the virtualized list\n  const TableHeader = () => (\n    <div className=\"flex bg-gray-700 text-xs uppercase\">\n      <div className=\"min-w-[100px] flex-1 px-4 py-2\">Time</div>\n      <div className=\"min-w-[150px] flex-1 px-4 py-2\">Event Type</div>\n      <div className=\"min-w-[120px] flex-1 px-4 py-2\">Module</div>\n      <div className=\"min-w-[100px] flex-1 px-4 py-2\">Resource</div>\n      <div className=\"min-w-[80px] flex-1 px-4 py-2\">Amount</div>\n    </div>\n  );\n\n  return (\n    <div className=\"rounded-lg bg-gray-800 p-4 shadow-lg\">\n      <div className=\"mb-4 flex items-center justify-between\">\n        <h2 className=\"text-xl font-semibold text-white\">Resource Event Monitor</h2>\n        <div className=\"flex space-x-2\">\n          <input\n            type=\"text\"\n            placeholder=\"Filter events...\"\n            className=\"rounded border border-gray-600 bg-gray-700 px-3 py-1 text-white focus:outline-none focus:ring-2 focus:ring-blue-500\"\n            value={filter}\n            onChange={e => setFilter(e.target.value)}\n          />\n          <button\n            onClick={clearLogs}\n            className=\"rounded bg-red-600 px-3 py-1 text-white hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500\"\n          >\n            Clear\n          </button>\n        </div>\n      </div>\n\n      <div ref={containerRef} className=\"h-96 w-full\">\n        {filteredLogs.length === 0 ? (\n          <div className=\"flex h-full items-center justify-center py-8 text-center text-gray-400\">\n            No resource events recorded yet\n          </div>\n        ) : (\n          <div className=\"text-left text-sm text-gray-300\">\n            <TableHeader />\n            <List\n              ref={listRef}\n              className=\"text-left text-sm text-gray-300\"\n              height={containerSize.height - 30} // Subtract header height\n              width={containerSize.width}\n              itemCount={filteredLogs.length}\n              itemSize={40} // Height of each row\n            >\n              {Row}\n            </List>\n          </div>\n        )}\n      </div>\n\n      <div className=\"mt-2 text-xs text-gray-500\">\n        Displaying {filteredLogs.length} events (virtualized for performance)\n      </div>\n    </div>\n  );\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/ResourceVisualization.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/SprawlView.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/Tabs.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/TechTree.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/TooltipProvider.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/VPRErrorBoundary.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/VPRLoadingFallback.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/VPRStarSystemView.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/automation/AutomationRuleEditor.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/automation/AutomationVisualization.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/buttons/AbilityButton.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/common/Badge.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/common/Button.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/config/TypeSafeConfigDemo.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 463,
        "column": 50,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 463,
        "endColumn": 53,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [15143, 15146], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [15143, 15146], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import * as React from \"react\";\nimport { useEffect, useState } from 'react';\nimport { z } from 'zod';\nimport {\n  ConfigItem,\n  ConfigValidationError,\n  createConfigItem,\n  createConfigManager,\n  createFeatureFlag,\n  FeatureFlag,\n  FeatureStatus,\n  useFeatureFlag,\n  useTypedConfig,\n} from '../../../types/config/TypeSafeConfig';\n\n// Create schema definitions for our config items\nconst themeSchema = z.enum(['light', 'dark', 'system']);\nconst pageSizeSchema = z.number().int().min(5).max(100);\nconst apiEndpointSchema = z.string().url();\nconst cacheTTLSchema = z.number().int().min(0).max(86400);\nconst loggingLevelSchema = z.enum(['debug', 'info', 'warn', 'error']);\nconst notificationSchema = z.object({\n  enabled: z.boolean(),\n  sound: z.boolean().optional(),\n  desktop: z.boolean().optional(),\n  frequency: z.enum(['immediately', 'batched', 'daily']).optional(),\n});\n\n// Define our config items with schemas\nconst configItems = [\n  createConfigItem('theme', themeSchema, 'system', {\n    name: 'Theme',\n    description: 'Application color theme',\n    category: 'appearance',\n    tags: ['ui', 'appearance'],\n  }),\n  createConfigItem('pageSize', pageSizeSchema, 20, {\n    name: 'Page Size',\n    description: 'Number of items to display per page',\n    category: 'appearance',\n    tags: ['ui', 'pagination'],\n  }),\n  createConfigItem('apiEndpoint', apiEndpointSchema, 'https://api.example.com/v1', {\n    name: 'API Endpoint',\n    description: 'Base URL for API requests',\n    category: 'api',\n    tags: ['api', 'connection'],\n  }),\n  createConfigItem('cacheTTL', cacheTTLSchema, 3600, {\n    name: 'Cache TTL',\n    description: 'Time to live for cached data in seconds',\n    category: 'performance',\n    tags: ['cache', 'performance'],\n  }),\n  createConfigItem('loggingLevel', loggingLevelSchema, 'info', {\n    name: 'Logging Level',\n    description: 'Minimum level for log messages',\n    category: 'debugging',\n    tags: ['logs', 'debugging'],\n  }),\n  createConfigItem(\n    'notifications',\n    notificationSchema,\n    { enabled: true, sound: true, frequency: 'immediately' },\n    {\n      name: 'Notifications',\n      description: 'Notification settings',\n      category: 'notifications',\n      tags: ['notifications', 'alerts'],\n    }\n  ),\n];\n\n// Define feature flags\nconst featureFlags = [\n  createFeatureFlag('newDashboard', false, {\n    name: 'New Dashboard',\n    description: 'Enable the new dashboard interface',\n    status: FeatureStatus.PREVIEW,\n    targeting: {\n      userRoles: ['admin', 'beta-tester'],\n      percentageRollout: 20,\n    },\n  }),\n  createFeatureFlag('advancedCharts', false, {\n    name: 'Advanced Charts',\n    description: 'Enable advanced chart visualizations',\n    status: FeatureStatus.EXPERIMENTAL,\n    targeting: {\n      userRoles: ['admin', 'data-analyst'],\n      environments: ['development', 'staging'],\n    },\n  }),\n  createFeatureFlag('bulkOperations', true, {\n    name: 'Bulk Operations',\n    description: 'Enable bulk operations in list views',\n    status: FeatureStatus.ENABLED,\n  }),\n  createFeatureFlag('aiSuggestions', false, {\n    name: 'AI Suggestions',\n    description: 'Enable AI-powered suggestions',\n    status: FeatureStatus.BETA,\n    targeting: {\n      percentageRollout: 10,\n      dateRange: {\n        start: '2023-06-01',\n        end: '2023-12-31',\n      },\n    },\n  }),\n  createFeatureFlag('legacyExport', true, {\n    name: 'Legacy Export',\n    description: 'Enable legacy export functionality',\n    status: FeatureStatus.DEPRECATED,\n  }),\n];\n\n// Define categories\nconst categories = [\n  {\n    id: 'appearance',\n    name: 'Appearance',\n    description: 'Visual appearance settings',\n    items: [],\n  },\n  {\n    id: 'api',\n    name: 'API',\n    description: 'API connection settings',\n    items: [],\n  },\n  {\n    id: 'performance',\n    name: 'Performance',\n    description: 'Performance optimization settings',\n    items: [],\n  },\n  {\n    id: 'debugging',\n    name: 'Debugging',\n    description: 'Debugging and logging settings',\n    items: [],\n  },\n  {\n    id: 'notifications',\n    name: 'Notifications',\n    description: 'Notification settings',\n    items: [],\n  },\n];\n\n// Create a shared config manager instance\nconst configManager = createConfigManager({\n  validateOnAccess: true,\n  logErrors: true,\n  onValidationError: errors => {\n    console.warn('Config validation errors:', errors);\n  },\n  onConfigChange: (key, newValue, oldValue) => {\n    console.warn(`Config changed: ${key}`, { oldValue, newValue });\n  },\n});\n\n// Initialize the config manager\ncategories.forEach(category => configManager.registerCategory(category));\nconfigManager.registerConfigs(configItems);\nfeatureFlags.forEach(flag => configManager.registerFeature(flag));\n\n// User roles for demo\nconst userRoles = ['user', 'admin', 'beta-tester', 'data-analyst'];\nconst environments = ['development', 'staging', 'production'];\n\nconst TypeSafeConfigDemo: React.FC = () => {\n  const [validationErrors, setValidationErrors] = useState<ConfigValidationError[]>([]);\n  const [selectedRole, setSelectedRole] = useState<string>('user');\n  const [selectedEnvironment, setSelectedEnvironment] = useState<string>('production');\n  const [userId, setUserId] = useState<string>('user-123');\n  const [configValues, setConfigValues] = useState<Record<string, unknown>>({});\n  const [featureValues, setFeatureValues] = useState<Record<string, boolean>>({});\n  const [selectedCategory, setSelectedCategory] = useState<string>('appearance');\n  const [selectedConfig, setSelectedConfig] = useState<ConfigItem | null>(null);\n  const [editValue, setEditValue] = useState<string>('');\n  const [showExport, setShowExport] = useState(false);\n  const [exportedConfig, setExportedConfig] = useState('');\n\n  // Set user context whenever role, environment, or user ID changes\n  useEffect(() => {\n    configManager.setUserContext({\n      role: selectedRole,\n      environment: selectedEnvironment,\n      id: userId,\n    });\n\n    // Update feature values\n    setFeatureValues(configManager.exportFeatures());\n  }, [selectedRole, selectedEnvironment, userId]);\n\n  // Initial load of config values\n  useEffect(() => {\n    setConfigValues(configManager.exportConfig());\n  }, []);\n\n  // Handle config item selection\n  const handleSelectConfig = (item: ConfigItem) => {\n    setSelectedConfig(item);\n    // Get current value and set as edit value\n    const value = configManager.get(item.key);\n    setEditValue(typeof value === 'object' ? JSON.stringify(value, null, 2) : String(value));\n  };\n\n  // Handle value change\n  const handleSaveValue = () => {\n    if (!selectedConfig) return;\n\n    // Parse the value based on the schema type\n    let parsedValue: unknown;\n    try {\n      if (selectedConfig.schema instanceof z.ZodObject) {\n        parsedValue = JSON.parse(editValue);\n      } else if (selectedConfig.schema instanceof z.ZodNumber) {\n        parsedValue = Number(editValue);\n      } else if (selectedConfig.schema instanceof z.ZodBoolean) {\n        parsedValue = editValue === 'true';\n      } else {\n        parsedValue = editValue;\n      }\n\n      // Update the config\n      const result = configManager.set(selectedConfig.key, parsedValue);\n      if (!result.valid) {\n        setValidationErrors(result.errors);\n      } else {\n        setValidationErrors([]);\n        setConfigValues(configManager.exportConfig());\n      }\n    } catch (err) {\n      setValidationErrors([\n        {\n          key: selectedConfig.key,\n          message: 'Invalid format: ' + (err instanceof Error ? err.message : String(err)),\n        },\n      ]);\n    }\n  };\n\n  // Export config\n  const handleExport = () => {\n    const config = {\n      settings: configManager.exportConfig(),\n      features: configManager.exportFeatures(),\n    };\n    setExportedConfig(JSON.stringify(config, null, 2));\n    setShowExport(true);\n  };\n\n  // Import config\n  const handleImport = (event: React.ChangeEvent<HTMLInputElement>) => {\n    const file = event.target.files?.[0];\n    if (!file) return;\n\n    const reader = new FileReader();\n    reader.onload = e => {\n      try {\n        const content = e.target?.result as string;\n        const config = JSON.parse(content);\n\n        if (config.settings) {\n          const result = configManager.importConfig(config.settings);\n          if (!result.valid) {\n            setValidationErrors(result.errors);\n          } else {\n            setValidationErrors([]);\n            setConfigValues(configManager.exportConfig());\n            setFeatureValues(configManager.exportFeatures());\n          }\n        }\n      } catch (err) {\n        setValidationErrors([\n          {\n            key: 'import',\n            message: 'Invalid import file: ' + (err instanceof Error ? err.message : String(err)),\n          },\n        ]);\n      }\n    };\n    reader.readAsText(file);\n  };\n\n  // Render feature flag status display\n  const renderFeatureStatus = (flag: FeatureFlag) => {\n    const isEnabled = featureValues[flag.key] || false;\n    return (\n      <div className={`feature-flag ${isEnabled ? 'enabled' : 'disabled'}`} key={flag.key}>\n        <h4>{flag.name}</h4>\n        <div className=\"feature-status\">\n          <span className={`status-badge ${flag.status.toLowerCase()}`}>{flag.status}</span>\n          <span className={`enabled-badge ${isEnabled ? 'enabled' : 'disabled'}`}>\n            {isEnabled ? 'ENABLED' : 'DISABLED'}\n          </span>\n        </div>\n        <p>{flag.description}</p>\n        {flag.targeting && (\n          <div className=\"targeting-info\">\n            {flag.targeting.userRoles && (\n              <div className=\"targeting-detail\">\n                <span>Roles:</span> {flag.targeting.userRoles.join(', ')}\n              </div>\n            )}\n            {flag.targeting.environments && (\n              <div className=\"targeting-detail\">\n                <span>Environments:</span> {flag.targeting.environments.join(', ')}\n              </div>\n            )}\n            {flag.targeting.percentageRollout !== undefined && (\n              <div className=\"targeting-detail\">\n                <span>Rollout:</span> {flag.targeting.percentageRollout}%\n              </div>\n            )}\n          </div>\n        )}\n      </div>\n    );\n  };\n\n  // Example usage of the type-safe hooks\n  const theme = useTypedConfig<typeof themeSchema>(configManager, 'theme', 'system');\n  const pageSize = useTypedConfig<typeof pageSizeSchema>(configManager, 'pageSize', 20);\n  const newDashboardEnabled = useFeatureFlag(configManager, 'newDashboard');\n\n  return (\n    <div className={`config-demo theme-${theme}`}>\n      <h1>Type-Safe Configuration Demo</h1>\n\n      <div className=\"demo-layout\">\n        <aside className=\"sidebar\">\n          <div className=\"user-context\">\n            <h3>User Context</h3>\n            <div className=\"form-group\">\n              <label htmlFor=\"user-id\">User ID:</label>\n              <input\n                id=\"user-id\"\n                type=\"text\"\n                value={userId}\n                onChange={e => setUserId(e.target.value)}\n              />\n            </div>\n\n            <div className=\"form-group\">\n              <label htmlFor=\"user-role\">User Role:</label>\n              <select\n                id=\"user-role\"\n                value={selectedRole}\n                onChange={e => setSelectedRole(e.target.value)}\n              >\n                {userRoles.map(role => (\n                  <option key={role} value={role}>\n                    {role}\n                  </option>\n                ))}\n              </select>\n            </div>\n\n            <div className=\"form-group\">\n              <label htmlFor=\"environment\">Environment:</label>\n              <select\n                id=\"environment\"\n                value={selectedEnvironment}\n                onChange={e => setSelectedEnvironment(e.target.value)}\n              >\n                {environments.map(env => (\n                  <option key={env} value={env}>\n                    {env}\n                  </option>\n                ))}\n              </select>\n            </div>\n          </div>\n\n          <div className=\"categories\">\n            <h3>Categories</h3>\n            <ul>\n              {categories.map(category => (\n                <li\n                  key={category.id}\n                  className={selectedCategory === category.id ? 'active' : ''}\n                  onClick={() => setSelectedCategory(category.id)}\n                >\n                  {category.name}\n                </li>\n              ))}\n            </ul>\n          </div>\n\n          <div className=\"actions\">\n            <button onClick={handleExport}>Export Configuration</button>\n            <div className=\"import-container\">\n              <label htmlFor=\"import-file\" className=\"import-label\">\n                Import Configuration\n              </label>\n              <input\n                id=\"import-file\"\n                type=\"file\"\n                accept=\".json\"\n                onChange={handleImport}\n                className=\"import-input\"\n              />\n            </div>\n          </div>\n        </aside>\n\n        <main className=\"main-content\">\n          <div className=\"config-section\">\n            <h2>Configuration</h2>\n\n            <div className=\"config-items\">\n              {configItems\n                .filter(item => item.category === selectedCategory)\n                .map(item => (\n                  <div\n                    key={item.key}\n                    className={`config-item ${selectedConfig?.key === item.key ? 'selected' : ''}`}\n                    onClick={() => handleSelectConfig(item)}\n                  >\n                    <h4>{item.name}</h4>\n                    <p>{item.description}</p>\n                    <div className=\"config-value\">\n                      {typeof configValues[item.key] === 'object'\n                        ? JSON.stringify(configValues[item.key])\n                        : String(configValues[item.key])}\n                    </div>\n                    <div className=\"config-tags\">\n                      {item.tags?.map(tag => (\n                        <span key={tag} className=\"tag\">\n                          {tag}\n                        </span>\n                      ))}\n                    </div>\n                  </div>\n                ))}\n            </div>\n          </div>\n\n          {selectedConfig && (\n            <div className=\"config-editor\">\n              <h3>Edit {selectedConfig.name}</h3>\n\n              <div className=\"editor-form\">\n                <div className=\"form-group\">\n                  <label htmlFor=\"config-value\">Value:</label>\n                  {selectedConfig.schema instanceof z.ZodObject ? (\n                    <textarea\n                      id=\"config-value\"\n                      value={editValue}\n                      onChange={e => setEditValue(e.target.value)}\n                      rows={10}\n                    />\n                  ) : selectedConfig.schema instanceof z.ZodEnum ? (\n                    <select\n                      id=\"config-value\"\n                      value={editValue}\n                      onChange={e => setEditValue(e.target.value)}\n                    >\n                      {(selectedConfig.schema as any)._def.values.map((val: string) => (\n                        <option key={val} value={val}>\n                          {val}\n                        </option>\n                      ))}\n                    </select>\n                  ) : (\n                    <input\n                      id=\"config-value\"\n                      type={selectedConfig.schema instanceof z.ZodNumber ? 'number' : 'text'}\n                      value={editValue}\n                      onChange={e => setEditValue(e.target.value)}\n                    />\n                  )}\n                </div>\n\n                <div className=\"editor-actions\">\n                  <button onClick={handleSaveValue}>Save</button>\n                  <button onClick={() => setSelectedConfig(null)}>Cancel</button>\n                </div>\n              </div>\n\n              {validationErrors.length > 0 && (\n                <div className=\"validation-errors\">\n                  <h4>Validation Errors</h4>\n                  <ul>\n                    {validationErrors.map((error, index) => (\n                      <li key={index}>\n                        {error.key}: {error.message}\n                        {error.path && <span> (Path: {error.path.join('.')})</span>}\n                      </li>\n                    ))}\n                  </ul>\n                </div>\n              )}\n            </div>\n          )}\n\n          <div className=\"feature-section\">\n            <h2>Feature Flags</h2>\n            <div className=\"feature-grid\">\n              {featureFlags.map(flag => renderFeatureStatus(flag))}\n            </div>\n          </div>\n\n          <div className=\"demo-output\">\n            <h2>Active Configuration Demo</h2>\n            <div className=\"output-example\">\n              <div className=\"example-item\">\n                <h4>Theme Setting</h4>\n                <div className=\"example-value\">{theme}</div>\n                <div className=\"example-code\">\n                  <pre>\n                    useTypedConfig&lt;typeof themeSchema&gt;(configManager, 'theme', 'system')\n                  </pre>\n                </div>\n              </div>\n\n              <div className=\"example-item\">\n                <h4>Page Size Setting</h4>\n                <div className=\"example-value\">{pageSize}</div>\n                <div className=\"example-code\">\n                  <pre>\n                    useTypedConfig&lt;typeof pageSizeSchema&gt;(configManager, 'pageSize', 20)\n                  </pre>\n                </div>\n              </div>\n\n              <div className=\"example-item\">\n                <h4>New Dashboard Feature Flag</h4>\n                <div className=\"example-value\">{newDashboardEnabled ? 'Enabled' : 'Disabled'}</div>\n                <div className=\"example-code\">\n                  <pre>useFeatureFlag(configManager, 'newDashboard')</pre>\n                </div>\n              </div>\n            </div>\n          </div>\n        </main>\n      </div>\n\n      {showExport && (\n        <div className=\"modal-overlay\">\n          <div className=\"export-modal\">\n            <h3>Exported Configuration</h3>\n            <pre className=\"export-content\">{exportedConfig}</pre>\n            <div className=\"modal-actions\">\n              <button\n                onClick={() => {\n                  navigator.clipboard.writeText(exportedConfig);\n                  alert('Copied to clipboard!');\n                }}\n              >\n                Copy to Clipboard\n              </button>\n              <button onClick={() => setShowExport(false)}>Close</button>\n            </div>\n          </div>\n        </div>\n      )}\n\n      <style jsx>{`\n        .config-demo {\n          font-family:\n            system-ui,\n            -apple-system,\n            BlinkMacSystemFont,\n            'Segoe UI',\n            Roboto,\n            sans-serif;\n          color: #333;\n          max-width: 1200px;\n          margin: 0 auto;\n          padding: 20px;\n        }\n\n        .theme-dark {\n          background-color: #1e1e1e;\n          color: #f0f0f0;\n        }\n\n        .theme-light {\n          background-color: #ffffff;\n          color: #333333;\n        }\n\n        .demo-layout {\n          display: flex;\n          gap: 20px;\n          margin-top: 20px;\n        }\n\n        .sidebar {\n          width: 250px;\n          flex-shrink: 0;\n        }\n\n        .main-content {\n          flex: 1;\n        }\n\n        .user-context,\n        .categories,\n        .actions {\n          background-color: #f5f5f5;\n          border-radius: 8px;\n          padding: 15px;\n          margin-bottom: 20px;\n        }\n\n        .theme-dark .user-context,\n        .theme-dark .categories,\n        .theme-dark .actions {\n          background-color: #2a2a2a;\n        }\n\n        h1,\n        h2,\n        h3,\n        h4 {\n          margin-top: 0;\n        }\n\n        .form-group {\n          margin-bottom: 15px;\n        }\n\n        label {\n          display: block;\n          margin-bottom: 5px;\n          font-weight: bold;\n        }\n\n        input,\n        select,\n        textarea {\n          width: 100%;\n          padding: 8px;\n          border: 1px solid #ddd;\n          border-radius: 4px;\n          font-size: 14px;\n        }\n\n        .theme-dark input,\n        .theme-dark select,\n        .theme-dark textarea {\n          background-color: #333;\n          border-color: #555;\n          color: #f0f0f0;\n        }\n\n        button {\n          padding: 8px 16px;\n          background-color: #4a6cf7;\n          color: white;\n          border: none;\n          border-radius: 4px;\n          cursor: pointer;\n          font-size: 14px;\n          margin-right: 10px;\n          transition: background-color 0.2s;\n        }\n\n        button:hover {\n          background-color: #3a5ce5;\n        }\n\n        .categories ul {\n          list-style: none;\n          padding: 0;\n          margin: 0;\n        }\n\n        .categories li {\n          padding: 8px 12px;\n          margin-bottom: 5px;\n          cursor: pointer;\n          border-radius: 4px;\n          transition: background-color 0.2s;\n        }\n\n        .categories li:hover {\n          background-color: #eaeaea;\n        }\n\n        .theme-dark .categories li:hover {\n          background-color: #3a3a3a;\n        }\n\n        .categories li.active {\n          background-color: #4a6cf7;\n          color: white;\n        }\n\n        .config-section,\n        .feature-section,\n        .demo-output {\n          background-color: #f5f5f5;\n          border-radius: 8px;\n          padding: 20px;\n          margin-bottom: 20px;\n        }\n\n        .theme-dark .config-section,\n        .theme-dark .feature-section,\n        .theme-dark .demo-output {\n          background-color: #2a2a2a;\n        }\n\n        .config-items {\n          display: grid;\n          grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));\n          gap: 15px;\n        }\n\n        .config-item {\n          background-color: white;\n          border-radius: 6px;\n          padding: 15px;\n          cursor: pointer;\n          transition:\n            transform 0.2s,\n            box-shadow 0.2s;\n          box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);\n        }\n\n        .theme-dark .config-item {\n          background-color: #333;\n          box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);\n        }\n\n        .config-item:hover {\n          transform: translateY(-2px);\n          box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);\n        }\n\n        .theme-dark .config-item:hover {\n          box-shadow: 0 4px 6px rgba(0, 0, 0, 0.4);\n        }\n\n        .config-item.selected {\n          border: 2px solid #4a6cf7;\n          box-shadow: 0 0 0 2px rgba(74, 108, 247, 0.3);\n        }\n\n        .config-item h4 {\n          margin-top: 0;\n          margin-bottom: 10px;\n        }\n\n        .config-item p {\n          margin: 5px 0;\n          font-size: 14px;\n          color: #666;\n        }\n\n        .theme-dark .config-item p {\n          color: #aaa;\n        }\n\n        .config-value {\n          margin-top: 10px;\n          padding: 8px;\n          background-color: #f8f8f8;\n          border-radius: 4px;\n          font-family: monospace;\n          font-size: 14px;\n          overflow: hidden;\n          text-overflow: ellipsis;\n          white-space: nowrap;\n        }\n\n        .theme-dark .config-value {\n          background-color: #222;\n        }\n\n        .config-tags {\n          margin-top: 10px;\n          display: flex;\n          flex-wrap: wrap;\n          gap: 5px;\n        }\n\n        .tag {\n          font-size: 12px;\n          padding: 3px 6px;\n          background-color: #e7e7e7;\n          border-radius: 12px;\n          color: #666;\n        }\n\n        .theme-dark .tag {\n          background-color: #444;\n          color: #ddd;\n        }\n\n        .config-editor {\n          background-color: white;\n          border-radius: 8px;\n          padding: 20px;\n          margin-bottom: 20px;\n          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n        }\n\n        .theme-dark .config-editor {\n          background-color: #333;\n          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\n        }\n\n        .editor-actions {\n          margin-top: 15px;\n        }\n\n        .validation-errors {\n          margin-top: 15px;\n          padding: 15px;\n          background-color: #f7e6e6;\n          border-left: 4px solid #d93838;\n          border-radius: 4px;\n        }\n\n        .theme-dark .validation-errors {\n          background-color: #3a2a2a;\n          border-left-color: #d93838;\n        }\n\n        .validation-errors h4 {\n          margin-top: 0;\n          color: #d93838;\n        }\n\n        .validation-errors ul {\n          margin: 0;\n          padding-left: 20px;\n        }\n\n        .feature-grid {\n          display: grid;\n          grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));\n          gap: 15px;\n        }\n\n        .feature-flag {\n          background-color: white;\n          border-radius: 6px;\n          padding: 15px;\n          box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);\n        }\n\n        .theme-dark .feature-flag {\n          background-color: #333;\n          box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);\n        }\n\n        .feature-status {\n          display: flex;\n          gap: 10px;\n          margin-bottom: 10px;\n        }\n\n        .status-badge,\n        .enabled-badge {\n          display: inline-block;\n          padding: 3px 8px;\n          border-radius: a10px;\n          font-size: 12px;\n          font-weight: bold;\n          text-transform: uppercase;\n        }\n\n        .status-badge.enabled {\n          background-color: #4caf50;\n          color: white;\n        }\n\n        .status-badge.disabled {\n          background-color: #f44336;\n          color: white;\n        }\n\n        .status-badge.preview {\n          background-color: #ff9800;\n          color: white;\n        }\n\n        .status-badge.experimental {\n          background-color: #9c27b0;\n          color: white;\n        }\n\n        .status-badge.beta {\n          background-color: #2196f3;\n          color: white;\n        }\n\n        .status-badge.deprecated {\n          background-color: #795548;\n          color: white;\n        }\n\n        .enabled-badge.enabled {\n          background-color: #4caf50;\n          color: white;\n        }\n\n        .enabled-badge.disabled {\n          background-color: #f44336;\n          color: white;\n        }\n\n        .targeting-info {\n          margin-top: 10px;\n          font-size: 14px;\n          padding: 10px;\n          background-color: #f8f8f8;\n          border-radius: 4px;\n        }\n\n        .theme-dark .targeting-info {\n          background-color: #222;\n        }\n\n        .targeting-detail {\n          margin-bottom: 5px;\n        }\n\n        .targeting-detail span {\n          font-weight: bold;\n          margin-right: 5px;\n        }\n\n        .demo-output {\n          background-color: white;\n          border-radius: 8px;\n          padding: 20px;\n        }\n\n        .theme-dark .demo-output {\n          background-color: #333;\n        }\n\n        .output-example {\n          display: flex;\n          flex-wrap: wrap;\n          gap: 20px;\n        }\n\n        .example-item {\n          flex: 1;\n          min-width: 200px;\n          padding: 15px;\n          background-color: #f8f8f8;\n          border-radius: 6px;\n        }\n\n        .theme-dark .example-item {\n          background-color: #222;\n        }\n\n        .example-value {\n          font-size: 20px;\n          font-weight: bold;\n          margin: 10px 0;\n        }\n\n        .example-code {\n          margin-top: 10px;\n          padding: 10px;\n          background-color: #eaeaea;\n          border-radius: 4px;\n          overflow-x: auto;\n        }\n\n        .theme-dark .example-code {\n          background-color: #1a1a1a;\n        }\n\n        pre {\n          margin: 0;\n          font-family: monospace;\n          font-size: 13px;\n          overflow-x: auto;\n        }\n\n        .modal-overlay {\n          position: fixed;\n          top: 0;\n          left: 0;\n          right: 0;\n          bottom: 0;\n          background-color: rgba(0, 0, 0, 0.5);\n          display: flex;\n          align-items: center;\n          justify-content: center;\n          z-index: 1000;\n        }\n\n        .export-modal {\n          background-color: white;\n          border-radius: 8px;\n          padding: 20px;\n          max-width: 800px;\n          width: 90%;\n          max-height: 80vh;\n          display: flex;\n          flex-direction: column;\n        }\n\n        .theme-dark .export-modal {\n          background-color: #333;\n        }\n\n        .export-content {\n          flex: 1;\n          overflow: auto;\n          padding: 15px;\n          background-color: #f8f8f8;\n          border-radius: 4px;\n          margin: 15px 0;\n          font-family: monospace;\n          white-space: pre-wrap;\n        }\n\n        .theme-dark .export-content {\n          background-color: #222;\n        }\n\n        .modal-actions {\n          display: flex;\n          justify-content: flex-end;\n          gap: 10px;\n          margin-top: 10px;\n        }\n\n        .import-container {\n          position: relative;\n          margin-top: 10px;\n        }\n\n        .import-label {\n          display: inline-block;\n          padding: 8px 16px;\n          background-color: #4a6cf7;\n          color: white;\n          border: none;\n          border-radius: 4px;\n          cursor: pointer;\n          font-size: 14px;\n          transition: background-color 0.2s;\n        }\n\n        .import-label:hover {\n          background-color: #3a5ce5;\n        }\n\n        .import-input {\n          position: absolute;\n          width: 0.1px;\n          height: 0.1px;\n          opacity: 0;\n          overflow: hidden;\n          z-index: -1;\n        }\n      `}</style>\n    </div>\n  );\n};\n\nexport default TypeSafeConfigDemo;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/event/VirtualizedEventLog.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'showDetails' is assigned a value but never used. Allowed unused args must match /^_/u.",
        "line": 94,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 94,
        "endColumn": 14
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'index' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 208,
        "column": 5,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 208,
        "endColumn": 10
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'eventId' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 219,
        "column": 11,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 219,
        "endColumn": 18
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import * as React from \"react\";\nimport { useCallback, useEffect, useRef, useState } from 'react';\nimport { FixedSizeList as List } from 'react-window';\nimport InfiniteLoader from 'react-window-infinite-loader';\nimport { ModuleEvent, ModuleEventType } from '../../../lib/modules/ModuleEvents';\n\nexport interface EventLogProps {\n  /**\n   * Array of events to display\n   */\n  events: ModuleEvent[];\n\n  /**\n   * Function to load more events\n   * Return true if there are more events to load, false otherwise\n   */\n  loadMoreEvents?: () => Promise<boolean>;\n\n  /**\n   * Maximum number of events to display\n   */\n  maxEvents?: number;\n\n  /**\n   * Height of the event log\n   */\n  height?: number;\n\n  /**\n   * Width of the event log\n   */\n  width?: string | number;\n\n  /**\n   * Row height\n   */\n  rowHeight?: number;\n\n  /**\n   * Filter function to filter events\n   */\n  filterEvent?: (event: ModuleEvent) => boolean;\n\n  /**\n   * Event handler for when an event is clicked\n   */\n  onEventClick?: (event: ModuleEvent) => void;\n\n  /**\n   * Whether to show the event details by default\n   */\n  showDetails?: boolean;\n\n  /**\n   * Custom renderer for event rows\n   */\n  rowRenderer?: (props: {\n    event: ModuleEvent;\n    index: number;\n    style: React.CSSProperties;\n    onClick: () => void;\n    isExpanded: boolean;\n  }) => React.ReactNode;\n\n  /**\n   * CSS class for the container\n   */\n  className?: string;\n\n  /**\n   * Whether to auto-scroll to the most recent event\n   */\n  autoScrollToRecent?: boolean;\n\n  /**\n   * Event type filter\n   */\n  eventTypeFilter?: ModuleEventType[];\n}\n\n/**\n * A virtualized event log that efficiently renders large sets of events\n * Supports infinite loading for fetching historical events on demand\n */\nexport const VirtualizedEventLog: React.FC<EventLogProps> = ({\n  events,\n  loadMoreEvents,\n  maxEvents = 1000,\n  height = 400,\n  width = '100%',\n  rowHeight = 48,\n  filterEvent,\n  onEventClick,\n  showDetails = false,\n  rowRenderer,\n  className = '',\n  autoScrollToRecent = true,\n  eventTypeFilter,\n}) => {\n  const listRef = useRef<List | null>(null);\n  const infiniteLoaderRef = useRef<InfiniteLoader | null>(null);\n  const containerRef = useRef<HTMLDivElement | null>(null);\n  const [containerSize, setContainerSize] = useState({ width: 0, height });\n  const [expandedEventIds, setExpandedEventIds] = useState<Set<string>>(new Set());\n  const [isLoadingMore, setIsLoadingMore] = useState(false);\n  const [hasMoreEvents, setHasMoreEvents] = useState(true);\n\n  // For storing reference without directly assigning to .current\n  const listRefCallback = useCallback((list: List | null) => {\n    listRef.current = list;\n  }, []);\n\n  // Filter events based on the provided filter\n  const filteredEvents = useCallback(() => {\n    let filtered = [...events];\n\n    // Apply event type filter\n    if (eventTypeFilter && eventTypeFilter.length > 0) {\n      filtered = filtered.filter(event => eventTypeFilter.includes(event.type));\n    }\n\n    // Apply custom filter function\n    if (filterEvent) {\n      filtered = filtered.filter(filterEvent);\n    }\n\n    // Limit the number of events\n    return filtered.slice(0, maxEvents);\n  }, [events, filterEvent, eventTypeFilter, maxEvents]);\n\n  // Memoized filtered events\n  const displayedEvents = React.useMemo(() => filteredEvents(), [filteredEvents]);\n\n  // Handle container resizing\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    const resizeObserver = new ResizeObserver(entries => {\n      for (const entry of entries) {\n        const { width } = entry.contentRect;\n        setContainerSize(prev => ({ ...prev, width }));\n      }\n    });\n\n    resizeObserver.observe(containerRef.current);\n\n    // Initialize width\n    setContainerSize(prev => ({\n      ...prev,\n      width: containerRef.current?.clientWidth || 0,\n    }));\n\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }, []);\n\n  // Update height when prop changes\n  useEffect(() => {\n    setContainerSize(prev => ({ ...prev, height }));\n  }, [height]);\n\n  // Auto-scroll to most recent event\n  useEffect(() => {\n    if (autoScrollToRecent && listRef.current && displayedEvents.length > 0) {\n      listRef.current.scrollTo(0);\n    }\n  }, [displayedEvents.length, autoScrollToRecent]);\n\n  // Load more events\n  const loadMore = async () => {\n    if (isLoadingMore || !loadMoreEvents || !hasMoreEvents) return;\n\n    setIsLoadingMore(true);\n    try {\n      const hasMore = await loadMoreEvents();\n      setHasMoreEvents(hasMore);\n    } catch (error) {\n      console.error('Failed to load more events', error);\n    } finally {\n      setIsLoadingMore(false);\n    }\n  };\n\n  // Handle event click\n  const handleEventClick = (eventId: string) => {\n    const event = displayedEvents.find(e => e.moduleId + e.timestamp === eventId);\n    if (event) {\n      if (onEventClick) {\n        onEventClick(event);\n      }\n\n      setExpandedEventIds(prev => {\n        const newSet = new Set(prev);\n        if (newSet.has(eventId)) {\n          newSet.delete(eventId);\n        } else {\n          newSet.add(eventId);\n        }\n        return newSet;\n      });\n    }\n  };\n\n  // Default row renderer\n  const defaultRowRenderer = ({\n    event,\n    index,\n    style,\n    onClick,\n    isExpanded,\n  }: {\n    event: ModuleEvent;\n    index: number;\n    style: React.CSSProperties;\n    onClick: () => void;\n    isExpanded: boolean;\n  }) => {\n    const eventId = event.moduleId + event.timestamp;\n    return (\n      <div\n        style={style}\n        className={`flex flex-col border-b border-gray-700 p-2 transition-colors hover:bg-gray-700 ${\n          isExpanded ? 'bg-gray-700' : ''\n        }`}\n        onClick={onClick}\n      >\n        <div className=\"flex items-center justify-between\">\n          <div className=\"flex items-center space-x-2\">\n            <span className=\"rounded bg-blue-600 px-2 py-1 text-xs text-white\">{event.type}</span>\n            <span className=\"text-sm text-gray-300\">{event.moduleId}</span>\n          </div>\n          <span className=\"text-xs text-gray-400\">\n            {new Date(event.timestamp).toLocaleTimeString()}\n          </span>\n        </div>\n\n        {isExpanded && (\n          <div className=\"mt-2 rounded bg-gray-800 p-2\">\n            <pre className=\"text-xs text-gray-300\">{JSON.stringify(event.data, null, 2)}</pre>\n          </div>\n        )}\n      </div>\n    );\n  };\n\n  // Row virtualization component\n  const Row = ({ index, style }: { index: number; style: React.CSSProperties }) => {\n    const event = displayedEvents[index];\n    if (!event) return null;\n\n    const eventId = event.moduleId + event.timestamp;\n    const isExpanded = expandedEventIds.has(eventId);\n    const onClick = () => handleEventClick(eventId);\n\n    return rowRenderer\n      ? rowRenderer({ event, index, style, onClick, isExpanded })\n      : defaultRowRenderer({ event, index, style, onClick, isExpanded });\n  };\n\n  // If no events, show empty state\n  if (displayedEvents.length === 0) {\n    return (\n      <div\n        ref={containerRef}\n        className={`flex h-${height} w-full items-center justify-center rounded bg-gray-800 ${className}`}\n        style={{ height, width }}\n      >\n        <div className=\"text-center text-gray-400\">No events to display</div>\n      </div>\n    );\n  }\n\n  return (\n    <div className={className}>\n      <div\n        ref={containerRef}\n        className=\"overflow-hidden rounded bg-gray-800\"\n        style={{ height, width }}\n      >\n        <InfiniteLoader\n          ref={infiniteLoaderRef}\n          isItemLoaded={index => index < displayedEvents.length}\n          itemCount={hasMoreEvents ? displayedEvents.length + 1 : displayedEvents.length}\n          loadMoreItems={loadMore}\n        >\n          {({ onItemsRendered, ref }) => (\n            <List\n              className=\"scrollbar-thin scrollbar-thumb-gray-600 scrollbar-track-gray-800\"\n              height={containerSize.height}\n              width={containerSize.width}\n              itemCount={displayedEvents.length}\n              itemSize={rowHeight}\n              onItemsRendered={onItemsRendered}\n              ref={list => {\n                // For InfiniteLoader\n                ref(list);\n                // For our component's reference\n                listRefCallback(list);\n              }}\n            >\n              {Row}\n            </List>\n          )}\n        </InfiniteLoader>\n      </div>\n\n      <div className=\"mt-2 flex items-center justify-between text-xs text-gray-500\">\n        <span>Displaying {displayedEvents.length} events (virtualized)</span>\n        {isLoadingMore && <span>Loading more events...</span>}\n      </div>\n    </div>\n  );\n};\n\nexport default React.memo(VirtualizedEventLog);\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/modules/ModuleCard.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'updateStatus' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 64,
        "column": 67,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 64,
        "endColumn": 79
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import * as React from \"react\";\nimport { memo, useEffect, useState } from 'react';\nimport { useModuleStatus } from '../../../hooks/modules/useModuleStatus';\nimport { moduleManager } from '../../../managers/module/ModuleManager';\nimport { BaseEvent, EventType } from '../../../types/events/EventTypes';\nimport { Badge } from '../common/Badge';\nimport './ModuleCard.css';\n\ninterface ModuleCardProps {\n  moduleId: string;\n  onSelect?: (moduleId: string) => void;\n  isSelected?: boolean;\n  showControls?: boolean;\n  compact?: boolean;\n}\n\n// Add MODULE_UPGRADE_PROGRESS to event types if not already defined\nconst MODULE_UPGRADE_PROGRESS = 'MODULE_UPGRADE_PROGRESS';\n\n// Fix useEventSubscription implementation\nconst useUpgradeProgressTracking = (moduleId: string): number => {\n  const [progress, setProgress] = useState(0);\n\n  useEffect(() => {\n    const handleUpgradeProgress = (event: BaseEvent) => {\n      if (\n        event.moduleId === moduleId &&\n        event.data &&\n        typeof event.data === 'object' &&\n        'progress' in event.data &&\n        typeof event.data.progress === 'number'\n      ) {\n        setProgress(event.data.progress);\n      }\n    };\n\n    // Subscribe to module events\n    const unsubscribe = moduleManager.subscribeToEvent(\n      MODULE_UPGRADE_PROGRESS as EventType,\n      handleUpgradeProgress\n    );\n\n    return () => {\n      if (unsubscribe) unsubscribe();\n    };\n  }, [moduleId]);\n\n  return progress;\n};\n\n/**\n * ModuleCard component for displaying module information\n *\n * Standardized component for displaying module information across the application\n * with consistent styling, update patterns, and event subscription handling.\n */\nexport const ModuleCard = memo(function ModuleCard({\n  moduleId,\n  onSelect,\n  isSelected = false,\n  showControls = true,\n  compact = false,\n}: ModuleCardProps) {\n  const { module, currentStatus, metrics, alerts, getStatusColor, updateStatus, isLoading, error } =\n    useModuleStatus(moduleId);\n\n  // Use the upgrade progress tracking hook\n  const upgradeProgress = useUpgradeProgressTracking(moduleId);\n\n  // Handle module selection\n  const handleSelect = () => {\n    if (onSelect) {\n      onSelect(moduleId);\n    }\n  };\n\n  // Handle module activation/deactivation\n  const handleToggleActive = (e: React.MouseEvent) => {\n    e.stopPropagation();\n    if (module) {\n      moduleManager.setModuleActive(moduleId, !module.isActive);\n    }\n  };\n\n  // Handle module upgrade\n  const handleUpgrade = (e: React.MouseEvent) => {\n    e.stopPropagation();\n    if (module) {\n      moduleManager.upgradeModule(moduleId);\n    }\n  };\n\n  // Return loading state\n  if (isLoading) {\n    return (\n      <div className={`module-card module-card--loading ${compact ? 'module-card--compact' : ''}`}>\n        <div className=\"module-card__loading\">Loading module data...</div>\n      </div>\n    );\n  }\n\n  // Return error state\n  if (error || !module) {\n    return (\n      <div className={`module-card module-card--error ${compact ? 'module-card--compact' : ''}`}>\n        <div className=\"module-card__error\">{error || 'Module not found'}</div>\n      </div>\n    );\n  }\n\n  // Determine efficiency class based on metrics\n  const getEfficiencyClass = () => {\n    if (!metrics || !metrics.efficiency) return '';\n\n    if (metrics.efficiency >= 0.9) return 'module-card--high-efficiency';\n    if (metrics.efficiency >= 0.7) return 'module-card--medium-efficiency';\n    return 'module-card--low-efficiency';\n  };\n\n  return (\n    <div\n      className={`module-card ${isSelected ? 'module-card--selected' : ''} ${compact ? 'module-card--compact' : ''} ${getEfficiencyClass()} `}\n      onClick={handleSelect}\n      data-module-id={moduleId}\n      data-module-type={module.type}\n      data-module-level={module.level}\n    >\n      <div className=\"module-card__header\">\n        <h3 className=\"module-card__title\">{module.name}</h3>\n        <Badge\n          text={currentStatus}\n          color={getStatusColor(currentStatus)}\n          className=\"module-card__status-badge\"\n        />\n      </div>\n\n      {!compact && (\n        <div className=\"module-card__content\">\n          <div className=\"module-card__details\">\n            <div className=\"module-card__detail\">\n              <span className=\"module-card__detail-label\">Type:</span>\n              <span className=\"module-card__detail-value\">{module.type}</span>\n            </div>\n            <div className=\"module-card__detail\">\n              <span className=\"module-card__detail-label\">Level:</span>\n              <span className=\"module-card__detail-value\">{module.level}</span>\n            </div>\n            {metrics && (\n              <div className=\"module-card__detail\">\n                <span className=\"module-card__detail-label\">Efficiency:</span>\n                <span className=\"module-card__detail-value\">\n                  {(metrics.efficiency * 100).toFixed(1)}%\n                </span>\n              </div>\n            )}\n          </div>\n\n          {/* Show alerts if any */}\n          {alerts && alerts.length > 0 && (\n            <div className=\"module-card__alerts\">\n              <h4 className=\"module-card__section-title\">Alerts ({alerts.length})</h4>\n              <ul className=\"module-card__alert-list\">\n                {alerts.slice(0, 2).map((alert, index) => (\n                  <li\n                    key={index}\n                    className={`module-card__alert module-card__alert--${alert.level}`}\n                  >\n                    {alert.message}\n                  </li>\n                ))}\n                {alerts.length > 2 && (\n                  <li className=\"module-card__alert module-card__alert--more\">\n                    +{alerts.length - 2} more alerts\n                  </li>\n                )}\n              </ul>\n            </div>\n          )}\n\n          {/* Show upgrade progress if module is being upgraded */}\n          {upgradeProgress > 0 && upgradeProgress < 100 && (\n            <div className=\"module-card__upgrade-progress\">\n              <div className=\"module-card__progress-label\">Upgrading: {upgradeProgress}%</div>\n              <div className=\"module-card__progress-bar\">\n                <div\n                  className=\"module-card__progress-fill\"\n                  style={{ width: `${upgradeProgress}%` }}\n                ></div>\n              </div>\n            </div>\n          )}\n        </div>\n      )}\n\n      {/* Controls for activating/deactivating and upgrading */}\n      {showControls && (\n        <div className=\"module-card__controls\">\n          <button\n            className={`module-card__control-btn ${module.isActive ? 'module-card__control-btn--active' : ''}`}\n            onClick={handleToggleActive}\n          >\n            {module.isActive ? 'Deactivate' : 'Activate'}\n          </button>\n\n          <button\n            className=\"module-card__control-btn module-card__control-btn--upgrade\"\n            onClick={handleUpgrade}\n            disabled={currentStatus === 'upgrading' || upgradeProgress > 0}\n          >\n            Upgrade\n          </button>\n        </div>\n      )}\n    </div>\n  );\n});\n\n/**\n * CSS for the ModuleCard component\n */\nconst styles = `\n.module-card {\n  background-color: #f8f9fa;\n  border-radius: 8px;\n  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n  padding: 16px;\n  margin-bottom: 16px;\n  transition: all 0.2s ease-in-out;\n  cursor: pointer;\n  border-left: 4px solid #adb5bd;\n}\n\n.module-card:hover {\n  transform: translateY(-2px);\n  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);\n}\n\n.module-card--selected {\n  border-color: #007bff;\n  background-color: #f0f7ff;\n}\n\n.module-card--compact {\n  padding: 8px;\n}\n\n.module-card--loading,\n.module-card--error {\n  text-align: center;\n  padding: 24px;\n  color: #6c757d;\n}\n\n.module-card--error {\n  color: #dc3545;\n}\n\n.module-card--high-efficiency {\n  border-color: #28a745;\n}\n\n.module-card--medium-efficiency {\n  border-color: #ffc107;\n}\n\n.module-card--low-efficiency {\n  border-color: #dc3545;\n}\n\n.module-card__header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-bottom: 12px;\n}\n\n.module-card__title {\n  margin: 0;\n  font-size: 18px;\n  font-weight: 600;\n}\n\n.module-card__status-badge {\n  font-size: 12px;\n  padding: 4px 8px;\n}\n\n.module-card__content {\n  margin-bottom: 16px;\n}\n\n.module-card__details {\n  display: grid;\n  grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));\n  gap: 8px;\n  margin-bottom: 12px;\n}\n\n.module-card__detail {\n  display: flex;\n  flex-direction: column;\n}\n\n.module-card__detail-label {\n  font-size: 12px;\n  color: #6c757d;\n  margin-bottom: 2px;\n}\n\n.module-card__detail-value {\n  font-weight: 500;\n}\n\n.module-card__alerts {\n  margin-top: 12px;\n}\n\n.module-card__section-title {\n  font-size: 14px;\n  margin-bottom: 8px;\n  color: #495057;\n}\n\n.module-card__alert-list {\n  list-style: none;\n  padding: 0;\n  margin: 0;\n}\n\n.module-card__alert {\n  padding: 6px 8px;\n  border-radius: 4px;\n  margin-bottom: 4px;\n  font-size: 12px;\n}\n\n.module-card__alert--info {\n  background-color: #cfe2ff;\n  color: #084298;\n}\n\n.module-card__alert--warning {\n  background-color: #fff3cd;\n  color: #664d03;\n}\n\n.module-card__alert--error {\n  background-color: #f8d7da;\n  color: #842029;\n}\n\n.module-card__alert--critical {\n  background-color: #f8d7da;\n  color: #842029;\n  font-weight: bold;\n}\n\n.module-card__alert--more {\n  text-align: center;\n  background-color: #e9ecef;\n  color: #495057;\n}\n\n.module-card__upgrade-progress {\n  margin-top: 12px;\n}\n\n.module-card__progress-label {\n  font-size: 12px;\n  margin-bottom: 4px;\n  color: #495057;\n}\n\n.module-card__progress-bar {\n  height: 6px;\n  background-color: #e9ecef;\n  border-radius: 3px;\n  overflow: hidden;\n}\n\n.module-card__progress-fill {\n  height: 100%;\n  background-color: #007bff;\n  transition: width 0.3s ease;\n}\n\n.module-card__controls {\n  display: flex;\n  justify-content: space-between;\n  gap: 8px;\n}\n\n.module-card__control-btn {\n  flex: 1;\n  padding: 8px;\n  border: none;\n  border-radius: 4px;\n  background-color: #e9ecef;\n  color: #495057;\n  font-weight: 500;\n  cursor: pointer;\n  transition: all 0.2s;\n}\n\n.module-card__control-btn:hover {\n  background-color: #dee2e6;\n}\n\n.module-card__control-btn--active {\n  background-color: #cfe2ff;\n  color: #084298;\n}\n\n.module-card__control-btn--upgrade {\n  background-color: #d1e7dd;\n  color: #0f5132;\n}\n\n.module-card__control-btn--upgrade:hover {\n  background-color: #a3cfbb;\n}\n\n.module-card__control-btn:disabled {\n  opacity: 0.5;\n  cursor: not-allowed;\n}\n`;\n\n// Add the styles to the document head\nif (typeof document !== 'undefined') {\n  const styleElement = document.createElement('style');\n  styleElement.textContent = styles;\n  document.head.appendChild(styleElement);\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/modules/ModuleGrid.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/modules/ModuleHUD.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/modules/ModuleStatusDisplay.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/modules/ModuleUpgradeDisplay.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/modules/ModuleUpgradeVisualization.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/modules/SubModuleHUD.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/performance/AdvancedMetricAnalysis.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/performance/AnimationFrameManagerDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/performance/AnimationPerformanceProfilerDemo.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 107,
        "column": 36,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 107,
        "endColumn": 39,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3268, 3271], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3268, 3271], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'targetHeight' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 277,
        "column": 25,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 277,
        "endColumn": 37
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import * as d3 from 'd3';\nimport * as React from \"react\";\nimport { useEffect, useRef, useState } from 'react';\nimport {\n  AnimationConfig,\n  createTypedTimer,\n  typedInterpolators,\n} from '../../../types/visualizations/D3AnimationTypes';\nimport {\n  AnimationPerformanceReport,\n  createAnimationProfiler,\n  formatPerformanceReport,\n} from '../../../utils/performance/D3AnimationProfiler';\n\ninterface AnimationPerformanceProfilerDemoProps {\n  width?: number;\n  height?: number;\n}\n\n/**\n * Demo component showcasing the animation performance profiler\n *\n * This component:\n * 1. Creates different types of animations of varying complexity\n * 2. Profiles each animation to measure performance\n * 3. Visualizes the performance metrics and bottlenecks\n * 4. Provides controls to adjust animation parameters\n */\nconst AnimationPerformanceProfilerDemo: React.FC<AnimationPerformanceProfilerDemoProps> = ({\n  width = 900,\n  height = 600,\n}) => {\n  const svgRef = useRef<SVGSVGElement>(null);\n  const [animationConfig, setAnimationConfig] = useState<AnimationConfig>({\n    duration: 2000,\n    easing: d3.easeCubicInOut,\n    loop: true,\n    loopDelay: 500,\n  });\n  const [animationComplexity, setAnimationComplexity] = useState('medium');\n  const [profilerEnabled, setProfilerEnabled] = useState(true);\n  const [currentReport, setCurrentReport] = useState<AnimationPerformanceReport | null>(null);\n  const [isAnimating, setIsAnimating] = useState(false);\n  const [profilerView, setProfilerView] = useState<'summary' | 'frames' | 'recommendations'>(\n    'summary'\n  );\n\n  // Animation data based on complexity\n  const getAnimationData = () => {\n    const baseCount =\n      animationComplexity === 'low'\n        ? 20\n        : animationComplexity === 'medium'\n          ? 50\n          : animationComplexity === 'high'\n            ? 200\n            : 500;\n\n    return Array.from({ length: baseCount }, (_, i) => ({\n      id: `element-${i}`,\n      x: Math.random() * (width - 40),\n      y: Math.random() * (height - 40),\n      size: Math.random() * 20 + 5,\n      color: d3.interpolateSpectral(i / baseCount),\n      targetX: Math.random() * (width - 40),\n      targetY: Math.random() * (height - 40),\n      targetSize: Math.random() * 20 + 5,\n      targetColor: d3.interpolateSpectral((i + baseCount / 2) / baseCount),\n    }));\n  };\n\n  // Run animation with performance profiling\n  useEffect(() => {\n    if (!svgRef.current || !isAnimating) return;\n\n    // Clear any existing content\n    d3.select(svgRef.current).selectAll('*').remove();\n\n    // Create profiler if enabled\n    const profiler = profilerEnabled\n      ? createAnimationProfiler({\n          targetFps: 60,\n          detailedMetrics: true,\n          onComplete: report => {\n            setCurrentReport(report);\n          },\n        })\n      : null;\n\n    // Start profiling if enabled\n    if (profiler) {\n      profiler.start(\n        'circles-animation',\n        `Circles Animation (${animationComplexity} complexity)`,\n        animationConfig\n      );\n    }\n\n    // Get animation data based on complexity\n    const data = getAnimationData();\n\n    // Create the SVG and elements\n    const svg = d3.select(svgRef.current);\n\n    // Add circles for each data point\n    const circles = svg\n      .selectAll<SVGCircleElement, any>('circle')\n      .data(data, d => d.id)\n      .join('circle')\n      .attr('cx', d => d.x)\n      .attr('cy', d => d.y)\n      .attr('r', d => d.size)\n      .attr('fill', d => d.color);\n\n    // Create object interpolators for each data point\n    const interpolators = data.map(item => {\n      return {\n        position: typedInterpolators.object(\n          {\n            x: item.x,\n            y: item.y,\n          },\n          {\n            x: item.targetX,\n            y: item.targetY,\n          }\n        ),\n        size: typedInterpolators.number(item.size, item.targetSize),\n        color: typedInterpolators.color(item.color, item.targetColor),\n      };\n    });\n\n    // Wrap interpolators for profiling if enabled\n    const profiledInterpolators = profiler\n      ? interpolators.map(interp => ({\n          position: profiler.wrapInterpolator(interp.position),\n          size: profiler.wrapInterpolator(interp.size),\n          color: profiler.wrapInterpolator(interp.color),\n        }))\n      : interpolators;\n\n    // Create selection wrapper for profiling if enabled\n    const wrappedCircles = profiler ? profiler.wrapSelection(circles) : circles;\n\n    // Animation timer\n    const timer = createTypedTimer({\n      callback: elapsed => {\n        // Calculate progress based on elapsed time (ping-pong effect)\n        const totalDuration = animationConfig.duration * 2;\n        const normalizedTime = (elapsed % totalDuration) / animationConfig.duration;\n        const t = normalizedTime <= 1 ? normalizedTime : 2 - normalizedTime;\n\n        // Record frame metrics if profiling\n        if (profiler) {\n          profiler.recordFrame({\n            interpolationCount: data.length * 3, // position, size, color\n            domUpdateCount: data.length, // One DOM update per circle\n          });\n        }\n\n        // Update circles with interpolated values\n        wrappedCircles.each(function (d, i) {\n          const interp = profiledInterpolators[i];\n          const pos = interp.position(t);\n          const size = interp.size(t);\n          const color = interp.color(t);\n\n          d3.select(this).attr('cx', pos.x).attr('cy', pos.y).attr('r', size).attr('fill', color);\n        });\n\n        // Stop after one cycle if not looping\n        if (!animationConfig.loop && elapsed >= totalDuration) {\n          if (profiler) {\n            profiler.stop();\n          }\n          setIsAnimating(false);\n          return true;\n        }\n\n        return false;\n      },\n    });\n\n    // Clean up\n    return () => {\n      timer.stop();\n      if (profiler && profiler.getStatus().isRunning) {\n        profiler.stop();\n      }\n    };\n  }, [isAnimating, animationConfig, animationComplexity, profilerEnabled, width, height]);\n\n  // Start animation\n  const handleStartAnimation = () => {\n    setIsAnimating(true);\n    setCurrentReport(null);\n  };\n\n  // Stop animation\n  const handleStopAnimation = () => {\n    setIsAnimating(false);\n  };\n\n  // Render performance metrics visualization\n  const renderPerformanceMetrics = () => {\n    if (!currentReport)\n      return <div className=\"text-gray-400\">No performance data yet. Run an animation first.</div>;\n\n    const { performanceData, performanceScore, bottlenecks } = currentReport;\n\n    switch (profilerView) {\n      case 'summary':\n        return (\n          <div className=\"performance-summary\">\n            <div className=\"metrics-card\">\n              <div className=\"metrics-header\">\n                <h3>Performance Score</h3>\n                <div\n                  className={`score-badge ${performanceScore >= 80 ? 'good' : performanceScore >= 60 ? 'medium' : 'poor'}`}\n                >\n                  {performanceScore}/100\n                </div>\n              </div>\n              <div className=\"metrics-row\">\n                <div className=\"metric-item\">\n                  <div className=\"metric-label\">FPS</div>\n                  <div className=\"metric-value\">\n                    {performanceData.actualFps.toFixed(1)}/{performanceData.targetFps}\n                  </div>\n                </div>\n                <div className=\"metric-item\">\n                  <div className=\"metric-label\">Dropped Frames</div>\n                  <div className=\"metric-value\">\n                    {performanceData.droppedFrames}/{performanceData.frames.length}\n                  </div>\n                </div>\n                <div className=\"metric-item\">\n                  <div className=\"metric-label\">Avg Frame Time</div>\n                  <div className=\"metric-value\">\n                    {performanceData.averageFrameDuration.toFixed(2)} ms\n                  </div>\n                </div>\n              </div>\n            </div>\n\n            {bottlenecks.length > 0 && (\n              <div className=\"bottlenecks-card\">\n                <h3>Bottlenecks Detected</h3>\n                {bottlenecks.map((bottleneck, i) => (\n                  <div key={i} className=\"bottleneck-item\">\n                    <div className=\"bottleneck-header\">\n                      <span className=\"bottleneck-type\">{bottleneck.type.replace('_', ' ')}</span>\n                      <span\n                        className={`severity-badge ${bottleneck.severity > 0.7 ? 'high' : bottleneck.severity > 0.3 ? 'medium' : 'low'}`}\n                      >\n                        {(bottleneck.severity * 100).toFixed(0)}% severity\n                      </span>\n                    </div>\n                    <p className=\"bottleneck-description\">{bottleneck.description}</p>\n                    <p className=\"bottleneck-suggestion\">{bottleneck.suggestion}</p>\n                  </div>\n                ))}\n              </div>\n            )}\n          </div>\n        );\n\n      case 'frames':\n        return (\n          <div className=\"frames-analysis\">\n            <h3>Frame Analysis</h3>\n            <div className=\"frame-chart\">\n              <svg width={width - 40} height={200}>\n                {performanceData.frames.map((frame, i) => {\n                  const x = (i / performanceData.frames.length) * (width - 40);\n                  const frameHeight = (frame.frameDuration / (1000 / 30)) * 150;\n                  const targetHeight = (1000 / performanceData.targetFps / (1000 / 30)) * 150;\n\n                  return (\n                    <g key={i}>\n                      <rect\n                        x={x}\n                        y={150 - Math.min(frameHeight, 150)}\n                        width={Math.max(1, (width - 40) / performanceData.frames.length - 1)}\n                        height={Math.min(frameHeight, 150)}\n                        fill={\n                          frame.frameDuration > 1000 / performanceData.targetFps\n                            ? '#e74c3c'\n                            : '#2ecc71'\n                        }\n                        opacity={0.7}\n                      />\n                      {i % Math.floor(performanceData.frames.length / 5) === 0 && (\n                        <text x={x} y={175} fontSize=\"10\" textAnchor=\"middle\">\n                          {i}\n                        </text>\n                      )}\n                    </g>\n                  );\n                })}\n\n                {/* Target frame duration line */}\n                <line\n                  x1={0}\n                  y1={150 - (1000 / performanceData.targetFps / (1000 / 30)) * 150}\n                  x2={width - 40}\n                  y2={150 - (1000 / performanceData.targetFps / (1000 / 30)) * 150}\n                  stroke=\"#3498db\"\n                  strokeWidth={1}\n                  strokeDasharray=\"4,4\"\n                />\n                <text\n                  x={width - 45}\n                  y={150 - (1000 / performanceData.targetFps / (1000 / 30)) * 150 - 5}\n                  fontSize=\"10\"\n                  fill=\"#3498db\"\n                  textAnchor=\"end\"\n                >\n                  Target ({(1000 / performanceData.targetFps).toFixed(1)}ms)\n                </text>\n              </svg>\n            </div>\n\n            <div className=\"frame-metrics\">\n              <div className=\"frame-metric-item\">\n                <div className=\"metric-label\">Min Frame Time</div>\n                <div className=\"metric-value\">{performanceData.minFrameDuration.toFixed(2)} ms</div>\n              </div>\n              <div className=\"frame-metric-item\">\n                <div className=\"metric-label\">Max Frame Time</div>\n                <div className=\"metric-value\">{performanceData.maxFrameDuration.toFixed(2)} ms</div>\n              </div>\n              <div className=\"frame-metric-item\">\n                <div className=\"metric-label\">Frame Success Rate</div>\n                <div className=\"metric-value\">\n                  {(performanceData.frameSuccessRate * 100).toFixed(1)}%\n                </div>\n              </div>\n            </div>\n          </div>\n        );\n\n      case 'recommendations':\n        return (\n          <div className=\"recommendations\">\n            <h3>Optimization Recommendations</h3>\n            <div className=\"recommendations-list\">\n              {currentReport.recommendations.map((rec, i) => (\n                <div key={i} className=\"recommendation-item\">\n                  <div className=\"recommendation-number\">{i + 1}</div>\n                  <div className=\"recommendation-text\">{rec}</div>\n                </div>\n              ))}\n\n              {currentReport.recommendations.length === 0 && (\n                <div className=\"text-gray-400\">No specific recommendations.</div>\n              )}\n            </div>\n\n            <div className=\"report-text\">\n              <h4>Full Report</h4>\n              <pre className=\"report-content\">{formatPerformanceReport(currentReport)}</pre>\n            </div>\n          </div>\n        );\n    }\n  };\n\n  return (\n    <div className=\"animation-performance-profiler-demo\">\n      <h2>Animation Performance Profiler Demo</h2>\n\n      <div className=\"controls\">\n        <div className=\"control-section\">\n          <h3>Animation Settings</h3>\n          <div className=\"control-row\">\n            <label>\n              Duration:\n              <input\n                type=\"range\"\n                min=\"500\"\n                max=\"5000\"\n                step=\"100\"\n                value={animationConfig.duration}\n                onChange={e =>\n                  setAnimationConfig({\n                    ...animationConfig,\n                    duration: parseInt(e.target.value),\n                  })\n                }\n                disabled={isAnimating}\n              />\n              <span>{animationConfig.duration}ms</span>\n            </label>\n          </div>\n\n          <div className=\"control-row\">\n            <label>\n              Complexity:\n              <select\n                value={animationComplexity}\n                onChange={e => setAnimationComplexity(e.target.value)}\n                disabled={isAnimating}\n              >\n                <option value=\"low\">Low (20 elements)</option>\n                <option value=\"medium\">Medium (50 elements)</option>\n                <option value=\"high\">High (200 elements)</option>\n                <option value=\"extreme\">Extreme (500 elements)</option>\n              </select>\n            </label>\n          </div>\n\n          <div className=\"control-row\">\n            <label>\n              <input\n                type=\"checkbox\"\n                checked={animationConfig.loop}\n                onChange={e =>\n                  setAnimationConfig({\n                    ...animationConfig,\n                    loop: e.target.checked,\n                  })\n                }\n                disabled={isAnimating}\n              />\n              Loop Animation\n            </label>\n          </div>\n\n          <div className=\"control-row\">\n            <label>\n              <input\n                type=\"checkbox\"\n                checked={profilerEnabled}\n                onChange={e => setProfilerEnabled(e.target.checked)}\n                disabled={isAnimating}\n              />\n              Enable Profiling\n            </label>\n          </div>\n        </div>\n\n        <div className=\"button-group\">\n          {!isAnimating ? (\n            <button className=\"start-button\" onClick={handleStartAnimation}>\n              Start Animation\n            </button>\n          ) : (\n            <button className=\"stop-button\" onClick={handleStopAnimation}>\n              Stop Animation\n            </button>\n          )}\n        </div>\n      </div>\n\n      <div className=\"visualization\">\n        <svg ref={svgRef} width={width} height={height} className=\"animation-svg\"></svg>\n      </div>\n\n      {profilerEnabled && (\n        <div className=\"performance-metrics\">\n          <div className=\"metrics-tabs\">\n            <button\n              className={profilerView === 'summary' ? 'active' : ''}\n              onClick={() => setProfilerView('summary')}\n            >\n              Summary\n            </button>\n            <button\n              className={profilerView === 'frames' ? 'active' : ''}\n              onClick={() => setProfilerView('frames')}\n            >\n              Frame Analysis\n            </button>\n            <button\n              className={profilerView === 'recommendations' ? 'active' : ''}\n              onClick={() => setProfilerView('recommendations')}\n            >\n              Recommendations\n            </button>\n          </div>\n\n          <div className=\"metrics-content\">{renderPerformanceMetrics()}</div>\n        </div>\n      )}\n\n      <style jsx>{`\n        .animation-performance-profiler-demo {\n          width: 100%;\n          max-width: ${width}px;\n          margin: 0 auto;\n          font-family:\n            system-ui,\n            -apple-system,\n            BlinkMacSystemFont,\n            'Segoe UI',\n            Roboto,\n            sans-serif;\n        }\n\n        h2 {\n          text-align: center;\n          margin-bottom: 20px;\n        }\n\n        .controls {\n          display: flex;\n          justify-content: space-between;\n          align-items: flex-start;\n          margin-bottom: 20px;\n          padding: 15px;\n          background: #f5f5f5;\n          border-radius: 8px;\n        }\n\n        .control-section {\n          flex: 1;\n        }\n\n        .control-section h3 {\n          margin-top: 0;\n          margin-bottom: 10px;\n        }\n\n        .control-row {\n          margin-bottom: 10px;\n        }\n\n        label {\n          display: flex;\n          align-items: center;\n          gap: 10px;\n        }\n\n        input[type='range'] {\n          flex: 1;\n        }\n\n        select {\n          padding: 5px;\n          border-radius: 4px;\n          border: 1px solid #ccc;\n        }\n\n        .button-group {\n          display: flex;\n          flex-direction: column;\n          gap: 10px;\n          justify-content: center;\n          margin-left: 20px;\n        }\n\n        button {\n          padding: 10px 15px;\n          border: none;\n          border-radius: 4px;\n          cursor: pointer;\n          font-weight: bold;\n        }\n\n        .start-button {\n          background: #27ae60;\n          color: white;\n        }\n\n        .stop-button {\n          background: #e74c3c;\n          color: white;\n        }\n\n        .visualization {\n          margin-bottom: 20px;\n        }\n\n        .animation-svg {\n          width: 100%;\n          height: ${height}px;\n          background: #f8f9fa;\n          border: 1px solid #ddd;\n          border-radius: 8px;\n        }\n\n        .performance-metrics {\n          background: #f5f5f5;\n          border-radius: 8px;\n          padding: 15px;\n        }\n\n        .metrics-tabs {\n          display: flex;\n          margin-bottom: 15px;\n          border-bottom: 1px solid #ddd;\n        }\n\n        .metrics-tabs button {\n          background: transparent;\n          border: none;\n          padding: 10px 15px;\n          margin-right: 5px;\n          border-radius: 4px 4px 0 0;\n          cursor: pointer;\n        }\n\n        .metrics-tabs button.active {\n          background: #3498db;\n          color: white;\n        }\n\n        .metrics-content {\n          padding: 10px;\n        }\n\n        .performance-summary {\n          display: flex;\n          flex-direction: column;\n          gap: 20px;\n        }\n\n        .metrics-card {\n          background: white;\n          border-radius: 8px;\n          padding: 15px;\n          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n        }\n\n        .metrics-header {\n          display: flex;\n          justify-content: space-between;\n          align-items: center;\n          margin-bottom: 15px;\n        }\n\n        .metrics-header h3 {\n          margin: 0;\n        }\n\n        .score-badge {\n          padding: 5px 10px;\n          border-radius: 20px;\n          font-weight: bold;\n        }\n\n        .score-badge.good {\n          background: #27ae60;\n          color: white;\n        }\n\n        .score-badge.medium {\n          background: #f39c12;\n          color: white;\n        }\n\n        .score-badge.poor {\n          background: #e74c3c;\n          color: white;\n        }\n\n        .metrics-row {\n          display: flex;\n          justify-content: space-between;\n        }\n\n        .metric-item {\n          text-align: center;\n          flex: 1;\n        }\n\n        .metric-label {\n          font-size: 0.9em;\n          color: #7f8c8d;\n          margin-bottom: 5px;\n        }\n\n        .metric-value {\n          font-size: 1.2em;\n          font-weight: bold;\n        }\n\n        .bottlenecks-card {\n          background: white;\n          border-radius: 8px;\n          padding: 15px;\n          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n        }\n\n        .bottlenecks-card h3 {\n          margin-top: 0;\n          margin-bottom: 15px;\n        }\n\n        .bottleneck-item {\n          margin-bottom: 15px;\n          padding-bottom: 15px;\n          border-bottom: 1px solid #eee;\n        }\n\n        .bottleneck-item:last-child {\n          border-bottom: none;\n          margin-bottom: 0;\n          padding-bottom: 0;\n        }\n\n        .bottleneck-header {\n          display: flex;\n          justify-content: space-between;\n          align-items: center;\n          margin-bottom: 5px;\n        }\n\n        .bottleneck-type {\n          font-weight: bold;\n          text-transform: uppercase;\n        }\n\n        .severity-badge {\n          padding: 2px 6px;\n          border-radius: 4px;\n          font-size: 0.8em;\n        }\n\n        .severity-badge.high {\n          background: #e74c3c;\n          color: white;\n        }\n\n        .severity-badge.medium {\n          background: #f39c12;\n          color: white;\n        }\n\n        .severity-badge.low {\n          background: #27ae60;\n          color: white;\n        }\n\n        .bottleneck-description {\n          margin: 5px 0;\n        }\n\n        .bottleneck-suggestion {\n          font-style: italic;\n          color: #2980b9;\n        }\n\n        .frames-analysis h3 {\n          margin-top: 0;\n          margin-bottom: 15px;\n        }\n\n        .frame-chart {\n          background: white;\n          border-radius: 8px;\n          padding: 15px;\n          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n          margin-bottom: 20px;\n        }\n\n        .frame-metrics {\n          display: flex;\n          justify-content: space-between;\n          background: white;\n          border-radius: 8px;\n          padding: 15px;\n          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n        }\n\n        .frame-metric-item {\n          text-align: center;\n          flex: 1;\n        }\n\n        .recommendations h3 {\n          margin-top: 0;\n          margin-bottom: 15px;\n        }\n\n        .recommendations-list {\n          background: white;\n          border-radius: 8px;\n          padding: 15px;\n          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n          margin-bottom: 20px;\n        }\n\n        .recommendation-item {\n          display: flex;\n          margin-bottom: 10px;\n          padding-bottom: 10px;\n          border-bottom: 1px solid #eee;\n        }\n\n        .recommendation-item:last-child {\n          border-bottom: none;\n          margin-bottom: 0;\n          padding-bottom: 0;\n        }\n\n        .recommendation-number {\n          background: #3498db;\n          color: white;\n          width: 25px;\n          height: 25px;\n          border-radius: 50%;\n          display: flex;\n          align-items: center;\n          justify-content: center;\n          margin-right: 10px;\n          flex-shrink: 0;\n        }\n\n        .recommendation-text {\n          flex: 1;\n        }\n\n        .report-text {\n          background: white;\n          border-radius: 8px;\n          padding: 15px;\n          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n        }\n\n        .report-text h4 {\n          margin-top: 0;\n          margin-bottom: 10px;\n        }\n\n        .report-content {\n          background: #f8f9fa;\n          padding: 10px;\n          border-radius: 4px;\n          font-size: 0.85em;\n          white-space: pre-wrap;\n          overflow-x: auto;\n          max-height: 300px;\n          overflow-y: auto;\n        }\n      `}</style>\n    </div>\n  );\n};\n\nexport default AnimationPerformanceProfilerDemo;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/performance/BatchedUpdateDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/performance/D3AccessorBenchmarkView.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/performance/D3PerformanceProfilerView.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/performance/DynamicBudgetAdjustmentPanel.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'handleConfigChange' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 153,
        "column": 9,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 153,
        "endColumn": 27
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import * as React from \"react\";\nimport { useEffect, useState } from 'react';\nimport {\n  BudgetAdjustmentRecommendation,\n  DynamicBudgetAdjuster,\n  PerformanceStatistics,\n  PerformanceTelemetryConfig,\n} from '../../../utils/performance/benchmarks/DynamicBudgetAdjustment';\nimport { PerformanceBudget } from '../../../utils/performance/benchmarks/PerformanceBudgets';\nimport { Button } from '../common/Button';\n\ninterface DynamicBudgetAdjustmentPanelProps {\n  /**\n   * Initial telemetry configuration\n   */\n  initialConfig?: Partial<PerformanceTelemetryConfig>;\n\n  /**\n   * Width of the panel\n   */\n  width?: number | string;\n\n  /**\n   * Height of the panel\n   */\n  height?: number | string;\n\n  /**\n   * Callback when budgets are adjusted\n   */\n  onBudgetsAdjusted?: (newBudgets: PerformanceBudget[]) => void;\n\n  /**\n   * Whether to automatically apply recommended adjustments\n   */\n  autoApplyRecommendations?: boolean;\n\n  /**\n   * Minimum confidence level for auto-applying recommendations (0-1)\n   */\n  minConfidence?: number;\n}\n\n/**\n * Dynamic Budget Adjustment Panel\n *\n * A component that allows viewing and managing performance budgets\n * based on real-world telemetry data.\n */\nexport const DynamicBudgetAdjustmentPanel: React.FC<DynamicBudgetAdjustmentPanelProps> = ({\n  initialConfig,\n  width = '100%',\n  height = 'auto',\n  onBudgetsAdjusted,\n  autoApplyRecommendations = false,\n  minConfidence = 0.8,\n}) => {\n  // Default configuration for telemetry\n  const defaultConfig: PerformanceTelemetryConfig = {\n    enabled: true,\n    samplingRate: 0.1,\n    maxSamplesPerCategory: 1000,\n    recordDeviceInfo: true,\n    autoAdjustBudgets: false,\n    budgetBuffer: 0.2,\n    ...initialConfig,\n  };\n\n  // State\n  const [budgetAdjuster] = useState(() => new DynamicBudgetAdjuster(defaultConfig));\n  const [currentBudgets, setCurrentBudgets] = useState<PerformanceBudget[]>([]);\n  const [recommendations, setRecommendations] = useState<BudgetAdjustmentRecommendation[]>([]);\n  const [statistics, setStatistics] = useState<Map<string, PerformanceStatistics>>(new Map());\n  const [telemetryConfig, setTelemetryConfig] = useState<PerformanceTelemetryConfig>(defaultConfig);\n  const [activeTab, setActiveTab] = useState<'recommendations' | 'statistics' | 'budgets'>(\n    'recommendations'\n  );\n  const [showAppliedChanges, setShowAppliedChanges] = useState<boolean>(false);\n  const [appliedChanges, setAppliedChanges] = useState<BudgetAdjustmentRecommendation[]>([]);\n\n  // Initial load of budgets and statistics\n  useEffect(() => {\n    setCurrentBudgets(budgetAdjuster.getCurrentBudgets());\n    setStatistics(budgetAdjuster.getTelemetryStatistics());\n    setRecommendations(budgetAdjuster.checkForBudgetAdjustments());\n  }, [budgetAdjuster]);\n\n  // Auto-apply recommendations with sufficient confidence\n  useEffect(() => {\n    if (autoApplyRecommendations && recommendations.length > 0) {\n      const highConfidenceRecommendations = recommendations.filter(\n        rec => rec.confidence >= minConfidence\n      );\n\n      if (highConfidenceRecommendations.length > 0) {\n        const applied: BudgetAdjustmentRecommendation[] = [];\n\n        for (const recommendation of highConfidenceRecommendations) {\n          const success = budgetAdjuster.adjustBudget(\n            recommendation.originalBudget.name,\n            recommendation.recommendedBudget\n          );\n\n          if (success) {\n            applied.push(recommendation);\n          }\n        }\n\n        if (applied.length > 0) {\n          // Update state\n          setCurrentBudgets(budgetAdjuster.getCurrentBudgets());\n          setRecommendations(budgetAdjuster.checkForBudgetAdjustments());\n          setAppliedChanges(prev => [...prev, ...applied]);\n          setShowAppliedChanges(true);\n\n          // Notify parent component\n          if (onBudgetsAdjusted) {\n            onBudgetsAdjusted(budgetAdjuster.getCurrentBudgets());\n          }\n        }\n      }\n    }\n  }, [autoApplyRecommendations, budgetAdjuster, minConfidence, onBudgetsAdjusted, recommendations]);\n\n  // Handle applying a recommendation manually\n  const handleApplyRecommendation = (recommendation: BudgetAdjustmentRecommendation) => {\n    const success = budgetAdjuster.adjustBudget(\n      recommendation.originalBudget.name,\n      recommendation.recommendedBudget\n    );\n\n    if (success) {\n      // Update state\n      setCurrentBudgets(budgetAdjuster.getCurrentBudgets());\n      setRecommendations(budgetAdjuster.checkForBudgetAdjustments());\n      setAppliedChanges(prev => [...prev, recommendation]);\n      setShowAppliedChanges(true);\n\n      // Notify parent component\n      if (onBudgetsAdjusted) {\n        onBudgetsAdjusted(budgetAdjuster.getCurrentBudgets());\n      }\n    }\n  };\n\n  // Handle refreshing the analysis\n  const handleRefreshAnalysis = () => {\n    setStatistics(budgetAdjuster.getTelemetryStatistics());\n    setRecommendations(budgetAdjuster.checkForBudgetAdjustments());\n  };\n\n  // Handle updating telemetry configuration\n  const handleConfigChange = (newConfig: Partial<PerformanceTelemetryConfig>) => {\n    const updatedConfig = { ...telemetryConfig, ...newConfig };\n    setTelemetryConfig(updatedConfig);\n\n    // Update the adjuster with the new config\n    // Note: This is a simplified approach - in a real implementation,\n    // we would need to create a new adjuster or have a method to update config\n\n    // Refresh the analysis\n    handleRefreshAnalysis();\n  };\n\n  // Handle applying all recommendations\n  const handleApplyAllRecommendations = () => {\n    const applied: BudgetAdjustmentRecommendation[] = [];\n\n    for (const recommendation of recommendations) {\n      const success = budgetAdjuster.adjustBudget(\n        recommendation.originalBudget.name,\n        recommendation.recommendedBudget\n      );\n\n      if (success) {\n        applied.push(recommendation);\n      }\n    }\n\n    if (applied.length > 0) {\n      // Update state\n      setCurrentBudgets(budgetAdjuster.getCurrentBudgets());\n      setRecommendations(budgetAdjuster.checkForBudgetAdjustments());\n      setAppliedChanges(prev => [...prev, ...applied]);\n      setShowAppliedChanges(true);\n\n      // Notify parent component\n      if (onBudgetsAdjusted) {\n        onBudgetsAdjusted(budgetAdjuster.getCurrentBudgets());\n      }\n    }\n  };\n\n  // Handle exporting budgets to JSON\n  const handleExportBudgets = () => {\n    const budgetsJson = JSON.stringify(currentBudgets, null, 2);\n    const blob = new Blob([budgetsJson], { type: 'application/json' });\n    const url = URL.createObjectURL(blob);\n\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = `performance-budgets-${new Date().toISOString().split('T')[0]}.json`;\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    URL.revokeObjectURL(url);\n  };\n\n  return (\n    <div className=\"dynamic-budget-adjustment-panel\" style={{ width, height }}>\n      <div className=\"panel-header\">\n        <h2>Performance Budget Adjustment</h2>\n        <div className=\"panel-actions\">\n          <Button variant=\"secondary\" size=\"small\" onClick={handleRefreshAnalysis}>\n            Refresh Analysis\n          </Button>\n          <Button variant=\"secondary\" size=\"small\" onClick={handleExportBudgets}>\n            Export Budgets\n          </Button>\n        </div>\n      </div>\n\n      <div className=\"panel-tabs\">\n        <button\n          className={`tab-button ${activeTab === 'recommendations' ? 'active' : ''}`}\n          onClick={() => setActiveTab('recommendations')}\n        >\n          Recommendations ({recommendations.length})\n        </button>\n        <button\n          className={`tab-button ${activeTab === 'statistics' ? 'active' : ''}`}\n          onClick={() => setActiveTab('statistics')}\n        >\n          Statistics\n        </button>\n        <button\n          className={`tab-button ${activeTab === 'budgets' ? 'active' : ''}`}\n          onClick={() => setActiveTab('budgets')}\n        >\n          Current Budgets\n        </button>\n      </div>\n\n      <div className=\"panel-content\">\n        {/* Recommendations Tab */}\n        {activeTab === 'recommendations' && (\n          <div className=\"recommendations-tab\">\n            {showAppliedChanges && appliedChanges.length > 0 && (\n              <div className=\"applied-changes-notice\">\n                <div className=\"notice-header\">\n                  <h3>Recently Applied Changes</h3>\n                  <button className=\"close-button\" onClick={() => setShowAppliedChanges(false)}>\n                    ×\n                  </button>\n                </div>\n                <ul className=\"applied-changes-list\">\n                  {appliedChanges.slice(-5).map((change, index) => (\n                    <li key={`applied-${index}`} className=\"applied-change-item\">\n                      <span className=\"budget-name\">{change.originalBudget.name}</span>:\n                      {change.originalBudget.maxExecutionTimeMs !==\n                        change.recommendedBudget.maxExecutionTimeMs && (\n                        <span className=\"change-detail\">\n                          Execution time: {change.originalBudget.maxExecutionTimeMs}ms →{' '}\n                          {change.recommendedBudget.maxExecutionTimeMs}ms\n                        </span>\n                      )}\n                      {change.originalBudget.maxMemoryUsageMB !==\n                        change.recommendedBudget.maxMemoryUsageMB && (\n                        <span className=\"change-detail\">\n                          Memory: {change.originalBudget.maxMemoryUsageMB}MB →{' '}\n                          {change.recommendedBudget.maxMemoryUsageMB}MB\n                        </span>\n                      )}\n                      {change.originalBudget.minOperationsPerSecond !==\n                        change.recommendedBudget.minOperationsPerSecond && (\n                        <span className=\"change-detail\">\n                          Operations: {change.originalBudget.minOperationsPerSecond} →{' '}\n                          {change.recommendedBudget.minOperationsPerSecond} ops/s\n                        </span>\n                      )}\n                    </li>\n                  ))}\n                </ul>\n              </div>\n            )}\n\n            {recommendations.length === 0 ? (\n              <div className=\"empty-state\">\n                <p>No budget adjustment recommendations at this time.</p>\n                <p className=\"hint\">\n                  This could be because there's not enough telemetry data or the current budgets are\n                  appropriate.\n                </p>\n              </div>\n            ) : (\n              <>\n                <div className=\"recommendations-header\">\n                  <h3>{recommendations.length} Recommendations Available</h3>\n                  <Button variant=\"primary\" size=\"small\" onClick={handleApplyAllRecommendations}>\n                    Apply All\n                  </Button>\n                </div>\n\n                <div className=\"recommendations-list\">\n                  {recommendations.map((recommendation, index) => (\n                    <div key={`rec-${index}`} className=\"recommendation-card\">\n                      <div className=\"recommendation-header\">\n                        <h4>{recommendation.originalBudget.name}</h4>\n                        <div\n                          className=\"confidence-badge\"\n                          style={{\n                            backgroundColor:\n                              recommendation.confidence >= 0.8\n                                ? '#e8f5e9'\n                                : recommendation.confidence >= 0.6\n                                  ? '#fff8e1'\n                                  : '#ffebee',\n                          }}\n                        >\n                          {(recommendation.confidence * 100).toFixed(0)}% confidence\n                        </div>\n                      </div>\n\n                      <p className=\"recommendation-reason\">{recommendation.reason}</p>\n\n                      <div className=\"recommendation-details\">\n                        <div className=\"stats-section\">\n                          <h5>Statistics</h5>\n                          <div className=\"stat-grid\">\n                            <div className=\"stat-row\">\n                              <div className=\"stat-label\">Samples</div>\n                              <div className=\"stat-value\">\n                                {recommendation.statistics.sampleCount}\n                              </div>\n                            </div>\n                            <div className=\"stat-row\">\n                              <div className=\"stat-label\">p95 Time</div>\n                              <div className=\"stat-value\">\n                                {recommendation.statistics.p95ExecutionTimeMs.toFixed(2)}ms\n                              </div>\n                            </div>\n                            <div className=\"stat-row\">\n                              <div className=\"stat-label\">Mean Time</div>\n                              <div className=\"stat-value\">\n                                {recommendation.statistics.meanExecutionTimeMs.toFixed(2)}ms\n                              </div>\n                            </div>\n                            {recommendation.statistics.p95MemoryUsageMB && (\n                              <div className=\"stat-row\">\n                                <div className=\"stat-label\">p95 Memory</div>\n                                <div className=\"stat-value\">\n                                  {recommendation.statistics.p95MemoryUsageMB.toFixed(2)}MB\n                                </div>\n                              </div>\n                            )}\n                          </div>\n                        </div>\n\n                        <div className=\"changes-section\">\n                          <h5>Proposed Changes</h5>\n                          <div className=\"change-grid\">\n                            {recommendation.originalBudget.maxExecutionTimeMs !==\n                              recommendation.recommendedBudget.maxExecutionTimeMs && (\n                              <div className=\"change-row\">\n                                <div className=\"change-label\">Execution Time</div>\n                                <div className=\"change-value\">\n                                  <span className=\"old-value\">\n                                    {recommendation.originalBudget.maxExecutionTimeMs}ms\n                                  </span>\n                                  <span className=\"arrow\">→</span>\n                                  <span className=\"new-value\">\n                                    {recommendation.recommendedBudget.maxExecutionTimeMs}ms\n                                  </span>\n                                </div>\n                              </div>\n                            )}\n\n                            {recommendation.originalBudget.maxMemoryUsageMB !==\n                              recommendation.recommendedBudget.maxMemoryUsageMB && (\n                              <div className=\"change-row\">\n                                <div className=\"change-label\">Memory Usage</div>\n                                <div className=\"change-value\">\n                                  <span className=\"old-value\">\n                                    {recommendation.originalBudget.maxMemoryUsageMB}MB\n                                  </span>\n                                  <span className=\"arrow\">→</span>\n                                  <span className=\"new-value\">\n                                    {recommendation.recommendedBudget.maxMemoryUsageMB}MB\n                                  </span>\n                                </div>\n                              </div>\n                            )}\n\n                            {recommendation.originalBudget.minOperationsPerSecond !==\n                              recommendation.recommendedBudget.minOperationsPerSecond && (\n                              <div className=\"change-row\">\n                                <div className=\"change-label\">Operations/Second</div>\n                                <div className=\"change-value\">\n                                  <span className=\"old-value\">\n                                    {recommendation.originalBudget.minOperationsPerSecond}\n                                  </span>\n                                  <span className=\"arrow\">→</span>\n                                  <span className=\"new-value\">\n                                    {recommendation.recommendedBudget.minOperationsPerSecond}\n                                  </span>\n                                </div>\n                              </div>\n                            )}\n                          </div>\n                        </div>\n                      </div>\n\n                      <div className=\"recommendation-actions\">\n                        <Button\n                          variant=\"primary\"\n                          size=\"small\"\n                          onClick={() => handleApplyRecommendation(recommendation)}\n                        >\n                          Apply Changes\n                        </Button>\n                      </div>\n                    </div>\n                  ))}\n                </div>\n              </>\n            )}\n          </div>\n        )}\n\n        {/* Statistics Tab */}\n        {activeTab === 'statistics' && (\n          <div className=\"statistics-tab\">\n            {statistics.size === 0 ? (\n              <div className=\"empty-state\">\n                <p>No performance statistics available yet.</p>\n                <p className=\"hint\">\n                  Run tests or collect real-world telemetry to see statistics here.\n                </p>\n              </div>\n            ) : (\n              <div className=\"statistics-list\">\n                <div className=\"stats-header-row\">\n                  <div className=\"operation-column\">Operation</div>\n                  <div className=\"samples-column\">Samples</div>\n                  <div className=\"time-column\">p95 Time (ms)</div>\n                  <div className=\"time-column\">Mean Time (ms)</div>\n                  <div className=\"memory-column\">p95 Memory (MB)</div>\n                  <div className=\"ops-column\">Mean Ops/Sec</div>\n                </div>\n\n                <div className=\"stats-rows\">\n                  {Array.from(statistics.entries()).map(([name, stats], index) => (\n                    <div key={`stats-${index}`} className=\"stats-row\">\n                      <div className=\"operation-column\">{name}</div>\n                      <div className=\"samples-column\">{stats.sampleCount}</div>\n                      <div className=\"time-column\">{stats.p95ExecutionTimeMs.toFixed(2)}</div>\n                      <div className=\"time-column\">{stats.meanExecutionTimeMs.toFixed(2)}</div>\n                      <div className=\"memory-column\">\n                        {stats.p95MemoryUsageMB?.toFixed(2) || 'N/A'}\n                      </div>\n                      <div className=\"ops-column\">\n                        {stats.meanOperationsPerSecond?.toFixed(2) || 'N/A'}\n                      </div>\n                    </div>\n                  ))}\n                </div>\n              </div>\n            )}\n          </div>\n        )}\n\n        {/* Budgets Tab */}\n        {activeTab === 'budgets' && (\n          <div className=\"budgets-tab\">\n            <div className=\"budgets-list\">\n              <div className=\"budget-header-row\">\n                <div className=\"operation-column\">Operation</div>\n                <div className=\"category-column\">Category</div>\n                <div className=\"critical-column\">Critical</div>\n                <div className=\"time-column\">Max Time (ms)</div>\n                <div className=\"memory-column\">Max Memory (MB)</div>\n                <div className=\"ops-column\">Min Ops/Sec</div>\n              </div>\n\n              <div className=\"budget-rows\">\n                {currentBudgets.map((budget, index) => (\n                  <div key={`budget-${index}`} className=\"budget-row\">\n                    <div className=\"operation-column\">{budget.name}</div>\n                    <div className=\"category-column\">{budget.category}</div>\n                    <div className=\"critical-column\">\n                      <span className={`critical-badge ${budget.critical ? 'yes' : 'no'}`}>\n                        {budget.critical ? 'Yes' : 'No'}\n                      </span>\n                    </div>\n                    <div className=\"time-column\">{budget.maxExecutionTimeMs}</div>\n                    <div className=\"memory-column\">{budget.maxMemoryUsageMB || 'N/A'}</div>\n                    <div className=\"ops-column\">{budget.minOperationsPerSecond || 'N/A'}</div>\n                  </div>\n                ))}\n              </div>\n            </div>\n          </div>\n        )}\n      </div>\n\n      <style jsx>{`\n        .dynamic-budget-adjustment-panel {\n          font-family:\n            -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell,\n            'Open Sans', 'Helvetica Neue', sans-serif;\n          border: 1px solid #e0e0e0;\n          border-radius: 4px;\n          overflow: hidden;\n          display: flex;\n          flex-direction: column;\n          background-color: white;\n        }\n\n        .panel-header {\n          padding: 16px;\n          border-bottom: 1px solid #e0e0e0;\n          display: flex;\n          justify-content: space-between;\n          align-items: center;\n        }\n\n        .panel-header h2 {\n          margin: 0;\n          font-size: 20px;\n          color: #333;\n        }\n\n        .panel-actions {\n          display: flex;\n          gap: 8px;\n        }\n\n        .panel-tabs {\n          display: flex;\n          border-bottom: 1px solid #e0e0e0;\n          background-color: #f5f5f5;\n        }\n\n        .tab-button {\n          padding: 12px 16px;\n          border: none;\n          background: none;\n          cursor: pointer;\n          font-size: 14px;\n          font-weight: 500;\n          color: #555;\n          border-bottom: 2px solid transparent;\n        }\n\n        .tab-button:hover {\n          background-color: #ececec;\n        }\n\n        .tab-button.active {\n          color: #1a73e8;\n          border-bottom-color: #1a73e8;\n        }\n\n        .panel-content {\n          flex: 1;\n          overflow-y: auto;\n          padding: 16px;\n        }\n\n        .empty-state {\n          text-align: center;\n          padding: 32px;\n          color: #666;\n        }\n\n        .hint {\n          font-size: 14px;\n          color: #888;\n          margin-top: 8px;\n        }\n\n        /* Recommendations tab */\n        .recommendations-header {\n          display: flex;\n          justify-content: space-between;\n          align-items: center;\n          margin-bottom: 16px;\n        }\n\n        .recommendations-header h3 {\n          margin: 0;\n          font-size: 16px;\n          color: #333;\n        }\n\n        .recommendations-list {\n          display: flex;\n          flex-direction: column;\n          gap: 16px;\n        }\n\n        .recommendation-card {\n          border: 1px solid #e0e0e0;\n          border-radius: 4px;\n          padding: 16px;\n          background-color: #fff;\n        }\n\n        .recommendation-header {\n          display: flex;\n          justify-content: space-between;\n          align-items: center;\n          margin-bottom: 8px;\n        }\n\n        .recommendation-header h4 {\n          margin: 0;\n          font-size: 16px;\n          color: #333;\n        }\n\n        .confidence-badge {\n          padding: 4px 8px;\n          border-radius: 4px;\n          font-size: 12px;\n          font-weight: 500;\n        }\n\n        .recommendation-reason {\n          margin-top: 0;\n          margin-bottom: 16px;\n          color: #666;\n          font-size: 14px;\n        }\n\n        .recommendation-details {\n          display: flex;\n          gap: 24px;\n          margin-bottom: 16px;\n        }\n\n        .stats-section,\n        .changes-section {\n          flex: 1;\n        }\n\n        .stats-section h5,\n        .changes-section h5 {\n          margin-top: 0;\n          margin-bottom: 8px;\n          font-size: 14px;\n          color: #333;\n        }\n\n        .stat-grid,\n        .change-grid {\n          display: flex;\n          flex-direction: column;\n          gap: 4px;\n        }\n\n        .stat-row,\n        .change-row {\n          display: flex;\n          justify-content: space-between;\n          font-size: 14px;\n        }\n\n        .stat-label,\n        .change-label {\n          color: #666;\n        }\n\n        .change-value {\n          display: flex;\n          align-items: center;\n          gap: 4px;\n        }\n\n        .old-value {\n          color: #d32f2f;\n          text-decoration: line-through;\n        }\n\n        .arrow {\n          color: #666;\n        }\n\n        .new-value {\n          color: #388e3c;\n          font-weight: 500;\n        }\n\n        .recommendation-actions {\n          display: flex;\n          justify-content: flex-end;\n        }\n\n        /* Applied changes notice */\n        .applied-changes-notice {\n          margin-bottom: 16px;\n          border: 1px solid #c8e6c9;\n          border-radius: 4px;\n          background-color: #e8f5e9;\n          padding: 12px;\n        }\n\n        .notice-header {\n          display: flex;\n          justify-content: space-between;\n          align-items: center;\n          margin-bottom: 8px;\n        }\n\n        .notice-header h3 {\n          margin: 0;\n          font-size: 14px;\n          color: #2e7d32;\n        }\n\n        .close-button {\n          background: none;\n          border: none;\n          font-size: 18px;\n          color: #2e7d32;\n          cursor: pointer;\n        }\n\n        .applied-changes-list {\n          margin: 0;\n          padding-left: 16px;\n        }\n\n        .applied-change-item {\n          font-size: 13px;\n          margin-bottom: 4px;\n        }\n\n        .budget-name {\n          font-weight: 500;\n        }\n\n        .change-detail {\n          margin-left: 4px;\n          margin-right: 8px;\n          color: #2e7d32;\n        }\n\n        /* Statistics tab */\n        .statistics-list {\n          border: 1px solid #e0e0e0;\n          border-radius: 4px;\n          overflow: hidden;\n        }\n\n        .stats-header-row {\n          display: flex;\n          background-color: #f5f5f5;\n          padding: 12px 16px;\n          font-weight: 500;\n          font-size: 14px;\n          color: #333;\n        }\n\n        .stats-rows {\n          max-height: 500px;\n          overflow-y: auto;\n        }\n\n        .stats-row {\n          display: flex;\n          padding: 12px 16px;\n          font-size: 14px;\n          border-top: 1px solid #f0f0f0;\n        }\n\n        .stats-row:nth-child(even) {\n          background-color: #fafafa;\n        }\n\n        .operation-column {\n          flex: 2;\n        }\n\n        .samples-column {\n          flex: 1;\n          text-align: center;\n        }\n\n        .time-column,\n        .memory-column,\n        .ops-column {\n          flex: 1;\n          text-align: right;\n        }\n\n        /* Budgets tab */\n        .budgets-list {\n          border: 1px solid #e0e0e0;\n          border-radius: 4px;\n          overflow: hidden;\n        }\n\n        .budget-header-row {\n          display: flex;\n          background-color: #f5f5f5;\n          padding: 12px 16px;\n          font-weight: 500;\n          font-size: 14px;\n          color: #333;\n        }\n\n        .budget-rows {\n          max-height: 500px;\n          overflow-y: auto;\n        }\n\n        .budget-row {\n          display: flex;\n          padding: 12px 16px;\n          font-size: 14px;\n          border-top: 1px solid #f0f0f0;\n        }\n\n        .budget-row:nth-child(even) {\n          background-color: #fafafa;\n        }\n\n        .category-column {\n          flex: 1;\n        }\n\n        .critical-column {\n          flex: 0.5;\n          text-align: center;\n        }\n\n        .critical-badge {\n          display: inline-block;\n          padding: 2px 6px;\n          border-radius: 4px;\n          font-size: 12px;\n        }\n\n        .critical-badge.yes {\n          background-color: #ffebee;\n          color: #d32f2f;\n        }\n\n        .critical-badge.no {\n          background-color: #e8f5e9;\n          color: #388e3c;\n        }\n      `}</style>\n    </div>\n  );\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/performance/InterpolationMemoizationDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/performance/MLPerformancePrediction.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/performance/OptimizationComparisonView.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'width' is assigned a value but never used. Allowed unused args must match /^_/u.",
        "line": 31,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 31,
        "endColumn": 8
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'height' is assigned a value but never used. Allowed unused args must match /^_/u.",
        "line": 32,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 32,
        "endColumn": 9
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import * as React from \"react\";\nimport { useEffect, useRef, useState } from 'react';\nimport { animationFrameManager } from '../../../utils/performance/animationFrameManagerInstance';\nimport { FrameInfo } from '../../../utils/performance/D3AnimationFrameManager';\nimport { AnimationPerformanceReport } from '../../../utils/performance/D3AnimationProfiler';\nimport {\n  ActiveMode,\n  ComparisonMode,\n  PerformanceComparison,\n  PerformanceMetrics,\n} from './performanceTypes';\n\n// Declare the metricInterval property on window for TypeScript\ndeclare global {\n  interface Window {\n    metricInterval?: ReturnType<typeof setInterval>;\n  }\n}\n\ninterface OptimizationComparisonViewProps {\n  width?: number;\n  height?: number;\n  animationId?: string;\n}\n\n/**\n * A component that provides side-by-side comparison between optimized and unoptimized\n * performance modes with real-time metrics visualization.\n */\nconst OptimizationComparisonView: React.FC<OptimizationComparisonViewProps> = ({\n  width = 1200,\n  height = 800,\n  animationId = 'test-animation',\n}) => {\n  // References for chart containers\n  const optimizedChartRef = useRef<HTMLDivElement>(null);\n  const unoptimizedChartRef = useRef<HTMLDivElement>(null);\n\n  // State for tracking metrics\n  const [optimizedMetrics, setOptimizedMetrics] = useState<PerformanceMetrics>({\n    fps: [],\n    renderTime: [],\n    cpuTime: [],\n    domOperations: [],\n    memoryUsage: [],\n    animationSmoothness: [],\n  });\n\n  const [unoptimizedMetrics, setUnoptimizedMetrics] = useState<PerformanceMetrics>({\n    fps: [],\n    renderTime: [],\n    cpuTime: [],\n    domOperations: [],\n    memoryUsage: [],\n    animationSmoothness: [],\n  });\n\n  // State for comparison mode\n  const [comparisonMode, setComparisonMode] = useState<ComparisonMode>('side-by-side');\n  const [isRunning, setIsRunning] = useState(false);\n  const [activeMode, setActiveMode] = useState<ActiveMode>('both');\n  const [comparisons, setComparisons] = useState<PerformanceComparison[]>([]);\n\n  // State for animation performance reports\n  const [optimizedReport, setOptimizedReport] = useState<AnimationPerformanceReport | null>(null);\n  const [unoptimizedReport, setUnoptimizedReport] = useState<AnimationPerformanceReport | null>(\n    null\n  );\n\n  // Initialize comparison\n  useEffect(() => {\n    // Setup chart visualization (would implement with D3 in a real component)\n    setupCharts();\n\n    return () => {\n      // Cleanup any running animations\n      if (isRunning) {\n        stopComparison();\n      }\n    };\n  }, []);\n\n  // Update charts when metrics change\n  useEffect(() => {\n    if (optimizedMetrics.fps.length > 0 || unoptimizedMetrics.fps.length > 0) {\n      updateCharts();\n    }\n  }, [optimizedMetrics, unoptimizedMetrics]);\n\n  // Update statistical comparison when reports change\n  useEffect(() => {\n    if (optimizedReport && unoptimizedReport) {\n      generateComparisons();\n    }\n  }, [optimizedReport, unoptimizedReport]);\n\n  // Setup chart visualization\n  const setupCharts = () => {\n    // In a real implementation, this would initialize D3 charts\n    console.warn('Setting up performance comparison charts');\n  };\n\n  // Update chart visualization\n  const updateCharts = () => {\n    // In a real implementation, this would update D3 charts with new data\n    console.warn('Updating performance comparison charts');\n  };\n\n  // Start the comparison\n  const startComparison = () => {\n    setIsRunning(true);\n\n    // Clear previous metrics\n    setOptimizedMetrics({\n      fps: [],\n      renderTime: [],\n      cpuTime: [],\n      domOperations: [],\n      memoryUsage: [],\n      animationSmoothness: [],\n    });\n\n    setUnoptimizedMetrics({\n      fps: [],\n      renderTime: [],\n      cpuTime: [],\n      domOperations: [],\n      memoryUsage: [],\n      animationSmoothness: [],\n    });\n\n    // Run optimized animation if mode is optimized or both\n    if (activeMode === 'optimized' || activeMode === 'both') {\n      runOptimizedAnimation();\n    }\n\n    // Run unoptimized animation if mode is unoptimized or both\n    if (activeMode === 'unoptimized' || activeMode === 'both') {\n      runUnoptimizedAnimation();\n    }\n\n    // Start metric collection\n    startMetricCollection();\n  };\n\n  // Stop the comparison\n  const stopComparison = () => {\n    setIsRunning(false);\n\n    // Stop animations\n    animationFrameManager.pauseAnimation(`${animationId}-optimized`);\n    animationFrameManager.pauseAnimation(`${animationId}-unoptimized`);\n\n    // Stop metric collection\n    stopMetricCollection();\n  };\n\n  // Run the optimized animation\n  const runOptimizedAnimation = () => {\n    // In a real implementation, this would set up and run the optimized animation\n    console.warn('Running optimized animation');\n\n    // Example of registering an animation with the animation frame manager\n    animationFrameManager.registerAnimation(\n      {\n        id: `${animationId}-optimized`,\n        name: 'Optimized Animation',\n        priority: 'high',\n        type: 'custom',\n        duration: 0, // Run indefinitely\n        loop: true,\n        enableProfiling: true,\n      },\n      (_elapsed: number, _deltaTime: number, _frameInfo: FrameInfo) => {\n        // Animation logic here\n        return false; // Continue running\n      }\n    );\n\n    // Start the animation\n    animationFrameManager.startAnimation(`${animationId}-optimized`);\n  };\n\n  // Run the unoptimized animation\n  const runUnoptimizedAnimation = () => {\n    // In a real implementation, this would set up and run the unoptimized animation\n    console.warn('Running unoptimized animation');\n\n    // Example of registering an animation with the animation frame manager\n    animationFrameManager.registerAnimation(\n      {\n        id: `${animationId}-unoptimized`,\n        name: 'Unoptimized Animation',\n        priority: 'high',\n        type: 'custom',\n        duration: 0, // Run indefinitely\n        loop: true,\n        enableProfiling: true,\n      },\n      (_elapsed: number, _deltaTime: number, _frameInfo: FrameInfo) => {\n        // Animation logic here - with deliberate inefficiencies to demonstrate difference\n        return false; // Continue running\n      }\n    );\n\n    // Start the animation\n    animationFrameManager.startAnimation(`${animationId}-unoptimized`);\n  };\n\n  // Start collecting metrics\n  const startMetricCollection = () => {\n    const metricInterval = setInterval(() => {\n      const now = Date.now();\n\n      // In a real implementation, these would be actual metrics from the animations\n      if (activeMode === 'optimized' || activeMode === 'both') {\n        setOptimizedMetrics(prev => ({\n          fps: [...prev.fps, { timestamp: now, value: 55 + Math.random() * 5 }], // 55-60 FPS\n          renderTime: [...prev.renderTime, { timestamp: now, value: 8 + Math.random() * 3 }], // 8-11ms\n          cpuTime: [...prev.cpuTime, { timestamp: now, value: 5 + Math.random() * 2 }], // 5-7ms\n          domOperations: [...prev.domOperations, { timestamp: now, value: 10 + Math.random() * 5 }], // 10-15 ops\n          memoryUsage: [...prev.memoryUsage, { timestamp: now, value: 20 + Math.random() * 10 }], // 20-30MB\n          animationSmoothness: [\n            ...prev.animationSmoothness,\n            { timestamp: now, value: 90 + Math.random() * 10 },\n          ], // 90-100%\n        }));\n      }\n\n      if (activeMode === 'unoptimized' || activeMode === 'both') {\n        setUnoptimizedMetrics(prev => ({\n          fps: [...prev.fps, { timestamp: now, value: 30 + Math.random() * 15 }], // 30-45 FPS\n          renderTime: [...prev.renderTime, { timestamp: now, value: 16 + Math.random() * 10 }], // 16-26ms\n          cpuTime: [...prev.cpuTime, { timestamp: now, value: 12 + Math.random() * 8 }], // 12-20ms\n          domOperations: [\n            ...prev.domOperations,\n            { timestamp: now, value: 30 + Math.random() * 20 },\n          ], // 30-50 ops\n          memoryUsage: [...prev.memoryUsage, { timestamp: now, value: 40 + Math.random() * 20 }], // 40-60MB\n          animationSmoothness: [\n            ...prev.animationSmoothness,\n            { timestamp: now, value: 60 + Math.random() * 20 },\n          ], // 60-80%\n        }));\n      }\n    }, 1000); // Collect metrics every second\n\n    // Store interval ID for cleanup\n    window.metricInterval = metricInterval;\n  };\n\n  // Stop collecting metrics\n  const stopMetricCollection = () => {\n    if (window.metricInterval) {\n      clearInterval(window.metricInterval);\n      window.metricInterval = undefined;\n    }\n\n    // Generate final performance reports\n    if (activeMode === 'optimized' || activeMode === 'both') {\n      const report = animationFrameManager.getPerformanceReport(`${animationId}-optimized`);\n      if (report) {\n        setOptimizedReport(report);\n      }\n    }\n\n    if (activeMode === 'unoptimized' || activeMode === 'both') {\n      const report = animationFrameManager.getPerformanceReport(`${animationId}-unoptimized`);\n      if (report) {\n        setUnoptimizedReport(report);\n      }\n    }\n  };\n\n  // Generate statistical comparisons between optimized and unoptimized\n  const generateComparisons = () => {\n    // In a real implementation, this would compare actual metrics\n    const newComparisons: PerformanceComparison[] = [\n      {\n        metric: 'FPS',\n        optimized: calculateAverage(optimizedMetrics.fps.map(point => point.value)),\n        unoptimized: calculateAverage(unoptimizedMetrics.fps.map(point => point.value)),\n        difference: 0, // Will be calculated\n        percentImprovement: 0, // Will be calculated\n      },\n      {\n        metric: 'Render Time (ms)',\n        optimized: calculateAverage(optimizedMetrics.renderTime.map(point => point.value)),\n        unoptimized: calculateAverage(unoptimizedMetrics.renderTime.map(point => point.value)),\n        difference: 0, // Will be calculated\n        percentImprovement: 0, // Will be calculated\n      },\n      {\n        metric: 'CPU Time (ms)',\n        optimized: calculateAverage(optimizedMetrics.cpuTime.map(point => point.value)),\n        unoptimized: calculateAverage(unoptimizedMetrics.cpuTime.map(point => point.value)),\n        difference: 0, // Will be calculated\n        percentImprovement: 0, // Will be calculated\n      },\n      {\n        metric: 'DOM Operations',\n        optimized: calculateAverage(optimizedMetrics.domOperations.map(point => point.value)),\n        unoptimized: calculateAverage(unoptimizedMetrics.domOperations.map(point => point.value)),\n        difference: 0, // Will be calculated\n        percentImprovement: 0, // Will be calculated\n      },\n      {\n        metric: 'Memory Usage (MB)',\n        optimized: calculateAverage(optimizedMetrics.memoryUsage.map(point => point.value)),\n        unoptimized: calculateAverage(unoptimizedMetrics.memoryUsage.map(point => point.value)),\n        difference: 0, // Will be calculated\n        percentImprovement: 0, // Will be calculated\n      },\n      {\n        metric: 'Animation Smoothness (%)',\n        optimized: calculateAverage(optimizedMetrics.animationSmoothness.map(point => point.value)),\n        unoptimized: calculateAverage(\n          unoptimizedMetrics.animationSmoothness.map(point => point.value)\n        ),\n        difference: 0, // Will be calculated\n        percentImprovement: 0, // Will be calculated\n      },\n    ];\n\n    // Calculate difference and percentage improvement\n    newComparisons.forEach(comparison => {\n      comparison.difference = comparison.optimized - comparison.unoptimized;\n\n      // For metrics where higher is better (FPS, smoothness)\n      if (comparison.metric === 'FPS' || comparison.metric === 'Animation Smoothness (%)') {\n        comparison.percentImprovement =\n          (comparison.difference / Math.max(0.1, comparison.unoptimized)) * 100;\n      }\n      // For metrics where lower is better (render time, CPU time, DOM ops, memory)\n      else {\n        comparison.percentImprovement =\n          ((comparison.unoptimized - comparison.optimized) /\n            Math.max(0.1, comparison.unoptimized)) *\n          100;\n      }\n    });\n\n    setComparisons(newComparisons);\n  };\n\n  // Helper to calculate average of an array of numbers\n  const calculateAverage = (values: number[]): number => {\n    if (values.length === 0) return 0;\n    return values.reduce((sum, value) => sum + value, 0) / values.length;\n  };\n\n  // Toggle the comparison mode\n  const toggleComparisonMode = () => {\n    setComparisonMode(prev => (prev === 'side-by-side' ? 'overlay' : 'side-by-side'));\n  };\n\n  // Change the active mode\n  const changeActiveMode = (mode: ActiveMode) => {\n    if (isRunning) {\n      stopComparison();\n    }\n\n    setActiveMode(mode);\n\n    if (isRunning) {\n      startComparison();\n    }\n  };\n\n  // Render the comparison view\n  return (\n    <div className=\"optimization-comparison-view\">\n      <h2>Performance Optimization Comparison</h2>\n\n      <div className=\"controls\">\n        <div className=\"control-section\">\n          <h3>Comparison Mode</h3>\n          <div className=\"control-row\">\n            <button\n              className={`mode-button ${activeMode === 'optimized' ? 'active' : ''}`}\n              onClick={() => changeActiveMode('optimized')}\n            >\n              Optimized Only\n            </button>\n            <button\n              className={`mode-button ${activeMode === 'unoptimized' ? 'active' : ''}`}\n              onClick={() => changeActiveMode('unoptimized')}\n            >\n              Unoptimized Only\n            </button>\n            <button\n              className={`mode-button ${activeMode === 'both' ? 'active' : ''}`}\n              onClick={() => changeActiveMode('both')}\n            >\n              Side-by-Side Comparison\n            </button>\n          </div>\n\n          <div className=\"control-row\">\n            <button\n              className=\"action-button\"\n              onClick={isRunning ? stopComparison : startComparison}\n            >\n              {isRunning ? 'Stop Comparison' : 'Start Comparison'}\n            </button>\n\n            {activeMode === 'both' && (\n              <button className=\"action-button\" onClick={toggleComparisonMode}>\n                {comparisonMode === 'side-by-side' ? 'Switch to Overlay' : 'Switch to Side-by-Side'}\n              </button>\n            )}\n          </div>\n        </div>\n      </div>\n\n      <div className={`visualizations ${comparisonMode}`}>\n        {(activeMode === 'optimized' || activeMode === 'both') && (\n          <div className=\"visualization-container optimized\">\n            <h3>Optimized Performance</h3>\n            <div className=\"visualization-wrapper\" ref={optimizedChartRef}>\n              {/* In a real implementation, this would be a D3 chart */}\n              <div className=\"placeholder-chart\">\n                <div className=\"chart-bar\" style={{ height: '80%' }}></div>\n                <div className=\"chart-label\">Chart Placeholder - Optimized</div>\n              </div>\n            </div>\n          </div>\n        )}\n\n        {(activeMode === 'unoptimized' || activeMode === 'both') && (\n          <div className=\"visualization-container unoptimized\">\n            <h3>Unoptimized Performance</h3>\n            <div className=\"visualization-wrapper\" ref={unoptimizedChartRef}>\n              {/* In a real implementation, this would be a D3 chart */}\n              <div className=\"placeholder-chart\">\n                <div className=\"chart-bar\" style={{ height: '40%' }}></div>\n                <div className=\"chart-label\">Chart Placeholder - Unoptimized</div>\n              </div>\n            </div>\n          </div>\n        )}\n      </div>\n\n      {comparisons.length > 0 && (\n        <div className=\"statistical-analysis\">\n          <h3>Statistical Comparison</h3>\n          <table className=\"comparison-table\">\n            <thead>\n              <tr>\n                <th>Metric</th>\n                <th>Optimized</th>\n                <th>Unoptimized</th>\n                <th>Difference</th>\n                <th>Improvement</th>\n              </tr>\n            </thead>\n            <tbody>\n              {comparisons.map((comparison, index) => (\n                <tr key={index}>\n                  <td>{comparison.metric}</td>\n                  <td>{comparison.optimized.toFixed(2)}</td>\n                  <td>{comparison.unoptimized.toFixed(2)}</td>\n                  <td className={comparison.percentImprovement > 0 ? 'positive' : 'negative'}>\n                    {comparison.difference.toFixed(2)}\n                  </td>\n                  <td className={comparison.percentImprovement > 0 ? 'positive' : 'negative'}>\n                    {comparison.percentImprovement.toFixed(2)}%\n                  </td>\n                </tr>\n              ))}\n            </tbody>\n          </table>\n        </div>\n      )}\n\n      <style jsx>{`\n        .optimization-comparison-view {\n          padding: 20px;\n          font-family:\n            system-ui,\n            -apple-system,\n            BlinkMacSystemFont,\n            'Segoe UI',\n            Roboto,\n            sans-serif;\n        }\n\n        h2 {\n          color: #333;\n          border-bottom: 2px solid #4285f4;\n          padding-bottom: 10px;\n        }\n\n        .controls {\n          display: flex;\n          flex-wrap: wrap;\n          gap: 20px;\n          margin-bottom: 30px;\n          background: #f5f5f5;\n          padding: 15px;\n          border-radius: 8px;\n        }\n\n        .control-section {\n          flex: 1;\n          min-width: 300px;\n        }\n\n        h3 {\n          color: #4285f4;\n          margin-top: 0;\n        }\n\n        .control-row {\n          display: flex;\n          align-items: center;\n          margin-bottom: 12px;\n          gap: 10px;\n        }\n\n        .mode-button,\n        .action-button {\n          padding: 8px 16px;\n          background: #f1f1f1;\n          color: #333;\n          border: 1px solid #ddd;\n          border-radius: 4px;\n          cursor: pointer;\n          font-weight: 500;\n          transition: all 0.2s;\n        }\n\n        .mode-button.active {\n          background: #4285f4;\n          color: white;\n          border-color: #3367d6;\n        }\n\n        .action-button {\n          background: #4285f4;\n          color: white;\n          border: none;\n        }\n\n        .action-button:hover {\n          background: #3367d6;\n        }\n\n        .visualizations {\n          display: flex;\n          flex-wrap: wrap;\n          gap: 20px;\n          margin-bottom: 30px;\n        }\n\n        .visualizations.side-by-side {\n          flex-direction: row;\n        }\n\n        .visualizations.overlay {\n          position: relative;\n          height: 500px;\n        }\n\n        .visualization-container {\n          flex: 1;\n          min-width: 300px;\n          background: #fff;\n          border-radius: 8px;\n          overflow: hidden;\n          box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);\n        }\n\n        .visualizations.overlay .visualization-container {\n          position: absolute;\n          top: 0;\n          left: 0;\n          right: 0;\n          bottom: 0;\n          opacity: 0.7;\n        }\n\n        .visualizations.overlay .optimized {\n          z-index: 2;\n        }\n\n        .visualization-container h3 {\n          padding: 15px;\n          margin: 0;\n          background: #f5f5f5;\n          border-bottom: 1px solid #ddd;\n        }\n\n        .visualization-wrapper {\n          height: 400px;\n          padding: 10px;\n        }\n\n        .placeholder-chart {\n          height: 100%;\n          display: flex;\n          flex-direction: column;\n          justify-content: flex-end;\n          align-items: center;\n          background: #f9f9f9;\n          border-radius: 4px;\n          padding: 10px;\n        }\n\n        .chart-bar {\n          width: 80px;\n          background: linear-gradient(to top, #4285f4, #34a853);\n          border-radius: 4px 4px 0 0;\n        }\n\n        .unoptimized .chart-bar {\n          background: linear-gradient(to top, #ea4335, #fbbc05);\n        }\n\n        .chart-label {\n          margin-top: 10px;\n          font-size: 14px;\n          color: #666;\n        }\n\n        .statistical-analysis {\n          background: #fff;\n          border-radius: 8px;\n          overflow: hidden;\n          box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);\n          margin-bottom: 30px;\n        }\n\n        .statistical-analysis h3 {\n          padding: 15px;\n          margin: 0;\n          background: #f5f5f5;\n          border-bottom: 1px solid #ddd;\n        }\n\n        .comparison-table {\n          width: 100%;\n          border-collapse: collapse;\n        }\n\n        .comparison-table th,\n        .comparison-table td {\n          padding: 12px 15px;\n          text-align: left;\n          border-bottom: 1px solid #eee;\n        }\n\n        .comparison-table th {\n          background: #f9f9f9;\n          font-weight: 500;\n        }\n\n        .comparison-table td.positive {\n          color: #34a853;\n        }\n\n        .comparison-table td.negative {\n          color: #ea4335;\n        }\n      `}</style>\n    </div>\n  );\n};\n\nexport default OptimizationComparisonView;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/performance/OptimizedFlowDiagram.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/performance/PerformanceBenchmarkDashboard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/performance/PerformanceBudgetTracker.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/performance/PerformanceRegressionReport.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/performance/UserBehaviorCorrelationView.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/performance/VisualizationInspector.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/performance/VisualizationPerformanceComparison.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/performance/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/performance/performanceTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/profiling/ProfilingOverlay.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/profiling/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/resource/ChainManagementInterface.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/resource/ChainVisualization.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/resource/ConverterDashboard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/resource/ConverterDetailsView.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/resource/ResourceDisplay.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/resource/ResourceDistributionChart.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/resource/ResourceDistributionChartDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/resource/ResourceFlowDiagram.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/resource/ResourceForecastingVisualization.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/resource/ResourceIcon.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/resource/ResourceManagementDashboard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/resource/ResourceOptimizationSuggestions.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/resource/ResourceRateFiltering.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/resource/ResourceRatesDisplay.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/resource/ResourceRatesTrends.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/resource/ResourceRatesUI.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/resource/ResourceRegistrationDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/resource/ResourceThresholdVisualization.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/resource/ResourceVisualizationEnhanced.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'percentFilled' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 88,
        "column": 11,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 88,
        "endColumn": 24
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'timeUntilEmpty' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 89,
        "column": 11,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 89,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'timeUntilFull' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 90,
        "column": 11,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 90,
        "endColumn": 24
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'setRate' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 155,
        "column": 16,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 155,
        "endColumn": 23
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'fillPercentage' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 202,
        "column": 9,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 202,
        "endColumn": 23
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 5,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { AlertTriangle, TrendingDown, TrendingUp } from 'lucide-react';\nimport * as React from 'react';\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { useModuleEvents } from '../../../hooks/events/useModuleEvents';\nimport { ModuleEvent } from '../../../lib/events/ModuleEventBus';\nimport { EventType } from '../../../types/events/EventTypes';\nimport { ResourceType } from '../../../types/resources/ResourceTypes';\nimport { isResourceUpdateEvent } from '../../../utils/events/eventTypeGuards';\nimport { resourceColors, resourceIcons, resourceNames } from '../ResourceVisualization';\nimport { useTooltipContext } from '../tooltip-context';\n\n/**\n * Enhanced version of ResourceVisualization that uses the component registration system\n *\n * This component:\n * 1. Registers with the ComponentRegistryService\n * 2. Subscribes to resource-related events\n * 3. Updates in real-time based on resource events\n * 4. Provides performance metrics through the registry\n */\n\ninterface ResourceDisplayProps {\n  type: ResourceType;\n  value: number;\n  rate?: number;\n  capacity?: number;\n  thresholds?: {\n    warning: number;\n    critical: number;\n  };\n}\n\n// Resource descriptions for tooltips\nconst resourceDescriptions: Record<ResourceType, string> = {\n  [ResourceType.MINERALS]: 'Raw materials used for construction and manufacturing.',\n  [ResourceType.ENERGY]: 'Powers all modules, buildings, and operations.',\n  [ResourceType.POPULATION]: 'Citizens of your empire who can be assigned to various tasks.',\n  [ResourceType.RESEARCH]: 'Scientific knowledge used to unlock new technologies.',\n  [ResourceType.PLASMA]: 'High-energy matter used for advanced technology.',\n  [ResourceType.GAS]: 'Various gases used for life support and manufacturing.',\n  [ResourceType.EXOTIC]: 'Rare materials with unique properties for special projects.',\n  [ResourceType.IRON]: 'Basic building material for structures and components.',\n  [ResourceType.COPPER]: 'Conductive material used in electronics and wiring.',\n  [ResourceType.TITANIUM]: 'Strong, lightweight metal used for advanced construction.',\n  [ResourceType.URANIUM]: 'Radioactive material used for nuclear power and weapons.',\n  [ResourceType.WATER]: 'Essential resource for life support and various processes.',\n  [ResourceType.HELIUM]: 'Light gas used for cooling and propulsion systems.',\n  [ResourceType.DEUTERIUM]: 'Isotope of hydrogen used in fusion reactors.',\n  [ResourceType.ANTIMATTER]: 'Exotic material with immense energy potential.',\n  [ResourceType.DARK_MATTER]: 'Mysterious substance with unique gravitational properties.',\n  [ResourceType.EXOTIC_MATTER]: 'Extremely rare material with extraordinary properties.',\n  [ResourceType.ORGANIC]: 'Biological materials used for sustenance and bio-engineering.',\n};\n\nfunction getResourceStatus(\n  value: number,\n  capacity?: number,\n  thresholds?: { warning: number; critical: number }\n) {\n  if (!capacity || !thresholds) return null;\n\n  const percentage = (value / capacity) * 100;\n\n  if (percentage <= thresholds.critical) {\n    return {\n      icon: AlertTriangle,\n      message: 'Critical',\n      color: 'text-red-500',\n    };\n  }\n\n  if (percentage <= thresholds.warning) {\n    return {\n      icon: AlertTriangle,\n      message: 'Warning',\n      color: 'text-yellow-500',\n    };\n  }\n\n  return null;\n}\n\n// Tooltip content for resources\nconst ResourceTooltip = React.memo(\n  ({ type, value, rate = 0, capacity, thresholds }: ResourceDisplayProps) => {\n    const status = getResourceStatus(value, capacity, thresholds);\n    const colors = resourceColors[type];\n    const percentFilled = capacity ? ((value / capacity) * 100).toFixed(1) : 'N/A';\n    const timeUntilEmpty = rate < 0 ? Math.abs(value / rate).toFixed(1) : 'N/A';\n    const timeUntilFull = rate > 0 && capacity ? ((capacity - value) / rate).toFixed(1) : 'N/A';\n\n    return (\n      <div className={`rounded-md p-2 ${colors.bg} border ${colors.border}`}>\n        <div className=\"flex items-center gap-2\">\n          <span className={colors.base}>{resourceNames[type]}</span>\n          {status && (\n            <span className={status.color}>\n              <status.icon className=\"h-4 w-4\" />\n            </span>\n          )}\n        </div>\n\n        <div className=\"mt-1 space-y-1\">\n          <div className=\"flex items-center justify-between gap-4\">\n            <span className=\"text-gray-400\">Current:</span>\n            <span className={colors.base}>{value.toLocaleString()}</span>\n          </div>\n\n          {rate !== 0 && (\n            <div className=\"flex items-center justify-between gap-4\">\n              <span className=\"text-gray-400\">Rate:</span>\n              <div className=\"flex items-center gap-1\">\n                {rate > 0 ? (\n                  <TrendingUp className=\"h-4 w-4 text-green-500\" />\n                ) : rate < 0 ? (\n                  <TrendingDown className=\"h-4 w-4 text-red-500\" />\n                ) : null}\n                <span\n                  className={rate > 0 ? 'text-green-500' : rate < 0 ? 'text-red-500' : colors.base}\n                >\n                  {rate > 0 ? '+' : ''}\n                  {rate.toLocaleString()}/s\n                </span>\n              </div>\n            </div>\n          )}\n\n          {capacity !== undefined && (\n            <div className=\"flex items-center justify-between gap-4\">\n              <span className=\"text-gray-400\">Capacity:</span>\n              <span className={colors.base}>{capacity.toLocaleString()}</span>\n            </div>\n          )}\n\n          <div className=\"mt-2 text-sm text-gray-400\">{resourceDescriptions[type]}</div>\n        </div>\n      </div>\n    );\n  }\n);\n\nResourceTooltip.displayName = 'ResourceTooltip';\n\n/**\n * Enhanced resource display component that updates in real-time based on resource events\n */\nconst EnhancedResourceDisplay = React.memo(function EnhancedResourceDisplayBase({\n  type,\n  value: initialValue,\n  rate: initialRate,\n  capacity,\n  thresholds,\n}: ResourceDisplayProps) {\n  const [value, setValue] = useState(initialValue);\n  const [rate, setRate] = useState(initialRate);\n  const { showTooltip, hideTooltip } = useTooltipContext();\n  const componentRef = useRef<HTMLDivElement>(null);\n  const { subscribe } = useModuleEvents();\n\n  // Subscribe to resource update events\n  useEffect(() => {\n    const handleResourceUpdate = (event: ModuleEvent) => {\n      if (isResourceUpdateEvent(event)) {\n        const resourceAmounts = event.data?.resourceAmounts;\n        if (resourceAmounts && type in resourceAmounts) {\n          const newValue = resourceAmounts[type];\n          if (typeof newValue === 'number') {\n            setValue(newValue);\n          }\n        }\n      }\n    };\n\n    const unsubscribe = subscribe(EventType.RESOURCE_UPDATED, handleResourceUpdate);\n    return () => {\n      unsubscribe();\n    };\n  }, [type, subscribe]);\n\n  // Handle mouse events for tooltip\n  const handleMouseEnter = useCallback(() => {\n    if (componentRef.current) {\n      const rect = componentRef.current.getBoundingClientRect();\n      showTooltip(\n        <ResourceTooltip\n          type={type}\n          value={value}\n          rate={rate}\n          capacity={capacity}\n          thresholds={thresholds}\n        />,\n        { x: rect.left + rect.width / 2, y: rect.top }\n      );\n    }\n  }, [type, value, rate, capacity, thresholds, showTooltip]);\n\n  const handleMouseLeave = useCallback(() => {\n    hideTooltip();\n  }, [hideTooltip]);\n\n  // Calculate fill percentage for the progress bar\n  const fillPercentage = useMemo(() => {\n    if (!capacity) return 100;\n    return Math.min(100, (value / capacity) * 100);\n  }, [value, capacity]);\n\n  const colors = resourceColors[type];\n  const Icon = resourceIcons[type];\n  const status = getResourceStatus(value, capacity, thresholds);\n\n  return (\n    <div\n      ref={componentRef}\n      className={`relative flex items-center gap-2 rounded-md p-2 ${colors.bg} border ${colors.border} cursor-pointer`}\n      onMouseEnter={handleMouseEnter}\n      onMouseLeave={handleMouseLeave}\n    >\n      <Icon className={`h-5 w-5 ${colors.base}`} />\n      <span className={colors.base}>{value.toLocaleString()}</span>\n      {status && <status.icon className={`h-4 w-4 ${status.color}`} />}\n    </div>\n  );\n});\n\n/**\n * ResourceVisualizationEnhanced component\n *\n * Enhanced version of ResourceVisualization that uses the new event system\n * and provides real-time updates based on resource events.\n */\nexport const ResourceVisualizationEnhanced = React.memo(\n  function ResourceVisualizationEnhancedBase() {\n    const [resources, setResources] = useState<ResourceDisplayProps[]>([]);\n    const { subscribe } = useModuleEvents();\n\n    // Subscribe to resource events\n    useEffect(() => {\n      const handleResourceUpdate = (event: ModuleEvent) => {\n        if (isResourceUpdateEvent(event)) {\n          const resourceAmounts = event.data?.resourceAmounts;\n          if (resourceAmounts && typeof resourceAmounts === 'object') {\n            setResources(prev =>\n              prev.map(resource => {\n                const newValue =\n                  resource.type in resourceAmounts ? resourceAmounts[resource.type] : null;\n                return {\n                  ...resource,\n                  value: typeof newValue === 'number' ? newValue : resource.value,\n                };\n              })\n            );\n          }\n        }\n      };\n\n      const unsubscribe = subscribe(EventType.RESOURCE_UPDATED, handleResourceUpdate);\n      return () => {\n        unsubscribe();\n      };\n    }, [subscribe]);\n\n    return (\n      <div className=\"space-y-2\">\n        {resources.map(resource => (\n          <EnhancedResourceDisplay key={resource.type} {...resource} />\n        ))}\n      </div>\n    );\n  }\n);\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/resource/VirtualizedResourceDataset.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/resource/VirtualizedResourceList.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/showcase/DataDashboardApp.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'D3Link' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 234,
        "column": 11,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 234,
        "endColumn": 17
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'setTimeRange' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 309,
        "column": 21,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 309,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'worldMapData' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 331,
        "column": 10,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 331,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'range' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 380,
        "column": 47,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 380,
        "endColumn": 52
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'labels' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 598,
        "column": 13,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 598,
        "endColumn": 19
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'convertTimeSeriesDataToD3Format' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 707,
        "column": 9,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 707,
        "endColumn": 40
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'convertGeoDataToD3Format' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 753,
        "column": 9,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 753,
        "endColumn": 33
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 7,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import * as d3 from 'd3';\nimport { Feature } from 'geojson';\nimport * as React from 'react';\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react';\n\n// Import optimization utilities\nimport {\n  animationQualityManager,\n  QualitySettings,\n} from '../../../utils/performance/D3AnimationQualityManager';\n\n// Import type-safe D3 utilities\nimport { AnimationConfig } from '../../../types/visualizations/D3AnimationTypes';\nimport { createSimulationDragBehavior } from '../../../types/visualizations/D3DragTypes';\nimport {\n  d3Accessors,\n  SimulationLinkDatum,\n  SimulationNodeDatum,\n} from '../../../types/visualizations/D3Types';\nimport {\n  createSvgZoomBehavior,\n  getFitToViewportTransform,\n} from '../../../types/visualizations/D3ZoomTypes';\n\n// Type definitions\ninterface DataDashboardAppProps {\n  width?: number;\n  height?: number;\n}\n\n// Data types\ninterface BaseDataPoint {\n  id: string;\n  value: number;\n  category: string;\n  timestamp: Date;\n}\n\ninterface NetworkNode extends BaseDataPoint {\n  connections: string[];\n  group: string;\n  size: number;\n}\n\ninterface NetworkLink {\n  source: string;\n  target: string;\n  value: number;\n  type: string;\n}\n\ninterface TimeSeriesPoint extends BaseDataPoint {\n  timePeriod: string;\n  change: number;\n}\n\ninterface GeoDataPoint extends BaseDataPoint {\n  region: string;\n  latitude: number;\n  longitude: number;\n  population: number;\n}\n\ninterface HierarchyNode extends BaseDataPoint {\n  parentId: string | null;\n  children?: HierarchyNode[];\n  size: number;\n}\n\n// D3 simulation node interface with proper typing\ninterface D3NetworkNode extends SimulationNodeDatum<NetworkNode> {\n  id: string;\n  value: number;\n  category: string;\n  group: string;\n  size: number;\n  color?: string;\n  radius?: number;\n  // Reference to original data\n  data?: NetworkNode;\n}\n\n// D3 simulation link interface with proper typing\ninterface _D3Link extends SimulationLinkDatum<D3NetworkNode> {\n  source: string | D3NetworkNode;\n  target: string | D3NetworkNode;\n  value: number;\n  type: string;\n  width?: number;\n  color?: string;\n}\n\n// D3 time series chart types with proper type safety\ninterface D3TimeSeriesPoint {\n  id: string;\n  date: Date;\n  value: number;\n  category: string;\n  color?: string;\n  originalData?: TimeSeriesPoint; // Reference to original data\n}\n\n// Interface for grouped time series data\ninterface CategorySeries {\n  category: string;\n  color: string;\n  points: D3TimeSeriesPoint[];\n}\n\n// Animation configuration for time series\ninterface _TimeSeriesAnimationConfig extends AnimationConfig {\n  // Additional animation settings specific to time series\n  staggerDelay?: number; // Delay between animating different series\n  pointDelay?: number; // Delay between animating different points\n  lineAnimationType?: 'grow' | 'fade' | 'draw'; // How the line should animate\n}\n\n// Enums\nenum VisualizationType {\n  NETWORK = 'network',\n  TIMESERIES = 'timeseries',\n  GEOSPATIAL = 'geospatial',\n  HIERARCHY = 'hierarchy',\n}\n\n// Extended quality settings for all visualization types\ninterface ExtendedQualitySettings extends QualitySettings {\n  // Node rendering settings\n  nodeDetailLevel: number;\n  linkDetailLevel: number;\n  showLabels: boolean;\n  textScaleFactor: number;\n\n  // Time series visualization settings\n  lineWidth: number;\n  pointRadius: number;\n  animationsEnabled: boolean;\n  animationDuration: number;\n  showGridLines: boolean;\n  maxDataPointsPerSeries: number;\n  downsampling: boolean;\n\n  // Geographic visualization settings\n  mapProjection: 'mercator' | 'equalEarth' | 'orthographic' | 'naturalEarth';\n  mapDetailLevel: 'low' | 'medium' | 'high';\n  showGraticules: boolean;\n  pointSizeScale: number;\n  showTooltips: boolean;\n\n  // Hierarchical visualization settings\n  hierarchyLayout: 'tree' | 'treemap' | 'cluster' | 'radial';\n  treeOrientation: 'vertical' | 'horizontal' | 'radial';\n  nodeColor: 'byCategory' | 'byValue' | 'byDepth';\n  linkStyle: 'straight' | 'curved' | 'diagonal' | 'step';\n  treemapTiling: 'binary' | 'squarify' | 'slice' | 'dice' | 'sliceDice';\n  includeSizeEncoding: boolean;\n}\n\n// Type for drag behavior with SVG circles\ntype CircleDragBehavior = d3.DragBehavior<SVGCircleElement, D3NetworkNode, unknown>;\n\n// D3 geo data types with proper type safety\ninterface D3GeoPoint {\n  id: string;\n  coordinates: [number, number]; // [longitude, latitude]\n  value: number;\n  category: string;\n  color?: string;\n  radius?: number;\n  region: string;\n  population: number;\n  originalData?: GeoDataPoint; // Reference to original data\n}\n\n// Interface for grouped geographic data\ninterface GeoCategory {\n  category: string;\n  color: string;\n  points: D3GeoPoint[];\n}\n\n// GeoJSON world map type\ninterface WorldMapData {\n  features: Feature[];\n  type: string;\n}\n\n// D3 hierarchical data types with proper type safety\ninterface D3HierarchyNode {\n  id: string;\n  name: string;\n  value: number;\n  size: number;\n  category: string;\n  depth?: number;\n  color?: string;\n  children?: D3HierarchyNode[];\n  originalData?: HierarchyNode; // Reference to original data\n}\n\n// Define a custom type for treemap tiling functions\ntype TreemapTilingFunc = (\n  node: d3.HierarchyRectangularNode<D3HierarchyNode>,\n  x0: number,\n  y0: number,\n  x1: number,\n  y1: number\n) => void;\n\n// Define a custom type for hierarchy point links\ninterface CustomHierarchyPointLink {\n  source: {\n    x: number;\n    y: number;\n    data: D3HierarchyNode;\n  };\n  target: {\n    x: number;\n    y: number;\n    data: D3HierarchyNode;\n  };\n}\n\n// Type for D3's link data structure\ninterface D3LinkDatum {\n  x: number;\n  y: number;\n  data?: D3HierarchyNode;\n  // Other optional properties that might be present\n  [key: string]: number | D3HierarchyNode | undefined;\n}\n\n// Type for D3's link structure\ninterface D3Link {\n  source: D3LinkDatum;\n  target: D3LinkDatum;\n}\n\n// Type definition for d3.hierarchy result with proper typing\n// Using a type that doesn't extend HierarchyNode directly to avoid the 'this' type issue\ninterface HierarchyDatum {\n  x?: number;\n  y?: number;\n  x0?: number;\n  y0?: number;\n  x1?: number;\n  y1?: number;\n  depth: number;\n  height: number;\n  parent: HierarchyDatum | null;\n  children?: HierarchyDatum[];\n  data: D3HierarchyNode;\n  // Add methods from HierarchyNode that we need\n  ancestors(): HierarchyDatum[];\n  descendants(): HierarchyDatum[];\n  leaves(): HierarchyDatum[];\n  find(filter: (node: HierarchyDatum) => boolean): HierarchyDatum | undefined;\n  path(target: HierarchyDatum): HierarchyDatum[];\n  links(): Array<{ source: HierarchyDatum; target: HierarchyDatum }>;\n  sum(value: (d: D3HierarchyNode) => number): HierarchyDatum;\n  sort(compare: (a: HierarchyDatum, b: HierarchyDatum) => number): HierarchyDatum;\n  count(): HierarchyDatum;\n  copy(): HierarchyDatum;\n  each(callback: (node: HierarchyDatum) => void): HierarchyDatum;\n  eachAfter(callback: (node: HierarchyDatum) => void): HierarchyDatum;\n  eachBefore(callback: (node: HierarchyDatum) => void): HierarchyDatum;\n  [Symbol.iterator](): Iterator<HierarchyDatum>;\n}\n\n// Define a proper interface for the link data expected by d3.linkHorizontal\ninterface D3LinkData {\n  source: [number, number];\n  target: [number, number];\n}\n\n/**\n * DataDashboardApp\n *\n * A comprehensive visualization dashboard that demonstrates multiple D3 visualization types\n * optimized with our performance techniques. It shows how various visualizations can coexist\n * and interact while maintaining smooth performance.\n *\n * Features:\n * - Multi-panel visualization layout\n * - Interactive data exploration\n * - Coordinated views and cross-filtering\n * - Integrated performance optimization\n * - Type-safe implementation\n */\nexport const DataDashboardApp: React.FC<DataDashboardAppProps> = ({\n  width = 1200,\n  height = 900,\n}) => {\n  // References\n  const containerRef = useRef<HTMLDivElement>(null);\n  const networkRef = useRef<SVGSVGElement>(null);\n  const timeSeriesRef = useRef<SVGSVGElement>(null);\n  const geoMapRef = useRef<SVGSVGElement>(null);\n  const hierarchyRef = useRef<SVGSVGElement>(null);\n\n  // Simulation state reference for force-directed graph\n  const simulationRef = useRef<d3.Simulation<D3NetworkNode, _D3Link> | null>(null);\n\n  // State\n  const [currentView, setCurrentView] = useState<VisualizationType>(VisualizationType.NETWORK);\n  const [isAnimating, setIsAnimating] = useState(false);\n  const [dataLoaded, setDataLoaded] = useState(false);\n  const [optimizationsEnabled, setOptimizationsEnabled] = useState(true);\n  const [timeRange, setTimeRange] = useState<[Date, Date]>([\n    new Date(2022, 0, 1),\n    new Date(2023, 0, 1),\n  ]);\n  const [selectedEntities, setSelectedEntities] = useState<string[]>([]);\n  const [filterValue, setFilterValue] = useState<number>(0);\n\n  // Data state\n  const [networkData, setNetworkData] = useState<{ nodes: NetworkNode[]; links: NetworkLink[] }>({\n    nodes: [],\n    links: [],\n  });\n  const [timeSeriesData, setTimeSeriesData] = useState<TimeSeriesPoint[]>([]);\n  const [geoData, setGeoData] = useState<GeoDataPoint[]>([]);\n  const [hierarchyData, setHierarchyData] = useState<HierarchyNode[]>([]);\n\n  // Quality settings\n  const [qualitySettings, setQualitySettings] = useState<QualitySettings>(\n    animationQualityManager.getCurrentSettings()\n  );\n\n  // World map GeoJSON data reference\n  const [worldMapData, setWorldMapData] = useState<WorldMapData | null>(null);\n\n  // State for hierarchical visualization layout type\n  const [hierarchyLayoutType, setHierarchyLayoutType] =\n    useState<ExtendedQualitySettings['hierarchyLayout']>('tree');\n\n  // Memoized world map data\n  const _worldMapData = useMemo(() => {\n    return {\n      features: [],\n      type: 'FeatureCollection',\n    };\n  }, []);\n\n  // Define visualization initialization functions early to avoid \"used before declaration\" errors\n  const initializeTimeSeriesVisualization = useCallback(() => {\n    console.warn('Initializing time series visualization');\n    // Implementation would go here\n  }, [timeSeriesData, selectedEntities, timeRange, optimizationsEnabled, qualitySettings]);\n\n  const initializeGeoVisualization = useCallback(() => {\n    console.warn('Initializing geo visualization');\n    // Implementation would go here\n  }, [geoData, selectedEntities, optimizationsEnabled, qualitySettings]);\n\n  // Event handlers\n  const handleViewChange = (view: VisualizationType) => {\n    setCurrentView(view);\n  };\n\n  const toggleAnimation = () => {\n    setIsAnimating(!isAnimating);\n  };\n\n  const toggleOptimizations = () => {\n    setOptimizationsEnabled(!optimizationsEnabled);\n  };\n\n  // Define entity selection handler here before it's used in the visualization functions\n  const handleEntitySelection = (entityId: string) => {\n    setSelectedEntities(prev => {\n      if (prev.includes(entityId)) {\n        return prev.filter(id => id !== entityId);\n      } else {\n        return [...prev, entityId];\n      }\n    });\n  };\n\n  const _handleTimeRangeChange = useCallback((range: [Date, Date]) => {\n    // Implementation\n  }, []);\n\n  const handleFilterChange = (value: number) => {\n    setFilterValue(value);\n  };\n\n  // Load data\n  useEffect(() => {\n    // In a real application, this would be an API call\n    // For now, we'll generate synthetic data\n\n    // Generate network data\n    const networkData = generateNetworkData(50, 100);\n    setNetworkData(networkData);\n\n    // Generate time series data\n    const timeSeriesData = generateTimeSeriesData(100);\n    setTimeSeriesData(timeSeriesData);\n\n    // Generate geo data\n    const geoData = generateGeoData(200);\n    setGeoData(geoData);\n\n    // Generate hierarchy data\n    const hierarchyData = generateHierarchyData(100);\n    setHierarchyData(hierarchyData);\n\n    // Mark data as loaded\n    setDataLoaded(true);\n  }, []);\n\n  // Register with animation quality manager\n  useEffect(() => {\n    if (optimizationsEnabled) {\n      animationQualityManager.registerAnimation('data-dashboard', settings => {\n        setQualitySettings(settings);\n      });\n    }\n\n    return () => {\n      animationQualityManager.unregisterAnimation('data-dashboard');\n    };\n  }, [optimizationsEnabled]);\n\n  /**\n   * Converts network data to D3-compatible format with proper typing\n   * This creates new objects with additional properties needed for D3\n   * while maintaining references to the original data\n   */\n  const convertNetworkDataToD3Format = useCallback(() => {\n    // Create node map for quick lookups\n    const nodeMap = new Map<string, D3NetworkNode>();\n\n    // Convert nodes with proper typing\n    const nodes: D3NetworkNode[] = networkData.nodes.map(node => {\n      // Create a color based on the group\n      let color = '';\n      switch (node.group) {\n        case 'A':\n          color = '#4285F4';\n          break; // Blue\n        case 'B':\n          color = '#EA4335';\n          break; // Red\n        case 'C':\n          color = '#FBBC05';\n          break; // Yellow\n        case 'D':\n          color = '#34A853';\n          break; // Green\n        default:\n          color = '#9AA0A6'; // Grey\n      }\n\n      // Calculate radius based on size and current quality settings\n      const baseRadius = Math.sqrt(node.size) * 3;\n      // Cast to ExtendedQualitySettings to use the additional properties\n      const extendedSettings = qualitySettings as ExtendedQualitySettings;\n      const nodeDetailLevel = extendedSettings.nodeDetailLevel || 1; // Default to 1 if not defined\n      const radius = optimizationsEnabled ? baseRadius * nodeDetailLevel : baseRadius;\n\n      // Create D3 node with proper typing\n      const d3Node: D3NetworkNode = {\n        id: node.id,\n        value: node.value,\n        category: node.category,\n        group: node.group,\n        size: node.size,\n        color,\n        radius,\n        // Store reference to original data\n        data: node,\n      };\n\n      // Add to map for quick lookups when creating links\n      nodeMap.set(node.id, d3Node);\n\n      return d3Node;\n    });\n\n    // Convert links with proper typing\n    const links: _D3Link[] = networkData.links.map(link => {\n      // Calculate link width based on value and quality settings\n      const baseWidth = Math.sqrt(link.value) * 1.5;\n      // Cast to ExtendedQualitySettings to use the additional properties\n      const extendedSettings = qualitySettings as ExtendedQualitySettings;\n      const linkDetailLevel = extendedSettings.linkDetailLevel || 1; // Default to 1 if not defined\n      const width = optimizationsEnabled ? baseWidth * linkDetailLevel : baseWidth;\n\n      // Create color based on link type\n      const color = link.type === 'direct' ? '#4285F4' : '#9AA0A6';\n\n      // Create D3 link with proper typing\n      const d3Link: _D3Link = {\n        source: link.source,\n        target: link.target,\n        value: link.value,\n        type: link.type,\n        width,\n        color,\n      };\n\n      return d3Link;\n    });\n\n    return { nodes, links, nodeMap };\n  }, [networkData, optimizationsEnabled, qualitySettings]);\n\n  /**\n   * Initialize the network visualization with a force-directed graph\n   * This uses D3's force layout with type-safe implementation\n   */\n  const initializeNetworkVisualization = useCallback(() => {\n    if (!networkRef.current || networkData.nodes.length === 0) return;\n\n    console.warn('Initializing network visualization with force-directed graph');\n\n    // Clear previous visualization\n    d3.select(networkRef.current).selectAll('*').remove();\n\n    // Get the container dimensions\n    const svgWidth = width;\n    const svgHeight = height * 0.8; // 80% of total height for the visualization\n\n    // Convert data to D3 format with proper typing\n    const { nodes, links, nodeMap } = convertNetworkDataToD3Format();\n\n    // Create the SVG container\n    const svg = d3\n      .select(networkRef.current)\n      .attr('width', svgWidth)\n      .attr('height', svgHeight)\n      .attr('viewBox', [0, 0, svgWidth, svgHeight])\n      .attr('style', 'max-width: 100%; height: auto; font: 10px sans-serif;');\n\n    // Create a group for zoom/pan transformations\n    const g = svg.append('g').attr('class', 'network-container');\n\n    // Create the zoom behavior with type safety\n    const zoom = createSvgZoomBehavior<SVGSVGElement>({\n      scaleExtentMin: 0.1,\n      scaleExtentMax: 5,\n      targetElement: g,\n      constrainPan: true,\n    });\n\n    // Apply zoom to the SVG\n    svg.call(zoom);\n\n    // Initial transform to fit content\n    const initialTransform = getFitToViewportTransform(\n      svgWidth,\n      svgHeight,\n      svgWidth,\n      svgHeight,\n      50\n    );\n    svg.call(zoom.transform, initialTransform);\n\n    // Create link elements\n    const link = g\n      .append('g')\n      .attr('class', 'links')\n      .selectAll('line')\n      .data(links)\n      .enter()\n      .append('line')\n      .attr('stroke', d => d.color || '#999')\n      .attr('stroke-opacity', 0.6)\n      .attr('stroke-width', d => d.width || 1);\n\n    // Create node elements\n    const node = g\n      .append('g')\n      .attr('class', 'nodes')\n      .selectAll('circle')\n      .data(nodes)\n      .enter()\n      .append('circle')\n      .attr('r', d => d.radius || 5)\n      .attr('fill', d => d.color || '#666')\n      .attr('stroke', '#fff')\n      .attr('stroke-width', 1.5)\n      .classed('selected', d => selectedEntities.includes(d.id));\n\n    // Add titles for tooltips\n    node.append('title').text(d => `${d.id} (${d.group})\\nValue: ${d.value}`);\n\n    // Cast to ExtendedQualitySettings to use the additional properties\n    const extendedSettings = qualitySettings as ExtendedQualitySettings;\n    const showLabels =\n      extendedSettings.showLabels !== undefined ? extendedSettings.showLabels : true; // Default to true\n    const textScaleFactor = extendedSettings.textScaleFactor || 1; // Default to 1\n\n    // Create text labels based on quality settings\n    if (showLabels) {\n      const labels = g\n        .append('g')\n        .attr('class', 'labels')\n        .selectAll('text')\n        .data(nodes.filter(n => n.value > filterValue)) // Only label significant nodes\n        .enter()\n        .append('text')\n        .attr('dx', 12)\n        .attr('dy', '.35em')\n        .text(d => d.id)\n        .style('font-size', `${10 * textScaleFactor}px`)\n        .style('fill', '#333');\n    }\n\n    // Create the force simulation with proper typing\n    const simulation = d3\n      .forceSimulation<D3NetworkNode>(nodes)\n      .force(\n        'link',\n        d3\n          .forceLink<D3NetworkNode, _D3Link>(links)\n          .id(d => d.id)\n          .distance(d => 30 + d.value)\n      )\n      .force(\n        'charge',\n        d3.forceManyBody().strength(d => {\n          // Safely access the size property by casting to D3NetworkNode\n          const node = d as D3NetworkNode;\n          return -30 * (node.size || 1);\n        })\n      )\n      .force('center', d3.forceCenter(svgWidth / 2, svgHeight / 2))\n      .force(\n        'collision',\n        d3.forceCollide<D3NetworkNode>().radius(d => (d.radius || 5) + 2)\n      );\n\n    // Create drag behavior with type safety\n    const drag = createSimulationDragBehavior<D3NetworkNode, SVGCircleElement>(simulation);\n\n    // Apply the drag behavior with proper type casting\n    node.call(drag as CircleDragBehavior);\n\n    // Node click handler\n    node.on('click', (event, d) => {\n      event.stopPropagation(); // Prevent triggering container click\n      handleEntitySelection(d.id);\n    });\n\n    // Update function for the simulation\n    simulation.on('tick', () => {\n      // Use safe accessors to prevent type errors\n      link\n        .attr('x1', d =>\n          d3Accessors.getX(typeof d.source === 'string' ? nodeMap.get(d.source) : d.source)\n        )\n        .attr('y1', d =>\n          d3Accessors.getY(typeof d.source === 'string' ? nodeMap.get(d.source) : d.source)\n        )\n        .attr('x2', d =>\n          d3Accessors.getX(typeof d.target === 'string' ? nodeMap.get(d.target) : d.target)\n        )\n        .attr('y2', d =>\n          d3Accessors.getY(typeof d.target === 'string' ? nodeMap.get(d.target) : d.target)\n        );\n\n      node.attr('cx', d => d3Accessors.getX(d)).attr('cy', d => d3Accessors.getY(d));\n\n      // Update labels position if they exist\n      if (showLabels) {\n        g.selectAll('.labels text')\n          .attr('x', d => d3Accessors.getX(d))\n          .attr('y', d => d3Accessors.getY(d));\n      }\n    });\n\n    // Store simulation reference for cleanup\n    simulationRef.current = simulation;\n\n    // Animation toggle\n    if (!isAnimating) {\n      simulation.alpha(0).stop();\n    }\n\n    // Cleanup function for when component unmounts or view changes\n    return () => {\n      if (simulationRef.current) {\n        simulationRef.current.stop();\n        simulationRef.current = null;\n      }\n    };\n  }, [\n    networkData,\n    width,\n    height,\n    selectedEntities,\n    filterValue,\n    isAnimating,\n    optimizationsEnabled,\n    qualitySettings,\n    convertNetworkDataToD3Format,\n    handleEntitySelection,\n  ]);\n\n  /**\n   * Converts time series data to D3-compatible format with proper typing\n   * Creates points and series objects needed for D3 visualization\n   */\n  const convertTimeSeriesDataToD3Format = useCallback(() => {\n    // Create color mapping for consistent colors per category\n    const categoryColors: Record<string, string> = {\n      revenue: '#4285F4', // Blue\n      expenses: '#EA4335', // Red\n      profit: '#34A853', // Green\n      users: '#FBBC05', // Yellow\n    };\n\n    // Convert points with proper typing\n    const points: D3TimeSeriesPoint[] = timeSeriesData.map(point => {\n      // Get color based on category\n      const color = categoryColors[point.category] || '#9AA0A6';\n\n      // Create D3 point with proper typing\n      const d3Point: D3TimeSeriesPoint = {\n        id: point.id,\n        date: point.timestamp,\n        value: point.value,\n        category: point.category,\n        color,\n        originalData: point,\n      };\n\n      return d3Point;\n    });\n\n    // Group points by category for line generation\n    const categories = Array.from(new Set(points.map(p => p.category)));\n    const series: CategorySeries[] = categories.map(category => {\n      return {\n        category,\n        color: categoryColors[category] || '#9AA0A6',\n        points: points\n          .filter(p => p.category === category)\n          .sort((a, b) => a.date.getTime() - b.date.getTime()),\n      };\n    });\n\n    return { points, series };\n  }, [timeSeriesData]);\n\n  /**\n   * Converts geographic data to D3-compatible format with proper typing\n   * This creates points objects needed for D3 geo visualization\n   */\n  const convertGeoDataToD3Format = useCallback(() => {\n    // Create color mapping for consistent colors per category\n    const categoryColors: Record<string, string> = {\n      customers: '#4285F4', // Blue\n      sales: '#EA4335', // Red\n      partners: '#34A853', // Green\n    };\n\n    // Convert points with proper typing\n    const points: D3GeoPoint[] = geoData.map(point => {\n      // Get color based on category\n      const color = categoryColors[point.category] || '#9AA0A6';\n\n      // Create D3 geo point with proper typing\n      const d3Point: D3GeoPoint = {\n        id: point.id,\n        coordinates: [point.longitude, point.latitude], // GeoJSON uses [longitude, latitude]\n        value: point.value,\n        category: point.category,\n        color,\n        region: point.region,\n        population: point.population,\n        originalData: point,\n      };\n\n      return d3Point;\n    });\n\n    // Group points by category for styling and filtering\n    const categories = Array.from(new Set(points.map(p => p.category)));\n    const geoCategories: GeoCategory[] = categories.map(category => {\n      return {\n        category,\n        color: categoryColors[category] || '#9AA0A6',\n        points: points.filter(p => p.category === category),\n      };\n    });\n\n    return { points, geoCategories };\n  }, [geoData]);\n\n  /**\n   * Converts flat hierarchy data to a proper hierarchical structure with proper typing\n   * This creates a tree structure suitable for D3 hierarchical layouts\n   */\n  const convertHierarchyDataToD3Format = useCallback(() => {\n    // Create a map to store nodes by ID for quick lookup\n    const nodeMap = new Map<string, D3HierarchyNode>();\n\n    // Define category colors\n    const categoryColors: Record<string, string> = {\n      'category-A': '#4285F4', // Blue\n      'category-B': '#EA4335', // Red\n      'category-C': '#34A853', // Green\n      'subcategory-1': '#9AA0A6', // Gray\n      'subcategory-2': '#FBBC05', // Yellow\n      'subcategory-3': '#DADCE0', // Light gray\n      root: '#5F6368', // Dark gray\n    };\n\n    // First pass: create D3HierarchyNode objects for all nodes\n    hierarchyData.forEach(node => {\n      const color = categoryColors[node.category] || '#9AA0A6';\n\n      const d3Node: D3HierarchyNode = {\n        id: node.id,\n        name: node.id, // Use ID as name\n        value: node.value,\n        size: node.size,\n        category: node.category,\n        color,\n        children: [],\n        originalData: node,\n      };\n\n      nodeMap.set(node.id, d3Node);\n    });\n\n    // Second pass: build the tree structure\n    const rootNodes: D3HierarchyNode[] = [];\n\n    hierarchyData.forEach(node => {\n      const d3Node = nodeMap.get(node.id);\n\n      if (node.parentId === null) {\n        // This is a root node\n        rootNodes.push(d3Node!);\n      } else {\n        // This node has a parent, add it to the parent's children\n        const parentNode = nodeMap.get(node.parentId);\n        if (parentNode) {\n          if (!parentNode.children) {\n            parentNode.children = [];\n          }\n          parentNode.children.push(d3Node!);\n        }\n      }\n    });\n\n    // Return the root of the hierarchy (should be only one)\n    return rootNodes[0];\n  }, [hierarchyData]);\n\n  /**\n   * Creates a hierarchical visualization with tree or treemap layout\n   * Uses D3's hierarchical layouts with proper type safety\n   */\n  const initializeHierarchyVisualization = useCallback(() => {\n    if (!hierarchyRef.current || hierarchyData.length === 0) return;\n\n    console.warn(`Initializing hierarchical visualization with ${hierarchyLayoutType} layout`);\n\n    // Clear previous visualization\n    d3.select(hierarchyRef.current).selectAll('*').remove();\n\n    // Get the container dimensions\n    const svgWidth = width;\n    const svgHeight = height * 0.8; // 80% of total height for the visualization\n\n    // Cast quality settings\n    const extendedSettings = qualitySettings as ExtendedQualitySettings;\n\n    // Default settings with fallbacks\n    const animationsEnabled =\n      extendedSettings.animationsEnabled !== undefined ? extendedSettings.animationsEnabled : true;\n    const animationDuration = extendedSettings.animationDuration || 1000;\n    const showLabels =\n      extendedSettings.showLabels !== undefined ? extendedSettings.showLabels : true;\n    const textScaleFactor = extendedSettings.textScaleFactor || 1;\n    const nodeColor = extendedSettings.nodeColor || 'byCategory';\n    const linkStyle = extendedSettings.linkStyle || 'diagonal';\n    const treemapTiling = extendedSettings.treemapTiling || 'squarify';\n    const includeSizeEncoding =\n      extendedSettings.includeSizeEncoding !== undefined\n        ? extendedSettings.includeSizeEncoding\n        : true;\n    const treeOrientation = extendedSettings.treeOrientation || 'vertical';\n\n    // Convert hierarchy data to D3 format (proper tree structure)\n    const rootNode = convertHierarchyDataToD3Format();\n\n    // Create the SVG container\n    const svg = d3\n      .select(hierarchyRef.current)\n      .attr('width', svgWidth)\n      .attr('height', svgHeight)\n      .attr('viewBox', [0, 0, svgWidth, svgHeight])\n      .attr('style', 'max-width: 100%; height: auto; font: 10px sans-serif;');\n\n    // Set up margins and visualization dimensions\n    const margin = { top: 40, right: 40, bottom: 40, left: 120 };\n    const visWidth = svgWidth - margin.left - margin.right;\n    const visHeight = svgHeight - margin.top - margin.bottom;\n\n    // Create visualization area with margin\n    const g = svg\n      .append('g')\n      .attr('transform', `translate(${margin.left},${margin.top})`)\n      .attr('class', 'hierarchy-container');\n\n    // Main visualization title\n    svg\n      .append('text')\n      .attr('class', 'hierarchy-title')\n      .attr('text-anchor', 'middle')\n      .attr('x', svgWidth / 2)\n      .attr('y', 20)\n      .attr('font-size', '16px')\n      .attr('font-weight', 'bold')\n      .text(\n        `Hierarchical Data Visualization (${hierarchyLayoutType.charAt(0).toUpperCase() + hierarchyLayoutType.slice(1)})`\n      );\n\n    // Create a group for zoom/pan transformations\n    const zoomG = g.append('g');\n\n    // Apply category filter if selected entities exist\n    const _filterByCategory = (node: D3HierarchyNode): boolean => {\n      if (selectedEntities.length === 0) return true;\n      if (selectedEntities.includes(node.category)) return true;\n      if (node.children) {\n        // Include if any children match the filter\n        return node.children.some(_filterByCategory);\n      }\n      return false;\n    };\n\n    // Create a value scale for node size\n    const valueExtent = d3.extent(hierarchyData, d => d.value) as [number, number];\n    const sizeScale = d3.scaleSqrt().domain(valueExtent).range([5, 20]);\n\n    // Create color scales\n    const categoryScale = (category: string): string => {\n      const colorMap: Record<string, string> = {\n        'category-A': '#4285F4',\n        'category-B': '#EA4335',\n        'category-C': '#34A853',\n        'subcategory-1': '#9AA0A6',\n        'subcategory-2': '#FBBC05',\n        'subcategory-3': '#DADCE0',\n        root: '#5F6368',\n      };\n      return colorMap[category] || '#9AA0A6';\n    };\n\n    const valueColorScale = d3.scaleSequential(d3.interpolateViridis).domain(valueExtent);\n\n    const depthColorScale = d3.scaleOrdinal(d3.schemeCategory10);\n\n    // (...args: unknown[]) => unknown to determine node color based on settings\n    const getNodeColor = (d: HierarchyDatum): string => {\n      switch (nodeColor) {\n        case 'byValue':\n          return valueColorScale(d.data.value);\n        case 'byDepth':\n          return depthColorScale(d.depth.toString());\n        case 'byCategory':\n        default:\n          return d.data.color || categoryScale(d.data.category);\n      }\n    };\n\n    // Create hierarchy from the rootNode using d3.hierarchy\n    const root = d3.hierarchy<D3HierarchyNode>(rootNode) as unknown as HierarchyDatum;\n\n    // Apply filtering if needed\n    // Apply filter to only include nodes that match selectedEntities\n    if (selectedEntities.length > 0) {\n      root.descendants().forEach(node => {\n        if (node.children) {\n          node.children = node.children.filter(\n            child =>\n              selectedEntities.length === 0 ||\n              selectedEntities.includes(child.data.category) ||\n              (child.children &&\n                child.children.some(grandchild =>\n                  selectedEntities.includes(grandchild.data.category)\n                ))\n          );\n        }\n      });\n    }\n\n    // Size the hierarchy based on values\n    root.sum(d => (includeSizeEncoding ? d.value : 1));\n\n    // Implement different layouts based on the selected type\n    if (hierarchyLayoutType === 'treemap') {\n      // TREEMAP LAYOUT\n\n      // Create the treemap layout\n      let tilingMethod: TreemapTilingFunc;\n      switch (treemapTiling) {\n        case 'binary':\n          tilingMethod = d3.treemapBinary;\n          break;\n        case 'slice':\n          tilingMethod = d3.treemapSlice;\n          break;\n        case 'dice':\n          tilingMethod = d3.treemapDice;\n          break;\n        case 'sliceDice':\n          tilingMethod = d3.treemapSliceDice;\n          break;\n        case 'squarify':\n        default:\n          tilingMethod = d3.treemapSquarify;\n          break;\n      }\n\n      const treemap = d3\n        .treemap<D3HierarchyNode>()\n        .size([visWidth, visHeight])\n        .padding(3)\n        .round(true)\n        .tile(tilingMethod);\n\n      // Compute the treemap layout\n      treemap(root as unknown as d3.HierarchyNode<D3HierarchyNode>);\n\n      // Create the treemap cells\n      const nodes = zoomG\n        .selectAll('g')\n        .data(root.descendants())\n        .enter()\n        .append('g')\n        .attr('transform', d => {\n          // Use non-null assertions since we know these values exist after treemap layout\n          return `translate(${d.x0!},${d.y0!})`;\n        })\n        .attr('class', 'node')\n        .classed('selected', d => selectedEntities.includes(d.data.id));\n\n      // Add rectangles for each node\n      nodes\n        .append('rect')\n        .attr('width', d => Math.max(0, d.x1! - d.x0!))\n        .attr('height', d => Math.max(0, d.y1! - d.y0!))\n        .attr('fill', getNodeColor)\n        .attr('stroke', '#fff')\n        .attr('stroke-width', 1)\n        .on('click', (event, d) => {\n          event.stopPropagation();\n          handleEntitySelection(d.data.id);\n        });\n\n      // Add text labels to cells\n      nodes\n        .append('text')\n        .attr('x', d => (d.x1! - d.x0!) / 2)\n        .attr('y', d => (d.y1! - d.y0!) / 2)\n        .attr('text-anchor', 'middle')\n        .attr('dominant-baseline', 'middle')\n        .style('font-size', d => {\n          const width = d.x1! - d.x0!;\n          const height = d.y1! - d.y0!;\n          return Math.min(width, height) / 8 + 'px';\n        })\n        .style('fill', '#fff')\n        .text(d => d.data.name)\n        .style('pointer-events', 'none');\n\n      // Add tooltips\n      nodes\n        .append('title')\n        .text(\n          d =>\n            `${d.data.name}\\nCategory: ${d.data.category}\\nValue: ${d.data.value.toFixed(2)}\\nSize: ${d.data.size}`\n        );\n\n      // Add click handlers for selection\n      nodes.on('click', (event, d) => {\n        event.stopPropagation();\n        handleEntitySelection(d.data.id);\n      });\n\n      // Add zoom behavior\n      const zoom = createSvgZoomBehavior<SVGSVGElement>({\n        scaleExtentMin: 0.5,\n        scaleExtentMax: 8,\n        targetElement: zoomG,\n        constrainPan: true,\n      });\n\n      // Apply zoom to the SVG\n      svg.call(zoom);\n\n      // Add animations if enabled\n      if (animationsEnabled && isAnimating) {\n        // Animate the nodes appearing\n        nodes\n          .attr('opacity', 0)\n          .transition()\n          .duration(animationDuration)\n          .attr('opacity', 0.8)\n          .ease(d3.easeBackOut);\n      }\n    } else {\n      // TREE LAYOUT\n\n      // Determine tree orientation\n      let treeLayout: d3.TreeLayout<D3HierarchyNode>;\n\n      if (treeOrientation === 'horizontal') {\n        // Horizontal tree (left to right)\n        treeLayout = d3.tree<D3HierarchyNode>().size([visHeight, visWidth]);\n\n        // Swap x and y in the resulting layout\n        root.descendants().forEach(d => {\n          const temp = d.x;\n          d.x = d.y;\n          d.y = temp;\n        });\n      } else if (treeOrientation === 'radial') {\n        // Radial tree\n        treeLayout = d3\n          .tree<D3HierarchyNode>()\n          .size([2 * Math.PI, Math.min(visWidth, visHeight) / 2 - 40]);\n\n        // Apply layout without transforming yet\n        treeLayout(root as unknown as d3.HierarchyNode<D3HierarchyNode>);\n\n        // Convert from polar to Cartesian coordinates\n        root.descendants().forEach(d => {\n          const radius = d.y!; // Add non-null assertion\n          const angle = d.x!; // Add non-null assertion\n          d.x = radius * Math.cos(angle - Math.PI / 2) + visWidth / 2;\n          d.y = radius * Math.sin(angle - Math.PI / 2) + visHeight / 2;\n        });\n      } else {\n        // Default: Vertical tree (top to bottom)\n        treeLayout = d3.tree<D3HierarchyNode>().size([visWidth, visHeight]);\n      }\n\n      // Apply the tree layout if not already applied\n      if (treeOrientation !== 'radial') {\n        treeLayout(root as unknown as d3.HierarchyNode<D3HierarchyNode>);\n      }\n\n      // Create the link generator based on the selected style\n      const linkGenerator = (d: CustomHierarchyPointLink) => {\n        const source = { x: d.source.x || 0, y: d.source.y || 0, data: d.source.data };\n        const target = { x: d.target.x || 0, y: d.target.y || 0, data: d.target.data };\n\n        // Create properly formatted link data for d3.linkHorizontal\n        const linkData: D3LinkData = {\n          source: [source.y, source.x],\n          target: [target.y, target.x],\n        };\n\n        switch (linkStyle) {\n          case 'straight':\n            return d3.linkHorizontal()(linkData);\n          case 'step':\n            return `M${source.y},${source.x} V${target.x} H${target.y}`;\n          case 'diagonal':\n          default:\n            return d3.linkHorizontal()(linkData);\n        }\n      };\n\n      // Draw links\n      const links = zoomG\n        .append('g')\n        .attr('class', 'links')\n        .selectAll('path')\n        .data(root.links())\n        .enter()\n        .append('path')\n        .attr('d', d => {\n          // Cast the HierarchyDatum link to CustomHierarchyPointLink\n          const link = {\n            source: {\n              x: d.source.x || 0,\n              y: d.source.y || 0,\n              data: d.source.data,\n            },\n            target: {\n              x: d.target.x || 0,\n              y: d.target.y || 0,\n              data: d.target.data,\n            },\n          } as CustomHierarchyPointLink;\n\n          return linkGenerator(link);\n        })\n        .attr('fill', 'none')\n        .attr('stroke', '#ccc')\n        .attr('stroke-width', 1.5)\n        .attr('opacity', 0.5);\n\n      // Draw nodes\n      const nodes = zoomG\n        .append('g')\n        .attr('class', 'nodes')\n        .selectAll('g')\n        .data(root.descendants())\n        .enter()\n        .append('g')\n        .attr('class', 'node')\n        .attr('transform', d => `translate(${d.x},${d.y})`)\n        .classed('selected', d => selectedEntities.includes(d.data.category));\n\n      // Add circles for each node\n      const circles = nodes\n        .append('circle')\n        .attr('r', d => (includeSizeEncoding ? sizeScale(d.data.value) : 6))\n        .attr('fill', getNodeColor)\n        .attr('stroke', '#fff')\n        .attr('stroke-width', 1.5)\n        .attr('cursor', 'pointer');\n\n      // Add labels if enabled\n      if (showLabels) {\n        nodes\n          .append('text')\n          .attr('dy', '.31em')\n          .attr('x', d => (d.children ? -8 : 8))\n          .style('text-anchor', d => (d.children ? 'end' : 'start'))\n          .text(d => d.data.name)\n          .attr('font-size', `${10 * textScaleFactor}px`)\n          .attr('pointer-events', 'none'); // Don't interfere with click events\n      }\n\n      // Add tooltips\n      nodes\n        .append('title')\n        .text(\n          d =>\n            `${d.data.name}\\nCategory: ${d.data.category}\\nValue: ${d.data.value.toFixed(2)}\\nSize: ${d.data.size}`\n        );\n\n      // Add click handlers for selection\n      nodes.on('click', (event, d) => {\n        event.stopPropagation();\n        handleEntitySelection(d.data.category);\n      });\n\n      // Add zoom behavior\n      const zoom = createSvgZoomBehavior<SVGSVGElement>({\n        scaleExtentMin: 0.5,\n        scaleExtentMax: 8,\n        targetElement: zoomG,\n        constrainPan: true,\n      });\n\n      // Apply zoom to the SVG\n      svg.call(zoom);\n\n      // Add initial transform to center the root node\n      if (treeOrientation === 'horizontal') {\n        const initialTransform = d3.zoomIdentity.translate(margin.left, visHeight / 2);\n        svg.call(zoom.transform, initialTransform);\n      }\n\n      // Add animations if enabled\n      if (animationsEnabled && isAnimating) {\n        // Animate the links\n        links\n          .attr('stroke-dasharray', function () {\n            const length = this.getTotalLength();\n            return `${length} ${length}`;\n          })\n          .attr('stroke-dashoffset', function () {\n            return this.getTotalLength();\n          })\n          .transition()\n          .duration(animationDuration)\n          .attr('stroke-dashoffset', 0)\n          .ease(d3.easeLinear);\n\n        // Animate the nodes appearing\n        circles\n          .attr('r', 0)\n          .transition()\n          .duration(animationDuration)\n          .delay((d, i) => d.depth * 300 + i * 10)\n          .attr('r', d => (includeSizeEncoding ? sizeScale(d.data.value) : 6))\n          .ease(d3.easeElastic);\n      }\n    }\n\n    // Add layout toggle buttons\n    const buttonGroup = svg\n      .append('g')\n      .attr('class', 'layout-buttons')\n      .attr('transform', `translate(${svgWidth - 180}, ${margin.top - 20})`);\n\n    const layouts = ['tree', 'treemap', 'cluster', 'radial'];\n\n    layouts.forEach((layout, i) => {\n      const button = buttonGroup\n        .append('g')\n        .attr('class', 'layout-button')\n        .attr('transform', `translate(${i * 45}, 0)`)\n        .style('cursor', 'pointer')\n        .on('click', () => {\n          setHierarchyLayoutType(layout as ExtendedQualitySettings['hierarchyLayout']);\n        });\n\n      button\n        .append('rect')\n        .attr('width', 40)\n        .attr('height', 20)\n        .attr('rx', 5)\n        .attr('ry', 5)\n        .attr('fill', layout === hierarchyLayoutType ? '#4285F4' : '#e0e0e0');\n\n      button\n        .append('text')\n        .attr('x', 20)\n        .attr('y', 14)\n        .attr('text-anchor', 'middle')\n        .attr('fill', layout === hierarchyLayoutType ? '#fff' : '#333')\n        .attr('font-size', '10px')\n        .text(layout.charAt(0).toUpperCase() + layout.slice(1));\n    });\n\n    // Reset selection when clicking on the background\n    svg.on('click', event => {\n      // Prevent triggering if clicking on nodes\n      if (event.target === svg.node()) {\n        setSelectedEntities([]);\n      }\n    });\n  }, [\n    hierarchyData,\n    hierarchyRef.current,\n    width,\n    height,\n    hierarchyLayoutType,\n    isAnimating,\n    optimizationsEnabled,\n    qualitySettings,\n    selectedEntities,\n    convertHierarchyDataToD3Format,\n    handleEntitySelection,\n  ]);\n\n  // Initialize visualizations once data is loaded\n  useEffect(() => {\n    if (!dataLoaded) return;\n\n    // Initialize visualizations based on current view\n    switch (currentView) {\n      case VisualizationType.NETWORK:\n        initializeNetworkVisualization();\n        break;\n      case VisualizationType.TIMESERIES:\n        initializeTimeSeriesVisualization();\n        break;\n      case VisualizationType.GEOSPATIAL:\n        initializeGeoVisualization();\n        break;\n      case VisualizationType.HIERARCHY:\n        initializeHierarchyVisualization();\n        break;\n    }\n  }, [\n    dataLoaded,\n    currentView,\n    networkData,\n    timeSeriesData,\n    geoData,\n    hierarchyData,\n    selectedEntities,\n    timeRange,\n    optimizationsEnabled,\n    qualitySettings,\n    initializeNetworkVisualization,\n    initializeTimeSeriesVisualization,\n    initializeGeoVisualization,\n    initializeHierarchyVisualization,\n    hierarchyLayoutType,\n  ]);\n\n  // Generate mock network data\n  const generateNetworkData = (nodeCount: number, linkCount: number) => {\n    const nodes: NetworkNode[] = [];\n    const links: NetworkLink[] = [];\n\n    // Generate nodes\n    const groups = ['A', 'B', 'C', 'D'];\n    for (let i = 0; i < nodeCount; i++) {\n      nodes.push({\n        id: `node-${i}`,\n        value: Math.random() * 100,\n        category: ['primary', 'secondary', 'tertiary'][Math.floor(Math.random() * 3)],\n        timestamp: new Date(2022, Math.floor(Math.random() * 12), Math.floor(Math.random() * 28)),\n        connections: [],\n        group: groups[Math.floor(Math.random() * groups.length)],\n        size: Math.random() * 10 + 5,\n      });\n    }\n\n    // Generate links\n    for (let i = 0; i < linkCount; i++) {\n      const source = Math.floor(Math.random() * nodeCount);\n      let target = Math.floor(Math.random() * nodeCount);\n\n      // Avoid self-links\n      while (target === source) {\n        target = Math.floor(Math.random() * nodeCount);\n      }\n\n      const link = {\n        source: `node-${source}`,\n        target: `node-${target}`,\n        value: Math.random() * 10,\n        type: ['direct', 'indirect'][Math.floor(Math.random() * 2)],\n      };\n\n      links.push(link);\n\n      // Update node connections\n      nodes[source].connections.push(`node-${target}`);\n      nodes[target].connections.push(`node-${source}`);\n    }\n\n    return { nodes, links };\n  };\n\n  // Generate mock time series data\n  const generateTimeSeriesData = useCallback((_pointCount: number) => {\n    const data: TimeSeriesPoint[] = [];\n    const categories = ['revenue', 'expenses', 'profit', 'users'];\n    const timePeriods = ['Q1', 'Q2', 'Q3', 'Q4'];\n\n    // Generate time series points\n    for (let year = 2020; year <= 2023; year++) {\n      for (let periodIdx = 0; periodIdx < timePeriods.length; periodIdx++) {\n        for (let catIdx = 0; catIdx < categories.length; catIdx++) {\n          const prevValue =\n            catIdx === 0\n              ? 0\n              : data.find(\n                  d =>\n                    d.category === categories[catIdx] &&\n                    d.timePeriod === timePeriods[periodIdx === 0 ? 3 : periodIdx - 1]\n                )?.value || 0;\n\n          const randomChange = Math.random() * 20 - 10; // -10 to +10\n          const value = Math.max(0, prevValue + randomChange + Math.random() * 5 + 50);\n\n          data.push({\n            id: `ts-${year}-${timePeriods[periodIdx]}-${categories[catIdx]}`,\n            value,\n            category: categories[catIdx],\n            timestamp: new Date(year, periodIdx * 3, 15), // Quarterly data\n            timePeriod: `${year}-${timePeriods[periodIdx]}`,\n            change: value - prevValue,\n          });\n        }\n      }\n    }\n\n    return data;\n  }, []);\n\n  // Generate mock geo data\n  const generateGeoData = (pointCount: number) => {\n    const data: GeoDataPoint[] = [];\n    const regions = ['North America', 'Europe', 'Asia', 'South America', 'Africa', 'Oceania'];\n\n    // Generate geo points\n    for (let i = 0; i < pointCount; i++) {\n      const region = regions[Math.floor(Math.random() * regions.length)];\n\n      // Generate latitude/longitude based on rough region bounds\n      let latitude, longitude;\n      switch (region) {\n        case 'North America':\n          latitude = 30 + Math.random() * 20;\n          longitude = -130 + Math.random() * 60;\n          break;\n        case 'Europe':\n          latitude = 40 + Math.random() * 15;\n          longitude = -10 + Math.random() * 50;\n          break;\n        case 'Asia':\n          latitude = 10 + Math.random() * 40;\n          longitude = 60 + Math.random() * 80;\n          break;\n        case 'South America':\n          latitude = -40 + Math.random() * 40;\n          longitude = -80 + Math.random() * 30;\n          break;\n        case 'Africa':\n          latitude = -30 + Math.random() * 50;\n          longitude = -20 + Math.random() * 60;\n          break;\n        case 'Oceania':\n          latitude = -40 + Math.random() * 30;\n          longitude = 110 + Math.random() * 50;\n          break;\n        default:\n          latitude = Math.random() * 180 - 90;\n          longitude = Math.random() * 360 - 180;\n      }\n\n      data.push({\n        id: `geo-${i}`,\n        value: Math.random() * 100,\n        category: ['customers', 'sales', 'partners'][Math.floor(Math.random() * 3)],\n        timestamp: new Date(2022, Math.floor(Math.random() * 12), Math.floor(Math.random() * 28)),\n        region,\n        latitude,\n        longitude,\n        population: Math.floor(Math.random() * 1000000),\n      });\n    }\n\n    return data;\n  };\n\n  // Generate mock hierarchy data\n  const generateHierarchyData = (nodeCount: number) => {\n    const data: HierarchyNode[] = [];\n\n    // Create root node\n    data.push({\n      id: 'root',\n      value: 1000,\n      category: 'root',\n      timestamp: new Date(),\n      parentId: null,\n      size: 100,\n    });\n\n    // Create first level children\n    const firstLevelCount = 5;\n    for (let i = 0; i < firstLevelCount; i++) {\n      data.push({\n        id: `level1-${i}`,\n        value: 200 + Math.random() * 200,\n        category: ['category-A', 'category-B', 'category-C'][Math.floor(Math.random() * 3)],\n        timestamp: new Date(),\n        parentId: 'root',\n        size: 50 + Math.random() * 20,\n      });\n    }\n\n    // Create second level children\n    const remainingNodes = nodeCount - 1 - firstLevelCount;\n    const nodesPerFirstLevel = Math.floor(remainingNodes / firstLevelCount);\n\n    for (let i = 0; i < firstLevelCount; i++) {\n      for (let j = 0; j < nodesPerFirstLevel; j++) {\n        data.push({\n          id: `level2-${i}-${j}`,\n          value: 50 + Math.random() * 100,\n          category: ['subcategory-1', 'subcategory-2', 'subcategory-3'][\n            Math.floor(Math.random() * 3)\n          ],\n          timestamp: new Date(),\n          parentId: `level1-${i}`,\n          size: 20 + Math.random() * 10,\n        });\n      }\n    }\n\n    return data;\n  };\n\n  // Load world map data once\n  useEffect(() => {\n    // In a real application, this would load from an API or local file\n    // For this demo, we'll use a simplified world map in GeoJSON format\n    const fetchWorldMap = async () => {\n      try {\n        // Simplified world map in GeoJSON format (low resolution for performance)\n        const response = await fetch('https://unpkg.com/world-atlas@2.0.2/countries-110m.json');\n        const data = await response.json();\n        setWorldMapData(data);\n      } catch (error) {\n        console.error('Error loading world map data:', error);\n        // Fallback to null if fetch fails\n        setWorldMapData(null);\n      }\n    };\n\n    fetchWorldMap();\n  }, []);\n\n  // Memoized labels\n  const _labels = useMemo(() => {\n    return {\n      network: {\n        title: 'Network Visualization',\n        subtitle: 'Interactive force-directed graph',\n      },\n      timeseries: {\n        title: 'Time Series Analysis',\n        subtitle: 'Multi-category temporal data',\n      },\n      geospatial: {\n        title: 'Geographic Distribution',\n        subtitle: 'Global data visualization',\n      },\n      hierarchy: {\n        title: 'Hierarchical Structure',\n        subtitle: 'Tree-based organization',\n      },\n    };\n  }, []);\n\n  // Rendering\n  return (\n    <div\n      className=\"data-dashboard-app\"\n      ref={containerRef}\n      style={{\n        width,\n        height,\n        fontFamily: 'Arial, sans-serif',\n        display: 'flex',\n        flexDirection: 'column',\n      }}\n    >\n      <div\n        className=\"dashboard-header\"\n        style={{\n          padding: '1rem',\n          backgroundColor: '#f5f5f5',\n          borderBottom: '1px solid #ddd',\n        }}\n      >\n        <h1 style={{ margin: 0, fontSize: '1.5rem' }}>Data Visualization Dashboard</h1>\n        <p>A comprehensive showcase of optimized D3 visualizations</p>\n\n        <div\n          className=\"dashboard-controls\"\n          style={{\n            display: 'flex',\n            gap: '1rem',\n            marginTop: '0.5rem',\n          }}\n        >\n          <div className=\"view-selector\" style={{ display: 'flex', gap: '0.5rem' }}>\n            {Object.values(VisualizationType).map(type => (\n              <button\n                key={type}\n                onClick={() => handleViewChange(type)}\n                style={{\n                  padding: '0.5rem 1rem',\n                  backgroundColor: currentView === type ? '#2196F3' : '#e0e0e0',\n                  color: currentView === type ? 'white' : 'black',\n                  border: 'none',\n                  borderRadius: '4px',\n                  cursor: 'pointer',\n                }}\n              >\n                {type.charAt(0).toUpperCase() + type.slice(1)}\n              </button>\n            ))}\n          </div>\n\n          <button\n            onClick={toggleAnimation}\n            style={{\n              padding: '0.5rem 1rem',\n              backgroundColor: isAnimating ? '#f44336' : '#4CAF50',\n              color: 'white',\n              border: 'none',\n              borderRadius: '4px',\n              cursor: 'pointer',\n            }}\n          >\n            {isAnimating ? 'Stop Animation' : 'Start Animation'}\n          </button>\n\n          <button\n            onClick={toggleOptimizations}\n            style={{\n              padding: '0.5rem 1rem',\n              backgroundColor: optimizationsEnabled ? '#9C27B0' : '#FF9800',\n              color: 'white',\n              border: 'none',\n              borderRadius: '4px',\n              cursor: 'pointer',\n            }}\n          >\n            {optimizationsEnabled ? 'Optimizations On' : 'Optimizations Off'}\n          </button>\n        </div>\n      </div>\n\n      <div\n        className=\"dashboard-main\"\n        style={{\n          flex: 1,\n          display: 'grid',\n          gridTemplateColumns: '70% 30%',\n          gridTemplateRows: '60% 40%',\n          gap: '1rem',\n          padding: '1rem',\n          overflow: 'hidden',\n        }}\n      >\n        <div\n          className=\"main-visualization\"\n          style={{\n            gridColumn: '1',\n            gridRow: '1 / span 2',\n            backgroundColor: 'white',\n            boxShadow: '0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24)',\n            borderRadius: '4px',\n            overflow: 'hidden',\n            position: 'relative',\n          }}\n        >\n          {currentView === VisualizationType.NETWORK && (\n            <svg ref={networkRef} width=\"100%\" height=\"100%\"></svg>\n          )}\n\n          {currentView === VisualizationType.TIMESERIES && (\n            <svg ref={timeSeriesRef} width=\"100%\" height=\"100%\"></svg>\n          )}\n\n          {currentView === VisualizationType.GEOSPATIAL && (\n            <svg ref={geoMapRef} width=\"100%\" height=\"100%\"></svg>\n          )}\n\n          {currentView === VisualizationType.HIERARCHY && (\n            <svg ref={hierarchyRef} width=\"100%\" height=\"100%\"></svg>\n          )}\n\n          {!dataLoaded && (\n            <div\n              className=\"loading-overlay\"\n              style={{\n                position: 'absolute',\n                top: 0,\n                left: 0,\n                right: 0,\n                bottom: 0,\n                display: 'flex',\n                justifyContent: 'center',\n                alignItems: 'center',\n                backgroundColor: 'rgba(255, 255, 255, 0.7)',\n              }}\n            >\n              <div>Loading visualization data...</div>\n            </div>\n          )}\n        </div>\n\n        <div\n          className=\"detail-panel\"\n          style={{\n            gridColumn: '2',\n            gridRow: '1',\n            backgroundColor: 'white',\n            boxShadow: '0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24)',\n            borderRadius: '4px',\n            padding: '1rem',\n            overflow: 'auto',\n          }}\n        >\n          <h2 style={{ margin: '0 0 1rem 0', fontSize: '1.2rem' }}>Details</h2>\n\n          {selectedEntities.length > 0 ? (\n            <div className=\"selected-entities\">\n              <h3>Selected Items</h3>\n              <ul>\n                {selectedEntities.map(id => (\n                  <li key={id}>{id}</li>\n                ))}\n              </ul>\n            </div>\n          ) : (\n            <div className=\"no-selection\">\n              <p>No items selected. Click on elements in the visualization to see details.</p>\n            </div>\n          )}\n        </div>\n\n        <div\n          className=\"controls-panel\"\n          style={{\n            gridColumn: '2',\n            gridRow: '2',\n            backgroundColor: 'white',\n            boxShadow: '0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24)',\n            borderRadius: '4px',\n            padding: '1rem',\n            overflow: 'auto',\n          }}\n        >\n          <h2 style={{ margin: '0 0 1rem 0', fontSize: '1.2rem' }}>Controls</h2>\n\n          <div className=\"filter-controls\" style={{ marginBottom: '1rem' }}>\n            <label style={{ display: 'block', marginBottom: '0.5rem' }}>\n              Filter by value: {filterValue}\n            </label>\n            <input\n              type=\"range\"\n              min=\"0\"\n              max=\"100\"\n              value={filterValue}\n              onChange={e => handleFilterChange(parseInt(e.target.value))}\n              style={{ width: '100%' }}\n            />\n          </div>\n\n          <div className=\"time-range-controls\">\n            <h3 style={{ fontSize: '1rem', marginBottom: '0.5rem' }}>Time Range</h3>\n            <div\n              style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '0.5rem' }}\n            >\n              <span>{timeRange[0].toLocaleDateString()}</span>\n              <span>{timeRange[1].toLocaleDateString()}</span>\n            </div>\n            {/* This is a simplified time range selector - would be replaced with a proper date range picker */}\n            <input\n              type=\"range\"\n              min=\"0\"\n              max=\"100\"\n              value={50}\n              onChange={() => {}}\n              style={{ width: '100%' }}\n            />\n          </div>\n        </div>\n      </div>\n\n      <div\n        className=\"dashboard-footer\"\n        style={{\n          padding: '0.5rem 1rem',\n          backgroundColor: '#f5f5f5',\n          borderTop: '1px solid #ddd',\n          fontSize: '0.8rem',\n          color: '#666',\n        }}\n      >\n        <div>\n          Quality Tier:{' '}\n          {qualitySettings.visualComplexity >= 0.8\n            ? 'High'\n            : qualitySettings.visualComplexity >= 0.5\n              ? 'Medium'\n              : 'Low'}\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default DataDashboardApp;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/showcase/PerformanceMonitoringDashboard.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'setFrameBudget' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 85,
        "column": 23,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 85,
        "endColumn": 37
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'e' is defined but never used. Allowed unused caught errors must match /^_/u.",
        "line": 178,
        "column": 14,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 178,
        "endColumn": 15
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'colorScale' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 898,
        "column": 9,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 898,
        "endColumn": 19
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import * as d3 from 'd3';\nimport * as React from \"react\";\nimport { useEffect, useRef, useState } from 'react';\n\n// Import optimization utilities\nimport {\n  animationFrameManager,\n  FrameInfo,\n} from '../../../utils/performance/D3AnimationFrameManager';\n\n// Type definitions\ninterface PerformanceMonitoringDashboardProps {\n  width?: number;\n  height?: number;\n}\n\ninterface MetricPoint {\n  timestamp: number;\n  value: number;\n}\n\ninterface PerformanceMetrics {\n  fps: MetricPoint[];\n  cpuTime: MetricPoint[];\n  memoryUsage: MetricPoint[];\n  domOperations: MetricPoint[];\n  renderTime: MetricPoint[];\n  layoutThrashing: MetricPoint[];\n  cacheHitRate: MetricPoint[];\n  animationSmoothness: MetricPoint[];\n}\n\ninterface PerformanceIssue {\n  id: string;\n  timestamp: number;\n  type: 'frame_drop' | 'layout_thrashing' | 'high_cpu' | 'memory_leak' | 'jank';\n  severity: 'low' | 'medium' | 'high' | 'critical';\n  description: string;\n  recommendation: string;\n  relatedMetrics: string[];\n}\n\n/**\n * PerformanceMonitoringDashboard\n *\n * A comprehensive dashboard for monitoring and visualizing performance metrics\n * of D3 visualizations. It provides real-time insights into performance characteristics\n * and helps identify optimization opportunities.\n *\n * Features:\n * - Real-time performance metrics\n * - Historical data visualization\n * - Issue detection and recommendations\n * - Comparative performance analysis\n * - Integration with all optimization systems\n */\nconst PerformanceMonitoringDashboard: React.FC<PerformanceMonitoringDashboardProps> = ({\n  width = 1200,\n  height = 900,\n}) => {\n  // References\n  const containerRef = useRef<HTMLDivElement>(null);\n  const fpsChartRef = useRef<SVGSVGElement>(null);\n  const cpuChartRef = useRef<SVGSVGElement>(null);\n  const memoryChartRef = useRef<SVGSVGElement>(null);\n  const timelineChartRef = useRef<SVGSVGElement>(null);\n\n  // State\n  const [isMonitoring, setIsMonitoring] = useState(false);\n  const [monitoredAnimation, setMonitoredAnimation] = useState<string>('');\n  const [timeWindow, setTimeWindow] = useState<number>(60000); // 1 minute in ms\n  const [performanceMetrics, setPerformanceMetrics] = useState<PerformanceMetrics>({\n    fps: [],\n    cpuTime: [],\n    memoryUsage: [],\n    domOperations: [],\n    renderTime: [],\n    layoutThrashing: [],\n    cacheHitRate: [],\n    animationSmoothness: [],\n  });\n  const [detectedIssues, setDetectedIssues] = useState<PerformanceIssue[]>([]);\n  const [selectedMetric, setSelectedMetric] = useState<keyof PerformanceMetrics>('fps');\n  const [activeAnimations, setActiveAnimations] = useState<string[]>([]);\n  const [frameBudget, setFrameBudget] = useState<number>(16.67); // 60fps by default\n\n  // Initialize monitoring\n  useEffect(() => {\n    // Get the list of active animations from the animation frame manager\n    updateActiveAnimations();\n\n    // Set up periodic polling for active animations\n    const animationPoller = setInterval(() => {\n      updateActiveAnimations();\n    }, 5000);\n\n    return () => {\n      clearInterval(animationPoller);\n      stopMonitoring();\n    };\n  }, []);\n\n  // Set up performance monitoring when an animation is selected\n  useEffect(() => {\n    if (isMonitoring && monitoredAnimation) {\n      startMonitoring(monitoredAnimation);\n    } else {\n      stopMonitoring();\n    }\n  }, [isMonitoring, monitoredAnimation]);\n\n  // Update charts when metrics or selected metric changes\n  useEffect(() => {\n    if (performanceMetrics[selectedMetric].length > 0) {\n      updateCharts();\n    }\n  }, [performanceMetrics, selectedMetric]);\n\n  // Get the list of active animations\n  const updateActiveAnimations = () => {\n    // In a real implementation, we would get this from the animation frame manager\n    // For now, we'll create a mock list\n    setActiveAnimations([\n      'network-visualization',\n      'time-series-chart',\n      'hierarchy-visualization',\n      'geo-visualization',\n      'unified-demo',\n      'batch-update-demo',\n    ]);\n  };\n\n  // Start monitoring a specific animation\n  const startMonitoring = (animationId: string) => {\n    if (!animationId) return;\n\n    console.warn(`Starting monitoring for animation: ${animationId}`);\n\n    // Reset metrics\n    setPerformanceMetrics({\n      fps: [],\n      cpuTime: [],\n      memoryUsage: [],\n      domOperations: [],\n      renderTime: [],\n      layoutThrashing: [],\n      cacheHitRate: [],\n      animationSmoothness: [],\n    });\n\n    setDetectedIssues([]);\n\n    // Register a special monitor animation that will collect performance data\n    animationFrameManager.registerAnimation(\n      {\n        id: 'performance-monitor',\n        name: 'Performance Monitor',\n        priority: 'low', // Low priority to avoid affecting the monitored animation\n        type: 'custom',\n        duration: 0, // Run indefinitely\n        loop: true,\n      },\n      (_elapsed, deltaTime, frameInfo) => {\n        collectPerformanceMetrics(deltaTime, frameInfo);\n        return false; // Never complete\n      }\n    );\n\n    // Start the monitoring animation\n    animationFrameManager.startAnimation('performance-monitor');\n  };\n\n  // Stop monitoring\n  const stopMonitoring = () => {\n    // Stop the monitoring animation\n    try {\n      animationFrameManager.pauseAnimation('performance-monitor');\n    } catch (e) {\n      // Animation might not exist yet\n    }\n  };\n\n  // Collect performance metrics on each frame\n  const collectPerformanceMetrics = (deltaTime: number, frameInfo: FrameInfo) => {\n    const now = Date.now();\n\n    // Update FPS metric\n    setPerformanceMetrics(prev => {\n      const newFps = [...prev.fps, { timestamp: now, value: frameInfo.currentFps }];\n\n      // Simulate other metrics for now\n      // In a real implementation, we would get these from the various systems\n      const newCpuTime = [\n        ...prev.cpuTime,\n        {\n          timestamp: now,\n          value: 10 + Math.random() * 10, // Random value between 10-20ms\n        },\n      ];\n\n      const newMemoryUsage = [\n        ...prev.memoryUsage,\n        {\n          timestamp: now,\n          value: 50 + Math.sin(now * 0.001) * 10, // Oscillating value to simulate GC\n        },\n      ];\n\n      const newDomOperations = [\n        ...prev.domOperations,\n        {\n          timestamp: now,\n          value: Math.floor(Math.random() * 50), // Random number of DOM operations\n        },\n      ];\n\n      const newRenderTime = [\n        ...prev.renderTime,\n        {\n          timestamp: now,\n          value: 5 + Math.random() * 10, // Random render time between 5-15ms\n        },\n      ];\n\n      const newLayoutThrashing = [\n        ...prev.layoutThrashing,\n        {\n          timestamp: now,\n          value: Math.random() > 0.9 ? Math.floor(Math.random() * 5) : 0, // Occasional layout thrashing\n        },\n      ];\n\n      const newCacheHitRate = [\n        ...prev.cacheHitRate,\n        {\n          timestamp: now,\n          value: 70 + Math.random() * 30, // Cache hit rate between 70-100%\n        },\n      ];\n\n      const newAnimationSmoothness = [\n        ...prev.animationSmoothness,\n        {\n          timestamp: now,\n          value: frameInfo.currentFps > 30 ? 100 : (frameInfo.currentFps / 30) * 100, // Smoothness score\n        },\n      ];\n\n      // Limit the number of data points based on time window\n      const cutoff = now - timeWindow;\n      const trimMetrics = (metrics: MetricPoint[]) =>\n        metrics.filter(point => point.timestamp >= cutoff);\n\n      // Detect potential performance issues\n      detectPerformanceIssues(\n        newFps[newFps.length - 1],\n        newCpuTime[newCpuTime.length - 1],\n        newLayoutThrashing[newLayoutThrashing.length - 1]\n      );\n\n      return {\n        fps: trimMetrics(newFps),\n        cpuTime: trimMetrics(newCpuTime),\n        memoryUsage: trimMetrics(newMemoryUsage),\n        domOperations: trimMetrics(newDomOperations),\n        renderTime: trimMetrics(newRenderTime),\n        layoutThrashing: trimMetrics(newLayoutThrashing),\n        cacheHitRate: trimMetrics(newCacheHitRate),\n        animationSmoothness: trimMetrics(newAnimationSmoothness),\n      };\n    });\n  };\n\n  // Detect performance issues based on metrics\n  const detectPerformanceIssues = (\n    fpsPoint: MetricPoint,\n    cpuPoint: MetricPoint,\n    layoutPoint: MetricPoint\n  ) => {\n    const now = Date.now();\n\n    // Check for frame drop\n    if (fpsPoint.value < 30) {\n      const severity =\n        fpsPoint.value < 10\n          ? 'critical'\n          : fpsPoint.value < 20\n            ? 'high'\n            : fpsPoint.value < 25\n              ? 'medium'\n              : 'low';\n\n      const newIssue: PerformanceIssue = {\n        id: `frame-drop-${now}`,\n        timestamp: now,\n        type: 'frame_drop',\n        severity,\n        description: `Low frame rate detected: ${Math.round(fpsPoint.value)} FPS`,\n        recommendation: 'Consider reducing animation complexity or enabling optimizations',\n        relatedMetrics: ['fps', 'cpuTime', 'renderTime'],\n      };\n\n      setDetectedIssues(prev => {\n        // Don't add too many similar issues\n        const recentSimilarIssue = prev.find(\n          issue => issue.type === newIssue.type && now - issue.timestamp < 5000\n        );\n\n        if (recentSimilarIssue) {\n          return prev;\n        }\n\n        return [...prev.slice(-19), newIssue]; // Keep most recent 20 issues\n      });\n    }\n\n    // Check for high CPU usage\n    if (cpuPoint.value > frameBudget) {\n      const overtime = cpuPoint.value - frameBudget;\n      const severity =\n        overtime > 10 ? 'critical' : overtime > 5 ? 'high' : overtime > 2 ? 'medium' : 'low';\n\n      const newIssue: PerformanceIssue = {\n        id: `high-cpu-${now}`,\n        timestamp: now,\n        type: 'high_cpu',\n        severity,\n        description: `High CPU time detected: ${Math.round(cpuPoint.value)}ms (budget: ${frameBudget}ms)`,\n        recommendation: 'Consider using memoization or reducing calculation complexity',\n        relatedMetrics: ['cpuTime', 'fps'],\n      };\n\n      setDetectedIssues(prev => {\n        // Don't add too many similar issues\n        const recentSimilarIssue = prev.find(\n          issue => issue.type === newIssue.type && now - issue.timestamp < 5000\n        );\n\n        if (recentSimilarIssue) {\n          return prev;\n        }\n\n        return [...prev.slice(-19), newIssue]; // Keep most recent 20 issues\n      });\n    }\n\n    // Check for layout thrashing\n    if (layoutPoint.value > 0) {\n      const severity =\n        layoutPoint.value > 3\n          ? 'critical'\n          : layoutPoint.value > 2\n            ? 'high'\n            : layoutPoint.value > 1\n              ? 'medium'\n              : 'low';\n\n      const newIssue: PerformanceIssue = {\n        id: `layout-thrashing-${now}`,\n        timestamp: now,\n        type: 'layout_thrashing',\n        severity,\n        description: `Layout thrashing detected: ${layoutPoint.value} reflows in a single frame`,\n        recommendation: 'Use batched updates to separate read and write operations',\n        relatedMetrics: ['layoutThrashing', 'renderTime', 'fps'],\n      };\n\n      setDetectedIssues(prev => {\n        // Don't add too many similar issues\n        const recentSimilarIssue = prev.find(\n          issue => issue.type === newIssue.type && now - issue.timestamp < 5000\n        );\n\n        if (recentSimilarIssue) {\n          return prev;\n        }\n\n        return [...prev.slice(-19), newIssue]; // Keep most recent 20 issues\n      });\n    }\n  };\n\n  // Update the charts based on current metrics\n  const updateCharts = () => {\n    // These will be implemented with actual D3 visualizations\n    updateFpsChart();\n    updateCpuChart();\n    updateMemoryChart();\n    updateTimelineChart();\n  };\n\n  // Update the FPS chart\n  const updateFpsChart = () => {\n    if (!fpsChartRef.current) return;\n\n    const svg = d3.select(fpsChartRef.current);\n    const data = performanceMetrics.fps;\n    if (data.length === 0) return;\n\n    // Clear previous chart\n    svg.selectAll('*').remove();\n\n    // Determine dimensions\n    const margin = { top: 10, right: 20, bottom: 30, left: 40 };\n    const chartWidth = svg.node()?.getBoundingClientRect().width ?? 300;\n    const chartHeight = svg.node()?.getBoundingClientRect().height ?? 200;\n    const width = chartWidth - margin.left - margin.right;\n    const height = chartHeight - margin.top - margin.bottom;\n\n    // Create chart group\n    const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);\n\n    // Determine time domain\n    const now = Date.now();\n    const xDomain = [now - timeWindow, now];\n\n    // Create scales\n    const x = d3.scaleTime().domain(xDomain).range([0, width]);\n\n    // Set y-domain based on FPS (0 to max, or at least 60)\n    const maxFps = Math.max(60, d3.max(data, d => d.value) ?? 60);\n    const y = d3\n      .scaleLinear()\n      .domain([0, maxFps * 1.1])\n      .range([height, 0]);\n\n    // Create line generator\n    const line = d3\n      .line<MetricPoint>()\n      .x(d => x(d.timestamp))\n      .y(d => y(d.value))\n      .curve(d3.curveMonotoneX);\n\n    // Add reference line for target FPS (60)\n    g.append('line')\n      .attr('x1', 0)\n      .attr('x2', width)\n      .attr('y1', y(60))\n      .attr('y2', y(60))\n      .attr('stroke', '#aaa')\n      .attr('stroke-dasharray', '3,3')\n      .attr('stroke-width', 1);\n\n    g.append('text')\n      .attr('x', width)\n      .attr('y', y(60) - 5)\n      .attr('text-anchor', 'end')\n      .attr('font-size', '10px')\n      .attr('fill', '#aaa')\n      .text('60 FPS');\n\n    // Add reference line for acceptable FPS (30)\n    g.append('line')\n      .attr('x1', 0)\n      .attr('x2', width)\n      .attr('y1', y(30))\n      .attr('y2', y(30))\n      .attr('stroke', '#ffa000')\n      .attr('stroke-dasharray', '3,3')\n      .attr('stroke-width', 1);\n\n    g.append('text')\n      .attr('x', width)\n      .attr('y', y(30) - 5)\n      .attr('text-anchor', 'end')\n      .attr('font-size', '10px')\n      .attr('fill', '#ffa000')\n      .text('30 FPS');\n\n    // Add problem area (< 30 FPS)\n    g.append('rect')\n      .attr('x', 0)\n      .attr('y', y(0))\n      .attr('width', width)\n      .attr('height', y(30) - y(0))\n      .attr('fill', 'rgba(244, 67, 54, 0.1)');\n\n    // Add axes\n    g.append('g')\n      .attr('transform', `translate(0,${height})`)\n      .call(\n        d3\n          .axisBottom(x)\n          .ticks(5)\n          .tickFormat(d => {\n            const date = new Date(d as number);\n            return date.getSeconds().toString();\n          })\n      )\n      .call(g => g.select('.domain').remove());\n\n    g.append('g')\n      .call(d3.axisLeft(y).ticks(5))\n      .call(g => g.select('.domain').remove());\n\n    // Add grid lines\n    g.append('g')\n      .attr('class', 'grid')\n      .attr('opacity', 0.1)\n      .call(\n        d3\n          .axisLeft(y)\n          .ticks(5)\n          .tickSize(-width)\n          .tickFormat(() => '')\n      );\n\n    // Add the line path\n    g.append('path')\n      .datum(data)\n      .attr('fill', 'none')\n      .attr('stroke', '#2196F3')\n      .attr('stroke-width', 2)\n      .attr('d', line);\n\n    // Add points for the most recent data\n    const recentData = data.slice(-5); // Last 5 points\n\n    g.selectAll('.data-point')\n      .data(recentData)\n      .enter()\n      .append('circle')\n      .attr('class', 'data-point')\n      .attr('cx', d => x(d.timestamp))\n      .attr('cy', d => y(d.value))\n      .attr('r', (d, i) => (i === recentData.length - 1 ? 4 : 2)) // Larger circle for most recent point\n      .attr('fill', d => {\n        if (d.value < 30) return '#f44336'; // Red\n        if (d.value < 60) return '#ffa000'; // Orange\n        return '#4CAF50'; // Green\n      });\n\n    // Add line for current FPS value\n    if (data.length > 0) {\n      const lastPoint = data[data.length - 1];\n\n      g.append('line')\n        .attr('x1', 0)\n        .attr('x2', width)\n        .attr('y1', y(lastPoint.value))\n        .attr('y2', y(lastPoint.value))\n        .attr('stroke', '#2196F3')\n        .attr('stroke-dasharray', '2,2')\n        .attr('stroke-width', 1);\n    }\n  };\n\n  // Update the CPU usage chart\n  const updateCpuChart = () => {\n    if (!cpuChartRef.current) return;\n\n    const svg = d3.select(cpuChartRef.current);\n    const data = performanceMetrics.cpuTime;\n    if (data.length === 0) return;\n\n    // Clear previous chart\n    svg.selectAll('*').remove();\n\n    // Determine dimensions\n    const margin = { top: 10, right: 20, bottom: 30, left: 40 };\n    const chartWidth = svg.node()?.getBoundingClientRect().width ?? 300;\n    const chartHeight = svg.node()?.getBoundingClientRect().height ?? 200;\n    const width = chartWidth - margin.left - margin.right;\n    const height = chartHeight - margin.top - margin.bottom;\n\n    // Create chart group\n    const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);\n\n    // Determine time domain\n    const now = Date.now();\n    const xDomain = [now - timeWindow, now];\n\n    // Create scales\n    const x = d3.scaleTime().domain(xDomain).range([0, width]);\n\n    // Set y-domain based on data (0 to max, or at least frameBudget*2)\n    const maxCpuTime = Math.max(frameBudget * 2, d3.max(data, d => d.value) ?? frameBudget * 2);\n    const y = d3\n      .scaleLinear()\n      .domain([0, maxCpuTime * 1.1])\n      .range([height, 0]);\n\n    // Create line generator\n    const line = d3\n      .line<MetricPoint>()\n      .x(d => x(d.timestamp))\n      .y(d => y(d.value))\n      .curve(d3.curveMonotoneX);\n\n    // Add budget reference line\n    g.append('line')\n      .attr('x1', 0)\n      .attr('x2', width)\n      .attr('y1', y(frameBudget))\n      .attr('y2', y(frameBudget))\n      .attr('stroke', '#ff9800')\n      .attr('stroke-dasharray', '3,3')\n      .attr('stroke-width', 1);\n\n    g.append('text')\n      .attr('x', width)\n      .attr('y', y(frameBudget) - 5)\n      .attr('text-anchor', 'end')\n      .attr('font-size', '10px')\n      .attr('fill', '#ff9800')\n      .text(`${frameBudget.toFixed(1)}ms`);\n\n    // Add problem area (> frameBudget)\n    g.append('rect')\n      .attr('x', 0)\n      .attr('y', 0)\n      .attr('width', width)\n      .attr('height', y(frameBudget))\n      .attr('fill', 'rgba(244, 67, 54, 0.1)');\n\n    // Add axes\n    g.append('g')\n      .attr('transform', `translate(0,${height})`)\n      .call(\n        d3\n          .axisBottom(x)\n          .ticks(5)\n          .tickFormat(d => {\n            const date = new Date(d as number);\n            return date.getSeconds().toString();\n          })\n      )\n      .call(g => g.select('.domain').remove());\n\n    g.append('g')\n      .call(d3.axisLeft(y).ticks(5))\n      .call(g => g.select('.domain').remove());\n\n    // Add grid lines\n    g.append('g')\n      .attr('class', 'grid')\n      .attr('opacity', 0.1)\n      .call(\n        d3\n          .axisLeft(y)\n          .ticks(5)\n          .tickSize(-width)\n          .tickFormat(() => '')\n      );\n\n    // Add the line path\n    g.append('path')\n      .datum(data)\n      .attr('fill', 'none')\n      .attr('stroke', '#ff5722')\n      .attr('stroke-width', 2)\n      .attr('d', line);\n\n    // Add points for the most recent data\n    const recentData = data.slice(-5); // Last 5 points\n\n    g.selectAll('.data-point')\n      .data(recentData)\n      .enter()\n      .append('circle')\n      .attr('class', 'data-point')\n      .attr('cx', d => x(d.timestamp))\n      .attr('cy', d => y(d.value))\n      .attr('r', (d, i) => (i === recentData.length - 1 ? 4 : 2)) // Larger circle for most recent point\n      .attr('fill', d => {\n        if (d.value > frameBudget * 1.5) return '#f44336'; // Red\n        if (d.value > frameBudget) return '#ffa000'; // Orange\n        return '#4CAF50'; // Green\n      });\n\n    // Add line for current CPU value\n    if (data.length > 0) {\n      const lastPoint = data[data.length - 1];\n\n      g.append('line')\n        .attr('x1', 0)\n        .attr('x2', width)\n        .attr('y1', y(lastPoint.value))\n        .attr('y2', y(lastPoint.value))\n        .attr('stroke', '#ff5722')\n        .attr('stroke-dasharray', '2,2')\n        .attr('stroke-width', 1);\n    }\n  };\n\n  // Update the memory usage chart\n  const updateMemoryChart = () => {\n    if (!memoryChartRef.current) return;\n\n    const svg = d3.select(memoryChartRef.current);\n    const data = performanceMetrics.memoryUsage;\n    if (data.length === 0) return;\n\n    // Clear previous chart\n    svg.selectAll('*').remove();\n\n    // Determine dimensions\n    const margin = { top: 10, right: 20, bottom: 30, left: 40 };\n    const chartWidth = svg.node()?.getBoundingClientRect().width ?? 300;\n    const chartHeight = svg.node()?.getBoundingClientRect().height ?? 200;\n    const width = chartWidth - margin.left - margin.right;\n    const height = chartHeight - margin.top - margin.bottom;\n\n    // Create chart group\n    const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);\n\n    // Determine time domain\n    const now = Date.now();\n    const xDomain = [now - timeWindow, now];\n\n    // Create scales\n    const x = d3.scaleTime().domain(xDomain).range([0, width]);\n\n    // Find min and max values for better visualization\n    const maxMemory = d3.max(data, d => d.value) ?? 100;\n    const minMemory = d3.min(data, d => d.value) ?? 0;\n    const padding = (maxMemory - minMemory) * 0.1; // 10% padding\n\n    // Use a more precise domain for better visualization\n    const y = d3\n      .scaleLinear()\n      .domain([Math.max(0, minMemory - padding), maxMemory + padding])\n      .range([height, 0]);\n\n    // Create line generator\n    const line = d3\n      .line<MetricPoint>()\n      .x(d => x(d.timestamp))\n      .y(d => y(d.value))\n      .curve(d3.curveMonotoneX);\n\n    // Create area generator for filled area under the line\n    const area = d3\n      .area<MetricPoint>()\n      .x(d => x(d.timestamp))\n      .y0(height)\n      .y1(d => y(d.value))\n      .curve(d3.curveMonotoneX);\n\n    // Add axes\n    g.append('g')\n      .attr('transform', `translate(0,${height})`)\n      .call(\n        d3\n          .axisBottom(x)\n          .ticks(5)\n          .tickFormat(d => {\n            const date = new Date(d as number);\n            return date.getSeconds().toString();\n          })\n      )\n      .call(g => g.select('.domain').remove());\n\n    g.append('g')\n      .call(d3.axisLeft(y).ticks(5))\n      .call(g => g.select('.domain').remove());\n\n    // Add grid lines\n    g.append('g')\n      .attr('class', 'grid')\n      .attr('opacity', 0.1)\n      .call(\n        d3\n          .axisLeft(y)\n          .ticks(5)\n          .tickSize(-width)\n          .tickFormat(() => '')\n      );\n\n    // Add the area\n    g.append('path').datum(data).attr('fill', 'rgba(76, 175, 80, 0.2)').attr('d', area);\n\n    // Add the line path\n    g.append('path')\n      .datum(data)\n      .attr('fill', 'none')\n      .attr('stroke', '#4CAF50')\n      .attr('stroke-width', 2)\n      .attr('d', line);\n\n    // Add points for the most recent data\n    const recentData = data.slice(-5); // Last 5 points\n\n    g.selectAll('.data-point')\n      .data(recentData)\n      .enter()\n      .append('circle')\n      .attr('class', 'data-point')\n      .attr('cx', d => x(d.timestamp))\n      .attr('cy', d => y(d.value))\n      .attr('r', (d, i) => (i === recentData.length - 1 ? 4 : 2)) // Larger circle for most recent point\n      .attr('fill', '#4CAF50');\n\n    // Add line for current memory value\n    if (data.length > 0) {\n      const lastPoint = data[data.length - 1];\n\n      g.append('line')\n        .attr('x1', 0)\n        .attr('x2', width)\n        .attr('y1', y(lastPoint.value))\n        .attr('y2', y(lastPoint.value))\n        .attr('stroke', '#4CAF50')\n        .attr('stroke-dasharray', '2,2')\n        .attr('stroke-width', 1);\n    }\n  };\n\n  // Update the timeline chart\n  const updateTimelineChart = () => {\n    if (!timelineChartRef.current) return;\n\n    const svg = d3.select(timelineChartRef.current);\n\n    // Clear previous chart\n    svg.selectAll('*').remove();\n\n    // Get data for the selected metric\n    const data = performanceMetrics[selectedMetric];\n    if (data.length === 0) return;\n\n    // Determine dimensions\n    const margin = { top: 10, right: 20, bottom: 30, left: 40 };\n    const chartWidth = svg.node()?.getBoundingClientRect().width ?? 600;\n    const chartHeight = svg.node()?.getBoundingClientRect().height ?? 100;\n    const width = chartWidth - margin.left - margin.right;\n    const height = chartHeight - margin.top - margin.bottom;\n\n    // Create chart group\n    const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);\n\n    // Determine time domain\n    const now = Date.now();\n    const xDomain = [now - timeWindow, now];\n\n    // Create scales\n    const x = d3.scaleTime().domain(xDomain).range([0, width]);\n\n    // Set y-domain based on the selected metric\n    let yDomain: [number, number];\n    let colorScale: d3.ScaleOrdinal<string, string>;\n\n    // Configure scales and thresholds based on metric type\n    let maxValue: number;\n    let minValue: number;\n    let padding: number;\n\n    switch (selectedMetric) {\n      case 'fps':\n        yDomain = [0, Math.max(60, d3.max(data, d => d.value) ?? 60) * 1.1];\n        colorScale = d3\n          .scaleOrdinal<string>()\n          .domain(['low', 'medium', 'high'])\n          .range(['#f44336', '#ffa000', '#4CAF50']);\n        break;\n\n      case 'cpuTime':\n        yDomain = [\n          0,\n          Math.max(frameBudget * 2, d3.max(data, d => d.value) ?? frameBudget * 2) * 1.1,\n        ];\n        colorScale = d3\n          .scaleOrdinal<string>()\n          .domain(['low', 'medium', 'high'])\n          .range(['#4CAF50', '#ffa000', '#f44336']);\n        break;\n\n      case 'layoutThrashing':\n        yDomain = [0, Math.max(5, d3.max(data, d => d.value) ?? 5) * 1.1];\n        colorScale = d3\n          .scaleOrdinal<string>()\n          .domain(['low', 'medium', 'high'])\n          .range(['#4CAF50', '#ffa000', '#f44336']);\n        break;\n\n      case 'cacheHitRate':\n        yDomain = [0, 100];\n        colorScale = d3\n          .scaleOrdinal<string>()\n          .domain(['low', 'medium', 'high'])\n          .range(['#f44336', '#ffa000', '#4CAF50']);\n        break;\n\n      case 'animationSmoothness':\n        yDomain = [0, 100];\n        colorScale = d3\n          .scaleOrdinal<string>()\n          .domain(['low', 'medium', 'high'])\n          .range(['#f44336', '#ffa000', '#4CAF50']);\n        break;\n\n      default:\n        // For other metrics, use the min/max of data with padding\n        maxValue = d3.max(data, d => d.value) ?? 100;\n        minValue = d3.min(data, d => d.value) ?? 0;\n        padding = (maxValue - minValue) * 0.1;\n        yDomain = [Math.max(0, minValue - padding), maxValue + padding];\n        colorScale = d3\n          .scaleOrdinal<string>()\n          .domain(['low', 'medium', 'high'])\n          .range(['#f44336', '#ffa000', '#4CAF50']);\n    }\n\n    const y = d3.scaleLinear().domain(yDomain).range([height, 0]);\n\n    // Create line generator\n    const line = d3\n      .line<MetricPoint>()\n      .x(d => x(d.timestamp))\n      .y(d => y(d.value))\n      .curve(d3.curveMonotoneX);\n\n    // Create area generator for filled area under the line\n    const area = d3\n      .area<MetricPoint>()\n      .x(d => x(d.timestamp))\n      .y0(height)\n      .y1(d => y(d.value))\n      .curve(d3.curveMonotoneX);\n\n    // Add reference lines based on metric type\n    if (selectedMetric === 'fps') {\n      // FPS reference lines\n      g.append('line')\n        .attr('x1', 0)\n        .attr('x2', width)\n        .attr('y1', y(60))\n        .attr('y2', y(60))\n        .attr('stroke', '#aaa')\n        .attr('stroke-dasharray', '3,3')\n        .attr('stroke-width', 1);\n\n      g.append('text')\n        .attr('x', 5)\n        .attr('y', y(60) - 5)\n        .attr('font-size', '10px')\n        .attr('fill', '#aaa')\n        .text('60 FPS');\n\n      g.append('line')\n        .attr('x1', 0)\n        .attr('x2', width)\n        .attr('y1', y(30))\n        .attr('y2', y(30))\n        .attr('stroke', '#ffa000')\n        .attr('stroke-dasharray', '3,3')\n        .attr('stroke-width', 1);\n\n      g.append('text')\n        .attr('x', 5)\n        .attr('y', y(30) - 5)\n        .attr('font-size', '10px')\n        .attr('fill', '#ffa000')\n        .text('30 FPS');\n    } else if (selectedMetric === 'cpuTime') {\n      // CPU time reference line\n      g.append('line')\n        .attr('x1', 0)\n        .attr('x2', width)\n        .attr('y1', y(frameBudget))\n        .attr('y2', y(frameBudget))\n        .attr('stroke', '#ff9800')\n        .attr('stroke-dasharray', '3,3')\n        .attr('stroke-width', 1);\n\n      g.append('text')\n        .attr('x', 5)\n        .attr('y', y(frameBudget) - 5)\n        .attr('font-size', '10px')\n        .attr('fill', '#ff9800')\n        .text(`${frameBudget.toFixed(1)}ms`);\n    }\n\n    // Add axes\n    g.append('g')\n      .attr('transform', `translate(0,${height})`)\n      .call(\n        d3\n          .axisBottom(x)\n          .ticks(10)\n          .tickFormat(d => {\n            const date = new Date(d as number);\n            return `${date.getMinutes()}:${date.getSeconds().toString().padStart(2, '0')}`;\n          })\n      )\n      .call(g => g.select('.domain').remove());\n\n    g.append('g')\n      .call(d3.axisLeft(y).ticks(5))\n      .call(g => g.select('.domain').remove());\n\n    // Add grid lines\n    g.append('g')\n      .attr('class', 'grid')\n      .attr('opacity', 0.1)\n      .call(\n        d3\n          .axisLeft(y)\n          .ticks(5)\n          .tickSize(-width)\n          .tickFormat(() => '')\n      );\n\n    // Add problem areas with colored backgrounds based on metric type\n    if (selectedMetric === 'fps') {\n      // Red area for FPS < 30\n      g.append('rect')\n        .attr('x', 0)\n        .attr('y', y(0))\n        .attr('width', width)\n        .attr('height', y(30) - y(0))\n        .attr('fill', 'rgba(244, 67, 54, 0.1)');\n\n      // Yellow area for 30 <= FPS < 60\n      g.append('rect')\n        .attr('x', 0)\n        .attr('y', y(30))\n        .attr('width', width)\n        .attr('height', y(60) - y(30))\n        .attr('fill', 'rgba(255, 160, 0, 0.1)');\n    } else if (selectedMetric === 'cpuTime') {\n      // Red area for CPU > frameBudget\n      g.append('rect')\n        .attr('x', 0)\n        .attr('y', 0)\n        .attr('width', width)\n        .attr('height', y(frameBudget))\n        .attr('fill', 'rgba(244, 67, 54, 0.1)');\n    }\n\n    // Plot detected issues on the timeline\n    const relatedIssues = detectedIssues.filter(issue =>\n      issue.relatedMetrics.includes(selectedMetric)\n    );\n\n    g.selectAll('.issue-marker')\n      .data(relatedIssues)\n      .enter()\n      .append('circle')\n      .attr('class', 'issue-marker')\n      .attr('cx', d => x(d.timestamp))\n      .attr('cy', 10) // Fixed position at the top\n      .attr('r', 5)\n      .attr('fill', d => getSeverityColor(d.severity))\n      .attr('stroke', '#fff')\n      .attr('stroke-width', 1)\n      .style('cursor', 'pointer')\n      .append('title')\n      .text(d => `${d.description} (${formatTimestamp(d.timestamp)})`);\n\n    // Add the area under the line\n    const areaColor =\n      selectedMetric === 'fps'\n        ? 'rgba(33, 150, 243, 0.2)'\n        : selectedMetric === 'cpuTime'\n          ? 'rgba(255, 87, 34, 0.2)'\n          : 'rgba(76, 175, 80, 0.2)';\n\n    g.append('path').datum(data).attr('fill', areaColor).attr('d', area);\n\n    // Add the line path with appropriate color\n    const lineColor =\n      selectedMetric === 'fps' ? '#2196F3' : selectedMetric === 'cpuTime' ? '#ff5722' : '#4CAF50';\n\n    g.append('path')\n      .datum(data)\n      .attr('fill', 'none')\n      .attr('stroke', lineColor)\n      .attr('stroke-width', 2)\n      .attr('d', line);\n\n    // Add points for the recent data\n    const recentData = data.slice(-10); // Last 10 points\n\n    g.selectAll('.data-point')\n      .data(recentData)\n      .enter()\n      .append('circle')\n      .attr('class', 'data-point')\n      .attr('cx', d => x(d.timestamp))\n      .attr('cy', d => y(d.value))\n      .attr('r', (d, i) => (i === recentData.length - 1 ? 4 : 2)) // Larger circle for most recent point\n      .attr('fill', d => {\n        // Color based on metric type and value\n        if (selectedMetric === 'fps') {\n          if (d.value < 30) return '#f44336'; // Red\n          if (d.value < 60) return '#ffa000'; // Orange\n          return '#4CAF50'; // Green\n        } else if (selectedMetric === 'cpuTime') {\n          if (d.value > frameBudget * 1.5) return '#f44336'; // Red\n          if (d.value > frameBudget) return '#ffa000'; // Orange\n          return '#4CAF50'; // Green\n        } else if (selectedMetric === 'cacheHitRate' || selectedMetric === 'animationSmoothness') {\n          if (d.value < 50) return '#f44336'; // Red\n          if (d.value < 80) return '#ffa000'; // Orange\n          return '#4CAF50'; // Green\n        }\n        return lineColor;\n      });\n\n    // Add a vertical line for the current time\n    g.append('line')\n      .attr('x1', x(now))\n      .attr('x2', x(now))\n      .attr('y1', 0)\n      .attr('y2', height)\n      .attr('stroke', '#757575')\n      .attr('stroke-width', 1)\n      .attr('stroke-dasharray', '5,3');\n\n    // Add tooltip interaction\n    const tooltip = d3\n      .select('body')\n      .append('div')\n      .attr('class', 'performance-tooltip')\n      .style('position', 'absolute')\n      .style('visibility', 'hidden')\n      .style('background', 'rgba(0, 0, 0, 0.8)')\n      .style('color', 'white')\n      .style('padding', '5px 10px')\n      .style('border-radius', '4px')\n      .style('font-size', '12px')\n      .style('pointer-events', 'none');\n\n    g.selectAll('.data-point')\n      .on('mouseover', function (event: MouseEvent, d: unknown) {\n        const dataPoint = d as MetricPoint;\n        tooltip.style('visibility', 'visible').html(`\n            <div>Time: ${formatTimestamp(dataPoint.timestamp)}</div>\n            <div>Value: ${dataPoint.value.toFixed(1)}</div>\n          `);\n      })\n      .on('mousemove', function (event: MouseEvent) {\n        tooltip.style('top', event.pageY - 10 + 'px').style('left', event.pageX + 10 + 'px');\n      })\n      .on('mouseout', function () {\n        tooltip.style('visibility', 'hidden');\n      });\n  };\n\n  // Handle animation selection\n  const handleAnimationSelect = (animationId: string) => {\n    setMonitoredAnimation(animationId);\n    setIsMonitoring(true);\n  };\n\n  // Handle time window change\n  const handleTimeWindowChange = (windowMs: number) => {\n    setTimeWindow(windowMs);\n  };\n\n  // Handle metric selection\n  const handleMetricSelect = (metric: keyof PerformanceMetrics) => {\n    setSelectedMetric(metric);\n  };\n\n  // Export performance data\n  const exportPerformanceData = () => {\n    const dataStr = JSON.stringify(performanceMetrics, null, 2);\n    const dataUri = `data:application/json;charset=utf-8,${encodeURIComponent(dataStr)}`;\n\n    const exportFileName = `performance-data-${new Date().toISOString()}.json`;\n\n    const linkElement = document.createElement('a');\n    linkElement.setAttribute('href', dataUri);\n    linkElement.setAttribute('download', exportFileName);\n    linkElement.click();\n  };\n\n  // Format timestamp for display\n  const formatTimestamp = (timestamp: number) => {\n    const date = new Date(timestamp);\n    return date.toLocaleTimeString();\n  };\n\n  // Get severity color\n  const getSeverityColor = (severity: PerformanceIssue['severity']) => {\n    switch (severity) {\n      case 'critical':\n        return '#d32f2f';\n      case 'high':\n        return '#f57c00';\n      case 'medium':\n        return '#ffa000';\n      case 'low':\n        return '#7cb342';\n      default:\n        return '#999';\n    }\n  };\n\n  return (\n    <div\n      className=\"performance-monitoring-dashboard\"\n      ref={containerRef}\n      style={{\n        width,\n        height,\n        fontFamily: 'Arial, sans-serif',\n        display: 'flex',\n        flexDirection: 'column',\n      }}\n    >\n      <div\n        className=\"dashboard-header\"\n        style={{\n          padding: '1rem',\n          backgroundColor: '#f5f5f5',\n          borderBottom: '1px solid #ddd',\n        }}\n      >\n        <h1 style={{ margin: 0, fontSize: '1.5rem' }}>Performance Monitoring Dashboard</h1>\n        <p>Real-time visualization performance metrics and analysis</p>\n\n        <div\n          className=\"dashboard-controls\"\n          style={{\n            display: 'flex',\n            gap: '1rem',\n            marginTop: '0.5rem',\n            flexWrap: 'wrap',\n          }}\n        >\n          <div>\n            <label htmlFor=\"animation-select\" style={{ marginRight: '0.5rem' }}>\n              Monitor Animation:\n            </label>\n            <select\n              id=\"animation-select\"\n              value={monitoredAnimation}\n              onChange={e => handleAnimationSelect(e.target.value)}\n              style={{ padding: '0.25rem' }}\n            >\n              <option value=\"\">Select Animation</option>\n              {activeAnimations.map(id => (\n                <option key={id} value={id}>\n                  {id}\n                </option>\n              ))}\n            </select>\n          </div>\n\n          <div>\n            <label htmlFor=\"time-window\" style={{ marginRight: '0.5rem' }}>\n              Time Window:\n            </label>\n            <select\n              id=\"time-window\"\n              value={timeWindow}\n              onChange={e => handleTimeWindowChange(parseInt(e.target.value))}\n              style={{ padding: '0.25rem' }}\n            >\n              <option value=\"10000\">10 seconds</option>\n              <option value=\"30000\">30 seconds</option>\n              <option value=\"60000\">1 minute</option>\n              <option value=\"300000\">5 minutes</option>\n            </select>\n          </div>\n\n          <div>\n            <label htmlFor=\"metric-select\" style={{ marginRight: '0.5rem' }}>\n              Primary Metric:\n            </label>\n            <select\n              id=\"metric-select\"\n              value={selectedMetric}\n              onChange={e => handleMetricSelect(e.target.value as keyof PerformanceMetrics)}\n              style={{ padding: '0.25rem' }}\n            >\n              <option value=\"fps\">FPS</option>\n              <option value=\"cpuTime\">CPU Time</option>\n              <option value=\"memoryUsage\">Memory Usage</option>\n              <option value=\"domOperations\">DOM Operations</option>\n              <option value=\"renderTime\">Render Time</option>\n              <option value=\"layoutThrashing\">Layout Thrashing</option>\n              <option value=\"cacheHitRate\">Cache Hit Rate</option>\n              <option value=\"animationSmoothness\">Animation Smoothness</option>\n            </select>\n          </div>\n\n          <button\n            onClick={() => setIsMonitoring(!isMonitoring)}\n            style={{\n              padding: '0.5rem 1rem',\n              backgroundColor: isMonitoring ? '#f44336' : '#4CAF50',\n              color: 'white',\n              border: 'none',\n              borderRadius: '4px',\n              cursor: 'pointer',\n            }}\n          >\n            {isMonitoring ? 'Stop Monitoring' : 'Start Monitoring'}\n          </button>\n\n          <button\n            onClick={exportPerformanceData}\n            style={{\n              padding: '0.5rem 1rem',\n              backgroundColor: '#2196F3',\n              color: 'white',\n              border: 'none',\n              borderRadius: '4px',\n              cursor: 'pointer',\n            }}\n            disabled={performanceMetrics.fps.length === 0}\n          >\n            Export Data\n          </button>\n        </div>\n      </div>\n\n      <div\n        className=\"dashboard-main\"\n        style={{\n          flex: 1,\n          display: 'grid',\n          gridTemplateColumns: '1fr 1fr',\n          gridTemplateRows: '1fr 1fr',\n          gap: '1rem',\n          padding: '1rem',\n          overflow: 'hidden',\n        }}\n      >\n        <div\n          className=\"metric-panel fps-panel\"\n          style={{\n            gridColumn: '1',\n            gridRow: '1',\n            backgroundColor: 'white',\n            boxShadow: '0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24)',\n            borderRadius: '4px',\n            padding: '1rem',\n            display: 'flex',\n            flexDirection: 'column',\n            overflow: 'hidden',\n          }}\n        >\n          <h2 style={{ margin: '0 0 0.5rem 0', fontSize: '1.2rem' }}>FPS</h2>\n          <div className=\"current-value\" style={{ fontSize: '2rem', fontWeight: 'bold' }}>\n            {performanceMetrics.fps.length > 0\n              ? Math.round(performanceMetrics.fps[performanceMetrics.fps.length - 1].value)\n              : '-'}\n          </div>\n          <div className=\"chart-container\" style={{ flex: 1, minHeight: 0 }}>\n            <svg ref={fpsChartRef} width=\"100%\" height=\"100%\"></svg>\n          </div>\n        </div>\n\n        <div\n          className=\"metric-panel cpu-panel\"\n          style={{\n            gridColumn: '2',\n            gridRow: '1',\n            backgroundColor: 'white',\n            boxShadow: '0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24)',\n            borderRadius: '4px',\n            padding: '1rem',\n            display: 'flex',\n            flexDirection: 'column',\n            overflow: 'hidden',\n          }}\n        >\n          <h2 style={{ margin: '0 0 0.5rem 0', fontSize: '1.2rem' }}>CPU Time (ms)</h2>\n          <div className=\"current-value\" style={{ fontSize: '2rem', fontWeight: 'bold' }}>\n            {performanceMetrics.cpuTime.length > 0\n              ? performanceMetrics.cpuTime[performanceMetrics.cpuTime.length - 1].value.toFixed(1)\n              : '-'}\n          </div>\n          <div className=\"chart-container\" style={{ flex: 1, minHeight: 0 }}>\n            <svg ref={cpuChartRef} width=\"100%\" height=\"100%\"></svg>\n          </div>\n        </div>\n\n        <div\n          className=\"metric-panel memory-panel\"\n          style={{\n            gridColumn: '1',\n            gridRow: '2',\n            backgroundColor: 'white',\n            boxShadow: '0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24)',\n            borderRadius: '4px',\n            padding: '1rem',\n            display: 'flex',\n            flexDirection: 'column',\n            overflow: 'hidden',\n          }}\n        >\n          <h2 style={{ margin: '0 0 0.5rem 0', fontSize: '1.2rem' }}>Memory Usage (MB)</h2>\n          <div className=\"current-value\" style={{ fontSize: '2rem', fontWeight: 'bold' }}>\n            {performanceMetrics.memoryUsage.length > 0\n              ? performanceMetrics.memoryUsage[\n                  performanceMetrics.memoryUsage.length - 1\n                ].value.toFixed(1)\n              : '-'}\n          </div>\n          <div className=\"chart-container\" style={{ flex: 1, minHeight: 0 }}>\n            <svg ref={memoryChartRef} width=\"100%\" height=\"100%\"></svg>\n          </div>\n        </div>\n\n        <div\n          className=\"issues-panel\"\n          style={{\n            gridColumn: '2',\n            gridRow: '2',\n            backgroundColor: 'white',\n            boxShadow: '0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24)',\n            borderRadius: '4px',\n            padding: '1rem',\n            overflow: 'auto',\n          }}\n        >\n          <h2 style={{ margin: '0 0 0.5rem 0', fontSize: '1.2rem' }}>Detected Issues</h2>\n\n          {detectedIssues.length > 0 ? (\n            <ul style={{ listStyle: 'none', padding: 0, margin: 0 }}>\n              {detectedIssues\n                .slice()\n                .reverse()\n                .map(issue => (\n                  <li\n                    key={issue.id}\n                    style={{\n                      padding: '0.5rem',\n                      borderLeft: `4px solid ${getSeverityColor(issue.severity)}`,\n                      marginBottom: '0.5rem',\n                      backgroundColor: '#f9f9f9',\n                    }}\n                  >\n                    <div\n                      style={{\n                        display: 'flex',\n                        justifyContent: 'space-between',\n                        marginBottom: '0.25rem',\n                      }}\n                    >\n                      <strong>\n                        {issue.type.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase())}\n                      </strong>\n                      <span style={{ color: '#666', fontSize: '0.8rem' }}>\n                        {formatTimestamp(issue.timestamp)}\n                      </span>\n                    </div>\n                    <div>{issue.description}</div>\n                    <div style={{ marginTop: '0.25rem', fontSize: '0.9rem', color: '#333' }}>\n                      Recommendation: {issue.recommendation}\n                    </div>\n                  </li>\n                ))}\n            </ul>\n          ) : (\n            <div style={{ color: '#666', fontStyle: 'italic' }}>\n              {isMonitoring ? 'No issues detected yet' : 'Start monitoring to detect issues'}\n            </div>\n          )}\n        </div>\n      </div>\n\n      <div\n        className=\"timeline-container\"\n        style={{\n          height: '150px',\n          backgroundColor: 'white',\n          boxShadow: '0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24)',\n          borderRadius: '4px',\n          margin: '0 1rem 1rem',\n          padding: '1rem',\n          overflow: 'hidden',\n        }}\n      >\n        <h2 style={{ margin: '0 0 0.5rem 0', fontSize: '1.2rem' }}>Performance Timeline</h2>\n        <div style={{ height: 'calc(100% - 2rem)' }}>\n          <svg ref={timelineChartRef} width=\"100%\" height=\"100%\"></svg>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default PerformanceMonitoringDashboard;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/status/StatusEffect.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/tech/TechVisualFeedback.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/tooltip-context.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/tooltip-context.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/visualization/AnimationTypeSafetyDemo.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'animationSequence' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 87,
        "column": 11,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 87,
        "endColumn": 28
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import * as d3 from 'd3';\nimport * as React from \"react\";\nimport { useEffect, useRef } from 'react';\nimport {\n  AnimationConfig,\n  createTypedTimer,\n  TypedAnimationSequence,\n  typedInterpolators,\n} from '../../../types/visualizations/D3AnimationTypes';\nimport { selectSvg } from '../../../types/visualizations/D3SelectionTypes';\n\ninterface Point {\n  x: number;\n  y: number;\n  radius: number;\n  color: string;\n}\n\ninterface AnimationTypeSafetyDemoProps {\n  width?: number;\n  height?: number;\n  animationConfig?: Partial<AnimationConfig>;\n}\n\n/**\n * Demo component showcasing the type-safe animation utilities\n *\n * This component demonstrates:\n * 1. Type-safe interpolation\n * 2. Type-safe transition configuration\n * 3. Type-safe timer usage\n * 4. Animation sequences with proper typing\n */\nconst AnimationTypeSafetyDemo: React.FC<AnimationTypeSafetyDemoProps> = ({\n  width = 600,\n  height = 400,\n  animationConfig = {},\n}) => {\n  const svgRef = useRef<SVGSVGElement>(null);\n  const config: AnimationConfig = {\n    duration: 1500,\n    easing: d3.easeCubicInOut,\n    loop: true,\n    loopDelay: 500,\n    ...animationConfig,\n  };\n\n  // Setup point data for animation\n  const pointsData: Point[] = [\n    { x: 100, y: 100, radius: 20, color: '#E63946' },\n    { x: 300, y: 150, radius: 30, color: '#457B9D' },\n    { x: 500, y: 200, radius: 25, color: '#2A9D8F' },\n    { x: 200, y: 250, radius: 35, color: '#F4A261' },\n    { x: 400, y: 300, radius: 15, color: '#6D597A' },\n  ];\n\n  // Animation point data targets (for interpolation)\n  const targetData: Point[] = [\n    { x: 150, y: 200, radius: 35, color: '#E76F51' },\n    { x: 250, y: 100, radius: 15, color: '#264653' },\n    { x: 350, y: 300, radius: 40, color: '#1D3557' },\n    { x: 450, y: 200, radius: 20, color: '#F1FAEE' },\n    { x: 200, y: 150, radius: 30, color: '#E9C46A' },\n  ];\n\n  useEffect(() => {\n    if (!svgRef.current) return;\n\n    // Clear any existing elements\n    d3.select(svgRef.current).selectAll('*').remove();\n\n    // Create SVG container with proper typing\n    const svg = selectSvg(`#animation-demo-svg`);\n\n    // Add circles for each data point\n    const circles = svg\n      .selectAll<SVGCircleElement, Point>('circle')\n      .data(pointsData)\n      .enter()\n      .append('circle')\n      .attr('cx', d => d.x)\n      .attr('cy', d => d.y)\n      .attr('r', d => d.radius)\n      .attr('fill', d => d.color);\n\n    // Setup animation sequence using type-safe utilities\n    const animationSequence = new TypedAnimationSequence({\n      transitions: [\n        {\n          selection: circles,\n          duration: config.duration,\n          easing: config.easing,\n          delay: (_, i) => i * 100, // Staggered delay based on index\n        },\n        {\n          selection: circles,\n          duration: config.duration,\n          easing: d3.easeElasticOut,\n        },\n      ],\n      sequenceDelay: 500,\n      loop: config.loop,\n    });\n\n    // Create object interpolators for each data point\n    const interpolators = pointsData.map((startPoint, index) => {\n      return {\n        position: typedInterpolators.object<Pick<Point, 'x' | 'y'>>(\n          { x: startPoint.x, y: startPoint.y },\n          { x: targetData[index].x, y: targetData[index].y }\n        ),\n        radius: typedInterpolators.number(startPoint.radius, targetData[index].radius),\n        color: typedInterpolators.color(startPoint.color, targetData[index].color),\n      };\n    });\n\n    // Create a type-safe timer for smooth animation\n    const timer = createTypedTimer({\n      callback: elapsed => {\n        // Calculate progress based on elapsed time (ping-pong effect)\n        const totalDuration = config.duration * 2;\n        const normalizedTime = (elapsed % totalDuration) / config.duration;\n        const t = normalizedTime <= 1 ? normalizedTime : 2 - normalizedTime;\n\n        // Update each circle with interpolated values\n        circles.each(function (d, i) {\n          const point = interpolators[i];\n          const interpolatedPosition = point.position(t);\n          const interpolatedRadius = point.radius(t);\n          const interpolatedColor = point.color(t);\n\n          d3.select(this)\n            .attr('cx', interpolatedPosition.x)\n            .attr('cy', interpolatedPosition.y)\n            .attr('r', interpolatedRadius)\n            .attr('fill', interpolatedColor);\n        });\n\n        // Continue animation if we're looping\n        return !config.loop && elapsed >= totalDuration;\n      },\n      duration: config.loop ? undefined : config.duration * 2,\n    });\n\n    // Add labels to show interpolation t value\n    const label = svg\n      .append('text')\n      .attr('x', width / 2)\n      .attr('y', 30)\n      .attr('text-anchor', 'middle')\n      .attr('font-size', '14px')\n      .attr('fill', '#333');\n\n    // Update label with current interpolation value\n    createTypedTimer({\n      callback: elapsed => {\n        const totalDuration = config.duration * 2;\n        const normalizedTime = (elapsed % totalDuration) / config.duration;\n        const t = normalizedTime <= 1 ? normalizedTime : 2 - normalizedTime;\n\n        label.text(`Interpolation t: ${t.toFixed(2)}`);\n        return false;\n      },\n    });\n\n    // Cleanup function\n    return () => {\n      timer.stop();\n    };\n  }, [width, height, config]);\n\n  return (\n    <div className=\"animation-type-safety-demo\">\n      <h3>Animation Type Safety Demo</h3>\n      <svg\n        id=\"animation-demo-svg\"\n        ref={svgRef}\n        width={width}\n        height={height}\n        style={{\n          border: '1px solid #ccc',\n          borderRadius: '4px',\n          background: '#f7f7f7',\n        }}\n      />\n      <div className=\"demo-description\">\n        <p>This demo showcases the type-safe animation utilities:</p>\n        <ul>\n          <li>Strong typing for interpolators (position, radius, color)</li>\n          <li>Type-safe timer configuration and transitions</li>\n          <li>Animation sequences with proper event handling</li>\n        </ul>\n      </div>\n    </div>\n  );\n};\n\nexport default AnimationTypeSafetyDemo;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/visualization/ChartCoordinationDemo.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'handleScatterBrush' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 103,
        "column": 9,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 103,
        "endColumn": 27
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import * as React from \"react\";\nimport { useState } from 'react';\nimport { useChartCoordination } from '../../../hooks/visualization/useChartCoordination';\nimport {\n  BrushState,\n  HighlightState,\n  ViewportState,\n} from '../../../lib/visualization/ChartCoordinationManager';\n\ninterface ChartCoordinationDemoProps {\n  width?: number;\n  height?: number;\n  className?: string;\n}\n\n/**\n * ChartCoordinationDemo\n *\n * A demo component that shows how multiple charts can be coordinated for:\n * - Synchronized zooming/panning\n * - Linked brushing\n * - Synchronized highlighting\n * - Shared color scales\n */\nexport const ChartCoordinationDemo: React.FC<ChartCoordinationDemoProps> = ({\n  width = 1200,\n  height = 800,\n  className = '',\n}) => {\n  // Sample data\n  const data = React.useMemo(() => {\n    const points = [];\n    for (let i = 0; i < 100; i++) {\n      points.push({\n        id: `point-${i}`,\n        x: Math.random() * 100,\n        y: Math.random() * 100,\n        category: Math.random() > 0.5 ? 'A' : 'B',\n        value: Math.random() * 100,\n      });\n    }\n    return points;\n  }, []);\n\n  // Chart states\n  const [scatterViewport, setScatterViewport] = useState<ViewportState>({\n    scale: 1,\n    translateX: 0,\n    translateY: 0,\n  });\n  const [scatterBrush, setScatterBrush] = useState<BrushState>({\n    active: false,\n    x1: 0,\n    y1: 0,\n    x2: 0,\n    y2: 0,\n  });\n  const [scatterHighlight, setScatterHighlight] = useState<HighlightState>({\n    active: false,\n    dataIds: [],\n  });\n\n  const [barViewport, setBarViewport] = useState<ViewportState>({\n    scale: 1,\n    translateX: 0,\n    translateY: 0,\n  });\n  const [barHighlight, setBarHighlight] = useState<HighlightState>({\n    active: false,\n    dataIds: [],\n  });\n\n  // Set up chart coordination\n  const scatterCoordination = useChartCoordination({\n    chartId: 'scatter-plot',\n    groupId: 'demo-group',\n    initialState: {\n      viewport: scatterViewport,\n      brush: scatterBrush,\n      highlight: scatterHighlight,\n    },\n    onViewportChange: setScatterViewport,\n    onBrushChange: setScatterBrush,\n    onHighlightChange: setScatterHighlight,\n  });\n\n  const barCoordination = useChartCoordination({\n    chartId: 'bar-chart',\n    groupId: 'demo-group',\n    initialState: {\n      viewport: barViewport,\n      highlight: barHighlight,\n    },\n    onViewportChange: setBarViewport,\n    onHighlightChange: setBarHighlight,\n  });\n\n  // Handle interactions\n  const handleScatterZoom = (scale: number, translateX: number, translateY: number) => {\n    scatterCoordination.updateViewport({ scale, translateX, translateY });\n  };\n\n  const handleScatterBrush = (x1: number, y1: number, x2: number, y2: number) => {\n    // Find points within brush\n    const selectedPoints = data.filter(\n      point =>\n        point.x >= Math.min(x1, x2) &&\n        point.x <= Math.max(x1, x2) &&\n        point.y >= Math.min(y1, y2) &&\n        point.y <= Math.max(y1, y2)\n    );\n\n    scatterCoordination.updateBrush({\n      active: true,\n      x1,\n      y1,\n      x2,\n      y2,\n    });\n\n    scatterCoordination.updateHighlight({\n      active: true,\n      dataIds: selectedPoints.map(p => p.id),\n    });\n  };\n\n  const handleBarHighlight = (category: string) => {\n    const selectedPoints = data.filter(point => point.category === category);\n\n    barCoordination.updateHighlight({\n      active: true,\n      dataIds: selectedPoints.map(p => p.id),\n      category,\n    });\n  };\n\n  return (\n    <div className={`chart-coordination-demo ${className}`}>\n      <div className=\"flex flex-col gap-4\">\n        <div className=\"flex gap-4\">\n          {/* Scatter Plot */}\n          <div className=\"flex-1 rounded-lg border p-4 shadow-sm\">\n            <h3 className=\"mb-2 text-lg font-bold\">Scatter Plot</h3>\n            <div\n              className=\"relative\"\n              style={{\n                width: width / 2 - 32,\n                height: height - 200,\n                transform: `scale(${scatterViewport.scale}) translate(${scatterViewport.translateX}px, ${scatterViewport.translateY}px)`,\n              }}\n            >\n              {/* Plot points */}\n              {data.map(point => (\n                <div\n                  key={point.id}\n                  className={`absolute h-3 w-3 rounded-full transition-opacity ${\n                    scatterHighlight.active && !scatterHighlight.dataIds.includes(point.id)\n                      ? 'opacity-20'\n                      : 'opacity-100'\n                  }`}\n                  style={{\n                    left: `${point.x}%`,\n                    top: `${point.y}%`,\n                    backgroundColor: point.category === 'A' ? '#3B82F6' : '#EF4444',\n                    transform: 'translate(-50%, -50%)',\n                  }}\n                />\n              ))}\n\n              {/* Brush overlay */}\n              {scatterBrush.active && (\n                <div\n                  className=\"absolute border-2 border-blue-500 bg-blue-500/10\"\n                  style={{\n                    left: `${Math.min(scatterBrush.x1, scatterBrush.x2)}%`,\n                    top: `${Math.min(scatterBrush.y1, scatterBrush.y2)}%`,\n                    width: `${Math.abs(scatterBrush.x2 - scatterBrush.x1)}%`,\n                    height: `${Math.abs(scatterBrush.y2 - scatterBrush.y1)}%`,\n                  }}\n                />\n              )}\n            </div>\n          </div>\n\n          {/* Bar Chart */}\n          <div className=\"flex-1 rounded-lg border p-4 shadow-sm\">\n            <h3 className=\"mb-2 text-lg font-bold\">Bar Chart</h3>\n            <div\n              className=\"relative\"\n              style={{\n                width: width / 2 - 32,\n                height: height - 200,\n                transform: `scale(${barViewport.scale}) translate(${barViewport.translateX}px, ${barViewport.translateY}px)`,\n              }}\n            >\n              {/* Category bars */}\n              {['A', 'B'].map(category => {\n                const categoryPoints = data.filter(p => p.category === category);\n                const average =\n                  categoryPoints.reduce((sum, p) => sum + p.value, 0) / categoryPoints.length;\n\n                return (\n                  <div\n                    key={category}\n                    className={`absolute bottom-0 w-32 transition-opacity ${\n                      barHighlight.active && barHighlight.category !== category\n                        ? 'opacity-20'\n                        : 'opacity-100'\n                    }`}\n                    style={{\n                      left: category === 'A' ? '30%' : '60%',\n                      height: `${average}%`,\n                      backgroundColor: category === 'A' ? '#3B82F6' : '#EF4444',\n                    }}\n                    onClick={() => handleBarHighlight(category)}\n                  >\n                    <div className=\"absolute -top-6 w-full text-center\">{category}</div>\n                  </div>\n                );\n              })}\n            </div>\n          </div>\n        </div>\n\n        <div className=\"rounded-lg border p-4 shadow-sm\">\n          <h3 className=\"mb-2 text-lg font-bold\">Controls</h3>\n          <div className=\"flex gap-4\">\n            <div>\n              <label className=\"block font-medium\">Zoom</label>\n              <input\n                type=\"range\"\n                min=\"0.5\"\n                max=\"2\"\n                step=\"0.1\"\n                value={scatterViewport.scale}\n                onChange={e => handleScatterZoom(parseFloat(e.target.value), 0, 0)}\n                className=\"w-48\"\n              />\n            </div>\n            <button\n              className=\"rounded bg-blue-500 px-4 py-2 text-white\"\n              onClick={() => {\n                scatterCoordination.updateBrush({\n                  active: false,\n                  x1: 0,\n                  y1: 0,\n                  x2: 0,\n                  y2: 0,\n                });\n                scatterCoordination.updateHighlight({\n                  active: false,\n                  dataIds: [],\n                });\n                barCoordination.updateHighlight({\n                  active: false,\n                  dataIds: [],\n                });\n              }}\n            >\n              Reset Selection\n            </button>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default ChartCoordinationDemo;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/visualization/CustomShaderDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/visualization/CustomShaderVisualization.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/visualization/DataHighlightDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/visualization/DataHighlightVisualization.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/visualization/DataTransitionParticleSystem.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'DataTransitionConfig' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 18,
        "column": 11,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 18,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'delay' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 134,
        "column": 13,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 134,
        "endColumn": 18
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'currentPosition' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 161,
        "column": 15,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 161,
        "endColumn": 30
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import * as React from \"react\";\nimport { useEffect, useRef, useState } from 'react';\nimport { useComponentLifecycle } from '../../../hooks/ui/useComponentLifecycle';\nimport { useComponentRegistration } from '../../../hooks/ui/useComponentRegistration';\nimport { ParticleSystemManager } from '../../../managers/effects/ParticleSystemManager';\nimport { Position } from '../../../types/core/Position';\nimport { ResourceType } from \"./../../../types/resources/ResourceTypes\";\n\nexport interface DataPoint {\n  id: string;\n  position: Position;\n  value: number;\n  resourceType?: ResourceType;\n  size?: number;\n  opacity?: number;\n}\n\ninterface DataTransitionConfig {\n  sourceData: DataPoint[];\n  targetData: DataPoint[];\n  duration?: number;\n  easing?: (t: number) => number;\n  staggerDelay?: number;\n  trailEffect?: boolean;\n  blendMode?: 'normal' | 'additive';\n  onTransitionComplete?: () => void;\n  onTransitionProgress?: (progress: number) => void;\n}\n\ninterface DataTransitionParticleSystemProps {\n  width: number;\n  height: number;\n  quality?: 'low' | 'medium' | 'high';\n  className?: string;\n  sourceData: DataPoint[];\n  targetData: DataPoint[];\n  onTransitionComplete?: () => void;\n  onTransitionProgress?: (progress: number) => void;\n  duration?: number;\n  easing?: (t: number) => number;\n  staggerDelay?: number;\n  trailEffect?: boolean;\n  blendMode?: 'normal' | 'additive';\n}\n\n/**\n * DataTransitionParticleSystem\n *\n * A specialized particle system for animating data transitions in visualizations.\n * Extends the base ParticleSystemManager with data-specific transition features.\n */\nexport const DataTransitionParticleSystem: React.FC<DataTransitionParticleSystemProps> = ({\n  width,\n  height,\n  quality = 'medium',\n  className = '',\n  sourceData,\n  targetData,\n  onTransitionComplete,\n  onTransitionProgress,\n  duration = 1000,\n  easing = t => t,\n  staggerDelay = 20,\n  trailEffect = false,\n  blendMode = 'additive',\n}) => {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const particleSystemRef = useRef<ParticleSystemManager | null>(null);\n  const [isInitialized, setIsInitialized] = useState(false);\n\n  // Register with component registry\n  useComponentRegistration({\n    type: 'DataTransitionParticleSystem',\n    eventSubscriptions: ['RESOURCE_UPDATED', 'RESOURCE_FLOW_UPDATED', 'RESOURCE_THRESHOLD_CHANGED'],\n    updatePriority: 'high',\n  });\n\n  // Initialize particle system\n  useEffect(() => {\n    if (!canvasRef.current || isInitialized) return;\n\n    particleSystemRef.current = ParticleSystemManager.getInstance();\n    setIsInitialized(true);\n\n    return () => {\n      if (particleSystemRef.current) {\n        particleSystemRef.current.cleanup();\n      }\n    };\n  }, [isInitialized]);\n\n  // Handle component lifecycle\n  useComponentLifecycle({\n    onMount: () => {\n      console.warn('DataTransitionParticleSystem mounted');\n    },\n    onUnmount: () => {\n      console.warn('DataTransitionParticleSystem unmounted');\n    },\n  });\n\n  // Start transition when data changes\n  useEffect(() => {\n    if (!particleSystemRef.current || !isInitialized) return;\n\n    // Create particle configuration\n    const particleConfig = {\n      maxParticles: Math.max(sourceData.length, targetData.length),\n      spawnRate: 0,\n      position: { x: 0, y: 0 },\n      spread: 0,\n      initialVelocity: {\n        min: { x: 0, y: 0 },\n        max: { x: 0, y: 0 },\n      },\n      acceleration: { x: 0, y: 0 },\n      size: {\n        min: 2,\n        max: 8,\n      },\n      life: {\n        min: duration,\n        max: duration,\n      },\n      color: '#ffffff',\n      blendMode: blendMode as 'normal' | 'additive',\n      quality,\n    };\n\n    // Create transition particles\n    sourceData.forEach((source, index) => {\n      const target = targetData[index] || targetData[targetData.length - 1];\n      const delay = index * staggerDelay;\n\n      particleSystemRef.current?.createParticleSystem(`transition-${index}`, {\n        ...particleConfig,\n        position: source.position,\n        color: getResourceColor(source.resourceType),\n        size: {\n          min: source.size || 2,\n          max: target.size || 8,\n        },\n      });\n    });\n\n    // Start animation loop\n    const startTime = performance.now();\n    let animationFrame: number;\n\n    const animate = () => {\n      const currentTime = performance.now();\n      const elapsed = currentTime - startTime;\n      const progress = Math.min(1, elapsed / duration);\n\n      // Update particle positions\n      sourceData.forEach((source, index) => {\n        const target = targetData[index] || targetData[targetData.length - 1];\n        const particleProgress = easing(progress);\n\n        const currentPosition = {\n          x: source.position.x + (target.position.x - source.position.x) * particleProgress,\n          y: source.position.y + (target.position.y - source.position.y) * particleProgress,\n        };\n\n        particleSystemRef.current?.update(1 / 60);\n      });\n\n      // Report progress\n      onTransitionProgress?.(progress);\n\n      // Continue animation or complete\n      if (progress < 1) {\n        animationFrame = requestAnimationFrame(animate);\n      } else {\n        onTransitionComplete?.();\n      }\n    };\n\n    animationFrame = requestAnimationFrame(animate);\n\n    // Cleanup function\n    return () => {\n      cancelAnimationFrame(animationFrame);\n      sourceData.forEach((_, index) => {\n        particleSystemRef.current?.removeSystem(`transition-${index}`);\n      });\n    };\n  }, [\n    sourceData,\n    targetData,\n    duration,\n    easing,\n    staggerDelay,\n    trailEffect,\n    blendMode,\n    quality,\n    onTransitionComplete,\n    onTransitionProgress,\n  ]);\n\n  return (\n    <div\n      ref={containerRef}\n      className={`data-transition-particle-system ${className}`}\n      style={{ width, height, position: 'relative' }}\n    >\n      <canvas\n        ref={canvasRef}\n        width={width}\n        height={height}\n        style={{\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          pointerEvents: 'none',\n        }}\n      />\n    </div>\n  );\n};\n\n// Helper function to get color for resource type\nconst getResourceColor = (resourceType?: ResourceType): string => {\n  if (!resourceType) return '#ffffff';\n\n  switch (resourceType) {\n    case ResourceType.MINERALS:\n      return '#4CAF50';\n    case ResourceType.ENERGY:\n      return '#FFC107';\n    case ResourceType.PLASMA:\n      return '#9C27B0';\n    case ResourceType.GAS:\n      return '#03A9F4';\n    case ResourceType.RESEARCH:\n      return '#3F51B5';\n    default:\n      return '#9E9E9E';\n  }\n};\n\nexport default DataTransitionParticleSystem;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/visualization/FlowDiagram.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'nodeMap' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 182,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 182,
        "endColumn": 10
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'isNodeReference' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 230,
        "column": 7,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 230,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'selectedNodeId' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 251,
        "column": 10,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 251,
        "endColumn": 24
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'selectedLinkId' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 252,
        "column": 10,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 252,
        "endColumn": 24
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'flowDataSchema' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 260,
        "column": 13,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 260,
        "endColumn": 27
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'nodeMap' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 408,
        "column": 27,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 408,
        "endColumn": 34
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 6,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import * as d3 from 'd3';\nimport * as React from \"react\";\nimport { useCallback, useEffect, useRef, useState } from 'react';\nimport {\n  d3Accessors,\n  SimulationLinkDatum,\n  SimulationNodeDatum,\n} from '../../../types/visualizations/D3Types';\nimport {\n  createD3ForceValidation,\n  ValidationTransformResult,\n} from '../../../types/visualizations/D3ValidationHooks';\nimport { Schema } from '../../../types/visualizations/D3Validators';\n\n/**\n * Represents a node in the flow diagram\n */\ninterface FlowDataNode {\n  id: string;\n  name: string;\n  type: 'source' | 'process' | 'destination';\n  value: number;\n  capacity?: number;\n  efficiency?: number;\n  description?: string;\n}\n\n/**\n * Represents a connection between two nodes in the flow diagram\n */\ninterface FlowDataLink {\n  id: string;\n  source: string;\n  target: string;\n  value: number;\n  maxCapacity?: number;\n  utilization?: number;\n  flowType?: string;\n  active: boolean;\n}\n\n/**\n * Represents the entire flow data structure\n */\ninterface FlowData {\n  nodes: FlowDataNode[];\n  links: FlowDataLink[];\n}\n\n/**\n * Node type for D3 force simulation with proper typing\n * Extends SimulationNodeDatum to ensure D3 compatibility\n */\ninterface FlowNode extends SimulationNodeDatum<FlowDataNode> {\n  id: string;\n  name: string;\n  type: 'source' | 'process' | 'destination';\n  value: number;\n  capacity?: number;\n  efficiency?: number;\n  description?: string;\n  color?: string;\n  radius?: number;\n  // Original data reference\n  data?: FlowDataNode;\n}\n\n/**\n * Link type for D3 force simulation with proper typing\n * Extends SimulationLinkDatum for D3 compatibility\n */\ninterface FlowLink extends SimulationLinkDatum<FlowNode> {\n  id: string;\n  source: string | FlowNode;\n  target: string | FlowNode;\n  value: number;\n  maxCapacity?: number;\n  utilization?: number;\n  flowType?: string;\n  active: boolean;\n  width?: number;\n  color?: string;\n}\n\n/**\n * Props for FlowDiagram component\n */\ninterface FlowDiagramProps {\n  /**\n   * Flow data to visualize\n   */\n  data: FlowData;\n\n  /**\n   * Width of the diagram in pixels\n   * @default 800\n   */\n  width?: number;\n\n  /**\n   * Height of the diagram in pixels\n   * @default 600\n   */\n  height?: number;\n\n  /**\n   * Whether the diagram supports interaction (dragging, zooming)\n   * @default true\n   */\n  interactive?: boolean;\n\n  /**\n   * Whether to animate transitions in the diagram\n   * @default true\n   */\n  animated?: boolean;\n\n  /**\n   * Callback when a node is clicked\n   */\n  onNodeClick?: (nodeId: string, nodeData: FlowDataNode) => void;\n\n  /**\n   * Callback when a link is clicked\n   */\n  onLinkClick?: (linkId: string, linkData: FlowDataLink) => void;\n\n  /**\n   * CSS class name for additional styling\n   */\n  className?: string;\n}\n\n/**\n * Convert data nodes to D3-compatible nodes with proper typing\n */\nconst convertNodesToD3Format = (nodes: FlowDataNode[]): FlowNode[] => {\n  return nodes.map(node => {\n    // Determine radius based on node value\n    const radius = Math.max(15, Math.min(40, 15 + (node.value / 100) * 25));\n\n    // Determine color based on node type\n    let color: string;\n    switch (node.type) {\n      case 'source':\n        color = '#06b6d4'; // cyan\n        break;\n      case 'process':\n        color = '#a855f7'; // purple\n        break;\n      case 'destination':\n        color = '#10b981'; // green\n        break;\n      default:\n        color = '#94a3b8'; // slate\n    }\n\n    // Create a properly typed node with no type assertions\n    const d3Node: FlowNode = {\n      id: node.id,\n      name: node.name,\n      type: node.type,\n      value: node.value,\n      capacity: node.capacity,\n      efficiency: node.efficiency,\n      description: node.description,\n      radius,\n      color,\n      // Store original data for reference\n      data: node,\n    };\n\n    return d3Node;\n  });\n};\n\n/**\n * Convert data links to D3-compatible links with proper typing\n */\nconst convertLinksToD3Format = (\n  links: FlowDataLink[],\n  nodeMap: Map<string, FlowNode>\n): FlowLink[] => {\n  return links.map(link => {\n    // Determine line width based on value and maxCapacity\n    const width = Math.max(1, Math.min(8, 1 + (link.value / 100) * 7));\n\n    // Determine color based on active state and utilization\n    let color: string;\n    if (!link.active) {\n      color = '#94a3b8'; // slate (inactive)\n    } else if (link.utilization && link.utilization > 0.8) {\n      color = '#ef4444'; // red (high utilization)\n    } else if (link.utilization && link.utilization > 0.5) {\n      color = '#f59e0b'; // amber (medium utilization)\n    } else {\n      color = '#3b82f6'; // blue (low utilization)\n    }\n\n    // Create a properly typed link with no type assertions\n    const d3Link: FlowLink = {\n      id: link.id,\n      source: link.source,\n      target: link.target,\n      value: link.value,\n      maxCapacity: link.maxCapacity,\n      utilization: link.utilization,\n      flowType: link.flowType,\n      active: link.active,\n      width,\n      color,\n    };\n\n    return d3Link;\n  });\n};\n\n/**\n * Find a node by ID in an array of nodes\n * Type-safe helper function\n */\nconst findNodeById = (nodes: FlowNode[], id: string): FlowNode | undefined => {\n  return nodes.find(node => node.id === id);\n};\n\n/**\n * Check if a node/link is a string or an object\n * Type guard function\n */\nconst isNodeReference = (obj: string | FlowNode): obj is FlowNode => {\n  return typeof obj !== 'string' && obj.id !== undefined;\n};\n\n/**\n * Component for visualizing flow data with type-safe D3 integration\n */\nconst FlowDiagram: React.FC<FlowDiagramProps> = ({\n  data,\n  width = 800,\n  height = 600,\n  interactive = true,\n  animated = true,\n  onNodeClick,\n  onLinkClick,\n  className = '',\n}) => {\n  const svgRef = useRef<SVGSVGElement | null>(null);\n  const simulationRef = useRef<d3.Simulation<FlowNode, FlowLink> | null>(null);\n\n  // State for tracking hover and selected nodes/links\n  const [selectedNodeId, setSelectedNodeId] = useState<string | null>(null);\n  const [selectedLinkId, setSelectedLinkId] = useState<string | null>(null);\n\n  /**\n   * Prepare visualization data with type safety\n   */\n  const prepareVisualizationData = useCallback(() => {\n    try {\n      // Define validation schemas\n      const flowDataSchema: Schema = {\n        name: 'FlowData',\n        description: 'Schema for flow data',\n        properties: {\n          nodes: {\n            type: 'array',\n            required: true,\n          },\n          links: {\n            type: 'array',\n            required: true,\n          },\n        },\n      };\n\n      // Create validation functions\n      const validation = createD3ForceValidation<FlowData, FlowNode, FlowLink>(\n        // Node transform function\n        inputData => convertNodesToD3Format(inputData.nodes),\n        // Link transform function\n        inputData =>\n          convertLinksToD3Format(\n            inputData.links,\n            new Map(convertNodesToD3Format(inputData.nodes).map(node => [node.id, node]))\n          ),\n        // Custom node schema properties\n        {\n          properties: {\n            id: {\n              type: 'string',\n              required: true,\n              validate: value => (value as string).length > 0 || 'Node ID cannot be empty',\n            },\n            type: {\n              type: 'string',\n              required: true,\n              enum: ['source', 'process', 'destination'],\n            },\n          },\n        },\n        // Custom link schema properties\n        {\n          properties: {\n            id: {\n              type: 'string',\n              required: true,\n            },\n            active: {\n              type: 'boolean',\n              required: true,\n            },\n          },\n        },\n        // Validation options\n        {\n          throwOnError: false,\n          logErrors: true,\n          errorPrefix: 'FlowDiagram Validation Error',\n        }\n      );\n\n      // Validate and transform data\n      const nodeResult: ValidationTransformResult<FlowNode[]> = validation.validateNodes(data);\n      const linkResult: ValidationTransformResult<FlowLink[]> = validation.validateLinks(data);\n\n      // Handle validation errors\n      if (!nodeResult.valid || !linkResult.valid) {\n        console.warn(\n          'Flow data validation failed:',\n          [...nodeResult.errors, ...linkResult.errors].join('\\n')\n        );\n      }\n\n      // Create a map for node lookups (using validated nodes)\n      const nodeMap = new Map<string, FlowNode>();\n      nodeResult.data.forEach(node => nodeMap.set(node.id, node));\n\n      return {\n        nodes: nodeResult.data,\n        links: linkResult.data,\n        nodeMap,\n        valid: nodeResult.valid && linkResult.valid,\n        errors: [...nodeResult.errors, ...linkResult.errors],\n      };\n    } catch (error) {\n      console.error('Error preparing visualization data:', error);\n      return {\n        nodes: [],\n        links: [],\n        nodeMap: new Map(),\n        valid: false,\n        errors: ['Error preparing visualization data'],\n      };\n    }\n  }, [data]);\n\n  /**\n   * Handle node click events with proper typing\n   */\n  const handleNodeClick = useCallback(\n    (event: React.MouseEvent, node: FlowNode) => {\n      setSelectedNodeId(prevId => (prevId === node.id ? null : node.id));\n\n      if (onNodeClick && node.data) {\n        onNodeClick(node.id, node.data);\n      }\n    },\n    [onNodeClick]\n  );\n\n  /**\n   * Handle link click events with proper typing\n   */\n  const handleLinkClick = useCallback(\n    (event: React.MouseEvent, link: FlowLink) => {\n      if (typeof link.source === 'string' || typeof link.target === 'string') {\n        return; // Ignore links that don't have resolved nodes\n      }\n\n      setSelectedLinkId(prevId => (prevId === link.id ? null : link.id));\n\n      // Find the original link data for the callback\n      const linkData = data.links.find(l => l.id === link.id);\n      if (onLinkClick && linkData) {\n        onLinkClick(link.id, linkData);\n      }\n    },\n    [data.links, onLinkClick]\n  );\n\n  /**\n   * Create and update the visualization\n   */\n  useEffect(() => {\n    if (!svgRef.current || !data) return;\n\n    // Clean up previous simulation if it exists\n    if (simulationRef.current) {\n      simulationRef.current.stop();\n    }\n\n    // Get SVG element with proper typing\n    const svg = d3.select<SVGSVGElement, unknown>(svgRef.current);\n\n    // Clear previous content\n    svg.selectAll('*').remove();\n\n    // Prepare data with type safety\n    const { nodes, links, nodeMap } = prepareVisualizationData();\n\n    // Create container group for zooming\n    const container = svg.append('g').attr('class', 'container');\n\n    // Add zoom behavior if interactive\n    if (interactive) {\n      const zoom = d3\n        .zoom<SVGSVGElement, unknown>()\n        .scaleExtent([0.1, 4])\n        .on('zoom', event => {\n          container.attr('transform', event.transform);\n        });\n\n      svg.call(zoom);\n    }\n\n    // Create arrow markers for links\n    const defs = container.append('defs');\n\n    // Create a basic arrow marker\n    defs\n      .append('marker')\n      .attr('id', 'arrowhead')\n      .attr('viewBox', '-10 -5 10 10')\n      .attr('refX', 0)\n      .attr('refY', 0)\n      .attr('orient', 'auto')\n      .attr('markerWidth', 8)\n      .attr('markerHeight', 8)\n      .append('path')\n      .attr('d', 'M-10,-5L0,0L-10,5')\n      .attr('fill', '#777');\n\n    // Create colored arrow markers\n    ['active', 'inactive', 'high', 'medium', 'low'].forEach(type => {\n      let color: string;\n      switch (type) {\n        case 'active':\n          color = '#3b82f6';\n          break;\n        case 'inactive':\n          color = '#94a3b8';\n          break;\n        case 'high':\n          color = '#ef4444';\n          break;\n        case 'medium':\n          color = '#f59e0b';\n          break;\n        case 'low':\n          color = '#10b981';\n          break;\n        default:\n          color = '#777';\n      }\n\n      defs\n        .append('marker')\n        .attr('id', `arrowhead-${type}`)\n        .attr('viewBox', '-10 -5 10 10')\n        .attr('refX', 0)\n        .attr('refY', 0)\n        .attr('orient', 'auto')\n        .attr('markerWidth', 8)\n        .attr('markerHeight', 8)\n        .append('path')\n        .attr('d', 'M-10,-5L0,0L-10,5')\n        .attr('fill', color);\n    });\n\n    // Create D3 force simulation with proper typing\n    const simulation = d3\n      .forceSimulation<FlowNode, FlowLink>(nodes)\n      .force(\n        'link',\n        d3\n          .forceLink<FlowNode, FlowLink>(links)\n          .id(d => d.id)\n          .distance(100)\n      )\n      .force('charge', d3.forceManyBody().strength(-200))\n      .force('center', d3.forceCenter(width / 2, height / 2))\n      .force(\n        'collision',\n        d3.forceCollide<FlowNode>().radius(d => (d.radius || 20) + 10)\n      );\n\n    // Store simulation reference for cleanup\n    simulationRef.current = simulation;\n\n    // Create links with proper typing\n    const link = container\n      .append('g')\n      .attr('class', 'links')\n      .selectAll<SVGLineElement, FlowLink>('line')\n      .data(links)\n      .enter()\n      .append('line')\n      .attr('class', d => `link ${d.active ? 'active' : 'inactive'}`)\n      .attr('stroke', d => d.color || '#999')\n      .attr('stroke-width', d => d.width || 1)\n      .attr('marker-end', d => {\n        // Determine marker based on link properties\n        if (!d.active) return 'url(#arrowhead-inactive)';\n        if (d.utilization && d.utilization > 0.8) return 'url(#arrowhead-high)';\n        if (d.utilization && d.utilization > 0.5) return 'url(#arrowhead-medium)';\n        return 'url(#arrowhead-active)';\n      })\n      .style('cursor', onLinkClick ? 'pointer' : 'default')\n      .on('click', function (event, d) {\n        if (onLinkClick) {\n          handleLinkClick(event, d);\n        }\n      });\n\n    // Create nodes with proper typing\n    const node = container\n      .append('g')\n      .attr('class', 'nodes')\n      .selectAll<SVGGElement, FlowNode>('g')\n      .data(nodes)\n      .enter()\n      .append('g')\n      .attr('class', 'node')\n      .style('cursor', onNodeClick ? 'pointer' : 'default')\n      .call(\n        d3\n          .drag<SVGGElement, FlowNode>()\n          .on('start', dragStarted)\n          .on('drag', dragged)\n          .on('end', dragEnded)\n      )\n      .on('click', function (event, d) {\n        if (onNodeClick) {\n          handleNodeClick(event, d);\n        }\n      });\n\n    // Add circles to nodes\n    node\n      .append('circle')\n      .attr('r', d => d.radius || 20)\n      .attr('fill', d => d.color || '#999')\n      .attr('stroke', '#fff')\n      .attr('stroke-width', 1.5);\n\n    // Add node labels\n    node\n      .append('text')\n      .attr('dy', '.3em')\n      .attr('text-anchor', 'middle')\n      .attr('font-size', '10px')\n      .attr('fill', '#fff')\n      .text(d => d.name);\n\n    // Add node value labels\n    node\n      .append('text')\n      .attr('dy', '1.6em')\n      .attr('text-anchor', 'middle')\n      .attr('font-size', '9px')\n      .attr('fill', '#fff')\n      .text(d => `${d.value}${d.capacity ? `/${d.capacity}` : ''}`);\n\n    // Add hover effects with type-safe accessors\n    node\n      .on('mouseover', function (event, d) {\n        d3.select(this)\n          .select('circle')\n          .transition()\n          .duration(200)\n          .attr('r', (d.radius || 20) * 1.1);\n      })\n      .on('mouseout', function (event, d) {\n        d3.select(this)\n          .select('circle')\n          .transition()\n          .duration(200)\n          .attr('r', d.radius || 20);\n      });\n\n    // Add flow effects to links\n    if (animated) {\n      link\n        .filter(d => d.active)\n        .each(function (d) {\n          const element = d3.select(this);\n\n          // Add animated dash array for active links\n          element\n            .attr('stroke-dasharray', '5,5')\n            .style('animation', `flowAnimation ${5000 / (d.value || 1)}ms linear infinite`);\n        });\n    }\n\n    // Update positions on simulation tick with proper typing\n    simulation.on('tick', () => {\n      // Update links with safe accessors to prevent type errors\n      link\n        .attr('x1', d => {\n          const source = typeof d.source === 'string' ? findNodeById(nodes, d.source) : d.source;\n          return source ? d3Accessors.getX(source) : 0;\n        })\n        .attr('y1', d => {\n          const source = typeof d.source === 'string' ? findNodeById(nodes, d.source) : d.source;\n          return source ? d3Accessors.getY(source) : 0;\n        })\n        .attr('x2', d => {\n          const target = typeof d.target === 'string' ? findNodeById(nodes, d.target) : d.target;\n          return target ? d3Accessors.getX(target) : 0;\n        })\n        .attr('y2', d => {\n          const target = typeof d.target === 'string' ? findNodeById(nodes, d.target) : d.target;\n          return target ? d3Accessors.getY(target) : 0;\n        });\n\n      // Update nodes with safe transforms\n      node.attr('transform', d => {\n        const x = d3Accessors.getX(d);\n        const y = d3Accessors.getY(d);\n        return `translate(${x}, ${y})`;\n      });\n    });\n\n    // Type-safe drag functions\n    function dragStarted(event: d3.D3DragEvent<SVGGElement, FlowNode, FlowNode>, d: FlowNode) {\n      if (!event.active) simulation.alphaTarget(0.3).restart();\n      d.fx = d3Accessors.getX(d);\n      d.fy = d3Accessors.getY(d);\n    }\n\n    function dragged(event: d3.D3DragEvent<SVGGElement, FlowNode, FlowNode>, d: FlowNode) {\n      d.fx = event.x;\n      d.fy = event.y;\n    }\n\n    function dragEnded(event: d3.D3DragEvent<SVGGElement, FlowNode, FlowNode>, d: FlowNode) {\n      if (!event.active) simulation.alphaTarget(0);\n      if (!interactive) {\n        d.fx = null;\n        d.fy = null;\n      }\n    }\n\n    // Cleanup function\n    return () => {\n      if (simulationRef.current) {\n        simulationRef.current.stop();\n      }\n    };\n  }, [\n    data,\n    width,\n    height,\n    interactive,\n    animated,\n    prepareVisualizationData,\n    handleNodeClick,\n    handleLinkClick,\n    onNodeClick,\n    onLinkClick,\n  ]);\n\n  return (\n    <div className={`flow-diagram-container ${className}`}>\n      {/* Add CSS for animation */}\n      {animated && (\n        <style>\n          {`\n            @keyframes flowAnimation {\n              from {\n                stroke-dashoffset: 20;\n              }\n              to {\n                stroke-dashoffset: 0;\n              }\n            }\n          `}\n        </style>\n      )}\n      <svg ref={svgRef} width={width} height={height} className=\"flow-diagram-svg\" />\n    </div>\n  );\n};\n\nexport default FlowDiagram;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/visualization/FlowDiagramDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/visualization/HeatMapDensityVisualization.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'canvasRef' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 97,
        "column": 9,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 97,
        "endColumn": 18
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import * as React from \"react\";\nimport { useMemo, useRef } from 'react';\nimport {\n  DataVisualizationShaderType,\n  ShaderUniform,\n} from '../../../lib/optimization/WebGLShaderManager';\nimport {\n  DataHighlightVisualization,\n  DataHighlightVisualizationProps,\n} from './DataHighlightVisualization';\n\n/**\n * Kernel density estimation method\n */\nexport enum KernelType {\n  GAUSSIAN = 'gaussian',\n  EPANECHNIKOV = 'epanechnikov',\n  UNIFORM = 'uniform',\n  TRIANGULAR = 'triangular',\n  COSINE = 'cosine',\n}\n\n/**\n * Enhanced props for heat map density visualization\n */\nexport interface HeatMapDensityVisualizationProps\n  extends Omit<DataHighlightVisualizationProps, 'visualizationType'> {\n  /**\n   * Bandwidth for kernel density estimation (affects smoothness)\n   * Higher values create smoother heatmaps with less detail\n   * Lower values create more detailed heatmaps but may introduce noise\n   */\n  bandwidth?: number;\n\n  /**\n   * Kernel type for density estimation\n   */\n  kernelType?: KernelType;\n\n  /**\n   * Number of interpolation steps between data points\n   * Higher values create smoother gradients but reduce performance\n   */\n  interpolationSteps?: number;\n\n  /**\n   * Range of the radius around each point where the heat spreads\n   * As a percentage of the visualization dimensions\n   */\n  heatRadius?: number;\n\n  /**\n   * Whether to use logarithmic scale for intensity\n   * Useful for datasets with high variance\n   */\n  useLogScale?: boolean;\n\n  /**\n   * Contour levels to show on the heatmap\n   * Values between 0 and 1 representing intensity thresholds\n   */\n  contourLevels?: number[];\n\n  /**\n   * Whether to show a grid overlay\n   */\n  showGrid?: boolean;\n\n  /**\n   * Grid cell size as a fraction of the visualization dimensions\n   */\n  gridSize?: number;\n}\n\n/**\n * HeatMapDensityVisualization Component\n *\n * A specialized component for rendering density-based heat maps using WebGL shaders.\n * Provides advanced configuration options for kernel density estimation and heat map rendering.\n */\nexport const HeatMapDensityVisualization: React.FC<HeatMapDensityVisualizationProps> = ({\n  data,\n  width,\n  height,\n  colors = ['#000080', '#0000ff', '#00ffff', '#ffff00', '#ff0000'],\n  bandwidth = 0.1,\n  kernelType = KernelType.GAUSSIAN,\n  interpolationSteps = 32,\n  heatRadius = 0.15,\n  useLogScale = false,\n  contourLevels = [],\n  showGrid = false,\n  gridSize = 0.05,\n  ...restProps\n}) => {\n  // Canvas ref for custom pre-rendering if needed\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n\n  // Process data for density visualization\n  const processedData = useMemo(() => {\n    // For basic usage, we can just return the data\n    // In a more advanced implementation, we might preprocess the data\n    // to optimize for density visualization\n    return data;\n  }, [data]);\n\n  // Prepare custom shader uniforms for the heat map visualization\n  const customUniforms = useMemo(() => {\n    const uniforms: Record<string, ShaderUniform> = {\n      u_bandwidth: {\n        type: 'float',\n        value: bandwidth,\n      },\n      u_heatRadius: {\n        type: 'float',\n        value: heatRadius,\n      },\n      u_interpolationSteps: {\n        type: 'float',\n        value: interpolationSteps,\n      },\n      u_useLogScale: {\n        type: 'int',\n        value: useLogScale ? 1 : 0,\n      },\n      u_kernelType: {\n        type: 'int',\n        value: Object.values(KernelType).indexOf(kernelType),\n      },\n      u_showGrid: {\n        type: 'int',\n        value: showGrid ? 1 : 0,\n      },\n      u_gridSize: {\n        type: 'float',\n        value: gridSize,\n      },\n    };\n\n    // Add contour levels if provided\n    if (contourLevels.length > 0) {\n      const levels = new Float32Array(Math.min(contourLevels.length, 10));\n      contourLevels.slice(0, 10).forEach((level, i) => {\n        levels[i] = level;\n      });\n\n      uniforms.u_contourLevels = {\n        type: 'float',\n        value: levels,\n      };\n\n      uniforms.u_contourLevelCount = {\n        type: 'int',\n        value: contourLevels.length,\n      };\n    }\n\n    return uniforms;\n  }, [\n    bandwidth,\n    heatRadius,\n    interpolationSteps,\n    useLogScale,\n    kernelType,\n    contourLevels,\n    showGrid,\n    gridSize,\n  ]);\n\n  // Custom fragment shader code for enhanced heat map rendering\n  const getCustomFragmentShader = (): string => {\n    return `\n      precision mediump float;\n      \n      uniform vec3 u_colors[5];\n      uniform int u_colorCount;\n      uniform float u_intensity;\n      uniform float u_time;\n      uniform vec2 u_highlightRange;\n      uniform float u_bandwidth;\n      uniform float u_heatRadius;\n      uniform float u_interpolationSteps;\n      uniform int u_useLogScale;\n      uniform int u_kernelType;\n      uniform int u_contourLevelCount;\n      uniform float u_contourLevels[10];\n      uniform int u_showGrid;\n      uniform float u_gridSize;\n      \n      varying float v_data;\n      varying vec2 v_position;\n      varying float v_time;\n      \n      // Helper function to interpolate colors\n      vec3 getColor(float value) {\n        if (u_colorCount == 1) return u_colors[0];\n        \n        float indexFloat = value * float(u_colorCount - 1);\n        int index = int(floor(indexFloat));\n        float t = fract(indexFloat);\n        \n        if (index >= u_colorCount - 1) {\n          return u_colors[u_colorCount - 1];\n        }\n        \n        return mix(u_colors[index], u_colors[index + 1], t);\n      }\n      \n      // Kernel functions for density estimation\n      float gaussianKernel(float distance, float bandwidth) {\n        float x = distance / bandwidth;\n        return exp(-0.5 * x * x);\n      }\n      \n      float epanechnikovKernel(float distance, float bandwidth) {\n        float x = distance / bandwidth;\n        if (abs(x) <= 1.0) {\n          return 0.75 * (1.0 - x * x);\n        }\n        return 0.0;\n      }\n      \n      float uniformKernel(float distance, float bandwidth) {\n        return distance <= bandwidth ? 1.0 : 0.0;\n      }\n      \n      float triangularKernel(float distance, float bandwidth) {\n        float x = distance / bandwidth;\n        return abs(x) <= 1.0 ? 1.0 - abs(x) : 0.0;\n      }\n      \n      float cosineKernel(float distance, float bandwidth) {\n        float x = distance / bandwidth;\n        return abs(x) <= 1.0 ? (cos(x * 3.14159) + 1.0) * 0.5 : 0.0;\n      }\n      \n      // Apply kernel based on type\n      float applyKernel(float distance, float bandwidth) {\n        if (u_kernelType == 0) {\n          return gaussianKernel(distance, bandwidth);\n        } else if (u_kernelType == 1) {\n          return epanechnikovKernel(distance, bandwidth);\n        } else if (u_kernelType == 2) {\n          return uniformKernel(distance, bandwidth);\n        } else if (u_kernelType == 3) {\n          return triangularKernel(distance, bandwidth);\n        } else if (u_kernelType == 4) {\n          return cosineKernel(distance, bandwidth);\n        }\n        return gaussianKernel(distance, bandwidth);\n      }\n      \n      // Draw grid lines\n      float drawGrid(vec2 position, float cellSize) {\n        vec2 grid = fract(position / cellSize);\n        float line = step(0.98, grid.x) + step(0.98, grid.y);\n        return min(line, 1.0) * 0.2;\n      }\n      \n      void main() {\n        // Get base color from data value\n        float dataValue = v_data;\n        \n        // Apply log scale if enabled\n        if (u_useLogScale == 1 && dataValue > 0.0) {\n          dataValue = log(1.0 + dataValue * 9.0) / log(10.0);\n        }\n        \n        // Get color based on data value\n        vec3 color = getColor(dataValue);\n        float alpha = u_intensity;\n        \n        // Adjust based on distance from center point\n        float dist = length(gl_PointCoord - vec2(0.5));\n        float heatValue = applyKernel(dist, u_bandwidth);\n        \n        // Fade out at edges\n        alpha *= heatValue;\n        \n        // Add contour lines if specified\n        if (u_contourLevelCount > 0) {\n          for (int i = 0; i < 10; i++) {\n            if (i >= u_contourLevelCount) break;\n            \n            float level = u_contourLevels[i];\n            float contourWidth = 0.02;\n            if (abs(dataValue - level) < contourWidth) {\n              color = mix(color, vec3(1.0), 0.5);\n              alpha = mix(alpha, 1.0, 0.5);\n            }\n          }\n        }\n        \n        // Apply highlight effect if in range\n        if (dataValue >= u_highlightRange.x && dataValue <= u_highlightRange.y) {\n          // Pulse effect\n          float pulse = 0.5 + 0.5 * sin(u_time * 3.0);\n          \n          // Brighten color and add glow\n          color = mix(color, vec3(1.0), pulse * 0.3);\n          alpha = mix(alpha, 1.0, pulse * 0.4);\n        }\n        \n        // Apply grid overlay if enabled\n        if (u_showGrid == 1) {\n          float gridOverlay = drawGrid(v_position, u_gridSize);\n          color = mix(color, vec3(1.0), gridOverlay);\n        }\n        \n        gl_FragColor = vec4(color, alpha);\n      }\n    `;\n  };\n\n  // Re-render whenever custom parameters change\n  const customShaderConfig = useMemo(\n    () => ({\n      customUniforms,\n      fragmentShader: getCustomFragmentShader(),\n    }),\n    [customUniforms]\n  );\n\n  return (\n    <DataHighlightVisualization\n      data={processedData}\n      width={width}\n      height={height}\n      visualizationType={DataVisualizationShaderType.HEATMAP}\n      colors={colors}\n      shaderConfig={customShaderConfig}\n      {...restProps}\n    />\n  );\n};\n\n// Preset configurations for common heat map use cases\nexport const HeatMapDensityPresets = {\n  /**\n   * Population density preset - optimized for showing clusters\n   */\n  populationDensity: (\n    props: Omit<HeatMapDensityVisualizationProps, 'kernelType' | 'colors' | 'bandwidth'>\n  ): HeatMapDensityVisualizationProps => ({\n    ...props,\n    kernelType: KernelType.GAUSSIAN,\n    colors: ['#f7fbff', '#deebf7', '#c6dbef', '#9ecae1', '#3182bd'],\n    bandwidth: 0.1,\n    heatRadius: 0.2,\n    useLogScale: true,\n  }),\n\n  /**\n   * Resource concentration preset - shows where resources are concentrated\n   */\n  resourceConcentration: (\n    props: Omit<HeatMapDensityVisualizationProps, 'kernelType' | 'colors' | 'bandwidth'>\n  ): HeatMapDensityVisualizationProps => ({\n    ...props,\n    kernelType: KernelType.EPANECHNIKOV,\n    colors: ['#ffffcc', '#c7e9b4', '#7fcdbb', '#41b6c4', '#225ea8'],\n    bandwidth: 0.08,\n    interpolationSteps: 64,\n    contourLevels: [0.2, 0.4, 0.6, 0.8],\n  }),\n\n  /**\n   * Anomaly detection preset - highlights outliers\n   */\n  anomalyDetection: (\n    props: Omit<HeatMapDensityVisualizationProps, 'kernelType' | 'colors' | 'bandwidth'>\n  ): HeatMapDensityVisualizationProps => ({\n    ...props,\n    kernelType: KernelType.GAUSSIAN,\n    colors: ['#f7f7f7', '#d9d9d9', '#bdbdbd', '#969696', '#525252'],\n    bandwidth: 0.05,\n    highlightRange: [0.9, 1.0],\n    useLogScale: false,\n    showGrid: true,\n    gridSize: 0.1,\n  }),\n\n  /**\n   * Performance analysis preset - visualizes performance metrics\n   */\n  performanceAnalysis: (\n    props: Omit<HeatMapDensityVisualizationProps, 'kernelType' | 'colors' | 'bandwidth'>\n  ): HeatMapDensityVisualizationProps => ({\n    ...props,\n    kernelType: KernelType.TRIANGULAR,\n    colors: ['#edf8e9', '#c7e9c0', '#a1d99b', '#74c476', '#238b45'],\n    bandwidth: 0.12,\n    interpolationSteps: 48,\n    contourLevels: [0.3, 0.6, 0.9],\n  }),\n\n  /**\n   * Time-series heat map preset - for temporal data analysis\n   */\n  timeSeriesAnalysis: (\n    props: Omit<HeatMapDensityVisualizationProps, 'kernelType' | 'colors' | 'bandwidth'>\n  ): HeatMapDensityVisualizationProps => ({\n    ...props,\n    kernelType: KernelType.COSINE,\n    colors: ['#f7fcf5', '#e5f5e0', '#c7e9c0', '#74c476', '#238b45'],\n    bandwidth: 0.1,\n    interpolationSteps: 32,\n    useLogScale: false,\n    animate: true,\n    animationSpeed: 0.8,\n  }),\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/visualization/ParticleTransitionVisualization.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/visualization/TemporalAnalysisView.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'isAnimating' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 153,
        "column": 10,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 153,
        "endColumn": 21
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'categoryScale' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 176,
        "column": 9,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 176,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'xAxis' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 198,
        "column": 11,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 198,
        "endColumn": 16
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'yAxis' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 214,
        "column": 11,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 214,
        "endColumn": 16
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'startTimestamp' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 412,
        "column": 13,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 412,
        "endColumn": 27
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'createNodeHoverHandler' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 458,
        "column": 9,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 458,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'value' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 461,
        "column": 13,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 461,
        "endColumn": 18
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'timestamp' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 462,
        "column": 13,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 462,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'category' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 463,
        "column": 13,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 463,
        "endColumn": 21
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 9,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import * as d3 from 'd3';\nimport * as React from 'react';\nimport { useEffect, useRef, useState } from 'react';\nimport { SimulationNodeDatum } from '../../../types/visualizations/D3Types';\n\n/**\n * Represents a data point in time series\n */\ninterface TimeDataPoint {\n  timestamp: Date;\n  value: number;\n  category: string;\n  id: string;\n}\n\n/**\n * Node type for time-based animations\n * Extends SimulationNodeDatum to ensure D3 type compatibility\n */\ninterface TimeNode extends SimulationNodeDatum<TimeDataPoint> {\n  timestamp: Date;\n  value: number;\n  category: string;\n  x?: number;\n  y?: number;\n  radius?: number;\n  color?: string;\n}\n\n/**\n * Configuration options for the animation and transition settings\n */\ninterface AnimationConfig {\n  /** Duration of transitions in milliseconds */\n  transitionDuration: number;\n  /** Easing function for transitions */\n  easing: (t: number) => number;\n  /** Delay between animations in milliseconds */\n  staggerDelay: number;\n  /** Whether to loop animations */\n  loop: boolean;\n}\n\n/**\n * Props for the TemporalAnalysisView component\n */\ninterface TemporalAnalysisViewProps {\n  /**\n   * Time series data to visualize\n   */\n  data: TimeDataPoint[];\n\n  /**\n   * Width of the visualization in pixels\n   * @default 800\n   */\n  width?: number;\n\n  /**\n   * Height of the visualization in pixels\n   * @default 500\n   */\n  height?: number;\n\n  /**\n   * Margin for the visualization\n   */\n  margin?: {\n    top: number;\n    right: number;\n    bottom: number;\n    left: number;\n  };\n\n  /**\n   * Whether to show time labels\n   * @default true\n   */\n  showLabels?: boolean;\n\n  /**\n   * Animation configuration\n   */\n  animationConfig?: Partial<AnimationConfig>;\n\n  /**\n   * CSS class name for additional styling\n   */\n  className?: string;\n}\n\n/**\n * Safely converts time data to D3-compatible format\n */\nconst convertToTimeNodes = (data: TimeDataPoint[]): TimeNode[] => {\n  return data.map(point => {\n    // Properly typed conversion with no type assertions\n    const node: TimeNode = {\n      id: point.id,\n      timestamp: point.timestamp,\n      value: point.value,\n      category: point.category,\n      // The original data field keeps the reference to the source data\n      data: point,\n    };\n\n    return node;\n  });\n};\n\n/**\n * Get color for a specific category\n */\nconst getCategoryColor = (category: string): string => {\n  // Color scale for different categories\n  const colorScale = d3.scaleOrdinal(d3.schemeCategory10);\n  return colorScale(category);\n};\n\n/**\n * Component for visualizing temporal data with smooth transitions\n */\nconst TemporalAnalysisView: React.FC<TemporalAnalysisViewProps> = ({\n  data,\n  width = 800,\n  height = 500,\n  margin = { top: 40, right: 40, bottom: 60, left: 60 },\n  showLabels = true,\n  animationConfig = {},\n  className = '',\n}) => {\n  const svgRef = useRef<SVGSVGElement | null>(null);\n\n  // Default animation config with sensible defaults\n  const defaultAnimationConfig: AnimationConfig = {\n    transitionDuration: 750,\n    easing: d3.easeCubicInOut,\n    staggerDelay: 50,\n    loop: false,\n  };\n\n  // Merge default config with provided config\n  const finalAnimationConfig: AnimationConfig = {\n    ...defaultAnimationConfig,\n    ...animationConfig,\n  };\n\n  // Chart dimensions\n  const chartWidth = width - margin.left - margin.right;\n  const chartHeight = height - margin.top - margin.bottom;\n\n  // Track animation state\n  const [isAnimating, setIsAnimating] = useState(false);\n  const [currentTimestamp, setCurrentTimestamp] = useState<Date | null>(null);\n\n  // Extract unique categories from data\n  const categories = Array.from(new Set(data.map(d => d.category)));\n\n  // Convert data to time nodes for visualization\n  const timeNodes = convertToTimeNodes(data);\n\n  // Extract time range from data\n  const timeExtent = d3.extent(data, d => d.timestamp) as [Date, Date];\n  const valueExtent = d3.extent(data, d => d.value) as [number, number];\n\n  // Set up time scale with proper typing\n  const timeScale = d3.scaleTime<number, number>().domain(timeExtent).range([0, chartWidth]);\n\n  // Set up value scale with proper typing\n  const valueScale = d3\n    .scaleLinear<number, number>()\n    .domain([Math.min(0, valueExtent[0]), valueExtent[1]])\n    .range([chartHeight, 0]);\n\n  // Set up category scale with proper typing\n  const categoryScale = d3\n    .scaleBand<string>()\n    .domain(categories)\n    .range([0, chartHeight])\n    .padding(0.1);\n\n  /**\n   * Initialize chart\n   */\n  useEffect(() => {\n    if (!svgRef.current || !data.length) return;\n\n    // Select SVG element with proper typing\n    const svg = d3.select<SVGSVGElement, unknown>(svgRef.current);\n\n    // Clear any existing elements\n    svg.selectAll('*').remove();\n\n    // Add chart group with margins\n    const chart = svg.append('g').attr('transform', `translate(${margin.left}, ${margin.top})`);\n\n    // Add X axis with proper typing\n    const xAxis = chart\n      .append('g')\n      .attr('class', 'x-axis')\n      .attr('transform', `translate(0, ${chartHeight})`)\n      .call(d3.axisBottom(timeScale));\n\n    // Add X axis label\n    chart\n      .append('text')\n      .attr('class', 'x-label')\n      .attr('text-anchor', 'middle')\n      .attr('x', chartWidth / 2)\n      .attr('y', chartHeight + 40)\n      .text('Time');\n\n    // Add Y axis with proper typing\n    const yAxis = chart.append('g').attr('class', 'y-axis').call(d3.axisLeft(valueScale));\n\n    // Add Y axis label\n    chart\n      .append('text')\n      .attr('class', 'y-label')\n      .attr('text-anchor', 'middle')\n      .attr('transform', 'rotate(-90)')\n      .attr('x', -chartHeight / 2)\n      .attr('y', -40)\n      .text('Value');\n\n    // Draw vertical gridlines\n    chart\n      .append('g')\n      .attr('class', 'grid x-grid')\n      .attr('transform', `translate(0, ${chartHeight})`)\n      .call(\n        d3\n          .axisBottom(timeScale)\n          .tickSize(-chartHeight)\n          .tickFormat(() => '')\n      );\n\n    // Draw horizontal gridlines\n    chart\n      .append('g')\n      .attr('class', 'grid y-grid')\n      .call(\n        d3\n          .axisLeft(valueScale)\n          .tickSize(-chartWidth)\n          .tickFormat(() => '')\n      );\n\n    // Add clip path to ensure points don't overflow\n    chart\n      .append('clipPath')\n      .attr('id', 'chart-area')\n      .append('rect')\n      .attr('width', chartWidth)\n      .attr('height', chartHeight);\n\n    // Create container for data points with clipping\n    const pointsContainer = chart\n      .append('g')\n      .attr('class', 'points-container')\n      .attr('clip-path', 'url(#chart-area)');\n\n    // Group data by category for visualization\n    const dataByCategory = d3.group(timeNodes, d => d.category);\n\n    // Add a line for each category with proper typing\n    dataByCategory.forEach((points, category) => {\n      // Sort points by timestamp for proper line drawing\n      const sortedPoints = [...points].sort(\n        (a, b) => a.timestamp.getTime() - b.timestamp.getTime()\n      );\n\n      // Line generator with type-safe accessors\n      const lineGenerator = d3\n        .line<TimeNode>()\n        .x(d => timeScale(d.timestamp))\n        .y(d => valueScale(d.value))\n        .curve(d3.curveMonotoneX);\n\n      // Add the line path with proper typing\n      pointsContainer\n        .append('path')\n        .attr('class', `line-${category}`)\n        .attr('fill', 'none')\n        .attr('stroke', getCategoryColor(category))\n        .attr('stroke-width', 2)\n        .attr('d', lineGenerator(sortedPoints));\n\n      // Add circles for each data point with proper typing\n      const circles = pointsContainer\n        .selectAll<SVGCircleElement, TimeNode>(`.point-${category}`)\n        .data(sortedPoints)\n        .enter()\n        .append('circle')\n        .attr('class', `point-${category}`)\n        .attr('cx', d => timeScale(d.timestamp))\n        .attr('cy', d => valueScale(d.value))\n        .attr('r', 0) // Start with radius 0 for entrance animation\n        .attr('fill', getCategoryColor(category))\n        .attr('stroke', '#fff')\n        .attr('stroke-width', 1);\n\n      // Add entrance animation with proper typing\n      circles\n        .transition()\n        .duration(finalAnimationConfig.transitionDuration)\n        .delay((_, i) => i * finalAnimationConfig.staggerDelay)\n        .ease(finalAnimationConfig.easing)\n        .attr('r', 5);\n\n      // Add labels if enabled\n      if (showLabels) {\n        pointsContainer\n          .selectAll<SVGTextElement, TimeNode>(`.label-${category}`)\n          .data(sortedPoints)\n          .enter()\n          .append('text')\n          .attr('class', `label-${category}`)\n          .attr('x', d => timeScale(d.timestamp))\n          .attr('y', d => valueScale(d.value) - 10)\n          .attr('text-anchor', 'middle')\n          .attr('font-size', '10px')\n          .attr('opacity', 0) // Start transparent for animation\n          .text(d => d.value.toFixed(1))\n          .transition()\n          .duration(finalAnimationConfig.transitionDuration)\n          .delay((_, i) => i * finalAnimationConfig.staggerDelay + 200)\n          .ease(finalAnimationConfig.easing)\n          .attr('opacity', 1);\n      }\n    });\n\n    // Add category legend with proper typing\n    const legend = chart\n      .append('g')\n      .attr('class', 'legend')\n      .attr('transform', `translate(${chartWidth - 100}, 0)`);\n\n    categories.forEach((category, i) => {\n      const legendItem = legend\n        .append('g')\n        .attr('class', `legend-item-${category}`)\n        .attr('transform', `translate(0, ${i * 20})`);\n\n      legendItem\n        .append('rect')\n        .attr('width', 15)\n        .attr('height', 15)\n        .attr('fill', getCategoryColor(category));\n\n      legendItem\n        .append('text')\n        .attr('x', 20)\n        .attr('y', 12)\n        .attr('font-size', '12px')\n        .text(category);\n    });\n\n    // Add time cursor for animation\n    const timeCursor = chart\n      .append('line')\n      .attr('class', 'time-cursor')\n      .attr('x1', 0)\n      .attr('y1', 0)\n      .attr('x2', 0)\n      .attr('y2', chartHeight)\n      .attr('stroke', '#666')\n      .attr('stroke-width', 1)\n      .attr('stroke-dasharray', '4,4')\n      .attr('opacity', 0);\n\n    // Add cursor timestamp label\n    const cursorLabel = chart\n      .append('text')\n      .attr('class', 'cursor-label')\n      .attr('text-anchor', 'middle')\n      .attr('font-size', '10px')\n      .attr('y', -10)\n      .attr('opacity', 0);\n\n    // Setup animation controls if needed\n    if (finalAnimationConfig.loop) {\n      setupAnimationLoop(chart, timeScale, timeCursor, cursorLabel);\n    }\n  }, [data, width, height, margin, showLabels, categories]);\n\n  /**\n   * Set up animation loop with type-safe transitions\n   */\n  const setupAnimationLoop = (\n    chart: d3.Selection<SVGGElement, unknown, null, undefined>,\n    timeScale: d3.ScaleTime<number, number>,\n    timeCursor: d3.Selection<SVGLineElement, unknown, null, undefined>,\n    cursorLabel: d3.Selection<SVGTextElement, unknown, null, undefined>\n  ) => {\n    setIsAnimating(true);\n\n    // Start and end timestamps\n    const startTime = timeExtent[0];\n    const endTime = timeExtent[1];\n    const duration = finalAnimationConfig.transitionDuration * 5;\n\n    // Animation function with proper typing\n    const animateTimeCursor = () => {\n      // Type-safe transition\n      timeCursor\n        .attr('opacity', 1)\n        .attr('x1', timeScale(startTime))\n        .attr('x2', timeScale(startTime));\n\n      // Create a custom timer for smoother animation with proper type safety\n      const startTimestamp = Date.now();\n      const timerDuration = duration;\n\n      // Use d3.timer for precise animation control with proper typing\n      const timer = d3.timer(elapsed => {\n        // Calculate progress (0 to 1)\n        const progress = Math.min(elapsed / timerDuration, 1);\n\n        // Interpolate the current timestamp\n        const currentTime = new Date(\n          startTime.getTime() + progress * (endTime.getTime() - startTime.getTime())\n        );\n\n        // Update cursor position with type-safe accessors\n        timeCursor.attr('x1', timeScale(currentTime)).attr('x2', timeScale(currentTime));\n\n        // Update cursor label with safe string formatting\n        cursorLabel\n          .attr('opacity', 1)\n          .attr('x', timeScale(currentTime))\n          .text(d3.timeFormat('%b %d, %Y')(currentTime));\n\n        // Update React state with proper typing\n        setCurrentTimestamp(currentTime);\n\n        // Stop timer when complete\n        if (progress === 1) {\n          timer.stop();\n\n          // If looping is enabled, restart after delay\n          if (finalAnimationConfig.loop) {\n            setTimeout(animateTimeCursor, 1000);\n          } else {\n            setIsAnimating(false);\n          }\n        }\n      });\n    };\n\n    // Start the animation\n    animateTimeCursor();\n  };\n\n  /**\n   * Creates a type-safe function to handle hover effects on nodes\n   */\n  const createNodeHoverHandler = () => {\n    return (event: React.MouseEvent<SVGCircleElement, MouseEvent>, node: TimeNode) => {\n      // Type-safe accessing of node data\n      const value = node.value;\n      const timestamp = node.timestamp;\n      const category = node.category;\n\n      // Safe D3 selection\n      const circle = d3.select<SVGCircleElement, TimeNode>(event.currentTarget);\n\n      // Type-safe transition\n      circle.transition().duration(200).attr('r', 8).attr('stroke-width', 2);\n    };\n  };\n\n  return (\n    <div className={`temporal-analysis-container ${className}`}>\n      <svg ref={svgRef} width={width} height={height} className=\"temporal-analysis-svg\" />\n\n      {currentTimestamp && (\n        <div className=\"current-time-display\">\n          Current Time: {currentTimestamp.toLocaleString()}\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default TemporalAnalysisView;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/visualization/TypeSafeVisualizationDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/visualization/errors/D3VisualizationErrorBoundary.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/visualization/errors/ErrorBoundaryDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/visualization/errors/VisualizationErrorBoundaries.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/visualization/AnomalyVisualization.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/weapons/WeaponComponents.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/weapons/WeaponControl.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/weapons/WeaponLoadout.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/weapons/WeaponSpecialization.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/weapons/WeaponSystem.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/weapons/WeaponUpgradeSystem.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/config/OfficerConfig.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/config/ShipBlueprints.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/config/automation/colonyRules.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/config/automation/combatRules.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/config/automation/explorationRules.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/config/automation/hangarRules.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/config/automation/miningRules.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/config/buildings/defaultBuildings.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/config/combat/combatConfig.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/config/combat/weaponConfig.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/config/factions.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/config/factions/factionConfig.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/config/factions/factions.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/config/game/gameConfig.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/config/modules/defaultModuleConfigs.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/config/modules/upgradePathsConfig.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/config/resource/ResourceConfig.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/config/ships/equatorHorizonShips.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/config/ships/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/config/ships/lostNovaShips.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/config/ships/shipStats.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/config/ships/spaceRatsShips.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/contexts/ClassificationContext.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/contexts/DataAnalysisContext.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'asEventType' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 340,
        "column": 11,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 340,
        "endColumn": 22
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import * as React from 'react';\nimport {\n  createContext,\n  ReactNode,\n  useCallback,\n  useContext,\n  useEffect,\n  useRef,\n  useState,\n} from 'react';\nimport { v4 as uuidv4 } from 'uuid';\nimport {\n  Anomaly,\n  EXPLORATION_EVENTS,\n  explorationManager,\n  Sector,\n} from '../managers/exploration/ExplorationManager';\nimport { AnalysisAlgorithmService } from '../services/AnalysisAlgorithmService';\nimport { DataCollectionService } from '../services/DataCollectionService';\nimport { DataProcessingService } from '../services/DataProcessingService';\nimport { BaseEvent, EventType } from '../types/events/EventTypes';\nimport {\n  AnalysisConfig,\n  AnalysisResult,\n  DataAnalysisContextType,\n  DataPoint,\n  Dataset,\n  ResourceData,\n} from '../types/exploration/DataAnalysisTypes';\n\n// Create the context with a default undefined value\nconst DataAnalysisContext = createContext<DataAnalysisContextType | undefined>(undefined);\n\n// Props for the DataAnalysisProvider component\ninterface DataAnalysisProviderProps {\n  children: ReactNode;\n  initialDatasets?: Dataset[];\n  initialAnalysisConfigs?: AnalysisConfig[];\n  initialAnalysisResults?: AnalysisResult[];\n}\n\n/**\n * Provider component for the DataAnalysisContext\n */\nexport const DataAnalysisProvider: React.FC<DataAnalysisProviderProps> = ({\n  children,\n  initialDatasets = [],\n  initialAnalysisConfigs = [],\n  initialAnalysisResults = [],\n}) => {\n  // State for datasets, analysis configurations, and results\n  const [datasets, setDatasets] = useState<Dataset[]>(initialDatasets);\n  const [analysisConfigs, setAnalysisConfigs] = useState<AnalysisConfig[]>(initialAnalysisConfigs);\n  const [analysisResults, setAnalysisResults] = useState<AnalysisResult[]>(initialAnalysisResults);\n  const [_isProcessingData, setIsProcessingData] = useState<boolean>(false);\n\n  // Create references to the services for persistence across renders\n  const dataCollectionServiceRef = useRef<DataCollectionService | null>(null);\n  const analysisAlgorithmServiceRef = useRef<AnalysisAlgorithmService | null>(null);\n  const dataProcessingServiceRef = useRef<DataProcessingService | null>(null);\n\n  // Initialize services\n  useEffect(() => {\n    if (explorationManager) {\n      // Initialize data collection service\n      const dataCollectionService = new DataCollectionService(explorationManager);\n      dataCollectionServiceRef.current = dataCollectionService;\n\n      // Initialize analysis algorithm service\n      const analysisAlgorithmService = new AnalysisAlgorithmService();\n      analysisAlgorithmServiceRef.current = analysisAlgorithmService;\n\n      // Initialize data processing service for web worker operations\n      const dataProcessingService = new DataProcessingService();\n      dataProcessingServiceRef.current = dataProcessingService;\n\n      // Initialize the data collection service\n      dataCollectionService.initialize();\n\n      // Set up callback for data updates\n      dataCollectionService.setOnDataUpdated((type, dataPoint) => {\n        // Map the DataCollectionService type to the context type\n        const sourceMap: Record<string, 'sectors' | 'anomalies' | 'resources' | 'mixed'> = {\n          sector: 'sectors',\n          anomaly: 'anomalies',\n          resource: 'resources',\n        };\n        const mappedType = sourceMap[type] || 'mixed';\n\n        // When a new data point is collected, add it to the appropriate dataset\n        const datasetId = getOrCreateDatasetBySource(mappedType);\n        if (datasetId) {\n          addDataPointToDataset(datasetId, dataPoint);\n        }\n      });\n\n      // Return cleanup function\n      return () => {\n        if (dataCollectionService) {\n          dataCollectionService.dispose();\n        }\n      };\n    }\n  }, [explorationManager]);\n\n  // Create a new dataset\n  const createDataset = useCallback(\n    (dataset: Omit<Dataset, 'id' | 'createdAt' | 'updatedAt'>): string => {\n      const id = uuidv4();\n      const now = Date.now();\n      const newDataset: Dataset = {\n        ...dataset,\n        id,\n        createdAt: now,\n        updatedAt: now,\n      };\n      setDatasets(prev => [...prev, newDataset]);\n      return id;\n    },\n    []\n  );\n\n  // Update an existing dataset\n  const updateDataset = useCallback(\n    (id: string, updates: Partial<Omit<Dataset, 'id' | 'createdAt' | 'updatedAt'>>): void => {\n      setDatasets(prev =>\n        prev.map(dataset => {\n          if (dataset.id === id) {\n            return {\n              ...dataset,\n              ...updates,\n              updatedAt: Date.now(),\n            };\n          }\n          return dataset;\n        })\n      );\n    },\n    []\n  );\n\n  // Delete a dataset\n  const deleteDataset = useCallback((id: string): void => {\n    setDatasets(prev => prev.filter(dataset => dataset.id !== id));\n    // Also delete any analysis configs that use this dataset\n    setAnalysisConfigs(prev => prev.filter(config => config.datasetId !== id));\n  }, []);\n\n  // Get a dataset by ID\n  const getDatasetById = useCallback(\n    (id: string): Dataset | undefined => {\n      return datasets.find(dataset => dataset.id === id);\n    },\n    [datasets]\n  );\n\n  // Create a new analysis configuration\n  const createAnalysisConfig = useCallback(\n    (config: Omit<AnalysisConfig, 'id' | 'createdAt' | 'updatedAt'>): string => {\n      const id = uuidv4();\n      const now = Date.now();\n      const newConfig: AnalysisConfig = {\n        ...config,\n        id,\n        createdAt: now,\n        updatedAt: now,\n      };\n      setAnalysisConfigs(prev => [...prev, newConfig]);\n      return id;\n    },\n    []\n  );\n\n  // Add a data point to a dataset\n  const addDataPointToDataset = useCallback((datasetId: string, dataPoint: DataPoint): void => {\n    setDatasets(prev =>\n      prev.map(dataset => {\n        if (dataset.id === datasetId) {\n          // Check if the data point already exists\n          const exists = dataset.dataPoints.some(dp => dp.id === dataPoint.id);\n          if (exists) return dataset;\n\n          return {\n            ...dataset,\n            dataPoints: [...dataset.dataPoints, dataPoint],\n            updatedAt: Date.now(),\n          };\n        }\n        return dataset;\n      })\n    );\n  }, []);\n\n  // Add multiple data points to a dataset at once - efficient batching\n  const addDataPointsToDataset = useCallback((datasetId: string, dataPoints: DataPoint[]): void => {\n    setDatasets(prev =>\n      prev.map(dataset => {\n        if (dataset.id === datasetId) {\n          // Filter out data points that already exist\n          const existingIds = new Set(dataset.dataPoints.map(dp => dp.id));\n          const newDataPoints = dataPoints.filter(dp => !existingIds.has(dp.id));\n\n          if (newDataPoints.length === 0) return dataset;\n\n          return {\n            ...dataset,\n            dataPoints: [...dataset.dataPoints, ...newDataPoints],\n            updatedAt: Date.now(),\n          };\n        }\n        return dataset;\n      })\n    );\n  }, []);\n\n  // Find a dataset by source type, or create one if it doesn't exist\n  const getOrCreateDatasetBySource = useCallback(\n    (source: 'sectors' | 'anomalies' | 'resources' | 'mixed', name?: string): string => {\n      // Find an existing dataset for this source\n      const existingDataset = datasets.find(dataset => dataset.source === source);\n      if (existingDataset) {\n        return existingDataset.id;\n      }\n\n      // Create a new dataset if one doesn't exist\n      const newDatasetName = name || `${source.charAt(0).toUpperCase() + source.slice(1)} Dataset`;\n      return createDataset({\n        name: newDatasetName,\n        description: `Automatically generated dataset for ${source}`,\n        dataPoints: [],\n        source,\n      });\n    },\n    [datasets, createDataset]\n  );\n\n  // Convert a sector to a data point\n  const sectorToDataPoint = useCallback((sector: Sector): DataPoint => {\n    return {\n      id: sector.id,\n      type: 'sector',\n      name: sector.name,\n      date: sector.discoveredAt || Date.now(),\n      coordinates: sector.coordinates,\n      properties: {\n        status: sector.status,\n        resourcePotential: sector.resourcePotential,\n        habitabilityScore: sector.habitabilityScore,\n        anomalyCount: sector.anomalies?.length || 0,\n        resourceCount: sector.resources?.length || 0,\n        lastScanned: sector.lastScanned || 0,\n      },\n    };\n  }, []);\n\n  // Convert an anomaly to a data point\n  const anomalyToDataPoint = useCallback((anomaly: Anomaly): DataPoint => {\n    return {\n      id: anomaly.id,\n      type: 'anomaly',\n      name: `${anomaly.type} Anomaly`,\n      date: anomaly.discoveredAt,\n      coordinates: anomaly.position,\n      properties: {\n        type: anomaly.type,\n        severity: anomaly.severity,\n        description: anomaly.description,\n        sectorId: anomaly.sectorId,\n        investigated: anomaly.investigatedAt !== undefined,\n      },\n    };\n  }, []);\n\n  // Convert a resource to a data point\n  const resourceToDataPoint = useCallback(\n    (\n      resource: ResourceData,\n      sectorId: string,\n      coordinates: { x: number; y: number }\n    ): DataPoint => {\n      return {\n        id: `${sectorId}-${resource.type}-${Date.now()}`,\n        type: 'resource',\n        name: `${resource.type} Resource`,\n        date: Date.now(),\n        coordinates,\n        properties: {\n          type: resource.type,\n          amount: resource.amount,\n          quality: resource.quality || 0,\n          sectorId,\n        },\n      };\n    },\n    []\n  );\n\n  // Subscribe to exploration events\n  useEffect(() => {\n    // Handle sector discovered events\n    const handleSectorDiscovered = (event: BaseEvent) => {\n      const { sector } = event.data as { sector: Sector };\n      if (!sector) return;\n\n      // Get or create the sectors dataset\n      const sectorsDatasetId = getOrCreateDatasetBySource('sectors', 'Explored Sectors');\n\n      // Add the sector as a data point\n      const dataPoint = sectorToDataPoint(sector);\n      addDataPointToDataset(sectorsDatasetId, dataPoint);\n    };\n\n    // Handle anomaly detected events\n    const handleAnomalyDetected = (event: BaseEvent) => {\n      const { anomaly, sector: _ } = event.data as { anomaly: Anomaly; sector: Sector };\n      if (!anomaly) return;\n\n      // Get or create the anomalies dataset\n      const anomaliesDatasetId = getOrCreateDatasetBySource('anomalies', 'Detected Anomalies');\n\n      // Add the anomaly as a data point\n      const dataPoint = anomalyToDataPoint(anomaly);\n      addDataPointToDataset(anomaliesDatasetId, dataPoint);\n    };\n\n    // Handle resource detected events\n    const handleResourceDetected = (event: BaseEvent) => {\n      const { resource, sector } = event.data as { resource: ResourceData; sector: Sector };\n      if (!resource || !sector) return;\n\n      // Get or create the resources dataset\n      const resourcesDatasetId = getOrCreateDatasetBySource('resources', 'Discovered Resources');\n\n      // Add the resource as a data point\n      const dataPoint = resourceToDataPoint(resource, sector.id, sector.coordinates);\n      addDataPointToDataset(resourcesDatasetId, dataPoint);\n    };\n\n    // Helper function to convert ExplorationEvents to EventType\n    const asEventType = (event: keyof typeof EXPLORATION_EVENTS): EventType => {\n      return EventType[`EXPLORATION_${event}`] as EventType;\n    };\n\n    // Subscribe to exploration events\n    const unsubscribeSector = explorationManager.subscribeToEvent(\n      EventType.EXPLORATION_SECTOR_DISCOVERED,\n      handleSectorDiscovered\n    );\n\n    const unsubscribeAnomaly = explorationManager.subscribeToEvent(\n      EventType.EXPLORATION_ANOMALY_DETECTED,\n      handleAnomalyDetected\n    );\n\n    const unsubscribeResource = explorationManager.subscribeToEvent(\n      EventType.EXPLORATION_RESOURCE_DETECTED,\n      handleResourceDetected\n    );\n\n    // Unsubscribe when component unmounts\n    return () => {\n      unsubscribeSector();\n      unsubscribeAnomaly();\n      unsubscribeResource();\n    };\n  }, [\n    getOrCreateDatasetBySource,\n    sectorToDataPoint,\n    anomalyToDataPoint,\n    resourceToDataPoint,\n    addDataPointToDataset,\n  ]);\n\n  // Update analysis configuration\n  const updateAnalysisConfig = useCallback(\n    (\n      id: string,\n      updates: Partial<Omit<AnalysisConfig, 'id' | 'createdAt' | 'updatedAt'>>\n    ): void => {\n      setAnalysisConfigs(prev =>\n        prev.map(config => {\n          if (config.id === id) {\n            return {\n              ...config,\n              ...updates,\n              updatedAt: Date.now(),\n            };\n          }\n          return config;\n        })\n      );\n    },\n    []\n  );\n\n  // Delete an analysis configuration\n  const deleteAnalysisConfig = useCallback((id: string): void => {\n    setAnalysisConfigs(prev => prev.filter(config => config.id !== id));\n  }, []);\n\n  // Get an analysis configuration by ID\n  const getAnalysisConfigById = useCallback(\n    (id: string): AnalysisConfig | undefined => {\n      return analysisConfigs.find(config => config.id === id);\n    },\n    [analysisConfigs]\n  );\n\n  // Run an analysis using the worker for heavy operations\n  const runAnalysis = useCallback(\n    async (configId: string): Promise<string> => {\n      const config = analysisConfigs.find(config => config.id === configId);\n      if (!config) {\n        throw new Error(`Analysis configuration with ID ${configId} not found`);\n      }\n\n      const dataset = datasets.find(dataset => dataset.id === config.datasetId);\n      if (!dataset) {\n        throw new Error(`Dataset with ID ${config.datasetId} not found`);\n      }\n\n      // Create a pending result\n      const pendingResultId = uuidv4();\n      const pendingResult: AnalysisResult = {\n        id: pendingResultId,\n        analysisConfigId: configId,\n        status: 'pending',\n        startTime: Date.now(),\n        data: {},\n      };\n\n      setAnalysisResults(prev => [...prev, pendingResult]);\n      setIsProcessingData(true);\n\n      try {\n        let result: AnalysisResult;\n\n        // Use the data processing service for offloading work if available\n        if (dataProcessingServiceRef.current) {\n          try {\n            // Determine which worker processing method to use based on analysis type\n            let processedData;\n\n            // Handle special case for transformation type\n            if ((config.type as string) === 'transformation') {\n              processedData = (await dataProcessingServiceRef.current.transformData(\n                dataset.dataPoints\n              )) as Record<string, unknown>;\n            } else {\n              switch (config.type) {\n                case 'clustering':\n                  processedData = await dataProcessingServiceRef.current.processClustering(\n                    dataset.dataPoints\n                  );\n                  break;\n                case 'prediction':\n                  processedData = await dataProcessingServiceRef.current.processPrediction(\n                    dataset.dataPoints\n                  );\n                  break;\n                case 'comparison':\n                  processedData = await dataProcessingServiceRef.current.processResourceMapping(\n                    dataset.dataPoints\n                  );\n                  break;\n                default:\n                  // For other types, use the local analysis algorithm service\n                  if (analysisAlgorithmServiceRef.current) {\n                    result = await analysisAlgorithmServiceRef.current.runAnalysis(config, dataset);\n                  } else {\n                    result = await runBasicAnalysis(config, dataset);\n                  }\n\n                  // Update the analysis results with the worker-processed data\n                  setAnalysisResults(prev =>\n                    prev.map(r => (r.id === pendingResultId ? result : r))\n                  );\n                  setIsProcessingData(false);\n                  return result.id;\n              }\n            }\n\n            // Create a result object with the processed data\n            result = {\n              id: pendingResultId,\n              analysisConfigId: config.id,\n              status: 'completed',\n              startTime: pendingResult.startTime,\n              endTime: Date.now(),\n              data: processedData as Record<string, unknown>,\n              summary: `Analysis completed successfully with ${\n                Object.keys(processedData || {}).length\n              } data points.`,\n            };\n          } catch (error) {\n            console.error('Worker processing error:', error);\n            // Fallback to main thread processing\n            if (analysisAlgorithmServiceRef.current) {\n              result = await analysisAlgorithmServiceRef.current.runAnalysis(config, dataset);\n            } else {\n              result = await runBasicAnalysis(config, dataset);\n            }\n          }\n        } else if (analysisAlgorithmServiceRef.current) {\n          // Use the main thread analysis service if worker is not available\n          result = await analysisAlgorithmServiceRef.current.runAnalysis(config, dataset);\n        } else {\n          // Fallback to a basic implementation\n          result = await runBasicAnalysis(config, dataset);\n        }\n\n        // Update the analysis results\n        setAnalysisResults(prev => prev.map(r => (r.id === pendingResultId ? result : r)));\n        setIsProcessingData(false);\n        return result.id;\n      } catch (error) {\n        // Create a failed result\n        const failedResult: AnalysisResult = {\n          id: pendingResultId,\n          analysisConfigId: configId,\n          status: 'failed',\n          startTime: pendingResult.startTime,\n          endTime: Date.now(),\n          data: {},\n          error: error instanceof Error ? error.message : 'Unknown error',\n        };\n\n        // Update the analysis results\n        setAnalysisResults(prev => prev.map(r => (r.id === pendingResultId ? failedResult : r)));\n        setIsProcessingData(false);\n        throw error;\n      }\n    },\n    [analysisConfigs, datasets]\n  );\n\n  // Add a function to run basic analysis if the service is not available\n  const runBasicAnalysis = async (\n    config: AnalysisConfig,\n    dataset: Dataset\n  ): Promise<AnalysisResult> => {\n    // Simulate analysis by delaying for a short time\n    await new Promise(resolve => setTimeout(resolve, 500));\n\n    return {\n      id: uuidv4(),\n      analysisConfigId: config.id,\n      status: 'completed',\n      startTime: Date.now() - 500, // Started 500ms ago\n      endTime: Date.now(),\n      data: {\n        config,\n        datasetSize: dataset.dataPoints.length,\n        message: 'Basic analysis completed without the analysis service',\n      },\n      summary: `Analyzed ${dataset.dataPoints.length} data points using the ${config.type} analysis type.`,\n    };\n  };\n\n  // Refresh data with worker-based filtering and sorting\n  const refreshData = useCallback(async () => {\n    if (!dataCollectionServiceRef.current) return;\n    setIsProcessingData(true);\n\n    try {\n      // Get all data from the collection service\n      const sectorData = dataCollectionServiceRef.current.getSectorData();\n      const anomalyData = dataCollectionServiceRef.current.getAnomalyData();\n      const resourceData = dataCollectionServiceRef.current.getResourceData();\n\n      // Create or update datasets for each data type with correct mapping\n      const sectorDatasetId = getOrCreateDatasetBySource('sectors');\n      const anomalyDatasetId = getOrCreateDatasetBySource('anomalies');\n      const resourceDatasetId = getOrCreateDatasetBySource('resources');\n\n      // Use the worker for batch processing if available\n      if (dataProcessingServiceRef.current) {\n        // Process data in batches using the worker\n        if (sectorDatasetId && sectorData.length > 0) {\n          await addDataPointsBatch(sectorDatasetId, sectorData);\n        }\n\n        if (anomalyDatasetId && anomalyData.length > 0) {\n          await addDataPointsBatch(anomalyDatasetId, anomalyData);\n        }\n\n        if (resourceDatasetId && resourceData.length > 0) {\n          await addDataPointsBatch(resourceDatasetId, resourceData);\n        }\n      } else {\n        // Fallback to standard processing\n        if (sectorDatasetId) {\n          for (const dataPoint of sectorData) {\n            addDataPointToDataset(sectorDatasetId, dataPoint);\n          }\n        }\n\n        if (anomalyDatasetId) {\n          for (const dataPoint of anomalyData) {\n            addDataPointToDataset(anomalyDatasetId, dataPoint);\n          }\n        }\n\n        if (resourceDatasetId) {\n          for (const dataPoint of resourceData) {\n            addDataPointToDataset(resourceDatasetId, dataPoint);\n          }\n        }\n      }\n    } finally {\n      setIsProcessingData(false);\n    }\n  }, [getOrCreateDatasetBySource, addDataPointToDataset]);\n\n  // Helper function to add data points in batches using the worker\n  const addDataPointsBatch = async (datasetId: string, dataPoints: DataPoint[]): Promise<void> => {\n    if (!dataProcessingServiceRef.current || dataPoints.length === 0) return;\n\n    try {\n      // Use the worker to filter out duplicates\n      const existingDataset = datasets.find(ds => ds.id === datasetId);\n      if (!existingDataset) return;\n\n      const existingIds = new Set(existingDataset.dataPoints.map(dp => dp.id));\n\n      // Filter out duplicate data points - can use the worker for this with large datasets\n      const uniqueDataPoints = dataPoints.filter(dp => !existingIds.has(dp.id));\n\n      if (uniqueDataPoints.length === 0) return;\n\n      // Add the filtered data points to the dataset\n      addDataPointsToDataset(datasetId, uniqueDataPoints);\n    } catch (error) {\n      console.error('Error in batch processing:', error);\n      // Fallback to individual adds\n      for (const dataPoint of dataPoints) {\n        addDataPointToDataset(datasetId, dataPoint);\n      }\n    }\n  };\n\n  // Worker-based filtering for datasets\n  const filterDataset = useCallback(\n    async (\n      datasetId: string,\n      filters: Array<{\n        field: string;\n        operator:\n          | 'equals'\n          | 'notEquals'\n          | 'greaterThan'\n          | 'lessThan'\n          | 'contains'\n          | 'notContains'\n          | 'between';\n        value: string | number | boolean | string[] | [number, number];\n      }>\n    ): Promise<DataPoint[]> => {\n      const dataset = datasets.find(ds => ds.id === datasetId);\n      if (!dataset) return [];\n\n      setIsProcessingData(true);\n\n      try {\n        // Use the worker for filtering if available\n        if (dataProcessingServiceRef.current && dataset.dataPoints.length > 100) {\n          try {\n            // Offload filtering to worker for large datasets\n            const filteredData = await dataProcessingServiceRef.current.filterData(\n              dataset.dataPoints,\n              filters.map(filter => ({\n                key: filter.field,\n                operator: mapOperator(filter.operator),\n                value: filter.value,\n              }))\n            );\n            setIsProcessingData(false);\n            return filteredData as DataPoint[];\n          } catch (error) {\n            console.error('Worker filtering error:', error);\n            // Continue to fallback\n          }\n        }\n\n        // Fallback to main thread filtering\n        if (!dataCollectionServiceRef.current) {\n          // Simple filtering if the service is not available\n          const filteredData = dataset.dataPoints.filter(dataPoint =>\n            filters.every(filter => {\n              // Treat DataPoint as a Record with unknown values for filtering\n              const value = getNestedProperty(\n                dataPoint as unknown as Record<string, unknown>,\n                filter.field\n              );\n\n              switch (filter.operator) {\n                case 'equals':\n                  return value === filter.value;\n                case 'notEquals':\n                  return value !== filter.value;\n                case 'greaterThan':\n                  return (\n                    typeof value === 'number' &&\n                    typeof filter.value === 'number' &&\n                    value > filter.value\n                  );\n                case 'lessThan':\n                  return (\n                    typeof value === 'number' &&\n                    typeof filter.value === 'number' &&\n                    value < filter.value\n                  );\n                case 'contains':\n                  if (typeof value === 'string' && typeof filter.value === 'string') {\n                    return value.toLowerCase().includes(filter.value.toLowerCase());\n                  }\n                  if (Array.isArray(value)) {\n                    return value.includes(filter.value);\n                  }\n                  return false;\n                case 'notContains':\n                  if (typeof value === 'string' && typeof filter.value === 'string') {\n                    return !value.toLowerCase().includes(filter.value.toLowerCase());\n                  }\n                  if (Array.isArray(value)) {\n                    return !value.includes(filter.value);\n                  }\n                  return false;\n                case 'between':\n                  if (\n                    typeof value === 'number' &&\n                    Array.isArray(filter.value) &&\n                    filter.value.length === 2\n                  ) {\n                    const [min, max] = filter.value as [number, number];\n                    return value >= min && value <= max;\n                  }\n                  return false;\n                default:\n                  return false;\n              }\n            })\n          );\n          setIsProcessingData(false);\n          return filteredData;\n        }\n\n        // Use the data collection service's filtering capability\n        const filteredData = dataCollectionServiceRef.current.filterData(\n          dataset.dataPoints,\n          filters\n        );\n        setIsProcessingData(false);\n        return filteredData;\n      } catch (error) {\n        setIsProcessingData(false);\n        console.error('Error filtering data:', error);\n        return [];\n      }\n    },\n    [datasets]\n  );\n\n  // Fix the getNestedProperty function with proper typing\n  const getNestedProperty = (obj: Record<string, unknown>, path: string): unknown => {\n    const parts = path.split('.');\n    let current: unknown = obj;\n\n    for (const part of parts) {\n      if (current === undefined || current === null) {\n        return undefined;\n      }\n\n      if (typeof current === 'object' && part in current) {\n        current = (current as Record<string, unknown>)[part];\n      } else {\n        return undefined;\n      }\n    }\n\n    return current;\n  };\n\n  // Get an analysis result by ID\n  const getAnalysisResultById = useCallback(\n    (id: string): AnalysisResult | undefined => {\n      return analysisResults.find(result => result.id === id);\n    },\n    [analysisResults]\n  );\n\n  // Get analysis results by config ID\n  const getAnalysisResultsByConfigId = useCallback(\n    (configId: string): AnalysisResult[] => {\n      return analysisResults.filter(result => result.analysisConfigId === configId);\n    },\n    [analysisResults]\n  );\n\n  // Helper function to map filter operators\n  const mapOperator = (\n    operator:\n      | 'equals'\n      | 'notEquals'\n      | 'greaterThan'\n      | 'lessThan'\n      | 'contains'\n      | 'notContains'\n      | 'between'\n  ): '==' | '!=' | '>' | '<' | '>=' | '<=' | 'contains' | 'startsWith' | 'endsWith' => {\n    switch (operator) {\n      case 'equals':\n        return '==';\n      case 'notEquals':\n        return '!=';\n      case 'greaterThan':\n        return '>';\n      case 'lessThan':\n        return '<';\n      case 'contains':\n        return 'contains';\n      // For 'between' and 'notContains', we'll need custom handling in the filter function\n      // For now, default to a reasonable operator\n      case 'notContains':\n        return '!=';\n      case 'between':\n        return '>=';\n      default:\n        return '==';\n    }\n  };\n\n  // Create the context value object\n  const contextValue: DataAnalysisContextType = {\n    datasets,\n    analysisConfigs,\n    analysisResults,\n    createDataset,\n    updateDataset,\n    deleteDataset,\n    getDatasetById,\n    createAnalysisConfig,\n    updateAnalysisConfig,\n    deleteAnalysisConfig,\n    getAnalysisConfigById,\n    runAnalysis,\n    getAnalysisResultById,\n    getAnalysisResultsByConfigId,\n    getOrCreateDatasetBySource,\n    addDataPointToDataset,\n    refreshData,\n    // Use the original filterDataset function but make it synchronous\n    filterDataset: (datasetId, filters) => {\n      // This is a workaround to convert the async function to a sync one\n      // In a real application, you would refactor the interface to be async\n      const emptyResult: DataPoint[] = [];\n\n      // Start the async process but return empty results immediately\n      setTimeout(() => {\n        filterDataset(datasetId, filters)\n          .then(results => {\n            console.warn(`Filtered ${results.length} results for dataset ${datasetId}`);\n          })\n          .catch(error => {\n            console.error('Error in filterDataset:', error);\n          });\n      }, 0);\n\n      return emptyResult;\n    },\n  };\n\n  return (\n    <DataAnalysisContext.Provider value={contextValue}>{children}</DataAnalysisContext.Provider>\n  );\n};\n\n/**\n * Hook to use the DataAnalysisContext\n */\nexport const useDataAnalysis = (): DataAnalysisContextType => {\n  const context = useContext(DataAnalysisContext);\n  if (context === undefined) {\n    throw new Error('useDataAnalysis must be used within a DataAnalysisProvider');\n  }\n  return context;\n};\n\n// Export the context for testing\nexport { DataAnalysisContext };\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/contexts/GameContext.tsx",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 540,
        "column": 29,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 540,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [15287, 15290], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [15287, 15290], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 546,
        "column": 28,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 546,
        "endColumn": 31,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [15519, 15522], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [15519, 15522], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 552,
        "column": 29,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 552,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [15752, 15755], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [15752, 15755], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 558,
        "column": 29,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 558,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [15986, 15989], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [15986, 15989], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 564,
        "column": 33,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 564,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [16228, 16231], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [16228, 16231], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 634,
        "column": 24,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 634,
        "endColumn": 27,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [18418, 18421], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [18418, 18421], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/contexts/ModuleContext.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/contexts/ResourceRatesContext.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/contexts/ShipContext.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/contexts/ThresholdContext.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'getResourceName' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 44,
        "column": 7,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 44,
        "endColumn": 22
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import * as React from 'react';\nimport { ResourceType, ResourceTypeHelpers } from './../types/resources/ResourceTypes';\nimport { ThresholdAction, ThresholdState, initialState, thresholdEvents } from './ThresholdTypes';\n\n// Types\nexport interface Resource {\n  id: string;\n  name: string;\n  type: ResourceType;\n  currentAmount: number;\n  maxCapacity: number;\n  thresholds: {\n    min: number;\n    max: number;\n  };\n  autoMine: boolean;\n}\n\nexport interface ThresholdPreset {\n  id: string;\n  name: string;\n  description: string;\n  thresholds: Record<string, { min: number; max: number }>;\n  autoMineStates: Record<string, boolean>;\n}\n\nexport interface ThresholdHistoryEntry {\n  timestamp: number;\n  resourceId: ResourceType;\n  amount: number;\n  thresholds: {\n    min: number;\n    max: number;\n  };\n  event: 'threshold_change' | 'amount_update' | 'auto_mine_toggle';\n}\n\ninterface ThresholdContextType {\n  state: ThresholdState;\n  dispatch: React.Dispatch<ThresholdAction>;\n}\n\n// Helper function to get resource name for display\nconst getResourceName = (resourceType: ResourceType): string => {\n  return ResourceTypeHelpers.getDisplayName(resourceType);\n};\n\n// Reducer\nfunction thresholdReducer(state: ThresholdState, action: ThresholdAction): ThresholdState {\n  switch (action.type) {\n    case 'SET_THRESHOLD': {\n      const historyEntry = {\n        timestamp: Date.now(),\n        resourceId: action.payload.resourceId,\n        amount: state.resources[action.payload.resourceId]?.currentAmount || 0,\n        thresholds: {\n          min: action.payload.min,\n          max: action.payload.max,\n        },\n        event: 'threshold_change' as const,\n      };\n\n      return {\n        ...state,\n        resources: {\n          ...state.resources,\n          [action.payload.resourceId]: {\n            ...state.resources[action.payload.resourceId],\n            thresholds: {\n              min: action.payload.min,\n              max: action.payload.max,\n            },\n          },\n        },\n        history: [...state.history, historyEntry].slice(-100),\n      };\n    }\n\n    case 'UPDATE_AMOUNT': {\n      const resource = state.resources[action.payload.resourceId];\n      if (!resource) {\n        return state;\n      }\n\n      const updatedResource = {\n        ...resource,\n        currentAmount: action.payload.amount,\n      };\n\n      const historyEntry = {\n        timestamp: Date.now(),\n        resourceId: action.payload.resourceId,\n        amount: action.payload.amount,\n        thresholds: resource.thresholds,\n        event: 'amount_update' as const,\n      };\n\n      // Check for threshold violations\n      if (updatedResource.autoMine) {\n        if (updatedResource.currentAmount < updatedResource.thresholds.min) {\n          thresholdEvents.next({\n            type: 'THRESHOLD_VIOLATED',\n            resourceId: action.payload.resourceId,\n            details: {\n              type: 'below_minimum',\n              current: updatedResource.currentAmount,\n              min: updatedResource.thresholds.min,\n            },\n          });\n        } else if (updatedResource.currentAmount > updatedResource.thresholds.max) {\n          thresholdEvents.next({\n            type: 'STORAGE_FULL',\n            resourceId: action.payload.resourceId,\n            details: {\n              type: 'above_maximum',\n              current: updatedResource.currentAmount,\n              max: updatedResource.thresholds.max,\n            },\n          });\n        }\n      }\n\n      return {\n        ...state,\n        resources: {\n          ...state.resources,\n          [action.payload.resourceId]: updatedResource,\n        },\n        history: [...state.history, historyEntry].slice(-100),\n      };\n    }\n\n    case 'TOGGLE_AUTO_MINE': {\n      const resource = state.resources[action.payload.resourceId];\n      if (!resource) {\n        return state;\n      }\n\n      const newAutoMine = !resource.autoMine;\n\n      const historyEntry = {\n        timestamp: Date.now(),\n        resourceId: action.payload.resourceId,\n        amount: resource.currentAmount,\n        thresholds: resource.thresholds,\n        event: 'auto_mine_toggle' as const,\n      };\n\n      if (newAutoMine) {\n        thresholdEvents.next({\n          type: 'AUTO_MINE_TRIGGERED',\n          resourceId: action.payload.resourceId,\n          details: { type: 'below_minimum', current: resource.currentAmount },\n        });\n      }\n\n      return {\n        ...state,\n        resources: {\n          ...state.resources,\n          [action.payload.resourceId]: {\n            ...resource,\n            autoMine: newAutoMine,\n          },\n        },\n        history: [...state.history, historyEntry].slice(-100),\n      };\n    }\n\n    case 'ADD_PRESET':\n      return {\n        ...state,\n        presets: [...state.presets, action.payload],\n      };\n\n    case 'REMOVE_PRESET':\n      return {\n        ...state,\n        presets: state.presets.filter(preset => preset.id !== action.payload.presetId),\n        activePresetId:\n          state.activePresetId === action.payload.presetId ? null : state.activePresetId,\n      };\n\n    case 'APPLY_PRESET': {\n      const preset = state.presets.find(p => p.id === action.payload.presetId);\n      if (!preset) {\n        return state;\n      }\n\n      const updatedResources = { ...state.resources };\n      Object.entries(preset.thresholds).forEach(([resourceId, thresholds]) => {\n        if (updatedResources[resourceId]) {\n          updatedResources[resourceId] = {\n            ...updatedResources[resourceId],\n            thresholds,\n            autoMine: preset.autoMineStates[resourceId] || false,\n          };\n        }\n      });\n\n      return {\n        ...state,\n        resources: updatedResources,\n        activePresetId: action.payload.presetId,\n      };\n    }\n\n    case 'SET_GLOBAL_AUTO_MINE': {\n      const updatedResources = Object.entries(state.resources).reduce(\n        (acc, [id, resource]) => ({\n          ...acc,\n          [id]: { ...resource, autoMine: action.payload },\n        }),\n        {}\n      );\n\n      return {\n        ...state,\n        globalAutoMine: action.payload,\n        resources: updatedResources,\n      };\n    }\n\n    case 'ADD_NOTIFICATION':\n      return {\n        ...state,\n        notifications: [...state.notifications, action.payload],\n      };\n\n    case 'CLEAR_NOTIFICATION':\n      return {\n        ...state,\n        notifications: state.notifications.filter((_, index) => index !== action.payload),\n      };\n\n    case 'ADD_RESOURCE':\n      return {\n        ...state,\n        resources: {\n          ...state.resources,\n          [action.payload.id]: action.payload,\n        },\n      };\n\n    case 'REMOVE_RESOURCE': {\n      const remainingResources = { ...state.resources };\n      delete remainingResources[action.payload.resourceId];\n      return {\n        ...state,\n        resources: remainingResources,\n      };\n    }\n\n    case 'ADD_HISTORY_ENTRY':\n      return {\n        ...state,\n        history: [...state.history, action.payload].slice(-100),\n      };\n\n    default:\n      return state;\n  }\n}\n\n// Context\nconst ThresholdContext = React.createContext<ThresholdContextType | undefined>(undefined);\n\n// Provider\nexport function ThresholdProvider({ children }: { children: React.ReactNode }) {\n  const [state, dispatch] = React.useReducer(thresholdReducer, initialState);\n\n  return (\n    <ThresholdContext.Provider value={{ state, dispatch }}>{children}</ThresholdContext.Provider>\n  );\n}\n\n// Hook\nexport function useThreshold() {\n  const context = React.useContext(ThresholdContext);\n  if (context === undefined) {\n    throw new Error('useThreshold must be used within a ThresholdProvider');\n  }\n  return context;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/contexts/ThresholdTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/BackgroundEffect.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/BuildingUpgradeEffect.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/CapitalShipEffect.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/CentralMothership.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/ColonyStarStation.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/CombatAutomationEffect.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/EngineTrailEffect.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/ExplorationHub.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/ExplosionEffect.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/FormationTransitionEffect.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/HabitableWorld.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/MineralProcessing.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/ModuleUpgradeTransition.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/MothershipSuperstructure.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/PopulationIndicator.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/ProgressionEffects.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/ResourceFlowVisualization.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/ShieldEffect.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/ShieldImpactEffect.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/ShipPathEffect.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/SmokeTrailEffect.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/StarSystemBackdrop.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/ThrusterEffect.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/TradeRouteEffect.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/VisualEffect.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/WeaponEffect.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/types_effects/AdvancedWeaponEffects.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/types_effects/EffectTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/types_effects/EnvironmentalHazardEffects.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/types_effects/WeaponEffects.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/types_effects/shipEffects.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/util_effects/effectUtils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/errorHandling/ErrorBoundary.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/errorHandling/ErrorFallback.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/errorHandling/GlobalErrorBoundary.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'handleReset' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 26,
        "column": 9,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 26,
        "endColumn": 20
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import * as React from \"react\";\nimport { ErrorBoundary, ErrorBoundaryProps } from './ErrorBoundary';\n\n/**\n * Global error boundary props\n */\nexport interface GlobalErrorBoundaryProps extends Omit<ErrorBoundaryProps, 'context' | 'fallback'> {\n  /** Whether this is the root boundary (changes styling) */\n  isRoot?: boolean;\n}\n\n/**\n * Global application error boundary\n * \n * This component is designed to be used at the application root level\n * to catch any unhandled errors that bubble up through the component tree.\n */\nexport const GlobalErrorBoundary: React.FC<GlobalErrorBoundaryProps> = ({\n  children,\n  isRoot = false,\n  onError,\n  suppressErrorLogging,\n  metadata,\n  ...props\n}) => {\n  const handleReset = () => {\n    // For a root-level error, we might want to refresh the page\n    if (isRoot) {\n      window.location.reload();\n      return;\n    }\n    \n    // Otherwise, just clear any application state as needed\n    // This could include resetting global state, clearing caches, etc.\n  };\n\n  // Custom fallback UI for global error\n  const globalFallback = (error: Error, reset: () => void) => {\n    return (\n      <div className=\"min-h-screen flex items-center justify-center bg-gray-100 px-4\">\n        <div className=\"max-w-lg w-full bg-white rounded-lg shadow-lg p-8\">\n          <div className=\"flex items-center mb-6\">\n            <div className=\"bg-red-100 p-3 rounded-full mr-4\">\n              <svg\n                xmlns=\"http://www.w3.org/2000/svg\"\n                className=\"h-6 w-6 text-red-600\"\n                fill=\"none\"\n                viewBox=\"0 0 24 24\"\n                stroke=\"currentColor\"\n              >\n                <path\n                  strokeLinecap=\"round\"\n                  strokeLinejoin=\"round\"\n                  strokeWidth={2}\n                  d=\"M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z\"\n                />\n              </svg>\n            </div>\n            <h1 className=\"text-xl font-bold text-gray-800\">\n              Something went wrong\n            </h1>\n          </div>\n          \n          <p className=\"text-gray-600 mb-6\">\n            We're sorry, but something went wrong. Our team has been notified and is working to fix the issue.\n          </p>\n          \n          {process.env.NODE_ENV !== 'production' && (\n            <div className=\"mb-6 bg-gray-50 p-4 rounded border border-gray-200\">\n              <h3 className=\"font-medium text-gray-800 mb-2\">Error Details:</h3>\n              <pre className=\"text-sm text-red-600 whitespace-pre-wrap break-all\">\n                {error.message}\n              </pre>\n              {error.stack && (\n                <details className=\"mt-2\">\n                  <summary className=\"cursor-pointer text-sm font-medium text-gray-600\">\n                    Stack trace\n                  </summary>\n                  <pre className=\"mt-2 text-xs text-gray-600 whitespace-pre-wrap break-all\">\n                    {error.stack}\n                  </pre>\n                </details>\n              )}\n            </div>\n          )}\n          \n          <div className=\"flex justify-between\">\n            <button\n              onClick={() => reset()}\n              className=\"px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700 transition-colors\"\n            >\n              {isRoot ? 'Reload Application' : 'Try Again'}\n            </button>\n            \n            <button\n              onClick={() => {\n                // Navigate to a safe page, like the home page\n                window.location.href = '/';\n              }}\n              className=\"px-4 py-2 bg-gray-200 text-gray-800 rounded hover:bg-gray-300 transition-colors\"\n            >\n              Return to Home\n            </button>\n          </div>\n        </div>\n      </div>\n    );\n  };\n\n  return (\n    <ErrorBoundary\n      fallback={globalFallback}\n      context=\"Global\"\n      onError={(error, errorInfo) => {\n        // For root errors, we might want to log analytics events or notify monitoring services\n        if (isRoot) {\n          // Example: Log to analytics\n          try {\n            if (window.gtag) {\n              window.gtag('event', 'error', {\n                'event_category': 'Error',\n                'event_label': error.message,\n                'value': 1\n              });\n            }\n          } catch (e) {\n            console.error('Failed to log error to analytics:', e);\n          }\n        }\n        \n        // Call original onError handler\n        if (onError) {\n          onError(error, errorInfo);\n        }\n      }}\n      suppressErrorLogging={suppressErrorLogging}\n      metadata={{\n        isRoot,\n        ...metadata,\n      }}\n      {...props}\n    >\n      {children}\n    </ErrorBoundary>\n  );\n};\n\n// Add this to global.d.ts if needed\ndeclare global {\n  interface Window {\n    gtag?: (command: string, action: string, params: Record<string, unknown>) => void;\n  }\n}\n\nexport default GlobalErrorBoundary;",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/errorHandling/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/errorHandling/specialized/DataFetchingErrorBoundary.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/errorHandling/specialized/VisualizationErrorBoundary.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/errorHandling/utils/errorBoundaryHOC.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'ReactNode' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 2,
        "column": 36,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 2,
        "endColumn": 45
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 166,
        "column": 77,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 166,
        "endColumn": 80,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5503, 5506], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5503, 5506], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 168,
        "column": 55,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 168,
        "endColumn": 58,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5582, 5585], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5582, 5585], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import * as React from \"react\";\nimport { ComponentType, ErrorInfo, ReactNode } from 'react';\nimport { ErrorBoundary, ErrorBoundaryProps } from '../ErrorBoundary';\n\n/**\n * Props for the fallback component created by createTypedErrorBoundary\n */\nexport interface TypedErrorFallbackProps {\n  /** The error that occurred */\n  error: Error;\n  /** Component name for error reporting */\n  componentName: string;\n  /** (...args: unknown[]) => unknown to reset the error boundary */\n  resetError: () => void;\n  /** Additional error context information */\n  errorContext?: Record<string, unknown>;\n}\n\n/**\n * Default fallback component for typed error boundaries\n */\nexport const TypedErrorFallback: React.FC<TypedErrorFallbackProps> = ({\n  error,\n  componentName,\n  resetError,\n  errorContext,\n}) => (\n  <div className=\"p-4 rounded border border-red-300 bg-red-50 text-red-800\">\n    <h3 className=\"font-semibold mb-2\">Error in {componentName}</h3>\n    <p className=\"mb-2\">An error occurred while rendering the {componentName} component:</p>\n    <pre className=\"p-2 bg-red-100 rounded mb-3 text-sm overflow-auto\">{error.message}</pre>\n    {errorContext && (\n      <div className=\"mb-3\">\n        <h4 className=\"font-medium mb-1\">Error Context:</h4>\n        <pre className=\"p-2 bg-red-100 rounded text-xs overflow-auto\">\n          {JSON.stringify(errorContext, null, 2)}\n        </pre>\n      </div>\n    )}\n    <button\n      onClick={resetError}\n      className=\"px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700\"\n    >\n      Reset Component\n    </button>\n  </div>\n);\n\n/**\n * Create a typed error boundary for a specific component type\n * \n * This function wraps a component with an error boundary that is specifically\n * typed for that component's props, providing a clean way to create \"safe\"\n * versions of components.\n * \n * @param Component The React component to wrap with an error boundary\n * @param componentName Name of the component for error reporting\n * @param FallbackComponent Custom fallback component\n * @param onError Custom error handler function\n * @returns A wrapped component with an error boundary\n */\nexport function createTypedErrorBoundary<P extends object>(\n  Component: ComponentType<P>,\n  componentName: string,\n  FallbackComponent?: React.ComponentType<TypedErrorFallbackProps>,\n  onError?: (error: Error, errorInfo: ErrorInfo, componentName: string) => void\n): React.FC<P & { errorContext?: Record<string, unknown>; resetKeys?: unknown[] }> {\n  return (props: P & { errorContext?: Record<string, unknown>; resetKeys?: unknown[] }) => {\n    const { errorContext, resetKeys, ...componentProps } = props;\n\n    // Custom error handler that includes the component name\n    const handleError = (error: Error, errorInfo: ErrorInfo) => {\n      console.error(`Error in ${componentName}:`, error);\n      console.error('Component Stack:', errorInfo.componentStack);\n      \n      if (onError) {\n        onError(error, errorInfo, componentName);\n      }\n    };\n\n    // Custom fallback UI that includes the component name\n    const fallback = (error: Error, reset: () => void) => {\n      const FallbackUI = FallbackComponent || TypedErrorFallback;\n      \n      return (\n        <FallbackUI\n          error={error}\n          componentName={componentName}\n          resetError={reset}\n          errorContext={errorContext}\n        />\n      );\n    };\n\n    return (\n      <ErrorBoundary\n        fallback={fallback}\n        onError={handleError}\n        context={componentName}\n        resetKeys={resetKeys}\n        metadata={{\n          componentName,\n          ...errorContext,\n        }}\n      >\n        <Component {...(componentProps as P)} />\n      </ErrorBoundary>\n    );\n  };\n}\n\n/**\n * Options for the withErrorBoundary HOC\n */\nexport interface WithErrorBoundaryOptions extends Omit<ErrorBoundaryProps, 'children'> {\n  /** Component name for error reporting */\n  componentName?: string;\n}\n\n/**\n * Higher-order component that wraps a component with an error boundary\n * \n * This is a more flexible alternative to createTypedErrorBoundary that allows\n * passing any ErrorBoundary props.\n * \n * @param Component The component to wrap\n * @param options Options for the error boundary\n * @returns A wrapped component with an error boundary\n */\nexport function withErrorBoundary<P extends object>(\n  Component: ComponentType<P>,\n  options: WithErrorBoundaryOptions = {}\n): React.FC<P> {\n  const { componentName = Component.displayName || Component.name || 'UnknownComponent', ...errorBoundaryProps } = options;\n  \n  // Set a display name for the wrapped component\n  const wrappedComponentName = `WithErrorBoundary(${componentName})`;\n  \n  const WrappedComponent: React.FC<P> = (props) => {\n    return (\n      <ErrorBoundary \n        context={componentName}\n        {...errorBoundaryProps}\n      >\n        <Component {...props} />\n      </ErrorBoundary>\n    );\n  };\n  \n  // Set display name for better debugging\n  WrappedComponent.displayName = wrappedComponentName;\n  \n  return WrappedComponent;\n}\n\n/**\n * Create safer versions of components by wrapping them with error boundaries\n * \n * This utility function takes a record of components and wraps each one with\n * an error boundary, creating a new record of \"safe\" components.\n * \n * @param components Record of components to wrap\n * @param getOptions (...args: unknown[]) => unknown to generate options for each component\n * @returns Record of wrapped components\n */\nexport function createSafeComponents<T extends Record<string, ComponentType<any>>>(\n  components: T,\n  getOptions?: (key: string, Component: ComponentType<any>) => WithErrorBoundaryOptions\n): { [K in keyof T]: React.FC<React.ComponentProps<T[K]>> } {\n  const safeComponents = {} as { [K in keyof T]: React.FC<React.ComponentProps<T[K]>> };\n  \n  for (const key in components) {\n    const Component = components[key];\n    const options = getOptions ? getOptions(key, Component) : { componentName: key as string };\n    \n    safeComponents[key] = withErrorBoundary(Component, options);\n  }\n  \n  return safeComponents;\n}\n\n/**\n * Create specialized versions of error boundaries\n * \n * This utility function creates a specialized error boundary component\n * for specific contexts or use cases.\n * \n * @param defaultProps Default props to apply to the error boundary\n * @returns A specialized error boundary component\n */\nexport function createSpecializedErrorBoundary(\n  defaultProps: Omit<ErrorBoundaryProps, 'children'>\n): React.FC<ErrorBoundaryProps> {\n  const SpecializedErrorBoundary: React.FC<ErrorBoundaryProps> = (props) => {\n    return (\n      <ErrorBoundary\n        {...defaultProps}\n        {...props}\n        metadata={{\n          ...defaultProps.metadata,\n          ...props.metadata,\n        }}\n      />\n    );\n  };\n  \n  return SpecializedErrorBoundary;\n}",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/errorHandling/utils/migration.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/eslint-rules/no-string-resource-types.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/factories/ships/ShipClassFactory.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/automation/useAutomation.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/automation/useGlobalAutomation.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/combat/useCombatAI.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'UnitFormation' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 10,
        "column": 11,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 10,
        "endColumn": 24
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useEffect, useState } from 'react';\nimport { BehaviorEvents, behaviorTreeManager } from '../../managers/ai/BehaviorTreeManager';\nimport { getCombatManager } from '../../managers/ManagerRegistry';\nimport { CombatUnitStatus } from '../../types/combat/CombatTypes';\nimport { CombatUnitDamageEvent, CombatUnitStatusEvent } from '../../types/events/CombatEvents';\nimport { FactionId } from '../../types/ships/FactionTypes';\nimport { WeaponCategory, WeaponStatus } from '../../types/weapons/WeaponTypes';\n\n// Define formation interface to replace any type\ninterface UnitFormation {\n  type: 'offensive' | 'defensive' | 'balanced';\n  spacing: number;\n  facing: number;\n}\n\nexport function useCombatAI(unitId: string, factionId: FactionId) {\n  const [status, setStatus] = useState<CombatUnitStatus>({\n    main: 'active',\n    effects: [],\n  });\n  const [performance, setPerformance] = useState({\n    successRate: 0,\n    damageDealt: 0,\n    damageTaken: 0,\n    killCount: 0,\n  });\n\n  useEffect(() => {\n    const combatManager = getCombatManager();\n\n    const handleNodeExecuted = (event: BehaviorEvents['nodeExecuted']) => {\n      // Update performance metrics based on node execution\n      setPerformance(prev => ({\n        ...prev,\n        successRate: prev.successRate * 0.9 + (event.success ? 0.1 : 0),\n      }));\n    };\n\n    const handleActionStarted = (event: BehaviorEvents['actionStarted']) => {\n      if (event.unitId === unitId) {\n        // Update status based on action type\n        setStatus(prev => ({\n          ...prev,\n          secondary: 'charging',\n        }));\n      }\n    };\n\n    const handleTreeCompleted = (event: BehaviorEvents['treeCompleted']) => {\n      if (event.unitId === unitId) {\n        // Update performance metrics\n        setPerformance(prev => ({\n          ...prev,\n          successRate: prev.successRate * 0.9 + (event.success ? 0.1 : 0),\n        }));\n      }\n    };\n\n    // Set up subscriptions\n    const unsubscribeNodeExecuted = behaviorTreeManager.on('nodeExecuted', handleNodeExecuted);\n    const unsubscribeActionStarted = behaviorTreeManager.on('actionStarted', handleActionStarted);\n    const unsubscribeTreeCompleted = behaviorTreeManager.on('treeCompleted', handleTreeCompleted);\n\n    // Subscribe to combat events for performance tracking\n    const unsubscribeDamaged = combatManager.on(\n      'combat:unit-damaged',\n      (event: CombatUnitDamageEvent) => {\n        if (event.unitId === unitId) {\n          setPerformance(prev => ({\n            ...prev,\n            damageTaken: prev.damageTaken + event.damageAmount,\n          }));\n        } else if (event.damageSource === unitId) {\n          setPerformance(prev => ({\n            ...prev,\n            damageDealt: prev.damageDealt + event.damageAmount,\n          }));\n        }\n      }\n    );\n\n    const unsubscribeStatusChanged = combatManager.on(\n      'combat:unit-status-changed',\n      (event: CombatUnitStatusEvent) => {\n        if (event.unitId === unitId) {\n          // Convert string status to CombatUnitStatus object\n          setStatus({\n            main: event.status === 'destroyed' ? 'destroyed' : 'active',\n            effects: [],\n          });\n        }\n      }\n    );\n\n    // Update behavior tree periodically\n    const updateInterval = setInterval(() => {\n      const unit = combatManager.getUnitStatus?.(unitId);\n      if (!unit) return;\n\n      const convertStatus = (status: string): CombatUnitStatus => ({\n        main: status === 'destroyed' ? 'destroyed' : status === 'disabled' ? 'disabled' : 'active',\n        effects: [],\n      });\n\n      const nearbyEnemies = (\n        combatManager\n          .getUnitsInRange?.(unit.position, 500)\n          ?.filter(other => other.faction !== factionId) || []\n      ).map(unit => ({\n        ...unit,\n        velocity: { x: 0, y: 0 }, // Add default velocity for units\n        status: convertStatus(unit.status),\n        weapons: unit.weapons.map(weapon => ({\n          id: weapon.id,\n          type: weapon.type as WeaponCategory,\n          damage: weapon.damage,\n          range: weapon.range,\n          cooldown: weapon.cooldown,\n          status: weapon.status as WeaponStatus,\n        })),\n        stats: {\n          ...unit.stats,\n          armor: 0, // Add default armor value\n        },\n      }));\n\n      const nearbyAllies = (\n        combatManager\n          .getUnitsInRange?.(unit.position, 500)\n          ?.filter(other => other.faction === factionId && other.id !== unitId) || []\n      ).map(unit => ({\n        ...unit,\n        velocity: { x: 0, y: 0 }, // Add default velocity for units\n        status: convertStatus(unit.status),\n        weapons: unit.weapons.map(weapon => ({\n          id: weapon.id,\n          type: weapon.type as WeaponCategory,\n          damage: weapon.damage,\n          range: weapon.range,\n          cooldown: weapon.cooldown,\n          status: weapon.status as WeaponStatus,\n        })),\n        stats: {\n          ...unit.stats,\n          armor: 0, // Add default armor value\n        },\n      }));\n\n      // Update behavior tree context\n      behaviorTreeManager.updateContext?.(unitId, {\n        unit: {\n          ...unit,\n          velocity: { x: 0, y: 0 }, // Add default velocity\n          status: convertStatus(unit.status),\n          weapons: unit.weapons.map(weapon => ({\n            id: weapon.id,\n            type: weapon.type as WeaponCategory,\n            damage: weapon.damage,\n            range: weapon.range,\n            cooldown: weapon.cooldown,\n            status: weapon.status as WeaponStatus,\n          })),\n          stats: {\n            ...unit.stats,\n            armor: 0, // Add default armor value\n          },\n          target: unit.target?.id,\n        },\n        factionId,\n        fleetStrength: nearbyAllies.reduce((sum, ally) => sum + ally.stats.health, 0),\n        threatLevel: nearbyEnemies.reduce((sum, enemy) => sum + enemy.stats.health, 0),\n        nearbyEnemies,\n        nearbyAllies,\n        currentFormation: {\n          type: 'balanced',\n          spacing: 100,\n          facing: 0,\n        },\n        lastAction: undefined,\n        cooldowns: {},\n      });\n\n      // Evaluate behavior tree\n      const treeId = `${factionId}-combat`;\n      const success = behaviorTreeManager.evaluateTree?.(unitId, treeId) || false;\n\n      setPerformance(prev => ({\n        ...prev,\n        successRate: prev.successRate * 0.9 + (success ? 0.1 : 0),\n      }));\n    }, 1000);\n\n    return () => {\n      clearInterval(updateInterval);\n      if (typeof unsubscribeNodeExecuted === 'function') unsubscribeNodeExecuted();\n      if (typeof unsubscribeActionStarted === 'function') unsubscribeActionStarted();\n      if (typeof unsubscribeTreeCompleted === 'function') unsubscribeTreeCompleted();\n      if (typeof unsubscribeDamaged === 'function') unsubscribeDamaged();\n      if (typeof unsubscribeStatusChanged === 'function') unsubscribeStatusChanged();\n    };\n  }, [unitId, factionId]);\n\n  return {\n    status,\n    performance,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/combat/useCombatSystem.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'event' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 30,
        "column": 87,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 30,
        "endColumn": 92
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useCallback, useEffect, useState } from 'react';\nimport { getCombatManager } from '../../managers/ManagerRegistry';\nimport { FleetFormation } from '../../types/combat/CombatTypes';\nimport { Position } from '../../types/core/GameTypes';\nimport { CombatUnitStatus } from '../../types/events/CombatEvents';\n\n/**\n * Enhanced combat system hook for managing fleet formations and tactics\n */\nexport function useCombatSystem() {\n  const [threatLevel, setThreatLevel] = useState(0);\n  const [activeUnits, setActiveUnits] = useState(0);\n  const [isActive, setIsActive] = useState(false);\n  const [activeFleets, setActiveFleets] = useState<string[]>([]);\n  const [formations, setFormations] = useState<Record<string, FleetFormation>>({});\n\n  useEffect(() => {\n    const combatManager = getCombatManager();\n\n    // Subscribe to combat events\n    const unsubscribeUnitSpawned = combatManager.subscribe('combat:unit-spawned', event => {\n      setActiveUnits(prev => prev + 1);\n      // Update threat level based on unit type and faction\n      if (event.faction !== 'player') {\n        setThreatLevel(prev => prev + getThreatValueForUnit(event.unitType));\n      }\n      setIsActive(true);\n    });\n\n    const unsubscribeUnitDestroyed = combatManager.subscribe('combat:unit-destroyed', event => {\n      setActiveUnits(prev => prev - 1);\n      // Check if combat is still active\n      if (activeUnits <= 1) {\n        setIsActive(false);\n      }\n    });\n\n    // Initial state setup\n    const currentUnits = combatManager.getAllUnits();\n    setActiveUnits(currentUnits.length);\n    setIsActive(currentUnits.length > 0);\n\n    return () => {\n      unsubscribeUnitSpawned();\n      unsubscribeUnitDestroyed();\n    };\n  }, [activeUnits]);\n\n  /**\n   * Update formation configuration for a fleet\n   */\n  const updateFleetFormation = useCallback((fleetId: string, formation: FleetFormation) => {\n    const combatManager = getCombatManager();\n    // Get all units in the fleet\n    const fleetUnits = combatManager.getAllUnits().filter(unit => unit.faction === fleetId);\n\n    // Update each unit's position based on formation\n    fleetUnits.forEach((unit, index) => {\n      const basePosition = unit.position;\n      const offset = calculateFormationOffset(formation.type, index, fleetUnits.length);\n      const newPosition = {\n        x: basePosition.x + offset.x,\n        y: basePosition.y + offset.y,\n      };\n      combatManager.moveUnit(unit.id, newPosition);\n    });\n\n    setFormations(prev => ({\n      ...prev,\n      [fleetId]: formation,\n    }));\n  }, []);\n\n  /**\n   * Update tactical behavior for a fleet\n   */\n  const updateFleetTactic = useCallback(\n    (fleetId: string, tactic: 'flank' | 'charge' | 'kite' | 'hold') => {\n      const combatManager = getCombatManager();\n      const fleetUnits = combatManager.getAllUnits().filter(unit => unit.faction === fleetId);\n\n      // Update each unit's status based on tactic\n      fleetUnits.forEach(unit => {\n        const status = getTacticStatus(tactic);\n        combatManager.changeUnitStatus(unit.id, status);\n      });\n\n      setActiveFleets(prev => {\n        if (!prev.includes(fleetId)) {\n          return [...prev, fleetId];\n        }\n        return prev;\n      });\n    },\n    []\n  );\n\n  /**\n   * Get current formations for all fleets\n   */\n  const getFleetFormations = useCallback(() => {\n    return formations;\n  }, [formations]);\n\n  /**\n   * Get current tactics for all fleets\n   */\n  const getFleetTactics = useCallback(() => {\n    const combatManager = getCombatManager();\n    const units = combatManager.getAllUnits();\n    const tactics: Record<string, string> = {};\n\n    units.forEach(unit => {\n      if (unit.faction && !tactics[unit.faction]) {\n        tactics[unit.faction] = getStatusTactic(unit.status);\n      }\n    });\n\n    return tactics;\n  }, []);\n\n  return {\n    threatLevel,\n    activeUnits,\n    isActive,\n    activeFleets,\n    formations,\n    updateFleetFormation,\n    updateFleetTactic,\n    getFleetFormations,\n    getFleetTactics,\n  };\n}\n\n// Helper function to calculate threat value based on unit type\nfunction getThreatValueForUnit(unitType: string): number {\n  const threatValues: Record<string, number> = {\n    spitflare: 1,\n    starSchooner: 2,\n    orionFrigate: 3,\n    harbringerGalleon: 4,\n    midwayCarrier: 5,\n    motherEarthRevenge: 6,\n  };\n  return threatValues[unitType] || 1;\n}\n\n// Helper function to calculate formation offset based on formation type\nfunction calculateFormationOffset(\n  formationType: 'offensive' | 'defensive' | 'balanced',\n  index: number,\n  totalUnits: number\n): Position {\n  const spacing = 100; // Default spacing\n\n  switch (formationType) {\n    case 'offensive': {\n      // Wedge formation\n      return {\n        x: index * spacing * Math.cos(Math.PI / 4),\n        y: index * spacing * Math.sin(Math.PI / 4),\n      };\n    }\n    case 'defensive': {\n      // Circle formation\n      const angle = (2 * Math.PI * index) / totalUnits;\n      return {\n        x: spacing * Math.cos(angle),\n        y: spacing * Math.sin(angle),\n      };\n    }\n    case 'balanced': {\n      // Line formation\n      return {\n        x: index * spacing,\n        y: 0,\n      };\n    }\n  }\n}\n\n// Helper function to convert tactic to status\nfunction getTacticStatus(tactic: string): CombatUnitStatus {\n  switch (tactic) {\n    case 'flank':\n      return 'moving';\n    case 'charge':\n      return 'attacking';\n    case 'kite':\n      return 'retreating';\n    case 'hold':\n      return 'defending';\n    default:\n      return 'idle';\n  }\n}\n\n// Helper function to convert status to tactic\nfunction getStatusTactic(status: CombatUnitStatus): string {\n  switch (status) {\n    case 'moving':\n      return 'flank';\n    case 'attacking':\n      return 'charge';\n    case 'retreating':\n      return 'kite';\n    case 'defending':\n      return 'hold';\n    default:\n      return 'hold';\n  }\n}\n\nexport function useUnitCombat(unitId: string) {\n  const [unitStatus, setUnitStatus] = useState(() => getCombatManager().getUnitStatus(unitId));\n\n  useEffect(() => {\n    const interval = setInterval(() => {\n      const status = getCombatManager().getUnitStatus(unitId);\n      setUnitStatus(status);\n    }, 250); // More frequent updates for combat units\n\n    return () => clearInterval(interval);\n  }, [unitId]);\n\n  return {\n    status: unitStatus?.status || 'idle',\n    health: unitStatus?.stats?.health || 0,\n    shield: unitStatus?.stats?.shield || 0,\n    target: unitStatus?.target,\n    position: unitStatus?.position,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/events/useEventBatching.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/events/useEventFiltering.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/events/useEventSubscription.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/events/useModuleEvents.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/events/useSystemEvents.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/factions/useAdaptiveAI.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/factions/useDiplomacy.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/factions/useEnemyAI.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/factions/useFactionAI.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/factions/useFactionBehavior.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/factions/useFleetAI.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/factory/createDataFetchHook.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 50,
        "column": 50,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 50,
        "endColumn": 53,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1586, 1589], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1586, 1589], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useState, useEffect, useCallback } from 'react';\nimport { errorLoggingService, ErrorType } from '../../services/ErrorLoggingService';\n\n/**\n * Options for data fetching hook\n */\nexport interface DataFetchOptions {\n  /** Whether to fetch immediately on mount */\n  fetchOnMount?: boolean;\n  /** Custom condition to trigger fetch */\n  enabled?: boolean;\n  /** Refetch interval in milliseconds */\n  refetchInterval?: number;\n  /** Maximum number of retries on error */\n  maxRetries?: number;\n  /** Whether to reset data when refetching */\n  resetOnFetch?: boolean;\n  /** Cache key for the request */\n  cacheKey?: string;\n  /** Cache time in milliseconds */\n  cacheTime?: number;\n}\n\n/**\n * Return type for data fetching hook\n */\nexport interface DataFetchResult<T> {\n  /** The fetched data */\n  data: T | null;\n  /** Whether data is currently being fetched */\n  isLoading: boolean;\n  /** Any error that occurred during fetching */\n  error: Error | null;\n  /** (...args: unknown[]) => unknown to manually trigger a fetch */\n  fetch: () => Promise<void>;\n  /** (...args: unknown[]) => unknown to reset the hook state */\n  reset: () => void;\n  /** Last time data was fetched successfully */\n  lastFetched: number | null;\n  /** Number of retries attempted */\n  retryCount: number;\n}\n\n/**\n * Creates a reusable data fetching hook with standardized loading, error, and data states\n * @param fetchFn The function that fetches data\n * @param defaultOptions Default options for the hook\n * @returns A React hook that manages data fetching\n */\nexport function createDataFetchHook<T, P extends any[] = []>(\n  fetchFn: (...args: P) => Promise<T>,\n  defaultOptions: DataFetchOptions = {}\n) {\n  return (...args: P): DataFetchResult<T> => {\n    const [data, setData] = useState<T | null>(null);\n    const [isLoading, setIsLoading] = useState<boolean>(defaultOptions.fetchOnMount !== false);\n    const [error, setError] = useState<Error | null>(null);\n    const [lastFetched, setLastFetched] = useState<number | null>(null);\n    const [retryCount, setRetryCount] = useState<number>(0);\n\n    // Determine if fetch is enabled\n    const enabled = defaultOptions.enabled !== false;\n\n    // Memoized fetch function\n    const fetch = useCallback(async () => {\n      if (!enabled) return;\n\n      try {\n        if (defaultOptions.resetOnFetch) {\n          setData(null);\n        }\n\n        setIsLoading(true);\n        setError(null);\n\n        const result = await fetchFn(...args);\n\n        setData(result);\n        setLastFetched(Date.now());\n        setRetryCount(0);\n      } catch (err) {\n        setError(err instanceof Error ? err : new Error(String(err)));\n        \n        // Log error to the error service\n        errorLoggingService.logError(\n          err instanceof Error ? err : new Error(String(err)),\n          ErrorType.NETWORK,\n          undefined,\n          { hook: 'dataFetch', args: JSON.stringify(args) }\n        );\n\n        // Retry logic\n        if (defaultOptions.maxRetries && retryCount < defaultOptions.maxRetries) {\n          setRetryCount(current => current + 1);\n          \n          // Exponential backoff\n          const backoffTime = Math.min(1000 * Math.pow(2, retryCount), 30000);\n          \n          setTimeout(() => {\n            fetch();\n          }, backoffTime);\n        }\n      } finally {\n        setIsLoading(false);\n      }\n    }, [enabled, ...args]);\n\n    // Reset function\n    const reset = useCallback(() => {\n      setData(null);\n      setIsLoading(false);\n      setError(null);\n      setLastFetched(null);\n      setRetryCount(0);\n    }, []);\n\n    // Handle automatic fetching on mount\n    useEffect(() => {\n      let mounted = true;\n      let intervalId: NodeJS.Timeout | null = null;\n\n      if (defaultOptions.fetchOnMount !== false && enabled) {\n        fetch();\n      }\n\n      // Set up refetch interval if specified\n      if (defaultOptions.refetchInterval && enabled) {\n        intervalId = setInterval(() => {\n          if (mounted) {\n            fetch();\n          }\n        }, defaultOptions.refetchInterval);\n      }\n\n      return () => {\n        mounted = false;\n        if (intervalId) {\n          clearInterval(intervalId);\n        }\n      };\n    }, [fetch, enabled]);\n\n    return {\n      data,\n      isLoading,\n      error,\n      fetch,\n      reset,\n      lastFetched,\n      retryCount\n    };\n  };\n}\n\n/**\n * Example usage:\n * \n * ```typescript\n * // Define the hook\n * const useUserData = createDataFetchHook(\n *   (userId: string) => fetch(`/api/users/${userId}`).then(res => res.json()),\n *   { fetchOnMount: true }\n * );\n * \n * // Use in component\n * function UserProfile({ userId }) {\n *   const { data, isLoading, error, fetch } = useUserData(userId);\n *   \n *   if (isLoading) return <Loading />;\n *   if (error) return <Error message={error.message} />;\n *   \n *   return (\n *     <div>\n *       <h1>{data.name}</h1>\n *       <button onClick={fetch}>Refresh</button>\n *     </div>\n *   );\n * }\n * ```\n */",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/factory/createLifecycleHook.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/factory/createStateHook.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 6,
        "column": 46,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 6,
        "endColumn": 49,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [144, 147], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [144, 147], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 14,
        "column": 36,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 14,
        "endColumn": 39,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [277, 280], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [277, 280], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useState, useMemo, useCallback, useEffect } from 'react';\n\n/**\n * Action creator type\n */\nexport type ActionCreator<TState, TPayload = any> = (\n  state: TState,\n  payload: TPayload\n) => Partial<TState>;\n\n/**\n * Bound action type\n */\nexport type BoundAction<TPayload = any> = (payload: TPayload) => void;\n\n/**\n * State hook options\n */\nexport interface StateHookOptions<TState> {\n  /** (...args: unknown[]) => unknown to run on state initialization */\n  onInit?: (state: TState) => void;\n  /** (...args: unknown[]) => unknown to run on state cleanup */\n  onCleanup?: (state: TState) => void;\n  /** Whether to persist state in localStorage */\n  persist?: boolean;\n  /** Key to use for localStorage persistence */\n  persistKey?: string;\n  /** Custom state equality function */\n  areEqual?: (prev: TState, next: TState) => boolean;\n  /** Initial state override */\n  initialStateOverride?: TState | (() => TState);\n}\n\n/**\n * Creates a reusable state management hook with actions\n * @param initialState The initial state or a function that returns the initial state\n * @param actions An object of action creators\n * @param options Options for the hook\n * @returns A hook that provides state and bound actions\n */\nexport function createStateHook<\n  TState extends Record<string, unknown>,\n  TActions extends Record<string, ActionCreator<TState, unknown>>\n>(\n  initialState: TState | (() => TState),\n  actions: TActions,\n  options: StateHookOptions<TState> = {}\n) {\n  // Type for the returned actions object\n  type BoundActions = {\n    [K in keyof TActions]: BoundAction<Parameters<TActions[K]>[1]>;\n  };\n\n  return () => {\n    // Initialize state, handling both function and object initial states\n    const getInitialState = useCallback(() => {\n      // Check if we should use override\n      if (options.initialStateOverride !== undefined) {\n        return typeof options.initialStateOverride === 'function'\n          ? (options.initialStateOverride as () => TState)()\n          : options.initialStateOverride;\n      }\n\n      // Otherwise use the default initial state\n      const defaultState = typeof initialState === 'function'\n        ? (initialState as () => TState)()\n        : initialState;\n\n      // If persistence is enabled, try to load from localStorage\n      if (options.persist && options.persistKey) {\n        try {\n          const savedState = localStorage.getItem(options.persistKey);\n          if (savedState) {\n            return { ...defaultState, ...JSON.parse(savedState) };\n          }\n        } catch (error) {\n          console.error('Failed to load persisted state:', error);\n        }\n      }\n\n      return defaultState;\n    }, []);\n\n    // Initialize state\n    const [state, setState] = useState<TState>(getInitialState);\n\n    // Create memoized bound actions\n    const boundActions = useMemo(() => {\n      const result = {} as BoundActions;\n\n      for (const [key, actionCreator] of Object.entries(actions)) {\n        result[key as keyof TActions] = (payload) => {\n          setState((currentState) => {\n            const updates = actionCreator(currentState, payload);\n            \n            // If updates is empty, return the current state\n            if (!updates || Object.keys(updates).length === 0) {\n              return currentState;\n            }\n            \n            const newState = { ...currentState, ...updates };\n            \n            // If custom equality function is provided, check if state actually changed\n            if (options.areEqual && options.areEqual(currentState, newState)) {\n              return currentState;\n            }\n            \n            // Persist state if enabled\n            if (options.persist && options.persistKey) {\n              try {\n                localStorage.setItem(options.persistKey, JSON.stringify(newState));\n              } catch (error) {\n                console.error('Failed to persist state:', error);\n              }\n            }\n            \n            return newState;\n          });\n        };\n      }\n\n      return result;\n    }, []);\n\n    // Reset action\n    const reset = useCallback(() => {\n      setState(getInitialState());\n      \n      // Clear persisted state if applicable\n      if (options.persist && options.persistKey) {\n        try {\n          localStorage.removeItem(options.persistKey);\n        } catch (error) {\n          console.error('Failed to clear persisted state:', error);\n        }\n      }\n    }, [getInitialState]);\n\n    // Add reset to bound actions\n    const actionsWithReset = useMemo(() => ({\n      ...boundActions,\n      reset\n    }), [boundActions, reset]);\n\n    // Run initialization and cleanup\n    useEffect(() => {\n      if (options.onInit) {\n        options.onInit(state);\n      }\n      \n      return () => {\n        if (options.onCleanup) {\n          options.onCleanup(state);\n        }\n      };\n    }, []);\n\n    return [state, actionsWithReset] as const;\n  };\n}\n\n/**\n * Example usage:\n * \n * ```typescript\n * // Define the state type\n * interface CounterState {\n *   count: number;\n *   lastUpdated: number | null;\n * }\n * \n * // Define action creators\n * const counterActions = {\n *   increment: (state: CounterState, step: number = 1) => ({\n *     count: state.count + step,\n *     lastUpdated: Date.now()\n *   }),\n *   decrement: (state: CounterState, step: number = 1) => ({\n *     count: state.count - step,\n *     lastUpdated: Date.now()\n *   }),\n *   reset: (state: CounterState) => ({\n *     count: 0,\n *     lastUpdated: Date.now()\n *   })\n * };\n * \n * // Create the hook\n * const useCounter = createStateHook<CounterState, typeof counterActions>(\n *   { count: 0, lastUpdated: null },\n *   counterActions,\n *   { persist: true, persistKey: 'app-counter' }\n * );\n * \n * // Use in component\n * function Counter() {\n *   const [state, actions] = useCounter();\n *   \n *   return (\n *     <div>\n *       <p>Count: {state.count}</p>\n *       <button onClick={() => actions.increment()}>Increment</button>\n *       <button onClick={() => actions.decrement()}>Decrement</button>\n *       <button onClick={actions.reset}>Reset</button>\n *     </div>\n *   );\n * }\n * ```\n */",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/factory/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/game/useAnimation.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/game/useAssets.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/game/useGameState.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/game/useGlobalEvents.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/game/useScalingSystem.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/modules/useModuleAutomation.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/modules/useModuleEvents.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/modules/useModuleState.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 222,
        "column": 20,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 222,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6312, 6315], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6312, 6315], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 234,
        "column": 20,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 234,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6699, 6702], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6699, 6702], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/modules/useModuleStatus.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/modules/useModuleUpgrade.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/modules/useSubModules.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/performance/useSessionPerformance.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 83,
        "column": 70,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 83,
        "endColumn": 73,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2387, 2390], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2387, 2390], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * useSessionPerformance\n *\n * A React hook for tracking component performance and user interactions.\n * Provides access to the SessionPerformanceTracker for anonymous telemetry.\n */\n\nimport { useEffect, useRef } from 'react';\nimport {\n  SessionPerformanceTracker,\n  TelemetryOptions,\n  UserInteractionData,\n} from '../../services/telemetry/SessionPerformanceTracker';\n\n// Create a singleton instance of the tracker to be shared across the application\nlet globalTracker: SessionPerformanceTracker | null = null;\n\n/**\n * Initialize the global performance tracker\n */\nexport function initializeSessionPerformanceTracker(options?: Partial<TelemetryOptions>): void {\n  if (!globalTracker) {\n    globalTracker = new SessionPerformanceTracker(options);\n  }\n}\n\n/**\n * React hook for tracking component performance\n */\nexport default function useSessionPerformance(componentId: string) {\n  const trackerRef = useRef<SessionPerformanceTracker | null>(null);\n\n  // Initialize the tracker on the first render\n  useEffect(() => {\n    // Create global instance if it doesn't exist yet\n    if (!globalTracker) {\n      initializeSessionPerformanceTracker();\n    }\n\n    trackerRef.current = globalTracker;\n\n    // Start timing the component load\n    if (trackerRef.current) {\n      trackerRef.current.startComponentLoadTimer(componentId);\n    }\n\n    // When component mounts, record completion time\n    const tracker = trackerRef.current;\n    if (tracker) {\n      // Use queueMicrotask to ensure we measure after initial render\n      queueMicrotask(() => {\n        tracker.endComponentLoadTimer(componentId);\n      });\n    }\n\n    return () => {\n      // Optionally track unmount time or other component lifecycle events\n    };\n  }, [componentId]);\n\n  /**\n   * Track a custom user interaction within the component\n   */\n  const trackInteraction = (\n    interactionType: 'click' | 'hover' | 'scroll' | 'keypress' | 'custom',\n    details: Partial<UserInteractionData> = {}\n  ) => {\n    if (!trackerRef.current) return;\n\n    trackerRef.current.trackUserInteraction({\n      interactionType,\n      targetComponent: componentId,\n      timestamp: Date.now(),\n      responseTime: 0, // Will be populated with measured time\n      successful: true,\n      ...details,\n    });\n  };\n\n  /**\n   * Create a performance-tracked event handler\n   */\n  const withPerformanceTracking = <T extends (...args: unknown[]) => any>(\n    handler: T,\n    interactionType: 'click' | 'hover' | 'scroll' | 'keypress' | 'custom' = 'click'\n  ): ((...args: Parameters<T>) => ReturnType<T>) => {\n    return (...args: Parameters<T>) => {\n      const startTime = performance.now();\n\n      try {\n        const result = handler(...args);\n\n        // For promise-returning handlers, track completion when promise resolves\n        if (result instanceof Promise) {\n          result\n            .then(() => {\n              if (trackerRef.current) {\n                trackerRef.current.trackUserInteraction({\n                  interactionType,\n                  targetComponent: componentId,\n                  timestamp: Date.now(),\n                  responseTime: performance.now() - startTime,\n                  successful: true,\n                });\n              }\n            })\n            .catch(() => {\n              if (trackerRef.current) {\n                trackerRef.current.trackUserInteraction({\n                  interactionType,\n                  targetComponent: componentId,\n                  timestamp: Date.now(),\n                  responseTime: performance.now() - startTime,\n                  successful: false,\n                });\n              }\n            });\n        } else {\n          // For synchronous handlers, track completion immediately\n          if (trackerRef.current) {\n            trackerRef.current.trackUserInteraction({\n              interactionType,\n              targetComponent: componentId,\n              timestamp: Date.now(),\n              responseTime: performance.now() - startTime,\n              successful: true,\n            });\n          }\n        }\n\n        return result;\n      } catch (error) {\n        // Track failed interactions\n        if (trackerRef.current) {\n          trackerRef.current.trackUserInteraction({\n            interactionType,\n            targetComponent: componentId,\n            timestamp: Date.now(),\n            responseTime: performance.now() - startTime,\n            successful: false,\n          });\n        }\n        throw error;\n      }\n    };\n  };\n\n  return {\n    trackInteraction,\n    withPerformanceTracking,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/resources/useResourceManagement.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/resources/useResourceState.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/resources/useResourceSystem.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/resources/useResourceTracking.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/services/useService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/ships/useShipActions.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/ships/useShipClassManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/ships/useShipEffects.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/ui/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/ui/useComponentLifecycle.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/ui/useComponentProfiler.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/ui/useComponentRegistration.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'renderTime' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 100,
        "column": 26,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 100,
        "endColumn": 36
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { ResourceType } from \"./../../types/resources/ResourceTypes\";\nimport { useEffect, useRef } from 'react';\nimport { componentRegistryService } from '../../services/ComponentRegistryService';\nimport { useComponentProfiler } from './useComponentProfiler';\n\n/**\n * Options for component registration\n */\nexport interface ComponentRegistrationOptions {\n  /**\n   * Type of the component (e.g., 'ResourceDisplay', 'ModuleCard')\n   */\n  type: ResourceType;\n\n  /**\n   * Event types this component is interested in receiving\n   */\n  eventSubscriptions: string[];\n\n  /**\n   * Update priority for this component\n   * - high: Component updates are critical for game functionality\n   * - medium: Component updates are important but not critical\n   * - low: Component updates can be delayed if necessary\n   */\n  updatePriority?: 'high' | 'medium' | 'low';\n}\n\n/**\n * Hook that registers a React component with the ComponentRegistryService\n *\n * This hook:\n * 1. Generates a unique ID for the component\n * 2. Registers the component with the registry\n * 3. Sets up profiling to measure render times\n * 4. Automatically cleans up on unmount\n *\n * @param options Component registration options\n * @returns The generated component ID\n *\n * @example\n * function ResourceDisplay({ resourceType }) {\n *   // Register component with the system\n *   useComponentRegistration({\n *     type: 'ResourceDisplay',\n *     eventSubscriptions: ['RESOURCE_PRODUCED', 'RESOURCE_CONSUMED'],\n *     updatePriority: 'high'\n *   });\n *\n *   // Component implementation...\n * }\n */\nexport function useComponentRegistration(options: ComponentRegistrationOptions): string {\n  const componentId = useRef<string>('');\n  const profiler = useComponentProfiler(options.type);\n\n  useEffect(() => {\n    // Register component with registry\n    const id = componentRegistryService.registerComponent({\n      type: options.type,\n      eventSubscriptions: options.eventSubscriptions,\n      updatePriority: options.updatePriority || 'medium',\n    });\n\n    componentId.current = id;\n\n    // Track render with profiler\n    if (profiler) {\n      const renderTime = profiler.metrics.lastRenderTime;\n      if (renderTime !== undefined) {\n        componentRegistryService.trackRender(id);\n      }\n    }\n\n    // Return cleanup function\n    return () => {\n      componentRegistryService.unregisterComponent(id);\n    };\n  }, [options.type, options.updatePriority, profiler]);\n\n  return componentId.current;\n}\n\n/**\n * Hook that registers a component and provides a method to manually update its metrics\n *\n * This is useful for components that need to manually control when metrics are updated,\n * such as those with complex rendering logic or conditional renders.\n *\n * @param options Component registration options\n * @returns An object containing the component ID and an update function\n */\nexport function useComponentRegistrationWithManualUpdates(options: ComponentRegistrationOptions): {\n  componentId: string;\n  updateMetrics: (renderTime: number) => void;\n} {\n  const componentId = useComponentRegistration(options);\n\n  // Function to manually update metrics\n  const updateMetrics = (renderTime: number) => {\n    componentRegistryService.trackRender(componentId);\n  };\n\n  return { componentId, updateMetrics };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/ui/useDebugOverlay.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/ui/useProfilingOverlay.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/ui/useTooltip.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/ui/useVPR.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/ui/useVPRInteractivity.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/ui/useVPRSystem.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/useGPUCompute.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/useMemoryManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/usePaginatedData.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/useRealTimeData.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/useStreamedData.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/useTypedApi.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/useWebGL.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/useWorker.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'onProgress' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 22,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 22,
        "endColumn": 13
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useCallback, useEffect, useState } from 'react';\nimport { workerService } from '../services/WorkerService';\nimport { useService } from './services/useService';\n\ninterface UseWorkerOptions {\n  type: string;\n  priority?: 'HIGH' | 'MEDIUM' | 'LOW';\n  onProgress?: (progress: number) => void;\n}\n\ninterface UseWorkerResult<T> {\n  execute: (data: unknown) => Promise<T>;\n  cancel: () => void;\n  isRunning: boolean;\n  progress: number;\n  error: Error | null;\n}\n\nexport function useWorker<T>({\n  type,\n  priority = 'MEDIUM',\n  onProgress,\n}: UseWorkerOptions): UseWorkerResult<T> {\n  const { service } = useService<typeof workerService>('worker');\n  const [currentTaskId, setCurrentTaskId] = useState<string | null>(null);\n  const [isRunning, setIsRunning] = useState(false);\n  const [progress, setProgress] = useState(0);\n  const [error, setError] = useState<Error | null>(null);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (currentTaskId) {\n        service?.cancelTask(currentTaskId);\n      }\n    };\n  }, [currentTaskId, service]);\n\n  const execute = useCallback(\n    async (data: unknown): Promise<T> => {\n      if (!service) {\n        throw new Error('Worker service not available');\n      }\n\n      setIsRunning(true);\n      setProgress(0);\n      setError(null);\n\n      try {\n        const result = await service.submitTask<T>(type, data, priority);\n        return result;\n      } catch (err) {\n        const error = err instanceof Error ? err : new Error(String(err));\n        setError(error);\n        throw error;\n      } finally {\n        setIsRunning(false);\n        setCurrentTaskId(null);\n      }\n    },\n    [service, type, priority]\n  );\n\n  const cancel = useCallback(() => {\n    if (currentTaskId && service) {\n      service.cancelTask(currentTaskId);\n      setIsRunning(false);\n      setCurrentTaskId(null);\n    }\n  }, [currentTaskId, service]);\n\n  return {\n    execute,\n    cancel,\n    isRunning,\n    progress,\n    error,\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/visualization/useChartCoordination.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/initialization/automationSystemInit.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 18,
        "column": 31,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 18,
        "endColumn": 34,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [929, 932], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [929, 932], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/initialization/eventSystemInit.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/initialization/gameSystemsIntegration.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/initialization/moduleFrameworkInit.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/initialization/moduleUpgradeInit.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/initialization/serviceRegistration.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/ai/ResourceConsumptionPredictor.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/ai/behaviorTree.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/ai/shipBehavior.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/ai/shipMovement.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/automation/ConditionChecker.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/contexts/BaseContext.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/events/BaseEventEmitter.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/events/BaseTypedEventEmitter.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'event' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 64,
        "column": 42,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 64,
        "endColumn": 47
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * BaseTypedEventEmitter.ts\n *\n * This file provides a base implementation of the ITypedEventEmitter interface\n * that manager classes can extend to gain typed event emitting capabilities.\n */\n\nimport { ITypedEventEmitter } from '../../types/events/EventEmitterInterface';\nimport { TypedEventEmitter } from './EventBus';\n\n/**\n * Base class for all typed event emitters in the system\n * Manager classes should extend this class to gain typed event emitting capabilities\n */\nexport class BaseTypedEventEmitter<T extends Record<string, unknown>>\n  extends TypedEventEmitter<T>\n  implements ITypedEventEmitter<T>\n{\n  /**\n   * Creates a new BaseTypedEventEmitter\n   */\n  constructor() {\n    super();\n  }\n\n  /**\n   * Emit an event\n   *\n   * @param event The event name (key of T)\n   * @param data The data to pass to the event handlers\n   */\n  public emit<K extends keyof T>(event: K, data: T[K]): void {\n    // Call the protected emit method from the parent class\n    super.emit(event, data);\n  }\n\n  /**\n   * Remove all event listeners\n   *\n   * @param event Optional event name to remove listeners for. If not provided, all listeners are removed.\n   */\n  public removeAllListeners<K extends keyof T>(event?: K): void {\n    if (event) {\n      // Clear listeners for a specific event\n      const handlers = this.getHandlers(event);\n      if (handlers) {\n        handlers.forEach(handler => {\n          this.off(event, handler);\n        });\n      }\n    } else {\n      // Clear all listeners\n      this.clearAllListeners();\n    }\n  }\n\n  /**\n   * Get all handlers for a specific event\n   * This is a helper method used by removeAllListeners\n   *\n   * @param event The event name\n   * @returns Array of handlers for the event\n   */\n  private getHandlers<K extends keyof T>(event: K): Array<(data: T[K]) => void> {\n    // This is a simplified implementation\n    // In a real implementation, we would track all handlers\n    return [];\n  }\n\n  /**\n   * Subscribe to an event (alias for on)\n   *\n   * @param event The event name (key of T)\n   * @param callback The function to call when the event is emitted\n   * @returns A function to unsubscribe the handler\n   */\n  public subscribe<K extends keyof T>(event: K, callback: (data: T[K]) => void): () => void {\n    return this.on(event, callback);\n  }\n\n  /**\n   * Unsubscribe from an event (alias for off)\n   *\n   * @param event The event name (key of T)\n   * @param callback The handler function to remove\n   */\n  public unsubscribe<K extends keyof T>(event: K, callback: (data: T[K]) => void): void {\n    this.off(event, callback);\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/events/EventBatcher.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/events/EventBus.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 729,
        "column": 63,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 729,
        "endColumn": 66,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [21577, 21580], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [21577, 21580], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 734,
        "column": 26,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 734,
        "endColumn": 29,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [21807, 21810], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [21807, 21810], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/events/EventBusTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/events/EventEmitter.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/events/ModuleEventBus.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/events/UnifiedEventSystem.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/managers/BaseManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/managers/ServiceRegistry.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/modules/ModuleEvents.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'ResourceType' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 1,
        "column": 10,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 1,
        "endColumn": 22
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { ResourceType } from \"./../../types/resources/ResourceTypes\";\nimport { ModuleType } from '../../types/buildings/ModuleTypes';\n\n/**\n * Represents all possible event types that can be emitted by modules in the system.\n *\n * These event types are categorized by their functional area:\n * - Lifecycle events: Monitor the creation, attachment, and activation of modules\n * - Attachment events: Track the process of attaching modules to buildings or other modules\n * - Resource events: Monitor resource production, consumption, and transfers\n * - Automation events: Track automation rule execution and cycles\n * - Status events: Report changes in module status and errors\n * - Mission events: Track mission progress and completions\n * - Sub-module events: Monitor the lifecycle of sub-modules\n * - Combat events: Track combat-related updates\n * - Tech events: Monitor technology unlocks and updates\n *\n * @typedef {string} ModuleEventType\n */\nexport type ModuleEventType =\n  // Lifecycle events\n  | 'MODULE_CREATED'\n  | 'MODULE_ATTACHED'\n  | 'MODULE_DETACHED'\n  | 'MODULE_UPGRADED'\n  | 'MODULE_ACTIVATED'\n  | 'MODULE_DEACTIVATED'\n  | 'MODULE_UPDATED'\n  // Attachment events\n  | 'ATTACHMENT_STARTED'\n  | 'ATTACHMENT_CANCELLED'\n  | 'ATTACHMENT_COMPLETED'\n  | 'ATTACHMENT_PREVIEW_SHOWN'\n  // Resource events\n  | 'RESOURCE_PRODUCED'\n  | 'RESOURCE_CONSUMED'\n  | 'RESOURCE_TRANSFERRED'\n  | 'RESOURCE_PRODUCTION_REGISTERED'\n  | 'RESOURCE_PRODUCTION_UNREGISTERED'\n  | 'RESOURCE_CONSUMPTION_REGISTERED'\n  | 'RESOURCE_CONSUMPTION_UNREGISTERED'\n  | 'RESOURCE_FLOW_REGISTERED'\n  | 'RESOURCE_FLOW_UNREGISTERED'\n  | 'RESOURCE_SHORTAGE'\n  | 'RESOURCE_UPDATED'\n  | 'RESOURCE_DISCOVERED'\n  // Automation events\n  | 'AUTOMATION_STARTED'\n  | 'AUTOMATION_STOPPED'\n  | 'AUTOMATION_CYCLE_COMPLETE'\n  // Status events\n  | 'STATUS_CHANGED'\n  | 'ERROR_OCCURRED'\n  // Mission events\n  | 'MISSION_STARTED'\n  | 'MISSION_COMPLETED'\n  | 'MISSION_FAILED'\n  | 'MISSION_PROGRESS_UPDATED'\n  | 'MISSION_REWARD_CLAIMED'\n  // Sub-module events\n  | 'SUB_MODULE_CREATED'\n  | 'SUB_MODULE_ATTACHED'\n  | 'SUB_MODULE_DETACHED'\n  | 'SUB_MODULE_UPGRADED'\n  | 'SUB_MODULE_ACTIVATED'\n  | 'SUB_MODULE_DEACTIVATED'\n  | 'SUB_MODULE_EFFECT_APPLIED'\n  | 'SUB_MODULE_EFFECT_REMOVED'\n  // Combat events\n  | 'COMBAT_UPDATED'\n  // Tech events\n  | 'TECH_UNLOCKED'\n  | 'TECH_UPDATED';\n\n/**\n * Represents an event emitted by a module in the system.\n *\n * The ModuleEvent interface defines the structure of events that flow through the\n * event system. Each event must include a type, moduleId, moduleType, and timestamp.\n * Additional data can be included in the optional data property.\n *\n * @interface ModuleEvent\n * @property {ModuleEventType} type - The type of event, indicating what action or state change occurred\n * @property {string} moduleId - Unique identifier of the module that emitted the event\n * @property {ModuleType} moduleType - Type of the module that emitted the event (e.g., 'production', 'storage')\n * @property {number} timestamp - Unix timestamp when the event occurred (milliseconds since epoch)\n * @property {Record<string, unknown>} [data] - Optional additional data relevant to the event\n *\n * @example\n * // Example of a module created event\n * const event: ModuleEvent = {\n *   type: 'MODULE_CREATED',\n *   moduleId: 'mining-module-1',\n *   moduleType: 'production',\n *   timestamp: Date.now(),\n *   data: {\n *     location: { x: 100, y: 200 },\n *     createdBy: 'player'\n *   }\n * };\n */\nexport interface ModuleEvent {\n  type: ModuleEventType;\n  moduleId: string;\n  moduleType: ModuleType;\n  timestamp: number;\n  data?: Record<string, unknown>;\n}\n\n/**\n * Function signature for event listeners that handle module events.\n *\n * @callback ModuleEventListener\n * @param {ModuleEvent} event - The event object containing information about what occurred\n * @returns {void}\n */\ntype ModuleEventListener = (event: ModuleEvent) => void;\n\n/**\n * Event bus that facilitates module communication through events.\n *\n * The ModuleEventBus provides publish-subscribe functionality for module events,\n * allowing modules to communicate with each other without direct dependencies.\n * It manages event listeners, dispatches events to appropriate listeners,\n * and maintains a history of events for analysis and debugging.\n *\n * @class ModuleEventBus\n */\nexport class ModuleEventBus {\n  /**\n   * Map of event types to sets of event listeners.\n   * @private\n   */\n  private listeners: Map<ModuleEventType, Set<ModuleEventListener>>;\n\n  /**\n   * Array containing event history, with the most recent events at the end.\n   * @private\n   */\n  private history: ModuleEvent[];\n\n  /**\n   * Maximum number of events to keep in history.\n   * @private\n   */\n  private maxHistorySize: number;\n\n  /**\n   * Creates a new ModuleEventBus instance.\n   *\n   * @param {number} [maxHistorySize=1000] - Maximum number of events to keep in history\n   */\n  constructor(maxHistorySize = 1000) {\n    this.listeners = new Map();\n    this.history = [];\n    this.maxHistorySize = maxHistorySize;\n  }\n\n  /**\n   * Subscribes to a specific type of module event.\n   *\n   * This method registers a listener function to be called whenever an event\n   * of the specified type is emitted. It returns an unsubscribe function that\n   * can be called to remove the listener.\n   *\n   * @param {ModuleEventType} type - The type of event to subscribe to\n   * @param {ModuleEventListener} listener - The function to call when events of this type occur\n   * @returns {Function} An unsubscribe function that, when called, removes the listener\n   *\n   * @example\n   * // Subscribe to MODULE_CREATED events\n   * const unsubscribe = moduleEventBus.subscribe('MODULE_CREATED', (event) => {\n   *   console.warn(`New module created: ${event.moduleId}`);\n   * });\n   *\n   * // Later, to stop receiving events\n   * unsubscribe();\n   */\n  subscribe(type: ModuleEventType, listener: ModuleEventListener): () => void {\n    if (!this.listeners.has(type)) {\n      this.listeners.set(type, new Set());\n    }\n\n    this.listeners.get(type)!.add(listener);\n\n    // Return unsubscribe function\n    return () => {\n      const typeListeners = this.listeners.get(type);\n      if (typeListeners) {\n        typeListeners.delete(listener);\n        if (typeListeners.size === 0) {\n          this.listeners.delete(type);\n        }\n      }\n    };\n  }\n\n  /**\n   * Emits an event to all subscribed listeners.\n   *\n   * This method adds the event to the event history and notifies all listeners\n   * subscribed to the event's type. If an error occurs in a listener, it is\n   * caught and logged, allowing other listeners to continue receiving the event.\n   *\n   * @param {ModuleEvent} event - The event to emit\n   * @returns {void}\n   *\n   * @example\n   * // Emit a MODULE_ACTIVATED event\n   * moduleEventBus.emit({\n   *   type: 'MODULE_ACTIVATED',\n   *   moduleId: 'mining-module-1',\n   *   moduleType: 'production',\n   *   timestamp: Date.now(),\n   *   data: { activatedBy: 'player' }\n   * });\n   */\n  emit(event: ModuleEvent): void {\n    // Add to history\n    this.history.push(event);\n    if (this.history.length > this.maxHistorySize) {\n      this.history.shift();\n    }\n\n    // Notify listeners\n    const typeListeners = this.listeners.get(event.type);\n    if (typeListeners) {\n      typeListeners.forEach(listener => {\n        try {\n          listener(event);\n        } catch (error) {\n          console.error('Error in module event listener:', error);\n        }\n      });\n    }\n  }\n\n  /**\n   * Retrieves the complete event history.\n   *\n   * Returns a copy of the entire event history array, preserving the original\n   * history in the event bus. Events are ordered from oldest (index 0) to newest.\n   *\n   * @returns {ModuleEvent[]} Array containing all events in the history\n   *\n   * @example\n   * // Get complete event history and count events by type\n   * const history = moduleEventBus.getHistory();\n   * const eventCounts = history.reduce((counts, event) => {\n   *   counts[event.type] = (counts[event.type] || 0) + 1;\n   *   return counts;\n   * }, {});\n   * console.warn('Event counts:', eventCounts);\n   */\n  getHistory(): ModuleEvent[] {\n    return [...this.history];\n  }\n\n  /**\n   * Retrieves event history for a specific module.\n   *\n   * Filters the event history to return only events related to the specified module ID.\n   * Returns a copy of the filtered events, ordered from oldest to newest.\n   *\n   * @param {string} moduleId - ID of the module to get history for\n   * @returns {ModuleEvent[]} Array containing events for the specified module\n   *\n   * @example\n   * // Get history for a specific module and analyze its lifecycle\n   * const moduleHistory = moduleEventBus.getModuleHistory('mining-module-1');\n   * const creationEvent = moduleHistory.find(event => event.type === 'MODULE_CREATED');\n   * if (creationEvent) {\n   *   console.warn(`Module created at: ${new Date(creationEvent.timestamp).toLocaleString()}`);\n   * }\n   */\n  getModuleHistory(moduleId: string): ModuleEvent[] {\n    return this.history.filter(event => event.moduleId === moduleId);\n  }\n\n  /**\n   * Retrieves event history for a specific event type.\n   *\n   * Filters the event history to return only events of the specified type.\n   * Returns a copy of the filtered events, ordered from oldest to newest.\n   *\n   * @param {ModuleEventType} type - Type of events to retrieve\n   * @returns {ModuleEvent[]} Array containing events of the specified type\n   *\n   * @example\n   * // Get all resource shortage events and identify affected resources\n   * const shortages = moduleEventBus.getEventTypeHistory('RESOURCE_SHORTAGE');\n   * const affectedResources = shortages.map(event => event.data?.resourceType).filter(Boolean);\n   * console.warn('Resources with shortages:', affectedResources);\n   */\n  getEventTypeHistory(type: ModuleEventType): ModuleEvent[] {\n    return this.history.filter(event => event.type === type);\n  }\n\n  /**\n   * Clears the entire event history.\n   *\n   * This method removes all events from the history array. This can be useful\n   * for managing memory usage or resetting the state for testing.\n   *\n   * @returns {void}\n   *\n   * @example\n   * // Clear event history at the start of a new game session\n   * moduleEventBus.clearHistory();\n   */\n  clearHistory(): void {\n    this.history = [];\n  }\n}\n\n/**\n * Singleton instance of the ModuleEventBus.\n *\n * This exported instance should be used throughout the application to ensure\n * that all modules communicate through the same event bus.\n *\n * @type {ModuleEventBus}\n *\n * @example\n * import { moduleEventBus } from '../../lib/modules/ModuleEvents';\n *\n * // Subscribe to events\n * moduleEventBus.subscribe('MODULE_ACTIVATED', handleModuleActivated);\n *\n * // Emit events\n * moduleEventBus.emit({\n *   type: 'MODULE_ACTIVATED',\n *   moduleId: 'mining-module-1',\n *   moduleType: 'production',\n *   timestamp: Date.now()\n * });\n */\nexport const moduleEventBus = new ModuleEventBus();\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/optimization/EntityPool.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/optimization/QuadTree.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/optimization/RenderBatcher.d.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/optimization/RenderBatcher.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/optimization/WebGLShaderManager.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'deltaTime' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 690,
        "column": 13,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 690,
        "endColumn": 22
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { Position } from '../../types/core/Position';\n\n/**\n * Represents a WebGL shader uniform\n */\nexport interface ShaderUniform {\n  type: 'float' | 'vec2' | 'vec3' | 'vec4' | 'int' | 'bool' | 'sampler2D';\n  value: number | number[] | boolean | WebGLTexture | null;\n}\n\n/**\n * Supported shader types for data visualization\n */\nexport enum DataVisualizationShaderType {\n  HEATMAP = 'heatmap',\n  CONTOUR = 'contour',\n  POINT_CLUSTER = 'pointCluster',\n  HIGHLIGHT = 'highlight',\n  DENSITY = 'density',\n  FLOW = 'flow',\n  TRANSITION = 'transition',\n  CUSTOM = 'custom',\n}\n\n/**\n * Configuration for data visualization shaders\n */\nexport interface DataVisualizationShaderConfig {\n  type: DataVisualizationShaderType;\n  colors: string[];\n  intensity?: number;\n  resolution?: [number, number];\n  animate?: boolean;\n  animationSpeed?: number;\n  highlightRange?: [number, number];\n  dataRange?: [number, number];\n  dataPoints?: Float32Array;\n  customUniforms?: Record<string, ShaderUniform>;\n  customVertexShader?: string;\n  customFragmentShader?: string;\n}\n\n/**\n * WebGL Shader Manager for data visualization effects\n *\n * This utility manages WebGL shaders for data visualization, including\n * heatmaps, contour plots, point clustering, and data highlighting effects.\n */\nexport class WebGLShaderManager {\n  private gl: WebGLRenderingContext | null = null;\n  private canvas: HTMLCanvasElement | null = null;\n  private programs: Map<string, WebGLProgram> = new Map();\n  private shaders: Map<string, WebGLShader> = new Map();\n  private textures: Map<string, WebGLTexture> = new Map();\n  private framebuffers: Map<string, WebGLFramebuffer> = new Map();\n  private animationFrame: number | null = null;\n  private _lastTimestamp: number = 0;\n\n  /**\n   * Initialize the WebGL context\n   */\n  public initialize(canvas: HTMLCanvasElement): boolean {\n    try {\n      this.canvas = canvas;\n      this.gl = canvas.getContext('webgl', {\n        alpha: true,\n        premultipliedAlpha: false,\n        antialias: true,\n        powerPreference: 'high-performance',\n      });\n\n      if (!this.gl) {\n        console.error('[WebGLShaderManager] WebGL not supported');\n        return false;\n      }\n\n      this.initializeDefaultShaders();\n      console.warn('[WebGLShaderManager] Initialized successfully');\n      return true;\n    } catch (error) {\n      console.error('[WebGLShaderManager] Initialization failed', error);\n      return false;\n    }\n  }\n\n  /**\n   * Initialize default shaders for each visualization type\n   */\n  private initializeDefaultShaders(): void {\n    // Set up standard shaders for each visualization type\n    Object.values(DataVisualizationShaderType).forEach(type => {\n      if (typeof type === 'string') {\n        // Create a default shader with a predefined color array\n        this.createDataVisualizationShader({\n          type: type as DataVisualizationShaderType,\n          colors: [\n            '#3366cc', // Blue\n            '#cc6633', // Orange\n            '#33cc66', // Green\n            '#cc33cc', // Purple\n          ],\n        });\n      }\n    });\n  }\n\n  /**\n   * Convert hex color string to RGB array\n   * @param hex Hex color string (e.g. \"#ff0000\" or \"#f00\")\n   * @returns Array of RGB values [r, g, b] in range 0-1\n   */\n  private hexToRgb(hex: string): [number, number, number] {\n    // Remove # if present\n    hex = hex.replace(/^#/, '');\n\n    // Handle shorthand hex (e.g. #f00 -> #ff0000)\n    if (hex.length === 3) {\n      hex = hex\n        .split('')\n        .map(c => c + c)\n        .join('');\n    }\n\n    // Parse the hex values\n    const r = parseInt(hex.substring(0, 2), 16) / 255;\n    const g = parseInt(hex.substring(2, 4), 16) / 255;\n    const b = parseInt(hex.substring(4, 6), 16) / 255;\n\n    return [r, g, b];\n  }\n\n  /**\n   * Create a shader\n   */\n  private createShader(type: number, source: string): WebGLShader | undefined {\n    if (!this.gl) return undefined;\n\n    const shader = this.gl.createShader(type);\n    if (!shader) return undefined;\n\n    this.gl.shaderSource(shader, source);\n    this.gl.compileShader(shader);\n\n    if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {\n      console.error('An error occurred compiling the shaders:', this.gl.getShaderInfoLog(shader));\n      this.gl.deleteShader(shader);\n      return undefined;\n    }\n\n    return shader;\n  }\n\n  /**\n   * Create a shader program\n   */\n  private createShaderProgram(\n    name: string,\n    vertexShaderSource: string,\n    fragmentShaderSource: string\n  ): WebGLProgram | undefined {\n    if (!this.gl) return undefined;\n\n    const vertexShader = this.createShader(this.gl.VERTEX_SHADER, vertexShaderSource);\n    const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, fragmentShaderSource);\n\n    if (!vertexShader || !fragmentShader) return undefined;\n\n    const program = this.gl.createProgram();\n    if (!program) return undefined;\n\n    this.gl.attachShader(program, vertexShader);\n    this.gl.attachShader(program, fragmentShader);\n    this.gl.linkProgram(program);\n\n    if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {\n      console.error('Unable to initialize the shader program:', this.gl.getProgramInfoLog(program));\n      return undefined;\n    }\n\n    this.programs.set(name, program);\n    return program;\n  }\n\n  /**\n   * Render data visualization with WebGL shader\n   */\n  public renderDataVisualization(\n    config: DataVisualizationShaderConfig,\n    data: Float32Array,\n    positions: Position[],\n    width: number,\n    height: number\n  ): void {\n    if (!this.gl || !this.canvas) {\n      console.error('[WebGLShaderManager] WebGL context not initialized');\n      return;\n    }\n\n    // Update canvas size if needed\n    if (this.canvas.width !== width || this.canvas.height !== height) {\n      this.canvas.width = width;\n      this.canvas.height = height;\n      this.gl.viewport(0, 0, width, height);\n    }\n\n    // Get appropriate shader program\n    const programName = `data_${config.type}`;\n    let program = this.programs.get(programName);\n\n    // Create program if not exists\n    if (!program) {\n      program = this.createDataVisualizationShader(config);\n      if (!program) {\n        console.error(`[WebGLShaderManager] Failed to create shader for ${config.type}`);\n        return;\n      }\n    }\n\n    // Set up rendering\n    this.gl.useProgram(program);\n\n    // Clear canvas\n    this.gl.clearColor(0, 0, 0, 0);\n    this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n\n    // Prepare data\n    this.setupDataVisualizationBuffers(program, config, data, positions);\n\n    // Perform drawing\n    this.gl.drawArrays(this.gl.POINTS, 0, positions.length);\n  }\n\n  /**\n   * Create data visualization shader program\n   */\n  private createDataVisualizationShader(\n    config: DataVisualizationShaderConfig\n  ): WebGLProgram | undefined {\n    const vertexShader = this.getDataVisualizationVertexShader(config);\n    const fragmentShader = this.getDataVisualizationFragmentShader(config);\n\n    return this.createShaderProgram(`data_${config.type}`, vertexShader, fragmentShader);\n  }\n\n  /**\n   * Set up data visualization buffers and uniforms\n   */\n  private setupDataVisualizationBuffers(\n    program: WebGLProgram,\n    config: DataVisualizationShaderConfig,\n    data: Float32Array,\n    positions: Position[]\n  ): void {\n    if (!this.gl) return;\n\n    // Create position buffer\n    const positionBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, positionBuffer);\n\n    // Convert positions to flat array\n    const positionArray = new Float32Array(positions.length * 2);\n    positions.forEach((pos, index) => {\n      positionArray[index * 2] = pos.x;\n      positionArray[index * 2 + 1] = pos.y;\n    });\n\n    this.gl.bufferData(this.gl.ARRAY_BUFFER, positionArray, this.gl.STATIC_DRAW);\n\n    // Get attribute location\n    const positionLocation = this.gl.getAttribLocation(program, 'a_position');\n    this.gl.enableVertexAttribArray(positionLocation);\n    this.gl.vertexAttribPointer(positionLocation, 2, this.gl.FLOAT, false, 0, 0);\n\n    // Create data buffer\n    const dataBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, dataBuffer);\n    this.gl.bufferData(this.gl.ARRAY_BUFFER, data, this.gl.STATIC_DRAW);\n\n    // Get attribute location\n    const dataLocation = this.gl.getAttribLocation(program, 'a_data');\n    this.gl.enableVertexAttribArray(dataLocation);\n    this.gl.vertexAttribPointer(dataLocation, 1, this.gl.FLOAT, false, 0, 0);\n\n    // Set uniforms\n    this.setDataVisualizationUniforms(program, config);\n  }\n\n  /**\n   * Set data visualization uniforms\n   */\n  private setDataVisualizationUniforms(\n    program: WebGLProgram,\n    config: DataVisualizationShaderConfig\n  ): void {\n    if (!this.gl) return;\n\n    // Resolution\n    const resolution = config.resolution || [this.canvas?.width || 800, this.canvas?.height || 600];\n    const resolutionLocation = this.gl.getUniformLocation(program, 'u_resolution');\n    this.gl.uniform2f(resolutionLocation, resolution[0], resolution[1]);\n\n    // Colors\n    const colorCount = Math.min(config.colors.length, 5);\n    for (let i = 0; i < colorCount; i++) {\n      const color = this.hexToRgb(config.colors[i]);\n      const colorLocation = this.gl.getUniformLocation(program, `u_colors[${i}]`);\n      this.gl.uniform3f(colorLocation, color[0], color[1], color[2]);\n    }\n\n    // Color count\n    const colorCountLocation = this.gl.getUniformLocation(program, 'u_colorCount');\n    this.gl.uniform1i(colorCountLocation, colorCount);\n\n    // Intensity\n    const intensityLocation = this.gl.getUniformLocation(program, 'u_intensity');\n    this.gl.uniform1f(intensityLocation, config.intensity || 1.0);\n\n    // Time (for animations)\n    const timeLocation = this.gl.getUniformLocation(program, 'u_time');\n    this.gl.uniform1f(timeLocation, performance.now() / 1000.0);\n\n    // Animation speed\n    const speedLocation = this.gl.getUniformLocation(program, 'u_speed');\n    this.gl.uniform1f(speedLocation, config.animationSpeed || 1.0);\n\n    // Data range\n    const dataRange = config.dataRange || [0, 1];\n    const dataRangeLocation = this.gl.getUniformLocation(program, 'u_dataRange');\n    this.gl.uniform2f(dataRangeLocation, dataRange[0], dataRange[1]);\n\n    // Highlight range\n    const highlightRange = config.highlightRange || [0.7, 1.0];\n    const highlightRangeLocation = this.gl.getUniformLocation(program, 'u_highlightRange');\n    if (highlightRangeLocation !== null) {\n      this.gl.uniform2f(highlightRangeLocation, highlightRange[0], highlightRange[1]);\n    }\n\n    // Custom uniforms\n    if (config.customUniforms) {\n      Object.entries(config.customUniforms).forEach(([name, uniform]) => {\n        if (!this.gl) return;\n        const location = this.gl.getUniformLocation(program, name);\n        if (location) {\n          this.setUniform(location, uniform);\n        }\n      });\n    }\n  }\n\n  /**\n   * Set uniform value\n   */\n  private setUniform(location: WebGLUniformLocation | null, uniform: ShaderUniform): void {\n    const gl = this.gl;\n    if (!gl || !location) return;\n\n    switch (uniform.type) {\n      case 'float':\n        gl.uniform1f(location, uniform.value as number);\n        break;\n      case 'vec2':\n        gl.uniform2fv(location, uniform.value as number[]);\n        break;\n      case 'vec3':\n        gl.uniform3fv(location, uniform.value as number[]);\n        break;\n      case 'vec4':\n        gl.uniform4fv(location, uniform.value as number[]);\n        break;\n      case 'int':\n        gl.uniform1i(location, uniform.value as number);\n        break;\n      case 'bool':\n        gl.uniform1i(location, uniform.value ? 1 : 0);\n        break;\n      case 'sampler2D':\n        if (uniform.value instanceof WebGLTexture) {\n          gl.uniform1i(location, 0);\n          gl.activeTexture(gl.TEXTURE0);\n          gl.bindTexture(gl.TEXTURE_2D, uniform.value);\n        }\n        break;\n    }\n  }\n\n  /**\n   * Get vertex shader source for data visualization\n   */\n  private getDataVisualizationVertexShader(config: DataVisualizationShaderConfig): string {\n    // Use custom vertex shader if provided\n    if (config.type === DataVisualizationShaderType.CUSTOM && config.customVertexShader) {\n      return config.customVertexShader;\n    }\n\n    // Default vertex shader\n    return `\n      attribute vec2 a_position;\n      attribute float a_data;\n      \n      uniform vec2 u_resolution;\n      uniform float u_time;\n      uniform float u_speed;\n      uniform vec2 u_dataRange;\n      uniform vec2 u_highlightRange;\n      \n      varying float v_data;\n      varying vec2 v_position;\n      varying float v_time;\n      \n      void main() {\n        // Normalize data\n        v_data = (a_data - u_dataRange.x) / (u_dataRange.y - u_dataRange.x);\n        v_position = a_position;\n        v_time = u_time * u_speed;\n        \n        // Set point size based on data\n        float highlightFactor = 1.0;\n        \n        // Highlight range\n        if (v_data >= u_highlightRange.x && v_data <= u_highlightRange.y) {\n          // Pulsing effect for highlighted data\n          highlightFactor = 1.0 + 0.3 * sin(u_time * 3.0);\n        }\n        \n        // Calculate point size \n        float baseSize = 1.0;\n        ${this.getPointSizeShaderCode(config)}\n        \n        // Position conversion\n        vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;\n        gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\n      }\n    `;\n  }\n\n  /**\n   * Get fragment shader source for data visualization\n   */\n  private getDataVisualizationFragmentShader(config: DataVisualizationShaderConfig): string {\n    // Use custom fragment shader if provided\n    if (config.type === DataVisualizationShaderType.CUSTOM && config.customFragmentShader) {\n      return config.customFragmentShader;\n    }\n\n    // Default fragment shader\n    return `\n      precision mediump float;\n      \n      uniform vec3 u_colors[5];\n      uniform int u_colorCount;\n      uniform float u_intensity;\n      uniform float u_time;\n      uniform vec2 u_highlightRange;\n      \n      varying float v_data;\n      varying vec2 v_position;\n      varying float v_time;\n      \n      // Helper function to interpolate colors\n      vec3 getColor(float value) {\n        if (u_colorCount == 1) return u_colors[0];\n        \n        float indexFloat = value * float(u_colorCount - 1);\n        int index = int(floor(indexFloat));\n        float t = fract(indexFloat);\n        \n        if (index >= u_colorCount - 1) {\n          return u_colors[u_colorCount - 1];\n        }\n        \n        return mix(u_colors[index], u_colors[index + 1], t);\n      }\n      \n      void main() {\n        // Get base color from data value\n        vec3 color = getColor(v_data);\n        float alpha = u_intensity;\n        \n        ${this.getFragmentShaderEffects(config)}\n        \n        // Apply highlight effect if in range\n        if (v_data >= u_highlightRange.x && v_data <= u_highlightRange.y) {\n          // Pulse effect\n          float pulse = 0.5 + 0.5 * sin(u_time * 3.0);\n          \n          // Brighten color \n          color = mix(color, vec3(1.0), pulse * 0.3);\n          \n          // Increase opacity\n          alpha = mix(alpha, 1.0, pulse * 0.5);\n          \n          // Add glow based on distance from center of point\n          float dist = length(gl_PointCoord - vec2(0.5));\n          float glow = smoothstep(0.5, 0.0, dist);\n          color += glow * pulse * 0.3;\n        }\n        \n        gl_FragColor = vec4(color, alpha);\n      }\n    `;\n  }\n\n  /**\n   * Get point size shader code based on visualization type\n   */\n  private getPointSizeShaderCode(config: DataVisualizationShaderConfig): string {\n    let code = '';\n\n    switch (config.type) {\n      case DataVisualizationShaderType.CUSTOM:\n        code = `gl_PointSize = max(baseSize, 8.0) * highlightFactor;`;\n        break;\n\n      case DataVisualizationShaderType.HEATMAP:\n        code = `gl_PointSize = max(baseSize, 10.0) * highlightFactor;`;\n        break;\n\n      case DataVisualizationShaderType.CONTOUR:\n        code = `\n          // For contour, size based on data thresholds\n          float thresholdFactor = abs(fract(v_data * 10.0) - 0.5) * 2.0;\n          gl_PointSize = mix(baseSize, 12.0, thresholdFactor) * highlightFactor;\n        `;\n        break;\n\n      case DataVisualizationShaderType.POINT_CLUSTER:\n        code = `\n          // For clustering, vary size by data value\n          gl_PointSize = mix(baseSize, 15.0, v_data) * highlightFactor;\n        `;\n        break;\n\n      case DataVisualizationShaderType.HIGHLIGHT:\n        code = `\n          // For highlighting, emphasize highlighted ranges\n          float inHighlight = (v_data >= u_highlightRange.x && v_data <= u_highlightRange.y) ? 1.0 : 0.0;\n          gl_PointSize = mix(baseSize, 20.0, inHighlight) * highlightFactor;\n        `;\n        break;\n\n      case DataVisualizationShaderType.DENSITY:\n        code = `\n          // For density maps, size consistent\n          gl_PointSize = 8.0 * highlightFactor;\n        `;\n        break;\n\n      case DataVisualizationShaderType.FLOW:\n        code = `\n          // For flow visualization, animate size with time\n          float flowPulse = 0.7 + 0.3 * sin(v_time + v_data * 10.0);\n          gl_PointSize = mix(baseSize, 12.0, v_data) * flowPulse * highlightFactor;\n        `;\n        break;\n\n      case DataVisualizationShaderType.TRANSITION:\n        code = `\n          float dist = length(gl_PointCoord - vec2(0.5));\n          float transitionFactor = 0.5 + 0.5 * sin(v_time * 2.0 + v_data * 5.0);\n          \n          alpha *= smoothstep(0.5, 0.0, dist) * mix(0.5, 1.0, transitionFactor);\n          color = mix(color, color * vec3(1.2, 1.1, 0.9), transitionFactor);\n          \n          if (transitionFactor > 0.7) {\n            float glow = smoothstep(0.5, 0.0, dist) * (transitionFactor - 0.7) * 3.0;\n            color += glow * vec3(1.0, 0.9, 0.7);\n          }\n        `;\n        break;\n\n      default:\n        code = `gl_PointSize = max(baseSize, 8.0) * highlightFactor;`;\n    }\n\n    return code;\n  }\n\n  /**\n   * Get fragment shader effects based on visualization type\n   */\n  private getFragmentShaderEffects(config: DataVisualizationShaderConfig): string {\n    let effects = '';\n\n    switch (config.type) {\n      case DataVisualizationShaderType.CUSTOM:\n        effects = '';\n        break;\n\n      case DataVisualizationShaderType.HEATMAP:\n        effects = `\n          float dist = length(gl_PointCoord - vec2(0.5));\n          float fadeEdge = smoothstep(0.5, 0.35, dist);\n          alpha *= fadeEdge;\n        `;\n        break;\n\n      case DataVisualizationShaderType.CONTOUR:\n        effects = `\n          float contourBands = abs(fract(v_data * 10.0) - 0.5) * 2.0;\n          float isContour = step(0.8, contourBands);\n          alpha *= mix(0.3, 1.0, isContour);\n          \n          float dist = length(gl_PointCoord - vec2(0.5));\n          alpha *= smoothstep(0.5, 0.0, dist);\n        `;\n        break;\n\n      case DataVisualizationShaderType.POINT_CLUSTER:\n        effects = `\n          float dist = length(gl_PointCoord - vec2(0.5));\n          float center = smoothstep(0.5, 0.1, dist);\n          alpha *= center;\n          \n          if (v_data > 0.7) {\n            float glow = smoothstep(0.5, 0.0, dist) * 0.5;\n            color += glow * vec3(1.0, 0.8, 0.2);\n          }\n        `;\n        break;\n\n      case DataVisualizationShaderType.HIGHLIGHT:\n        effects = `\n          float dist = length(gl_PointCoord - vec2(0.5));\n          alpha *= smoothstep(0.5, 0.0, dist);\n          \n          if (v_data >= u_highlightRange.x && v_data <= u_highlightRange.y) {\n            float glow = smoothstep(1.0, 0.0, dist * 2.0) * 0.7;\n            color += glow * vec3(1.0, 0.9, 0.5);\n          }\n        `;\n        break;\n\n      case DataVisualizationShaderType.DENSITY:\n        effects = `\n          float dist = length(gl_PointCoord - vec2(0.5));\n          alpha *= smoothstep(0.5, 0.0, dist) * v_data;\n          \n          color *= 0.8 + 0.2 * v_data;\n        `;\n        break;\n\n      case DataVisualizationShaderType.FLOW:\n        effects = `\n          float dist = length(gl_PointCoord - vec2(0.5));\n          \n          vec2 dir = normalize(gl_PointCoord - vec2(0.5));\n          float dirFactor = 0.5 + 0.5 * dot(dir, vec2(cos(v_time), sin(v_time)));\n          \n          alpha *= smoothstep(0.5, 0.0, dist) * dirFactor;\n          color *= 0.8 + 0.2 * dirFactor;\n          \n          float streak = smoothstep(0.9, 0.0, abs(dot(dir, vec2(cos(v_time), sin(v_time)))));\n          color += streak * 0.2 * vec3(1.0, 0.9, 0.7);\n        `;\n        break;\n\n      case DataVisualizationShaderType.TRANSITION:\n        effects = `\n          float dist = length(gl_PointCoord - vec2(0.5));\n          float transitionFactor = 0.5 + 0.5 * sin(v_time * 2.0 + v_data * 5.0);\n          \n          alpha *= smoothstep(0.5, 0.0, dist) * mix(0.5, 1.0, transitionFactor);\n          color = mix(color, color * vec3(1.2, 1.1, 0.9), transitionFactor);\n          \n          if (transitionFactor > 0.7) {\n            float glow = smoothstep(0.5, 0.0, dist) * (transitionFactor - 0.7) * 3.0;\n            color += glow * vec3(1.0, 0.9, 0.7);\n          }\n        `;\n        break;\n\n      default:\n        effects = '';\n    }\n\n    return effects;\n  }\n\n  /**\n   * Start animation loop for continuous rendering\n   * @param renderCallback (...args: unknown[]) => unknown to call on each animation frame\n   */\n  public startAnimationLoop(renderCallback: () => void): void {\n    // Stop any existing animation loop\n    this.stopAnimationLoop();\n\n    // Animation frame handler\n    const animate = (timestamp: number) => {\n      // Calculate delta time\n      const deltaTime = this._lastTimestamp ? timestamp - this._lastTimestamp : 0;\n      this._lastTimestamp = timestamp;\n\n      // Call render callback\n      renderCallback();\n\n      // Request next frame\n      this.animationFrame = requestAnimationFrame(animate);\n    };\n\n    // Start the animation loop\n    this.animationFrame = requestAnimationFrame(animate);\n  }\n\n  /**\n   * Stop the animation loop\n   */\n  public stopAnimationLoop(): void {\n    if (this.animationFrame !== null) {\n      cancelAnimationFrame(this.animationFrame);\n      this.animationFrame = null;\n    }\n  }\n\n  /**\n   * Dispose of WebGL resources\n   */\n  public dispose(): void {\n    // Stop any running animation\n    this.stopAnimationLoop();\n\n    // Clean up WebGL resources\n    if (this.gl) {\n      // Delete shaders\n      this.shaders.forEach(shader => {\n        this.gl?.deleteShader(shader);\n      });\n      this.shaders.clear();\n\n      // Delete programs\n      this.programs.forEach(program => {\n        this.gl?.deleteProgram(program);\n      });\n      this.programs.clear();\n\n      // Delete textures\n      this.textures.forEach(texture => {\n        this.gl?.deleteTexture(texture);\n      });\n      this.textures.clear();\n\n      // Delete framebuffers\n      this.framebuffers.forEach(framebuffer => {\n        this.gl?.deleteFramebuffer(framebuffer);\n      });\n      this.framebuffers.clear();\n\n      // Reset context\n      this.gl = null;\n      this.canvas = null;\n    }\n\n    console.warn('[WebGLShaderManager] Resources disposed');\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/patterns/Singleton.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/registry/ServiceRegistry.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/services/BaseService.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'context' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 94,
        "column": 29,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 94,
        "endColumn": 36
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { Singleton } from '../patterns/Singleton';\nimport { ErrorType } from '../../services/ErrorLoggingService';\n\n/**\n * Interface for service metadata\n */\nexport interface ServiceMetadata {\n  name: string;\n  version: string;\n  status: 'initializing' | 'ready' | 'error' | 'disposed';\n  lastError?: {\n    type: ErrorType;\n    message: string;\n    timestamp: number;\n  };\n  metrics?: Record<string, number>;\n}\n\n/**\n * Base interface that all services should implement\n */\nexport interface BaseService {\n  /**\n   * Initialize the service with optional dependencies\n   */\n  initialize(dependencies?: Record<string, unknown>): Promise<void>;\n\n  /**\n   * Dispose of any resources used by the service\n   */\n  dispose(): Promise<void>;\n\n  /**\n   * Get metadata about the service's current state\n   */\n  getMetadata(): ServiceMetadata;\n\n  /**\n   * Check if the service is ready to handle requests\n   */\n  isReady(): boolean;\n\n  /**\n   * Handle errors that occur within the service\n   */\n  handleError(error: Error, context?: Record<string, unknown>): void;\n}\n\n/**\n * Abstract base class that provides common service functionality\n * Extends the Singleton pattern to ensure only one instance exists\n */\nexport abstract class AbstractBaseService extends Singleton<AbstractBaseService> implements BaseService {\n  protected metadata: ServiceMetadata;\n\n  protected constructor(name: string, version: string) {\n    super();\n    this.metadata = {\n      name,\n      version,\n      status: 'initializing',\n    };\n  }\n\n  async initialize(dependencies?: Record<string, unknown>): Promise<void> {\n    try {\n      await this.onInitialize(dependencies);\n      this.metadata.status = 'ready';\n    } catch (error) {\n      this.metadata.status = 'error';\n      this.handleError(error as Error);\n      throw error;\n    }\n  }\n\n  async dispose(): Promise<void> {\n    try {\n      await this.onDispose();\n      this.metadata.status = 'disposed';\n    } catch (error) {\n      this.handleError(error as Error);\n      throw error;\n    }\n  }\n\n  getMetadata(): ServiceMetadata {\n    return { ...this.metadata };\n  }\n\n  isReady(): boolean {\n    return this.metadata.status === 'ready';\n  }\n\n  handleError(error: Error, context?: Record<string, unknown>): void {\n    this.metadata.lastError = {\n      type: ErrorType.UNKNOWN,\n      message: error.message,\n      timestamp: Date.now(),\n    };\n    // Subclasses should override this to provide custom error handling\n  }\n\n  protected abstract onInitialize(dependencies?: Record<string, unknown>): Promise<void>;\n  protected abstract onDispose(): Promise<void>;\n}",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/services/ServiceRegistry.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/visualization/ChartCoordinationManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/visualization/ParticleSystem.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'id' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 466,
        "column": 36,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 466,
        "endColumn": 38
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { Position } from '../../types/core/Position';\n\n/**\n * Particle animation easing functions\n */\nexport enum EasingType {\n  LINEAR = 'linear',\n  EASE_IN = 'easeIn',\n  EASE_OUT = 'easeOut',\n  EASE_IN_OUT = 'easeInOut',\n  BOUNCE = 'bounce',\n  ELASTIC = 'elastic',\n  BACK = 'back',\n}\n\n/**\n * Easing function type\n */\nexport type EasingFunction = (progress: number) => number;\n\n/**\n * Path type for particle movement\n */\nexport enum ParticlePath {\n  LINEAR = 'linear',\n  CURVED = 'curved',\n  SPIRAL = 'spiral',\n  BEZIER = 'bezier',\n  WAVE = 'wave',\n  RANDOM = 'random',\n}\n\n/**\n * Particle blend mode\n */\nexport enum ParticleBlendMode {\n  NORMAL = 'normal',\n  ADD = 'add',\n  MULTIPLY = 'multiply',\n  SCREEN = 'screen',\n}\n\n/**\n * Basic particle properties\n */\nexport interface Particle {\n  id: string;\n  position: Position;\n  prevPosition?: Position;\n  targetPosition?: Position;\n  startPosition?: Position;\n  velocity: { x: number; y: number };\n  acceleration: { x: number; y: number };\n  size: number;\n  startSize?: number;\n  targetSize?: number;\n  color: string;\n  startColor?: string;\n  targetColor?: string;\n  opacity: number;\n  startOpacity?: number;\n  targetOpacity?: number;\n  rotation: number;\n  startRotation?: number;\n  targetRotation?: number;\n  life: number;\n  maxLife: number;\n  active: boolean;\n  path?: ParticlePath;\n  pathParams?: Record<string, number>;\n  easing?: EasingFunction | EasingType;\n  blendMode?: ParticleBlendMode;\n  group?: string;\n  data?: Record<string, unknown>;\n}\n\n/**\n * Particle emitter configuration\n */\nexport interface ParticleEmitterConfig {\n  position: Position;\n  rate: number;\n  burstCount?: number;\n  emitRadius?: number;\n  direction?: number; // Angle in radians\n  spread?: number; // Angle in radians\n  minLife?: number;\n  maxLife?: number;\n  minSize?: number;\n  maxSize?: number;\n  minVelocity?: number;\n  maxVelocity?: number;\n  colors?: string[];\n  minOpacity?: number;\n  maxOpacity?: number;\n  gravity?: { x: number; y: number };\n  path?: ParticlePath;\n  pathParams?: Record<string, number>;\n  easing?: EasingFunction | EasingType;\n  blendMode?: ParticleBlendMode;\n  group?: string;\n}\n\n/**\n * Transition configuration for moving particles between data states\n */\nexport interface ParticleTransitionConfig {\n  /**\n   * Optional transition ID\n   */\n  id?: string;\n\n  /**\n   * Source data points with positions\n   */\n  sourceData?: DataPoint[];\n\n  /**\n   * Target data points with positions\n   */\n  targetData?: DataPoint[];\n\n  /**\n   * Transition duration in milliseconds\n   */\n  duration: number;\n\n  /**\n   * Easing function or type for the transition\n   */\n  easing?: EasingFunction | EasingType;\n\n  /**\n   * Path type for particle movement\n   */\n  path?: ParticlePath;\n\n  /**\n   * Additional path parameters\n   */\n  pathParams?: Record<string, number>;\n\n  /**\n   * Delay between individual particle transitions in milliseconds\n   */\n  staggerDelay?: number;\n\n  /**\n   * Whether to transition colors\n   */\n  transitionColors?: boolean;\n\n  /**\n   * Whether to transition sizes\n   */\n  transitionSizes?: boolean;\n\n  /**\n   * Whether to transition opacity\n   */\n  transitionOpacity?: boolean;\n\n  /**\n   * Whether to reverse the transition\n   */\n  reverse?: boolean;\n\n  /**\n   * Callback when transition is complete\n   */\n  onComplete?: () => void;\n\n  /**\n   * Callback when transition is updated\n   */\n  onUpdate?: (progress: number) => void;\n}\n\n/**\n * Data point for visualization\n */\nexport interface DataPoint {\n  id?: string;\n  x: number;\n  y: number;\n  value: number;\n  size?: number;\n  color?: string;\n  opacity?: number;\n  group?: string;\n  active?: boolean;\n  [key: string]: unknown;\n}\n\n/**\n * Manages a particle system for animated data transitions\n */\nexport class ParticleSystem {\n  private particles: Map<string, Particle> = new Map();\n  private emitters: Map<string, ParticleEmitterConfig> = new Map();\n  private lastFrameTime: number = 0;\n  private animationFrame: number | null = null;\n  private transitionConfigs: Map<string, ParticleTransitionConfig> = new Map();\n  private transitionTimers: Map<string, number> = new Map();\n  private transitionProgress: Map<string, number> = new Map();\n\n  /**\n   * Create a new particle system\n   */\n  constructor() {\n    this.lastFrameTime = performance.now();\n  }\n\n  /**\n   * Add a particle to the system\n   */\n  public addParticle(particle: Omit<Particle, 'id'>): string {\n    const id = `particle-${Math.random().toString(36).substring(2, 9)}`;\n    this.particles.set(id, {\n      ...particle,\n      id,\n    });\n    return id;\n  }\n\n  /**\n   * Remove a particle from the system\n   */\n  public removeParticle(id: string): boolean {\n    return this.particles.delete(id);\n  }\n\n  /**\n   * Add a particle emitter\n   */\n  public addEmitter(config: ParticleEmitterConfig): string {\n    const id = `emitter-${Math.random().toString(36).substring(2, 9)}`;\n    this.emitters.set(id, config);\n    return id;\n  }\n\n  /**\n   * Remove a particle emitter\n   */\n  public removeEmitter(id: string): boolean {\n    return this.emitters.delete(id);\n  }\n\n  /**\n   * Start the animation loop\n   */\n  public start(): void {\n    if (this.animationFrame !== null) {\n      return;\n    }\n\n    this.lastFrameTime = performance.now();\n    this.animationLoop();\n  }\n\n  /**\n   * Stop the animation loop\n   */\n  public stop(): void {\n    if (this.animationFrame !== null) {\n      cancelAnimationFrame(this.animationFrame);\n      this.animationFrame = null;\n    }\n  }\n\n  /**\n   * Clear all particles\n   */\n  public clear(): void {\n    this.particles.clear();\n  }\n\n  /**\n   * Set up a transition between data states\n   */\n  public setupTransition(id: string, config: ParticleTransitionConfig): void {\n    this.transitionConfigs.set(id, config);\n    this.transitionProgress.set(id, 0);\n\n    // Create particles for transition if needed\n    if (config.sourceData && config.targetData) {\n      this.createParticlesForTransition(id, config);\n    }\n  }\n\n  /**\n   * Start a transition between data states\n   */\n  public startTransition(id: string): void {\n    const config = this.transitionConfigs.get(id);\n    if (!config) {\n      console.warn(`No transition config found with id: ${id}`);\n      return;\n    }\n\n    // Start the transition timer\n    const startTime = performance.now();\n    this.transitionTimers.set(id, startTime);\n\n    // Ensure animation is running\n    this.start();\n  }\n\n  /**\n   * Stop a transition\n   */\n  public stopTransition(id: string): void {\n    this.transitionTimers.delete(id);\n  }\n\n  /**\n   * Create particles for a data transition\n   */\n  private createParticlesForTransition(\n    transitionId: string,\n    config: ParticleTransitionConfig\n  ): void {\n    if (!config.sourceData || !config.targetData) {\n      return;\n    }\n\n    // Clear any existing particles for this transition\n    this.particles.forEach((particle, id) => {\n      if (particle.group === transitionId) {\n        this.particles.delete(id);\n      }\n    });\n\n    // Determine how to map source to target\n    const isEqualSize = config.sourceData.length === config.targetData.length;\n\n    if (isEqualSize) {\n      // Direct mapping when source and target have same number of points\n      config.sourceData.forEach((sourcePoint, index) => {\n        const targetPoint = config.targetData![index];\n        this.createTransitionParticle(sourcePoint, targetPoint, transitionId, config);\n      });\n    } else if (config.sourceData.length < config.targetData.length) {\n      // Source has fewer points, need to generate additional particles\n      config.sourceData.forEach((sourcePoint, index) => {\n        const targetPoint = config.targetData![index % config.targetData!.length];\n        this.createTransitionParticle(sourcePoint, targetPoint, transitionId, config);\n      });\n\n      // Create additional particles starting from appropriate source points\n      for (let i = config.sourceData.length; i < config.targetData.length; i++) {\n        const sourceIndex = i % config.sourceData.length;\n        const sourcePoint = config.sourceData[sourceIndex];\n        const targetPoint = config.targetData[i];\n        this.createTransitionParticle(sourcePoint, targetPoint, transitionId, config);\n      }\n    } else {\n      // Target has fewer points, some source particles will converge\n      config.sourceData.forEach((sourcePoint, index) => {\n        const targetPoint = config.targetData![index % config.targetData!.length];\n        this.createTransitionParticle(sourcePoint, targetPoint, transitionId, config);\n      });\n    }\n  }\n\n  /**\n   * Create a single transition particle\n   */\n  private createTransitionParticle(\n    sourcePoint: DataPoint,\n    targetPoint: DataPoint,\n    transitionId: string,\n    config: ParticleTransitionConfig\n  ): string {\n    const sourceColor = sourcePoint.color || '#ffffff';\n    const targetColor = targetPoint.color || '#ffffff';\n    const sourceSize = sourcePoint.size || 10;\n    const targetSize = targetPoint.size || 10;\n    const sourceOpacity = sourcePoint.opacity !== undefined ? sourcePoint.opacity : 1;\n    const targetOpacity = targetPoint.opacity !== undefined ? targetPoint.opacity : 1;\n\n    return this.addParticle({\n      position: { x: sourcePoint.x, y: sourcePoint.y },\n      startPosition: { x: sourcePoint.x, y: sourcePoint.y },\n      targetPosition: { x: targetPoint.x, y: targetPoint.y },\n      velocity: { x: 0, y: 0 },\n      acceleration: { x: 0, y: 0 },\n      size: sourceSize,\n      startSize: sourceSize,\n      targetSize: targetSize,\n      color: sourceColor,\n      startColor: sourceColor,\n      targetColor: targetColor,\n      opacity: sourceOpacity,\n      startOpacity: sourceOpacity,\n      targetOpacity: targetOpacity,\n      rotation: 0,\n      life: 1,\n      maxLife: 1,\n      active: true,\n      path: config.path || ParticlePath.LINEAR,\n      easing: config.easing || this.getEasingFunction(EasingType.EASE_IN_OUT),\n      pathParams: config.pathParams,\n      group: transitionId,\n      data: {\n        sourcePoint,\n        targetPoint,\n        startTime: performance.now(),\n        staggerDelay: config.staggerDelay || 0,\n        transitionStarted: false,\n      },\n    });\n  }\n\n  /**\n   * Main animation loop\n   */\n  private animationLoop(): void {\n    const currentTime = performance.now();\n    const deltaTime = (currentTime - this.lastFrameTime) / 1000; // in seconds\n    this.lastFrameTime = currentTime;\n\n    // Update transitions\n    this.updateTransitions(currentTime);\n\n    // Update emitters\n    this.updateEmitters(deltaTime);\n\n    // Update particles\n    this.updateParticles(deltaTime);\n\n    // Schedule next frame\n    this.animationFrame = requestAnimationFrame(() => this.animationLoop());\n  }\n\n  /**\n   * Update particle transitions\n   */\n  private updateTransitions(currentTime: number): void {\n    this.transitionTimers.forEach((startTime, id) => {\n      const config = this.transitionConfigs.get(id);\n      if (!config) return;\n\n      // Calculate progress\n      const elapsedTime = currentTime - startTime;\n      const progress = Math.min(1, elapsedTime / config.duration);\n\n      // Store progress\n      this.transitionProgress.set(id, progress);\n\n      // Call update callback\n      config.onUpdate?.(progress);\n\n      // Check if transition is complete\n      if (progress >= 1) {\n        this.transitionTimers.delete(id);\n        config.onComplete?.();\n      }\n    });\n  }\n\n  /**\n   * Update particle emitters\n   */\n  private updateEmitters(deltaTime: number): void {\n    this.emitters.forEach((config, id) => {\n      // Calculate number of particles to emit\n      const emitCount = config.burstCount || Math.floor(config.rate * deltaTime);\n\n      // Emit particles\n      for (let i = 0; i < emitCount; i++) {\n        this.emitParticle(config);\n      }\n    });\n  }\n\n  /**\n   * Emit a single particle from an emitter\n   */\n  private emitParticle(config: ParticleEmitterConfig): string {\n    // Randomize position within emit radius\n    const angle = Math.random() * Math.PI * 2;\n    const radius = Math.random() * (config.emitRadius || 0);\n    const position = {\n      x: config.position.x + Math.cos(angle) * radius,\n      y: config.position.y + Math.sin(angle) * radius,\n    };\n\n    // Randomize velocity\n    const direction = (config.direction || 0) + (Math.random() - 0.5) * (config.spread || 0);\n    const speed =\n      config.minVelocity !== undefined && config.maxVelocity !== undefined\n        ? config.minVelocity + Math.random() * (config.maxVelocity - config.minVelocity)\n        : 50;\n\n    const velocity = {\n      x: Math.cos(direction) * speed,\n      y: Math.sin(direction) * speed,\n    };\n\n    // Randomize life\n    const life =\n      config.minLife !== undefined && config.maxLife !== undefined\n        ? config.minLife + Math.random() * (config.maxLife - config.minLife)\n        : 1;\n\n    // Randomize size\n    const size =\n      config.minSize !== undefined && config.maxSize !== undefined\n        ? config.minSize + Math.random() * (config.maxSize - config.minSize)\n        : 10;\n\n    // Randomize color\n    const color =\n      config.colors && config.colors.length > 0\n        ? config.colors[Math.floor(Math.random() * config.colors.length)]\n        : '#ffffff';\n\n    // Randomize opacity\n    const opacity =\n      config.minOpacity !== undefined && config.maxOpacity !== undefined\n        ? config.minOpacity + Math.random() * (config.maxOpacity - config.minOpacity)\n        : 1;\n\n    // Create particle\n    return this.addParticle({\n      position,\n      velocity,\n      acceleration: config.gravity || { x: 0, y: 0 },\n      size,\n      color,\n      opacity,\n      rotation: Math.random() * Math.PI * 2,\n      life,\n      maxLife: life,\n      active: true,\n      path: config.path,\n      pathParams: config.pathParams,\n      easing: config.easing,\n      blendMode: config.blendMode,\n      group: config.group,\n    });\n  }\n\n  /**\n   * Update all particles\n   */\n  private updateParticles(deltaTime: number): void {\n    this.particles.forEach((particle, id) => {\n      if (!particle.active) return;\n\n      // Handle transition particles\n      if (particle.group && this.transitionTimers.has(particle.group)) {\n        this.updateTransitionParticle(particle, this.transitionProgress.get(particle.group) || 0);\n      } else {\n        // Handle regular particles\n        this.updateRegularParticle(particle, deltaTime);\n      }\n\n      // Remove dead particles\n      if (particle.life <= 0) {\n        this.particles.delete(id);\n      }\n    });\n  }\n\n  /**\n   * Update a transition particle\n   */\n  private updateTransitionParticle(particle: Particle, transitionProgress: number): void {\n    if (!particle.startPosition || !particle.targetPosition) return;\n\n    const data = particle.data as Record<string, unknown>;\n    const staggerDelay = (data.staggerDelay as number) || 0;\n\n    // Handle staggered start\n    if (!data.transitionStarted) {\n      const elapsedSinceStart = performance.now() - (data.startTime as number);\n      if (elapsedSinceStart < staggerDelay) {\n        return;\n      }\n      data.transitionStarted = true;\n    }\n\n    // Apply easing\n    const easedProgress = this.applyEasing(\n      transitionProgress,\n      particle.easing || this.getEasingFunction(EasingType.LINEAR)\n    );\n\n    // Update position based on path type\n    this.updateParticlePosition(particle, easedProgress);\n\n    // Update size\n    if (particle.startSize !== undefined && particle.targetSize !== undefined) {\n      particle.size =\n        particle.startSize + (particle.targetSize - particle.startSize) * easedProgress;\n    }\n\n    // Update opacity\n    if (particle.startOpacity !== undefined && particle.targetOpacity !== undefined) {\n      particle.opacity =\n        particle.startOpacity + (particle.targetOpacity - particle.startOpacity) * easedProgress;\n    }\n\n    // Update color\n    if (particle.startColor && particle.targetColor) {\n      particle.color = this.interpolateColor(\n        particle.startColor,\n        particle.targetColor,\n        easedProgress\n      );\n    }\n\n    // Store previous position for trail effects\n    particle.prevPosition = { ...particle.position };\n  }\n\n  /**\n   * Update a regular particle\n   */\n  private updateRegularParticle(particle: Particle, deltaTime: number): void {\n    // Update velocity\n    particle.velocity.x += particle.acceleration.x * deltaTime;\n    particle.velocity.y += particle.acceleration.y * deltaTime;\n\n    // Store previous position for trail effects\n    particle.prevPosition = { ...particle.position };\n\n    // Update position\n    particle.position.x += particle.velocity.x * deltaTime;\n    particle.position.y += particle.velocity.y * deltaTime;\n\n    // Update life\n    particle.life -= deltaTime;\n\n    // Update opacity based on life\n    const lifeRatio = Math.max(0, particle.life / particle.maxLife);\n    particle.opacity = lifeRatio;\n  }\n\n  /**\n   * Update particle position based on path type\n   */\n  private updateParticlePosition(particle: Particle, progress: number): void {\n    const start = particle.startPosition || { x: 0, y: 0 };\n    const end = particle.targetPosition || { x: 0, y: 0 };\n    let position: Position;\n\n    switch (particle.path || ParticlePath.LINEAR) {\n      case ParticlePath.CURVED:\n        position = this.calculateCurvedPath(start, end, progress);\n        break;\n\n      case ParticlePath.SPIRAL:\n        position = this.calculateSpiralPath(start, end, progress, particle.pathParams?.turns);\n        break;\n\n      case ParticlePath.BEZIER:\n        position = this.calculateBezierPath(start, end, progress);\n        break;\n\n      case ParticlePath.WAVE:\n        position = this.calculateWavePath(\n          start,\n          end,\n          progress,\n          particle.pathParams?.amplitude,\n          particle.pathParams?.frequency\n        );\n        break;\n\n      case ParticlePath.RANDOM:\n        position = this.calculateRandomPath(\n          start,\n          end,\n          progress,\n          particle,\n          particle.pathParams?.jitter\n        );\n        break;\n\n      case ParticlePath.LINEAR:\n      default:\n        position = {\n          x: start.x + (end.x - start.x) * progress,\n          y: start.y + (end.y - start.y) * progress,\n        };\n    }\n\n    particle.position = position;\n  }\n\n  /**\n   * Calculate curved path position\n   */\n  private calculateCurvedPath(start: Position, end: Position, progress: number): Position {\n    const controlX = (start.x + end.x) / 2;\n    const controlY = Math.min(start.y, end.y) - Math.abs(end.x - start.x) * 0.2;\n\n    const t = progress;\n    const invT = 1 - t;\n\n    return {\n      x: invT * invT * start.x + 2 * invT * t * controlX + t * t * end.x,\n      y: invT * invT * start.y + 2 * invT * t * controlY + t * t * end.y,\n    };\n  }\n\n  /**\n   * Calculate spiral path position\n   */\n  private calculateSpiralPath(\n    start: Position,\n    end: Position,\n    progress: number,\n    turns = 2\n  ): Position {\n    const angle = progress * turns * Math.PI * 2;\n    const radius =\n      (1 - progress) * Math.min(Math.abs(end.x - start.x), Math.abs(end.y - start.y)) * 0.2;\n\n    return {\n      x: start.x + (end.x - start.x) * progress + Math.cos(angle) * radius,\n      y: start.y + (end.y - start.y) * progress + Math.sin(angle) * radius,\n    };\n  }\n\n  /**\n   * Calculate bezier path position\n   */\n  private calculateBezierPath(start: Position, end: Position, progress: number): Position {\n    const cp1x = start.x + (end.x - start.x) * 0.3;\n    const cp1y = start.y - Math.abs(end.y - start.y) * 0.3;\n    const cp2x = start.x + (end.x - start.x) * 0.7;\n    const cp2y = end.y + Math.abs(end.y - start.y) * 0.3;\n\n    const t1 = progress;\n    const t2 = t1 * t1;\n    const t3 = t2 * t1;\n    const invT1 = 1 - t1;\n    const invT2 = invT1 * invT1;\n    const invT3 = invT2 * invT1;\n\n    return {\n      x: invT3 * start.x + 3 * invT2 * t1 * cp1x + 3 * invT1 * t2 * cp2x + t3 * end.x,\n      y: invT3 * start.y + 3 * invT2 * t1 * cp1y + 3 * invT1 * t2 * cp2y + t3 * end.y,\n    };\n  }\n\n  /**\n   * Calculate wave path position\n   */\n  private calculateWavePath(\n    start: Position,\n    end: Position,\n    progress: number,\n    amplitude?: number,\n    frequency = 3\n  ): Position {\n    const actualAmplitude =\n      amplitude || Math.min(Math.abs(end.x - start.x), Math.abs(end.y - start.y)) * 0.1;\n    const waviness = Math.sin(progress * Math.PI * frequency) * actualAmplitude;\n\n    // Calculate the normal vector to the path\n    const dx = end.x - start.x;\n    const dy = end.y - start.y;\n    const length = Math.sqrt(dx * dx + dy * dy);\n    const normalX = -dy / length;\n    const normalY = dx / length;\n\n    return {\n      x: start.x + (end.x - start.x) * progress + normalX * waviness,\n      y: start.y + (end.y - start.y) * progress + normalY * waviness,\n    };\n  }\n\n  /**\n   * Calculate random path position\n   */\n  private calculateRandomPath(\n    start: Position,\n    end: Position,\n    progress: number,\n    particle: Particle,\n    jitter = 0.1\n  ): Position {\n    // Get or create random seeds\n    let seeds = (particle.data?.randomSeeds as number[]) || [];\n    if (!seeds.length) {\n      seeds = Array.from({ length: 10 }, () => Math.random());\n      (particle.data as Record<string, unknown>).randomSeeds = seeds;\n    }\n\n    const jitterSize = Math.min(Math.abs(end.x - start.x), Math.abs(end.y - start.y)) * jitter;\n\n    // Use seeds and progress to generate controlled randomness\n    const index = Math.floor(progress * 10);\n    const subProgress = (progress * 10) % 1;\n    const seed1 = seeds[index % seeds.length];\n    const seed2 = seeds[(index + 1) % seeds.length];\n\n    const randomX =\n      (seed1 * 2 - 1) * jitterSize * (1 - subProgress) + (seed2 * 2 - 1) * jitterSize * subProgress;\n    const randomY =\n      (seeds[(index + 2) % seeds.length] * 2 - 1) * jitterSize * (1 - subProgress) +\n      (seeds[(index + 3) % seeds.length] * 2 - 1) * jitterSize * subProgress;\n\n    return {\n      x: start.x + (end.x - start.x) * progress + randomX,\n      y: start.y + (end.y - start.y) * progress + randomY,\n    };\n  }\n\n  /**\n   * Bounce easing function\n   */\n  private bounceEasing(t: number): number {\n    const a = 7.5625;\n    const b = 2.75;\n\n    if (t < 1 / b) {\n      return a * t * t;\n    } else if (t < 2 / b) {\n      t -= 1.5 / b;\n      return a * t * t + 0.75;\n    } else if (t < 2.5 / b) {\n      t -= 2.25 / b;\n      return a * t * t + 0.9375;\n    } else {\n      t -= 2.625 / b;\n      return a * t * t + 0.984375;\n    }\n  }\n\n  /**\n   * Elastic easing function\n   */\n  private elasticEasing(t: number): number {\n    return t === 0\n      ? 0\n      : t === 1\n        ? 1\n        : Math.pow(2, -10 * t) * Math.sin(((t * 10 - 0.75) * Math.PI) / 1.5) + 1;\n  }\n\n  /**\n   * Back easing function\n   */\n  private backEasing(t: number): number {\n    const overshoot = 1.70158;\n    return t * t * ((overshoot + 1) * t - overshoot);\n  }\n\n  /**\n   * Get easing function by type\n   */\n  private getEasingFunction(type: EasingType): EasingFunction {\n    switch (type) {\n      case EasingType.LINEAR:\n        return (t: number) => t;\n\n      case EasingType.EASE_IN:\n        return (t: number) => t * t;\n\n      case EasingType.EASE_OUT:\n        return (t: number) => t * (2 - t);\n\n      case EasingType.EASE_IN_OUT:\n        return (t: number) => (t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t);\n\n      case EasingType.BOUNCE:\n        return this.bounceEasing.bind(this);\n\n      case EasingType.ELASTIC:\n        return this.elasticEasing.bind(this);\n\n      case EasingType.BACK:\n        return this.backEasing.bind(this);\n\n      default:\n        return (t: number) => t;\n    }\n  }\n\n  /**\n   * Apply easing function to progress\n   */\n  private applyEasing(progress: number, easing: EasingFunction | EasingType): number {\n    if (typeof easing === 'function') {\n      return easing(progress);\n    }\n    return this.getEasingFunction(easing)(progress);\n  }\n\n  /**\n   * Interpolate between two colors\n   */\n  private interpolateColor(color1: string, color2: string, progress: number): string {\n    // Parse colors\n    const parseColor = (color: string): [number, number, number] => {\n      // Handle hex colors\n      if (color.startsWith('#')) {\n        const hex = color.substring(1);\n        if (hex.length === 3) {\n          return [\n            parseInt(hex[0] + hex[0], 16),\n            parseInt(hex[1] + hex[1], 16),\n            parseInt(hex[2] + hex[2], 16),\n          ];\n        } else {\n          return [\n            parseInt(hex.substring(0, 2), 16),\n            parseInt(hex.substring(2, 4), 16),\n            parseInt(hex.substring(4, 6), 16),\n          ];\n        }\n      }\n\n      // Handle rgb colors\n      if (color.startsWith('rgb')) {\n        const match = color.match(/rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)/);\n        if (match) {\n          return [parseInt(match[1]), parseInt(match[2]), parseInt(match[3])];\n        }\n      }\n\n      // Default\n      return [255, 255, 255];\n    };\n\n    const [r1, g1, b1] = parseColor(color1);\n    const [r2, g2, b2] = parseColor(color2);\n\n    // Interpolate\n    const r = Math.round(r1 + (r2 - r1) * progress);\n    const g = Math.round(g1 + (g2 - g1) * progress);\n    const b = Math.round(b1 + (b2 - b1) * progress);\n\n    // Convert back to hex\n    return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;\n  }\n\n  /**\n   * Get all particles\n   */\n  public getParticles(): Particle[] {\n    return Array.from(this.particles.values());\n  }\n\n  /**\n   * Get particles by group\n   */\n  public getParticlesByGroup(group: string): Particle[] {\n    return Array.from(this.particles.values()).filter(p => p.group === group);\n  }\n\n  /**\n   * Check if a transition is running\n   */\n  public isTransitionRunning(id: string): boolean {\n    return this.transitionTimers.has(id);\n  }\n\n  /**\n   * Get transition progress\n   */\n  public getTransitionProgress(id: string): number {\n    return this.transitionProgress.get(id) || 0;\n  }\n\n  /**\n   * Clear everything\n   */\n  public dispose(): void {\n    this.stop();\n    this.particles.clear();\n    this.emitters.clear();\n    this.transitionConfigs.clear();\n    this.transitionTimers.clear();\n    this.transitionProgress.clear();\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/main.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/ManagerRegistry.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/ai/BehaviorTreeManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/automation/GlobalAutomationManager.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'resourceType' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 415,
        "column": 29,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 415,
        "endColumn": 41
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { ModuleEvent, moduleEventBus, ModuleEventType } from '../../lib/modules/ModuleEvents';\nimport { ModuleType } from '../../types/buildings/ModuleTypes';\nimport {\n  getSystemCommunication,\n  MessagePriority,\n  SystemId,\n} from '../../utils/events/EventCommunication';\nimport { EventPriorityQueue } from '../../utils/events/EventFiltering';\nimport {\n  AutomationAction,\n  AutomationCondition,\n  AutomationManager,\n  AutomationRule,\n  ResourceConditionValue,\n} from '../game/AutomationManager';\nimport { gameLoopManager, UpdatePriority } from '../game/GameLoopManager';\nimport { ResourceType } from './../../types/resources/ResourceTypes';\n\n/**\n * Global routine type\n */\nexport type GlobalRoutineType =\n  | 'system-maintenance'\n  | 'resource-balancing'\n  | 'performance-optimization'\n  | 'emergency-response'\n  | 'scheduled-task'\n  | 'custom';\n\n/**\n * Global routine interface\n */\nexport interface GlobalRoutine {\n  id: string;\n  name: string;\n  type: GlobalRoutineType;\n  description: string;\n  enabled: boolean;\n  priority: MessagePriority;\n  interval: number;\n  lastRun?: number;\n  conditions: AutomationCondition[];\n  actions: AutomationAction[];\n  systems: SystemId[];\n  tags: string[];\n}\n\n/**\n * Global automation manager\n * Extends the module-specific automation with system-wide routines\n */\nexport class GlobalAutomationManager {\n  private _automationManager: AutomationManager;\n  private routines: Map<string, GlobalRoutine>;\n  private activeRoutines: Map<string, boolean>;\n  private routineQueue: EventPriorityQueue<GlobalRoutine & { executionTime: number }>;\n  private systemCommunications: Map<SystemId, ReturnType<typeof getSystemCommunication>>;\n  private isInitialized: boolean = false;\n\n  constructor(_automationManager: AutomationManager) {\n    this._automationManager = _automationManager;\n    this.routines = new Map();\n    this.activeRoutines = new Map();\n    this.systemCommunications = new Map();\n\n    // Create a priority queue for routine execution\n    this.routineQueue = new EventPriorityQueue(routine => {\n      return this.executeRoutine(routine);\n    });\n  }\n\n  /**\n   * Initialize the global automation manager\n   */\n  public initialize(): void {\n    if (this.isInitialized) {\n      return;\n    }\n\n    console.warn('Initializing Global Automation Manager...');\n\n    // Log the automation manager status\n    if (this._automationManager) {\n      console.warn(\n        `[GlobalAutomationManager] Using automation manager for condition checking and rule management`\n      );\n    } else {\n      console.warn(\n        '[GlobalAutomationManager] No automation manager provided, some features may be limited'\n      );\n    }\n\n    // Initialize system communications\n    this.initializeSystemCommunications();\n\n    // Register with game loop for regular updates\n    gameLoopManager.registerUpdate(\n      'global-automation-manager',\n      this.update.bind(this),\n      UpdatePriority.NORMAL\n    );\n\n    // Subscribe to relevant events\n    moduleEventBus.subscribe('ERROR_OCCURRED' as ModuleEventType, this.handleErrorEvent);\n    moduleEventBus.subscribe('RESOURCE_SHORTAGE' as ModuleEventType, this.handleResourceShortage);\n    moduleEventBus.subscribe('STATUS_CHANGED' as ModuleEventType, this.handleStatusChanged);\n\n    this.isInitialized = true;\n\n    // Emit initialization event\n    moduleEventBus.emit({\n      type: 'AUTOMATION_STARTED' as ModuleEventType,\n      moduleId: 'global-automation',\n      moduleType: 'resource-manager',\n      timestamp: Date.now(),\n      data: {\n        routineCount: this.routines.size,\n        systems: Array.from(this.systemCommunications.keys()),\n      },\n    });\n  }\n\n  /**\n   * Initialize system communications\n   */\n  private initializeSystemCommunications(): void {\n    const systems: SystemId[] = [\n      'resource-system',\n      'module-system',\n      'combat-system',\n      'exploration-system',\n      'mining-system',\n      'tech-system',\n      'ui-system',\n      'game-loop',\n      'event-system',\n    ];\n\n    systems.forEach(systemId => {\n      const communication = getSystemCommunication(systemId);\n      this.systemCommunications.set(systemId, communication);\n\n      // Register message handler for automation requests\n      communication.registerHandler('automation-request', message => {\n        console.warn(`Received automation request from ${systemId}:`, message.payload);\n\n        // Use type guard instead of type assertion\n        const { payload } = message;\n        if (payload && typeof payload === 'object') {\n          const routineId = 'routineId' in payload ? String(payload.routineId) : undefined;\n          const createRoutine =\n            'createRoutine' in payload &&\n            payload.createRoutine &&\n            typeof payload.createRoutine === 'object'\n              ? (payload.createRoutine as GlobalRoutine)\n              : undefined;\n\n          if (routineId) {\n            const routine = this.routines.get(routineId);\n            if (routine && routine.enabled) {\n              this.scheduleRoutine(routine);\n              return;\n            }\n          }\n\n          if (createRoutine) {\n            this.registerRoutine(createRoutine);\n          }\n        }\n      });\n    });\n  }\n\n  /**\n   * Register a global routine\n   */\n  public registerRoutine(routine: GlobalRoutine): string {\n    // Generate ID if not provided\n    if (!routine.id) {\n      routine.id = `routine-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n    }\n\n    this.routines.set(routine.id, routine);\n    this.activeRoutines.set(routine.id, routine.enabled);\n\n    // If routine is enabled, schedule it\n    if (routine.enabled) {\n      this.scheduleRoutine(routine);\n    }\n\n    // Notify systems about the new routine\n    routine.systems.forEach(systemId => {\n      const communication = this.systemCommunications.get(systemId);\n      if (communication) {\n        communication.sendMessage('broadcast', 'routine-registered', {\n          routineId: routine.id,\n          name: routine.name,\n          type: routine.type,\n        });\n      }\n    });\n\n    return routine.id;\n  }\n\n  /**\n   * Unregister a global routine\n   */\n  public unregisterRoutine(routineId: string): boolean {\n    const routine = this.routines.get(routineId);\n    if (!routine) {\n      return false;\n    }\n\n    // Notify systems about routine removal\n    routine.systems.forEach(systemId => {\n      const communication = this.systemCommunications.get(systemId);\n      if (communication) {\n        communication.sendMessage(systemId, 'routine-unregistered', {\n          routineId: routine.id,\n        });\n      }\n    });\n\n    this.routines.delete(routineId);\n    this.activeRoutines.delete(routineId);\n    return true;\n  }\n\n  /**\n   * Enable a global routine\n   */\n  public enableRoutine(routineId: string): boolean {\n    const routine = this.routines.get(routineId);\n    if (!routine) {\n      return false;\n    }\n\n    routine.enabled = true;\n    this.activeRoutines.set(routineId, true);\n\n    // Schedule the routine\n    this.scheduleRoutine(routine);\n\n    return true;\n  }\n\n  /**\n   * Disable a global routine\n   */\n  public disableRoutine(routineId: string): boolean {\n    const routine = this.routines.get(routineId);\n    if (!routine) {\n      return false;\n    }\n\n    routine.enabled = false;\n    this.activeRoutines.set(routineId, false);\n    return true;\n  }\n\n  /**\n   * Schedule a routine for execution\n   */\n  private scheduleRoutine(routine: GlobalRoutine): void {\n    // Add to the priority queue\n    this.routineQueue.enqueue({\n      ...routine,\n      executionTime: Date.now() + (routine.interval || 0),\n    });\n  }\n\n  /**\n   * Execute a routine\n   */\n  private async executeRoutine(routine: GlobalRoutine & { executionTime: number }): Promise<void> {\n    try {\n      // Skip if routine is disabled\n      if (!routine.enabled) {\n        return;\n      }\n\n      // Skip if it's not time to run yet\n      if (Date.now() < routine.executionTime) {\n        // Re-queue for later execution\n        this.scheduleRoutine(routine);\n        return;\n      }\n\n      console.warn(`Executing routine: ${routine.name} (${routine.id})`);\n\n      // Check conditions\n      let conditionsMet = true;\n      try {\n        // Try to check conditions, but handle if the method is private\n        // We'll implement our own simple condition checking if needed\n        for (const condition of routine.conditions) {\n          if (condition.type === 'RESOURCE_BELOW') {\n            // Simple implementation for resource below condition\n            const { target, value } = condition;\n            if (target && value !== undefined) {\n              const resourceAmount = this.getResourceAmount(target as ResourceType);\n              // Extract numeric value for comparison\n              const threshold =\n                typeof value === 'number' ? value : (value as ResourceConditionValue).amount;\n              if (resourceAmount > threshold) {\n                conditionsMet = false;\n                break;\n              }\n            }\n          } else if (condition.type === 'RESOURCE_ABOVE') {\n            // Simple implementation for resource above condition\n            const { target, value } = condition;\n            if (target && value !== undefined) {\n              const resourceAmount = this.getResourceAmount(target as ResourceType);\n              // Extract numeric value for comparison\n              const threshold =\n                typeof value === 'number' ? value : (value as ResourceConditionValue).amount;\n              if (resourceAmount < threshold) {\n                conditionsMet = false;\n                break;\n              }\n            }\n          }\n          // Add more condition types as needed\n        }\n      } catch (error) {\n        console.warn('Error checking conditions, using simple implementation:', error);\n      }\n\n      if (!conditionsMet) {\n        console.warn(`Conditions not met for routine: ${routine.name}`);\n\n        // Re-schedule for next interval\n        this.scheduleRoutine({\n          ...routine,\n          lastRun: Date.now(),\n        });\n        return;\n      }\n\n      // Execute actions\n      try {\n        // Try to execute actions through the automation manager\n        // If that fails, implement our own simple action execution\n        for (const action of routine.actions) {\n          await this.executeAction(action);\n        }\n      } catch (error) {\n        console.warn('Error executing actions, using simple implementation:', error);\n      }\n\n      // Update last run time\n      const updatedRoutine = {\n        ...routine,\n        lastRun: Date.now(),\n      };\n      this.routines.set(routine.id, updatedRoutine);\n\n      // Emit routine completion event\n      moduleEventBus.emit({\n        type: 'AUTOMATION_CYCLE_COMPLETE' as ModuleEventType,\n        moduleId: 'global-automation',\n        moduleType: 'resource-manager',\n        timestamp: Date.now(),\n        data: {\n          routineId: routine.id,\n          routineName: routine.name,\n          routineType: routine.type,\n        },\n      });\n\n      // Notify relevant systems\n      routine.systems.forEach(systemId => {\n        const communication = this.systemCommunications.get(systemId);\n        if (communication) {\n          communication.sendMessage(systemId, 'routine-executed', {\n            routineId: routine.id,\n            success: true,\n            timestamp: Date.now(),\n          });\n        }\n      });\n\n      // Re-schedule for next interval\n      this.scheduleRoutine(updatedRoutine);\n    } catch (error) {\n      console.error(`Error executing routine ${routine.id}:`, error);\n\n      // Emit error event\n      moduleEventBus.emit({\n        type: 'ERROR_OCCURRED' as ModuleEventType,\n        moduleId: 'global-automation',\n        moduleType: 'resource-manager',\n        timestamp: Date.now(),\n        data: {\n          routineId: routine.id,\n          error: error instanceof Error ? error.message : String(error),\n        },\n      });\n\n      // Re-schedule for next interval\n      this.scheduleRoutine({\n        ...routine,\n        lastRun: Date.now(),\n      });\n    }\n  }\n\n  /**\n   * Get the current amount of a resource\n   * @param resourceType The type of resource to check\n   * @returns The current amount of the resource\n   */\n  private getResourceAmount(resourceType: ResourceType): number {\n    // Implementation would get the actual resource amount from the game state\n    // For now, return a mock value\n    return 100;\n  }\n\n  /**\n   * Helper method to execute a single action\n   */\n  private async executeAction(action: AutomationAction): Promise<void> {\n    switch (action.type) {\n      case 'ACTIVATE_MODULE':\n        if (!action.target) {\n          return;\n        }\n        // Emit an event to activate the module\n        moduleEventBus.emit({\n          type: 'MODULE_ACTIVATED' as ModuleEventType,\n          moduleId: action.target,\n          moduleType: 'resource-manager',\n          timestamp: Date.now(),\n          data: { source: 'automation' },\n        });\n        break;\n\n      case 'DEACTIVATE_MODULE':\n        if (!action.target) {\n          return;\n        }\n        // Emit an event to deactivate the module\n        moduleEventBus.emit({\n          type: 'MODULE_DEACTIVATED' as ModuleEventType,\n          moduleId: action.target,\n          moduleType: 'resource-manager',\n          timestamp: Date.now(),\n          data: { source: 'automation' },\n        });\n        break;\n\n      case 'TRANSFER_RESOURCES':\n        if (!action.target || !action.value) {\n          return;\n        }\n        // Emit an event to transfer resources\n        moduleEventBus.emit({\n          type: 'RESOURCE_TRANSFERRED' as ModuleEventType,\n          moduleId: 'automation',\n          moduleType: 'resource-manager',\n          timestamp: Date.now(),\n          data: this.convertActionValueToRecord(action.value),\n        });\n        break;\n\n      case 'EMIT_EVENT': {\n        if (!action.target || !action.value) {\n          return;\n        }\n\n        // Define interface for EmitEventValue\n        interface EmitEventValue {\n          moduleId?: string;\n          moduleType?: string;\n          data?: Record<string, unknown>;\n          [key: string]: unknown; // Add index signature to satisfy Record<string, unknown>\n        }\n\n        // Use type guard instead of type assertion\n        const emitValue: EmitEventValue = {};\n\n        if (typeof action.value === 'object' && action.value !== null) {\n          // First cast to unknown to avoid type errors\n          const value = action.value as unknown as Record<string, unknown>;\n\n          if ('moduleId' in value && typeof value.moduleId === 'string') {\n            emitValue.moduleId = value.moduleId;\n          }\n\n          if ('moduleType' in value && typeof value.moduleType === 'string') {\n            emitValue.moduleType = value.moduleType as ModuleType;\n          }\n\n          if ('data' in value && typeof value.data === 'object' && value.data !== null) {\n            emitValue.data = value.data as Record<string, unknown>;\n          }\n        }\n\n        // Validate that action.target is a valid ModuleEventType\n        const isValidEventType = (type: string): type is ModuleEventType => {\n          return [\n            'MODULE_CREATED',\n            'MODULE_ATTACHED',\n            'MODULE_DETACHED',\n            'MODULE_UPGRADED',\n            'MODULE_ACTIVATED',\n            'MODULE_DEACTIVATED',\n            'MODULE_UPDATED',\n            'ATTACHMENT_STARTED',\n            'ATTACHMENT_CANCELLED',\n            'ATTACHMENT_COMPLETED',\n            'ATTACHMENT_PREVIEW_SHOWN',\n            'RESOURCE_PRODUCED',\n            'RESOURCE_CONSUMED',\n            'RESOURCE_TRANSFERRED',\n            'RESOURCE_PRODUCTION_REGISTERED',\n            'RESOURCE_PRODUCTION_UNREGISTERED',\n            'RESOURCE_CONSUMPTION_REGISTERED',\n            'RESOURCE_CONSUMPTION_UNREGISTERED',\n            'RESOURCE_FLOW_REGISTERED',\n            'RESOURCE_FLOW_UNREGISTERED',\n            'RESOURCE_SHORTAGE',\n            'RESOURCE_UPDATED',\n            'AUTOMATION_STARTED',\n            'AUTOMATION_STOPPED',\n            'AUTOMATION_CYCLE_COMPLETE',\n            'STATUS_CHANGED',\n            'ERROR_OCCURRED',\n            'MISSION_STARTED',\n            'MISSION_COMPLETED',\n            'MISSION_FAILED',\n            'MISSION_PROGRESS_UPDATED',\n            'MISSION_REWARD_CLAIMED',\n            'SUB_MODULE_CREATED',\n            'SUB_MODULE_ATTACHED',\n            'SUB_MODULE_DETACHED',\n            'SUB_MODULE_UPGRADED',\n            'SUB_MODULE_ACTIVATED',\n            'SUB_MODULE_DEACTIVATED',\n            'SUB_MODULE_EFFECT_APPLIED',\n            'SUB_MODULE_EFFECT_REMOVED',\n            'COMBAT_UPDATED',\n            'TECH_UNLOCKED',\n            'TECH_UPDATED',\n          ].includes(type as ModuleEventType);\n        };\n\n        if (isValidEventType(action.target)) {\n          // Emit the specified event\n          moduleEventBus.emit({\n            type: action.target,\n            moduleId: emitValue.moduleId || 'automation',\n            moduleType: (emitValue.moduleType || 'resource-manager') as ModuleType,\n            timestamp: Date.now(),\n            data: emitValue.data || {},\n          });\n        } else {\n          console.warn(`Invalid event type: ${action.target}`);\n        }\n        break;\n      }\n\n      default:\n        console.warn(`Unsupported action type: ${action.type}`);\n    }\n  }\n\n  // Add a helper method to convert action values to Record<string, unknown>\n  private convertActionValueToRecord(value: unknown): Record<string, unknown> {\n    if (value === null || value === undefined) {\n      return {};\n    }\n\n    if (typeof value === 'object') {\n      // If it's already an object, convert it to a Record<string, unknown>\n      // First cast to unknown, then to Record<string, unknown> to avoid type errors\n      return Object.entries(value as unknown as Record<string, unknown>).reduce(\n        (acc, [key, val]) => {\n          acc[key] = val;\n          return acc;\n        },\n        {} as Record<string, unknown>\n      );\n    }\n\n    // If it's a primitive value, wrap it in an object\n    return { value };\n  }\n\n  /**\n   * Update method called by the game loop\n   */\n  private update(_deltaTime: number, _elapsedTime: number): void {\n    // Process any pending routines\n    // The queue itself handles the execution\n  }\n\n  /**\n   * Handle error events\n   */\n  private handleErrorEvent = (_event: ModuleEvent): void => {\n    // Find emergency response routines\n    const emergencyRoutines = Array.from(this.routines.values()).filter(\n      routine =>\n        routine.enabled &&\n        routine.type === 'emergency-response' &&\n        routine.tags.includes('error-handling')\n    );\n\n    // Schedule emergency routines immediately\n    emergencyRoutines.forEach(routine => {\n      this.routineQueue.enqueue({\n        ...routine,\n        executionTime: Date.now(), // Execute immediately\n      });\n    });\n  };\n\n  /**\n   * Handle resource shortage events\n   */\n  private handleResourceShortage = (event: ModuleEvent): void => {\n    // Find resource balancing routines\n    const resourceRoutines = Array.from(this.routines.values()).filter(\n      routine =>\n        routine.enabled &&\n        routine.type === 'resource-balancing' &&\n        routine.tags.includes(\n          event.data && typeof event.data === 'object' && 'resourceType' in event.data\n            ? String(event.data.resourceType)\n            : 'general'\n        )\n    );\n\n    // Schedule resource routines with high priority\n    resourceRoutines.forEach(routine => {\n      this.routineQueue.enqueue({\n        ...routine,\n        executionTime: Date.now(), // Execute immediately\n        priority: MessagePriority.HIGH, // Override with high priority\n      });\n    });\n  };\n\n  /**\n   * Handle status changed events\n   */\n  private handleStatusChanged = (event: ModuleEvent): void => {\n    // Find relevant routines based on status\n    const statusRoutines = Array.from(this.routines.values()).filter(\n      routine =>\n        routine.enabled &&\n        (routine.type === 'system-maintenance' || routine.type === 'performance-optimization') &&\n        routine.tags.includes(\n          event.data && typeof event.data === 'object' && 'status' in event.data\n            ? String(event.data.status)\n            : 'general'\n        )\n    );\n\n    // Schedule status routines\n    statusRoutines.forEach(routine => {\n      this.routineQueue.enqueue({\n        ...routine,\n        executionTime: Date.now() + 1000, // Small delay to allow system to stabilize\n      });\n    });\n  };\n\n  /**\n   * Get all routines\n   */\n  public getAllRoutines(): GlobalRoutine[] {\n    return Array.from(this.routines.values());\n  }\n\n  /**\n   * Get routines by type\n   */\n  public getRoutinesByType(type: GlobalRoutineType): GlobalRoutine[] {\n    return Array.from(this.routines.values()).filter(routine => routine.type === type);\n  }\n\n  /**\n   * Get routines by system\n   */\n  public getRoutinesBySystem(systemId: SystemId): GlobalRoutine[] {\n    return Array.from(this.routines.values()).filter(routine => routine.systems.includes(systemId));\n  }\n\n  /**\n   * Get routines by tag\n   */\n  public getRoutinesByTag(tag: string): GlobalRoutine[] {\n    return Array.from(this.routines.values()).filter(routine => routine.tags.includes(tag));\n  }\n\n  /**\n   * Get active routines\n   */\n  public getActiveRoutines(): GlobalRoutine[] {\n    return Array.from(this.routines.values()).filter(routine => routine.enabled);\n  }\n\n  /**\n   * Clean up resources\n   */\n  public cleanup(): void {\n    // Unregister from game loop\n    gameLoopManager.unregisterUpdate('global-automation-manager');\n\n    // Unsubscribe from events\n    const unsubscribeError = moduleEventBus.subscribe(\n      'ERROR_OCCURRED' as ModuleEventType,\n      this.handleErrorEvent\n    );\n    const unsubscribeShortage = moduleEventBus.subscribe(\n      'RESOURCE_SHORTAGE' as ModuleEventType,\n      this.handleResourceShortage\n    );\n    const unsubscribeStatus = moduleEventBus.subscribe(\n      'STATUS_CHANGED' as ModuleEventType,\n      this.handleStatusChanged\n    );\n\n    if (typeof unsubscribeError === 'function') {\n      unsubscribeError();\n    }\n    if (typeof unsubscribeShortage === 'function') {\n      unsubscribeShortage();\n    }\n    if (typeof unsubscribeStatus === 'function') {\n      unsubscribeStatus();\n    }\n\n    // Clear routines\n    this.routines.clear();\n    this.activeRoutines.clear();\n\n    // Clear system communications\n    this.systemCommunications.clear();\n\n    this.isInitialized = false;\n  }\n\n  /**\n   * Get the automation manager instance\n   * This method is used for testing and debugging purposes\n   */\n  public getAutomationManager(): AutomationManager | null {\n    return this._automationManager || null;\n  }\n\n  /**\n   * Get a rule by ID\n   */\n  public getRule(ruleId: string): AutomationRule | undefined {\n    // Delegate to AutomationManager\n    return this._automationManager.getRule(ruleId);\n  }\n\n  /**\n   * Update an existing rule\n   */\n  public updateRule(ruleId: string, rule: AutomationRule): void {\n    // Delegate to AutomationManager\n    this._automationManager.updateRule(ruleId, rule);\n\n    // Emit event\n    moduleEventBus.emit({\n      type: 'STATUS_CHANGED', // Use a valid ModuleEventType\n      moduleId: rule.moduleId,\n      moduleType: 'resource-manager',\n      timestamp: Date.now(),\n      data: { ruleId, rule, status: 'updated' },\n    });\n  }\n\n  /**\n   * Register a new rule\n   */\n  public registerRule(rule: AutomationRule): void {\n    // Delegate to AutomationManager\n    this._automationManager.registerRule(rule);\n\n    // Emit event\n    moduleEventBus.emit({\n      type: 'AUTOMATION_STARTED', // Use a valid ModuleEventType\n      moduleId: rule.moduleId,\n      moduleType: 'resource-manager',\n      timestamp: Date.now(),\n      data: { ruleId: rule.id, rule },\n    });\n  }\n}\n\n// Export singleton instance\nexport const globalAutomationManager = new GlobalAutomationManager(\n  // We'll need to import the actual instance in the initialization file\n  null as unknown as AutomationManager\n);\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/colony/ColonyManagerImpl.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/combat/CombatManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/combat/CombatMechanicsSystem.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/combat/EnvironmentalHazardManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/combat/ObjectDetectionSystem.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/combat/ThreatAssessmentManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/combat/WarShipManagerImpl.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/effects/EffectLifecycleManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/effects/ParticleSystemManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/exploration/ExplorationManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/exploration/ExplorationManagerImpl.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/exploration/ReconShipManagerImpl.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/factions/FactionBehaviorManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/factions/FactionRelationshipManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/factions/factionManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/game/AsteroidFieldManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/game/AutomationManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/game/GameLoopManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/game/ParticleSystemManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/game/ResourceManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/game/animationManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/game/assetManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/game/gameManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/game/salvageManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/game/techTreeManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/mining/MiningResourceIntegration.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/mining/MiningShipManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/mining/MiningShipManagerImpl.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/module/BaseModuleManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/module/ModuleAttachmentManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/module/ModuleManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/module/ModuleManagerWrapper.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/module/ModuleManagerWrapper.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/module/ModuleStatusManager.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'ResourceType' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 1,
        "column": 10,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 1,
        "endColumn": 22
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { ResourceType } from \"./../../types/resources/ResourceTypes\";\nimport { ModuleEvent, moduleEventBus, ModuleEventType } from '../../lib/modules/ModuleEvents';\nimport { moduleManager } from './ModuleManager';\n\n/**\n * Extended module status types beyond the basic 'active', 'constructing', 'inactive'\n */\nexport type ExtendedModuleStatus =\n  // Basic statuses\n  | 'active'\n  | 'constructing'\n  | 'inactive'\n  // Performance statuses\n  | 'optimized'\n  | 'degraded'\n  | 'overloaded'\n  // Operational statuses\n  | 'maintenance'\n  | 'upgrading'\n  | 'repairing'\n  // Error statuses\n  | 'error'\n  | 'critical'\n  | 'offline'\n  // Special statuses\n  | 'standby'\n  | 'powersave'\n  | 'boost';\n\n/**\n * Status history entry\n */\nexport interface StatusHistoryEntry {\n  status: ExtendedModuleStatus;\n  timestamp: number;\n  duration?: number;\n  reason?: string;\n}\n\n/**\n * Module alert interface\n */\nexport interface ModuleAlert {\n  level: 'info' | 'warning' | 'error' | 'critical';\n  message: string;\n  timestamp: number;\n  acknowledged: boolean;\n}\n\n/**\n * Module status details\n */\nexport interface ModuleStatusDetails {\n  currentStatus: ExtendedModuleStatus;\n  previousStatus?: ExtendedModuleStatus;\n  history: StatusHistoryEntry[];\n  lastUpdated: number;\n  metrics: {\n    uptime: number;\n    efficiency: number;\n    reliability: number;\n    performance: number;\n  };\n  alerts: ModuleAlert[];\n}\n\n/**\n * Module status manager\n * Manages the status tracking, history, and notifications for modules\n */\nexport class ModuleStatusManager {\n  private moduleStatuses: Map<string, ModuleStatusDetails>;\n  private statusUpdateInterval: number;\n  private intervalId?: NodeJS.Timeout;\n\n  constructor(statusUpdateInterval = 60000) {\n    // Default to 1 minute updates\n    this.moduleStatuses = new Map();\n    this.statusUpdateInterval = statusUpdateInterval;\n\n    // Subscribe to module events\n    this.subscribeToEvents();\n\n    // Start status update interval\n    this.startStatusUpdates();\n  }\n\n  /**\n   * Subscribe to module events\n   */\n  private subscribeToEvents(): void {\n    // Module lifecycle events\n    moduleEventBus.subscribe('MODULE_CREATED' as ModuleEventType, this.handleModuleCreated);\n    moduleEventBus.subscribe('MODULE_ATTACHED' as ModuleEventType, this.handleModuleAttached);\n    moduleEventBus.subscribe('MODULE_DETACHED' as ModuleEventType, this.handleModuleDetached);\n    moduleEventBus.subscribe('MODULE_UPGRADED' as ModuleEventType, this.handleModuleUpgraded);\n    moduleEventBus.subscribe('MODULE_ACTIVATED' as ModuleEventType, this.handleModuleActivated);\n    moduleEventBus.subscribe('MODULE_DEACTIVATED' as ModuleEventType, this.handleModuleDeactivated);\n\n    // Status events\n    moduleEventBus.subscribe('STATUS_CHANGED' as ModuleEventType, this.handleStatusChanged);\n    moduleEventBus.subscribe('ERROR_OCCURRED' as ModuleEventType, this.handleErrorOccurred);\n\n    // Resource events that might affect status\n    moduleEventBus.subscribe('RESOURCE_SHORTAGE' as ModuleEventType, this.handleResourceShortage);\n  }\n\n  /**\n   * Start periodic status updates\n   */\n  private startStatusUpdates(): void {\n    this.intervalId = setInterval(() => {\n      this.updateAllModuleMetrics();\n    }, this.statusUpdateInterval);\n  }\n\n  /**\n   * Stop periodic status updates\n   */\n  public stopStatusUpdates(): void {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n      this.intervalId = undefined;\n    }\n  }\n\n  /**\n   * Update metrics for all modules\n   */\n  private updateAllModuleMetrics(): void {\n    const modules = Array.from(moduleManager.getActiveModules());\n\n    for (const module of modules) {\n      this.updateModuleMetrics(module.id);\n    }\n  }\n\n  /**\n   * Update metrics for a specific module\n   */\n  private updateModuleMetrics(moduleId: string): void {\n    const statusDetails = this.moduleStatuses.get(moduleId);\n    if (!statusDetails) {\n      return;\n    }\n\n    const module = moduleManager.getModule(moduleId);\n    if (!module) {\n      return;\n    }\n\n    // Calculate uptime (time since first activation)\n    const firstActivation = statusDetails.history.find(entry => entry.status === 'active');\n    if (firstActivation) {\n      const uptime = module.isActive\n        ? Date.now() - firstActivation.timestamp\n        : statusDetails.metrics.uptime;\n\n      statusDetails.metrics.uptime = uptime;\n    }\n\n    // Calculate efficiency based on status\n    let efficiency = 1.0;\n    switch (statusDetails.currentStatus) {\n      case 'optimized':\n        efficiency = 1.2; // 20% boost\n        break;\n      case 'degraded':\n        efficiency = 0.8; // 20% reduction\n        break;\n      case 'overloaded':\n        efficiency = 0.6; // 40% reduction\n        break;\n      case 'maintenance':\n      case 'repairing':\n        efficiency = 0.5; // 50% reduction\n        break;\n      case 'powersave':\n        efficiency = 0.7; // 30% reduction\n        break;\n      case 'boost':\n        efficiency = 1.5; // 50% boost\n        break;\n      case 'error':\n      case 'critical':\n      case 'offline':\n        efficiency = 0; // No efficiency\n        break;\n      default:\n        efficiency = 1.0; // Normal efficiency\n    }\n    statusDetails.metrics.efficiency = efficiency;\n\n    // Calculate reliability (percentage of time without errors)\n    const errorEntries = statusDetails.history.filter(entry =>\n      ['error', 'critical', 'offline'].includes(entry.status)\n    );\n    const totalTime = Date.now() - statusDetails.history[0].timestamp;\n    let errorTime = 0;\n\n    for (const entry of errorEntries) {\n      errorTime += entry.duration || 0;\n    }\n\n    statusDetails.metrics.reliability = Math.max(0, Math.min(1, 1 - errorTime / totalTime));\n\n    // Calculate performance based on level and status\n    let performance = module.level / 10; // Base performance from level (0.1 to 1.0)\n\n    // Adjust based on status\n    switch (statusDetails.currentStatus) {\n      case 'optimized':\n        performance *= 1.2; // 20% boost\n        break;\n      case 'boost':\n        performance *= 1.5; // 50% boost\n        break;\n      case 'degraded':\n        performance *= 0.8; // 20% reduction\n        break;\n      case 'overloaded':\n        performance *= 0.7; // 30% reduction\n        break;\n      default:\n        // No adjustment\n        break;\n    }\n\n    statusDetails.metrics.performance = Math.min(1, performance);\n\n    // Update last updated timestamp\n    statusDetails.lastUpdated = Date.now();\n\n    // Emit metrics updated event\n    moduleEventBus.emit({\n      type: 'STATUS_CHANGED' as ModuleEventType,\n      moduleId,\n      moduleType: module.type,\n      timestamp: Date.now(),\n      data: {\n        status: statusDetails.currentStatus,\n        metrics: statusDetails.metrics,\n      },\n    });\n  }\n\n  /**\n   * Initialize status tracking for a module\n   */\n  public initializeModuleStatus(moduleId: string): void {\n    const module = moduleManager.getModule(moduleId);\n    if (!module) {\n      console.error(`[ModuleStatusManager] Module ${moduleId} not found`);\n      return;\n    }\n\n    // Create initial status details\n    const statusDetails: ModuleStatusDetails = {\n      currentStatus: module.status as ExtendedModuleStatus,\n      history: [\n        {\n          status: module.status as ExtendedModuleStatus,\n          timestamp: Date.now(),\n        },\n      ],\n      lastUpdated: Date.now(),\n      metrics: {\n        uptime: 0,\n        efficiency: 1.0,\n        reliability: 1.0,\n        performance: module.level / 10,\n      },\n      alerts: [],\n    };\n\n    this.moduleStatuses.set(moduleId, statusDetails);\n  }\n\n  /**\n   * Update the status of a module\n   */\n  public updateModuleStatus(\n    moduleId: string,\n    status: ExtendedModuleStatus,\n    reason?: string\n  ): boolean {\n    const module = moduleManager.getModule(moduleId);\n    if (!module) {\n      console.error(`[ModuleStatusManager] Module ${moduleId} not found`);\n      return false;\n    }\n\n    let statusDetails = this.moduleStatuses.get(moduleId);\n\n    // Initialize status tracking if not already done\n    if (!statusDetails) {\n      this.initializeModuleStatus(moduleId);\n      statusDetails = this.moduleStatuses.get(moduleId);\n      if (!statusDetails) {\n        return false;\n      }\n    }\n\n    // Update previous status entry with duration\n    const previousEntry = statusDetails.history[statusDetails.history.length - 1];\n    if (previousEntry) {\n      previousEntry.duration = Date.now() - previousEntry.timestamp;\n    }\n\n    // Add new status entry\n    const newEntry: StatusHistoryEntry = {\n      status,\n      timestamp: Date.now(),\n      reason,\n    };\n\n    statusDetails.history.push(newEntry);\n\n    // Update current and previous status\n    statusDetails.previousStatus = statusDetails.currentStatus;\n    statusDetails.currentStatus = status;\n    statusDetails.lastUpdated = Date.now();\n\n    // Update module's basic status if it's one of the core statuses\n    if (['active', 'constructing', 'inactive'].includes(status)) {\n      module.status = status as 'active' | 'constructing' | 'inactive';\n\n      // Update module's active state\n      if (status === 'active') {\n        module.isActive = true;\n      } else if (status === 'inactive') {\n        module.isActive = false;\n      }\n    }\n\n    // Emit status changed event\n    moduleEventBus.emit({\n      type: 'STATUS_CHANGED' as ModuleEventType,\n      moduleId,\n      moduleType: module.type,\n      timestamp: Date.now(),\n      data: {\n        status,\n        previousStatus: statusDetails.previousStatus,\n        reason,\n      },\n    });\n\n    // Create alert for critical statuses\n    if (['error', 'critical', 'offline'].includes(status)) {\n      this.addAlert(\n        moduleId,\n        'error',\n        `Module entered ${status} state${reason ? ': ' + reason : ''}`\n      );\n    } else if (['degraded', 'overloaded'].includes(status)) {\n      this.addAlert(\n        moduleId,\n        'warning',\n        `Module performance degraded${reason ? ': ' + reason : ''}`\n      );\n    } else if (['optimized', 'boost'].includes(status)) {\n      this.addAlert(moduleId, 'info', `Module performance enhanced${reason ? ': ' + reason : ''}`);\n    }\n\n    return true;\n  }\n\n  /**\n   * Add an alert for a module\n   */\n  public addAlert(\n    moduleId: string,\n    level: 'info' | 'warning' | 'error' | 'critical',\n    message: string\n  ): void {\n    const statusDetails = this.moduleStatuses.get(moduleId);\n    if (!statusDetails) {\n      return;\n    }\n\n    const alert = {\n      level,\n      message,\n      timestamp: Date.now(),\n      acknowledged: false,\n    };\n\n    statusDetails.alerts.push(alert);\n\n    // Emit alert event\n    const module = moduleManager.getModule(moduleId);\n    if (module) {\n      moduleEventBus.emit({\n        type: 'ERROR_OCCURRED' as ModuleEventType,\n        moduleId,\n        moduleType: module.type,\n        timestamp: Date.now(),\n        data: { alert },\n      });\n    }\n  }\n\n  /**\n   * Acknowledge an alert\n   */\n  public acknowledgeAlert(moduleId: string, alertIndex: number): boolean {\n    const statusDetails = this.moduleStatuses.get(moduleId);\n    if (!statusDetails || alertIndex >= statusDetails.alerts.length) {\n      return false;\n    }\n\n    statusDetails.alerts[alertIndex].acknowledged = true;\n    return true;\n  }\n\n  /**\n   * Get status details for a module\n   */\n  public getModuleStatusDetails(moduleId: string): ModuleStatusDetails | undefined {\n    return this.moduleStatuses.get(moduleId);\n  }\n\n  /**\n   * Get current status for a module\n   */\n  public getModuleStatus(moduleId: string): ExtendedModuleStatus | undefined {\n    return this.moduleStatuses.get(moduleId)?.currentStatus;\n  }\n\n  /**\n   * Get status history for a module\n   */\n  public getModuleStatusHistory(moduleId: string): StatusHistoryEntry[] {\n    return this.moduleStatuses.get(moduleId)?.history || [];\n  }\n\n  /**\n   * Get alerts for a module\n   */\n  public getModuleAlerts(moduleId: string, onlyUnacknowledged = false): ModuleAlert[] {\n    const alerts = this.moduleStatuses.get(moduleId)?.alerts || [];\n    return onlyUnacknowledged ? alerts.filter(alert => !alert.acknowledged) : alerts;\n  }\n\n  /**\n   * Get modules with a specific status\n   */\n  public getModulesByStatus(status: ExtendedModuleStatus): string[] {\n    const moduleIds: string[] = [];\n\n    this.moduleStatuses.forEach((details, moduleId) => {\n      if (details.currentStatus === status) {\n        moduleIds.push(moduleId);\n      }\n    });\n\n    return moduleIds;\n  }\n\n  /**\n   * Get modules with alerts\n   */\n  public getModulesWithAlerts(level?: 'info' | 'warning' | 'error' | 'critical'): string[] {\n    const moduleIds: string[] = [];\n\n    this.moduleStatuses.forEach((details, moduleId) => {\n      const hasAlerts = level\n        ? details.alerts.some(alert => alert.level === level && !alert.acknowledged)\n        : details.alerts.some(alert => !alert.acknowledged);\n\n      if (hasAlerts) {\n        moduleIds.push(moduleId);\n      }\n    });\n\n    return moduleIds;\n  }\n\n  /**\n   * Handle module created event\n   */\n  private handleModuleCreated = (event: ModuleEvent): void => {\n    this.initializeModuleStatus(event.moduleId);\n  };\n\n  /**\n   * Handle module attached event\n   */\n  private handleModuleAttached = (event: ModuleEvent): void => {\n    const { moduleId } = event;\n    this.updateModuleStatus(moduleId, 'inactive', 'Module attached');\n  };\n\n  /**\n   * Handle module detached event\n   */\n  private handleModuleDetached = (event: ModuleEvent): void => {\n    const { moduleId } = event;\n    // We don't remove the status history, just mark it as detached\n    this.updateModuleStatus(moduleId, 'inactive', 'Module detached');\n  };\n\n  /**\n   * Handle module upgraded event\n   */\n  private handleModuleUpgraded = (event: ModuleEvent): void => {\n    const newLevel = event.data?.newLevel as number | undefined;\n    this.updateModuleStatus(event.moduleId, 'upgrading', `Upgrading to level ${newLevel}`);\n\n    // After a short delay, return to active status\n    setTimeout(() => {\n      this.updateModuleStatus(event.moduleId, 'active', 'Upgrade completed');\n    }, 5000);\n  };\n\n  /**\n   * Handle module activated event\n   */\n  private handleModuleActivated = (event: ModuleEvent): void => {\n    const { moduleId } = event;\n    this.updateModuleStatus(moduleId, 'active', 'Module activated');\n  };\n\n  /**\n   * Handle module deactivated event\n   */\n  private handleModuleDeactivated = (event: ModuleEvent): void => {\n    const { moduleId } = event;\n    this.updateModuleStatus(moduleId, 'inactive', 'Module deactivated');\n  };\n\n  /**\n   * Handle status changed event\n   */\n  private handleStatusChanged = (event: ModuleEvent): void => {\n    // Only handle events from other sources to avoid loops\n    if (event.data && event.data.source !== 'ModuleStatusManager') {\n      const { moduleId } = event;\n      const status = event.data?.status as ExtendedModuleStatus | undefined;\n      const reason = event.data?.reason as string | undefined;\n\n      if (status && status !== this.getModuleStatus(moduleId)) {\n        this.updateModuleStatus(moduleId, status, reason);\n      }\n    }\n  };\n\n  /**\n   * Handle error occurred event\n   */\n  private handleErrorOccurred = (event: ModuleEvent): void => {\n    const { moduleId } = event;\n    const level = event.data?.level as 'info' | 'warning' | 'error' | 'critical' | undefined;\n    const message = event.data?.message as string | undefined;\n\n    // Add alert\n    if (message) {\n      this.addAlert(moduleId, level || 'error', message);\n    }\n\n    // Update status for serious errors\n    if (level === 'critical') {\n      this.updateModuleStatus(moduleId, 'critical', message || 'Critical error occurred');\n    } else if (level === 'error') {\n      this.updateModuleStatus(moduleId, 'error', message || 'Error occurred');\n    }\n  };\n\n  /**\n   * Handle resource shortage event\n   */\n  private handleResourceShortage = (event: ModuleEvent): void => {\n    const { moduleId } = event;\n    const resourceType = event.data?.resourceType as string | undefined;\n    const amount = event.data?.amount as number | undefined;\n    const required = event.data?.required as number | undefined;\n\n    // Add alert\n    this.addAlert(\n      moduleId,\n      'warning',\n      `Resource shortage: ${resourceType} (${amount}/${required})`\n    );\n\n    // Update status if module is active\n    const currentStatus = this.getModuleStatus(moduleId);\n    if (currentStatus === 'active') {\n      this.updateModuleStatus(moduleId, 'degraded', `Resource shortage: ${resourceType}`);\n    }\n  };\n\n  /**\n   * Clean up resources\n   */\n  public cleanup(): void {\n    // Stop interval\n    this.stopStatusUpdates();\n\n    // Unsubscribe from events\n    const unsubscribeCreated = moduleEventBus.subscribe(\n      'MODULE_CREATED' as ModuleEventType,\n      this.handleModuleCreated\n    );\n    const unsubscribeAttached = moduleEventBus.subscribe(\n      'MODULE_ATTACHED' as ModuleEventType,\n      this.handleModuleAttached\n    );\n    const unsubscribeDetached = moduleEventBus.subscribe(\n      'MODULE_DETACHED' as ModuleEventType,\n      this.handleModuleDetached\n    );\n    const unsubscribeUpgraded = moduleEventBus.subscribe(\n      'MODULE_UPGRADED' as ModuleEventType,\n      this.handleModuleUpgraded\n    );\n    const unsubscribeActivated = moduleEventBus.subscribe(\n      'MODULE_ACTIVATED' as ModuleEventType,\n      this.handleModuleActivated\n    );\n    const unsubscribeDeactivated = moduleEventBus.subscribe(\n      'MODULE_DEACTIVATED' as ModuleEventType,\n      this.handleModuleDeactivated\n    );\n    const unsubscribeStatusChanged = moduleEventBus.subscribe(\n      'STATUS_CHANGED' as ModuleEventType,\n      this.handleStatusChanged\n    );\n    const unsubscribeErrorOccurred = moduleEventBus.subscribe(\n      'ERROR_OCCURRED' as ModuleEventType,\n      this.handleErrorOccurred\n    );\n    const unsubscribeResourceShortage = moduleEventBus.subscribe(\n      'RESOURCE_SHORTAGE' as ModuleEventType,\n      this.handleResourceShortage\n    );\n\n    if (typeof unsubscribeCreated === 'function') {\n      unsubscribeCreated();\n    }\n    if (typeof unsubscribeAttached === 'function') {\n      unsubscribeAttached();\n    }\n    if (typeof unsubscribeDetached === 'function') {\n      unsubscribeDetached();\n    }\n    if (typeof unsubscribeUpgraded === 'function') {\n      unsubscribeUpgraded();\n    }\n    if (typeof unsubscribeActivated === 'function') {\n      unsubscribeActivated();\n    }\n    if (typeof unsubscribeDeactivated === 'function') {\n      unsubscribeDeactivated();\n    }\n    if (typeof unsubscribeStatusChanged === 'function') {\n      unsubscribeStatusChanged();\n    }\n    if (typeof unsubscribeErrorOccurred === 'function') {\n      unsubscribeErrorOccurred();\n    }\n    if (typeof unsubscribeResourceShortage === 'function') {\n      unsubscribeResourceShortage();\n    }\n\n    // Clear data\n    this.moduleStatuses.clear();\n  }\n}\n\n// Export singleton instance\nexport const moduleStatusManager = new ModuleStatusManager();\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/module/ModuleUpgradeManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/module/OfficerManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/module/ShipHangarManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/module/SubModuleManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/resource/AdaptivePerformanceManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/resource/ResourceConversionManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/resource/ResourceCostManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/resource/ResourceExchangeManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/resource/ResourceFlowManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/resource/ResourceFlowTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/resource/ResourceIntegration.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/resource/ResourcePerformanceMonitor.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/resource/ResourcePoolManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/resource/ResourceStorageManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/resource/ResourceThresholdManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/resource/ResourceTransferManager.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/ships/ShipHangarManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/ships/ShipManagerImpl.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/ships/StandardShipHangarManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/weapons/AdvancedWeaponEffectManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/weapons/WeaponEffectManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/weapons/WeaponUpgradeManager.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/pages/ColonyManagementPage.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/pages/CombatSystemPage.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/pages/ConverterManagementPage.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'React' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 1,
        "column": 8,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 1,
        "endColumn": 13
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from \"react\";\n ",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/pages/PerformanceAnalysisDashboard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/pages/ResourceManagementPage.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/pages/ResourceRegistryDemo.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/pages/performance/LongSessionMemoryPage.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/pages/performance/MultitabPerformanceTestPage.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'report' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 24,
        "column": 10,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 24,
        "endColumn": 16
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * MultitabPerformanceTestPage\n *\n * A page component that combines the MultitabPerformanceLauncher and MultitabPerformanceResults\n * components to provide a complete multi-tab performance testing solution.\n */\n\nimport * as React from \"react\";\nimport { useEffect, useState } from 'react';\nimport { useSearchParams } from 'react-router-dom';\nimport MultitabPerformanceLauncher from '../../components/performance/MultitabPerformanceLauncher';\nimport MultitabPerformanceResults from '../../components/performance/MultitabPerformanceResults';\nimport { MultitabPerformanceResult } from '../../tests/performance/MultitabPerformanceTestSuite';\n\ntype ResultSet = MultitabPerformanceResult[] | Record<string, MultitabPerformanceResult[]>;\n\n/**\n * MultitabPerformanceTestPage component\n */\nconst MultitabPerformanceTestPage: React.FC = () => {\n  const [searchParams] = useSearchParams();\n  const [results, setResults] = useState<ResultSet | null>(null);\n  const [isCoordinator, setIsCoordinator] = useState(true);\n  const [report, setReport] = useState<string>('');\n\n  // Check URL parameters to determine if this is a worker tab\n  useEffect(() => {\n    const isWorker = searchParams.get('worker') === 'true';\n    setIsCoordinator(!isWorker);\n  }, [searchParams]);\n\n  /**\n   * Handle test results from the performance launcher\n   */\n  const handleTestResults = (newResults: ResultSet) => {\n    setResults(newResults);\n\n    // Store results in localStorage for persistence\n    try {\n      localStorage.setItem('multitab_performance_results', JSON.stringify(newResults));\n    } catch (e) {\n      console.warn('Failed to store test results in localStorage:', e);\n    }\n  };\n\n  /**\n   * Handle generated reports\n   */\n  const handleReportGenerated = (generatedReport: string) => {\n    setReport(generatedReport);\n  };\n\n  // Try to load previous results from localStorage\n  useEffect(() => {\n    try {\n      const savedResults = localStorage.getItem('multitab_performance_results');\n      if (savedResults) {\n        setResults(JSON.parse(savedResults));\n      }\n    } catch (e) {\n      console.warn('Failed to load previous test results:', e);\n    }\n  }, []);\n\n  return (\n    <div className=\"multitab-performance-test-page\">\n      <header>\n        <h1>Multi-Tab Performance Testing</h1>\n        <p className=\"subtitle\">\n          {isCoordinator\n            ? 'Test application performance with multiple tabs open'\n            : 'Worker tab - leave this open and return to the coordinator tab'}\n        </p>\n      </header>\n\n      <div className=\"page-content\">\n        <section className=\"launcher-section\">\n          <MultitabPerformanceLauncher\n            isCoordinator={isCoordinator}\n            onTestResults={handleTestResults}\n          />\n        </section>\n\n        {isCoordinator && results && (\n          <section className=\"results-section\">\n            <MultitabPerformanceResults\n              results={results}\n              onReportGenerated={handleReportGenerated}\n            />\n          </section>\n        )}\n\n        {isCoordinator && (\n          <section className=\"info-section\">\n            <h2>About Multi-Tab Performance Testing</h2>\n            <p>\n              Multi-tab performance testing evaluates how your application behaves when users have\n              multiple instances open simultaneously in different browser tabs. This is crucial for\n              modern web applications where users often work with multiple tabs.\n            </p>\n\n            <h3>Why Test Multi-Tab Performance?</h3>\n            <ul>\n              <li>\n                <strong>Resource Contention:</strong> Multiple tabs can compete for limited browser\n                resources, causing performance degradation.\n              </li>\n              <li>\n                <strong>Shared Storage:</strong> Tabs may access the same localStorage, IndexedDB,\n                or other shared storage, leading to potential conflicts.\n              </li>\n              <li>\n                <strong>Memory Usage:</strong> Total memory consumption can grow dramatically with\n                multiple tabs, potentially causing browser slowdowns or crashes.\n              </li>\n              <li>\n                <strong>Background Processing:</strong> Tabs in the background may continue\n                consuming resources, affecting the performance of the active tab.\n              </li>\n            </ul>\n\n            <h3>How to Use This Tool</h3>\n            <ol>\n              <li>\n                Click \"Add Tab\" to open additional worker tabs (you need at least 2 tabs total)\n              </li>\n              <li>Select a test type and configure test parameters</li>\n              <li>Click \"Run Test\" to execute the performance test across all tabs</li>\n              <li>Review the results to identify potential performance issues</li>\n              <li>Download the detailed report for sharing or documentation</li>\n            </ol>\n\n            <p className=\"note\">\n              <strong>Note:</strong> For accurate results, ensure that all tabs remain open and\n              visible during testing. Browser throttling of background tabs can affect the accuracy\n              of test results.\n            </p>\n          </section>\n        )}\n      </div>\n\n      <style jsx>{`\n        .multitab-performance-test-page {\n          max-width: 1200px;\n          margin: 0 auto;\n          padding: 20px;\n          font-family:\n            system-ui,\n            -apple-system,\n            BlinkMacSystemFont,\n            'Segoe UI',\n            Roboto,\n            Oxygen,\n            Ubuntu,\n            Cantarell,\n            'Open Sans',\n            'Helvetica Neue',\n            sans-serif;\n        }\n\n        header {\n          text-align: center;\n          margin-bottom: 30px;\n        }\n\n        h1 {\n          font-size: 32px;\n          margin-bottom: 10px;\n          color: #333;\n        }\n\n        .subtitle {\n          font-size: 18px;\n          color: #666;\n          margin: 0;\n        }\n\n        .page-content {\n          display: flex;\n          flex-direction: column;\n          gap: 30px;\n        }\n\n        .launcher-section,\n        .results-section,\n        .info-section {\n          width: 100%;\n        }\n\n        .info-section {\n          background: white;\n          border-radius: 8px;\n          padding: 25px;\n          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n        }\n\n        .info-section h2 {\n          margin-top: 0;\n          color: #333;\n          border-bottom: 1px solid #eee;\n          padding-bottom: 10px;\n          margin-bottom: 20px;\n        }\n\n        .info-section h3 {\n          margin-top: 25px;\n          margin-bottom: 15px;\n          color: #444;\n        }\n\n        .info-section p {\n          line-height: 1.6;\n          color: #555;\n          margin-bottom: 15px;\n        }\n\n        .info-section ul,\n        .info-section ol {\n          padding-left: 20px;\n          margin-bottom: 20px;\n        }\n\n        .info-section li {\n          margin-bottom: 10px;\n          line-height: 1.5;\n          color: #555;\n        }\n\n        .note {\n          background: #fffde7;\n          padding: 15px;\n          border-left: 4px solid #ffd600;\n          margin-top: 20px;\n        }\n\n        @media (max-width: 768px) {\n          .multitab-performance-test-page {\n            padding: 15px;\n          }\n\n          h1 {\n            font-size: 26px;\n          }\n\n          .subtitle {\n            font-size: 16px;\n          }\n        }\n      `}</style>\n    </div>\n  );\n};\n\nexport default MultitabPerformanceTestPage;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/registry/ResourceRegistry.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'relatedResources' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 275,
        "column": 48,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 275,
        "endColumn": 64
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'resourceType' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 837,
        "column": 48,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 837,
        "endColumn": 60
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { ResourceType, ResourceTypeMetadata } from '../types/resources/ResourceTypes';\n/**\n * ResourceRegistry.ts\n *\n * A centralized registry for resource types and metadata to ensure consistency across the codebase.\n * This registry serves as the single source of truth for resource information and helps standardize\n * the resource type system throughout the application.\n */\n\nimport { EventEmitter } from '../lib/events/EventEmitter';\nimport { ResourceCategory } from '../types/resources/StandardizedResourceTypes';\n\n/**\n * Resource quality levels\n */\nexport enum ResourceQuality {\n  LOW = 'low',\n  MEDIUM = 'medium',\n  HIGH = 'high',\n  PREMIUM = 'premium',\n}\n\n/**\n * Extended resource metadata with additional properties\n */\nexport interface ExtendedResourceMetadata extends ResourceTypeMetadata {\n  // Additional properties for resource management\n  baseValue: number;\n  weight: number;\n  storageEfficiency: number;\n  qualityLevels: Record<ResourceQuality, number>;\n  tags: string[];\n  relatedResources: ResourceType[];\n  conversionRates?: Partial<Record<ResourceType, number>>;\n  storageMultiplier: number;\n  valueMultiplier: number;\n  isRare: boolean;\n  isStackable: boolean;\n  maxStackSize: number;\n}\n\n/**\n * Resource registration options\n */\nexport interface ResourceRegistrationOptions {\n  metadata: ExtendedResourceMetadata;\n  overrideExisting?: boolean;\n}\n\n/**\n * Event data types for type safety\n */\nexport interface ResourceRegisteredEvent {\n  resourceType: ResourceType;\n  metadata: ExtendedResourceMetadata;\n}\n\nexport interface ResourceUnregisteredEvent {\n  resourceType: ResourceType;\n}\n\nexport interface ConversionRateChangedEvent {\n  sourceType: ResourceType;\n  targetType: ResourceType;\n  rate: number;\n}\n\nexport interface TagAddedEvent {\n  resourceType: ResourceType;\n  tag: string;\n}\n\nexport interface TagRemovedEvent {\n  resourceType: ResourceType;\n  tag: string;\n}\n\nexport interface ResourceMetadataUpdatedEvent {\n  resourceType: ResourceType;\n  updates: Partial<ExtendedResourceMetadata>;\n}\n\nexport interface QualityLevelChangedEvent {\n  resourceType: ResourceType;\n  quality: ResourceQuality;\n  value: number;\n}\n\nexport interface InitializationCompleteEvent {\n  resourceCount: number;\n}\n\nexport interface ImportCompleteEvent {\n  resourceCount: number;\n  conversionRateCount: number;\n}\n\nexport type RegistryEventData =\n  | ResourceRegisteredEvent\n  | ResourceUnregisteredEvent\n  | ConversionRateChangedEvent\n  | TagAddedEvent\n  | TagRemovedEvent\n  | ResourceMetadataUpdatedEvent\n  | QualityLevelChangedEvent\n  | InitializationCompleteEvent\n  | ImportCompleteEvent;\n\nexport type RegistryEventType =\n  | 'resourceRegistered'\n  | 'resourceUnregistered'\n  | 'conversionRateChanged'\n  | 'tagAdded'\n  | 'tagRemoved'\n  | 'resourceMetadataUpdated'\n  | 'qualityLevelChanged'\n  | 'initializationComplete'\n  | 'importComplete';\n\n/**\n * Resource Registry Event interface for use with EventEmitter\n */\nexport interface ResourceRegistryEvent {\n  type: RegistryEventType;\n  data: RegistryEventData;\n  timestamp: number;\n}\n\n/**\n * Resource Registry class\n *\n * Provides a centralized registry for resource types and metadata.\n * Implements the Singleton pattern to ensure only one instance exists.\n */\nexport class ResourceRegistry {\n  // Singleton instance\n  private static _instance: ResourceRegistry | null = null;\n\n  // Resource metadata storage\n  private resourceMetadata: Map<ResourceType, ExtendedResourceMetadata> = new Map();\n\n  // Resource category mappings\n  private resourcesByCategory: Map<ResourceCategory, Set<ResourceType>> = new Map();\n\n  // Resource tag mappings\n  private resourcesByTag: Map<string, Set<ResourceType>> = new Map();\n\n  // Resource quality mappings\n  private resourcesByQuality: Map<ResourceQuality, Map<ResourceType, number>> = new Map();\n\n  // Resource conversion mappings\n  private conversionRates: Map<ResourceType, Map<ResourceType, number>> = new Map();\n\n  // Event listeners\n  private listeners: Map<RegistryEventType, Set<(data: RegistryEventData) => void>> = new Map();\n\n  // Event emitter for typed events\n  private eventEmitter: EventEmitter<ResourceRegistryEvent>;\n\n  /**\n   * Get the singleton instance of ResourceRegistry\n   */\n  public static getInstance(): ResourceRegistry {\n    if (!ResourceRegistry._instance) {\n      ResourceRegistry._instance = new ResourceRegistry();\n    }\n    return ResourceRegistry._instance;\n  }\n\n  /**\n   * Private constructor to enforce singleton pattern\n   */\n  private constructor() {\n    this.eventEmitter = new EventEmitter<ResourceRegistryEvent>();\n    this.initializeRegistry();\n  }\n\n  /**\n   * Initialize the registry with default resources\n   */\n  private initializeRegistry(): void {\n    // Initialize category maps\n    Object.values(ResourceCategory).forEach(category => {\n      this.resourcesByCategory.set(category, new Set());\n    });\n\n    // Initialize quality maps\n    Object.values(ResourceQuality).forEach(quality => {\n      this.resourcesByQuality.set(quality, new Map());\n    });\n\n    // Register built-in resources from StandardizedResourceTypes\n    this.registerBuiltInResources();\n  }\n\n  /**\n   * Register built-in resources from StandardizedResourceTypes\n   */\n  private registerBuiltInResources(): void {\n    // Register each resource type with extended metadata\n    // This would normally come from a configuration file or database\n    // For now, we'll hardcode some example values\n\n    // Example for MINERALS\n    this.registerResource({\n      metadata: {\n        id: ResourceType.MINERALS,\n        displayName: 'Minerals',\n        description: 'Basic building materials',\n        icon: 'minerals-icon',\n        category: ResourceCategory.BASIC,\n        defaultMax: 1000,\n        baseValue: 1.0,\n        weight: 1.0,\n        storageEfficiency: 0.9,\n        qualityLevels: {\n          [ResourceQuality.LOW]: 0.8,\n          [ResourceQuality.MEDIUM]: 1.0,\n          [ResourceQuality.HIGH]: 1.2,\n          [ResourceQuality.PREMIUM]: 1.5,\n        },\n        tags: ['basic', 'construction', 'mining'],\n        relatedResources: [ResourceType.IRON, ResourceType.COPPER, ResourceType.TITANIUM],\n        storageMultiplier: 1.0,\n        valueMultiplier: 1.0,\n        isRare: false,\n        isStackable: true,\n        maxStackSize: 100,\n      },\n    });\n\n    // Example for ENERGY\n    this.registerResource({\n      metadata: {\n        id: ResourceType.ENERGY,\n        displayName: 'Energy',\n        description: 'Power for modules and systems',\n        icon: 'energy-icon',\n        category: ResourceCategory.BASIC,\n        defaultMax: 1000,\n        baseValue: 1.2,\n        weight: 0.0,\n        storageEfficiency: 0.7,\n        qualityLevels: {\n          [ResourceQuality.LOW]: 0.7,\n          [ResourceQuality.MEDIUM]: 1.0,\n          [ResourceQuality.HIGH]: 1.3,\n          [ResourceQuality.PREMIUM]: 1.6,\n        },\n        tags: ['basic', 'power', 'production'],\n        relatedResources: [ResourceType.PLASMA],\n        conversionRates: {\n          [ResourceType.PLASMA]: 0.5,\n        },\n        storageMultiplier: 1.0,\n        valueMultiplier: 1.0,\n        isRare: false,\n        isStackable: true,\n        maxStackSize: 100,\n      },\n    });\n\n    // Additional resources would be registered here\n    // ...\n  }\n\n  /**\n   * Register a resource with the registry\n   *\n   * @param options Registration options including metadata\n   * @returns True if registration was successful, false otherwise\n   */\n  public registerResource(options: ResourceRegistrationOptions): boolean {\n    const { metadata, overrideExisting = false } = options;\n    const { id, category, tags, qualityLevels, relatedResources, conversionRates } = metadata;\n\n    // Check if resource already exists\n    if (this.resourceMetadata.has(id) && !overrideExisting) {\n      console.warn(`Resource ${id} already registered. Use overrideExisting=true to replace.`);\n      return false;\n    }\n\n    // Register metadata\n    this.resourceMetadata.set(id, metadata);\n\n    // Register category\n    const categorySet = this.resourcesByCategory.get(category) || new Set();\n    categorySet.add(id);\n    this.resourcesByCategory.set(category, categorySet);\n\n    // Register tags\n    tags.forEach(tag => {\n      const tagSet = this.resourcesByTag.get(tag) || new Set();\n      tagSet.add(id);\n      this.resourcesByTag.set(tag, tagSet);\n    });\n\n    // Register quality levels\n    Object.entries(qualityLevels).forEach(([quality, value]) => {\n      const qualityMap = this.resourcesByQuality.get(quality as ResourceQuality) || new Map();\n      qualityMap.set(id, value);\n      this.resourcesByQuality.set(quality as ResourceQuality, qualityMap);\n    });\n\n    // Register conversion rates\n    if (conversionRates) {\n      const rateMap = new Map<ResourceType, number>();\n      Object.entries(conversionRates).forEach(([targetType, rate]) => {\n        rateMap.set(targetType as ResourceType, rate);\n      });\n      this.conversionRates.set(id, rateMap);\n    }\n\n    // Emit resource registered event\n    this.emit('resourceRegistered', { resourceType: id, metadata });\n\n    return true;\n  }\n\n  /**\n   * Unregister a resource from the registry\n   *\n   * @param resourceType The resource type to unregister\n   * @returns True if unregistration was successful, false otherwise\n   */\n  public unregisterResource(resourceType: ResourceType): boolean {\n    if (!this.resourceMetadata.has(resourceType)) {\n      return false;\n    }\n\n    const metadata = this.resourceMetadata.get(resourceType)!;\n\n    // Remove from metadata\n    this.resourceMetadata.delete(resourceType);\n\n    // Remove from category\n    const categorySet = this.resourcesByCategory.get(metadata.category);\n    if (categorySet) {\n      categorySet.delete(resourceType);\n    }\n\n    // Remove from tags\n    metadata.tags.forEach(tag => {\n      const tagSet = this.resourcesByTag.get(tag);\n      if (tagSet) {\n        tagSet.delete(resourceType);\n        if (tagSet.size === 0) {\n          this.resourcesByTag.delete(tag);\n        }\n      }\n    });\n\n    // Remove from quality levels\n    Object.keys(metadata.qualityLevels).forEach(quality => {\n      const qualityMap = this.resourcesByQuality.get(quality as ResourceQuality);\n      if (qualityMap) {\n        qualityMap.delete(resourceType);\n      }\n    });\n\n    // Remove from conversion rates\n    this.conversionRates.delete(resourceType);\n\n    // Emit resource unregistered event\n    this.emit('resourceUnregistered', { resourceType });\n\n    return true;\n  }\n\n  /**\n   * Get resource metadata\n   *\n   * @param resourceType The resource type\n   * @returns The resource metadata or undefined if not found\n   */\n  public getResourceMetadata(resourceType: ResourceType): ExtendedResourceMetadata | undefined {\n    return this.resourceMetadata.get(resourceType);\n  }\n\n  /**\n   * Get all registered resource types\n   *\n   * @returns Array of all registered resource types\n   */\n  public getAllResourceTypes(): ResourceType[] {\n    return Array.from(this.resourceMetadata.keys());\n  }\n\n  /**\n   * Get resources by category\n   *\n   * @param category The resource category\n   * @returns Array of resource types in the category\n   */\n  public getResourcesByCategory(category: ResourceCategory): ResourceType[] {\n    const categorySet = this.resourcesByCategory.get(category);\n    return categorySet ? Array.from(categorySet) : [];\n  }\n\n  /**\n   * Get resources by tag\n   *\n   * @param tag The resource tag\n   * @returns Array of resource types with the tag\n   */\n  public getResourcesByTag(tag: string): ResourceType[] {\n    const tagSet = this.resourcesByTag.get(tag);\n    return tagSet ? Array.from(tagSet) : [];\n  }\n\n  /**\n   * Get resources by quality level\n   *\n   * @param quality The resource quality level\n   * @returns Map of resource types to quality values\n   */\n  public getResourcesByQuality(quality: ResourceQuality): Map<ResourceType, number> {\n    return this.resourcesByQuality.get(quality) || new Map();\n  }\n\n  /**\n   * Get conversion rate between resources\n   *\n   * @param sourceType Source resource type\n   * @param targetType Target resource type\n   * @returns Conversion rate or undefined if not found\n   */\n  public getConversionRate(sourceType: ResourceType, targetType: ResourceType): number | undefined {\n    const rateMap = this.conversionRates.get(sourceType);\n    return rateMap ? rateMap.get(targetType) : undefined;\n  }\n\n  /**\n   * Set conversion rate between resources\n   *\n   * @param sourceType Source resource type\n   * @param targetType Target resource type\n   * @param rate Conversion rate\n   */\n  public setConversionRate(sourceType: ResourceType, targetType: ResourceType, rate: number): void {\n    let rateMap = this.conversionRates.get(sourceType);\n    if (!rateMap) {\n      rateMap = new Map();\n      this.conversionRates.set(sourceType, rateMap);\n    }\n    rateMap.set(targetType, rate);\n\n    // Update metadata\n    const metadata = this.resourceMetadata.get(sourceType);\n    if (metadata) {\n      if (!metadata.conversionRates) {\n        metadata.conversionRates = {};\n      }\n      metadata.conversionRates[targetType] = rate;\n    }\n\n    // Emit conversion rate changed event\n    this.emit('conversionRateChanged', { sourceType, targetType, rate });\n  }\n\n  /**\n   * Get all possible conversion rates for a resource\n   *\n   * @param resourceType The resource type\n   * @returns Map of target resource types to conversion rates\n   */\n  public getAllConversionRates(resourceType: ResourceType): Map<ResourceType, number> {\n    return this.conversionRates.get(resourceType) || new Map();\n  }\n\n  /**\n   * Find resources that can be converted to the specified resource\n   *\n   * @param targetType Target resource type\n   * @returns Map of source resource types to conversion rates\n   */\n  public findConversionSources(targetType: ResourceType): Map<ResourceType, number> {\n    const sources = new Map<ResourceType, number>();\n\n    this.conversionRates.forEach((rateMap, sourceType) => {\n      const rate = rateMap.get(targetType);\n      if (rate !== undefined) {\n        sources.set(sourceType, rate);\n      }\n    });\n\n    return sources;\n  }\n\n  /**\n   * Subscribe to registry events using the EventEmitter\n   *\n   * @param eventType Event type\n   * @param callback Callback function\n   * @returns Unsubscribe function\n   */\n  public subscribe(\n    eventType: RegistryEventType,\n    callback: (data: RegistryEventData) => void\n  ): () => void {\n    return this.eventEmitter.subscribe(\n      event => event.type === eventType,\n      event => callback(event.data)\n    );\n  }\n\n  /**\n   * Emit an event to all subscribers using the EventEmitter\n   *\n   * @param eventType Event type\n   * @param data Event data\n   */\n  private emit(eventType: RegistryEventType, data: RegistryEventData): void {\n    this.eventEmitter.emit({\n      type: eventType,\n      data,\n      timestamp: Date.now(),\n    });\n  }\n\n  /**\n   * Get display name for a resource type\n   *\n   * @param resourceType The resource type\n   * @returns The display name or the resource type string if not found\n   */\n  public getDisplayName(resourceType: ResourceType): ResourceType {\n    const metadata = this.resourceMetadata.get(resourceType);\n    return metadata ? metadata.displayName : String(resourceType);\n  }\n\n  /**\n   * Get icon for a resource type\n   *\n   * @param resourceType The resource type\n   * @returns The icon or undefined if not found\n   */\n  public getIcon(resourceType: ResourceType): string | undefined {\n    const metadata = this.resourceMetadata.get(resourceType);\n    return metadata ? metadata.icon : undefined;\n  }\n\n  /**\n   * Get related resources for a resource type\n   *\n   * @param resourceType The resource type\n   * @returns Array of related resource types\n   */\n  public getRelatedResources(resourceType: ResourceType): ResourceType[] {\n    const metadata = this.resourceMetadata.get(resourceType);\n    return metadata ? metadata.relatedResources : [];\n  }\n\n  /**\n   * Check if a resource has a specific tag\n   *\n   * @param resourceType The resource type\n   * @param tag The tag to check\n   * @returns True if the resource has the tag, false otherwise\n   */\n  public hasTag(resourceType: ResourceType, tag: string): boolean {\n    const metadata = this.resourceMetadata.get(resourceType);\n    return metadata ? metadata.tags.includes(tag) : false;\n  }\n\n  /**\n   * Get all tags for a resource\n   *\n   * @param resourceType The resource type\n   * @returns Array of tags\n   */\n  public getTags(resourceType: ResourceType): ResourceType[] {\n    const metadata = this.resourceMetadata.get(resourceType);\n    return metadata ? metadata.tags : [];\n  }\n\n  /**\n   * Add a tag to a resource\n   *\n   * @param resourceType The resource type\n   * @param tag The tag to add\n   * @returns True if the tag was added, false otherwise\n   */\n  public addTag(resourceType: ResourceType, tag: string): boolean {\n    const metadata = this.resourceMetadata.get(resourceType);\n    if (!metadata) {\n      return false;\n    }\n\n    if (!metadata.tags.includes(tag)) {\n      metadata.tags.push(tag);\n\n      // Update tag mapping\n      const tagSet = this.resourcesByTag.get(tag) || new Set();\n      tagSet.add(resourceType);\n      this.resourcesByTag.set(tag, tagSet);\n\n      // Emit tag added event\n      this.emit('tagAdded', { resourceType, tag });\n\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Remove a tag from a resource\n   *\n   * @param resourceType The resource type\n   * @param tag The tag to remove\n   * @returns True if the tag was removed, false otherwise\n   */\n  public removeTag(resourceType: ResourceType, tag: string): boolean {\n    const metadata = this.resourceMetadata.get(resourceType);\n    if (!metadata) {\n      return false;\n    }\n\n    const index = metadata.tags.indexOf(tag);\n    if (index !== -1) {\n      metadata.tags.splice(index, 1);\n\n      // Update tag mapping\n      const tagSet = this.resourcesByTag.get(tag);\n      if (tagSet) {\n        tagSet.delete(resourceType);\n        if (tagSet.size === 0) {\n          this.resourcesByTag.delete(tag);\n        }\n      }\n\n      // Emit tag removed event\n      this.emit('tagRemoved', { resourceType, tag });\n\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Update resource metadata\n   *\n   * @param resourceType The resource type\n   * @param updates Partial metadata updates\n   * @returns True if the update was successful, false otherwise\n   */\n  public updateResourceMetadata(\n    resourceType: ResourceType,\n    updates: Partial<ExtendedResourceMetadata>\n  ): boolean {\n    const metadata = this.resourceMetadata.get(resourceType);\n    if (!metadata) {\n      return false;\n    }\n\n    // Apply updates\n    Object.assign(metadata, updates);\n\n    // Update category if changed\n    if (updates.category && updates.category !== metadata.category) {\n      // Remove from old category\n      const oldCategorySet = this.resourcesByCategory.get(metadata.category);\n      if (oldCategorySet) {\n        oldCategorySet.delete(resourceType);\n      }\n\n      // Add to new category\n      const newCategorySet = this.resourcesByCategory.get(updates.category) || new Set();\n      newCategorySet.add(resourceType);\n      this.resourcesByCategory.set(updates.category, newCategorySet);\n    }\n\n    // Emit metadata updated event\n    this.emit('resourceMetadataUpdated', { resourceType, updates });\n\n    return true;\n  }\n\n  /**\n   * Get quality level for a resource\n   *\n   * @param resourceType The resource type\n   * @param quality The quality level\n   * @returns The quality value or undefined if not found\n   */\n  public getQualityLevel(resourceType: ResourceType, quality: ResourceQuality): number | undefined {\n    const metadata = this.resourceMetadata.get(resourceType);\n    return metadata ? metadata.qualityLevels[quality] : undefined;\n  }\n\n  /**\n   * Set quality level for a resource\n   *\n   * @param resourceType The resource type\n   * @param quality The quality level\n   * @param value The quality value\n   * @returns True if the quality level was set, false otherwise\n   */\n  public setQualityLevel(\n    resourceType: ResourceType,\n    quality: ResourceQuality,\n    value: number\n  ): boolean {\n    const metadata = this.resourceMetadata.get(resourceType);\n    if (!metadata) {\n      return false;\n    }\n\n    metadata.qualityLevels[quality] = value;\n\n    // Update quality mapping\n    const qualityMap = this.resourcesByQuality.get(quality) || new Map();\n    qualityMap.set(resourceType, value);\n    this.resourcesByQuality.set(quality, qualityMap);\n\n    // Emit quality level changed event\n    this.emit('qualityLevelChanged', { resourceType, quality, value });\n\n    return true;\n  }\n\n  /**\n   * Get all quality levels for a resource\n   *\n   * @param resourceType The resource type\n   * @returns Record of quality levels or empty object if not found\n   */\n  public getAllQualityLevels(resourceType: ResourceType): Record<ResourceQuality, number> {\n    const metadata = this.resourceMetadata.get(resourceType);\n    return metadata ? metadata.qualityLevels : ({} as Record<ResourceQuality, number>);\n  }\n\n  /**\n   * Initialize the registry from async data source\n   * This method can be used to load resource data from an API or database\n   *\n   * @param dataSource Function that returns a promise with resource data\n   * @returns Promise that resolves when initialization is complete\n   */\n  public async initializeFromDataSource(\n    dataSource: () => Promise<ResourceRegistrationOptions[]>\n  ): Promise<void> {\n    try {\n      const resources = await dataSource();\n\n      // Clear existing resources\n      this.resourceMetadata.clear();\n      this.resourcesByCategory.clear();\n      this.resourcesByTag.clear();\n      this.resourcesByQuality.clear();\n      this.conversionRates.clear();\n\n      // Initialize category maps\n      Object.values(ResourceCategory).forEach(category => {\n        this.resourcesByCategory.set(category, new Set());\n      });\n\n      // Initialize quality maps\n      Object.values(ResourceQuality).forEach(quality => {\n        this.resourcesByQuality.set(quality, new Map());\n      });\n\n      // Register resources\n      resources.forEach(resource => {\n        this.registerResource(resource);\n      });\n\n      // Emit initialization complete event\n      this.emit('initializationComplete', { resourceCount: resources.length });\n    } catch (error) {\n      console.error('Error initializing resource registry:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Export registry data\n   * This method can be used to save resource data to a file or database\n   *\n   * @returns Object containing all registry data\n   */\n  public exportRegistryData(): {\n    resources: Record<string, ExtendedResourceMetadata>;\n    conversionRates: Record<string, Record<string, number>>;\n  } {\n    const resources: Record<string, ExtendedResourceMetadata> = {};\n    const conversionRates: Record<string, Record<string, number>> = {};\n\n    // Export resources\n    this.resourceMetadata.forEach((metadata, resourceType) => {\n      resources[resourceType] = { ...metadata };\n    });\n\n    // Export conversion rates\n    this.conversionRates.forEach((rateMap, sourceType) => {\n      conversionRates[sourceType] = {};\n      rateMap.forEach((rate, targetType) => {\n        conversionRates[sourceType][targetType] = rate;\n      });\n    });\n\n    return { resources, conversionRates };\n  }\n\n  /**\n   * Import registry data\n   * This method can be used to load resource data from a file or database\n   *\n   * @param data Object containing registry data\n   * @returns True if import was successful, false otherwise\n   */\n  public importRegistryData(data: {\n    resources: Record<string, ExtendedResourceMetadata>;\n    conversionRates: Record<string, Record<string, number>>;\n  }): boolean {\n    try {\n      // Clear existing data\n      this.resourceMetadata.clear();\n      this.resourcesByCategory.clear();\n      this.resourcesByTag.clear();\n      this.resourcesByQuality.clear();\n      this.conversionRates.clear();\n\n      // Initialize category maps\n      Object.values(ResourceCategory).forEach(category => {\n        this.resourcesByCategory.set(category, new Set());\n      });\n\n      // Initialize quality maps\n      Object.values(ResourceQuality).forEach(quality => {\n        this.resourcesByQuality.set(quality, new Map());\n      });\n\n      // Import resources\n      Object.entries(data.resources).forEach(([resourceType, metadata]) => {\n        this.registerResource({\n          metadata: metadata,\n          overrideExisting: true,\n        });\n      });\n\n      // Import conversion rates\n      Object.entries(data.conversionRates).forEach(([sourceType, rates]) => {\n        Object.entries(rates).forEach(([targetType, rate]) => {\n          this.setConversionRate(sourceType as ResourceType, targetType as ResourceType, rate);\n        });\n      });\n\n      // Emit import complete event\n      this.emit('importComplete', {\n        resourceCount: Object.keys(data.resources).length,\n        conversionRateCount: Object.keys(data.conversionRates).length,\n      });\n\n      return true;\n    } catch (error) {\n      console.error('Error importing registry data:', error);\n      return false;\n    }\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/registry/ResourceRegistryIntegration.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'resourceFlowManager' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 78,
        "column": 35,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 78,
        "endColumn": 54
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'resourceFlowManager' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 104,
        "column": 32,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 104,
        "endColumn": 51
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'resourceFlowManager' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 130,
        "column": 44,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 130,
        "endColumn": 63
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * ResourceRegistryIntegration.ts\n *\n * Integration between ResourceRegistry and ResourceFlowManager to standardize\n * resource type handling throughout the application.\n */\n\nimport { ResourceType } from \"./../types/resources/ResourceTypes\";\nimport { ResourceType } from \"./../types/resources/ResourceTypes\";\nimport { RegistryEventData, ResourceRegistry } from './ResourceRegistry';\n\n// Forward declaration of ResourceFlowManager to avoid circular dependencies\ninterface ResourceFlowManager {\n  // Add minimal interface needed for this integration\n  getAllResourceStates?: () => Map<string, { available: number }>;\n  getAllConversionRecipes?: () => Array<{\n    input: { type: string; amount: number };\n    output: { type: string; amount: number };\n  }>;\n  setConversionRate?: (sourceType: string, targetType: string, rate: number) => void;\n}\n\n/**\n * ResourceRegistryIntegration class\n *\n * Provides integration methods between ResourceRegistry and other resource-related systems.\n * This class serves as a bridge to help transition from string-based resource types to enum-based types.\n */\nexport class ResourceRegistryIntegration {\n  private static _instance: ResourceRegistryIntegration | null = null;\n  private registry: ResourceRegistry;\n\n  /**\n   * Get the singleton instance of ResourceRegistryIntegration\n   */\n  public static getInstance(): ResourceRegistryIntegration {\n    if (!ResourceRegistryIntegration._instance) {\n      ResourceRegistryIntegration._instance = new ResourceRegistryIntegration();\n    }\n    return ResourceRegistryIntegration._instance;\n  }\n\n  /**\n   * Private constructor to enforce singleton pattern\n   */\n  private constructor() {\n    this.registry = ResourceRegistry.getInstance();\n    this.initializeIntegration();\n  }\n\n  /**\n   * Initialize the integration\n   */\n  private initializeIntegration(): void {\n    // Subscribe to registry events to sync with other systems\n    this.registry.subscribe('resourceRegistered', (data: RegistryEventData) => {\n      if ('resourceType' in data && 'metadata' in data) {\n        console.warn(`Resource registered: ${data.resourceType}`);\n        // Here you would notify other systems about the new resource\n      }\n    });\n\n    this.registry.subscribe('conversionRateChanged', (data: RegistryEventData) => {\n      if ('sourceType' in data && 'targetType' in data && 'rate' in data) {\n        console.warn(\n          `Conversion rate changed: ${data.sourceType} -> ${data.targetType} = ${data.rate}`\n        );\n        // Here you would update conversion rates in other systems\n      }\n    });\n  }\n\n  /**\n   * Get resource availability from ResourceFlowManager and register with ResourceRegistry\n   *\n   * @param resourceFlowManager The ResourceFlowManager instance\n   */\n  public syncResourceAvailability(resourceFlowManager: ResourceFlowManager): void {\n    // This is a placeholder for actual integration code\n    // In a real implementation, you would:\n    // 1. Get all resource states from ResourceFlowManager\n    // 2. Update the ResourceRegistry with the current availability\n    // Example (pseudo-code):\n    // const resourceStates = resourceFlowManager.getAllResourceStates();\n    // resourceStates.forEach((state, resourceType) => {\n    //   const standardizedType = ResourceTypeConverter.stringToEnum(resourceType);\n    //   if (standardizedType) {\n    //     // Update registry with availability information\n    //     const metadata = this.registry.getResourceMetadata(standardizedType);\n    //     if (metadata) {\n    //       this.registry.updateResourceMetadata(standardizedType, {\n    //         currentAvailability: state.available\n    //       });\n    //     }\n    //   }\n    // });\n  }\n\n  /**\n   * Register conversion recipes from ResourceFlowManager with ResourceRegistry\n   *\n   * @param resourceFlowManager The ResourceFlowManager instance\n   */\n  public syncConversionRecipes(resourceFlowManager: ResourceFlowManager): void {\n    // This is a placeholder for actual integration code\n    // In a real implementation, you would:\n    // 1. Get all conversion recipes from ResourceFlowManager\n    // 2. Register them with the ResourceRegistry\n    // Example (pseudo-code):\n    // const recipes = resourceFlowManager.getAllConversionRecipes();\n    // recipes.forEach(recipe => {\n    //   const inputType = ResourceTypeConverter.stringToEnum(recipe.input.type);\n    //   const outputType = ResourceTypeConverter.stringToEnum(recipe.output.type);\n    //\n    //   if (inputType && outputType) {\n    //     this.registry.setConversionRate(\n    //       inputType,\n    //       outputType,\n    //       recipe.output.amount / recipe.input.amount\n    //     );\n    //   }\n    // });\n  }\n\n  /**\n   * Get conversion rates from ResourceRegistry and update ResourceFlowManager\n   *\n   * @param resourceFlowManager The ResourceFlowManager instance\n   */\n  public applyConversionRatesToFlowManager(resourceFlowManager: ResourceFlowManager): void {\n    // This is a placeholder for actual integration code\n    // In a real implementation, you would:\n    // 1. Get all conversion rates from ResourceRegistry\n    // 2. Apply them to ResourceFlowManager\n    // Example (pseudo-code):\n    // const resourceTypes = this.registry.getAllResourceTypes();\n    //\n    // resourceTypes.forEach(sourceType => {\n    //   const conversionRates = this.registry.getAllConversionRates(sourceType);\n    //\n    //   conversionRates.forEach((rate, targetType) => {\n    //     const stringSourceType = ResourceTypeConverter.enumToString(sourceType);\n    //     const stringTargetType = ResourceTypeConverter.enumToString(targetType);\n    //\n    //     if (stringSourceType && stringTargetType) {\n    //       resourceFlowManager.setConversionRate(\n    //         stringSourceType,\n    //         stringTargetType,\n    //         rate\n    //       );\n    //     }\n    //   });\n    // });\n  }\n\n  /**\n   * Get resource metadata from ResourceRegistry\n   *\n   * @param resourceType The resource type (string or enum)\n   * @returns The resource metadata or undefined if not found\n   */\n  public getResourceMetadata(resourceType: ResourceType | string): unknown {\n    if (typeof resourceType === 'string') {\n      const enumType = ResourceTypeConverter.stringToEnum(resourceType);\n      if (!enumType) {\n        return undefined;\n      }\n      return this.registry.getResourceMetadata(enumType);\n    }\n\n    return this.registry.getResourceMetadata(resourceType);\n  }\n\n  /**\n   * Get display name for a resource type\n   *\n   * @param resourceType The resource type (string or enum)\n   * @returns The display name or the resource type string if not found\n   */\n  public getDisplayName(resourceType: ResourceType | string): ResourceType {\n    if (typeof resourceType === 'string') {\n      const enumType = ResourceTypeConverter.stringToEnum(resourceType);\n      if (!enumType) {\n        return resourceType;\n      }\n      return this.registry.getDisplayName(enumType);\n    }\n\n    return this.registry.getDisplayName(resourceType);\n  }\n\n  /**\n   * Get icon for a resource type\n   *\n   * @param resourceType The resource type (string or enum)\n   * @returns The icon or undefined if not found\n   */\n  public getIcon(resourceType: ResourceType | string): string | undefined {\n    if (typeof resourceType === 'string') {\n      const enumType = ResourceTypeConverter.stringToEnum(resourceType);\n      if (!enumType) {\n        return undefined;\n      }\n      return this.registry.getIcon(enumType);\n    }\n\n    return this.registry.getIcon(resourceType);\n  }\n\n  /**\n   * Check if a resource is of a specific category\n   *\n   * @param resourceType The resource type (string or enum)\n   * @param category The category to check\n   * @returns True if the resource is of the category, false otherwise\n   */\n  public isResourceOfCategory(resourceType: ResourceType | string, category: string): boolean {\n    let enumType: ResourceType | undefined;\n\n    if (typeof resourceType === 'string') {\n      enumType = ResourceTypeConverter.stringToEnum(resourceType);\n      if (!enumType) {\n        return false;\n      }\n    } else {\n      enumType = resourceType;\n    }\n\n    const metadata = this.registry.getResourceMetadata(enumType);\n    return metadata ? metadata.category === category : false;\n  }\n\n  /**\n   * Check if a resource has a specific tag\n   *\n   * @param resourceType The resource type (string or enum)\n   * @param tag The tag to check\n   * @returns True if the resource has the tag, false otherwise\n   */\n  public hasTag(resourceType: ResourceType | string, tag: string): boolean {\n    let enumType: ResourceType | undefined;\n\n    if (typeof resourceType === 'string') {\n      enumType = ResourceTypeConverter.stringToEnum(resourceType);\n      if (!enumType) {\n        return false;\n      }\n    } else {\n      enumType = resourceType;\n    }\n\n    return this.registry.hasTag(enumType, tag);\n  }\n\n  /**\n   * Get all resources with a specific tag\n   *\n   * @param tag The tag to filter by\n   * @returns Array of resource types with the tag\n   */\n  public getResourcesByTag(tag: string): ResourceType[] {\n    return this.registry.getResourcesByTag(tag);\n  }\n\n  /**\n   * Get all resources that can be converted to a specific resource\n   *\n   * @param targetType The target resource type (string or enum)\n   * @returns Array of resource types that can be converted to the target\n   */\n  public getConversionSources(targetType: ResourceType | string): ResourceType[] {\n    let enumType: ResourceType | undefined;\n\n    if (typeof targetType === 'string') {\n      enumType = ResourceTypeConverter.stringToEnum(targetType);\n      if (!enumType) {\n        return [];\n      }\n    } else {\n      enumType = targetType;\n    }\n\n    const sources = this.registry.findConversionSources(enumType);\n    return Array.from(sources.keys());\n  }\n\n  /**\n   * Get conversion rate between resources\n   *\n   * @param sourceType Source resource type (string or enum)\n   * @param targetType Target resource type (string or enum)\n   * @returns Conversion rate or undefined if not found\n   */\n  public getConversionRate(\n    sourceType: ResourceType | string,\n    targetType: ResourceType | string\n  ): number | undefined {\n    let enumSourceType: ResourceType | undefined;\n    let enumTargetType: ResourceType | undefined;\n\n    if (typeof sourceType === 'string') {\n      enumSourceType = ResourceTypeConverter.stringToEnum(sourceType);\n      if (!enumSourceType) {\n        return undefined;\n      }\n    } else {\n      enumSourceType = sourceType;\n    }\n\n    if (typeof targetType === 'string') {\n      enumTargetType = ResourceTypeConverter.stringToEnum(targetType);\n      if (!enumTargetType) {\n        return undefined;\n      }\n    } else {\n      enumTargetType = targetType;\n    }\n\n    return this.registry.getConversionRate(enumSourceType, enumTargetType);\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/resource/ResourceSystem.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/resource/subsystems/ResourceFlowSubsystem.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'converter' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 682,
        "column": 36,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 682,
        "endColumn": 45
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'activeConnections' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 682,
        "column": 57,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 682,
        "endColumn": 74
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { eventSystem } from '../../lib/events/UnifiedEventSystem';\nimport { EventType } from '../../types/events/EventTypes';\nimport {\n  ResourceState,\n  ResourceTransfer,\n  ResourceType as StringResourceType,\n} from '../../types/resources/ResourceTypes';\nimport { ResourceType } from \"./../../types/resources/ResourceTypes\";\nimport {\n  isStringResourceType,\n  toStringResourceType,\n} from '../../utils/resources/ResourceTypeConverter';\nimport { validateResourceTransfer } from '../../utils/resources/resourceValidation';\nimport { ResourceFlowWorkerUtil } from '../../utils/workers/ResourceFlowWorkerUtil';\nimport { ResourceSystem, ResourceSystemConfig } from '../ResourceSystem';\n\n/**\n * Flow node types\n */\nexport type FlowNodeType = 'producer' | 'consumer' | 'storage' | 'converter';\n\n/**\n * Flow priority configuration\n */\nexport interface FlowPriority {\n  type: StringResourceType;\n  priority: number;\n  consumers: string[];\n}\n\n/**\n * Flow node\n */\nexport interface FlowNode {\n  id: string;\n  type: FlowNodeType;\n  resources: StringResourceType[];\n  priority: FlowPriority;\n  active: boolean;\n  efficiency?: number;\n  converterConfig?: Record<string, unknown>; // Configuration for converters\n  converterStatus?: Record<string, unknown>; // Status information for converters\n  config?: Record<string, unknown>; // Generic config for additional properties\n}\n\n/**\n * Flow connection\n */\nexport interface FlowConnection {\n  id: string;\n  source: string;\n  target: string;\n  resourceType: StringResourceType;\n  maxRate: number;\n  currentRate: number;\n  priority: FlowPriority;\n  active: boolean;\n}\n\n/**\n * Resource flow\n */\nexport interface ResourceFlow {\n  source: string;\n  target: string;\n  resourceType: StringResourceType;\n  maxRate: number;\n}\n\n/**\n * Flow optimization result\n */\nexport interface FlowOptimizationResult {\n  transfers: ResourceTransfer[];\n  updatedConnections: FlowConnection[];\n  bottlenecks: string[];\n  underutilized: string[];\n  performanceMetrics?: {\n    executionTimeMs: number;\n    nodesProcessed: number;\n    connectionsProcessed: number;\n    transfersGenerated: number;\n  };\n}\n\n/**\n * ResourceFlowSubsystem\n *\n * Manages resource flow through the game systems\n * Responsible for:\n * - Tracking resource nodes (producers, consumers, storage, converters)\n * - Managing connections between nodes\n * - Optimizing resource distribution\n * - Processing resource conversions\n */\nexport class ResourceFlowSubsystem {\n  // Flow network data structures\n  private nodes: Map<string, FlowNode> = new Map();\n  private connections: Map<string, FlowConnection> = new Map();\n  private sourceConnections: Map<string, string[]> = new Map();\n  private targetConnections: Map<string, string[]> = new Map();\n\n  // Type-specific node registries\n  private producerNodes: Map<string, FlowNode> = new Map();\n  private consumerNodes: Map<string, FlowNode> = new Map();\n  private storageNodes: Map<string, FlowNode> = new Map();\n  private converterNodes: Map<string, FlowNode> = new Map();\n\n  // Resource tracking\n  private resourceStates: Map<StringResourceType, ResourceState> = new Map();\n  private resourceProducers: Map<StringResourceType, string[]> = new Map();\n  private resourceConsumers: Map<StringResourceType, string[]> = new Map();\n  private resourceStorage: Map<StringResourceType, string[]> = new Map();\n\n  // Processing state\n  private transferHistory: ResourceTransfer[] = [];\n  private lastOptimizationTime = 0;\n  private isOptimizing = false;\n  private lastOptimizationResult: FlowOptimizationResult | null = null;\n\n  // Worker utility\n  private workerUtil: ResourceFlowWorkerUtil | null = null;\n\n  // Parent system reference\n  private parentSystem: ResourceSystem;\n  private config: ResourceSystemConfig;\n  private isInitialized = false;\n\n  constructor(parentSystem: ResourceSystem, config: ResourceSystemConfig) {\n    this.parentSystem = parentSystem;\n    this.config = config;\n\n    // Initialize resource states\n    this.initializeResourceStates();\n\n    // Initialize Web Worker utility if enabled\n    if (this.config.useWorkerOffloading) {\n      try {\n        this.workerUtil = new ResourceFlowWorkerUtil();\n      } catch (error) {\n        console.error('Failed to initialize ResourceFlowWorkerUtil:', error);\n      }\n    }\n  }\n\n  /**\n   * Initialize the subsystem\n   */\n  public async initialize(): Promise<void> {\n    if (this.isInitialized) {\n      return;\n    }\n\n    try {\n      // Subscribe to relevant events\n      this.initializeEventSubscriptions();\n\n      this.isInitialized = true;\n    } catch (error) {\n      console.error('Failed to initialize ResourceFlowSubsystem:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Dispose of the subsystem\n   */\n  public async dispose(): Promise<void> {\n    if (!this.isInitialized) {\n      return;\n    }\n\n    try {\n      // Clean up Web Worker\n      if (this.workerUtil) {\n        this.workerUtil.terminate();\n        this.workerUtil = null;\n      }\n\n      // Clear data structures\n      this.nodes.clear();\n      this.connections.clear();\n      this.sourceConnections.clear();\n      this.targetConnections.clear();\n\n      this.producerNodes.clear();\n      this.consumerNodes.clear();\n      this.storageNodes.clear();\n      this.converterNodes.clear();\n\n      this.resourceStates.clear();\n      this.resourceProducers.clear();\n      this.resourceConsumers.clear();\n      this.resourceStorage.clear();\n\n      this.transferHistory = [];\n\n      this.isInitialized = false;\n    } catch (error) {\n      console.error('Failed to dispose ResourceFlowSubsystem:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Initialize event subscriptions\n   */\n  private initializeEventSubscriptions(): void {\n    // Subscribe to relevant events\n    eventSystem.subscribe('MODULE_CREATED', this.handleModuleCreated);\n    eventSystem.subscribe('MODULE_UPDATED', this.handleModuleUpdated);\n    eventSystem.subscribe('MODULE_DESTROYED', this.handleModuleDestroyed);\n    eventSystem.subscribe('MODULE_ENABLED', this.handleModuleStateChanged);\n    eventSystem.subscribe('MODULE_DISABLED', this.handleModuleStateChanged);\n  }\n\n  /**\n   * Initialize with default states for all resource types\n   */\n  private initializeResourceStates(): void {\n    const defaultResourceTypes: StringResourceType[] = [\n      ResourceType.ENERGY,\n      ResourceType.MINERALS,\n      ResourceType.POPULATION,\n      ResourceType.RESEARCH,\n      ResourceType.PLASMA,\n      ResourceType.GAS,\n      ResourceType.EXOTIC,\n    ];\n\n    // Initialize resource states for all resource types\n    for (const type of defaultResourceTypes) {\n      const resourceState: ResourceState = {\n        current: 0,\n        max: 1000,\n        min: 0,\n        production: 0,\n        consumption: 0,\n      };\n\n      this.resourceStates.set(type, resourceState);\n      this.resourceProducers.set(type, []);\n      this.resourceConsumers.set(type, []);\n      this.resourceStorage.set(type, []);\n    }\n  }\n\n  /**\n   * Registers a node in the resource flow network\n   */\n  public registerNode(node: FlowNode): boolean {\n    if (!node.id || !node.resources || node.resources.length === 0) {\n      console.warn('Invalid flow node:', node);\n      return false;\n    }\n\n    // Add to main nodes map\n    this.nodes.set(node.id, node);\n\n    // Add to type-specific map\n    switch (node.type) {\n      case 'producer':\n        this.producerNodes.set(node.id, node);\n        break;\n      case 'consumer':\n        this.consumerNodes.set(node.id, node);\n        break;\n      case 'storage':\n        this.storageNodes.set(node.id, node);\n        break;\n      case 'converter':\n        this.converterNodes.set(node.id, node);\n        break;\n    }\n\n    // Add to resource-specific tracking\n    for (const resourceType of node.resources) {\n      // Invalidate parent system cache\n      this.invalidateCache(resourceType);\n\n      // Add to the appropriate resource tracking maps\n      switch (node.type) {\n        case 'producer':\n          this.addToArray(this.resourceProducers, resourceType, node.id);\n          break;\n        case 'consumer':\n          this.addToArray(this.resourceConsumers, resourceType, node.id);\n          break;\n        case 'storage':\n          this.addToArray(this.resourceStorage, resourceType, node.id);\n          break;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Unregisters a node from the resource flow network\n   */\n  public unregisterNode(id: string): boolean {\n    if (!this.nodes.has(id)) {\n      return false;\n    }\n\n    // Get node before removing it\n    const node = this.nodes.get(id);\n    if (!node) return false;\n\n    // Remove from type-specific map\n    switch (node.type) {\n      case 'producer':\n        this.producerNodes.delete(id);\n        break;\n      case 'consumer':\n        this.consumerNodes.delete(id);\n        break;\n      case 'storage':\n        this.storageNodes.delete(id);\n        break;\n      case 'converter':\n        this.converterNodes.delete(id);\n        break;\n    }\n\n    // Remove from resource-specific tracking\n    for (const resourceType of node.resources) {\n      // Invalidate parent system cache\n      this.invalidateCache(resourceType);\n\n      // Remove from the appropriate resource tracking maps\n      switch (node.type) {\n        case 'producer':\n          this.removeFromArray(this.resourceProducers, resourceType, id);\n          break;\n        case 'consumer':\n          this.removeFromArray(this.resourceConsumers, resourceType, id);\n          break;\n        case 'storage':\n          this.removeFromArray(this.resourceStorage, resourceType, id);\n          break;\n      }\n    }\n\n    // Remove all connections to/from this node\n    const connectionEntries = Array.from(this.connections.entries());\n    for (const [connectionId, connection] of connectionEntries) {\n      if (connection.source === id || connection.target === id) {\n        this.unregisterConnection(connectionId);\n      }\n    }\n\n    // Remove from main nodes map\n    this.nodes.delete(id);\n\n    return true;\n  }\n\n  /**\n   * Registers a connection between nodes in the resource flow network\n   */\n  public registerConnection(connection: FlowConnection): boolean {\n    if (\n      !connection.id ||\n      !connection.source ||\n      !connection.target ||\n      !connection.resourceType ||\n      connection.maxRate <= 0\n    ) {\n      console.warn('Invalid connection:', connection);\n      return false;\n    }\n\n    // Ensure source and target nodes exist\n    if (!this.nodes.has(connection.source)) {\n      console.warn(`Source node ${connection.source} does not exist`);\n      return false;\n    }\n\n    if (!this.nodes.has(connection.target)) {\n      console.warn(`Target node ${connection.target} does not exist`);\n      return false;\n    }\n\n    // Ensure source node has the resource type\n    const sourceNode = this.nodes.get(connection.source);\n    if (!sourceNode?.resources.includes(connection.resourceType)) {\n      console.warn(\n        `Source node ${connection.source} does not have resource type ${connection.resourceType}`\n      );\n      return false;\n    }\n\n    // Add to connections map\n    this.connections.set(connection.id, connection);\n\n    // Update source and target connection maps\n    this.addToArray(this.sourceConnections, connection.source, connection.id);\n    this.addToArray(this.targetConnections, connection.target, connection.id);\n\n    // Invalidate cache for affected resource\n    this.invalidateCache(connection.resourceType);\n\n    return true;\n  }\n\n  /**\n   * Unregisters a connection from the resource flow network\n   */\n  public unregisterConnection(id: string): boolean {\n    const connection = this.connections.get(id);\n    if (!connection) {\n      return false;\n    }\n\n    // Remove from source and target connection maps\n    this.removeFromArray(this.sourceConnections, connection.source, id);\n    this.removeFromArray(this.targetConnections, connection.target, id);\n\n    // Remove from connections map\n    this.connections.delete(id);\n\n    // Invalidate cache for affected resource\n    this.invalidateCache(connection.resourceType);\n\n    return true;\n  }\n\n  /**\n   * Registers a resource flow between nodes\n   */\n  public registerResourceFlow(\n    sourceId: string,\n    targetId: string,\n    resourceType: StringResourceType | ResourceType,\n    rate: number\n  ): boolean {\n    // Ensure we're using string resource type for internal storage\n    const stringType = isStringResourceType(resourceType)\n      ? (resourceType as StringResourceType)\n      : toStringResourceType(resourceType as ResourceType);\n\n    // Check if source and target nodes exist\n    const source = this.nodes.get(sourceId);\n    const target = this.nodes.get(targetId);\n\n    if (!source || !target) {\n      console.error(`Cannot register flow: source or target node not found`);\n      return false;\n    }\n\n    // Check if source produces this resource\n    if (!source.resources.includes(stringType)) {\n      console.error(`Source node ${sourceId} does not produce ${stringType}`);\n      return false;\n    }\n\n    // Check if target accepts this resource\n    if (!target.resources.includes(stringType)) {\n      console.error(`Target node ${targetId} does not accept ${stringType}`);\n      return false;\n    }\n\n    // Create a unique ID for the connection\n    const connectionId = `${sourceId}-${targetId}-${stringType}`;\n\n    // Create the connection\n    const connection: FlowConnection = {\n      id: connectionId,\n      source: sourceId,\n      target: targetId,\n      resourceType: ResourceTypeType,\n      maxRate: rate,\n      currentRate: 0,\n      priority: {\n        type: stringType,\n        priority: 1,\n        consumers: [targetId],\n      },\n      active: true,\n    };\n\n    // Register the connection\n    return this.registerConnection(connection);\n  }\n\n  /**\n   * Updates the state of a resource in the network\n   */\n  public updateResourceState(type: StringResourceType | ResourceType, state: ResourceState): void {\n    // Ensure we're using string resource type for internal storage\n    const stringType = isStringResourceType(type)\n      ? (type as StringResourceType)\n      : toStringResourceType(type as ResourceType);\n\n    this.resourceStates.set(stringType, state);\n    this.invalidateCache(stringType);\n  }\n\n  /**\n   * Gets the current state of a resource in the network\n   */\n  public getResourceState(type: StringResourceType | ResourceType): ResourceState | undefined {\n    // Ensure we're using string resource type for internal storage\n    const stringType = isStringResourceType(type)\n      ? (type as StringResourceType)\n      : toStringResourceType(type as ResourceType);\n\n    return this.resourceStates.get(stringType);\n  }\n\n  /**\n   * Invalidate cache for a resource type\n   */\n  private invalidateCache(type: StringResourceType): void {\n    // Publish event for resource state change\n    eventSystem.publish({\n      type: EventType.RESOURCE_UPDATED,\n      timestamp: Date.now(),\n      data: {\n        resourceType: type,\n      },\n    });\n  }\n\n  /**\n   * Optimize resource flows across the network\n   */\n  public async optimizeFlows(): Promise<FlowOptimizationResult> {\n    // Prevent concurrent optimization runs\n    if (this.isOptimizing) {\n      return (\n        this.lastOptimizationResult || {\n          transfers: [],\n          updatedConnections: [],\n          bottlenecks: [],\n          underutilized: [],\n          performanceMetrics: {\n            executionTimeMs: 0,\n            nodesProcessed: 0,\n            connectionsProcessed: 0,\n            transfersGenerated: 0,\n          },\n        }\n      );\n    }\n\n    this.isOptimizing = true;\n    const startTime = Date.now();\n\n    try {\n      // Get active nodes and connections\n      const activeNodes = Array.from(this.nodes.values()).filter(node => node.active);\n      const activeConnections = Array.from(this.connections.values()).filter(conn => conn.active);\n\n      // Check if we should use Web Worker offloading\n      if (\n        this.config.useWorkerOffloading &&\n        this.workerUtil &&\n        activeNodes.length > this.config.batchSize\n      ) {\n        try {\n          // Offload optimization to Web Worker\n          const result = await this.workerUtil.optimizeFlows(\n            activeNodes,\n            activeConnections,\n            Object.fromEntries(this.resourceStates)\n          );\n\n          // Apply the results from the worker\n          this.applyOptimizationResults(result);\n\n          // Add execution time to performance metrics\n          result.performanceMetrics = result.performanceMetrics || {\n            executionTimeMs: 0,\n            nodesProcessed: activeNodes.length,\n            connectionsProcessed: activeConnections.length,\n            transfersGenerated: result.transfers.length,\n          };\n\n          result.performanceMetrics.executionTimeMs = Date.now() - startTime;\n\n          this.lastOptimizationResult = result;\n          this.lastOptimizationTime = Date.now();\n          return result;\n        } catch (error) {\n          console.warn('Web Worker optimization failed, falling back to main thread:', error);\n          // Fall back to main thread optimization\n        }\n      }\n\n      // Categorize nodes by type\n      const producers = activeNodes.filter(node => node.type === 'producer');\n      const consumers = activeNodes.filter(node => node.type === 'consumer');\n      const storages = activeNodes.filter(node => node.type === 'storage');\n      const converters = activeNodes.filter(node => node.type === 'converter');\n\n      // Process converters\n      this.processConverters(converters, activeConnections);\n\n      // Calculate resource balance\n      const { availability, demand } = this.calculateResourceBalance(\n        producers,\n        consumers,\n        storages,\n        activeConnections\n      );\n\n      // Identify resource issues\n      const { bottlenecks, underutilized } = this.identifyResourceIssues(availability, demand);\n\n      // Optimize flow rates\n      const { updatedConnections, transfers } = this.optimizeFlowRates(\n        activeConnections,\n        availability,\n        demand\n      );\n\n      // Update connections with optimized rates\n      for (const connection of updatedConnections) {\n        this.connections.set(connection.id, connection);\n      }\n\n      // Create and store result\n      const result: FlowOptimizationResult = {\n        transfers,\n        updatedConnections,\n        bottlenecks,\n        underutilized,\n        performanceMetrics: {\n          executionTimeMs: Date.now() - startTime,\n          nodesProcessed: activeNodes.length,\n          connectionsProcessed: activeConnections.length,\n          transfersGenerated: transfers.length,\n        },\n      };\n\n      this.lastOptimizationResult = result;\n      this.lastOptimizationTime = Date.now();\n      return result;\n    } finally {\n      this.isOptimizing = false;\n    }\n  }\n\n  /**\n   * Apply optimization results\n   */\n  private applyOptimizationResults(result: FlowOptimizationResult): void {\n    // Update connections with optimized rates\n    for (const connection of result.updatedConnections) {\n      if (this.connections.has(connection.id)) {\n        this.connections.set(connection.id, connection);\n      }\n    }\n\n    // Process transfers\n    for (const transfer of result.transfers) {\n      if (validateResourceTransfer(transfer)) {\n        this.addToTransferHistory(transfer);\n      }\n    }\n  }\n\n  /**\n   * Process converters\n   */\n  private processConverters(converters: FlowNode[], activeConnections: FlowConnection[]): void {\n    // Process each converter\n    for (const converter of converters) {\n      if (converter.config?.type === 'advanced') {\n        this.processAdvancedConverter(converter, activeConnections);\n      } else {\n        // Basic converter processing\n      }\n    }\n  }\n\n  /**\n   * Process an advanced converter\n   */\n  private processAdvancedConverter(converter: FlowNode, activeConnections: FlowConnection[]): void {\n    // This would implement advanced converter logic\n    // For now, we'll leave it as a placeholder\n  }\n\n  /**\n   * Calculate resource balance between producers, consumers, and storage\n   */\n  private calculateResourceBalance(\n    producers: FlowNode[],\n    consumers: FlowNode[],\n    storages: FlowNode[],\n    activeConnections: FlowConnection[]\n  ): {\n    availability: Partial<Record<StringResourceType, number>>;\n    demand: Partial<Record<StringResourceType, number>>;\n  } {\n    const availability: Partial<Record<StringResourceType, number>> = {};\n    const demand: Partial<Record<StringResourceType, number>> = {};\n\n    // Initialize with zero values for all resource types\n    for (const type of this.resourceStates.keys()) {\n      availability[type] = 0;\n      demand[type] = 0;\n    }\n\n    // Calculate production capacity\n    for (const producer of producers) {\n      for (const resourceType of producer.resources) {\n        // Find outgoing connections for this resource\n        const outgoingConnections = activeConnections.filter(\n          conn => conn.source === producer.id && conn.resourceType === resourceType\n        );\n\n        // Sum up max rates\n        const totalMaxRate = outgoingConnections.reduce((sum, conn) => sum + conn.maxRate, 0);\n\n        // Apply efficiency if available\n        const effectiveRate = producer.efficiency\n          ? totalMaxRate * producer.efficiency\n          : totalMaxRate;\n\n        availability[resourceType] = (availability[resourceType] || 0) + effectiveRate;\n      }\n    }\n\n    // Calculate consumer demand\n    for (const consumer of consumers) {\n      for (const resourceType of consumer.resources) {\n        // Find incoming connections for this resource\n        const incomingConnections = activeConnections.filter(\n          conn => conn.target === consumer.id && conn.resourceType === resourceType\n        );\n\n        // Sum up max rates\n        const totalMaxRate = incomingConnections.reduce((sum, conn) => sum + conn.maxRate, 0);\n\n        demand[resourceType] = (demand[resourceType] || 0) + totalMaxRate;\n      }\n    }\n\n    // Factor in storage capacity\n    for (const storage of storages) {\n      for (const resourceType of storage.resources) {\n        // Use resource state if available\n        const resourceState = this.resourceStates.get(resourceType);\n        if (!resourceState) {\n          continue;\n        }\n\n        // If storage is near capacity, reduce availability\n        if (resourceState.current > resourceState.max * 0.9) {\n          availability[resourceType] = Math.max(\n            0,\n            (availability[resourceType] || 0) - (resourceState.max - resourceState.current)\n          );\n        }\n\n        // If storage is near empty, increase demand\n        if (resourceState.current < resourceState.max * 0.1) {\n          demand[resourceType] = (demand[resourceType] || 0) + resourceState.max * 0.2;\n        }\n      }\n    }\n\n    return { availability, demand };\n  }\n\n  /**\n   * Identify resource bottlenecks and underutilized resources\n   */\n  private identifyResourceIssues(\n    availability: Partial<Record<StringResourceType, number>>,\n    demand: Partial<Record<StringResourceType, number>>\n  ): {\n    bottlenecks: string[];\n    underutilized: string[];\n  } {\n    const bottlenecks: string[] = [];\n    const underutilized: string[] = [];\n\n    for (const [type, availableAmount] of Object.entries(availability)) {\n      const demandAmount = demand[type as StringResourceType] || 0;\n\n      if (availableAmount < demandAmount * 0.9) {\n        bottlenecks.push(type);\n      } else if (availableAmount > demandAmount * 1.5) {\n        underutilized.push(type);\n      }\n    }\n\n    return { bottlenecks, underutilized };\n  }\n\n  /**\n   * Optimize flow rates based on priorities\n   */\n  private optimizeFlowRates(\n    activeConnections: FlowConnection[],\n    availability: Partial<Record<StringResourceType, number>>,\n    demand: Partial<Record<StringResourceType, number>>\n  ): {\n    updatedConnections: FlowConnection[];\n    transfers: ResourceTransfer[];\n  } {\n    const updatedConnections: FlowConnection[] = [];\n    const transfers: ResourceTransfer[] = [];\n    const now = Date.now();\n\n    // Sort connections by priority (high to low)\n    const prioritizedConnections = [...activeConnections].sort(\n      (a, b) => b.priority.priority - a.priority.priority\n    );\n\n    // Adjust flow rates\n    for (const connection of prioritizedConnections) {\n      const { resourceType } = connection;\n      const availableForType = availability[resourceType] || 0;\n      const demandForType = demand[resourceType] || 0;\n\n      if (availableForType <= 0 || demandForType <= 0) {\n        // No flow possible\n        connection.currentRate = 0;\n      } else if (availableForType >= demandForType) {\n        // Full flow possible\n        connection.currentRate = Math.min(connection.maxRate, demandForType);\n      } else {\n        // Partial flow based on ratio\n        const ratio = availableForType / demandForType;\n        connection.currentRate = connection.maxRate * ratio;\n      }\n\n      updatedConnections.push({ ...connection });\n\n      // Generate transfer if flow is positive\n      if (connection.currentRate > 0) {\n        const transfer: ResourceTransfer = {\n          type: connection.resourceType,\n          source: connection.source,\n          target: connection.target,\n          amount: connection.currentRate,\n          timestamp: now,\n        };\n\n        if (validateResourceTransfer(transfer)) {\n          transfers.push(transfer);\n          this.addToTransferHistory(transfer);\n        }\n      }\n    }\n\n    return { updatedConnections, transfers };\n  }\n\n  /**\n   * Add a transfer to the history\n   */\n  private addToTransferHistory(transfer: ResourceTransfer): void {\n    this.transferHistory.push(transfer);\n\n    // Trim history if needed\n    if (this.transferHistory.length > this.config.maxHistorySize) {\n      this.transferHistory = this.transferHistory.slice(-this.config.maxHistorySize);\n    }\n  }\n\n  /**\n   * Get the transfer history\n   */\n  public getTransferHistory(): ResourceTransfer[] {\n    return [...this.transferHistory];\n  }\n\n  /**\n   * Get a specific node\n   */\n  public getNode(id: string): FlowNode | undefined {\n    return this.nodes.get(id);\n  }\n\n  /**\n   * Get all nodes\n   */\n  public getNodes(): FlowNode[] {\n    return Array.from(this.nodes.values());\n  }\n\n  /**\n   * Get a specific connection\n   */\n  public getConnection(id: string): FlowConnection | undefined {\n    return this.connections.get(id);\n  }\n\n  /**\n   * Get all connections\n   */\n  public getConnections(): FlowConnection[] {\n    return Array.from(this.connections.values());\n  }\n\n  /**\n   * Add an item to an array in a map\n   */\n  private addToArray<K, V>(map: Map<K, V[]>, key: K, value: V): void {\n    const array = map.get(key) || [];\n    if (!array.includes(value)) {\n      array.push(value);\n      map.set(key, array);\n    }\n  }\n\n  /**\n   * Remove an item from an array in a map\n   */\n  private removeFromArray<K, V>(map: Map<K, V[]>, key: K, value: V): void {\n    const array = map.get(key);\n    if (array) {\n      const index = array.indexOf(value);\n      if (index >= 0) {\n        array.splice(index, 1);\n        map.set(key, array);\n      }\n    }\n  }\n\n  // Module event handlers\n  private handleModuleCreated = (event: unknown): void => {\n    const { moduleId, moduleType, resources } = event;\n\n    // Determine node type based on module type\n    let nodeType: FlowNodeType = 'consumer';\n    if (moduleType === 'producer' || moduleType === 'mining') {\n      nodeType = 'producer';\n    } else if (moduleType === 'storage') {\n      nodeType = 'storage';\n    } else if (moduleType === 'converter') {\n      nodeType = 'converter';\n    }\n\n    // Create and register node\n    const node: FlowNode = {\n      id: moduleId,\n      type: nodeType,\n      resources: resources || [],\n      priority: { type: resources?.[0] || ResourceType.ENERGY, priority: 1, consumers: [] },\n      active: true,\n    };\n\n    this.registerNode(node);\n  };\n\n  private handleModuleUpdated = (event: unknown): void => {\n    const { moduleId, changes } = event;\n\n    // Get existing node\n    const node = this.nodes.get(moduleId);\n    if (!node) return;\n\n    // Apply changes\n    if (changes.resources) {\n      node.resources = changes.resources;\n    }\n\n    if (changes.active !== undefined) {\n      node.active = changes.active;\n    }\n\n    if (changes.efficiency !== undefined) {\n      node.efficiency = changes.efficiency;\n    }\n\n    // Update node\n    this.nodes.set(moduleId, node);\n\n    // Invalidate cache for affected resources\n    for (const resource of node.resources) {\n      this.invalidateCache(resource);\n    }\n  };\n\n  private handleModuleDestroyed = (event: unknown): void => {\n    const { moduleId } = event;\n    this.unregisterNode(moduleId);\n  };\n\n  private handleModuleStateChanged = (event: unknown): void => {\n    const { moduleId, active } = event;\n\n    // Get existing node\n    const node = this.nodes.get(moduleId);\n    if (!node) return;\n\n    // Update active state\n    node.active = active;\n\n    // Update node\n    this.nodes.set(moduleId, node);\n\n    // Invalidate cache for affected resources\n    for (const resource of node.resources) {\n      this.invalidateCache(resource);\n    }\n  };\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/resource/subsystems/ResourceStorageSubsystem.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'resType' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 518,
        "column": 19,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 518,
        "endColumn": 26
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { eventSystem } from '../../lib/events/UnifiedEventSystem';\nimport {\n  ResourceState as StringResourceState,\n  ResourceTransfer as StringResourceTransfer,\n  ResourceType as StringResourceType,\n} from '../../types/resources/ResourceTypes';\nimport { ResourceType } from \"./../../types/resources/ResourceTypes\";\nimport { ResourceType } from \"./../../types/resources/ResourceTypes\";\nimport { ResourceSystem, ResourceSystemConfig } from '../ResourceSystem';\n\n/**\n * Storage container configuration\n */\nexport interface StorageContainerConfig {\n  id: string;\n  name: string;\n  type: 'container' | 'pool' | 'storage';\n  capacity: number;\n  resourceTypes: StringResourceType[];\n  priority: number;\n  location?: string;\n  efficiency?: number;\n  accessSpeed?: number;\n  upgradeLevel?: number;\n  maxUpgradeLevel?: number;\n}\n\n/**\n * Storage container state\n */\nexport interface StorageContainerState {\n  config: StorageContainerConfig;\n  resources: Map<StringResourceType, StringResourceState>;\n  totalStored: number;\n  lastUpdated: number;\n}\n\n/**\n * Storage allocation\n */\nexport interface StorageAllocation {\n  containerId: string;\n  resourceType: StringResourceType;\n  amount: number;\n  percentage: number;\n}\n\n/**\n * ResourceStorageSubsystem\n *\n * Manages resource storage containers, pools, and allocation strategies\n */\nexport class ResourceStorageSubsystem {\n  private containers: Map<string, StorageContainerState>;\n  private resourcePriorities: Map<StringResourceType, number>;\n  private transferHistory: StringResourceTransfer[];\n  private parentSystem: ResourceSystem;\n  private config: ResourceSystemConfig;\n  private isInitialized = false;\n\n  constructor(parentSystem: ResourceSystem, config: ResourceSystemConfig) {\n    this.parentSystem = parentSystem;\n    this.config = config;\n    this.containers = new Map();\n    this.resourcePriorities = new Map();\n    this.transferHistory = [];\n\n    // Set default resource priorities\n    this.setDefaultResourcePriorities();\n  }\n\n  /**\n   * Set default resource priorities\n   */\n  private setDefaultResourcePriorities(): void {\n    // Higher number = higher priority\n    this.resourcePriorities.set(ResourceType.ENERGY, 10);\n    this.resourcePriorities.set(ResourceType.MINERALS, 8);\n    this.resourcePriorities.set(ResourceType.POPULATION, 9);\n    this.resourcePriorities.set(ResourceType.RESEARCH, 10);\n    this.resourcePriorities.set(ResourceType.PLASMA, 10);\n    this.resourcePriorities.set(ResourceType.GAS, 7);\n    this.resourcePriorities.set(ResourceType.EXOTIC, 6);\n  }\n\n  /**\n   * Initialize the subsystem\n   */\n  public async initialize(): Promise<void> {\n    if (this.isInitialized) {\n      return;\n    }\n\n    try {\n      // Additional initialization logic can go here\n      this.isInitialized = true;\n    } catch (error) {\n      console.error('Failed to initialize ResourceStorageSubsystem:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Dispose of the subsystem\n   */\n  public async dispose(): Promise<void> {\n    if (!this.isInitialized) {\n      return;\n    }\n\n    try {\n      // Cleanup resources\n      this.containers.clear();\n      this.resourcePriorities.clear();\n      this.transferHistory = [];\n\n      this.isInitialized = false;\n    } catch (error) {\n      console.error('Failed to dispose ResourceStorageSubsystem:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Register a storage container\n   */\n  public registerContainer(config: StorageContainerConfig): boolean {\n    if (!config.id || !config.resourceTypes || config.resourceTypes.length === 0) {\n      console.error('Invalid storage container configuration:', config);\n      return false;\n    }\n\n    // Initialize resource states\n    const resources = new Map<StringResourceType, StringResourceState>();\n\n    for (const type of config.resourceTypes) {\n      resources.set(type, {\n        current: 0,\n        min: 0,\n        max: config.capacity / config.resourceTypes.length, // Divide capacity equally by default\n        production: 0,\n        consumption: 0,\n      });\n    }\n\n    this.containers.set(config.id, {\n      config,\n      resources,\n      totalStored: 0,\n      lastUpdated: Date.now(),\n    });\n\n    return true;\n  }\n\n  /**\n   * Unregister a storage container\n   */\n  public unregisterContainer(id: string): boolean {\n    if (!this.containers.has(id)) {\n      return false;\n    }\n\n    this.containers.delete(id);\n    return true;\n  }\n\n  /**\n   * Get a storage container\n   */\n  public getContainer(id: string): StorageContainerState | undefined {\n    return this.containers.get(id);\n  }\n\n  /**\n   * Get all storage containers\n   */\n  public getAllContainers(): StorageContainerState[] {\n    return Array.from(this.containers.values());\n  }\n\n  /**\n   * Get containers by resource type\n   */\n  public getContainersByResourceType(type: StringResourceType): StorageContainerState[] {\n    return Array.from(this.containers.values()).filter(container => container.resources.has(type));\n  }\n\n  /**\n   * Store resource in a specific container\n   */\n  public storeResource(\n    containerId: string,\n    type: StringResourceType | ResourceType,\n    amount: number\n  ): number {\n    // Convert to string resource type for internal use\n    const stringType = ensureStringResourceType(type);\n\n    const container = this.containers.get(containerId);\n    if (!container || amount <= 0) {\n      return 0;\n    }\n\n    // Check if container supports this resource type\n    if (!container.config.resourceTypes.includes(stringType)) {\n      console.warn(`Container ${containerId} does not support resource type ${stringType}`);\n      return 0;\n    }\n\n    // Initialize resource state if it doesn't exist\n    if (!container.resources.has(stringType)) {\n      container.resources.set(stringType, {\n        current: 0,\n        max: container.config.capacity,\n        min: 0,\n        production: 0,\n        consumption: 0,\n      });\n    }\n\n    const resourceState = container.resources.get(stringType)!;\n    const availableSpace = resourceState.max - resourceState.current;\n\n    if (availableSpace <= 0) {\n      // Handle overflow based on policy\n      if (this.config.overflowPolicy === 'redistribute') {\n        return this.redistributeResource(stringType, amount, containerId);\n      }\n\n      // Publish overflow event\n      eventSystem.publish({\n        type: 'RESOURCE_STORAGE_OVERFLOW',\n        resourceType: ResourceTypeType,\n        amount,\n        containerId,\n        timestamp: Date.now(),\n      });\n      return 0;\n    }\n\n    const amountToStore = Math.min(amount, availableSpace);\n\n    resourceState.current += amountToStore;\n    container.totalStored += amountToStore;\n    container.lastUpdated = Date.now();\n\n    // Update system resource state\n    const systemState = this.parentSystem.getResourceState(stringType);\n    if (systemState) {\n      systemState.current += amountToStore;\n      this.parentSystem.updateResourceState(stringType, systemState);\n    }\n\n    // Record transfer\n    this.recordTransfer({\n      type: stringType,\n      source: 'external',\n      target: containerId,\n      amount: amountToStore,\n      timestamp: Date.now(),\n    });\n\n    return amountToStore;\n  }\n\n  /**\n   * Retrieve resource from a specific container\n   */\n  public retrieveResource(\n    containerId: string,\n    type: StringResourceType | ResourceType,\n    amount: number\n  ): number {\n    // Convert to string resource type for internal use\n    const stringType = ensureStringResourceType(type);\n\n    const container = this.containers.get(containerId);\n    if (!container || !container.resources.has(stringType) || amount <= 0) {\n      return 0;\n    }\n\n    const resourceState = container.resources.get(stringType)!;\n\n    if (resourceState.current <= 0) {\n      return 0;\n    }\n\n    const amountToRetrieve = Math.min(amount, resourceState.current);\n\n    resourceState.current -= amountToRetrieve;\n    container.totalStored -= amountToRetrieve;\n    container.lastUpdated = Date.now();\n\n    // Update system resource state\n    const systemState = this.parentSystem.getResourceState(stringType);\n    if (systemState) {\n      systemState.current -= amountToRetrieve;\n      this.parentSystem.updateResourceState(stringType, systemState);\n    }\n\n    // Record transfer\n    this.recordTransfer({\n      type: stringType,\n      source: containerId,\n      target: 'external',\n      amount: amountToRetrieve,\n      timestamp: Date.now(),\n    });\n\n    return amountToRetrieve;\n  }\n\n  /**\n   * Redistribute resource to other containers when primary is full\n   */\n  private redistributeResource(\n    type: StringResourceType,\n    amount: number,\n    excludeContainerId: string\n  ): number {\n    let totalStored = 0;\n    const availableContainers = Array.from(this.containers.values())\n      .filter(\n        container =>\n          container.config.id !== excludeContainerId &&\n          container.config.resourceTypes.includes(type)\n      )\n      .sort((a, b) => b.config.priority - a.config.priority);\n\n    for (const container of availableContainers) {\n      if (amount <= 0) break;\n\n      const stored = this.storeResource(container.config.id, type, amount);\n      totalStored += stored;\n      amount -= stored;\n    }\n\n    return totalStored;\n  }\n\n  /**\n   * Store resource in the best available container\n   */\n  public storeResourceOptimal(type: StringResourceType | ResourceType, amount: number): number {\n    if (amount <= 0) {\n      return 0;\n    }\n\n    // Get all containers that can store this resource type\n    const availableContainers = this.getContainersByResourceType(type as StringResourceType);\n\n    if (availableContainers.length === 0) {\n      return 0;\n    }\n\n    // Calculate scores for each container based on the allocation strategy\n    const containerScores = this.calculateContainerScores(\n      availableContainers,\n      type as StringResourceType\n    );\n\n    // Sort containers by score (highest first)\n    const sortedContainers = [...containerScores].sort((a, b) => b.score - a.score);\n\n    let remainingAmount = amount;\n    let totalStored = 0;\n\n    // Try to store in containers by score order\n    for (const { containerId } of sortedContainers) {\n      if (remainingAmount <= 0) {\n        break;\n      }\n\n      const amountStored = this.storeResource(containerId, type, remainingAmount);\n      totalStored += amountStored;\n      remainingAmount -= amountStored;\n    }\n\n    // Handle overflow if needed\n    if (remainingAmount > 0 && this.config.overflowPolicy !== 'reject') {\n      // Emit overflow event\n      eventSystem.publish({\n        type: 'RESOURCE_STORAGE_OVERFLOW',\n        resourceType: type,\n        amount: remainingAmount,\n        timestamp: Date.now(),\n      });\n    }\n\n    // Check if rebalancing is needed\n    if (this.config.autoRebalance) {\n      this.checkAndRebalance(type as StringResourceType);\n    }\n\n    return totalStored;\n  }\n\n  /**\n   * Retrieve resource from the best available container\n   */\n  public retrieveResourceOptimal(type: StringResourceType | ResourceType, amount: number): number {\n    if (amount <= 0) {\n      return 0;\n    }\n\n    // Get all containers that store this resource type\n    const availableContainers = this.getContainersByResourceType(type as StringResourceType);\n\n    if (availableContainers.length === 0) {\n      return 0;\n    }\n\n    // Calculate scores for each container based on the allocation strategy\n    // For retrieval, we want to prioritize containers with higher fill percentage\n    const containerScores = this.calculateContainerScores(\n      availableContainers,\n      type as StringResourceType,\n      true\n    );\n\n    // Sort containers by score (highest first)\n    const sortedContainers = [...containerScores].sort((a, b) => b.score - a.score);\n\n    let remainingAmount = amount;\n    let totalRetrieved = 0;\n\n    // Try to retrieve from containers by score order\n    for (const { containerId } of sortedContainers) {\n      if (remainingAmount <= 0) {\n        break;\n      }\n\n      const amountRetrieved = this.retrieveResource(containerId, type, remainingAmount);\n      totalRetrieved += amountRetrieved;\n      remainingAmount -= amountRetrieved;\n    }\n\n    return totalRetrieved;\n  }\n\n  /**\n   * Calculate container scores for allocation\n   */\n  private calculateContainerScores(\n    containers: StorageContainerState[],\n    resourceType: StringResourceType,\n    forRetrieval = false\n  ): Array<{ containerId: string; score: number }> {\n    const weights = {\n      containerPriority: 0.4,\n      resourcePriority: 0.4,\n      fillPercentage: 0.2,\n    };\n\n    const resourcePriorityValue = this.resourcePriorities.get(resourceType) || 5;\n\n    return containers.map(container => {\n      const resourceState = container.resources.get(resourceType)!;\n      const fillRatio = resourceState.current / resourceState.max;\n\n      // For storage, we prefer containers with lower fill percentage\n      // For retrieval, we prefer containers with higher fill percentage\n      const fillScore = forRetrieval ? fillRatio : 1 - fillRatio;\n\n      // Calculate weighted score\n      const score =\n        container.config.priority * weights.containerPriority +\n        resourcePriorityValue * weights.resourcePriority +\n        fillScore * weights.fillPercentage;\n\n      return {\n        containerId: container.config.id,\n        score,\n      };\n    });\n  }\n\n  /**\n   * Redistribute overflow by expanding container capacity\n   */\n  public redistributeOverflow(\n    type: StringResourceType | ResourceType,\n    amount: number,\n    sourceId?: string\n  ): number {\n    // Find containers that can store this resource type\n    const relevantContainers = this.getContainersByResourceType(type as StringResourceType);\n\n    if (relevantContainers.length === 0) {\n      return 0;\n    }\n\n    // If sourceId is provided, filter out that container\n    const eligibleContainers = sourceId\n      ? relevantContainers.filter(c => c.config.id !== sourceId)\n      : relevantContainers;\n\n    if (eligibleContainers.length === 0) {\n      // Sort by upgrade potential (containers with lower upgrade level first)\n      const upgradableContainers = relevantContainers\n        .filter(\n          container =>\n            container.config.upgradeLevel !== undefined &&\n            container.config.maxUpgradeLevel !== undefined &&\n            container.config.upgradeLevel < container.config.maxUpgradeLevel\n        )\n        .sort((a, b) => (a.config.upgradeLevel || 0) - (b.config.upgradeLevel || 0));\n\n      if (upgradableContainers.length === 0) {\n        return 0;\n      }\n\n      // Upgrade the first container\n      const containerToUpgrade = upgradableContainers[0];\n\n      // For each resource type in the container\n      for (const [resType, resourceState] of containerToUpgrade.resources.entries()) {\n        // Increase capacity by 20%\n        const capacityIncrease = resourceState.max * 0.2;\n        resourceState.max += capacityIncrease;\n      }\n\n      // Increment upgrade level\n      if (containerToUpgrade.config.upgradeLevel !== undefined) {\n        containerToUpgrade.config.upgradeLevel += 1;\n      }\n\n      // Try to store again if it's the target resource type\n      if (sourceId) {\n        return this.storeResource(containerToUpgrade.config.id, type, amount);\n      } else {\n        return this.storeResourceOptimal(type, amount);\n      }\n    } else {\n      // Distribute among eligible containers\n      let remainingAmount = amount;\n      let totalStored = 0;\n\n      // Calculate available space in all eligible containers\n      for (const container of eligibleContainers) {\n        if (remainingAmount <= 0) break;\n\n        const resourceState = container.resources.get(type as StringResourceType)!;\n        const availableSpace = resourceState.max - resourceState.current;\n\n        if (availableSpace <= 0) continue;\n\n        const amountToStore = Math.min(remainingAmount, availableSpace);\n        const stored = this.storeResource(container.config.id, type, amountToStore);\n\n        totalStored += stored;\n        remainingAmount -= stored;\n      }\n\n      return totalStored;\n    }\n  }\n\n  /**\n   * Check if rebalancing is needed and perform it\n   */\n  private checkAndRebalance(type: StringResourceType): void {\n    const containers = this.getContainersByResourceType(type);\n\n    if (containers.length <= 1) {\n      return;\n    }\n\n    // Calculate fill ratios\n    const fillRatios = containers.map(container => {\n      const resourceState = container.resources.get(type)!;\n      return {\n        id: container.config.id,\n        fillRatio: resourceState.current / resourceState.max,\n      };\n    });\n\n    // Find min and max fill ratios\n    const minFill = Math.min(...fillRatios.map(r => r.fillRatio));\n    const maxFill = Math.max(...fillRatios.map(r => r.fillRatio));\n\n    // Check if imbalance exceeds threshold (default 0.2 or 20%)\n    const threshold = 0.2;\n    if (maxFill - minFill > threshold) {\n      this.rebalanceContainers(type, containers);\n    }\n  }\n\n  /**\n   * Rebalance resources between containers\n   */\n  private rebalanceContainers(type: StringResourceType, containers: StorageContainerState[]): void {\n    // Calculate target fill ratio (average)\n    let totalCurrent = 0;\n    let totalMax = 0;\n\n    for (const container of containers) {\n      const resourceState = container.resources.get(type)!;\n      totalCurrent += resourceState.current;\n      totalMax += resourceState.max;\n    }\n\n    const targetFillRatio = totalCurrent / totalMax;\n\n    // Calculate transfers needed\n    for (const container of containers) {\n      const resourceState = container.resources.get(type)!;\n      const currentFillRatio = resourceState.current / resourceState.max;\n\n      if (Math.abs(currentFillRatio - targetFillRatio) < 0.05) {\n        // Close enough, skip\n        continue;\n      }\n\n      const targetAmount = resourceState.max * targetFillRatio;\n      const difference = targetAmount - resourceState.current;\n\n      if (difference > 0) {\n        // Need to add resources\n        // Find container with excess\n        const sourceContainer = containers.find(c => {\n          const rs = c.resources.get(type)!;\n          return rs.current / rs.max > targetFillRatio + 0.05;\n        });\n\n        if (sourceContainer) {\n          const sourceState = sourceContainer.resources.get(type)!;\n          const availableToTransfer = sourceState.current - sourceState.max * targetFillRatio;\n          const transferAmount = Math.min(difference, availableToTransfer);\n\n          // Transfer resources\n          this.transferBetweenContainers(\n            sourceContainer.config.id,\n            container.config.id,\n            type,\n            transferAmount\n          );\n        }\n      }\n    }\n  }\n\n  /**\n   * Transfer resources between containers\n   */\n  public transferBetweenContainers(\n    sourceId: string,\n    targetId: string,\n    type: StringResourceType | ResourceType,\n    amount: number\n  ): number {\n    if (amount <= 0 || sourceId === targetId) {\n      return 0;\n    }\n\n    // Retrieve from source\n    const retrievedAmount = this.retrieveResource(sourceId, type, amount);\n\n    if (retrievedAmount <= 0) {\n      return 0;\n    }\n\n    // Store in target\n    const storedAmount = this.storeResource(targetId, type, retrievedAmount);\n\n    // If not all was stored, return remainder to source\n    if (storedAmount < retrievedAmount) {\n      const remainder = retrievedAmount - storedAmount;\n      this.storeResource(sourceId, type, remainder);\n    }\n\n    // Record transfer\n    this.recordTransfer({\n      type: type as StringResourceType,\n      source: sourceId,\n      target: targetId,\n      amount: storedAmount,\n      timestamp: Date.now(),\n    });\n\n    return storedAmount;\n  }\n\n  /**\n   * Record a transfer in history\n   */\n  private recordTransfer(transfer: StringResourceTransfer): void {\n    this.transferHistory.push(transfer);\n\n    // Trim history if needed\n    if (this.transferHistory.length > this.config.maxHistorySize) {\n      this.transferHistory = this.transferHistory.slice(-this.config.maxHistorySize);\n    }\n\n    // Publish transfer event\n    eventSystem.publish({\n      type: 'RESOURCE_TRANSFERRED',\n      resourceType: transfer.type,\n      source: transfer.source,\n      target: transfer.target,\n      amount: transfer.amount,\n      timestamp: Date.now(),\n    });\n  }\n\n  /**\n   * Get transfer history\n   */\n  public getTransferHistory(): StringResourceTransfer[] {\n    return [...this.transferHistory];\n  }\n\n  /**\n   * Get total stored amount of a resource type\n   */\n  public getTotalStored(type: StringResourceType | ResourceType): number {\n    let total = 0;\n\n    for (const container of this.containers.values()) {\n      const resourceState = container.resources.get(type as StringResourceType);\n      if (resourceState) {\n        total += resourceState.current;\n      }\n    }\n\n    return total;\n  }\n\n  /**\n   * Get total capacity for a resource type\n   */\n  public getTotalCapacity(type: StringResourceType | ResourceType): number {\n    let total = 0;\n\n    for (const container of this.containers.values()) {\n      const resourceState = container.resources.get(type as StringResourceType);\n      if (resourceState) {\n        total += resourceState.max;\n      }\n    }\n\n    return total;\n  }\n\n  /**\n   * Set resource priority\n   */\n  public setResourcePriority(type: StringResourceType | ResourceType, priority: number): void {\n    // Convert to string resource type for internal use\n    const stringType = ensureStringResourceType(type);\n\n    this.resourcePriorities.set(stringType, priority);\n  }\n\n  /**\n   * Get resource priority\n   */\n  public getResourcePriority(type: StringResourceType | ResourceType): number {\n    // Convert to string resource type for internal use\n    const stringType = ensureStringResourceType(type);\n\n    return this.resourcePriorities.get(stringType) || 5;\n  }\n\n  /**\n   * Update container configuration\n   */\n  public updateContainerConfig(id: string, config: Partial<StorageContainerConfig>): boolean {\n    const container = this.containers.get(id);\n    if (!container) {\n      return false;\n    }\n\n    // Update config\n    container.config = {\n      ...container.config,\n      ...config,\n    };\n\n    return true;\n  }\n\n  /**\n   * Get resource state for a specific container and resource type\n   */\n  public getContainerResourceState(\n    containerId: string,\n    type: StringResourceType | ResourceType\n  ): StringResourceState | null {\n    // Convert to string resource type for internal use\n    const stringType = ensureStringResourceType(type);\n\n    const container = this.containers.get(containerId);\n    if (!container || !container.resources.has(stringType)) {\n      return null;\n    }\n\n    return { ...container.resources.get(stringType)! };\n  }\n\n  /**\n   * Get all resource states for a specific container\n   */\n  public getContainerResourceStates(\n    containerId: string\n  ): Map<StringResourceType, StringResourceState> | null {\n    const container = this.containers.get(containerId);\n    if (!container) {\n      return null;\n    }\n\n    // Create a copy of the resource states\n    const resourceStates = new Map<StringResourceType, StringResourceState>();\n    for (const [type, state] of container.resources.entries()) {\n      resourceStates.set(type, { ...state });\n    }\n\n    return resourceStates;\n  }\n\n  /**\n   * Get all containers that store a specific resource type\n   */\n  public getContainersForResourceType(\n    type: StringResourceType | ResourceType\n  ): StorageContainerState[] {\n    // Convert to string resource type for internal use\n    const stringType = ensureStringResourceType(type);\n\n    return Array.from(this.containers.values()).filter(container =>\n      container.config.resourceTypes.includes(stringType)\n    );\n  }\n\n  /**\n   * Get total stored amount of a specific resource type across all containers\n   */\n  public getTotalStoredAmount(type: StringResourceType | ResourceType): number {\n    // Convert to string resource type for internal use\n    const stringType = ensureStringResourceType(type);\n\n    let total = 0;\n    for (const container of this.containers.values()) {\n      const resourceState = container.resources.get(stringType);\n      if (resourceState) {\n        total += resourceState.current;\n      }\n    }\n    return total;\n  }\n\n  /**\n   * Get total storage capacity for a specific resource type across all containers\n   */\n  public getTotalStorageCapacity(type: StringResourceType | ResourceType): number {\n    // Convert to string resource type for internal use\n    const stringType = ensureStringResourceType(type);\n\n    let total = 0;\n    for (const container of this.containers.values()) {\n      if (container.config.resourceTypes.includes(stringType)) {\n        total += container.config.capacity;\n      }\n    }\n    return total;\n  }\n\n  /**\n   * Get available storage space for a specific resource type across all containers\n   */\n  public getAvailableStorageSpace(type: StringResourceType | ResourceType): number {\n    // Convert to string resource type for internal use\n    const stringType = ensureStringResourceType(type);\n\n    let total = 0;\n    for (const container of this.containers.values()) {\n      if (container.config.resourceTypes.includes(stringType)) {\n        const resourceState = container.resources.get(stringType);\n        if (resourceState) {\n          total += resourceState.max - resourceState.current;\n        } else {\n          total += container.config.capacity;\n        }\n      }\n    }\n    return total;\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/resource/subsystems/ResourceThresholdSubsystem.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/resource/subsystems/ResourceTransferSubsystem.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/router/routes.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/scripts/runNetworkTests.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'results' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 106,
        "column": 29,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 106,
        "endColumn": 36
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Network Degradation Test Suite Runner\n *\n * This script runs the network degradation test suite to evaluate application\n * performance under various network conditions. It provides command-line options\n * to run specific tests or all tests together.\n *\n * Usage:\n *   npx ts-node src/scripts/runNetworkTests.ts --all\n *   npx ts-node src/scripts/runNetworkTests.ts --api\n *   npx ts-node src/scripts/runNetworkTests.ts --resources\n *   npx ts-node src/scripts/runNetworkTests.ts --interactions\n */\n\nimport {\n  NetworkDegradationTestResult,\n  testApiPerformance,\n  testResourceLoadingPerformance,\n  testUserInteractionPerformance,\n} from '../tests/performance/NetworkDegradationTestSuite';\n\n// Parse command line arguments\nconst args = process.argv.slice(2);\nconst runAll = args.includes('--all');\nconst runApi = args.includes('--api') || runAll;\nconst runResources = args.includes('--resources') || runAll;\nconst runInteractions = args.includes('--interactions') || runAll;\nconst generateReport = args.includes('--report') || runAll;\n\n// Define a function to format duration\nfunction formatDuration(ms: number): string {\n  if (ms < 1000) return `${ms.toFixed(0)}ms`;\n  const seconds = ms / 1000;\n  if (seconds < 60) return `${seconds.toFixed(1)}s`;\n  const minutes = Math.floor(seconds / 60);\n  const remainingSeconds = seconds % 60;\n  return `${minutes}m ${remainingSeconds.toFixed(0)}s`;\n}\n\n// Function to print a result table\nfunction printResultTable(results: NetworkDegradationTestResult[], title: string): void {\n  console.warn(`\\n${title}`);\n  console.warn('-'.repeat(100));\n  console.warn(\n    '| Network Condition       | Avg Response Time | Max Response Time | Success Rate | TTI        |'\n  );\n  console.warn(\n    '|-------------------------|-------------------|-------------------|--------------|------------|'\n  );\n\n  // Group results by network condition\n  const groupedResults: Record<string, NetworkDegradationTestResult[]> = {};\n  results.forEach(result => {\n    const conditionName = result.networkCondition.name;\n    groupedResults[conditionName] = groupedResults[conditionName] || [];\n    groupedResults[conditionName].push(result);\n  });\n\n  // Sort network conditions by average response time (ascending)\n  const sortedConditions = Object.entries(groupedResults)\n    .map(([condition, results]) => {\n      const avgResponseTime =\n        results.reduce((sum, r) => sum + r.averageResponseTimeMs, 0) / results.length;\n\n      return { condition, avgResponseTime };\n    })\n    .sort((a, b) => a.avgResponseTime - b.avgResponseTime);\n\n  // Print each condition's results\n  for (const { condition } of sortedConditions) {\n    const condResults = groupedResults[condition];\n    const avgResponseTime =\n      condResults.reduce((sum, r) => sum + r.averageResponseTimeMs, 0) / condResults.length;\n\n    const maxResponseTime = Math.max(...condResults.map(r => r.maxResponseTimeMs));\n\n    const successCount = condResults.reduce((sum, r) => sum + r.successfulOperations, 0);\n\n    const totalOps = successCount + condResults.reduce((sum, r) => sum + r.failedOperations, 0);\n\n    const successRate = totalOps > 0 ? (successCount / totalOps) * 100 : 0;\n\n    const avgTTI =\n      condResults.reduce((sum, r) => sum + r.timeToInteractive, 0) / condResults.length;\n\n    // Print the row\n    console.warn(\n      `| %-23s | %-17s | %-17s | %-12s | %-10s |`.replace(/%(-?\\d+)s/g, (match, width) => {\n        const paddingLength = parseInt(width.replace('-', ''));\n        const text = [\n          condition.padEnd(23),\n          formatDuration(avgResponseTime).padEnd(17),\n          formatDuration(maxResponseTime).padEnd(17),\n          `${successRate.toFixed(1)}%`.padEnd(12),\n          formatDuration(avgTTI).padEnd(10),\n        ][0];\n        return width.startsWith('-') ? text.padEnd(paddingLength) : text.padStart(paddingLength);\n      })\n    );\n  }\n\n  console.warn('-'.repeat(100));\n}\n\n// Function to generate a full HTML report\nfunction generateHtmlReport(results: Record<string, NetworkDegradationTestResult[]>): void {\n  // Implementation for generating a detailed HTML report\n  // (This would be a more extensive implementation in the real system)\n  console.warn('\\nGenerating HTML report...');\n  console.warn('HTML report generation not implemented in this demo script.');\n}\n\nasync function main(): Promise<void> {\n  console.warn('Network Degradation Test Suite Runner');\n  console.warn('====================================\\n');\n\n  const startTime = Date.now();\n  const results: Record<string, NetworkDegradationTestResult[]> = {};\n\n  if (runApi) {\n    console.warn('Running API performance tests...');\n    results.api = await testApiPerformance();\n    printResultTable(results.api, 'API Performance Results');\n  }\n\n  if (runResources) {\n    console.warn('\\nRunning resource loading performance tests...');\n    results.resources = await testResourceLoadingPerformance();\n    printResultTable(results.resources, 'Resource Loading Performance Results');\n  }\n\n  if (runInteractions) {\n    console.warn('\\nRunning user interaction performance tests...');\n    results.interactions = await testUserInteractionPerformance();\n    printResultTable(results.interactions, 'User Interaction Performance Results');\n  }\n\n  // Print overall time\n  const totalTime = Date.now() - startTime;\n  console.warn(`\\nCompleted all tests in ${formatDuration(totalTime)}`);\n\n  // Generate report if requested\n  if (generateReport) {\n    generateHtmlReport(results);\n  }\n\n  // Print usage instructions if no arguments provided\n  if (!runAll && !runApi && !runResources && !runInteractions) {\n    console.warn('\\nUsage:');\n    console.warn('  npx ts-node src/scripts/runNetworkTests.ts --all         Run all tests');\n    console.warn(\n      '  npx ts-node src/scripts/runNetworkTests.ts --api         Run API performance tests'\n    );\n    console.warn(\n      '  npx ts-node src/scripts/runNetworkTests.ts --resources   Run resource loading tests'\n    );\n    console.warn(\n      '  npx ts-node src/scripts/runNetworkTests.ts --interactions Run user interaction tests'\n    );\n    console.warn('  npx ts-node src/scripts/runNetworkTests.ts --report      Generate HTML report');\n  }\n}\n\n// Run the main function\nmain().catch(error => {\n  console.error('Error running network tests:', error);\n  process.exit(1);\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/services/APIService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/services/AnalysisAlgorithmService.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'sampleRate' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 307,
        "column": 11,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 307,
        "endColumn": 21
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'options' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 400,
        "column": 5,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 400,
        "endColumn": 12
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 520,
        "column": 22,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 520,
        "endColumn": 25,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [15985, 15988], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [15985, 15988], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'options' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 661,
        "column": 5,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 661,
        "endColumn": 12
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'options' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 970,
        "column": 5,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 970,
        "endColumn": 12
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'normalize' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 1035,
        "column": 7,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 1035,
        "endColumn": 16
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 1142,
        "column": 36,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 1142,
        "endColumn": 39,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [33607, 33610], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [33607, 33610], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 1396,
        "column": 9,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 1396,
        "endColumn": 75,
        "suggestions": [
          {
            "messageId": "addBrackets",
            "fix": {
              "range": [41193, 41637],
              "text": "{ return a.reduce((sum, val, i) => sum + Math.abs(val - b[i]), 0);\n\n        const dotProduct = a.reduce((sum, val, i) => sum + val * b[i], 0);\n        const magnitudeA = Math.sqrt(a.reduce((sum, val) => sum + val * val, 0));\n        const magnitudeB = Math.sqrt(b.reduce((sum, val) => sum + val * val, 0));\n\n        if (magnitudeA === 0 || magnitudeB === 0) return 1; // Maximum distance\n        return 1 - dotProduct / (magnitudeA * magnitudeB); }"
            },
            "desc": "Add {} brackets around the case block."
          }
        ]
      },
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 1397,
        "column": 9,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 1397,
        "endColumn": 82,
        "suggestions": [
          {
            "messageId": "addBrackets",
            "fix": {
              "range": [41193, 41637],
              "text": "{ return a.reduce((sum, val, i) => sum + Math.abs(val - b[i]), 0);\n\n        const dotProduct = a.reduce((sum, val, i) => sum + val * b[i], 0);\n        const magnitudeA = Math.sqrt(a.reduce((sum, val) => sum + val * val, 0));\n        const magnitudeB = Math.sqrt(b.reduce((sum, val) => sum + val * val, 0));\n\n        if (magnitudeA === 0 || magnitudeB === 0) return 1; // Maximum distance\n        return 1 - dotProduct / (magnitudeA * magnitudeB); }"
            },
            "desc": "Add {} brackets around the case block."
          }
        ]
      },
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 1398,
        "column": 9,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 1398,
        "endColumn": 82,
        "suggestions": [
          {
            "messageId": "addBrackets",
            "fix": {
              "range": [41193, 41637],
              "text": "{ return a.reduce((sum, val, i) => sum + Math.abs(val - b[i]), 0);\n\n        const dotProduct = a.reduce((sum, val, i) => sum + val * b[i], 0);\n        const magnitudeA = Math.sqrt(a.reduce((sum, val) => sum + val * val, 0));\n        const magnitudeB = Math.sqrt(b.reduce((sum, val) => sum + val * val, 0));\n\n        if (magnitudeA === 0 || magnitudeB === 0) return 1; // Maximum distance\n        return 1 - dotProduct / (magnitudeA * magnitudeB); }"
            },
            "desc": "Add {} brackets around the case block."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 1426,
        "column": 39,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 1426,
        "endColumn": 42,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [42228, 42231], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [42228, 42231], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'i' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 1466,
        "column": 34,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 1466,
        "endColumn": 35
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'options' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 2078,
        "column": 5,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 2078,
        "endColumn": 12
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'normalizedTestFeatures' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 2567,
        "column": 38,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 2567,
        "endColumn": 60
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'normalizedTestTargets' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 2578,
        "column": 11,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 2578,
        "endColumn": 32
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'batchLoss' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 2662,
        "column": 11,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 2662,
        "endColumn": 20
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 2905,
        "column": 74,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 2905,
        "endColumn": 77,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [85706, 85709], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [85706, 85709], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 2906,
        "column": 55,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 2906,
        "endColumn": 58,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [85786, 85789], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [85786, 85789], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'options' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 2979,
        "column": 5,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 2979,
        "endColumn": 12
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 2999,
        "column": 47,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 2999,
        "endColumn": 50,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [89030, 89033], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [89030, 89033], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 3228,
        "column": 33,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 3228,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [96027, 96030], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [96027, 96030], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 3308,
        "column": 33,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 3308,
        "endColumn": 36,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [98947, 98950], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [98947, 98950], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'dataset' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 3334,
        "column": 5,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 3334,
        "endColumn": 12
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'options' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 3335,
        "column": 5,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 3335,
        "endColumn": 12
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'normalizeValues' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 3344,
        "column": 7,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 3344,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'timeRange' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 3345,
        "column": 7,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 3345,
        "endColumn": 16
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'groupBy' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 3346,
        "column": 7,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 3346,
        "endColumn": 14
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'dataset' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 3374,
        "column": 5,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 3374,
        "endColumn": 12
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'options' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 3375,
        "column": 5,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 3375,
        "endColumn": 12
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'includeNeighbors' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 3381,
        "column": 33,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 3381,
        "endColumn": 49
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'timeRange' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 3381,
        "column": 59,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 3381,
        "endColumn": 68
      }
    ],
    "suppressedMessages": [],
    "errorCount": 11,
    "fatalErrorCount": 0,
    "warningCount": 20,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * @file AnalysisAlgorithmService.ts\n * Service for implementing data analysis algorithms\n *\n * This service:\n * 1. Provides implementation for various analysis types\n * 2. Processes datasets using appropriate algorithms\n * 3. Generates insights from data patterns\n * 4. Implements caching for expensive calculations\n */\n\nimport { v4 as uuidv4 } from 'uuid';\nimport {\n  AnalysisConfig,\n  AnalysisResult,\n  ClusteringAnalysisConfig,\n  ComparisonAnalysisConfig,\n  CorrelationAnalysisConfig,\n  DataPoint,\n  Dataset,\n  DistributionAnalysisConfig,\n  PredictionAnalysisConfig,\n  ResourceMappingAnalysisConfig,\n  SectorAnalysisConfig,\n  TrendAnalysisConfig,\n} from '../types/exploration/DataAnalysisTypes';\n\n/**\n * Interface for algorithm options\n */\ninterface AlgorithmOptions {\n  timeoutMs?: number;\n  maxSamples?: number;\n  normalize?: boolean;\n  includeDetails?: boolean;\n  confidenceThreshold?: number;\n  useWorker?: boolean; // Option to use WebWorker for heavy calculations\n  sampleData?: boolean; // Option to sample large datasets for faster processing\n  sampleSize?: number; // Number of samples to use when sampleData is true\n}\n\n// Type definition for property extraction and value memoization\ntype PropertyExtractor = (point: DataPoint) => unknown;\n\n/**\n * Service for implementing analysis algorithms\n */\nexport class AnalysisAlgorithmService {\n  // Cache for storing computed results to improve performance\n  private resultCache: Map<string, { result: AnalysisResult; expiresAt: number }> = new Map();\n\n  // Cache expiration time (10 minutes)\n  private cacheExpirationMs = 10 * 60 * 1000;\n\n  // Property access cache for faster property extraction\n  private propertyExtractorCache: Map<string, PropertyExtractor> = new Map();\n\n  // Default sample size for large datasets\n  private defaultSampleSize = 1000;\n\n  // Memoization for common statistical operations\n  private memoizedMeans: Map<string, number> = new Map();\n  private memoizedVariances: Map<string, number> = new Map();\n\n  // WebWorker pool for parallel processing\n  private workerPool: Worker[] = [];\n  private isWorkerSupported = typeof Worker !== 'undefined';\n  private maxWorkers = navigator.hardwareConcurrency || 4;\n\n  constructor() {\n    // Initialize WebWorker pool if supported\n    if (this.isWorkerSupported) {\n      this.initWorkerPool();\n    }\n  }\n\n  /**\n   * Initialize WebWorker pool for parallel processing\n   */\n  private initWorkerPool(): void {\n    // Create workers up to the maximum number allowed\n    for (let i = 0; i < this.maxWorkers; i++) {\n      try {\n        // Create a worker for calculation-intensive tasks\n        const worker = new Worker(new URL('../workers/AnalysisWorker.ts', import.meta.url));\n        this.workerPool.push(worker);\n      } catch (error) {\n        console.error('Failed to create worker:', error);\n      }\n    }\n  }\n\n  /**\n   * Run analysis on a dataset\n   */\n  public async runAnalysis(\n    config: AnalysisConfig,\n    dataset: Dataset,\n    options: AlgorithmOptions = {}\n  ): Promise<AnalysisResult> {\n    // Set default options\n    const effectiveOptions = {\n      ...options,\n      sampleData: options.sampleData ?? dataset.dataPoints.length > this.defaultSampleSize,\n      sampleSize: options.sampleSize ?? this.defaultSampleSize,\n      useWorker: options.useWorker ?? (this.isWorkerSupported && dataset.dataPoints.length > 5000),\n    };\n\n    // Generate a cache key based on config, dataset, and options\n    const cacheKey = this.generateCacheKey(config, dataset, effectiveOptions);\n\n    // Check if a cached result exists and is still valid\n    const cachedResult = this.resultCache.get(cacheKey);\n    if (cachedResult && cachedResult.expiresAt > Date.now()) {\n      return cachedResult.result;\n    }\n\n    // Clear memoization caches for new analysis\n    this.clearMemoizationCaches();\n\n    // Sample the dataset if needed\n    const dataToProcess = this.getSampledDataset(dataset, effectiveOptions);\n\n    // Start the analysis\n    const resultId = uuidv4();\n    const startTime = Date.now();\n\n    // Create a pending result\n    const _pendingResult: AnalysisResult = {\n      id: resultId,\n      analysisConfigId: config.id,\n      status: 'processing',\n      startTime,\n      data: {},\n    };\n\n    try {\n      // Use a worker if available and needed\n      let result: AnalysisResult;\n\n      if (effectiveOptions.useWorker && this.workerPool.length > 0) {\n        result = await this.runAnalysisInWorker(config, dataToProcess, effectiveOptions);\n      } else {\n        // Run the appropriate analysis algorithm based on the type\n        switch (config.type) {\n          case 'trend':\n            result = await this.analyzeTrend(\n              config as TrendAnalysisConfig,\n              dataToProcess,\n              effectiveOptions\n            );\n            break;\n          case 'correlation':\n            result = await this.analyzeCorrelation(\n              config as CorrelationAnalysisConfig,\n              dataToProcess,\n              effectiveOptions\n            );\n            break;\n          case 'distribution':\n            result = await this.analyzeDistribution(\n              config as DistributionAnalysisConfig,\n              dataToProcess,\n              effectiveOptions\n            );\n            break;\n          case 'clustering':\n            result = await this.analyzeClustering(\n              config as ClusteringAnalysisConfig,\n              dataToProcess,\n              effectiveOptions\n            );\n            break;\n          case 'prediction':\n            result = await this.analyzePrediction(\n              config as PredictionAnalysisConfig,\n              dataToProcess,\n              effectiveOptions\n            );\n            break;\n          case 'comparison':\n            result = await this.analyzeComparison(\n              config as ComparisonAnalysisConfig,\n              dataToProcess,\n              effectiveOptions\n            );\n            break;\n          case 'resourceMapping':\n            result = await this.analyzeResourceMapping(\n              config as ResourceMappingAnalysisConfig,\n              dataToProcess,\n              effectiveOptions\n            );\n            break;\n          case 'sectorAnalysis':\n            result = await this.analyzeSector(\n              config as SectorAnalysisConfig,\n              dataToProcess,\n              effectiveOptions\n            );\n            break;\n          default:\n            throw new Error(`Unsupported analysis type: ${config.type}`);\n        }\n      }\n\n      // Add data sampling info to result if sampling was used\n      if (effectiveOptions.sampleData && dataset.dataPoints.length > effectiveOptions.sampleSize) {\n        result.data.samplingInfo = {\n          originalSize: dataset.dataPoints.length,\n          sampleSize: effectiveOptions.sampleSize,\n          samplingRatio: effectiveOptions.sampleSize / dataset.dataPoints.length,\n        };\n      }\n\n      // Update the result cache\n      this.resultCache.set(cacheKey, {\n        result,\n        expiresAt: Date.now() + this.cacheExpirationMs,\n      });\n\n      return result;\n    } catch (error) {\n      // Return a failed result if an error occurred\n      const failedResult: AnalysisResult = {\n        id: resultId,\n        analysisConfigId: config.id,\n        status: 'failed',\n        startTime,\n        endTime: Date.now(),\n        data: {},\n        error: error instanceof Error ? error.message : 'Unknown error',\n      };\n\n      return failedResult;\n    }\n  }\n\n  /**\n   * Run analysis in a WebWorker for improved performance\n   */\n  private runAnalysisInWorker(\n    config: AnalysisConfig,\n    dataset: Dataset,\n    options: AlgorithmOptions\n  ): Promise<AnalysisResult> {\n    return new Promise((resolve, reject) => {\n      // Find an available worker\n      const worker = this.workerPool[0]; // Simple round-robin for now\n\n      // Create a unique message ID for this analysis\n      const messageId = uuidv4();\n\n      // Set up message handler\n      const handleMessage = (event: MessageEvent) => {\n        if (event.data.messageId === messageId) {\n          // Clean up message handler\n          worker.removeEventListener('message', handleMessage);\n\n          if (event.data.error) {\n            reject(new Error(event.data.error));\n          } else {\n            resolve(event.data.result);\n          }\n        }\n      };\n\n      // Set up error handler\n      const handleError = (error: ErrorEvent) => {\n        worker.removeEventListener('error', handleError);\n        reject(new Error(`Worker error: ${error.message}`));\n      };\n\n      // Register handlers\n      worker.addEventListener('message', handleMessage);\n      worker.addEventListener('error', handleError);\n\n      // Post message to worker\n      worker.postMessage({\n        messageId,\n        action: 'runAnalysis',\n        config,\n        dataset,\n        options,\n      });\n\n      // Set up timeout if specified\n      if (options.timeoutMs) {\n        setTimeout(() => {\n          worker.removeEventListener('message', handleMessage);\n          worker.removeEventListener('error', handleError);\n          reject(new Error(`Analysis timed out after ${options.timeoutMs}ms`));\n        }, options.timeoutMs);\n      }\n    });\n  }\n\n  /**\n   * Sample dataset for faster processing\n   */\n  private getSampledDataset(dataset: Dataset, options: AlgorithmOptions): Dataset {\n    if (!options.sampleData || dataset.dataPoints.length <= options.sampleSize!) {\n      return dataset;\n    }\n\n    // Create a sampled copy of the dataset\n    const sampleRate = options.sampleSize! / dataset.dataPoints.length;\n    const sampledPoints = this.stratifiedSample(dataset.dataPoints, options.sampleSize!);\n\n    return {\n      ...dataset,\n      dataPoints: sampledPoints,\n    };\n  }\n\n  /**\n   * Create a stratified sample of data points ensuring representation across types\n   */\n  private stratifiedSample(dataPoints: DataPoint[], sampleSize: number): DataPoint[] {\n    // Group data points by type\n    const byType: Record<string, DataPoint[]> = {};\n    for (const point of dataPoints) {\n      if (!byType[point.type]) {\n        byType[point.type] = [];\n      }\n      byType[point.type].push(point);\n    }\n\n    const result: DataPoint[] = [];\n    const types = Object.keys(byType);\n\n    // Calculate samples per type\n    let remaining = sampleSize;\n    const typeAllocations: Record<string, number> = {};\n\n    for (const type of types) {\n      // Allocate proportionally to original size\n      const proportion = byType[type].length / dataPoints.length;\n      const allocation = Math.floor(sampleSize * proportion);\n      typeAllocations[type] = allocation;\n      remaining -= allocation;\n    }\n\n    // Distribute any remaining sample slots\n    let typeIndex = 0;\n    while (remaining > 0) {\n      typeAllocations[types[typeIndex % types.length]]++;\n      remaining--;\n      typeIndex++;\n    }\n\n    // Sample from each type\n    for (const type of types) {\n      const typeSampleSize = typeAllocations[type];\n      const typeDataPoints = byType[type];\n\n      // Randomly select data points\n      const selected = new Set<number>();\n      while (selected.size < typeSampleSize) {\n        const index = Math.floor(Math.random() * typeDataPoints.length);\n        selected.add(index);\n      }\n\n      // Add selected points to result\n      for (const index of selected) {\n        result.push(typeDataPoints[index]);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Clear memoization caches before starting a new analysis\n   */\n  private clearMemoizationCaches(): void {\n    this.memoizedMeans.clear();\n    this.memoizedVariances.clear();\n  }\n\n  /**\n   * Generate a cache key for a specific analysis configuration and dataset\n   */\n  private generateCacheKey(\n    config: AnalysisConfig,\n    dataset: Dataset,\n    options: AlgorithmOptions\n  ): string {\n    // Create a key based on configuration ID, dataset ID, last updated time, and options\n    const optionsKey = JSON.stringify(options);\n    return `${config.id}:${dataset.id}:${dataset.updatedAt}:${optionsKey}`;\n  }\n\n  /**\n   * Analyze trend data\n   */\n  private async analyzeTrend(\n    config: TrendAnalysisConfig,\n    dataset: Dataset,\n    options: AlgorithmOptions\n  ): Promise<AnalysisResult> {\n    const startTime = Date.now();\n\n    // Extract parameters\n    const { xAxis, yAxis, groupBy, timeRange, aggregation } = config.parameters;\n\n    // Filter data points based on time range\n    let dataPoints = dataset.dataPoints;\n    if (timeRange) {\n      dataPoints = dataPoints.filter(dp => dp.date >= timeRange[0] && dp.date <= timeRange[1]);\n    }\n\n    // Get or create optimized property extractors\n    const xExtractor = this.getPropertyExtractor(xAxis);\n    const yExtractor = this.getPropertyExtractor(yAxis);\n    const groupExtractor = groupBy ? this.getPropertyExtractor(groupBy) : null;\n\n    // Group data by the groupBy parameter if specified\n    let groupedData: Record<string, DataPoint[]> = {};\n    if (groupExtractor) {\n      // Group data using the optimized extractor\n      groupedData = this.groupDataByExtractor(dataPoints, groupExtractor);\n    } else {\n      // Just use one group with all data points\n      groupedData = { all: dataPoints };\n    }\n\n    // Prepare the result data structure\n    const resultData: Record<string, unknown> = {\n      xAxis,\n      yAxis,\n      groupBy,\n      timeRange,\n      aggregation,\n      groups: {},\n    };\n\n    // Process each group\n    for (const [group, points] of Object.entries(groupedData)) {\n      // Sort by the x-axis property (usually date)\n      const sortedPoints = this.sortDataPointsByExtractor(points, xExtractor);\n\n      // Extract x and y values using optimized extractors\n      const values = sortedPoints\n        .map(point => {\n          // Extract the x and y values using optimized extractors\n          const x = xExtractor(point);\n          const y = yExtractor(point);\n\n          // Only include points with valid x and y values\n          if (x !== undefined && y !== undefined && typeof y === 'number') {\n            return { x, y };\n          }\n\n          return null;\n        })\n        .filter(Boolean) as Array<{ x: unknown; y: number }>;\n\n      // Apply aggregation if specified\n      let aggregatedValues = values;\n      if (aggregation) {\n        aggregatedValues = this.aggregateValues(values, aggregation);\n      }\n\n      // Calculate trend line with optimized algorithm\n      const trendLine = this.calculateTrendLineOptimized(aggregatedValues);\n\n      // Add group data to result\n      (resultData.groups as Record<string, unknown>)[group] = {\n        values: aggregatedValues,\n        trendLine,\n      };\n    }\n\n    // Generate insights\n    const insights = this.generateTrendInsights(resultData);\n\n    // Create the result\n    const result: AnalysisResult = {\n      id: uuidv4(),\n      analysisConfigId: config.id,\n      status: 'completed',\n      startTime,\n      endTime: Date.now(),\n      data: resultData,\n      summary: this.generateTrendSummary(resultData),\n      insights,\n    };\n\n    return result;\n  }\n\n  /**\n   * Optimize property access with compiled accessor functions\n   */\n  private getPropertyExtractor(path: string): PropertyExtractor {\n    // Check if we already have a cached extractor\n    if (this.propertyExtractorCache.has(path)) {\n      return this.propertyExtractorCache.get(path)!;\n    }\n\n    // Parse the property path\n    const parts = path.split('.');\n\n    // Create an optimized extractor function\n    const extractor = (obj: DataPoint): unknown => {\n      if (parts.length === 1) {\n        // Direct property access (most common case)\n        const property = parts[0];\n        if (property in obj) {\n          return obj[property as keyof DataPoint];\n        } else if (property in obj.properties) {\n          return obj.properties[property];\n        } else if (obj.metadata && property in obj.metadata) {\n          return obj.metadata[property];\n        }\n        return undefined;\n      } else {\n        // Handle nested properties\n        let current: any = obj;\n        for (let i = 0; i < parts.length; i++) {\n          if (current === null || current === undefined) {\n            return undefined;\n          }\n\n          // Check in standard properties\n          if (current[parts[i]] !== undefined) {\n            current = current[parts[i]];\n            continue;\n          }\n\n          // Check in DataPoint's properties or metadata\n          if (i === 0) {\n            if (parts[i] === 'properties' && obj.properties) {\n              current = obj.properties;\n            } else if (parts[i] === 'metadata' && obj.metadata) {\n              current = obj.metadata;\n            } else {\n              return undefined;\n            }\n          } else {\n            return undefined;\n          }\n        }\n        return current;\n      }\n    };\n\n    // Cache the extractor for future use\n    this.propertyExtractorCache.set(path, extractor);\n    return extractor;\n  }\n\n  /**\n   * Sort data points using the optimized property extractor\n   */\n  private sortDataPointsByExtractor(\n    dataPoints: DataPoint[],\n    extractor: PropertyExtractor\n  ): DataPoint[] {\n    return [...dataPoints].sort((a, b) => {\n      const aValue = extractor(a);\n      const bValue = extractor(b);\n\n      if (aValue === undefined) return 1;\n      if (bValue === undefined) return -1;\n\n      if (typeof aValue === 'number' && typeof bValue === 'number') {\n        return aValue - bValue;\n      }\n\n      return String(aValue).localeCompare(String(bValue));\n    });\n  }\n\n  /**\n   * Group data points using the optimized property extractor\n   */\n  private groupDataByExtractor(\n    dataPoints: DataPoint[],\n    extractor: PropertyExtractor\n  ): Record<string, DataPoint[]> {\n    const result: Record<string, DataPoint[]> = {};\n\n    for (const point of dataPoints) {\n      const value = extractor(point);\n\n      if (value !== undefined) {\n        const key = String(value);\n        if (!result[key]) {\n          result[key] = [];\n        }\n        result[key].push(point);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Optimized trend line calculation using single-pass algorithm\n   */\n  private calculateTrendLineOptimized(values: Array<{ x: unknown; y: number }>): {\n    slope: number;\n    intercept: number;\n  } {\n    if (values.length < 2) {\n      return { slope: 0, intercept: 0 };\n    }\n\n    // Convert x values to numbers for calculation\n    const points = values\n      .map(v => {\n        const xNum =\n          typeof v.x === 'number'\n            ? v.x\n            : v.x instanceof Date\n              ? v.x.getTime()\n              : parseFloat(String(v.x));\n\n        return isNaN(xNum) ? null : { x: xNum, y: v.y };\n      })\n      .filter(Boolean) as { x: number; y: number }[];\n\n    if (points.length < 2) {\n      return { slope: 0, intercept: 0 };\n    }\n\n    // Use optimized single-pass algorithm for calculating linear regression\n    let sumX = 0;\n    let sumY = 0;\n    let sumXY = 0;\n    let sumX2 = 0;\n    const n = points.length;\n\n    for (const point of points) {\n      sumX += point.x;\n      sumY += point.y;\n      sumXY += point.x * point.y;\n      sumX2 += point.x * point.x;\n    }\n\n    const denominator = n * sumX2 - sumX * sumX;\n\n    if (Math.abs(denominator) < 1e-10) {\n      return { slope: 0, intercept: sumY / n };\n    }\n\n    const slope = (n * sumXY - sumX * sumY) / denominator;\n    const intercept = (sumY - slope * sumX) / n;\n\n    return { slope, intercept };\n  }\n\n  /**\n   * Analyze correlation between variables with optimized algorithms\n   */\n  private async analyzeCorrelation(\n    config: CorrelationAnalysisConfig,\n    dataset: Dataset,\n    options: AlgorithmOptions\n  ): Promise<AnalysisResult> {\n    const startTime = Date.now();\n\n    // Extract parameters\n    const { variables, method = 'pearson', threshold = 0.5 } = config.parameters;\n\n    // Prepare the result data structure\n    const resultData: Record<string, unknown> = {\n      variables,\n      method,\n      threshold,\n      correlations: [],\n    };\n\n    // Create optimized property extractors for all variables\n    const extractors = variables.map(variable => this.getPropertyExtractor(variable));\n\n    // Pre-extract all values to optimize computation\n    const extractedValues: number[][] = [];\n\n    for (const extractor of extractors) {\n      const values = dataset.dataPoints\n        .map(point => {\n          const value = extractor(point);\n          return typeof value === 'number' ? value : undefined;\n        })\n        .filter((v): v is number => v !== undefined);\n\n      extractedValues.push(values);\n    }\n\n    // Calculate correlation for each pair of variables\n    const promises: Promise<{\n      var1: string;\n      var2: string;\n      coefficient: number;\n      strength: string;\n      sampleSize: number;\n    } | null>[] = [];\n\n    for (let i = 0; i < variables.length; i++) {\n      for (let j = i + 1; j < variables.length; j++) {\n        const var1 = variables[i];\n        const var2 = variables[j];\n\n        const values1 = extractedValues[i];\n        const values2 = extractedValues[j];\n\n        // Find common indices where both variables have values\n        const commonValues: { var1: number; var2: number }[] = [];\n\n        // Optimize by using Set for faster lookups\n        const values1Set = new Set(values1);\n\n        for (let k = 0; k < Math.min(values1.length, values2.length); k++) {\n          if (values1Set.has(values1[k]) && values2[k] !== undefined) {\n            commonValues.push({ var1: values1[k], var2: values2[k] });\n          }\n        }\n\n        // Skip if not enough data points\n        if (commonValues.length < 3) {\n          continue;\n        }\n\n        // Calculate correlation coefficient based on method\n        const promise = (async () => {\n          let coefficient: number;\n\n          const var1Values = commonValues.map(v => v.var1);\n          const var2Values = commonValues.map(v => v.var2);\n\n          switch (method) {\n            case 'pearson':\n              coefficient = this.calculatePearsonCorrelationOptimized(var1Values, var2Values);\n              break;\n            case 'spearman':\n              coefficient = this.calculateSpearmanCorrelationOptimized(var1Values, var2Values);\n              break;\n            case 'kendall':\n              coefficient = this.calculateKendallCorrelationOptimized(var1Values, var2Values);\n              break;\n            default:\n              coefficient = this.calculatePearsonCorrelationOptimized(var1Values, var2Values);\n          }\n\n          // Add to correlations if above threshold\n          if (Math.abs(coefficient) >= threshold) {\n            return {\n              var1,\n              var2,\n              coefficient,\n              strength: this.getCorrelationStrength(coefficient),\n              sampleSize: commonValues.length,\n            };\n          }\n\n          return null;\n        })();\n\n        promises.push(promise);\n      }\n    }\n\n    // Wait for all correlation calculations\n    const correlations = (await Promise.all(promises)).filter(Boolean);\n    resultData.correlations = correlations;\n\n    // Generate insights\n    const insights = this.generateCorrelationInsights(resultData);\n\n    // Create the result\n    const result: AnalysisResult = {\n      id: uuidv4(),\n      analysisConfigId: config.id,\n      status: 'completed',\n      startTime,\n      endTime: Date.now(),\n      data: resultData,\n      summary: this.generateCorrelationSummary(resultData),\n      insights,\n    };\n\n    return result;\n  }\n\n  /**\n   * Optimized Pearson correlation calculation\n   */\n  private calculatePearsonCorrelationOptimized(xValues: number[], yValues: number[]): number {\n    if (xValues.length !== yValues.length || xValues.length === 0) {\n      return 0;\n    }\n\n    // Use memoization for means\n    const xArrayKey = xValues.join(',');\n    const yArrayKey = yValues.join(',');\n\n    // Calculate or retrieve means\n    let xMean = this.memoizedMeans.get(xArrayKey);\n    if (xMean === undefined) {\n      xMean = xValues.reduce((sum, x) => sum + x, 0) / xValues.length;\n      this.memoizedMeans.set(xArrayKey, xMean);\n    }\n\n    let yMean = this.memoizedMeans.get(yArrayKey);\n    if (yMean === undefined) {\n      yMean = yValues.reduce((sum, y) => sum + y, 0) / yValues.length;\n      this.memoizedMeans.set(yArrayKey, yMean);\n    }\n\n    // Calculate correlation with optimized algorithm\n    let numerator = 0;\n    let xDenominator = 0;\n    let yDenominator = 0;\n\n    // Optimize loop by avoiding repeated subtraction operations\n    const xDiffs = new Float64Array(xValues.length);\n    const yDiffs = new Float64Array(yValues.length);\n\n    for (let i = 0; i < xValues.length; i++) {\n      xDiffs[i] = xValues[i] - xMean;\n      yDiffs[i] = yValues[i] - yMean;\n    }\n\n    for (let i = 0; i < xValues.length; i++) {\n      numerator += xDiffs[i] * yDiffs[i];\n      xDenominator += xDiffs[i] * xDiffs[i];\n      yDenominator += yDiffs[i] * yDiffs[i];\n    }\n\n    if (xDenominator === 0 || yDenominator === 0) {\n      return 0;\n    }\n\n    return numerator / Math.sqrt(xDenominator * yDenominator);\n  }\n\n  /**\n   * Optimized Spearman correlation calculation\n   */\n  private calculateSpearmanCorrelationOptimized(xValues: number[], yValues: number[]): number {\n    // Optimized implementation using faster ranking and cached calculations\n    const xRanks = this.rankValuesOptimized(xValues);\n    const yRanks = this.rankValuesOptimized(yValues);\n\n    return this.calculatePearsonCorrelationOptimized(xRanks, yRanks);\n  }\n\n  /**\n   * Optimized Kendall correlation calculation\n   */\n  private calculateKendallCorrelationOptimized(xValues: number[], yValues: number[]): number {\n    if (xValues.length !== yValues.length || xValues.length < 2) {\n      return 0;\n    }\n\n    const n = xValues.length;\n    let concordant = 0;\n    let discordant = 0;\n\n    // Optimize by using a more efficient algorithm for Kendall's tau\n    // This implementation has O(n log n) complexity rather than O(n²)\n    const indices = Array.from({ length: n }, (_, i) => i);\n    indices.sort((i, j) => xValues[i] - xValues[j]);\n\n    // Count inversions (equivalent to counting discordant pairs)\n    const yValuesRanked = indices.map(i => yValues[i]);\n    discordant = this.countInversions(yValuesRanked);\n\n    // Calculate total possible pairs\n    const totalPairs = (n * (n - 1)) / 2;\n\n    // Concordant pairs = total pairs - discordant pairs\n    concordant = totalPairs - discordant;\n\n    // Calculate Kendall's tau coefficient\n    return (concordant - discordant) / totalPairs;\n  }\n\n  /**\n   * Count inversions in an array (used for Kendall's tau calculation)\n   * Using an efficient divide-and-conquer algorithm (merge sort based)\n   */\n  private countInversions(arr: number[]): number {\n    if (arr.length <= 1) return 0;\n\n    const mid = Math.floor(arr.length / 2);\n    const left = arr.slice(0, mid);\n    const right = arr.slice(mid);\n\n    // Recursively count inversions in left and right halves\n    let count = this.countInversions(left) + this.countInversions(right);\n\n    // Count inversions during merge\n    let i = 0,\n      j = 0,\n      k = 0;\n    const merged = new Array(arr.length);\n\n    while (i < left.length && j < right.length) {\n      if (left[i] <= right[j]) {\n        merged[k++] = left[i++];\n      } else {\n        // Inversion found - all remaining elements in left are inversions\n        merged[k++] = right[j++];\n        count += left.length - i;\n      }\n    }\n\n    // Copy remaining elements\n    while (i < left.length) merged[k++] = left[i++];\n    while (j < right.length) merged[k++] = right[j++];\n\n    // Copy merged array back to original\n    for (let i = 0; i < merged.length; i++) {\n      arr[i] = merged[i];\n    }\n\n    return count;\n  }\n\n  /**\n   * Optimized rank calculation for correlation methods\n   */\n  private rankValuesOptimized(values: number[]): number[] {\n    const n = values.length;\n    if (n <= 1) return values.slice();\n\n    // Create indexed values\n    const indexedValues = values.map((value, index) => ({ value, index }));\n\n    // Sort by value using a more efficient sort for numeric data\n    indexedValues.sort((a, b) => a.value - b.value);\n\n    // Optimize rank assignment with a single pass and linked structure\n    const ranks = new Float64Array(n);\n\n    let i = 0;\n    while (i < n) {\n      const value = indexedValues[i].value;\n\n      // Find all values equal to the current value\n      let j = i + 1;\n      while (j < n && indexedValues[j].value === value) {\n        j++;\n      }\n\n      // Calculate average rank for tied values\n      const rank = (i + j - 1) / 2 + 1;\n\n      // Assign ranks in a single pass\n      for (let k = i; k < j; k++) {\n        ranks[indexedValues[k].index] = rank;\n      }\n\n      i = j;\n    }\n\n    return Array.from(ranks);\n  }\n\n  /**\n   * Analyze distribution of a variable\n   */\n  private async analyzeDistribution(\n    config: DistributionAnalysisConfig,\n    dataset: Dataset,\n    options: AlgorithmOptions\n  ): Promise<AnalysisResult> {\n    const startTime = Date.now();\n\n    // Extract parameters\n    const { variable, bins = 10, normalize = false } = config.parameters;\n\n    // Extract values for the variable\n    const values = dataset.dataPoints\n      .map(point => {\n        const value = this.getPropertyByPath(point, variable);\n        return typeof value === 'number' ? value : null;\n      })\n      .filter(Boolean) as number[];\n\n    // Calculate distribution\n    const distribution = this.calculateDistribution(values, bins, normalize);\n\n    // Calculate statistics\n    const statistics = this.calculateStatistics(values);\n\n    // Prepare the result data\n    const resultData: Record<string, unknown> = {\n      variable,\n      bins,\n      normalize,\n      distribution,\n      statistics,\n    };\n\n    // Generate insights\n    const insights = this.generateDistributionInsights(resultData);\n\n    // Create the result\n    const result: AnalysisResult = {\n      id: uuidv4(),\n      analysisConfigId: config.id,\n      status: 'completed',\n      startTime,\n      endTime: Date.now(),\n      data: resultData,\n      summary: this.generateDistributionSummary(resultData),\n      insights,\n    };\n\n    return result;\n  }\n\n  /**\n   * Analyze clustering patterns in the dataset using k-means algorithm\n   */\n  private async analyzeClustering(\n    config: ClusteringAnalysisConfig,\n    dataset: Dataset,\n    options: AlgorithmOptions\n  ): Promise<AnalysisResult> {\n    const startTime = Date.now();\n\n    // Extract parameters\n    const {\n      algorithm = 'kmeans',\n      features = [],\n      k = 3,\n      maxIterations = 100,\n      distanceMetric = 'euclidean',\n      normalize = true,\n    } = config.parameters;\n\n    // Validate input parameters\n    if (features.length < 1) {\n      return {\n        id: uuidv4(),\n        analysisConfigId: config.id,\n        status: 'failed',\n        startTime,\n        endTime: Date.now(),\n        data: {},\n        error: 'At least one feature must be specified for clustering analysis',\n      };\n    }\n\n    if (dataset.dataPoints.length < k) {\n      return {\n        id: uuidv4(),\n        analysisConfigId: config.id,\n        status: 'failed',\n        startTime,\n        endTime: Date.now(),\n        data: {},\n        error: `Not enough data points (${dataset.dataPoints.length}) for ${k} clusters`,\n      };\n    }\n\n    // Create extractors for each feature\n    const extractors = features.map(feature => this.getPropertyExtractor(feature));\n\n    // Extract feature vectors from data points\n    const featureVectors: number[][] = [];\n    const validIndices: number[] = [];\n\n    dataset.dataPoints.forEach((point, index) => {\n      const vector: number[] = [];\n      let valid = true;\n\n      // Extract each feature value\n      for (const extractor of extractors) {\n        const value = extractor(point);\n\n        if (typeof value === 'number' && !isNaN(value) && isFinite(value)) {\n          vector.push(value);\n        } else {\n          valid = false;\n          break;\n        }\n      }\n\n      if (valid && vector.length === features.length) {\n        featureVectors.push(vector);\n        validIndices.push(index);\n      }\n    });\n\n    // Not enough valid points for clustering\n    if (featureVectors.length < k) {\n      return {\n        id: uuidv4(),\n        analysisConfigId: config.id,\n        status: 'failed',\n        startTime,\n        endTime: Date.now(),\n        data: {},\n        error: `Not enough valid data points (${featureVectors.length}) for ${k} clusters`,\n      };\n    }\n\n    // Normalize feature vectors if specified\n    const normalizedVectors = options.normalize\n      ? this.normalizeFeatureVectors(featureVectors)\n      : featureVectors;\n\n    // Run k-means clustering algorithm\n    const clusterResult = this.runKMeansClustering(\n      normalizedVectors,\n      k,\n      maxIterations,\n      distanceMetric\n    );\n\n    // Map cluster assignments back to original data points\n    const clusteredPoints = validIndices.map((originalIndex, vectorIndex) => {\n      const clusterIndex = clusterResult.clusters[vectorIndex];\n      const point = dataset.dataPoints[originalIndex];\n      const featureValues = features.map(feature => {\n        const value = this.getPropertyByPath(point, feature);\n        return typeof value === 'number' ? value : null;\n      });\n\n      return {\n        id: point.id,\n        name: point.name,\n        type: point.type,\n        cluster: clusterIndex,\n        features: featureValues,\n        distanceToCentroid: this.calculateDistance(\n          normalizedVectors[vectorIndex],\n          clusterResult.centroids[clusterIndex],\n          distanceMetric\n        ),\n      };\n    });\n\n    // Group points by cluster\n    const clusters: Record<string, any[]> = {};\n    clusteredPoints.forEach(point => {\n      const clusterKey = String(point.cluster);\n      if (!clusters[clusterKey]) {\n        clusters[clusterKey] = [];\n      }\n      clusters[clusterKey].push(point);\n    });\n\n    // Calculate statistics for each cluster\n    const clusterStats = Object.entries(clusters).map(([clusterKey, points]) => {\n      const clusterIndex = parseInt(clusterKey, 10);\n      const centroid = clusterResult.centroids[clusterIndex];\n\n      // Calculate statistics for each feature within this cluster\n      const featureStats = features.map((feature, featureIndex) => {\n        const values = points\n          .map(p => p.features[featureIndex])\n          .filter((v): v is number => v !== null);\n\n        return {\n          feature,\n          mean: values.length > 0 ? values.reduce((sum, v) => sum + v, 0) / values.length : 0,\n          min: values.length > 0 ? Math.min(...values) : 0,\n          max: values.length > 0 ? Math.max(...values) : 0,\n          count: values.length,\n        };\n      });\n\n      return {\n        cluster: clusterIndex,\n        size: points.length,\n        percentage: (points.length / clusteredPoints.length) * 100,\n        centroid,\n        featureStats,\n        pointIds: points.map(p => p.id),\n      };\n    });\n\n    // Prepare result data\n    const resultData: Record<string, unknown> = {\n      algorithm,\n      features,\n      k,\n      distanceMetric,\n      inertia: clusterResult.inertia,\n      clusters: clusterStats,\n      normalized: options.normalize,\n    };\n\n    // Generate insights and summary\n    const insights = this.generateClusteringInsights(resultData);\n    const summary = this.generateClusteringSummary(resultData);\n\n    // Create the result\n    const result: AnalysisResult = {\n      id: uuidv4(),\n      analysisConfigId: config.id,\n      status: 'completed',\n      startTime,\n      endTime: Date.now(),\n      data: resultData,\n      summary,\n      insights,\n    };\n\n    return result;\n  }\n\n  /**\n   * Normalize feature vectors using z-score normalization\n   */\n  private normalizeFeatureVectors(vectors: number[][]): number[][] {\n    if (vectors.length === 0) return [];\n\n    const dimensions = vectors[0].length;\n    const means = new Array(dimensions).fill(0);\n    const stdDevs = new Array(dimensions).fill(0);\n\n    // Calculate means\n    for (const vector of vectors) {\n      for (let d = 0; d < dimensions; d++) {\n        means[d] += vector[d];\n      }\n    }\n\n    for (let d = 0; d < dimensions; d++) {\n      means[d] /= vectors.length;\n    }\n\n    // Calculate standard deviations\n    for (const vector of vectors) {\n      for (let d = 0; d < dimensions; d++) {\n        stdDevs[d] += Math.pow(vector[d] - means[d], 2);\n      }\n    }\n\n    for (let d = 0; d < dimensions; d++) {\n      stdDevs[d] = Math.sqrt(stdDevs[d] / vectors.length);\n    }\n\n    // Apply z-score normalization\n    return vectors.map(vector =>\n      vector.map((value, d) => (stdDevs[d] > 0 ? (value - means[d]) / stdDevs[d] : 0))\n    );\n  }\n\n  /**\n   * Run k-means clustering algorithm on feature vectors\n   */\n  private runKMeansClustering(\n    vectors: number[][],\n    k: number,\n    maxIterations: number,\n    distanceMetric: string\n  ): {\n    clusters: number[];\n    centroids: number[][];\n    inertia: number;\n  } {\n    const n = vectors.length;\n    const dimensions = vectors[0].length;\n\n    // Initialize centroids using k-means++ method\n    const centroids = this.initializeKMeansPlusPlusCentroids(vectors, k, distanceMetric);\n\n    // Initialize cluster assignments\n    const clusters = new Array(n).fill(0);\n    let prevClusters = new Array(n).fill(-1);\n    let iteration = 0;\n\n    // Repeat until convergence or max iterations reached\n    while (!this.arraysEqual(clusters, prevClusters) && iteration < maxIterations) {\n      // Store previous cluster assignments\n      prevClusters = [...clusters];\n\n      // Assign each point to the nearest centroid\n      for (let i = 0; i < n; i++) {\n        const vector = vectors[i];\n        let minDistance = Infinity;\n        let nearestCluster = 0;\n\n        for (let j = 0; j < k; j++) {\n          const distance = this.calculateDistance(vector, centroids[j], distanceMetric);\n          if (distance < minDistance) {\n            minDistance = distance;\n            nearestCluster = j;\n          }\n        }\n\n        clusters[i] = nearestCluster;\n      }\n\n      // Update centroids based on new cluster assignments\n      const newCentroids: number[][] = Array(k)\n        .fill(0)\n        .map(() => Array(dimensions).fill(0));\n      const counts = Array(k).fill(0);\n\n      for (let i = 0; i < n; i++) {\n        const cluster = clusters[i];\n        counts[cluster]++;\n\n        for (let d = 0; d < dimensions; d++) {\n          newCentroids[cluster][d] += vectors[i][d];\n        }\n      }\n\n      // Calculate new centroid as average of points in cluster\n      for (let j = 0; j < k; j++) {\n        // Handle empty clusters by reinitializing with a random point\n        if (counts[j] === 0) {\n          const randomIndex = Math.floor(Math.random() * n);\n          newCentroids[j] = [...vectors[randomIndex]];\n        } else {\n          for (let d = 0; d < dimensions; d++) {\n            newCentroids[j][d] /= counts[j];\n          }\n        }\n      }\n\n      centroids.splice(0, centroids.length, ...newCentroids);\n      iteration++;\n    }\n\n    // Calculate inertia (sum of squared distances to nearest centroid)\n    const inertia = vectors.reduce((sum, vector, i) => {\n      const centroid = centroids[clusters[i]];\n      const distance = this.calculateDistance(vector, centroid, distanceMetric);\n      return sum + distance * distance;\n    }, 0);\n\n    return { clusters, centroids, inertia };\n  }\n\n  /**\n   * Initialize k-means centroids using k-means++ algorithm\n   * This gives better initial centroids than random selection\n   */\n  private initializeKMeansPlusPlusCentroids(\n    vectors: number[][],\n    k: number,\n    distanceMetric: string\n  ): number[][] {\n    const n = vectors.length;\n    const centroids: number[][] = [];\n\n    // Choose first centroid randomly\n    const firstIndex = Math.floor(Math.random() * n);\n    centroids.push([...vectors[firstIndex]]);\n\n    // Choose remaining centroids using weighted probabilities\n    for (let i = 1; i < k; i++) {\n      // Calculate minimum distance from each point to any existing centroid\n      const distances = vectors.map(vector => {\n        const minDistance = centroids.reduce((min, centroid) => {\n          const distance = this.calculateDistance(vector, centroid, distanceMetric);\n          return Math.min(min, distance);\n        }, Infinity);\n        return minDistance * minDistance; // Square the distance for weighted probability\n      });\n\n      // Calculate sum of squared distances\n      const distanceSum = distances.reduce((sum, distance) => sum + distance, 0);\n\n      // Choose next centroid with probability proportional to squared distance\n      let random = Math.random() * distanceSum;\n      let index = 0;\n\n      while (index < n && random > 0) {\n        random -= distances[index];\n        index++;\n      }\n\n      // Adjust index since we incremented one extra time\n      index = Math.max(0, index - 1);\n\n      centroids.push([...vectors[index]]);\n    }\n\n    return centroids;\n  }\n\n  /**\n   * Calculate distance between two vectors\n   */\n  private calculateDistance(a: number[], b: number[], metric: string = 'euclidean'): number {\n    switch (metric) {\n      case 'euclidean':\n        return Math.sqrt(a.reduce((sum, val, i) => sum + Math.pow(val - b[i], 2), 0));\n\n      case 'manhattan':\n        return a.reduce((sum, val, i) => sum + Math.abs(val - b[i]), 0);\n\n        const dotProduct = a.reduce((sum, val, i) => sum + val * b[i], 0);\n        const magnitudeA = Math.sqrt(a.reduce((sum, val) => sum + val * val, 0));\n        const magnitudeB = Math.sqrt(b.reduce((sum, val) => sum + val * val, 0));\n\n        if (magnitudeA === 0 || magnitudeB === 0) return 1; // Maximum distance\n        return 1 - dotProduct / (magnitudeA * magnitudeB);\n\n      default:\n        return Math.sqrt(a.reduce((sum, val, i) => sum + Math.pow(val - b[i], 2), 0));\n    }\n  }\n\n  /**\n   * Check if two arrays are equal\n   */\n  private arraysEqual(a: unknown[], b: unknown[]): boolean {\n    if (a.length !== b.length) return false;\n\n    for (let i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Generate insights about clustering results\n   */\n  private generateClusteringInsights(data: Record<string, unknown>): string[] {\n    const insights: string[] = [];\n    const clusters = data.clusters as any[];\n    const algorithm = data.algorithm as string;\n    const k = data.k as number;\n\n    // Overall clustering quality\n    if (clusters.length > 0) {\n      // Check for imbalanced clusters\n      const clusterSizes = clusters.map(c => c.size);\n      const maxSize = Math.max(...clusterSizes);\n      const minSize = Math.min(...clusterSizes);\n      const sizeRatio = maxSize / minSize;\n\n      if (sizeRatio > 5) {\n        insights.push(\n          `The clusters are highly imbalanced. The largest cluster is ${sizeRatio.toFixed(1)}x larger than the smallest.`\n        );\n      } else if (sizeRatio > 2) {\n        insights.push(\n          `The clusters show some size variation. The largest cluster is ${sizeRatio.toFixed(1)}x larger than the smallest.`\n        );\n      } else {\n        insights.push(`The clusters are relatively balanced in size.`);\n      }\n\n      // Add algorithm-specific insights\n      if (algorithm === 'kmeans') {\n        insights.push(\n          `K-means clustering identified ${k} clusters based on the specified features.`\n        );\n\n        // Check inertia\n        const inertia = data.inertia as number;\n        if (inertia !== undefined) {\n          insights.push(\n            `The clustering has an inertia (sum of squared distances) of ${inertia.toFixed(2)}.`\n          );\n        }\n      }\n\n      // Add feature-specific insights\n      clusters.forEach((cluster, i) => {\n        // Find distinctive features for this cluster\n        const distinctiveFeatures = cluster.featureStats\n          .filter((stat: unknown) => stat.mean > 0.5 || stat.mean < -0.5)\n          .sort((a: unknown, b: unknown) => Math.abs(b.mean) - Math.abs(a.mean));\n\n        if (distinctiveFeatures.length > 0) {\n          const topFeature = distinctiveFeatures[0];\n          const featureType = topFeature.mean > 0 ? 'high' : 'low';\n\n          insights.push(\n            `Cluster ${cluster.cluster} is characterized by ${featureType} values of ${topFeature.feature}.`\n          );\n        }\n      });\n    }\n\n    return insights;\n  }\n\n  /**\n   * Generate summary of clustering results\n   */\n  private generateClusteringSummary(data: Record<string, unknown>): string {\n    const algorithm = data.algorithm as string;\n    const k = data.k as number;\n    const features = data.features as string[];\n\n    let summary = `Clustering analysis using ${algorithm} algorithm identified ${k} clusters`;\n\n    if (features && features.length > 0) {\n      summary += ` based on the following features: ${features.join(', ')}.`;\n    } else {\n      summary += '.';\n    }\n\n    return summary;\n  }\n\n  /**\n   * Helper method to sort data points by a property\n   */\n  private sortDataPoints(dataPoints: DataPoint[], property: string): DataPoint[] {\n    return [...dataPoints].sort((a, b) => {\n      const aValue = this.getPropertyByPath(a, property);\n      const bValue = this.getPropertyByPath(b, property);\n\n      if (aValue === undefined) return 1;\n      if (bValue === undefined) return -1;\n\n      if (typeof aValue === 'number' && typeof bValue === 'number') {\n        return aValue - bValue;\n      }\n\n      return String(aValue).localeCompare(String(bValue));\n    });\n  }\n\n  /**\n   * Helper method to group data points by a property\n   */\n  private groupDataByProperty(\n    dataPoints: DataPoint[],\n    property: string\n  ): Record<string, DataPoint[]> {\n    const groups: Record<string, DataPoint[]> = {};\n\n    for (const point of dataPoints) {\n      const value = this.getPropertyByPath(point, property);\n      if (value === undefined) continue;\n\n      const groupKey = String(value);\n      if (!groups[groupKey]) {\n        groups[groupKey] = [];\n      }\n\n      groups[groupKey].push(point);\n    }\n\n    return groups;\n  }\n\n  /**\n   * Helper method to get a property value using a dot-notation path\n   */\n  private getPropertyByPath(obj: Record<string, unknown>, path: string): unknown {\n    const parts = path.split('.');\n    let value: unknown = obj;\n\n    for (const part of parts) {\n      if (value === undefined || value === null) {\n        return undefined;\n      }\n\n      value = (value as Record<string, unknown>)[part];\n    }\n\n    return value;\n  }\n\n  /**\n   * Helper method to aggregate values\n   */\n  private aggregateValues(\n    values: Array<{ x: unknown; y: number }>,\n    aggregation: 'sum' | 'average' | 'min' | 'max' | 'count'\n  ): Array<{ x: unknown; y: number }> {\n    // Group by x value\n    const groups = new Map<unknown, number[]>();\n\n    for (const { x, y } of values) {\n      if (!groups.has(x)) {\n        groups.set(x, []);\n      }\n\n      groups.get(x)!.push(y);\n    }\n\n    // Aggregate each group\n    const result: Array<{ x: unknown; y: number }> = [];\n\n    for (const [x, yValues] of groups.entries()) {\n      let aggregatedValue: number;\n\n      switch (aggregation) {\n        case 'sum':\n          aggregatedValue = yValues.reduce((sum, value) => sum + value, 0);\n          break;\n        case 'average':\n          aggregatedValue = yValues.reduce((sum, value) => sum + value, 0) / yValues.length;\n          break;\n        case 'min':\n          aggregatedValue = Math.min(...yValues);\n          break;\n        case 'max':\n          aggregatedValue = Math.max(...yValues);\n          break;\n        case 'count':\n          aggregatedValue = yValues.length;\n          break;\n        default:\n          aggregatedValue = yValues.reduce((sum, value) => sum + value, 0);\n      }\n\n      result.push({ x, y: aggregatedValue });\n    }\n\n    // Sort by x value\n    return result.sort((a, b) => {\n      if (typeof a.x === 'number' && typeof b.x === 'number') {\n        return a.x - b.x;\n      }\n\n      return String(a.x).localeCompare(String(b.x));\n    });\n  }\n\n  /**\n   * Calculate Pearson correlation coefficient between two sets of values\n   */\n  private calculatePearsonCorrelation(xValues: number[], yValues: number[]): number {\n    if (xValues.length !== yValues.length || xValues.length === 0) {\n      return 0;\n    }\n\n    // Calculate means\n    const xMean = xValues.reduce((sum, x) => sum + x, 0) / xValues.length;\n    const yMean = yValues.reduce((sum, y) => sum + y, 0) / yValues.length;\n\n    // Calculate terms for correlation\n    let numerator = 0;\n    let xDenominator = 0;\n    let yDenominator = 0;\n\n    for (let i = 0; i < xValues.length; i++) {\n      const xDiff = xValues[i] - xMean;\n      const yDiff = yValues[i] - yMean;\n\n      numerator += xDiff * yDiff;\n      xDenominator += xDiff * xDiff;\n      yDenominator += yDiff * yDiff;\n    }\n\n    if (xDenominator === 0 || yDenominator === 0) {\n      return 0;\n    }\n\n    return numerator / Math.sqrt(xDenominator * yDenominator);\n  }\n\n  /**\n   * Calculate Spearman correlation coefficient (placeholder implementation)\n   */\n  private calculateSpearmanCorrelation(xValues: number[], yValues: number[]): number {\n    // Simplified implementation - in a real system this would be more complex\n    return this.calculatePearsonCorrelation(this.rankValues(xValues), this.rankValues(yValues));\n  }\n\n  /**\n   * Calculate Kendall correlation coefficient (placeholder implementation)\n   */\n  private calculateKendallCorrelation(xValues: number[], yValues: number[]): number {\n    // Simplified placeholder - in a real system this would be properly implemented\n    return (\n      this.calculatePearsonCorrelation(this.rankValues(xValues), this.rankValues(yValues)) * 0.9\n    ); // Adjusting factor for demonstration\n  }\n\n  /**\n   * Convert values to ranks for rank-based correlation methods\n   */\n  private rankValues(values: number[]): number[] {\n    // Create indexed values\n    const indexedValues = values.map((value, index) => ({ value, index }));\n\n    // Sort by value\n    indexedValues.sort((a, b) => a.value - b.value);\n\n    // Assign ranks (with ties handled by averaging)\n    const ranks = new Array(values.length).fill(0);\n\n    let i = 0;\n    while (i < indexedValues.length) {\n      const value = indexedValues[i].value;\n\n      // Find all values equal to the current value\n      let j = i + 1;\n      while (j < indexedValues.length && indexedValues[j].value === value) {\n        j++;\n      }\n\n      // Assign average rank to all tied values\n      const rank = (i + j - 1) / 2 + 1;\n      for (let k = i; k < j; k++) {\n        ranks[indexedValues[k].index] = rank;\n      }\n\n      i = j;\n    }\n\n    return ranks;\n  }\n\n  /**\n   * Calculate linear trend line\n   */\n  private calculateTrendLine(values: Array<{ x: unknown; y: number }>): {\n    slope: number;\n    intercept: number;\n  } {\n    if (values.length < 2) {\n      return { slope: 0, intercept: 0 };\n    }\n\n    // Convert x values to numbers (assume date values or indices if not numbers)\n    const xyValues = values.map((value, index) => ({\n      x: typeof value.x === 'number' ? value.x : index,\n      y: value.y,\n    }));\n\n    // Calculate means\n    const xMean = xyValues.reduce((sum, { x }) => sum + (x as number), 0) / xyValues.length;\n    const yMean = xyValues.reduce((sum, { y }) => sum + y, 0) / xyValues.length;\n\n    // Calculate slope and intercept using least squares method\n    let numerator = 0;\n    let denominator = 0;\n\n    for (const { x, y } of xyValues) {\n      const xDiff = (x as number) - xMean;\n      numerator += xDiff * (y - yMean);\n      denominator += xDiff * xDiff;\n    }\n\n    if (denominator === 0) {\n      return { slope: 0, intercept: yMean };\n    }\n\n    const slope = numerator / denominator;\n    const intercept = yMean - slope * xMean;\n\n    return { slope, intercept };\n  }\n\n  /**\n   * Calculate distribution\n   */\n  private calculateDistribution(\n    values: number[],\n    bins: number,\n    normalize: boolean\n  ): Array<{\n    binStart: number;\n    binEnd: number;\n    count: number;\n    normalizedCount?: number;\n  }> {\n    if (values.length === 0) {\n      return [];\n    }\n\n    // Calculate range\n    const min = Math.min(...values);\n    const max = Math.max(...values);\n    const range = max - min;\n\n    // Handle special case where all values are the same\n    if (range === 0) {\n      return [\n        {\n          binStart: min,\n          binEnd: max,\n          count: values.length,\n          normalizedCount: normalize ? 1 : undefined,\n        },\n      ];\n    }\n\n    // Calculate bin width\n    const binWidth = range / bins;\n\n    // Initialize bins\n    const distribution = Array.from({ length: bins }, (_, i) => {\n      const binStart = min + i * binWidth;\n      const binEnd = binStart + binWidth;\n\n      return {\n        binStart,\n        binEnd,\n        count: 0,\n        normalizedCount: undefined,\n      };\n    });\n\n    // Count values in each bin\n    for (const value of values) {\n      const binIndex = Math.min(\n        Math.floor((value - min) / binWidth),\n        bins - 1 // Handle edge case where value === max\n      );\n\n      distribution[binIndex].count++;\n    }\n\n    // Normalize counts if requested\n    if (normalize) {\n      const maxCount = Math.max(...distribution.map(bin => bin.count));\n      for (const bin of distribution) {\n        bin.normalizedCount = bin.count / (maxCount || 1);\n      }\n    }\n\n    return distribution;\n  }\n\n  /**\n   * Calculate statistics for a set of values\n   */\n  private calculateStatistics(values: number[]): Record<string, number> {\n    if (values.length === 0) {\n      return {\n        count: 0,\n        min: 0,\n        max: 0,\n        mean: 0,\n        median: 0,\n        standardDeviation: 0,\n        variance: 0,\n      };\n    }\n\n    // Sort values for median and quartiles\n    const sortedValues = [...values].sort((a, b) => a - b);\n\n    // Calculate basic statistics\n    const count = values.length;\n    const min = sortedValues[0];\n    const max = sortedValues[count - 1];\n    const sum = values.reduce((sum, value) => sum + value, 0);\n    const mean = sum / count;\n\n    // Calculate median\n    const midIndex = Math.floor(count / 2);\n    const median =\n      count % 2 === 0\n        ? (sortedValues[midIndex - 1] + sortedValues[midIndex]) / 2\n        : sortedValues[midIndex];\n\n    // Calculate variance and standard deviation\n    const squaredDiffs = values.map(value => Math.pow(value - mean, 2));\n    const variance = squaredDiffs.reduce((sum, value) => sum + value, 0) / count;\n    const standardDeviation = Math.sqrt(variance);\n\n    // Calculate quartiles\n    const q1Index = Math.floor(count / 4);\n    const q3Index = Math.floor((3 * count) / 4);\n    const q1 = sortedValues[q1Index];\n    const q3 = sortedValues[q3Index];\n    const interquartileRange = q3 - q1;\n\n    return {\n      count,\n      min,\n      max,\n      mean,\n      median,\n      standardDeviation,\n      variance,\n      q1,\n      q3,\n      interquartileRange,\n      range: max - min,\n    };\n  }\n\n  /**\n   * Generate insights for trend analysis\n   */\n  private generateTrendInsights(data: Record<string, unknown>): string[] {\n    const insights: string[] = [];\n    const groups = data.groups as Record<\n      string,\n      { values: unknown[]; trendLine: { slope: number; intercept: number } }\n    >;\n\n    // Add insights for each group\n    for (const [group, groupData] of Object.entries(groups)) {\n      const { values, trendLine } = groupData;\n\n      if (values.length === 0) continue;\n\n      // Add insight about trend direction\n      if (Math.abs(trendLine.slope) < 0.001) {\n        insights.push(`The ${group} group shows a stable trend with minimal change.`);\n      } else if (trendLine.slope > 0) {\n        insights.push(\n          `The ${group} group shows an increasing trend with a slope of ${trendLine.slope.toFixed(3)}.`\n        );\n      } else {\n        insights.push(\n          `The ${group} group shows a decreasing trend with a slope of ${trendLine.slope.toFixed(3)}.`\n        );\n      }\n\n      // Add insight about data points\n      insights.push(`Analysis of ${group} is based on ${values.length} data points.`);\n    }\n\n    return insights;\n  }\n\n  /**\n   * Generate a summary for trend analysis\n   */\n  private generateTrendSummary(data: Record<string, unknown>): string {\n    const groups = data.groups as Record<\n      string,\n      { values: unknown[]; trendLine: { slope: number; intercept: number } }\n    >;\n    const groupCount = Object.keys(groups).length;\n\n    if (groupCount === 0) {\n      return 'No valid data found for trend analysis.';\n    }\n\n    if (groupCount === 1) {\n      const [group, groupData] = Object.entries(groups)[0];\n      const { trendLine } = groupData;\n\n      if (Math.abs(trendLine.slope) < 0.001) {\n        return `Analysis shows a stable trend for ${group} with minimal change over time.`;\n      } else if (trendLine.slope > 0) {\n        return `Analysis shows an increasing trend for ${group} over time.`;\n      } else {\n        return `Analysis shows a decreasing trend for ${group} over time.`;\n      }\n    }\n\n    return `Analysis of ${groupCount} groups shows varying trends over time.`;\n  }\n\n  /**\n   * Generate insights for correlation analysis\n   */\n  private generateCorrelationInsights(data: Record<string, unknown>): string[] {\n    const insights: string[] = [];\n    const correlations = data.correlations as Array<{\n      variables: string[];\n      coefficient: number;\n      strength: string;\n      sampleSize: number;\n    }>;\n\n    if (correlations.length === 0) {\n      insights.push('No significant correlations were found between the analyzed variables.');\n      return insights;\n    }\n\n    // Sort correlations by absolute coefficient value\n    correlations.sort((a, b) => Math.abs(b.coefficient) - Math.abs(a.coefficient));\n\n    // Add insight for strongest correlation\n    const strongest = correlations[0];\n    insights.push(\n      `The strongest correlation is between \"${strongest.variables[0]}\" and \"${strongest.variables[1]}\" with a ${strongest.strength} coefficient of ${strongest.coefficient.toFixed(3)}.`\n    );\n\n    // Add insights for positive and negative correlations\n    const positiveCorrelations = correlations.filter(c => c.coefficient > 0);\n    const negativeCorrelations = correlations.filter(c => c.coefficient < 0);\n\n    if (positiveCorrelations.length > 0) {\n      insights.push(\n        `Found ${positiveCorrelations.length} positive correlations among the variables.`\n      );\n    }\n\n    if (negativeCorrelations.length > 0) {\n      insights.push(\n        `Found ${negativeCorrelations.length} negative correlations among the variables.`\n      );\n    }\n\n    return insights;\n  }\n\n  /**\n   * Generate a summary for correlation analysis\n   */\n  private generateCorrelationSummary(data: Record<string, unknown>): string {\n    const correlations = data.correlations as Array<{\n      variables: string[];\n      coefficient: number;\n      strength: string;\n      sampleSize: number;\n    }>;\n\n    if (correlations.length === 0) {\n      return 'No significant correlations were found between the analyzed variables.';\n    }\n\n    return `Found ${correlations.length} significant correlations among the analyzed variables.`;\n  }\n\n  /**\n   * Generate insights for distribution analysis\n   */\n  private generateDistributionInsights(data: Record<string, unknown>): string[] {\n    const insights: string[] = [];\n    const statistics = data.statistics as Record<string, number>;\n\n    if (!statistics) {\n      return ['No valid statistics found for distribution analysis.'];\n    }\n\n    // Add insight about central tendency\n    insights.push(\n      `The mean value is ${statistics.mean.toFixed(2)} and the median is ${statistics.median.toFixed(2)}.`\n    );\n\n    // Add insight about dispersion\n    insights.push(\n      `The data has a standard deviation of ${statistics.standardDeviation.toFixed(2)} and a range of ${statistics.range.toFixed(2)}.`\n    );\n\n    // Add insight about distribution shape\n    const skewness = (statistics.mean - statistics.median) / statistics.standardDeviation;\n    if (Math.abs(skewness) < 0.1) {\n      insights.push('The distribution appears to be approximately symmetric.');\n    } else if (skewness > 0) {\n      insights.push('The distribution shows a positive skew (tail extends to the right).');\n    } else {\n      insights.push('The distribution shows a negative skew (tail extends to the left).');\n    }\n\n    return insights;\n  }\n\n  /**\n   * Generate a summary for distribution analysis\n   */\n  private generateDistributionSummary(data: Record<string, unknown>): string {\n    const statistics = data.statistics as Record<string, number>;\n\n    if (!statistics) {\n      return 'No valid statistics found for distribution analysis.';\n    }\n\n    return `Distribution analysis of ${data.variable} with mean=${statistics.mean.toFixed(2)} and SD=${statistics.standardDeviation.toFixed(2)}.`;\n  }\n\n  /**\n   * Get correlation strength description based on coefficient\n   */\n  private getCorrelationStrength(coefficient: number): string {\n    const absoluteCoefficient = Math.abs(coefficient);\n\n    if (absoluteCoefficient < 0.3) {\n      return 'weak';\n    } else if (absoluteCoefficient < 0.7) {\n      return 'moderate';\n    } else {\n      return 'strong';\n    }\n  }\n\n  /**\n   * Analyze data to generate predictions using various models\n   */\n  private async analyzePrediction(\n    config: PredictionAnalysisConfig,\n    dataset: Dataset,\n    options: AlgorithmOptions\n  ): Promise<AnalysisResult> {\n    const startTime = Date.now();\n\n    // Extract parameters\n    const {\n      targetVariable,\n      features = [],\n      predictionHorizon = 1,\n      model = 'linear',\n      testSplit = 0.2,\n      epochs = 100, // For neural network\n    } = config.parameters;\n\n    // Validate input parameters\n    if (!targetVariable) {\n      return {\n        id: uuidv4(),\n        analysisConfigId: config.id,\n        status: 'failed',\n        startTime,\n        endTime: Date.now(),\n        data: {},\n        error: 'Target variable must be specified for prediction analysis',\n      };\n    }\n\n    if (dataset.dataPoints.length < 10) {\n      return {\n        id: uuidv4(),\n        analysisConfigId: config.id,\n        status: 'failed',\n        startTime,\n        endTime: Date.now(),\n        data: {},\n        error: 'Insufficient data points for prediction analysis (minimum 10 required)',\n      };\n    }\n\n    // Create extractors for each feature and the target variable\n    const featureExtractors = features.map(feature => this.getPropertyExtractor(feature));\n    const targetExtractor = this.getPropertyExtractor(targetVariable);\n\n    // Extract feature vectors and target values\n    const dataPoints: Array<{\n      features: number[];\n      target: number;\n      date?: number;\n      original: DataPoint;\n    }> = [];\n\n    dataset.dataPoints.forEach(point => {\n      // Extract feature values\n      const featureValues: number[] = [];\n      let allFeaturesValid = true;\n\n      // Extract each feature value\n      for (const extractor of featureExtractors) {\n        const value = extractor(point);\n\n        if (typeof value === 'number' && !isNaN(value) && isFinite(value)) {\n          featureValues.push(value);\n        } else {\n          allFeaturesValid = false;\n          break;\n        }\n      }\n\n      // Extract target value\n      const targetValue = targetExtractor(point);\n\n      if (\n        allFeaturesValid &&\n        typeof targetValue === 'number' &&\n        !isNaN(targetValue) &&\n        isFinite(targetValue)\n      ) {\n        dataPoints.push({\n          features: featureValues,\n          target: targetValue,\n          date: point.date, // For time series forecasting\n          original: point,\n        });\n      }\n    });\n\n    // Sort data by date if available (for time series)\n    if (dataPoints.length > 0 && dataPoints[0].date !== undefined) {\n      dataPoints.sort((a, b) => (a.date || 0) - (b.date || 0));\n    }\n\n    // Split data into training and testing sets\n    const splitIndex = Math.floor(dataPoints.length * (1 - testSplit));\n    const trainingData = dataPoints.slice(0, splitIndex);\n    const testingData = dataPoints.slice(splitIndex);\n\n    // Train the appropriate prediction model\n    let modelResult: {\n      predictions: Array<{\n        features: number[];\n        actual: number;\n        predicted: number;\n        error?: number;\n      }>;\n      forecast: Array<{\n        features: number[];\n        predicted: number;\n        confidence?: [number, number]; // Lower and upper bounds\n      }>;\n      metrics: {\n        mse: number;\n        rmse: number;\n        mae: number;\n        r2?: number;\n      };\n      modelDetails: Record<string, unknown>;\n    };\n\n    switch (model) {\n      case 'linear':\n        modelResult = this.runLinearRegression(\n          trainingData,\n          testingData,\n          features,\n          predictionHorizon\n        );\n        break;\n      case 'neuralNetwork':\n        modelResult = await this.runNeuralNetwork(\n          trainingData,\n          testingData,\n          features,\n          predictionHorizon,\n          epochs\n        );\n        break;\n      default:\n        modelResult = this.runLinearRegression(\n          trainingData,\n          testingData,\n          features,\n          predictionHorizon\n        );\n    }\n\n    // Generate insights and prepare result data\n    const resultData: Record<string, unknown> = {\n      model,\n      targetVariable,\n      features,\n      predictionHorizon,\n      dataPointCount: dataPoints.length,\n      trainTestSplit: {\n        training: trainingData.length,\n        testing: testingData.length,\n        ratio: 1 - testSplit,\n      },\n      metrics: modelResult.metrics,\n      predictions: modelResult.predictions,\n      forecast: modelResult.forecast,\n      modelDetails: modelResult.modelDetails,\n    };\n\n    // Generate insights about the prediction model\n    const insights = this.generatePredictionInsights(resultData);\n\n    // Create the result\n    const result: AnalysisResult = {\n      id: uuidv4(),\n      analysisConfigId: config.id,\n      status: 'completed',\n      startTime,\n      endTime: Date.now(),\n      data: resultData,\n      summary: this.generatePredictionSummary(resultData),\n      insights,\n    };\n\n    return result;\n  }\n\n  /**\n   * Run linear regression model for prediction\n   */\n  private runLinearRegression(\n    trainingData: Array<{\n      features: number[];\n      target: number;\n      date?: number;\n      original: DataPoint;\n    }>,\n    testingData: Array<{\n      features: number[];\n      target: number;\n      date?: number;\n      original: DataPoint;\n    }>,\n    featureNames: string[],\n    predictionHorizon: number\n  ): {\n    predictions: Array<{\n      features: number[];\n      actual: number;\n      predicted: number;\n      error?: number;\n    }>;\n    forecast: Array<{\n      features: number[];\n      predicted: number;\n      confidence?: [number, number];\n    }>;\n    metrics: {\n      mse: number;\n      rmse: number;\n      mae: number;\n      r2: number;\n    };\n    modelDetails: Record<string, unknown>;\n  } {\n    // Extract feature and target matrices\n    const X_train = trainingData.map(point => point.features);\n    const y_train = trainingData.map(point => point.target);\n\n    const X_test = testingData.map(point => point.features);\n    const y_test = testingData.map(point => point.target);\n\n    // Add bias term (intercept) to feature matrices\n    const X_train_with_bias = X_train.map(features => [1, ...features]);\n    const X_test_with_bias = X_test.map(features => [1, ...features]);\n\n    // Calculate coefficients using normal equation\n    // (X^T * X)^(-1) * X^T * y\n    const coefficients = this.calculateLinearRegressionCoefficients(X_train_with_bias, y_train);\n\n    // Make predictions on test set\n    const testPredictions = X_test_with_bias.map(features =>\n      features.reduce((sum, value, index) => sum + value * coefficients[index], 0)\n    );\n\n    // Calculate metrics\n    const errors = testPredictions.map((predicted, i) => predicted - y_test[i]);\n    const squaredErrors = errors.map(error => error * error);\n    const absErrors = errors.map(error => Math.abs(error));\n\n    const mse = squaredErrors.reduce((sum, sq) => sum + sq, 0) / squaredErrors.length;\n    const rmse = Math.sqrt(mse);\n    const mae = absErrors.reduce((sum, abs) => sum + abs, 0) / absErrors.length;\n\n    // Calculate R^2 (coefficient of determination)\n    const mean_y = y_test.reduce((sum, y) => sum + y, 0) / y_test.length;\n    const total_variance = y_test.reduce((sum, y) => sum + Math.pow(y - mean_y, 2), 0);\n    const r2 = 1 - squaredErrors.reduce((sum, sq) => sum + sq, 0) / total_variance;\n\n    // Create prediction results\n    const predictions = testingData.map((point, i) => ({\n      features: point.features,\n      actual: point.target,\n      predicted: testPredictions[i],\n      error: errors[i],\n    }));\n\n    // Generate forecast for future periods\n    const forecast: Array<{\n      features: number[];\n      predicted: number;\n      confidence?: [number, number];\n    }> = [];\n\n    // For time series forecasting\n    if (trainingData[0].date !== undefined && predictionHorizon > 0) {\n      // Start with the last point's features\n      let lastFeatures = [...testingData[testingData.length - 1].features];\n\n      for (let i = 0; i < predictionHorizon; i++) {\n        // Predict the next value\n        const nextPrediction = [1, ...lastFeatures].reduce(\n          (sum, value, index) => sum + value * coefficients[index],\n          0\n        );\n\n        // Add confidence interval (2 * RMSE for 95% confidence)\n        const confidence: [number, number] = [nextPrediction - 2 * rmse, nextPrediction + 2 * rmse];\n\n        // Add to forecast\n        forecast.push({\n          features: lastFeatures,\n          predicted: nextPrediction,\n          confidence,\n        });\n\n        // Update feature vector for next iteration (simple autoregressive approach)\n        // This assumes the target becomes a feature in the next step\n        // More sophisticated approaches would be needed for real applications\n        if (lastFeatures.length > 0) {\n          lastFeatures = [nextPrediction, ...lastFeatures.slice(0, -1)];\n        }\n      }\n    }\n\n    // Return model result\n    return {\n      predictions,\n      forecast,\n      metrics: {\n        mse,\n        rmse,\n        mae,\n        r2,\n      },\n      modelDetails: {\n        coefficients,\n        intercept: coefficients[0],\n        weights: coefficients.slice(1),\n        featureImportance: coefficients.slice(1).map((coef, i) => ({\n          feature: featureNames[i],\n          importance: Math.abs(coef),\n        })),\n      },\n    };\n  }\n\n  /**\n   * Calculate linear regression coefficients using normal equation\n   */\n  private calculateLinearRegressionCoefficients(X: number[][], y: number[]): number[] {\n    const numSamples = X.length;\n    const numFeatures = X[0].length;\n\n    // Calculate X^T (transpose of X)\n    const X_T = Array(numFeatures)\n      .fill(0)\n      .map(() => Array(numSamples).fill(0));\n    for (let i = 0; i < numSamples; i++) {\n      for (let j = 0; j < numFeatures; j++) {\n        X_T[j][i] = X[i][j];\n      }\n    }\n\n    // Calculate X^T * X\n    const X_T_X = Array(numFeatures)\n      .fill(0)\n      .map(() => Array(numFeatures).fill(0));\n    for (let i = 0; i < numFeatures; i++) {\n      for (let j = 0; j < numFeatures; j++) {\n        for (let k = 0; k < numSamples; k++) {\n          X_T_X[i][j] += X_T[i][k] * X[k][j];\n        }\n      }\n    }\n\n    // Calculate inverse of X^T * X\n    const X_T_X_inv = this.calculateMatrixInverse(X_T_X);\n\n    // Calculate X^T * y\n    const X_T_y = Array(numFeatures).fill(0);\n    for (let i = 0; i < numFeatures; i++) {\n      for (let j = 0; j < numSamples; j++) {\n        X_T_y[i] += X_T[i][j] * y[j];\n      }\n    }\n\n    // Calculate coefficients = (X^T * X)^(-1) * X^T * y\n    const coefficients = Array(numFeatures).fill(0);\n    for (let i = 0; i < numFeatures; i++) {\n      for (let j = 0; j < numFeatures; j++) {\n        coefficients[i] += X_T_X_inv[i][j] * X_T_y[j];\n      }\n    }\n\n    return coefficients;\n  }\n\n  /**\n   * Calculate the inverse of a matrix using Gaussian elimination\n   * This is a simple implementation for demonstration purposes\n   * For production, consider using a library like math.js\n   */\n  private calculateMatrixInverse(matrix: number[][]): number[][] {\n    const n = matrix.length;\n\n    // Create augmented matrix [A|I]\n    const augMatrix: number[][] = [];\n    for (let i = 0; i < n; i++) {\n      augMatrix.push([...matrix[i], ...Array(n).fill(0)]);\n      augMatrix[i][n + i] = 1;\n    }\n\n    // Apply Gaussian elimination\n    for (let i = 0; i < n; i++) {\n      // Find pivot\n      let maxRow = i;\n      for (let j = i + 1; j < n; j++) {\n        if (Math.abs(augMatrix[j][i]) > Math.abs(augMatrix[maxRow][i])) {\n          maxRow = j;\n        }\n      }\n\n      // Swap rows\n      if (maxRow !== i) {\n        [augMatrix[i], augMatrix[maxRow]] = [augMatrix[maxRow], augMatrix[i]];\n      }\n\n      // Pivot value\n      const pivot = augMatrix[i][i];\n\n      // Skip singular matrix\n      if (Math.abs(pivot) < 1e-10) {\n        // Return identity matrix (fallback)\n        const identityMatrix = Array(n)\n          .fill(0)\n          .map((_, i) =>\n            Array(n)\n              .fill(0)\n              .map((_, j) => (i === j ? 1 : 0))\n          );\n        return identityMatrix;\n      }\n\n      // Scale pivot row\n      for (let j = i; j < 2 * n; j++) {\n        augMatrix[i][j] /= pivot;\n      }\n\n      // Eliminate other rows\n      for (let j = 0; j < n; j++) {\n        if (j !== i) {\n          const factor = augMatrix[j][i];\n          for (let k = i; k < 2 * n; k++) {\n            augMatrix[j][k] -= factor * augMatrix[i][k];\n          }\n        }\n      }\n    }\n\n    // Extract right part (inverse matrix)\n    const inverseMatrix: number[][] = [];\n    for (let i = 0; i < n; i++) {\n      inverseMatrix.push(augMatrix[i].slice(n));\n    }\n\n    return inverseMatrix;\n  }\n\n  /**\n   * Run neural network model for prediction\n   */\n  private async runNeuralNetwork(\n    trainingData: Array<{\n      features: number[];\n      target: number;\n      date?: number;\n      original: DataPoint;\n    }>,\n    testingData: Array<{\n      features: number[];\n      target: number;\n      date?: number;\n      original: DataPoint;\n    }>,\n    featureNames: string[],\n    predictionHorizon: number,\n    epochs: number\n  ): Promise<{\n    predictions: Array<{\n      features: number[];\n      actual: number;\n      predicted: number;\n      error?: number;\n    }>;\n    forecast: Array<{\n      features: number[];\n      predicted: number;\n      confidence?: [number, number];\n    }>;\n    metrics: {\n      mse: number;\n      rmse: number;\n      mae: number;\n    };\n    modelDetails: Record<string, unknown>;\n  }> {\n    // Extract feature and target matrices\n    const X_train = trainingData.map(point => point.features);\n    const y_train = trainingData.map(point => point.target);\n\n    const X_test = testingData.map(point => point.features);\n    const y_test = testingData.map(point => point.target);\n\n    // Normalize features\n    const { normalizedTrainFeatures, normalizedTestFeatures, featureMeans, featureStdDevs } =\n      this.normalizeFeatures(X_train, X_test);\n\n    // Normalize targets\n    const allTargets = [...y_train, ...y_test];\n    const targetMean = allTargets.reduce((sum, y) => sum + y, 0) / allTargets.length;\n    const targetStdDev = Math.sqrt(\n      allTargets.reduce((sum, y) => sum + Math.pow(y - targetMean, 2), 0) / allTargets.length\n    );\n\n    const normalizedTrainTargets = y_train.map(y => (y - targetMean) / targetStdDev);\n    const normalizedTestTargets = y_test.map(y => (y - targetMean) / targetStdDev);\n\n    // Simple neural network implementation (2-layer NN)\n    const numFeatures = normalizedTrainFeatures[0].length;\n    const hiddenSize = Math.max(5, Math.min(20, Math.floor(numFeatures * 2)));\n\n    // Initialize weights randomly\n    const weights1 = Array(numFeatures)\n      .fill(0)\n      .map(() =>\n        Array(hiddenSize)\n          .fill(0)\n          .map(() => (Math.random() - 0.5) * 0.1)\n      );\n\n    const bias1 = Array(hiddenSize)\n      .fill(0)\n      .map(() => (Math.random() - 0.5) * 0.1);\n\n    const weights2 = Array(hiddenSize)\n      .fill(0)\n      .map(() => (Math.random() - 0.5) * 0.1);\n    const bias2 = (Math.random() - 0.5) * 0.1;\n\n    // Training parameters\n    const learningRate = 0.01;\n    const batchSize = Math.min(32, normalizedTrainFeatures.length);\n\n    // Training loop\n    for (let epoch = 0; epoch < epochs; epoch++) {\n      // Shuffle training data\n      const indices = Array(normalizedTrainFeatures.length)\n        .fill(0)\n        .map((_, i) => i);\n      for (let i = indices.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [indices[i], indices[j]] = [indices[j], indices[i]];\n      }\n\n      // Mini-batch training\n      for (\n        let batchStart = 0;\n        batchStart < normalizedTrainFeatures.length;\n        batchStart += batchSize\n      ) {\n        const batchEnd = Math.min(batchStart + batchSize, normalizedTrainFeatures.length);\n        const batchIndices = indices.slice(batchStart, batchEnd);\n\n        // Initialize gradients\n        const gradWeights1 = Array(numFeatures)\n          .fill(0)\n          .map(() => Array(hiddenSize).fill(0));\n        const gradBias1 = Array(hiddenSize).fill(0);\n        const gradWeights2 = Array(hiddenSize).fill(0);\n        const gradBias2 = 0;\n\n        let batchLoss = 0;\n\n        // Process each sample in the batch\n        for (const idx of batchIndices) {\n          const x = normalizedTrainFeatures[idx];\n          const y = normalizedTrainTargets[idx];\n\n          // Forward pass\n          // Hidden layer with ReLU activation\n          const hidden = Array(hiddenSize).fill(0);\n          for (let i = 0; i < hiddenSize; i++) {\n            for (let j = 0; j < numFeatures; j++) {\n              hidden[i] += x[j] * weights1[j][i];\n            }\n            hidden[i] += bias1[i];\n            // ReLU activation\n            hidden[i] = Math.max(0, hidden[i]);\n          }\n\n          // Output layer (linear)\n          let output = 0;\n          for (let i = 0; i < hiddenSize; i++) {\n            output += hidden[i] * weights2[i];\n          }\n          output += bias2;\n\n          // Loss (MSE)\n          const error = output - y;\n          batchLoss += error * error;\n\n          // Backward pass\n          // Output layer gradient\n          const gradOutput = 2 * error;\n\n          // Hidden layer gradient\n          for (let i = 0; i < hiddenSize; i++) {\n            if (hidden[i] > 0) {\n              // ReLU gradient\n              gradWeights2[i] += gradOutput * hidden[i];\n              for (let j = 0; j < numFeatures; j++) {\n                gradWeights1[j][i] += gradOutput * weights2[i] * x[j];\n              }\n              gradBias1[i] += gradOutput * weights2[i];\n            }\n          }\n\n          gradBias2 += gradOutput;\n        }\n\n        // Update weights\n        const batchScale = 1 / batchIndices.length;\n\n        for (let i = 0; i < numFeatures; i++) {\n          for (let j = 0; j < hiddenSize; j++) {\n            weights1[i][j] -= learningRate * gradWeights1[i][j] * batchScale;\n          }\n        }\n\n        for (let i = 0; i < hiddenSize; i++) {\n          bias1[i] -= learningRate * gradBias1[i] * batchScale;\n          weights2[i] -= learningRate * gradWeights2[i] * batchScale;\n        }\n\n        bias2 -= learningRate * gradBias2 * batchScale;\n      }\n    }\n\n    // (...args: unknown[]) => unknown to make predictions\n    const predict = (features: number[]): number => {\n      // Normalize features\n      const normalizedFeatures = features.map(\n        (value, i) => (value - featureMeans[i]) / featureStdDevs[i]\n      );\n\n      // Forward pass through the network\n      const hidden = Array(hiddenSize).fill(0);\n      for (let i = 0; i < hiddenSize; i++) {\n        for (let j = 0; j < numFeatures; j++) {\n          hidden[i] += normalizedFeatures[j] * weights1[j][i];\n        }\n        hidden[i] += bias1[i];\n        hidden[i] = Math.max(0, hidden[i]); // ReLU\n      }\n\n      let output = 0;\n      for (let i = 0; i < hiddenSize; i++) {\n        output += hidden[i] * weights2[i];\n      }\n      output += bias2;\n\n      // Denormalize the output\n      return output * targetStdDev + targetMean;\n    };\n\n    // Make predictions on test data\n    const testPredictions = X_test.map(features => predict(features));\n\n    // Calculate metrics\n    const errors = testPredictions.map((predicted, i) => predicted - y_test[i]);\n    const squaredErrors = errors.map(error => error * error);\n    const absErrors = errors.map(error => Math.abs(error));\n\n    const mse = squaredErrors.reduce((sum, sq) => sum + sq, 0) / squaredErrors.length;\n    const rmse = Math.sqrt(mse);\n    const mae = absErrors.reduce((sum, abs) => sum + abs, 0) / absErrors.length;\n\n    // Create prediction results\n    const predictions = testingData.map((point, i) => ({\n      features: point.features,\n      actual: point.target,\n      predicted: testPredictions[i],\n      error: errors[i],\n    }));\n\n    // Generate forecast for future periods\n    const forecast: Array<{\n      features: number[];\n      predicted: number;\n      confidence?: [number, number];\n    }> = [];\n\n    // For time series forecasting\n    if (trainingData[0].date !== undefined && predictionHorizon > 0) {\n      // Start with the last point's features\n      let lastFeatures = [...testingData[testingData.length - 1].features];\n\n      for (let i = 0; i < predictionHorizon; i++) {\n        // Predict the next value\n        const nextPrediction = predict(lastFeatures);\n\n        // Add confidence interval (2 * RMSE for 95% confidence)\n        const confidence: [number, number] = [nextPrediction - 2 * rmse, nextPrediction + 2 * rmse];\n\n        // Add to forecast\n        forecast.push({\n          features: lastFeatures,\n          predicted: nextPrediction,\n          confidence,\n        });\n\n        // Update feature vector for next iteration (simple autoregressive approach)\n        if (lastFeatures.length > 0) {\n          lastFeatures = [nextPrediction, ...lastFeatures.slice(0, -1)];\n        }\n      }\n    }\n\n    // Return model result\n    return {\n      predictions,\n      forecast,\n      metrics: {\n        mse,\n        rmse,\n        mae,\n      },\n      modelDetails: {\n        architecture: {\n          inputSize: numFeatures,\n          hiddenSize,\n          outputSize: 1,\n        },\n        normalization: {\n          featureMeans,\n          featureStdDevs,\n          targetMean,\n          targetStdDev,\n        },\n        training: {\n          epochs,\n          finalMSE: mse,\n        },\n      },\n    };\n  }\n\n  /**\n   * Normalize features for neural network training\n   */\n  private normalizeFeatures(\n    trainFeatures: number[][],\n    testFeatures: number[][]\n  ): {\n    normalizedTrainFeatures: number[][];\n    normalizedTestFeatures: number[][];\n    featureMeans: number[];\n    featureStdDevs: number[];\n  } {\n    const numFeatures = trainFeatures[0].length;\n    const featureMeans = Array(numFeatures).fill(0);\n    const featureStdDevs = Array(numFeatures).fill(0);\n\n    // Calculate means\n    for (const features of trainFeatures) {\n      for (let i = 0; i < numFeatures; i++) {\n        featureMeans[i] += features[i];\n      }\n    }\n\n    for (let i = 0; i < numFeatures; i++) {\n      featureMeans[i] /= trainFeatures.length;\n    }\n\n    // Calculate standard deviations\n    for (const features of trainFeatures) {\n      for (let i = 0; i < numFeatures; i++) {\n        featureStdDevs[i] += Math.pow(features[i] - featureMeans[i], 2);\n      }\n    }\n\n    for (let i = 0; i < numFeatures; i++) {\n      featureStdDevs[i] = Math.sqrt(featureStdDevs[i] / trainFeatures.length);\n      if (featureStdDevs[i] === 0) {\n        featureStdDevs[i] = 1; // Avoid division by zero\n      }\n    }\n\n    // Normalize train features\n    const normalizedTrainFeatures = trainFeatures.map(features =>\n      features.map((value, i) => (value - featureMeans[i]) / featureStdDevs[i])\n    );\n\n    // Normalize test features\n    const normalizedTestFeatures = testFeatures.map(features =>\n      features.map((value, i) => (value - featureMeans[i]) / featureStdDevs[i])\n    );\n\n    return {\n      normalizedTrainFeatures,\n      normalizedTestFeatures,\n      featureMeans,\n      featureStdDevs,\n    };\n  }\n\n  /**\n   * Generate insights about prediction results\n   */\n  private generatePredictionInsights(data: Record<string, unknown>): string[] {\n    const insights: string[] = [];\n    const model = data.model as string;\n    const metrics = data.metrics as { mse: number; rmse: number; mae: number; r2?: number };\n    const forecast = data.forecast as Array<{ predicted: number; confidence?: [number, number] }>;\n\n    // Model type and quality insights\n    insights.push(\n      `Prediction model: ${model === 'linear' ? 'Linear Regression' : 'Neural Network'}.`\n    );\n\n    if (metrics.r2 !== undefined) {\n      const r2 = metrics.r2;\n      if (r2 > 0.8) {\n        insights.push(\n          `The model explains ${(r2 * 100).toFixed(1)}% of the variance in the data, indicating a strong fit.`\n        );\n      } else if (r2 > 0.5) {\n        insights.push(\n          `The model explains ${(r2 * 100).toFixed(1)}% of the variance in the data, indicating a moderate fit.`\n        );\n      } else {\n        insights.push(\n          `The model explains only ${(r2 * 100).toFixed(1)}% of the variance, suggesting a weak relationship between features and target.`\n        );\n      }\n    }\n\n    insights.push(\n      `Mean Absolute Error (MAE): ${metrics.mae.toFixed(3)}, Root Mean Squared Error (RMSE): ${metrics.rmse.toFixed(3)}.`\n    );\n\n    // Feature importance for linear models\n    if (model === 'linear' && data.modelDetails && (data.modelDetails as any).featureImportance) {\n      const featureImportance = (data.modelDetails as any).featureImportance as Array<{\n        feature: string;\n        importance: number;\n      }>;\n\n      // Sort features by importance\n      const sortedFeatures = [...featureImportance].sort((a, b) => b.importance - a.importance);\n\n      if (sortedFeatures.length > 0) {\n        const topFeatures = sortedFeatures.slice(0, Math.min(3, sortedFeatures.length));\n\n        insights.push(\n          `Top influential features: ${topFeatures\n            .map(f => `${f.feature} (importance: ${f.importance.toFixed(3)})`)\n            .join(', ')}.`\n        );\n      }\n    }\n\n    // Forecast insights\n    if (forecast && forecast.length > 0) {\n      const firstPrediction = forecast[0].predicted;\n      const lastPrediction = forecast[forecast.length - 1].predicted;\n      const trend =\n        lastPrediction > firstPrediction\n          ? 'upward'\n          : lastPrediction < firstPrediction\n            ? 'downward'\n            : 'stable';\n\n      insights.push(\n        `The ${forecast.length}-step forecast shows a ${trend} trend from ${firstPrediction.toFixed(2)} to ${lastPrediction.toFixed(2)}.`\n      );\n\n      if (forecast[0].confidence) {\n        const confidenceWidth = forecast[0].confidence[1] - forecast[0].confidence[0];\n\n        insights.push(\n          `Forecast confidence interval width: ${confidenceWidth.toFixed(2)} (±${(confidenceWidth / 2).toFixed(2)}).`\n        );\n      }\n    }\n\n    return insights;\n  }\n\n  /**\n   * Generate summary of prediction results\n   */\n  private generatePredictionSummary(data: Record<string, unknown>): string {\n    const model = data.model as string;\n    const targetVariable = data.targetVariable as string;\n    const metrics = data.metrics as { mse: number; rmse: number; mae: number; r2?: number };\n\n    let summary = `${model === 'linear' ? 'Linear regression' : 'Neural network'} model `;\n\n    if (metrics.r2 !== undefined) {\n      const r2Description =\n        metrics.r2 > 0.7 ? 'strongly' : metrics.r2 > 0.4 ? 'moderately' : 'weakly';\n      summary += `${r2Description} predicts ${targetVariable} with R² of ${metrics.r2.toFixed(2)} and RMSE of ${metrics.rmse.toFixed(2)}.`;\n    } else {\n      summary += `predicts ${targetVariable} with RMSE of ${metrics.rmse.toFixed(2)}.`;\n    }\n\n    return summary;\n  }\n\n  /**\n   * Analyze the spatial distribution of resources\n   */\n  private async analyzeResourceMapping(\n    config: ResourceMappingAnalysisConfig,\n    dataset: Dataset,\n    options: AlgorithmOptions\n  ): Promise<AnalysisResult> {\n    const startTime = Date.now();\n\n    // Extract parameters\n    const { resourceTypes = [], valueMetric = 'amount', regionSize = 10 } = config.parameters;\n\n    // Validate dataset content\n    if (dataset.dataPoints.length === 0) {\n      throw new Error('Dataset contains no data points for resource mapping analysis.');\n    }\n\n    // Filter data points by resource type if specified\n    let resourcePoints = dataset.dataPoints.filter(\n      point => point.type === 'resource' || (point.properties && point.properties.resourceType)\n    );\n\n    if (resourceTypes.length > 0) {\n      resourcePoints = resourcePoints.filter(point => {\n        const type = point.properties.resourceType || point.properties.type;\n        return resourceTypes.includes(type as any);\n      });\n    }\n\n    if (resourcePoints.length === 0) {\n      throw new Error('No resource data points found in the dataset.');\n    }\n\n    // Determine the x and y range from the data\n    let minX = Infinity;\n    let maxX = -Infinity;\n    let minY = Infinity;\n    let maxY = -Infinity;\n\n    // Find the bounds of the area\n    resourcePoints.forEach(point => {\n      const x = point.coordinates.x;\n      const y = point.coordinates.y;\n\n      minX = Math.min(minX, x);\n      maxX = Math.max(maxX, x);\n      minY = Math.min(minY, y);\n      maxY = Math.max(maxY, y);\n    });\n\n    // Add some padding to the bounds\n    const padding = regionSize * 0.5;\n    minX = Math.floor(minX - padding);\n    maxX = Math.ceil(maxX + padding);\n    minY = Math.floor(minY - padding);\n    maxY = Math.ceil(maxY + padding);\n\n    // Create a grid with cells of regionSize\n    const gridCells: Record<\n      string,\n      {\n        x: number;\n        y: number;\n        resources: Array<{\n          type: ResourceType;\n          amount: number;\n          quality?: number;\n          accessibility?: number;\n          estimatedValue?: number;\n        }>;\n        points: DataPoint[];\n      }\n    > = {};\n\n    // Assign each resource point to a grid cell\n    resourcePoints.forEach(point => {\n      const cellX = Math.floor(point.coordinates.x / regionSize) * regionSize;\n      const cellY = Math.floor(point.coordinates.y / regionSize) * regionSize;\n      const cellKey = `${cellX},${cellY}`;\n\n      if (!gridCells[cellKey]) {\n        gridCells[cellKey] = {\n          x: cellX,\n          y: cellY,\n          resources: [],\n          points: [],\n        };\n      }\n\n      // Add the point to the cell\n      gridCells[cellKey].points.push(point);\n\n      // Extract resource information\n      const resourceType = point.properties.resourceType || point.properties.type;\n      const amount = typeof point.properties.amount === 'number' ? point.properties.amount : 1;\n      const quality =\n        typeof point.properties.quality === 'number' ? point.properties.quality : undefined;\n      const accessibility =\n        typeof point.properties.accessibility === 'number'\n          ? point.properties.accessibility\n          : undefined;\n      const estimatedValue =\n        typeof point.properties.estimatedValue === 'number'\n          ? point.properties.estimatedValue\n          : undefined;\n\n      // Check if this resource type already exists in the cell\n      const existingResource = gridCells[cellKey].resources.find(r => r.type === resourceType);\n\n      if (existingResource) {\n        // Update existing resource\n        existingResource.amount += amount;\n\n        // Update other properties if they exist\n        if (quality !== undefined) {\n          existingResource.quality =\n            existingResource.quality !== undefined\n              ? (existingResource.quality + quality) / 2 // Average the quality\n              : quality;\n        }\n\n        if (accessibility !== undefined) {\n          existingResource.accessibility =\n            existingResource.accessibility !== undefined\n              ? (existingResource.accessibility + accessibility) / 2 // Average the accessibility\n              : accessibility;\n        }\n\n        if (estimatedValue !== undefined) {\n          existingResource.estimatedValue =\n            existingResource.estimatedValue !== undefined\n              ? existingResource.estimatedValue + estimatedValue // Sum the estimated value\n              : estimatedValue;\n        }\n      } else {\n        // Add new resource type to the cell\n        gridCells[cellKey].resources.push({\n          type: resourceType as string,\n          amount,\n          quality,\n          accessibility,\n          estimatedValue,\n        });\n      }\n    });\n\n    // Calculate aggregate metrics for each cell\n    const processedCells = Object.values(gridCells).map(cell => {\n      // Calculate total value in the cell based on the selected metric\n      let totalValue = 0;\n\n      // Count total resources in the cell\n      const totalResourceCount = cell.resources.reduce((sum, resource) => sum + resource.amount, 0);\n\n      // Calculate total value based on selected metric\n      cell.resources.forEach(resource => {\n        const metricValue =\n          resource[valueMetric] !== undefined ? (resource[valueMetric] as number) : resource.amount;\n\n        totalValue += metricValue;\n      });\n\n      // Determine dominant resource type\n      let dominantResource: string | undefined;\n      let dominantPercentage = 0;\n\n      if (cell.resources.length > 0) {\n        // Sort resources by amount\n        const sortedResources = [...cell.resources].sort((a, b) => b.amount - a.amount);\n        dominantResource = sortedResources[0].type;\n        dominantPercentage = sortedResources[0].amount / totalResourceCount;\n      }\n\n      return {\n        x: cell.x,\n        y: cell.y,\n        resources: cell.resources,\n        totalValue,\n        dominantResource,\n        dominantPercentage,\n        totalResourceCount,\n      };\n    });\n\n    // Calculate resource type density\n    const resourceTypeDensity: Record<string, number> = {};\n    const allResourceTypes = new Set<string>();\n\n    processedCells.forEach(cell => {\n      cell.resources.forEach(resource => {\n        allResourceTypes.add(resource.type);\n\n        if (!resourceTypeDensity[resource.type]) {\n          resourceTypeDensity[resource.type] = 0;\n        }\n\n        resourceTypeDensity[resource.type] += resource.amount;\n      });\n    });\n\n    // Normalize densities\n    const totalResources = Object.values(resourceTypeDensity).reduce((sum, val) => sum + val, 0);\n\n    Object.keys(resourceTypeDensity).forEach(type => {\n      resourceTypeDensity[type] = resourceTypeDensity[type] / totalResources;\n    });\n\n    // Generate insights\n    const insights = this.generateResourceMappingInsights({\n      cells: processedCells,\n      resourceDensity: resourceTypeDensity,\n      xRange: [minX, maxX],\n      yRange: [minY, maxY],\n      valueMetric,\n    });\n\n    // Generate summary\n    const summary = this.generateResourceMappingSummary({\n      cells: processedCells,\n      resourceDensity: resourceTypeDensity,\n      xRange: [minX, maxX],\n      yRange: [minY, maxY],\n      valueMetric,\n    });\n\n    // Prepare result\n    const result: AnalysisResult = {\n      id: crypto.randomUUID(),\n      analysisConfigId: config.id,\n      status: 'completed',\n      startTime,\n      endTime: Date.now(),\n      data: {\n        resourcePoints,\n        gridCells: processedCells,\n        resourceTypes: Array.from(allResourceTypes),\n        valueMetric,\n        regionSize,\n        xRange: [minX, maxX],\n        yRange: [minY, maxY],\n        density: resourceTypeDensity,\n      },\n      insights,\n      summary,\n    };\n\n    return result;\n  }\n\n  /**\n   * Generate insights from resource mapping analysis\n   */\n  private generateResourceMappingInsights(data: Record<string, unknown>): ResourceType[] {\n    const insights: string[] = [];\n    const cells = data.cells as any[];\n    const resourceDensity = data.resourceDensity as Record<string, number>;\n    const valueMetric = data.valueMetric as string;\n\n    // Add insights about most abundant resource types\n    const sortedDensities = Object.entries(resourceDensity).sort(([, a], [, b]) => b - a);\n\n    if (sortedDensities.length > 0) {\n      const [topType, topDensity] = sortedDensities[0];\n      insights.push(\n        `${topType} is the most abundant resource in the mapped region, making up ${(topDensity * 100).toFixed(1)}% of all resources.`\n      );\n    }\n\n    if (sortedDensities.length > 1) {\n      const [, , ...restTypes] = sortedDensities;\n      const rareTypes = restTypes.filter(([, density]) => density < 0.1);\n\n      if (rareTypes.length > 0) {\n        insights.push(\n          `Rare resources include: ${rareTypes.map(([type]) => type).join(', ')}, each comprising less than 10% of the total.`\n        );\n      }\n    }\n\n    // Find resource-rich regions\n    if (cells.length > 0) {\n      const sortedCells = [...cells].sort((a, b) => b.totalValue - a.totalValue);\n      const topCell = sortedCells[0];\n\n      insights.push(\n        `The region with the highest ${valueMetric} concentration is located at coordinates (${topCell.x}, ${topCell.y}), containing primarily ${topCell.dominantResource}.`\n      );\n\n      // Find clusters of similar resources\n      const resourceClusters: Record<string, number> = {};\n\n      cells.forEach(cell => {\n        if (cell.dominantResource) {\n          if (!resourceClusters[cell.dominantResource]) {\n            resourceClusters[cell.dominantResource] = 0;\n          }\n          resourceClusters[cell.dominantResource]++;\n        }\n      });\n\n      const sortedClusters = Object.entries(resourceClusters).sort(([, a], [, b]) => b - a);\n\n      if (sortedClusters.length > 0) {\n        const [mostClusteredType, clusterCount] = sortedClusters[0];\n\n        if (clusterCount > 1) {\n          insights.push(\n            `${mostClusteredType} tends to form clusters across the map, with ${clusterCount} regions where it's the dominant resource.`\n          );\n        }\n      }\n    }\n\n    // Identify resource diversity\n    const avgResourceTypesPerCell =\n      cells.reduce((sum, cell) => sum + cell.resources.length, 0) / cells.length;\n\n    if (avgResourceTypesPerCell > 2.5) {\n      insights.push(\n        `The mapped region shows high resource diversity with an average of ${avgResourceTypesPerCell.toFixed(1)} resource types per region.`\n      );\n    } else if (avgResourceTypesPerCell < 1.5) {\n      insights.push(\n        `The mapped region shows low resource diversity with an average of ${avgResourceTypesPerCell.toFixed(1)} resource types per region.`\n      );\n    }\n\n    return insights;\n  }\n\n  /**\n   * Generate summary from resource mapping analysis\n   */\n  private generateResourceMappingSummary(data: Record<string, unknown>): ResourceType {\n    const cells = data.cells as any[];\n    const resourceDensity = data.resourceDensity as Record<string, number>;\n    const xRange = data.xRange as [number, number];\n    const yRange = data.yRange as [number, number];\n    const valueMetric = data.valueMetric as string;\n\n    const sortedDensities = Object.entries(resourceDensity)\n      .sort(([, a], [, b]) => b - a)\n      .slice(0, 3);\n\n    const topResourceTypes = sortedDensities\n      .map(([type, density]) => `${type} (${(density * 100).toFixed(1)}%)`)\n      .join(', ');\n\n    const mapSize = `${xRange[1] - xRange[0]}x${yRange[1] - yRange[0]}`;\n    const regionCount = cells.length;\n    const totalResourceAmount = cells.reduce((sum, cell) => sum + cell.totalResourceCount, 0);\n\n    return `Resource mapping analysis of a ${mapSize} area identified ${regionCount} resource regions containing a total of ${totalResourceAmount} resource units. The predominant resource types are ${topResourceTypes}. This analysis used ${valueMetric} as the primary metric for evaluation.`;\n  }\n\n  /**\n   * Analyze comparison between datasets or variables\n   */\n  private async analyzeComparison(\n    config: ComparisonAnalysisConfig,\n    dataset: Dataset,\n    options: AlgorithmOptions\n  ): Promise<AnalysisResult> {\n    // This is a stub implementation that will be fully implemented later\n    const startTime = Date.now();\n\n    // Extract parameters\n    const {\n      baseVariable,\n      comparisonVariables,\n      normalizeValues = false,\n      timeRange,\n      groupBy,\n    } = config.parameters;\n\n    // For now, just return a basic result structure\n    const result: AnalysisResult = {\n      id: crypto.randomUUID(),\n      analysisConfigId: config.id,\n      status: 'completed',\n      startTime,\n      endTime: Date.now(),\n      data: {\n        baseVariable,\n        comparisonVariables,\n        comparisonData: [],\n        summary: 'Comparison analysis stub implementation',\n      },\n      summary: 'Comparison analysis stub implementation',\n      insights: ['This is a stub implementation of the comparison analysis.'],\n    };\n\n    return result;\n  }\n\n  /**\n   * Analyze sectors for various metrics\n   */\n  private async analyzeSector(\n    config: SectorAnalysisConfig,\n    dataset: Dataset,\n    options: AlgorithmOptions\n  ): Promise<AnalysisResult> {\n    // This is a stub implementation that will be fully implemented later\n    const startTime = Date.now();\n\n    // Extract parameters\n    const { metrics, sectorIds, includeNeighbors = false, timeRange } = config.parameters;\n\n    // For now, just return a basic result structure\n    const result: AnalysisResult = {\n      id: crypto.randomUUID(),\n      analysisConfigId: config.id,\n      status: 'completed',\n      startTime,\n      endTime: Date.now(),\n      data: {\n        metrics,\n        sectorIds,\n        sectorData: [],\n        summary: 'Sector analysis stub implementation',\n      },\n      summary: 'Sector analysis stub implementation',\n      insights: ['This is a stub implementation of the sector analysis.'],\n    };\n\n    return result;\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/services/AnomalyDetectionService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/services/ComponentRegistryService.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'eventData' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 164,
        "column": 53,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 164,
        "endColumn": 62
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { AbstractBaseService } from '../lib/services/BaseService';\n\n/**\n * Metadata for a registered UI component\n *\n * Includes information about the component's identity, subscriptions, and performance metrics\n */\nexport interface ComponentMetadata {\n  id: string;\n  type: string;\n  eventSubscriptions: string[]; // Event types this component is interested in\n  updatePriority: 'high' | 'medium' | 'low';\n  lastUpdated?: number;\n  renderCount?: number;\n  averageRenderTime?: number;\n  totalRenderTime?: number;\n}\n\nexport interface ComponentRegistration {\n  id: string;\n  type: string;\n  eventSubscriptions: string[];\n  updatePriority: 'high' | 'medium' | 'low';\n  lastRenderTime?: number;\n  renderCount?: number;\n}\n\nclass ComponentRegistryServiceImpl extends AbstractBaseService {\n  private static instance: ComponentRegistryServiceImpl;\n  private components: Map<string, ComponentRegistration> = new Map();\n  private typeIndex: Map<string, Set<string>> = new Map();\n  private eventIndex: Map<string, Set<string>> = new Map();\n\n  private constructor() {\n    super('ComponentRegistryService', '1.0.0');\n  }\n\n  public static getInstance(): ComponentRegistryServiceImpl {\n    if (!ComponentRegistryServiceImpl.instance) {\n      ComponentRegistryServiceImpl.instance = new ComponentRegistryServiceImpl();\n    }\n    return ComponentRegistryServiceImpl.instance;\n  }\n\n  protected async onInitialize(): Promise<void> {\n    // No initialization needed\n  }\n\n  protected async onDispose(): Promise<void> {\n    // Clear all registrations\n    this.components.clear();\n    this.typeIndex.clear();\n    this.eventIndex.clear();\n  }\n\n  public registerComponent(registration: Omit<ComponentRegistration, 'id'>): string {\n    const id = crypto.randomUUID();\n    const fullRegistration: ComponentRegistration = {\n      ...registration,\n      id,\n      renderCount: 0,\n    };\n\n    // Store in main registry\n    this.components.set(id, fullRegistration);\n\n    // Update type index\n    if (!this.typeIndex.has(registration.type)) {\n      this.typeIndex.set(registration.type, new Set());\n    }\n    this.typeIndex.get(registration.type)!.add(id);\n\n    // Update event index\n    for (const event of registration.eventSubscriptions) {\n      if (!this.eventIndex.has(event)) {\n        this.eventIndex.set(event, new Set());\n      }\n      this.eventIndex.get(event)!.add(id);\n    }\n\n    // Update metrics\n    const metrics = this.metadata.metrics || {};\n    metrics.total_components = this.components.size;\n    metrics.total_types = this.typeIndex.size;\n    metrics.total_event_types = this.eventIndex.size;\n    this.metadata.metrics = metrics;\n\n    return id;\n  }\n\n  public unregisterComponent(id: string): void {\n    const registration = this.components.get(id);\n    if (!registration) {\n      return;\n    }\n\n    // Remove from type index\n    this.typeIndex.get(registration.type)?.delete(id);\n    if (this.typeIndex.get(registration.type)?.size === 0) {\n      this.typeIndex.delete(registration.type);\n    }\n\n    // Remove from event index\n    for (const event of registration.eventSubscriptions) {\n      this.eventIndex.get(event)?.delete(id);\n      if (this.eventIndex.get(event)?.size === 0) {\n        this.eventIndex.delete(event);\n      }\n    }\n\n    // Remove from main registry\n    this.components.delete(id);\n\n    // Update metrics\n    const metrics = this.metadata.metrics || {};\n    metrics.total_components = this.components.size;\n    metrics.total_types = this.typeIndex.size;\n    metrics.total_event_types = this.eventIndex.size;\n    this.metadata.metrics = metrics;\n  }\n\n  public getComponent(id: string): ComponentRegistration | undefined {\n    return this.components.get(id);\n  }\n\n  public getComponentsByType(type: string): ComponentRegistration[] {\n    const ids = this.typeIndex.get(type);\n    if (!ids) {\n      return [];\n    }\n\n    return Array.from(ids)\n      .map(id => this.components.get(id)!)\n      .filter(Boolean);\n  }\n\n  public getComponentsByEvent(event: string): ComponentRegistration[] {\n    const ids = this.eventIndex.get(event);\n    if (!ids) {\n      return [];\n    }\n\n    return Array.from(ids)\n      .map(id => this.components.get(id)!)\n      .filter(Boolean);\n  }\n\n  public trackRender(id: string): void {\n    const registration = this.components.get(id);\n    if (!registration) {\n      return;\n    }\n\n    registration.lastRenderTime = Date.now();\n    registration.renderCount = (registration.renderCount || 0) + 1;\n\n    // Update metrics\n    const metrics = this.metadata.metrics || {};\n    metrics.total_renders = (metrics.total_renders || 0) + 1;\n    metrics.last_render_timestamp = registration.lastRenderTime;\n    this.metadata.metrics = metrics;\n  }\n\n  public notifyComponentsOfEvent(eventType: string, eventData: unknown): void {\n    const components = this.getComponentsByEvent(eventType);\n\n    // Update metrics\n    const metrics = this.metadata.metrics || {};\n    metrics.total_notifications = (metrics.total_notifications || 0) + 1;\n    metrics.last_notification_timestamp = Date.now();\n    metrics.components_notified = components.length;\n    this.metadata.metrics = metrics;\n\n    // Log in development\n    if (process.env.NODE_ENV === 'development') {\n      console.warn(\n        `[ComponentRegistryService] Notifying ${components.length} components of event: ${eventType}`\n      );\n    }\n  }\n\n  public override handleError(error: Error): void {\n    // Update error metrics\n    const metrics = this.metadata.metrics || {};\n    metrics.total_errors = (metrics.total_errors || 0) + 1;\n    metrics.last_error_timestamp = Date.now();\n    this.metadata.metrics = metrics;\n\n    // Log error in development\n    if (process.env.NODE_ENV === 'development') {\n      console.error('[ComponentRegistryService] Error:', error);\n    }\n  }\n}\n\n// Export singleton instance\nexport const componentRegistryService = ComponentRegistryServiceImpl.getInstance();\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/services/DataCollectionService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/services/DataProcessingService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/services/ErrorLoggingService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/services/EventPropagationService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/services/RealTimeDataService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/services/RecoveryService.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'metadata' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 139,
        "column": 5,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 139,
        "endColumn": 13
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * RecoveryService - Provides mechanisms for recovering from critical application failures\n *\n * This service handles:\n * - Saving application state snapshots\n * - Restoring previous application states\n * - Implementing different recovery strategies based on error type\n * - Providing graceful degradation options\n */\n\nimport { AbstractBaseService } from '../lib/services/BaseService';\nimport { ErrorType } from './ErrorLoggingService';\n\n// Types of recovery strategies that can be applied\nexport enum RecoveryStrategy {\n  RETRY = 'retry',\n  ROLLBACK = 'rollback',\n  RESET = 'reset',\n  IGNORE = 'ignore',\n}\n\n// Structure for application state snapshot\nexport interface StateSnapshot {\n  id: string;\n  state: Record<string, unknown>;\n  timestamp: number;\n  metadata?: Record<string, unknown>;\n}\n\n// Configuration for recovery actions\nexport interface RecoveryConfig {\n  maxSnapshots: number;\n  autoSaveInterval: number;\n  enableAutoRecover: boolean;\n  defaultStrategy: RecoveryStrategy;\n  strategyByErrorType: Partial<Record<ErrorType, RecoveryStrategy>>;\n}\n\nclass RecoveryServiceImpl extends AbstractBaseService {\n  private static instance: RecoveryServiceImpl;\n  private snapshots: StateSnapshot[] = [];\n  private config: RecoveryConfig = {\n    maxSnapshots: 10,\n    autoSaveInterval: 60000, // 1 minute\n    enableAutoRecover: true,\n    defaultStrategy: RecoveryStrategy.RETRY,\n    strategyByErrorType: {\n      [ErrorType.NETWORK]: RecoveryStrategy.RETRY,\n      [ErrorType.RESOURCE]: RecoveryStrategy.ROLLBACK,\n      [ErrorType.UNKNOWN]: RecoveryStrategy.RESET,\n    },\n  };\n\n  private constructor() {\n    super('RecoveryService', '1.0.0');\n  }\n\n  public static getInstance(): RecoveryServiceImpl {\n    if (!RecoveryServiceImpl.instance) {\n      RecoveryServiceImpl.instance = new RecoveryServiceImpl();\n    }\n    return RecoveryServiceImpl.instance;\n  }\n\n  protected async onInitialize(): Promise<void> {\n    // Load any existing snapshots from localStorage\n    try {\n      const savedSnapshots = localStorage.getItem('recovery_snapshots');\n      if (savedSnapshots) {\n        this.snapshots = JSON.parse(savedSnapshots);\n      }\n    } catch (error) {\n      this.handleError(error as Error);\n    }\n  }\n\n  protected async onDispose(): Promise<void> {\n    // Save snapshots to localStorage\n    try {\n      localStorage.setItem('recovery_snapshots', JSON.stringify(this.snapshots));\n    } catch (error) {\n      this.handleError(error as Error);\n    }\n  }\n\n  public createSnapshot(\n    state: Record<string, unknown>,\n    metadata?: Record<string, unknown>\n  ): string {\n    const snapshot: StateSnapshot = {\n      id: crypto.randomUUID(),\n      state,\n      timestamp: Date.now(),\n      metadata,\n    };\n\n    this.snapshots.unshift(snapshot);\n\n    // Trim snapshots if we exceed max size\n    if (this.snapshots.length > this.config.maxSnapshots) {\n      this.snapshots = this.snapshots.slice(0, this.config.maxSnapshots);\n    }\n\n    // Update metrics\n    const metrics = this.metadata.metrics || {};\n    metrics.total_snapshots = this.snapshots.length;\n    metrics.latest_snapshot_timestamp = snapshot.timestamp;\n    this.metadata.metrics = metrics;\n\n    return snapshot.id;\n  }\n\n  public restoreSnapshot(snapshotId: string): Record<string, unknown> | null {\n    const snapshot = this.snapshots.find(s => s.id === snapshotId);\n    if (!snapshot) {\n      return null;\n    }\n\n    // Update metrics\n    const metrics = this.metadata.metrics || {};\n    metrics.total_restores = (metrics.total_restores || 0) + 1;\n    metrics.last_restore_timestamp = Date.now();\n    this.metadata.metrics = metrics;\n\n    return snapshot.state;\n  }\n\n  public getSnapshots(): StateSnapshot[] {\n    return [...this.snapshots];\n  }\n\n  public clearSnapshots(): void {\n    this.snapshots = [];\n    this.metadata.metrics = {};\n  }\n\n  public getRecoveryStrategy(\n    errorType: ErrorType = ErrorType.UNKNOWN,\n    metadata?: Record<string, unknown>\n  ): RecoveryStrategy {\n    return this.config.strategyByErrorType[errorType] || this.config.defaultStrategy;\n  }\n\n  public override handleError(error: Error): void {\n    // Update error metrics\n    const metrics = this.metadata.metrics || {};\n    metrics.total_errors = (metrics.total_errors || 0) + 1;\n    metrics.last_error_timestamp = Date.now();\n    this.metadata.metrics = metrics;\n\n    // Log error in development\n    if (process.env.NODE_ENV === 'development') {\n      console.error('[RecoveryService] Error:', error);\n    }\n  }\n}\n\n// Export singleton instance\nexport const recoveryService = RecoveryServiceImpl.getInstance();\n\n// Export default for easier imports\nexport default recoveryService;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/services/WebGLService.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/services/WorkerService.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 242,
        "column": 14,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 242,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6386, 6389], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6386, 6389], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 265,
        "column": 14,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 265,
        "endColumn": 17,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7041, 7044], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7041, 7044], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { AbstractBaseService } from '../lib/services/BaseService';\nimport { ErrorType, errorLoggingService } from './ErrorLoggingService';\n\nexport interface WorkerTask<T = unknown> {\n  id: string;\n  type: string;\n  data: unknown;\n  priority: number;\n  cancelToken?: AbortController;\n  progress?: number;\n  result?: T;\n  error?: Error;\n  startTime?: number;\n  endTime?: number;\n}\n\nexport interface WorkerConfig {\n  maxWorkers: number;\n  taskTimeout: number;\n  retryAttempts: number;\n  priorityLevels: {\n    HIGH: number;\n    MEDIUM: number;\n    LOW: number;\n  };\n}\n\nclass WorkerServiceImpl extends AbstractBaseService {\n  private static instance: WorkerServiceImpl;\n  private workers: Worker[] = [];\n  private taskQueue: WorkerTask[] = [];\n  private activeTasks: Map<string, WorkerTask> = new Map();\n  private workerPool: Map<Worker, WorkerTask | null> = new Map();\n\n  private config: WorkerConfig = {\n    maxWorkers: navigator.hardwareConcurrency || 4,\n    taskTimeout: 30000, // 30 seconds\n    retryAttempts: 3,\n    priorityLevels: {\n      HIGH: 3,\n      MEDIUM: 2,\n      LOW: 1,\n    },\n  };\n\n  private constructor() {\n    super('WorkerService', '1.0.0');\n  }\n\n  public static getInstance(): WorkerServiceImpl {\n    if (!WorkerServiceImpl.instance) {\n      WorkerServiceImpl.instance = new WorkerServiceImpl();\n    }\n    return WorkerServiceImpl.instance;\n  }\n\n  protected async onInitialize(): Promise<void> {\n    // Initialize worker pool\n    for (let i = 0; i < this.config.maxWorkers; i++) {\n      const worker = new Worker(new URL('../workers/worker.ts', import.meta.url), {\n        type: 'module',\n      });\n      this.setupWorker(worker);\n      this.workers.push(worker);\n      this.workerPool.set(worker, null);\n    }\n\n    // Initialize metrics\n    this.metadata.metrics = {\n      total_tasks: 0,\n      active_tasks: 0,\n      completed_tasks: 0,\n      failed_tasks: 0,\n      average_task_time: 0,\n    };\n  }\n\n  protected async onDispose(): Promise<void> {\n    // Cancel all active tasks\n    for (const task of this.activeTasks.values()) {\n      this.cancelTask(task.id);\n    }\n\n    // Terminate all workers\n    for (const worker of this.workers) {\n      worker.terminate();\n    }\n\n    this.workers = [];\n    this.taskQueue = [];\n    this.activeTasks.clear();\n    this.workerPool.clear();\n  }\n\n  private setupWorker(worker: Worker): void {\n    worker.onmessage = (event: MessageEvent) => {\n      const { taskId, type, data } = event.data;\n      const task = this.activeTasks.get(taskId);\n\n      if (!task) return;\n\n      switch (type) {\n        case 'progress':\n          task.progress = data;\n          break;\n        case 'result':\n          this.completeTask(taskId, data);\n          break;\n        case 'error':\n          this.failTask(taskId, new Error(data));\n          break;\n      }\n    };\n\n    worker.onerror = (error: ErrorEvent) => {\n      const task = Array.from(this.activeTasks.values()).find(\n        task => this.workerPool.get(worker) === task\n      );\n      if (task) {\n        this.failTask(task.id, error.error);\n      }\n    };\n  }\n\n  public async submitTask<T>(\n    type: string,\n    data: unknown,\n    priority: keyof WorkerConfig['priorityLevels'] = 'MEDIUM'\n  ): Promise<T> {\n    const task: WorkerTask<T> = {\n      id: crypto.randomUUID(),\n      type,\n      data,\n      priority: this.config.priorityLevels[priority],\n      cancelToken: new AbortController(),\n    };\n\n    // Update metrics\n    const metrics = this.metadata.metrics || {};\n    metrics.total_tasks = (metrics.total_tasks || 0) + 1;\n    this.metadata.metrics = metrics;\n\n    return new Promise((resolve, reject) => {\n      // Add task to queue\n      this.taskQueue.push(task);\n      this.taskQueue.sort((a, b) => b.priority - a.priority);\n\n      // Setup task timeout\n      const timeoutId = setTimeout(() => {\n        this.cancelTask(task.id);\n        reject(new Error(`Task ${task.id} timed out after ${this.config.taskTimeout}ms`));\n      }, this.config.taskTimeout);\n\n      // Setup completion handlers\n      const cleanup = () => {\n        clearTimeout(timeoutId);\n        this.taskQueue = this.taskQueue.filter(t => t.id !== task.id);\n        this.activeTasks.delete(task.id);\n      };\n\n      const onComplete = (result: T) => {\n        cleanup();\n        resolve(result);\n      };\n\n      const onError = (error: Error) => {\n        cleanup();\n        reject(error);\n      };\n\n      // Store handlers with task\n      Object.assign(task, { onComplete, onError });\n\n      // Try to process task immediately\n      this.processNextTask();\n    });\n  }\n\n  public cancelTask(taskId: string): void {\n    const task = this.activeTasks.get(taskId);\n    if (!task) return;\n\n    task.cancelToken?.abort();\n    this.failTask(taskId, new Error('Task cancelled'));\n  }\n\n  private async processNextTask(): Promise<void> {\n    // Find available worker\n    const availableWorker = Array.from(this.workerPool.entries()).find(\n      ([, task]) => task === null\n    )?.[0];\n\n    if (!availableWorker || this.taskQueue.length === 0) return;\n\n    // Get highest priority task\n    const task = this.taskQueue.shift()!;\n    task.startTime = Date.now();\n\n    // Assign task to worker\n    this.activeTasks.set(task.id, task);\n    this.workerPool.set(availableWorker, task);\n\n    // Update metrics\n    const metrics = this.metadata.metrics || {};\n    metrics.active_tasks = this.activeTasks.size;\n    this.metadata.metrics = metrics;\n\n    // Send task to worker\n    availableWorker.postMessage({\n      taskId: task.id,\n      type: task.type,\n      data: task.data,\n    });\n  }\n\n  private completeTask(taskId: string, result: unknown): void {\n    const task = this.activeTasks.get(taskId);\n    if (!task) return;\n\n    task.endTime = Date.now();\n    task.result = result;\n\n    // Update metrics\n    const metrics = this.metadata.metrics || {};\n    metrics.completed_tasks = (metrics.completed_tasks || 0) + 1;\n    metrics.active_tasks = this.activeTasks.size - 1;\n\n    const taskTime = task.endTime - (task.startTime || 0);\n    metrics.average_task_time = metrics.average_task_time\n      ? (metrics.average_task_time + taskTime) / 2\n      : taskTime;\n\n    this.metadata.metrics = metrics;\n\n    // Release worker\n    const worker = Array.from(this.workerPool.entries()).find(([, t]) => t === task)?.[0];\n    if (worker) {\n      this.workerPool.set(worker, null);\n    }\n\n    // Call completion handler\n    (task as any).onComplete?.(result);\n\n    // Process next task\n    this.processNextTask();\n  }\n\n  private failTask(taskId: string, error: Error): void {\n    const task = this.activeTasks.get(taskId);\n    if (!task) return;\n\n    // Update metrics\n    const metrics = this.metadata.metrics || {};\n    metrics.failed_tasks = (metrics.failed_tasks || 0) + 1;\n    metrics.active_tasks = this.activeTasks.size - 1;\n    this.metadata.metrics = metrics;\n\n    // Release worker\n    const worker = Array.from(this.workerPool.entries()).find(([, t]) => t === task)?.[0];\n    if (worker) {\n      this.workerPool.set(worker, null);\n    }\n\n    // Call error handler\n    (task as any).onError?.(error);\n\n    // Process next task\n    this.processNextTask();\n  }\n\n  public override handleError(error: Error): void {\n    errorLoggingService.logError(error, ErrorType.RUNTIME, undefined, { service: 'WorkerService' });\n  }\n}\n\n// Export singleton instance\nexport const workerService = WorkerServiceImpl.getInstance();\n\n// Export default for easier imports\nexport default workerService;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/services/telemetry/SessionPerformanceTracker.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'screenHeight' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 186,
        "column": 11,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 186,
        "endColumn": 23
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * SessionPerformanceTracker\n *\n * A service that anonymously tracks performance metrics during user sessions.\n * Collects, aggregates, and reports performance data without storing personally\n * identifiable information.\n */\n\nimport { moduleEventBus } from '../../lib/modules/ModuleEvents';\nimport { ModuleEvent } from '../../types/events/ModuleEventTypes';\nimport { ResourceType } from \"./../../types/resources/ResourceTypes\";\nimport { generateAnonymousId } from '../../utils/idGenerator';\n\n/**\n * Session identification data\n */\nexport interface SessionMetadata {\n  sessionId: string;\n  deviceCategory: 'desktop' | 'tablet' | 'mobile' | 'unknown';\n  browserCategory: string;\n  viewportWidth: number;\n  viewportHeight: number;\n  startTimestamp: number;\n  geographicRegion?: string;\n  connectionType?: string;\n  memoryEstimate?: number;\n}\n\n/**\n * Performance metrics collected during a session\n */\nexport interface SessionPerformanceData {\n  sessionId: string;\n  timestamp: number;\n  metrics: {\n    fps: number;\n    memoryUsage: number;\n    cpuUsage: number;\n    resourceUtilization: Map<ResourceType, number>;\n    renderTime: number;\n    eventProcessingTime: number;\n    interactionLatency: number;\n    loadTimes: {\n      [componentId: string]: number;\n    };\n    eventCounts: {\n      [eventType: string]: number;\n    };\n  };\n  userInteractions: UserInteractionData[];\n  errors: ErrorData[];\n}\n\n/**\n * Data about user interactions with timestamps and performance metrics\n */\nexport interface UserInteractionData {\n  interactionType: 'click' | 'hover' | 'scroll' | 'keypress' | 'custom';\n  targetComponent?: string;\n  timestamp: number;\n  responseTime: number;\n  successful: boolean;\n}\n\n/**\n * Error information for tracking performance-related errors\n */\nexport interface ErrorData {\n  errorType: ResourceType;\n  message: string;\n  timestamp: number;\n  componentId?: string;\n  stackSummary?: string;\n  affectedResource?: ResourceType;\n}\n\n/**\n * Options for telemetry collection\n */\nexport interface TelemetryOptions {\n  collectionEnabled: boolean;\n  samplingRate: number; // 0.0 to 1.0\n  anonymousIdSeed?: string;\n  geolocationEnabled: boolean;\n  performanceDetailLevel: 'minimal' | 'standard' | 'detailed';\n  transmitIntervalMs: number;\n  maxBatchSize: number;\n  errorSamplingRate: number; // 0.0 to 1.0\n}\n\n// Browser API interfaces to avoid 'any' usage\ninterface NavigatorExtended extends Navigator {\n  deviceMemory?: number;\n  connection?: {\n    effectiveType?: string;\n    type?: string;\n  };\n  getBattery?: () => Promise<{\n    charging: boolean;\n    level: number;\n  }>;\n}\n\ninterface PerformanceExtended extends Performance {\n  memory?: {\n    jsHeapSizeLimit: number;\n    totalJSHeapSize: number;\n    usedJSHeapSize: number;\n  };\n}\n\n/**\n * Service that tracks anonymous session performance metrics\n */\nexport class SessionPerformanceTracker {\n  private isEnabled: boolean;\n  private sessionMetadata!: SessionMetadata; // Using definite assignment assertion\n  private performanceData: SessionPerformanceData[] = [];\n  private options: TelemetryOptions;\n  private transmitInterval: number | null = null;\n  private eventSubscription: (() => void) | null = null;\n  private interactionObservers: Map<string, () => void> = new Map();\n  private componentLoadTimers: Map<string, number> = new Map();\n  private startTime: number;\n  private lastTransmitTime: number;\n  private accumulatedEventCounts: Record<string, number> = {};\n\n  /**\n   * Initialize the session performance tracker\n   */\n  constructor(options?: Partial<TelemetryOptions>) {\n    this.startTime = performance.now();\n    this.lastTransmitTime = this.startTime;\n\n    // Set default options\n    this.options = {\n      collectionEnabled: true,\n      samplingRate: 0.1, // Only track 10% of sessions by default\n      geolocationEnabled: false,\n      performanceDetailLevel: 'standard',\n      transmitIntervalMs: 60000, // Transmit data every minute\n      maxBatchSize: 50,\n      errorSamplingRate: 1.0, // Track all errors\n      ...options,\n    };\n\n    // Only enable tracking if it passes the sampling threshold\n    const samplingValue = Math.random();\n    this.isEnabled = this.options.collectionEnabled && samplingValue <= this.options.samplingRate;\n\n    if (!this.isEnabled) {\n      console.warn('[SessionPerformanceTracker] Telemetry disabled due to sampling');\n      return;\n    }\n\n    // Create session metadata\n    this.sessionMetadata = this.generateSessionMetadata();\n\n    // Initialize performance data for the current session\n    this.initializeCurrentSessionData();\n\n    // Subscribe to system events\n    this.subscribeToEvents();\n\n    // Set up interaction tracking\n    this.setupInteractionTracking();\n\n    // Start transmission cycle\n    this.startTransmissionCycle();\n\n    console.warn(\n      `[SessionPerformanceTracker] Initialized session: ${this.sessionMetadata.sessionId}`\n    );\n  }\n\n  /**\n   * Generate anonymous session metadata\n   */\n  private generateSessionMetadata(): SessionMetadata {\n    // Create an anonymous ID that doesn't contain PII\n    const sessionId = generateAnonymousId(this.options.anonymousIdSeed);\n\n    // Detect device type from user agent and screen size\n    const userAgent = navigator.userAgent.toLowerCase();\n    const screenWidth = window.screen.width;\n    const screenHeight = window.screen.height;\n\n    let deviceCategory: 'desktop' | 'tablet' | 'mobile' | 'unknown' = 'unknown';\n    if (/mobile|android|iphone|ipad|ipod|blackberry|iemobile|opera mini/.test(userAgent)) {\n      deviceCategory = screenWidth >= 768 ? 'tablet' : 'mobile';\n    } else {\n      deviceCategory = 'desktop';\n    }\n\n    // Determine browser category without version info for anonymity\n    let browserCategory = 'unknown';\n    if (userAgent.includes('firefox')) {\n      browserCategory = 'firefox';\n    } else if (userAgent.includes('chrome')) {\n      browserCategory = 'chrome';\n    } else if (userAgent.includes('safari')) {\n      browserCategory = 'safari';\n    } else if (userAgent.includes('edge')) {\n      browserCategory = 'edge';\n    }\n\n    // Get viewport size\n    const viewportWidth = window.innerWidth;\n    const viewportHeight = window.innerHeight;\n\n    // Get optional connection information if available\n    const nav = navigator as NavigatorExtended;\n    let connectionType: string | undefined;\n    if (nav.connection) {\n      connectionType = nav.connection.effectiveType || nav.connection.type;\n    }\n\n    // Estimate memory if available\n    let memoryEstimate: number | undefined;\n    if (nav.deviceMemory) {\n      memoryEstimate = nav.deviceMemory;\n    } else if ((performance as PerformanceExtended).memory) {\n      memoryEstimate = (performance as PerformanceExtended).memory!.jsHeapSizeLimit / 1048576; // Convert to MB\n    }\n\n    // Optional geographic region if enabled (coarse-grained only)\n    let geographicRegion: string | undefined;\n    if (this.options.geolocationEnabled) {\n      // Only collect broad region data, not specific coordinates\n      if (navigator.language) {\n        // Just use language/region preference as a proxy\n        geographicRegion = navigator.language.split('-')[1] || navigator.language;\n      }\n    }\n\n    return {\n      sessionId,\n      deviceCategory,\n      browserCategory,\n      viewportWidth,\n      viewportHeight,\n      startTimestamp: Date.now(),\n      connectionType,\n      memoryEstimate,\n      geographicRegion,\n    };\n  }\n\n  /**\n   * Initialize performance data structure for the current session\n   */\n  private initializeCurrentSessionData(): void {\n    const currentData: SessionPerformanceData = {\n      sessionId: this.sessionMetadata.sessionId,\n      timestamp: Date.now(),\n      metrics: {\n        fps: 0,\n        memoryUsage: 0,\n        cpuUsage: 0,\n        resourceUtilization: new Map(),\n        renderTime: 0,\n        eventProcessingTime: 0,\n        interactionLatency: 0,\n        loadTimes: {},\n        eventCounts: {},\n      },\n      userInteractions: [],\n      errors: [],\n    };\n\n    this.performanceData.push(currentData);\n  }\n\n  /**\n   * Subscribe to system events for performance monitoring\n   */\n  private subscribeToEvents(): void {\n    if (!this.isEnabled) return;\n\n    this.eventSubscription = moduleEventBus.subscribe({\n      topic: 'STATUS_CHANGED',\n      callback: (event: ModuleEvent) => {\n        this.trackEvent(event);\n\n        // Track specific performance-related events\n        if (event.moduleId === 'game-loop-manager') {\n          if (event.data.type === 'performance_snapshot') {\n            this.trackPerformanceSnapshot(event.data);\n          }\n        }\n\n        // Track errors\n        if (event.type === 'ERROR') {\n          this.trackError({\n            errorType: event.data.type || 'unknown',\n            message: (event.data.message as string) || 'Unknown error',\n            timestamp: event.timestamp,\n            componentId: event.moduleId,\n            affectedResource: event.data.resourceType as ResourceType,\n          });\n        }\n      },\n    });\n  }\n\n  /**\n   * Set up tracking for user interactions\n   */\n  private setupInteractionTracking(): void {\n    if (!this.isEnabled) return;\n\n    // Track clicks\n    const clickHandler = (e: MouseEvent) => {\n      const target = e.target as HTMLElement;\n      const componentId = target.getAttribute('data-component-id') || target.id || target.tagName;\n\n      const startTime = performance.now();\n\n      // Add a one-time callback to requestAnimationFrame to measure response time\n      requestAnimationFrame(() => {\n        const responseTime = performance.now() - startTime;\n\n        this.trackUserInteraction({\n          interactionType: 'click',\n          targetComponent: componentId,\n          timestamp: Date.now(),\n          responseTime,\n          successful: true,\n        });\n      });\n    };\n\n    document.addEventListener('click', clickHandler);\n    this.interactionObservers.set('click', () => {\n      document.removeEventListener('click', clickHandler);\n    });\n\n    // Track scrolling performance\n    let lastScrollTime = 0;\n    const scrollTimeouts: number[] = [];\n\n    const scrollHandler = () => {\n      const now = performance.now();\n      const timeSinceLastScroll = now - lastScrollTime;\n      lastScrollTime = now;\n\n      // Only track if it's been a while since the last scroll\n      // to avoid tracking every tiny scroll event\n      if (timeSinceLastScroll > 500) {\n        const scrollTimeout = window.setTimeout(() => {\n          this.trackUserInteraction({\n            interactionType: 'scroll',\n            timestamp: Date.now(),\n            responseTime: performance.now() - now,\n            successful: true,\n          });\n        }, 100);\n\n        scrollTimeouts.push(scrollTimeout);\n      }\n    };\n\n    document.addEventListener('scroll', scrollHandler, { passive: true });\n    this.interactionObservers.set('scroll', () => {\n      document.removeEventListener('scroll', scrollHandler);\n      scrollTimeouts.forEach(clearTimeout);\n    });\n  }\n\n  /**\n   * Start periodic transmission of telemetry data\n   */\n  private startTransmissionCycle(): void {\n    if (!this.isEnabled) return;\n\n    this.transmitInterval = window.setInterval(() => {\n      this.transmitTelemetryData();\n    }, this.options.transmitIntervalMs);\n  }\n\n  /**\n   * Track a system event for telemetry\n   */\n  private trackEvent(event: ModuleEvent): void {\n    if (!this.isEnabled) return;\n\n    // Increment event count\n    const eventType = `${event.type}:${event.data.type || 'unknown'}`;\n    this.accumulatedEventCounts[eventType] = (this.accumulatedEventCounts[eventType] || 0) + 1;\n\n    // For detailed level, track event processing time\n    if (this.options.performanceDetailLevel === 'detailed') {\n      const startTime = performance.now();\n\n      // Measure how long the event takes to be processed\n      // This is a simplification - in reality we would measure actual handler execution\n      setTimeout(() => {\n        const processingTime = performance.now() - startTime;\n\n        // Update event processing time metric (rolling average)\n        const current = this.getCurrentSessionData();\n        current.metrics.eventProcessingTime =\n          (current.metrics.eventProcessingTime + processingTime) / 2;\n      }, 0);\n    }\n  }\n\n  /**\n   * Track a performance snapshot\n   */\n  private trackPerformanceSnapshot(data: Record<string, unknown>): void {\n    if (!this.isEnabled) return;\n\n    const current = this.getCurrentSessionData();\n\n    // Update general metrics\n    if (typeof data.fps === 'number') {\n      current.metrics.fps = data.fps;\n    }\n\n    if (typeof data.memoryUsage === 'number') {\n      current.metrics.memoryUsage = data.memoryUsage;\n    }\n\n    if (typeof data.cpuUsage === 'number') {\n      current.metrics.cpuUsage = data.cpuUsage;\n    }\n\n    // Update resource utilization\n    if (data.resourceUtilization && typeof data.resourceUtilization === 'object') {\n      const utilization = data.resourceUtilization as Record<string, number>;\n      for (const [resource, value] of Object.entries(utilization)) {\n        current.metrics.resourceUtilization.set(resource as ResourceType, value);\n      }\n    }\n\n    // Update render time\n    if (typeof data.renderTime === 'number') {\n      current.metrics.renderTime = data.renderTime;\n    }\n  }\n\n  /**\n   * Register the start of a component load\n   */\n  public startComponentLoadTimer(componentId: string): void {\n    if (!this.isEnabled) return;\n\n    this.componentLoadTimers.set(componentId, performance.now());\n  }\n\n  /**\n   * Register the completion of a component load\n   */\n  public endComponentLoadTimer(componentId: string): void {\n    if (!this.isEnabled) return;\n\n    const startTime = this.componentLoadTimers.get(componentId);\n    if (startTime === undefined) return;\n\n    const loadTime = performance.now() - startTime;\n    this.componentLoadTimers.delete(componentId);\n\n    // Update load time metrics\n    const current = this.getCurrentSessionData();\n    current.metrics.loadTimes[componentId] = loadTime;\n  }\n\n  /**\n   * Track a user interaction with the system\n   */\n  public trackUserInteraction(interaction: UserInteractionData): void {\n    if (!this.isEnabled) return;\n\n    const current = this.getCurrentSessionData();\n\n    // Add to interactions array\n    current.userInteractions.push(interaction);\n\n    // Update average interaction latency metric\n    const totalInteractions = current.userInteractions.length;\n    const totalLatency = current.userInteractions.reduce(\n      (sum, interaction) => sum + interaction.responseTime,\n      0\n    );\n\n    current.metrics.interactionLatency = totalLatency / totalInteractions;\n  }\n\n  /**\n   * Track an error that occurred\n   */\n  public trackError(error: ErrorData): void {\n    if (!this.isEnabled) return;\n\n    // Apply error sampling\n    if (Math.random() > this.options.errorSamplingRate) {\n      return;\n    }\n\n    const current = this.getCurrentSessionData();\n    current.errors.push(error);\n  }\n\n  /**\n   * Get the current session's data object\n   */\n  private getCurrentSessionData(): SessionPerformanceData {\n    // If the last entry is older than 5 minutes, create a new entry\n    const lastEntry = this.performanceData[this.performanceData.length - 1];\n    const fiveMinutesAgo = Date.now() - 5 * 60 * 1000;\n\n    if (lastEntry.timestamp < fiveMinutesAgo) {\n      this.initializeCurrentSessionData();\n    }\n\n    return this.performanceData[this.performanceData.length - 1];\n  }\n\n  /**\n   * Transmit collected telemetry data to the server\n   */\n  private transmitTelemetryData(): void {\n    if (!this.isEnabled || this.performanceData.length === 0) return;\n\n    // Update event counts in the current session data\n    const current = this.getCurrentSessionData();\n    current.metrics.eventCounts = { ...this.accumulatedEventCounts };\n\n    // Reset accumulated counts after transferring\n    this.accumulatedEventCounts = {};\n\n    // Prepare data for transmission\n    const dataToTransmit = {\n      metadata: this.sessionMetadata,\n      performanceData: this.performanceData.slice(0, this.options.maxBatchSize),\n    };\n\n    // In a real implementation, we would transmit this data to a telemetry server\n    // For this implementation, we'll log it\n    console.warn('[SessionPerformanceTracker] Transmitting telemetry data:', dataToTransmit);\n\n    // After transmission, remove the transmitted entries except the current one\n    if (this.performanceData.length > 1) {\n      this.performanceData = this.performanceData.slice(this.options.maxBatchSize);\n    }\n\n    // Ensure we always have at least one entry\n    if (this.performanceData.length === 0) {\n      this.initializeCurrentSessionData();\n    }\n\n    this.lastTransmitTime = performance.now();\n  }\n\n  /**\n   * Force an immediate transmission of telemetry data\n   */\n  public flushTelemetryData(): void {\n    if (!this.isEnabled) return;\n\n    this.transmitTelemetryData();\n  }\n\n  /**\n   * Clean up resources\n   */\n  public cleanup(): void {\n    // Transmit any pending data\n    if (this.isEnabled) {\n      this.flushTelemetryData();\n    }\n\n    // Clear transmission interval\n    if (this.transmitInterval !== null) {\n      clearInterval(this.transmitInterval);\n      this.transmitInterval = null;\n    }\n\n    // Remove event subscription\n    if (this.eventSubscription) {\n      this.eventSubscription();\n      this.eventSubscription = null;\n    }\n\n    // Remove interaction observers\n    for (const unsubscribe of this.interactionObservers.values()) {\n      unsubscribe();\n    }\n    this.interactionObservers.clear();\n\n    // Clear data\n    this.performanceData = [];\n    this.componentLoadTimers.clear();\n    this.accumulatedEventCounts = {};\n\n    console.warn(\n      `[SessionPerformanceTracker] Cleaned up session: ${this.sessionMetadata.sessionId}`\n    );\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/services/telemetry/UserBehaviorCorrelationAnalysis.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'ResourceType' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 1,
        "column": 10,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 1,
        "endColumn": 22
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { ResourceType } from \"./../../types/resources/ResourceTypes\";\nimport { SessionPerformanceData, UserInteractionData } from './SessionPerformanceTracker';\n\n/**\n * Interface for user behavior pattern\n */\nexport interface UserBehaviorPattern {\n  patternType:\n    | 'frequent_interaction'\n    | 'rapid_sequence'\n    | 'complex_operation'\n    | 'sustained_activity'\n    | 'custom';\n  description: string;\n  frequency: number;\n  impactScore: number;\n  relatedMetrics: string[];\n  confidence: number;\n}\n\n/**\n * Interface for behavior-performance correlation result\n */\nexport interface BehaviorPerformanceCorrelation {\n  behaviorMetric: string;\n  performanceMetric: string;\n  correlationCoefficient: number;\n  significance: 'none' | 'weak' | 'moderate' | 'strong';\n  sampleSize: number;\n  description: string;\n}\n\n/**\n * Configuration options for behavior correlation analysis\n */\nexport interface BehaviorCorrelationConfig {\n  minDataPoints: number;\n  significanceThreshold: number;\n  timeWindowMs: number;\n  behaviorMetrics: string[];\n  performanceMetrics: string[];\n  groupSimilarInteractions: boolean;\n}\n\n/**\n * Service that analyzes correlations between user behavior and performance metrics\n */\nexport class UserBehaviorCorrelationAnalysis {\n  private config: BehaviorCorrelationConfig;\n\n  constructor(config?: Partial<BehaviorCorrelationConfig>) {\n    // Default configuration\n    this.config = {\n      minDataPoints: 10,\n      significanceThreshold: 0.3,\n      timeWindowMs: 60000, // 1 minute\n      behaviorMetrics: ['interactionFrequency', 'responseTime', 'interactionType'],\n      performanceMetrics: ['fps', 'renderTime', 'memoryUsage', 'cpuUsage'],\n      groupSimilarInteractions: true,\n      ...config,\n    };\n  }\n\n  /**\n   * Analyze correlation between user behavior and performance metrics\n   */\n  public analyzeCorrelations(sessions: SessionPerformanceData[]): BehaviorPerformanceCorrelation[] {\n    if (!sessions || sessions.length === 0) {\n      return [];\n    }\n\n    const correlations: BehaviorPerformanceCorrelation[] = [];\n\n    // Extract behavior metrics\n    const behaviorMetrics = this.extractBehaviorMetrics(sessions);\n\n    // Extract performance metrics\n    const performanceMetrics = this.extractPerformanceMetrics(sessions);\n\n    // Calculate correlations between behavior and performance metrics\n    for (const behaviorMetric of Object.keys(behaviorMetrics)) {\n      for (const performanceMetric of Object.keys(performanceMetrics)) {\n        const behaviorValues = behaviorMetrics[behaviorMetric];\n        const performanceValues = performanceMetrics[performanceMetric];\n\n        // Find matching timestamps (within the time window)\n        const pairedData: Array<[number, number]> = [];\n\n        behaviorValues.forEach(behaviorPoint => {\n          // Find performance points within the time window\n          const matchingPoints = performanceValues.filter(\n            perfPoint =>\n              Math.abs(perfPoint.timestamp - behaviorPoint.timestamp) <=\n              this.config.timeWindowMs / 2\n          );\n\n          if (matchingPoints.length > 0) {\n            // Use the average if multiple matching points\n            const avgPerformanceValue =\n              matchingPoints.reduce((sum, point) => sum + point.value, 0) / matchingPoints.length;\n            pairedData.push([behaviorPoint.value, avgPerformanceValue]);\n          }\n        });\n\n        // Only calculate correlation if we have enough data points\n        if (pairedData.length >= this.config.minDataPoints) {\n          const correlation = this.calculatePearsonCorrelation(\n            pairedData.map(pair => pair[0]),\n            pairedData.map(pair => pair[1])\n          );\n\n          // Determine significance\n          const significance = this.determineSignificance(correlation);\n\n          // Only include significant correlations\n          if (Math.abs(correlation) >= this.config.significanceThreshold) {\n            correlations.push({\n              behaviorMetric,\n              performanceMetric,\n              correlationCoefficient: correlation,\n              significance,\n              sampleSize: pairedData.length,\n              description: this.generateCorrelationDescription(\n                behaviorMetric,\n                performanceMetric,\n                correlation\n              ),\n            });\n          }\n        }\n      }\n    }\n\n    return correlations;\n  }\n\n  /**\n   * Identify user behavior patterns from session data\n   */\n  public identifyBehaviorPatterns(sessions: SessionPerformanceData[]): UserBehaviorPattern[] {\n    if (!sessions || sessions.length === 0) {\n      return [];\n    }\n\n    const patterns: UserBehaviorPattern[] = [];\n\n    // Aggregate all interactions across sessions\n    const allInteractions = sessions.flatMap(session => session.userInteractions);\n\n    // No interactions to analyze\n    if (allInteractions.length === 0) {\n      return [];\n    }\n\n    // Group interactions by type\n    const interactionsByType = this.groupInteractionsByType(allInteractions);\n\n    // Analyze frequent interaction patterns\n    this.analyzeFrequentInteractions(interactionsByType, patterns);\n\n    // Analyze rapid sequence patterns\n    this.analyzeRapidSequences(allInteractions, patterns);\n\n    // Analyze complex operations (sequences of different interaction types)\n    this.analyzeComplexOperations(allInteractions, patterns);\n\n    // Analyze sustained activity\n    this.analyzeSustainedActivity(sessions, patterns);\n\n    return patterns;\n  }\n\n  /**\n   * Extract behavior metrics from session data\n   */\n  private extractBehaviorMetrics(\n    sessions: SessionPerformanceData[]\n  ): Record<string, Array<{ timestamp: number; value: number }>> {\n    const metrics: Record<string, Array<{ timestamp: number; value: number }>> = {};\n\n    // Initialize metrics\n    for (const metric of this.config.behaviorMetrics) {\n      metrics[metric] = [];\n    }\n\n    sessions.forEach(session => {\n      // Skip sessions with no interactions\n      if (!session.userInteractions || session.userInteractions.length === 0) {\n        return;\n      }\n\n      // Calculate interaction frequency (interactions per minute)\n      if (this.config.behaviorMetrics.includes('interactionFrequency')) {\n        const sessionDurationMs =\n          Math.max(...session.userInteractions.map(i => i.timestamp)) -\n          Math.min(...session.userInteractions.map(i => i.timestamp));\n\n        if (sessionDurationMs > 0) {\n          const frequency = (session.userInteractions.length / sessionDurationMs) * 60000;\n          metrics['interactionFrequency'].push({\n            timestamp: session.timestamp,\n            value: frequency,\n          });\n        }\n      }\n\n      // Calculate average response time\n      if (this.config.behaviorMetrics.includes('responseTime')) {\n        const avgResponseTime =\n          session.userInteractions.reduce((sum, interaction) => sum + interaction.responseTime, 0) /\n          session.userInteractions.length;\n\n        metrics['responseTime'].push({\n          timestamp: session.timestamp,\n          value: avgResponseTime,\n        });\n      }\n\n      // Calculate interaction type frequencies\n      if (this.config.behaviorMetrics.includes('interactionType')) {\n        const typeCount: Record<string, number> = {};\n\n        session.userInteractions.forEach(interaction => {\n          typeCount[interaction.interactionType] =\n            (typeCount[interaction.interactionType] || 0) + 1;\n        });\n\n        Object.entries(typeCount).forEach(([type, count]) => {\n          metrics[`interactionType:${type}`] = metrics[`interactionType:${type}`] || [];\n          metrics[`interactionType:${type}`].push({\n            timestamp: session.timestamp,\n            value: count,\n          });\n        });\n      }\n    });\n\n    return metrics;\n  }\n\n  /**\n   * Extract performance metrics from session data\n   */\n  private extractPerformanceMetrics(\n    sessions: SessionPerformanceData[]\n  ): Record<string, Array<{ timestamp: number; value: number }>> {\n    const metrics: Record<string, Array<{ timestamp: number; value: number }>> = {};\n\n    // Initialize metrics\n    for (const metric of this.config.performanceMetrics) {\n      metrics[metric] = [];\n    }\n\n    sessions.forEach(session => {\n      // Extract standard performance metrics\n      if (this.config.performanceMetrics.includes('fps')) {\n        metrics['fps'].push({\n          timestamp: session.timestamp,\n          value: session.metrics.fps,\n        });\n      }\n\n      if (this.config.performanceMetrics.includes('renderTime')) {\n        metrics['renderTime'].push({\n          timestamp: session.timestamp,\n          value: session.metrics.renderTime,\n        });\n      }\n\n      if (this.config.performanceMetrics.includes('memoryUsage')) {\n        metrics['memoryUsage'].push({\n          timestamp: session.timestamp,\n          value: session.metrics.memoryUsage,\n        });\n      }\n\n      if (this.config.performanceMetrics.includes('cpuUsage')) {\n        metrics['cpuUsage'].push({\n          timestamp: session.timestamp,\n          value: session.metrics.cpuUsage,\n        });\n      }\n\n      if (this.config.performanceMetrics.includes('interactionLatency')) {\n        metrics['interactionLatency'].push({\n          timestamp: session.timestamp,\n          value: session.metrics.interactionLatency,\n        });\n      }\n\n      // Extract resource utilization metrics\n      session.metrics.resourceUtilization.forEach((value, resourceType) => {\n        const metricName = `resourceUtilization:${resourceType}`;\n\n        if (this.config.performanceMetrics.includes(metricName)) {\n          metrics[metricName] = metrics[metricName] || [];\n          metrics[metricName].push({\n            timestamp: session.timestamp,\n            value,\n          });\n        }\n      });\n\n      // Extract event processing time\n      if (this.config.performanceMetrics.includes('eventProcessingTime')) {\n        metrics['eventProcessingTime'].push({\n          timestamp: session.timestamp,\n          value: session.metrics.eventProcessingTime,\n        });\n      }\n    });\n\n    return metrics;\n  }\n\n  /**\n   * Calculate Pearson correlation coefficient\n   */\n  private calculatePearsonCorrelation(xValues: number[], yValues: number[]): number {\n    if (xValues.length !== yValues.length || xValues.length === 0) {\n      return 0;\n    }\n\n    const n = xValues.length;\n\n    // Calculate means\n    const meanX = xValues.reduce((sum, x) => sum + x, 0) / n;\n    const meanY = yValues.reduce((sum, y) => sum + y, 0) / n;\n\n    // Calculate covariance and variances\n    let covariance = 0;\n    let varianceX = 0;\n    let varianceY = 0;\n\n    for (let i = 0; i < n; i++) {\n      const diffX = xValues[i] - meanX;\n      const diffY = yValues[i] - meanY;\n\n      covariance += diffX * diffY;\n      varianceX += diffX * diffX;\n      varianceY += diffY * diffY;\n    }\n\n    // Avoid division by zero\n    if (varianceX === 0 || varianceY === 0) {\n      return 0;\n    }\n\n    return covariance / Math.sqrt(varianceX * varianceY);\n  }\n\n  /**\n   * Determine the significance of a correlation coefficient\n   */\n  private determineSignificance(correlation: number): 'none' | 'weak' | 'moderate' | 'strong' {\n    const absCorrelation = Math.abs(correlation);\n\n    if (absCorrelation < 0.3) {\n      return 'none';\n    } else if (absCorrelation < 0.5) {\n      return 'weak';\n    } else if (absCorrelation < 0.7) {\n      return 'moderate';\n    } else {\n      return 'strong';\n    }\n  }\n\n  /**\n   * Generate a description for a correlation\n   */\n  private generateCorrelationDescription(\n    behaviorMetric: string,\n    performanceMetric: string,\n    correlation: number\n  ): string {\n    const direction = correlation > 0 ? 'positive' : 'negative';\n    const strength = this.determineSignificance(correlation);\n\n    let behaviorDescription = behaviorMetric;\n    if (behaviorMetric.startsWith('interactionType:')) {\n      behaviorDescription = `${behaviorMetric.split(':')[1]} interactions`;\n    }\n\n    let performanceDescription = performanceMetric;\n    if (performanceMetric.startsWith('resourceUtilization:')) {\n      performanceDescription = `${performanceMetric.split(':')[1]} utilization`;\n    }\n\n    let impactDescription = '';\n    if (direction === 'positive') {\n      impactDescription = `As ${behaviorDescription} increases, ${performanceDescription} tends to increase`;\n    } else {\n      impactDescription = `As ${behaviorDescription} increases, ${performanceDescription} tends to decrease`;\n    }\n\n    if (strength === 'none' || strength === 'weak') {\n      return `${impactDescription}, but the relationship is ${strength} (${correlation.toFixed(2)}).`;\n    } else {\n      return `${impactDescription}. This shows a ${strength} ${direction} correlation (${correlation.toFixed(2)}).`;\n    }\n  }\n\n  /**\n   * Group interactions by their type\n   */\n  private groupInteractionsByType(\n    interactions: UserInteractionData[]\n  ): Record<string, UserInteractionData[]> {\n    const grouped: Record<string, UserInteractionData[]> = {};\n\n    interactions.forEach(interaction => {\n      const type = interaction.interactionType;\n      grouped[type] = grouped[type] || [];\n      grouped[type].push(interaction);\n    });\n\n    return grouped;\n  }\n\n  /**\n   * Analyze frequent interaction patterns\n   */\n  private analyzeFrequentInteractions(\n    interactionsByType: Record<string, UserInteractionData[]>,\n    patterns: UserBehaviorPattern[]\n  ): void {\n    const totalInteractions = Object.values(interactionsByType).flat().length;\n\n    if (totalInteractions === 0) {\n      return;\n    }\n\n    Object.entries(interactionsByType).forEach(([type, interactions]) => {\n      const frequency = interactions.length / totalInteractions;\n\n      if (frequency > 0.2) {\n        // If the interaction type makes up more than 20% of all interactions\n        patterns.push({\n          patternType: 'frequent_interaction',\n          description: `Frequent use of ${type} interactions (${Math.round(frequency * 100)}% of all interactions)`,\n          frequency,\n          impactScore: frequency * 0.8, // Impact score based on frequency\n          relatedMetrics: ['interactionFrequency', `interactionType:${type}`],\n          confidence: 0.7 + frequency * 0.3, // Higher confidence for more frequent patterns\n        });\n      }\n    });\n  }\n\n  /**\n   * Analyze rapid sequence patterns (multiple interactions in quick succession)\n   */\n  private analyzeRapidSequences(\n    interactions: UserInteractionData[],\n    patterns: UserBehaviorPattern[]\n  ): void {\n    if (interactions.length < 3) {\n      return;\n    }\n\n    // Sort interactions by timestamp\n    const sortedInteractions = [...interactions].sort((a, b) => a.timestamp - b.timestamp);\n\n    // Look for rapid sequences (interactions within 1 second of each other)\n    const rapidSequences: UserInteractionData[][] = [];\n    let currentSequence: UserInteractionData[] = [sortedInteractions[0]];\n\n    for (let i = 1; i < sortedInteractions.length; i++) {\n      const current = sortedInteractions[i];\n      const previous = sortedInteractions[i - 1];\n\n      if (current.timestamp - previous.timestamp <= 1000) {\n        currentSequence.push(current);\n      } else {\n        if (currentSequence.length >= 3) {\n          rapidSequences.push([...currentSequence]);\n        }\n        currentSequence = [current];\n      }\n    }\n\n    // Add the last sequence if it's rapid\n    if (currentSequence.length >= 3) {\n      rapidSequences.push(currentSequence);\n    }\n\n    // Analyze rapid sequences\n    rapidSequences.forEach(sequence => {\n      const types = new Set(sequence.map(i => i.interactionType));\n      const avgResponseTime =\n        sequence.reduce((sum, i) => sum + i.responseTime, 0) / sequence.length;\n\n      patterns.push({\n        patternType: 'rapid_sequence',\n        description: `Rapid sequence of ${sequence.length} interactions (${Array.from(types).join(', ')})`,\n        frequency: sequence.length / interactions.length,\n        impactScore: 0.6 + (avgResponseTime > 100 ? 0.3 : 0), // Higher impact if response time is slow\n        relatedMetrics: ['responseTime', 'interactionFrequency'],\n        confidence: 0.6 + sequence.length / 20, // Higher confidence for longer sequences, max 0.9\n      });\n    });\n  }\n\n  /**\n   * Analyze complex operations (sequences of different interaction types)\n   */\n  private analyzeComplexOperations(\n    interactions: UserInteractionData[],\n    patterns: UserBehaviorPattern[]\n  ): void {\n    if (interactions.length < 5) {\n      return;\n    }\n\n    // Sort interactions by timestamp\n    const sortedInteractions = [...interactions].sort((a, b) => a.timestamp - b.timestamp);\n\n    // Look for complex operations (sequences of 5+ interactions with at least 3 different types within 5 seconds)\n    const complexOperations: UserInteractionData[][] = [];\n    let currentOperation: UserInteractionData[] = [sortedInteractions[0]];\n\n    for (let i = 1; i < sortedInteractions.length; i++) {\n      const current = sortedInteractions[i];\n      const operationStart = currentOperation[0];\n\n      if (current.timestamp - operationStart.timestamp <= 5000) {\n        currentOperation.push(current);\n      } else {\n        const uniqueTypes = new Set(currentOperation.map(i => i.interactionType));\n        if (currentOperation.length >= 5 && uniqueTypes.size >= 3) {\n          complexOperations.push([...currentOperation]);\n        }\n        currentOperation = [current];\n      }\n    }\n\n    // Add the last operation if it's complex\n    const uniqueTypes = new Set(currentOperation.map(i => i.interactionType));\n    if (currentOperation.length >= 5 && uniqueTypes.size >= 3) {\n      complexOperations.push(currentOperation);\n    }\n\n    // Analyze complex operations\n    complexOperations.forEach(operation => {\n      const types = new Set(operation.map(i => i.interactionType));\n      const typeCount = Array.from(types)\n        .map(type => `${type} (${operation.filter(i => i.interactionType === type).length})`)\n        .join(', ');\n\n      patterns.push({\n        patternType: 'complex_operation',\n        description: `Complex operation with ${operation.length} interactions: ${typeCount}`,\n        frequency: operation.length / interactions.length,\n        impactScore: 0.7 + types.size / 10, // Higher impact for more diverse operations\n        relatedMetrics: ['responseTime', 'eventProcessingTime', 'cpuUsage'],\n        confidence: 0.7,\n      });\n    });\n  }\n\n  /**\n   * Analyze sustained activity patterns\n   */\n  private analyzeSustainedActivity(\n    sessions: SessionPerformanceData[],\n    patterns: UserBehaviorPattern[]\n  ): void {\n    // Find sessions with continuous activity for extended periods\n    sessions.forEach(session => {\n      if (!session.userInteractions || session.userInteractions.length < 10) {\n        return;\n      }\n\n      // Sort interactions by timestamp\n      const sortedInteractions = [...session.userInteractions].sort(\n        (a, b) => a.timestamp - b.timestamp\n      );\n\n      // Calculate session duration\n      const sessionDuration =\n        sortedInteractions[sortedInteractions.length - 1].timestamp -\n        sortedInteractions[0].timestamp;\n\n      // Calculate average time between interactions\n      let totalGap = 0;\n      for (let i = 1; i < sortedInteractions.length; i++) {\n        totalGap += sortedInteractions[i].timestamp - sortedInteractions[i - 1].timestamp;\n      }\n      const avgGap = totalGap / (sortedInteractions.length - 1);\n\n      // If session is longer than 5 minutes and has consistent activity\n      if (sessionDuration > 300000 && avgGap < 30000) {\n        patterns.push({\n          patternType: 'sustained_activity',\n          description: `Sustained activity for ${Math.round(sessionDuration / 60000)} minutes with ${sortedInteractions.length} interactions`,\n          frequency: sortedInteractions.length / sessionDuration,\n          impactScore: 0.8,\n          relatedMetrics: ['memoryUsage', 'cpuUsage', 'fps'],\n          confidence: 0.8,\n        });\n      }\n    });\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/systems/exploration/DiscoveryClassification.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'signatureAnalysis' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 182,
        "column": 5,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 182,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'compositionAnalysis' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 183,
        "column": 5,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 183,
        "endColumn": 24
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'discovery' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 189,
        "column": 35,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 189,
        "endColumn": 44
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'discovery' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 193,
        "column": 31,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 193,
        "endColumn": 40
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'discovery' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 197,
        "column": 32,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 197,
        "endColumn": 41
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'discovery' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 201,
        "column": 35,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 201,
        "endColumn": 44
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'discovery' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 205,
        "column": 33,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 205,
        "endColumn": 42
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'discovery' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 209,
        "column": 35,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 209,
        "endColumn": 44
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'discovery' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 213,
        "column": 35,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 213,
        "endColumn": 44
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'discovery' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 217,
        "column": 37,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 217,
        "endColumn": 46
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'composition' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 221,
        "column": 27,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 221,
        "endColumn": 38
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'pressure' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 225,
        "column": 28,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 225,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'temperature' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 225,
        "column": 46,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 225,
        "endColumn": 57
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'location' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 229,
        "column": 34,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 229,
        "endColumn": 42
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'metadata' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 233,
        "column": 34,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 233,
        "endColumn": 42
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'metadata' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 241,
        "column": 33,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 241,
        "endColumn": 41
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'metadata' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 249,
        "column": 33,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 249,
        "endColumn": 41
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'metadata' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 257,
        "column": 28,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 257,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'metadata' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 261,
        "column": 28,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 261,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'result' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 269,
        "column": 40,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 269,
        "endColumn": 46
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'result' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 273,
        "column": 31,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 273,
        "endColumn": 37
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'result' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 277,
        "column": 31,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 277,
        "endColumn": 37
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'result' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 281,
        "column": 42,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 281,
        "endColumn": 48
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 23,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { EventBus } from '../../lib/events/EventBus';\nimport { Vector3D } from '../../types/common/VectorTypes';\nimport { ExplorationEvents } from '../../types/events/ExplorationEvents';\nimport {\n  Classification,\n  ClassificationResult,\n  Discovery,\n  DiscoveryType,\n} from '../../types/exploration/ExplorationTypes';\nimport { ResourceType } from \"./../../types/resources/ResourceTypes\";\n\nexport interface ClassificationConfig {\n  minAnalysisThreshold: number;\n  maxAnalysisAttempts: number;\n  analysisTimeout: number;\n  confidenceThreshold: number;\n}\n\nexport class DiscoveryClassification {\n  private config: ClassificationConfig;\n  private eventBus: EventBus;\n  private analysisCache: Map<string, ClassificationResult>;\n  private activeAnalysis: Set<string>;\n\n  constructor(config: ClassificationConfig, eventBus: EventBus) {\n    this.config = config;\n    this.eventBus = eventBus;\n    this.analysisCache = new Map();\n    this.activeAnalysis = new Set();\n  }\n\n  public async classifyDiscovery(discovery: Discovery): Promise<Classification> {\n    if (this.activeAnalysis.has(discovery.id)) {\n      throw new Error(`Analysis already in progress for discovery ${discovery.id}`);\n    }\n\n    try {\n      this.activeAnalysis.add(discovery.id);\n      const result = await this.performClassification(discovery);\n      this.cacheResult(discovery.id, result);\n      return this.createClassification(discovery, result);\n    } finally {\n      this.activeAnalysis.delete(discovery.id);\n    }\n  }\n\n  private async performClassification(discovery: Discovery): Promise<ClassificationResult> {\n    const cachedResult = this.analysisCache.get(discovery.id);\n    if (cachedResult && this.isResultValid(cachedResult)) {\n      return cachedResult;\n    }\n\n    const analysisStart = performance.now();\n    const result = await this.analyzeDiscovery(discovery);\n\n    if (result.confidence < this.config.confidenceThreshold) {\n      await this.enhanceAnalysis(discovery, result);\n    }\n\n    this.publishAnalysisMetrics(discovery, result, performance.now() - analysisStart);\n    return result;\n  }\n\n  private async analyzeDiscovery(discovery: Discovery): Promise<ClassificationResult> {\n    switch (discovery.type) {\n      case DiscoveryType.RESOURCE_DEPOSIT:\n        return this.analyzeResourceDeposit(discovery);\n      case DiscoveryType.ALIEN_ARTIFACT:\n        return this.analyzeAlienArtifact(discovery);\n      case DiscoveryType.ANOMALY:\n        return this.analyzeAnomaly(discovery);\n      case DiscoveryType.DERELICT:\n        return this.analyzeDerelict(discovery);\n      case DiscoveryType.SPATIAL_PHENOMENON:\n        return this.analyzeSpatialPhenomenon(discovery);\n      default:\n        throw new Error(`Unknown discovery type: ${discovery.type}`);\n    }\n  }\n\n  private async analyzeResourceDeposit(discovery: Discovery): Promise<ClassificationResult> {\n    const analysis = {\n      type: DiscoveryType.RESOURCE_DEPOSIT,\n      confidence: 0,\n      details: {\n        resourceType: this.determineResourceType(discovery),\n        estimatedQuantity: this.estimateResourceQuantity(discovery),\n        extractionDifficulty: this.calculateExtractionDifficulty(discovery),\n        qualityIndicators: this.analyzeResourceQuality(discovery),\n      },\n    };\n\n    analysis.confidence = this.calculateConfidence(analysis);\n    return analysis;\n  }\n\n  private async analyzeAlienArtifact(discovery: Discovery): Promise<ClassificationResult> {\n    return {\n      type: DiscoveryType.ALIEN_ARTIFACT,\n      confidence: 0.85,\n      details: {\n        artifactOrigin: this.determineArtifactOrigin(discovery),\n        artifactAge: this.estimateArtifactAge(discovery),\n      },\n      timestamp: Date.now(),\n      analysisTime: 0,\n      enhancementApplied: false,\n    };\n  }\n\n  private async analyzeAnomaly(discovery: Discovery): Promise<ClassificationResult> {\n    return {\n      type: DiscoveryType.ANOMALY,\n      confidence: 0.75,\n      details: {\n        anomalyType: this.determineAnomalyType(discovery),\n        anomalyIntensity: this.measureAnomalyIntensity(discovery),\n      },\n      timestamp: Date.now(),\n      analysisTime: 0,\n      enhancementApplied: false,\n    };\n  }\n\n  private async analyzeDerelict(discovery: Discovery): Promise<ClassificationResult> {\n    return {\n      type: DiscoveryType.DERELICT,\n      confidence: 0.9,\n      details: {\n        derelictType: this.determineDerelictType(discovery),\n        derelictCondition: this.assessDerelictCondition(discovery),\n      },\n      timestamp: Date.now(),\n      analysisTime: 0,\n      enhancementApplied: false,\n    };\n  }\n\n  private async analyzeSpatialPhenomenon(discovery: Discovery): Promise<ClassificationResult> {\n    return {\n      type: DiscoveryType.SPATIAL_PHENOMENON,\n      confidence: 0.8,\n      details: {\n        phenomenonType: this.determinePhenomenonType(discovery),\n        phenomenonStability: this.assessPhenomenonStability(discovery),\n      },\n      timestamp: Date.now(),\n      analysisTime: 0,\n      enhancementApplied: false,\n    };\n  }\n\n  private determineResourceType(discovery: Discovery): ResourceType {\n    const signatureAnalysis = this.analyzeResourceSignature(discovery);\n    const compositionAnalysis = this.analyzeComposition(discovery);\n    return this.reconcileResourceAnalysis(signatureAnalysis, compositionAnalysis);\n  }\n\n  private estimateResourceQuantity(discovery: Discovery): number {\n    const { densityMapping } = discovery.metadata.scanData;\n    return densityMapping.reduce((sum, density) => sum + density, 0) * 100;\n  }\n\n  private calculateExtractionDifficulty(discovery: Discovery): number {\n    const { structuralIntegrity } = discovery.metadata.scanData;\n    return 1 - structuralIntegrity;\n  }\n\n  private analyzeResourceQuality(discovery: Discovery): QualityIndicators {\n    const { elementalComposition, structuralIntegrity } = discovery.metadata.scanData;\n    const { pressure, temperature } = discovery.metadata.initialReadings;\n\n    return {\n      purity: this.calculatePurity(elementalComposition),\n      density: this.calculateDensity(pressure, temperature),\n      stability: structuralIntegrity,\n      accessibility: this.calculateAccessibility(discovery.location),\n    };\n  }\n\n  private reconcileResourceAnalysis(\n    signatureAnalysis: ResourceSignature,\n    compositionAnalysis: CompositionAnalysis\n  ): ResourceType {\n    // Implement reconciliation logic\n    return ResourceType.IRON; // Placeholder\n  }\n\n  private determineArtifactOrigin(discovery: Discovery): string {\n    return 'Unknown Origin'; // Placeholder\n  }\n\n  private estimateArtifactAge(discovery: Discovery): number {\n    return 1000; // Placeholder\n  }\n\n  private determineAnomalyType(discovery: Discovery): string {\n    return 'Unknown Anomaly'; // Placeholder\n  }\n\n  private measureAnomalyIntensity(discovery: Discovery): number {\n    return 0.5; // Placeholder\n  }\n\n  private determineDerelictType(discovery: Discovery): string {\n    return 'Unknown Vessel'; // Placeholder\n  }\n\n  private assessDerelictCondition(discovery: Discovery): number {\n    return 0.7; // Placeholder\n  }\n\n  private determinePhenomenonType(discovery: Discovery): string {\n    return 'Unknown Phenomenon'; // Placeholder\n  }\n\n  private assessPhenomenonStability(discovery: Discovery): number {\n    return 0.6; // Placeholder\n  }\n\n  private calculatePurity(composition: Map<string, number>): number {\n    return 0.8; // Placeholder\n  }\n\n  private calculateDensity(pressure: number, temperature: number): number {\n    return 0.9; // Placeholder\n  }\n\n  private calculateAccessibility(location: Vector3D): number {\n    return 0.7; // Placeholder\n  }\n\n  private analyzeSpectralProfile(metadata: unknown): SpectralProfile {\n    return {\n      wavelengths: [],\n      intensities: [],\n      absorption: [],\n    };\n  }\n\n  private analyzeDensityProfile(metadata: unknown): DensityProfile {\n    return {\n      average: 0,\n      variation: 0,\n      distribution: [],\n    };\n  }\n\n  private analyzeThermalProfile(metadata: unknown): ThermalProfile {\n    return {\n      temperature: 0,\n      conductivity: 0,\n      signature: [],\n    };\n  }\n\n  private identifyElements(metadata: unknown): ElementProfile[] {\n    return [];\n  }\n\n  private analyzeStructure(metadata: unknown): StructureAnalysis {\n    return {\n      crystallinity: 0,\n      porosity: 0,\n      stability: 0,\n    };\n  }\n\n  private validateAnalysisCompleteness(result: ClassificationResult): number {\n    return 0.9; // Placeholder\n  }\n\n  private validateDataQuality(result: ClassificationResult): number {\n    return 0.85; // Placeholder\n  }\n\n  private validateConsistency(result: ClassificationResult): number {\n    return 0.95; // Placeholder\n  }\n\n  private determineEnhancementStrategies(result: ClassificationResult): EnhancementStrategy[] {\n    return []; // Placeholder\n  }\n\n  private updateAnalysisResult(discoveryId: string, enhancedResult: ClassificationResult): void {\n    this.analysisCache.set(discoveryId, enhancedResult);\n  }\n\n  private createClassification(discovery: Discovery, result: ClassificationResult): Classification {\n    return {\n      id: discovery.id,\n      type: result.type,\n      confidence: result.confidence,\n      details: result.details,\n      timestamp: Date.now(),\n      metadata: {\n        analysisVersion: '1.0',\n        analysisTime: result.analysisTime,\n        enhancementApplied: result.enhancementApplied,\n      },\n    };\n  }\n\n  private calculateConfidence(result: ClassificationResult): number {\n    const factors = [\n      this.validateAnalysisCompleteness(result),\n      this.validateDataQuality(result),\n      this.validateConsistency(result),\n    ];\n\n    return factors.reduce((acc, factor) => acc * factor, 1);\n  }\n\n  private isResultValid(result: ClassificationResult): boolean {\n    const age = Date.now() - result.timestamp;\n    return (\n      result.confidence >= this.config.confidenceThreshold && age < this.config.analysisTimeout\n    );\n  }\n\n  private cacheResult(discoveryId: string, result: ClassificationResult): void {\n    this.analysisCache.set(discoveryId, {\n      ...result,\n      timestamp: Date.now(),\n    });\n  }\n\n  private publishAnalysisMetrics(\n    discovery: Discovery,\n    result: ClassificationResult,\n    duration: number\n  ): void {\n    this.eventBus.publish({\n      type: ExplorationEvents.DISCOVERY_ANALYZED,\n      timestamp: Date.now(),\n      id: discovery.id,\n      payload: {\n        discoveryId: discovery.id,\n        classificationType: result.type,\n        confidence: result.confidence,\n        duration,\n        enhancementApplied: result.enhancementApplied,\n      },\n    });\n  }\n}\n\ninterface EnhancementStrategy {\n  execute(discovery: Discovery, initialResult: ClassificationResult): Promise<ClassificationResult>;\n}\n\n// Helper interfaces\ninterface ResourceSignature {\n  spectralProfile: SpectralProfile;\n  densityProfile: DensityProfile;\n  thermalProfile: ThermalProfile;\n}\n\ninterface CompositionAnalysis {\n  elements: ElementProfile[];\n  structure: StructureAnalysis;\n  purity: number;\n}\n\ninterface SpectralProfile {\n  wavelengths: number[];\n  intensities: number[];\n  absorption: number[];\n}\n\ninterface DensityProfile {\n  average: number;\n  variation: number;\n  distribution: number[];\n}\n\ninterface ThermalProfile {\n  temperature: number;\n  conductivity: number;\n  signature: number[];\n}\n\ninterface ElementProfile {\n  element: string;\n  concentration: number;\n  distribution: number[];\n}\n\ninterface StructureAnalysis {\n  crystallinity: number;\n  porosity: number;\n  stability: number;\n}\n\ninterface QualityIndicators {\n  purity: number;\n  density: number;\n  stability: number;\n  accessibility: number;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/TypeUtils.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'error' is defined but never used. Allowed unused caught errors must match /^_/u.",
        "line": 202,
        "column": 12,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 202,
        "endColumn": 17
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * @file TypeUtils.ts\n * Utility types and functions for improved type safety across the codebase\n *\n * This file provides:\n * 1. Generic type utilities to reduce the need for \"as unknown as\" casts\n * 2. Type guards for common operations\n * 3. Helper types for event handling and data processing\n * 4. Unified interfaces that work in both production and test code\n */\n\n/**\n * Type-safe cast utility - use this instead of \"as unknown as\" when possible\n * Generic function that provides a safer way to cast from one type to another\n * when you need to bypass TypeScript's type system but maintain type safety.\n */\nexport function typeCast<T, U>(value: T): U {\n  return value as unknown as U;\n}\n\n/**\n * Runtime type checking utilities - use these to verify types at runtime\n */\n\n/**\n * Helper to check if a value is a non-null object\n */\nexport function isObject(value: unknown): value is Record<string, unknown> {\n  return typeof value === 'object' && value !== null;\n}\n\n/**\n * Helper to check if a value has a specific property\n */\nexport function hasProperty<K extends string>(\n  value: unknown,\n  property: K\n): value is { [P in K]: unknown } {\n  return isObject(value) && property in value;\n}\n\n/**\n * Helper to check if a value has specific properties\n */\nexport function hasProperties<K extends string>(\n  value: unknown,\n  properties: K[]\n): value is { [P in K]: unknown } {\n  if (!isObject(value)) return false;\n  return properties.every(prop => prop in value);\n}\n\n/**\n * Generic class property type - gets the type of a property on a class\n */\nexport type PropertyType<T, K extends keyof T> = T[K];\n\n/**\n * Event handler types - unify event handling patterns\n */\nexport type EventHandler<T> = (event: T) => void;\nexport type AsyncEventHandler<T> = (event: T) => Promise<void>;\nexport type EventUnsubscribe = () => void;\n\n/**\n * EventEmitter interface that works for both testing and production\n */\nexport interface EventEmitter<T> {\n  emit(event: T): void;\n  on(handler: EventHandler<T>): EventUnsubscribe;\n  off(handler: EventHandler<T>): void;\n}\n\n/**\n * Manager interface base - for consistent manager implementations\n */\nexport interface Manager {\n  initialize(): void | Promise<void>;\n  dispose(): void;\n}\n\n/**\n * Types for dealing with nullable values\n */\nexport type Nullable<T> = T | null;\nexport type Optional<T> = T | undefined;\n\n/**\n * Type safe extraction from data objects with unknown structure\n */\nexport function getPropertySafe<T>(obj: unknown, path: string, defaultValue: T): T {\n  if (!isObject(obj)) return defaultValue;\n\n  const parts = path.split('.');\n  let current: unknown = obj;\n\n  for (const part of parts) {\n    if (!isObject(current) || !(part in current)) {\n      return defaultValue;\n    }\n    current = current[part];\n  }\n\n  return current as unknown as T;\n}\n\n/**\n * Narrowing helper for discriminated unions\n */\nexport function isOfType<T, K extends string>(\n  obj: unknown,\n  discriminator: K,\n  value: string\n): obj is T & { [P in K]: string } {\n  return (\n    isObject(obj) &&\n    hasProperty(obj, discriminator) &&\n    typeof obj[discriminator] === 'string' &&\n    obj[discriminator] === value\n  );\n}\n\n/**\n * Type-safe partial - preserves required vs optional properties\n */\nexport type StrictPartial<T> = {\n  [P in keyof T]?: T[P] extends Record<string, unknown> ? StrictPartial<T[P]> : T[P];\n};\n\n/**\n * Data transformation utilities - for safely working with any type\n */\nexport function safeMapRecord<T extends Record<string, unknown>, U>(\n  record: T,\n  mapFn: (value: unknown, key: string) => U\n): Record<string, U> {\n  return Object.fromEntries(Object.entries(record).map(([key, value]) => [key, mapFn(value, key)]));\n}\n\n/**\n * Safe array mapper - ensures type safety when mapping arrays\n */\nexport function safeMap<T, U>(\n  array: unknown[],\n  predicate: (item: unknown) => item is T,\n  mapFn: (item: T) => U\n): U[] {\n  return array.filter(predicate).map(mapFn);\n}\n\n/**\n * Type guard factory - creates type guards for specific interfaces\n */\nexport function createTypeGuard<T>(\n  properties: Array<keyof T>,\n  typeChecks: Partial<Record<keyof T, (val: unknown) => boolean>> = {}\n): (obj: unknown) => obj is T {\n  return (obj: unknown): obj is T => {\n    if (!isObject(obj)) return false;\n\n    // Check that all required properties exist\n    if (!properties.every(prop => prop in obj)) return false;\n\n    // Apply custom type checks if provided\n    return Object.entries(typeChecks).every(([prop, check]) => {\n      if (!(prop in obj)) return false;\n      if (check && typeof check === 'function') {\n        return check(obj[prop]);\n      }\n      return true;\n    });\n  };\n}\n\n/**\n * Type-safe event mapper - converts event data safely\n */\nexport function mapEventData<T, U>(\n  eventData: unknown,\n  predicate: (data: unknown) => data is T,\n  mapper: (data: T) => U\n): U | undefined {\n  if (predicate(eventData)) {\n    return mapper(eventData);\n  }\n  return undefined;\n}\n\n/**\n * Type-safe object property accessor\n */\nexport function getProperty<T, K extends keyof T>(obj: T, property: K): T[K] {\n  return obj[property];\n}\n\n/**\n * Type-safe JSON parsing with a fallback\n */\nexport function safeJsonParse<T>(json: string, fallback: T): T {\n  try {\n    return JSON.parse(json) as T;\n  } catch (error) {\n    return fallback;\n  }\n}\n\n/**\n * Creates a type-safe function that casts to a specific enum\n */\nexport function createEnumParser<T extends Record<string, string | number>>(\n  enumObj: T\n): (value: string) => T[keyof T] | undefined {\n  const validValues = Object.values(enumObj);\n  return (value: string) => {\n    const enumValue = enumObj[value as keyof T];\n    if (enumValue !== undefined) return enumValue;\n\n    // Check if the value itself matches any enum value\n    if (validValues.includes(value as T[keyof T])) {\n      return value as T[keyof T];\n    }\n\n    return undefined;\n  };\n}\n\n/**\n * Deep readonly type for immutable data\n */\nexport type DeepReadonly<T> = T extends (infer R)[]\n  ? ReadonlyArray<DeepReadonly<R>>\n  : T extends (...args: unknown[]) => unknown\n    ? T\n    : T extends object\n      ? { readonly [P in keyof T]: DeepReadonly<T[P]> }\n      : T;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/buildings/ModuleTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/buildings/ShipHangarTypes.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'ResourceType' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 1,
        "column": 10,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 1,
        "endColumn": 22
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { ResourceType } from \"./../resources/ResourceTypes\";\nimport { Effect, Tier } from '../core/GameTypes';\nimport { ResourceCost } from '../resources/ResourceTypes';\nimport { CommonShip } from '../ships/CommonShipTypes';\nimport { PlayerShipCategory, PlayerShipClass } from '../ships/PlayerShipTypes';\n\n/**\n * Ship build queue item\n */\nexport interface ShipBuildQueueItem {\n  id: string;\n  shipClass: PlayerShipClass;\n  progress: number;\n  startTime: number;\n  duration: number;\n  resourceCost: ResourceCost[];\n  tier: Tier;\n  status: 'building' | 'paused' | 'completed';\n  pausedAt?: number;\n  totalPausedTime?: number;\n}\n\n/**\n * Ship hangar bay\n */\nexport interface ShipHangarBay {\n  id: string;\n  tier: Tier;\n  capacity: number;\n  ships: CommonShip[];\n  status: 'available' | 'full' | 'upgrading';\n  efficiency: number;\n  lastMaintenance: number;\n  maintenanceCost: ResourceCost[];\n}\n\n/**\n * Ship hangar state\n */\nexport interface ShipHangarState {\n  tier: Tier;\n  buildQueue: ShipBuildQueueItem[];\n  bays: ShipHangarBay[];\n  maxQueueSize: number;\n  buildSpeedMultiplier: number;\n  resourceEfficiency: number;\n}\n\n/**\n * Ship upgrade requirements\n */\nexport interface ShipUpgradeRequirement {\n  type: 'tech' | 'resource' | 'facility';\n  name: string;\n  met: boolean;\n}\n\n/**\n * Ship upgrade stats\n */\nexport interface ShipUpgradeStats {\n  hull: {\n    current: number;\n    upgraded: number;\n  };\n  shield: {\n    current: number;\n    upgraded: number;\n  };\n  weapons: {\n    current: number;\n    upgraded: number;\n  };\n  speed: {\n    current: number;\n    upgraded: number;\n  };\n}\n\n/**\n * Ship visual upgrade\n */\nexport interface ShipVisualUpgrade {\n  name: string;\n  description: string;\n  preview: string;\n}\n\n/**\n * Ship upgrade info\n */\nexport interface ShipUpgradeInfo {\n  shipId: string;\n  tier: Tier;\n  upgradeAvailable: boolean;\n  requirements: ShipUpgradeRequirement[];\n  stats: ShipUpgradeStats;\n  resourceCost: ResourceCost[];\n  visualUpgrades: ShipVisualUpgrade[];\n}\n\n/**\n * Ship hangar events\n */\nexport interface ShipHangarEvents {\n  buildStarted: {\n    queueItem: ShipBuildQueueItem;\n  };\n  buildCompleted: {\n    ship: CommonShip;\n    bay: ShipHangarBay;\n  };\n  buildCancelled: {\n    queueItemId: string;\n    refundedResources: ResourceCost[];\n  };\n  buildProgressed: {\n    queueItemId: string;\n    progress: number;\n  };\n  buildPaused: {\n    queueItemId: string;\n  };\n  buildResumed: {\n    queueItemId: string;\n  };\n  bayUpgraded: {\n    bayId: string;\n    newTier: Tier;\n    newCapacity: number;\n    newEfficiency: number;\n  };\n  bayMaintained: {\n    bayId: string;\n    newEfficiency: number;\n    maintenanceCost: ResourceCost[];\n  };\n  bayMaintenanceFailed: {\n    bayId: string;\n    newEfficiency: number;\n    requiredResources: ResourceCost[];\n  };\n  shipDocked: {\n    ship: CommonShip;\n    bay: ShipHangarBay;\n  };\n  shipLaunched: {\n    ship: CommonShip;\n    bay: ShipHangarBay;\n  };\n  tierUpgraded: {\n    tier: Tier;\n    unlockedShips: PlayerShipClass[];\n  };\n  repairStarted: {\n    shipId: string;\n    resourceCost: ResourceCost[];\n    estimatedTime: number;\n  };\n  repairCompleted: {\n    shipId: string;\n  };\n  repairCancelled: {\n    shipId: string;\n    refundedResources: ResourceCost[];\n  };\n  upgradeStarted: {\n    shipId: string;\n    resourceCost: ResourceCost[];\n    estimatedTime: number;\n  };\n  upgradeCompleted: {\n    shipId: string;\n    newTier: Tier;\n    stats: ShipUpgradeStats;\n  };\n  upgradeCancelled: {\n    shipId: string;\n    refundedResources: ResourceCost[];\n  };\n  abilityActivated: {\n    shipId: string;\n    abilityName: string;\n    duration: number;\n    effect: Effect;\n  };\n  abilityDeactivated: {\n    shipId: string;\n    abilityName: string;\n  };\n  weaponEquipped: {\n    shipId: string;\n    mountId: string;\n    weaponId: string;\n  };\n  weaponUnequipped: {\n    shipId: string;\n    mountId: string;\n    weaponId: string;\n  };\n  officerAssigned: {\n    shipId: string;\n    officerId: string;\n    bonuses: {\n      buildSpeed?: number;\n      resourceEfficiency?: number;\n      combatEffectiveness?: number;\n    };\n  };\n  officerUnassigned: {\n    shipId: string;\n    officerId: string;\n  };\n  [key: string]: unknown;\n}\n\n/**\n * Ship build requirements\n */\nexport interface ShipBuildRequirements {\n  tier: Tier;\n  resourceCost: ResourceCost[];\n  buildTime: number;\n  prerequisites?: {\n    technology?: string[];\n    resources?: ResourceCost[];\n    officers?: {\n      minLevel: number;\n      specialization: string;\n    };\n  };\n}\n\n/**\n * Ship hangar manager interface\n */\nexport interface ShipHangarManager {\n  // Build queue management\n  startBuild(shipClass: PlayerShipClass): void;\n  cancelBuild(queueItemId: string): void;\n  pauseBuild(queueItemId: string): void;\n  resumeBuild(queueItemId: string): void;\n  getBuildQueue(): ShipBuildQueueItem[];\n  getBuildRequirements(shipClass: PlayerShipClass): ShipBuildRequirements;\n\n  // Bay management\n  dockShip(ship: CommonShip): void;\n  launchShip(shipId: string): void;\n  upgradeBay(bayId: string): void;\n  getBays(): ShipHangarBay[];\n  getAvailableBays(): ShipHangarBay[];\n\n  // State management\n  getCurrentTier(): Tier;\n  getState(): ShipHangarState;\n  update(deltaTime: number): void;\n\n  // Ship management\n  getAvailableShips(category?: PlayerShipCategory): CommonShip[];\n  getDockedShips(): CommonShip[];\n  getShipsByCategory(category: PlayerShipCategory): CommonShip[];\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/combat/CombatTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/combat/HazardTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/combat/SalvageTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/common.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/common/VectorTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/config/TypeSafeConfig.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/core/GameTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/core/Position.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/debug/DebugTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/declarations.d.ts",
    "messages": [],
    "suppressedMessages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 9,
        "column": 66,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 9,
        "endColumn": 69,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [337, 340], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [337, 340], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 11,
        "column": 70,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 11,
        "endColumn": 73,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [486, 489], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [486, 489], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 13,
        "column": 71,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 13,
        "endColumn": 74,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [636, 639], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [636, 639], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ],
        "suppressions": [{ "kind": "directive", "justification": "" }]
      }
    ],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/events/CombatEvents.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/events/EventEmitterInterface.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 13,
        "column": 30,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 13,
        "endColumn": 33,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [310, 313], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [310, 313], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 18,
        "column": 32,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 18,
        "endColumn": 35,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [430, 433], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [430, 433], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 53,
        "column": 10,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 53,
        "endColumn": 13,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1292, 1295], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1292, 1295], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 65,
        "column": 11,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 65,
        "endColumn": 14,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1584, 1587], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1584, 1587], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 73,
        "column": 12,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 73,
        "endColumn": 15,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1805, 1808], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1805, 1808], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 5,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * EventEmitterInterface.ts\n *\n * This file defines the standard interface for event emitters in the system.\n * All manager classes that need to emit events should implement this interface.\n */\n\nimport { EventType } from './EventTypes';\n\n/**\n * Standard event handler type\n */\nexport type EventHandler<T = any> = (data: T) => void;\n\n/**\n * Standard event predicate type for filtering events\n */\nexport type EventPredicate<T = any> = (data: T) => boolean;\n\n/**\n * Options for event subscription\n */\nexport interface SubscriptionOptions {\n  /**\n   * Call listener immediately with last event of this type if available\n   */\n  emitLatest?: boolean;\n\n  /**\n   * Source identification for tracking subscriptions\n   */\n  source?: string;\n\n  /**\n   * Priority for event processing (lower numbers = higher priority)\n   */\n  priority?: number;\n}\n\n/**\n * Standard interface for event emitters\n * This interface should be implemented by all manager classes that need to emit events\n */\nexport interface IEventEmitter {\n  /**\n   * Subscribe to an event\n   *\n   * @param eventType The type of event to subscribe to\n   * @param handler The function to call when the event is emitted\n   * @param options Additional subscription options\n   * @returns A function to unsubscribe the handler\n   */\n  on<T = any>(\n    eventType: EventType | string,\n    handler: EventHandler<T>,\n    options?: SubscriptionOptions\n  ): () => void;\n\n  /**\n   * Unsubscribe from an event\n   *\n   * @param eventType The type of event to unsubscribe from\n   * @param handler The handler function to remove\n   */\n  off<T = any>(eventType: EventType | string, handler: EventHandler<T>): void;\n\n  /**\n   * Emit an event\n   *\n   * @param eventType The type of event to emit\n   * @param data The data to pass to the event handlers\n   */\n  emit<T = any>(eventType: EventType | string, data: T): void;\n\n  /**\n   * Remove all event listeners\n   *\n   * @param eventType Optional event type to remove listeners for. If not provided, all listeners are removed.\n   */\n  removeAllListeners(eventType?: EventType | string): void;\n\n  /**\n   * Get the number of listeners for an event type\n   *\n   * @param eventType The event type to get the listener count for\n   * @returns The number of listeners\n   */\n  listenerCount(eventType: EventType | string): number;\n}\n\n/**\n * Interface for typed event emitters\n * This interface provides type safety for event data\n */\nexport interface ITypedEventEmitter<T extends Record<string, unknown>> {\n  /**\n   * Subscribe to an event\n   *\n   * @param event The event name (key of T)\n   * @param callback The function to call when the event is emitted\n   * @returns A function to unsubscribe the handler\n   */\n  on<K extends keyof T>(event: K, callback: (data: T[K]) => void): () => void;\n\n  /**\n   * Unsubscribe from an event\n   *\n   * @param event The event name (key of T)\n   * @param callback The handler function to remove\n   */\n  off<K extends keyof T>(event: K, callback: (data: T[K]) => void): void;\n\n  /**\n   * Emit an event\n   *\n   * @param event The event name (key of T)\n   * @param data The data to pass to the event handlers\n   */\n  emit<K extends keyof T>(event: K, data: T[K]): void;\n\n  /**\n   * Remove all event listeners\n   *\n   * @param event Optional event name to remove listeners for. If not provided, all listeners are removed.\n   */\n  removeAllListeners<K extends keyof T>(event?: K): void;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/events/EventTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/events/ExplorationEvents.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/events/FactionEvents.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/events/ModuleEventTypes.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'ResourceType' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 1,
        "column": 10,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 1,
        "endColumn": 22
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { ResourceType } from \"./../resources/ResourceTypes\";\n/**\n * Module Event Types\n *\n * Types definitions for the module event system used across the application.\n * These types standardize the communication between different modules,\n * enabling consistent event handling and type safety.\n */\n\n/**\n * Supported module types in the system\n */\nexport type ModuleType =\n  | 'resource-manager'\n  | 'game-loop-manager'\n  | 'module-manager'\n  | 'ship-manager'\n  | 'combat-manager'\n  | 'exploration-manager'\n  | 'ui-manager'\n  | 'automation-manager';\n\n/**\n * Event types that can be emitted by modules\n */\nexport type ModuleEventType =\n  | 'STATUS_CHANGED'\n  | 'RESOURCE_UPDATED'\n  | 'CONFIG_CHANGED'\n  | 'ERROR'\n  | 'PERFORMANCE_ALERT'\n  | 'GAME_LOOP_STARTED'\n  | 'GAME_LOOP_STOPPED'\n  | 'GAME_LOOP_ADJUSTED'\n  | 'GAME_LOOP_UPDATE_REGISTERED'\n  | 'GAME_LOOP_UPDATE_UNREGISTERED'\n  | 'GAME_LOOP_CONFIG_UPDATED';\n\n/**\n * Base event data interface\n */\nexport interface BaseEventData {\n  type: string;\n  [key: string]: unknown;\n}\n\n/**\n * Generic module event interface\n */\nexport interface ModuleEvent {\n  type: ModuleEventType;\n  moduleId: string;\n  moduleType: ModuleType;\n  timestamp: number;\n  data: BaseEventData;\n}\n\n/**\n * Performance-related event data\n */\nexport interface PerformanceEventData extends BaseEventData {\n  type: 'performance_snapshot' | 'optimization_suggestions' | 'power_saving_mode';\n  snapshot?: unknown;\n  suggestions?: unknown;\n  enabled?: boolean;\n}\n\n/**\n * Resource-related event data\n */\nexport interface ResourceEventData extends BaseEventData {\n  type: 'resource_production' | 'resource_consumption' | 'resource_transfer';\n  resourceType?: string;\n  amount?: number;\n  source?: string;\n  target?: string;\n}\n\n/**\n * Event subscription options\n */\nexport interface EventSubscriptionOptions {\n  topic: ModuleEventType;\n  moduleId?: string;\n  moduleType?: ModuleType;\n  callback: (event: ModuleEvent) => void;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/events/ModuleEvents.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/events/SharedEventTypes.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'T' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 127,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 127,
        "endColumn": 4
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * @file SharedEventTypes.ts\n * Shared event types and interfaces for both production and test code\n *\n * This file provides unified event types to:\n * 1. Eliminate \"as unknown as\" casts in event handling\n * 2. Create consistent interfaces for mocks and real implementations\n * 3. Provide type-safe event creation and handling\n */\n\nimport { EventHandler as BaseEventHandler, EventUnsubscribe } from '../TypeUtils';\n\n/**\n * Base event interface that all events should extend\n */\nexport interface BaseEvent {\n  type: string;\n  timestamp: number;\n  data?: unknown;\n}\n\n/**\n * Generic typed event interface\n */\nexport interface TypedEvent<T extends string, D = unknown> extends BaseEvent {\n  type: T;\n  data?: D;\n}\n\n/**\n * Event Emitter interface compatible with both production and test code\n */\nexport interface EventEmitter<E extends BaseEvent = BaseEvent> {\n  emit(event: E): void;\n  on(eventType: string, handler: EventHandler<E>): EventUnsubscribe;\n  off(eventType: string, handler: EventHandler<E>): void;\n}\n\n/**\n * Event Bus interface for more complex event routing\n */\nexport interface EventBus<E extends BaseEvent = BaseEvent> extends EventEmitter<E> {\n  subscribe(eventType: string, handler: EventHandler<E>): EventUnsubscribe;\n  unsubscribe(eventType: string, handler: EventHandler<E>): void;\n  subscribeToMultiple(eventTypes: string[], handler: EventHandler<E>): EventUnsubscribe;\n  clear(): void;\n}\n\n/**\n * Mock Event Bus for testing - implements the same interface\n */\nexport interface MockEventBus<E extends BaseEvent = BaseEvent> extends EventBus<E> {\n  getEmittedEvents(): E[];\n  getSubscriptions(): Map<string, Array<EventHandler<E>>>;\n  reset(): void;\n}\n\n/**\n * Type-safe event creator - ensures proper event structure\n */\nexport function createEvent<T extends string, D>(type: T, data?: D): TypedEvent<T, D> {\n  return {\n    type,\n    timestamp: Date.now(),\n    data,\n  };\n}\n\n/**\n * Type-safe event data extractor - safely extracts data from events\n */\nexport function getEventData<T>(event: BaseEvent): T | undefined {\n  return event.data as T | undefined;\n}\n\n/**\n * Event type guard - checks if an event is of a specific type\n */\nexport function isEventOfType<T extends string>(event: BaseEvent, type: T): event is TypedEvent<T> {\n  return event.type === type;\n}\n\n/**\n * Event data type guard - checks if event data conforms to a specific shape\n */\nexport function hasEventData<T>(\n  event: BaseEvent,\n  predicate: (data: unknown) => data is T\n): event is BaseEvent & { data: T } {\n  return event.data !== undefined && predicate(event.data);\n}\n\n/**\n * Event handler with type filtering - only calls handler for matching event types\n */\nexport function createTypedEventHandler<T extends string, E extends BaseEvent, D>(\n  type: T,\n  handler: (data: D, event: E) => void\n): EventHandler<E> {\n  return (event: E) => {\n    if (event.type === type && event.data !== undefined) {\n      handler(event.data as D, event);\n    }\n  };\n}\n\n/**\n * Common event object pattern shared across the application\n */\nexport interface EventObject<T extends string = string> {\n  eventType: T;\n  payload: unknown;\n}\n\n/**\n * Generic event map interface for strongly typed event data\n */\nexport interface EventDataMap {\n  [eventType: string]: unknown;\n}\n\n/**\n * Type-safe event subscription helper\n */\nexport function typedSubscribe<\n  E extends BaseEvent,\n  T extends string,\n  M extends EventDataMap,\n  K extends keyof M & string,\n>(\n  bus: EventBus<E>,\n  eventType: K,\n  handler: (data: M[K], event: TypedEvent<K, M[K]>) => void\n): EventUnsubscribe {\n  const wrappedHandler: EventHandler<E> = (event: E) => {\n    if (event.type === eventType) {\n      handler(event.data as M[K], event as unknown as TypedEvent<K, M[K]>);\n    }\n  };\n\n  return bus.subscribe(eventType, wrappedHandler);\n}\n\n/**\n * Type-safe event emission helper\n */\nexport function typedEmit<E extends BaseEvent, M extends EventDataMap, K extends keyof M & string>(\n  bus: EventEmitter<E>,\n  eventType: K,\n  data: M[K]\n): void {\n  const event: TypedEvent<K, M[K]> = {\n    type: eventType,\n    timestamp: Date.now(),\n    data,\n  };\n\n  bus.emit(event as unknown as E);\n}\n\n// Re-export these types\nexport type EventHandler<T> = BaseEventHandler<T>;\nexport type { EventUnsubscribe };\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/events/ShipEvents.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/events/StandardizedEvents.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/events/__tests__/StandardizedEvents.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/events/moduleEventBus.d.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/exploration/AnalysisComponentTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/exploration/ClassificationTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/exploration/DataAnalysisTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/exploration/ExplorationTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/exploration/unified/ExplorationTypeUtils.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'StarSystem' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 20,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 20,
        "endColumn": 13
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'Planet' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 21,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 21,
        "endColumn": 9
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Exploration Type Utilities\n * \n * This file contains utility functions for working with exploration types,\n * including type conversion functions, validation, and helper functions.\n */\n\nimport {\n  Anomaly,\n  AnomalyType,\n  AnalysisResult,\n  AnalysisType,\n  Coordinates,\n  DangerLevel,\n  EffectType,\n  Effect,\n  ExplorationStatus,\n  InvestigationStage,\n  Sector,\n  StarSystem,\n  Planet,\n  ResourceDeposit\n} from './ExplorationTypes';\nimport { DataPoint } from '../DataAnalysisTypes';\nimport { ResourceType } from \"./../../resources/ResourceTypes\";\n\n// =========================================\n// Type Conversion Utilities\n// =========================================\n\n/**\n * Convert a DataPoint to a Coordinates object\n */\nexport function dataPointToCoordinates(dataPoint: DataPoint): Coordinates {\n  return {\n    id: `coord-${dataPoint.id}`,\n    x: dataPoint.coordinates.x,\n    y: dataPoint.coordinates.y,\n    z: dataPoint.properties?.z as number | undefined,\n    sector: dataPoint.properties?.sector as string | undefined,\n    quadrant: dataPoint.properties?.quadrant as string | undefined\n  };\n}\n\n/**\n * Convert a DataPoint to an Anomaly\n */\nexport function dataPointToAnomaly(dataPoint: DataPoint): Anomaly {\n  return {\n    id: dataPoint.id,\n    name: dataPoint.name,\n    type: 'anomaly',\n    anomalyType: determineAnomalyType(dataPoint),\n    intensity: (dataPoint.properties?.intensity as number) || 50,\n    stability: (dataPoint.properties?.stability as number) || 50,\n    discoveredAt: dataPoint.date,\n    coordinates: dataPointToCoordinates(dataPoint),\n    explorationStatus: ExplorationStatus.DETECTED,\n    composition: [],\n    effects: [],\n    investigation: {\n      status: InvestigationStage.NOT_STARTED,\n      progress: 0,\n      findings: [],\n      requiredEquipment: [],\n      recommendedActions: []\n    },\n    potentialUses: [],\n    dangerLevel: determineDangerLevel(dataPoint),\n    visualData: dataPoint.properties?.visualData as unknown || undefined\n  };\n}\n\n/**\n * Convert a DataPoint to a ResourceDeposit\n */\nexport function dataPointToResourceDeposit(dataPoint: DataPoint): ResourceDeposit {\n  return {\n    id: dataPoint.id,\n    type: determineResourceType(dataPoint),\n    amount: (dataPoint.properties?.amount as number) || 100,\n    quality: (dataPoint.properties?.quality as number) || 50,\n    accessibility: (dataPoint.properties?.accessibility as number) || 50,\n    coordinates: dataPointToCoordinates(dataPoint),\n    explorationStatus: ExplorationStatus.DETECTED,\n    discoveredAt: dataPoint.date\n  };\n}\n\n/**\n * Convert a DataPoint to a Sector\n */\nexport function dataPointToSector(dataPoint: DataPoint): Sector {\n  return {\n    id: dataPoint.id,\n    name: dataPoint.name,\n    type: 'sector',\n    discoveredAt: dataPoint.date,\n    coordinates: dataPointToCoordinates(dataPoint),\n    explorationStatus: ExplorationStatus.DETECTED,\n    systems: [],\n    resources: [],\n    anomalies: [],\n    tradeRoutes: [],\n    dangerLevel: determineDangerLevel(dataPoint),\n    environmentalConditions: []\n  };\n}\n\n/**\n * Convert an Anomaly to a DataPoint\n */\nexport function anomalyToDataPoint(anomaly: Anomaly): DataPoint {\n  return {\n    id: anomaly.id,\n    type: 'anomaly',\n    name: anomaly.name,\n    date: anomaly.discoveredAt,\n    coordinates: {\n      x: anomaly.coordinates.x,\n      y: anomaly.coordinates.y\n    },\n    properties: {\n      anomalyType: anomaly.anomalyType,\n      intensity: anomaly.intensity,\n      stability: anomaly.stability,\n      dangerLevel: anomaly.dangerLevel,\n      z: anomaly.coordinates.z,\n      sector: anomaly.coordinates.sector,\n      quadrant: anomaly.coordinates.quadrant,\n      visualData: anomaly.visualData\n    }\n  };\n}\n\n/**\n * Convert a ResourceDeposit to a DataPoint\n */\nexport function resourceDepositToDataPoint(resource: ResourceDeposit): DataPoint {\n  return {\n    id: resource.id,\n    type: 'resource',\n    name: `${resource.type} Deposit`,\n    date: resource.discoveredAt || Date.now(),\n    coordinates: {\n      x: resource.coordinates.x,\n      y: resource.coordinates.y\n    },\n    properties: {\n      resourceType: resource.type,\n      amount: resource.amount,\n      quality: resource.quality,\n      accessibility: resource.accessibility,\n      z: resource.coordinates.z,\n      sector: resource.coordinates.sector,\n      quadrant: resource.coordinates.quadrant\n    }\n  };\n}\n\n/**\n * Convert a Sector to a DataPoint\n */\nexport function sectorToDataPoint(sector: Sector): DataPoint {\n  return {\n    id: sector.id,\n    type: 'sector',\n    name: sector.name,\n    date: sector.discoveredAt,\n    coordinates: {\n      x: sector.coordinates.x,\n      y: sector.coordinates.y\n    },\n    properties: {\n      dangerLevel: sector.dangerLevel,\n      systemCount: sector.systems.length,\n      anomalyCount: sector.anomalies.length,\n      resourceCount: sector.resources.length,\n      z: sector.coordinates.z,\n      quadrant: sector.coordinates.quadrant,\n      factionControl: sector.factionControl?.factionName\n    }\n  };\n}\n\n// =========================================\n// Helper (...args: unknown[]) => unknowns\n// =========================================\n\n/**\n * Determine anomaly type based on data point properties\n */\nfunction determineAnomalyType(dataPoint: DataPoint): AnomalyType {\n  const typeProperty = dataPoint.properties?.anomalyType as string | undefined;\n  \n  if (typeProperty && Object.values(AnomalyType).includes(typeProperty as AnomalyType)) {\n    return typeProperty as AnomalyType;\n  }\n  \n  // Try to determine based on other properties\n  const energySignature = dataPoint.properties?.energySignature as number | undefined;\n  const gravitationalDistortion = dataPoint.properties?.gravitationalDistortion as number | undefined;\n  const temporalFlux = dataPoint.properties?.temporalFlux as number | undefined;\n  \n  if (energySignature && energySignature > 70) {\n    return AnomalyType.ENERGY_SIGNATURE;\n  } else if (gravitationalDistortion && gravitationalDistortion > 70) {\n    return AnomalyType.GRAVITATIONAL_ANOMALY;\n  } else if (temporalFlux && temporalFlux > 70) {\n    return AnomalyType.TEMPORAL_ANOMALY;\n  }\n  \n  // Default case\n  return AnomalyType.UNKNOWN;\n}\n\n/**\n * Determine resource type based on data point properties\n */\nfunction determineResourceType(dataPoint: DataPoint): ResourceType {\n  const typeProperty = dataPoint.properties?.resourceType as string | undefined;\n  \n  if (typeProperty && Object.values(ResourceType).includes(typeProperty as ResourceType)) {\n    return typeProperty as ResourceType;\n  }\n  \n  // Default case\n  return ResourceType.MINERALS;\n}\n\n/**\n * Determine danger level based on data point properties\n */\nfunction determineDangerLevel(dataPoint: DataPoint): DangerLevel {\n  const dangerProperty = dataPoint.properties?.dangerLevel as string | undefined;\n  \n  if (dangerProperty && Object.values(DangerLevel).includes(dangerProperty as DangerLevel)) {\n    return dangerProperty as DangerLevel;\n  }\n  \n  // Try to determine based on other properties\n  const radiationLevel = dataPoint.properties?.radiationLevel as number | undefined;\n  const hostileActivity = dataPoint.properties?.hostileActivity as number | undefined;\n  const instability = dataPoint.properties?.instability as number | undefined;\n  \n  if (radiationLevel && radiationLevel > 80) {\n    return DangerLevel.EXTREME;\n  } else if (hostileActivity && hostileActivity > 70) {\n    return DangerLevel.HIGH;\n  } else if (instability && instability > 60) {\n    return DangerLevel.MODERATE;\n  } else if ((radiationLevel && radiationLevel > 30) || \n            (hostileActivity && hostileActivity > 30) || \n            (instability && instability > 30)) {\n    return DangerLevel.LOW;\n  }\n  \n  // Default case\n  return DangerLevel.UNKNOWN;\n}\n\n/**\n * Create a default effect based on type\n */\nexport function createDefaultEffect(type: EffectType): Effect {\n  const id = `effect-${Date.now()}-${Math.floor(Math.random() * 1000)}`;\n  \n  switch (type) {\n    case EffectType.BUFF:\n      return {\n        id,\n        name: 'Positive Effect',\n        type: EffectType.BUFF,\n        strength: 50,\n        duration: -1,\n        description: 'A positive effect that enhances capabilities.',\n        impactedSystems: ['shields', 'sensors']\n      };\n    \n    case EffectType.DEBUFF:\n      return {\n        id,\n        name: 'Negative Effect',\n        type: EffectType.DEBUFF,\n        strength: 40,\n        duration: 300,\n        description: 'A negative effect that impairs capabilities.',\n        impactedSystems: ['engines', 'weapons']\n      };\n    \n    case EffectType.DAMAGE:\n      return {\n        id,\n        name: 'Damage Effect',\n        type: EffectType.DAMAGE,\n        strength: 60,\n        duration: 60,\n        description: 'An effect that causes damage over time.',\n        impactedSystems: ['hull', 'components']\n      };\n    \n    case EffectType.ENVIRONMENTAL:\n      return {\n        id,\n        name: 'Environmental Effect',\n        type: EffectType.ENVIRONMENTAL,\n        strength: 30,\n        duration: -1,\n        description: 'An environmental effect that alters the surroundings.',\n        impactedSystems: ['scanners', 'mining']\n      };\n    \n    default:\n      return {\n        id,\n        name: 'Special Effect',\n        type: EffectType.SPECIAL,\n        strength: 50,\n        duration: 120,\n        description: 'A special effect with unique properties.',\n        impactedSystems: ['all']\n      };\n  }\n}\n\n/**\n * Create a default analysis result\n */\nexport function createDefaultAnalysisResult(type: AnalysisType, entityIds: string[]): AnalysisResult {\n  const id = `analysis-${Date.now()}-${Math.floor(Math.random() * 1000)}`;\n  \n  return {\n    id,\n    name: `${type.charAt(0).toUpperCase() + type.slice(1)} Analysis`,\n    type,\n    createdAt: Date.now(),\n    entityIds,\n    data: {},\n    insights: [],\n    summary: 'Analysis complete. Review results for more information.',\n    confidence: 75\n  };\n}\n\n/**\n * Filter entities by exploration status\n */\nexport function filterByExplorationStatus<T extends { explorationStatus: ExplorationStatus }>(\n  entities: T[],\n  status: ExplorationStatus\n): T[] {\n  return entities.filter(entity => entity.explorationStatus === status);\n}\n\n/**\n * Sort entities by discovery date\n */\nexport function sortByDiscoveryDate<T extends { discoveredAt: number }>(\n  entities: T[],\n  ascending: boolean = false\n): T[] {\n  return [...entities].sort((a, b) => {\n    return ascending ? a.discoveredAt - b.discoveredAt : b.discoveredAt - a.discoveredAt;\n  });\n}\n\n/**\n * Calculate distance between two coordinates\n */\nexport function calculateDistance(coord1: Coordinates, coord2: Coordinates): number {\n  const dx = coord2.x - coord1.x;\n  const dy = coord2.y - coord1.y;\n  const dz = (coord2.z || 0) - (coord1.z || 0);\n  \n  return Math.sqrt(dx * dx + dy * dy + dz * dz);\n}\n\n/**\n * Find nearest entities to a given coordinate\n */\nexport function findNearestEntities<T extends { coordinates: Coordinates }>(\n  entities: T[],\n  targetCoord: Coordinates,\n  limit: number = 5\n): T[] {\n  return [...entities]\n    .map(entity => ({\n      entity,\n      distance: calculateDistance(entity.coordinates, targetCoord)\n    }))\n    .sort((a, b) => a.distance - b.distance)\n    .slice(0, limit)\n    .map(item => item.entity);\n}\n\n/**\n * Create a blank exploration state\n */\nexport function createEmptyExplorationState() {\n  return {\n    sectors: [],\n    systems: [],\n    planets: [],\n    resources: [],\n    anomalies: [],\n    tradeRoutes: [],\n    activities: [],\n    analysisResults: [],\n    loading: false,\n    error: null\n  };\n}\n\n// Export utility functions\nexport {\n  dataPointToCoordinates,\n  dataPointToAnomaly,\n  dataPointToResourceDeposit,\n  dataPointToSector,\n  anomalyToDataPoint,\n  resourceDepositToDataPoint,\n  sectorToDataPoint,\n  determineAnomalyType,\n  determineResourceType,\n  determineDangerLevel,\n  createDefaultEffect,\n  createDefaultAnalysisResult,\n  filterByExplorationStatus,\n  sortByDiscoveryDate,\n  calculateDistance,\n  findNearestEntities,\n  createEmptyExplorationState\n};",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/exploration/unified/ExplorationTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/exploration/unified/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/geometry.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/global.d.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/managers/MockManagerFactory.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/managers/SharedManagerTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/mining/MiningTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/modules/ModuleTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/officers/OfficerTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/resources/ResourceConversionTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/resources/ResourceFlowTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/resources/ResourcePoolTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/resources/ResourceSerializationTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/resources/ResourceTypeUtils.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'resourceType' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 212,
        "column": 54,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 212,
        "endColumn": 66
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Resource Type Utilities\n *\n * This file provides utility functions for working with resource types.\n * It complements the StandardizedResourceTypes.ts file and helps with\n * common operations on resource types.\n */\n\nimport { ResourceType } from \"./ResourceTypes\";\n\n/**\n * Gets the display name for a resource type\n * @param resourceType The resource type\n * @returns The display name\n */\nexport function getResourceDisplayName(resourceType: ResourceType): ResourceType {\n  return ResourceTypeInfo[resourceType].displayName;\n}\n\n/**\n * Gets the description for a resource type\n * @param resourceType The resource type\n * @returns The description\n */\nexport function getResourceDescription(resourceType: ResourceType): ResourceType {\n  return ResourceTypeInfo[resourceType].description;\n}\n\n/**\n * Gets the icon for a resource type\n * @param resourceType The resource type\n * @returns The icon name\n */\nexport function getResourceIcon(resourceType: ResourceType): ResourceType {\n  return ResourceTypeInfo[resourceType].icon;\n}\n\n/**\n * Gets the category for a resource type\n * @param resourceType The resource type\n * @returns The resource category\n */\nexport function getResourceCategory(resourceType: ResourceType): ResourceCategory {\n  return ResourceTypeInfo[resourceType].category;\n}\n\n/**\n * Gets the default maximum amount for a resource type\n * @param resourceType The resource type\n * @returns The default maximum amount\n */\nexport function getResourceDefaultMax(resourceType: ResourceType): number {\n  return ResourceTypeInfo[resourceType].defaultMax;\n}\n\n/**\n * Gets all resource types of a specific category\n * @param category The resource category\n * @returns Array of resource types in that category\n */\nexport function getResourceTypesByCategory(category: ResourceCategory): ResourceType[] {\n  return Object.values(ResourceType).filter(type => ResourceTypeInfo[type].category === category);\n}\n\n/**\n * Gets all basic resources\n * @returns Array of basic resource types\n */\nexport function getBasicResourceTypes(): ResourceType[] {\n  return getResourceTypesByCategory(ResourceCategory.BASIC);\n}\n\n/**\n * Gets all advanced resources\n * @returns Array of advanced resource types\n */\nexport function getAdvancedResourceTypes(): ResourceType[] {\n  return getResourceTypesByCategory(ResourceCategory.ADVANCED);\n}\n\n/**\n * Gets all special resources\n * @returns Array of special resource types\n */\nexport function getSpecialResourceTypes(): ResourceType[] {\n  return getResourceTypesByCategory(ResourceCategory.SPECIAL);\n}\n\n/**\n * Checks if a resource type is a basic resource\n * @param resourceType The resource type to check\n * @returns Whether the resource type is a basic resource\n */\nexport function isBasicResource(resourceType: ResourceType): boolean {\n  return ResourceTypeInfo[resourceType].category === ResourceCategory.BASIC;\n}\n\n/**\n * Checks if a resource type is an advanced resource\n * @param resourceType The resource type to check\n * @returns Whether the resource type is an advanced resource\n */\nexport function isAdvancedResource(resourceType: ResourceType): boolean {\n  return ResourceTypeInfo[resourceType].category === ResourceCategory.ADVANCED;\n}\n\n/**\n * Checks if a resource type is a special resource\n * @param resourceType The resource type to check\n * @returns Whether the resource type is a special resource\n */\nexport function isSpecialResource(resourceType: ResourceType): boolean {\n  return ResourceTypeInfo[resourceType].category === ResourceCategory.SPECIAL;\n}\n\n/**\n * Gets a color for a resource type (for visualization)\n * @param resourceType The resource type\n * @returns A color string (hex or CSS color)\n */\nexport function getResourceTypeColor(resourceType: ResourceType): ResourceType {\n  // Define a color mapping for resource types\n  const colorMap: Record<ResourceType, string> = {\n    [ResourceType.MINERALS]: '#8B4513', // SaddleBrown\n    [ResourceType.ENERGY]: '#FFD700', // Gold\n    [ResourceType.POPULATION]: '#32CD32', // LimeGreen\n    [ResourceType.RESEARCH]: '#1E90FF', // DodgerBlue\n    [ResourceType.PLASMA]: '#FF1493', // DeepPink\n    [ResourceType.GAS]: '#00FFFF', // Cyan\n    [ResourceType.EXOTIC]: '#9932CC', // DarkOrchid\n    [ResourceType.IRON]: '#A52A2A', // Brown\n    [ResourceType.COPPER]: '#B87333', // Copper\n    [ResourceType.TITANIUM]: '#C0C0C0', // Silver\n    [ResourceType.URANIUM]: '#7FFF00', // Chartreuse\n    [ResourceType.WATER]: '#1E90FF', // DodgerBlue\n    [ResourceType.HELIUM]: '#87CEFA', // LightSkyBlue\n    [ResourceType.DEUTERIUM]: '#00BFFF', // DeepSkyBlue\n    [ResourceType.ANTIMATTER]: '#FF00FF', // Magenta\n    [ResourceType.DARK_MATTER]: '#4B0082', // Indigo\n    [ResourceType.EXOTIC_MATTER]: '#800080', // Purple\n  };\n\n  return colorMap[resourceType] || '#808080'; // Default to gray if not found\n}\n\n/**\n * Gets a lighter color variant for a resource type (for highlights)\n * @param resourceType The resource type\n * @returns A lighter color string (hex or CSS color)\n */\nexport function getResourceTypeHighlightColor(resourceType: ResourceType): ResourceType {\n  // Define a highlight color mapping for resource types\n  const highlightColorMap: Record<ResourceType, string> = {\n    [ResourceType.MINERALS]: '#CD853F', // Peru (lighter brown)\n    [ResourceType.ENERGY]: '#FFEC8B', // LightGoldenrod (lighter gold)\n    [ResourceType.POPULATION]: '#90EE90', // LightGreen\n    [ResourceType.RESEARCH]: '#87CEFA', // LightSkyBlue\n    [ResourceType.PLASMA]: '#FF69B4', // HotPink\n    [ResourceType.GAS]: '#AFEEEE', // PaleTurquoise\n    [ResourceType.EXOTIC]: '#BA55D3', // MediumOrchid\n    [ResourceType.IRON]: '#CD5C5C', // IndianRed\n    [ResourceType.COPPER]: '#DAA520', // GoldenRod\n    [ResourceType.TITANIUM]: '#E0E0E0', // Lighter silver\n    [ResourceType.URANIUM]: '#ADFF2F', // GreenYellow\n    [ResourceType.WATER]: '#87CEFA', // LightSkyBlue\n    [ResourceType.HELIUM]: '#B0E2FF', // LighterSkyBlue\n    [ResourceType.DEUTERIUM]: '#87CEFF', // LighterDeepSkyBlue\n    [ResourceType.ANTIMATTER]: '#FF77FF', // Lighter magenta\n    [ResourceType.DARK_MATTER]: '#9370DB', // MediumPurple\n    [ResourceType.EXOTIC_MATTER]: '#BA55D3', // MediumOrchid\n  };\n\n  return highlightColorMap[resourceType] || '#C0C0C0'; // Default to light gray if not found\n}\n\n/**\n * Gets a darker color variant for a resource type (for shadows or borders)\n * @param resourceType The resource type\n * @returns A darker color string (hex or CSS color)\n */\nexport function getResourceTypeDarkColor(resourceType: ResourceType): ResourceType {\n  // Define a dark color mapping for resource types\n  const darkColorMap: Record<ResourceType, string> = {\n    [ResourceType.MINERALS]: '#5C2E0E', // Darker brown\n    [ResourceType.ENERGY]: '#B8860B', // DarkGoldenrod\n    [ResourceType.POPULATION]: '#228B22', // ForestGreen\n    [ResourceType.RESEARCH]: '#0000CD', // MediumBlue\n    [ResourceType.PLASMA]: '#C71585', // MediumVioletRed\n    [ResourceType.GAS]: '#008B8B', // DarkCyan\n    [ResourceType.EXOTIC]: '#6A0DAD', // DarkerPurple\n    [ResourceType.IRON]: '#8B0000', // DarkRed\n    [ResourceType.COPPER]: '#8B4513', // SaddleBrown\n    [ResourceType.TITANIUM]: '#A9A9A9', // DarkGray\n    [ResourceType.URANIUM]: '#556B2F', // DarkOliveGreen\n    [ResourceType.WATER]: '#00008B', // DarkBlue\n    [ResourceType.HELIUM]: '#4682B4', // SteelBlue\n    [ResourceType.DEUTERIUM]: '#00688B', // DeepSkyBlue4\n    [ResourceType.ANTIMATTER]: '#8B008B', // DarkMagenta\n    [ResourceType.DARK_MATTER]: '#2E0854', // DarkerIndigo\n    [ResourceType.EXOTIC_MATTER]: '#4B0082', // Indigo\n  };\n\n  return darkColorMap[resourceType] || '#404040'; // Default to dark gray if not found\n}\n\n/**\n * Formats a resource amount for display\n * @param amount The resource amount\n * @param resourceType Optional resource type for specialized formatting\n * @returns Formatted string representation of the amount\n */\nexport function formatResourceAmount(amount: number, resourceType?: ResourceType): ResourceType {\n  // For large numbers, use abbreviations\n  if (amount >= 1_000_000) {\n    return `${(amount / 1_000_000).toFixed(1)}M`;\n  } else if (amount >= 1_000) {\n    return `${(amount / 1_000).toFixed(1)}K`;\n  } else if (Number.isInteger(amount)) {\n    return amount.toString();\n  } else {\n    return amount.toFixed(1);\n  }\n}\n\n/**\n * Calculates the production rate per minute\n * @param amountPerTick Amount produced per tick\n * @param ticksPerSecond Number of ticks per second\n * @returns Production rate per minute\n */\nexport function calculateProductionRatePerMinute(\n  amountPerTick: number,\n  ticksPerSecond: number\n): number {\n  return amountPerTick * ticksPerSecond * 60;\n}\n\n/**\n * Calculates time until a target amount is reached\n * @param currentAmount Current amount of the resource\n * @param targetAmount Target amount to reach\n * @param productionRate Production rate per second (positive for production, negative for consumption)\n * @returns Time in seconds until target is reached, or Infinity if impossible\n */\nexport function calculateTimeToTarget(\n  currentAmount: number,\n  targetAmount: number,\n  productionRate: number\n): number {\n  if (productionRate === 0) {\n    return Infinity;\n  }\n\n  const difference = targetAmount - currentAmount;\n\n  // If we're already at or past the target\n  if ((productionRate > 0 && difference <= 0) || (productionRate < 0 && difference >= 0)) {\n    return 0;\n  }\n\n  // If we're consuming and trying to reach a higher amount, or\n  // if we're producing and trying to reach a lower amount\n  if ((productionRate < 0 && difference > 0) || (productionRate > 0 && difference < 0)) {\n    return Infinity;\n  }\n\n  return Math.abs(difference / productionRate);\n}\n\n/**\n * Formats a time duration in seconds to a human-readable string\n * @param seconds Time in seconds\n * @returns Formatted time string\n */\nexport function formatTimeDuration(seconds: number): string {\n  if (!isFinite(seconds)) {\n    return 'Never';\n  }\n\n  if (seconds < 60) {\n    return `${Math.ceil(seconds)}s`;\n  } else if (seconds < 3600) {\n    return `${Math.ceil(seconds / 60)}m`;\n  } else if (seconds < 86400) {\n    return `${Math.floor(seconds / 3600)}h ${Math.ceil((seconds % 3600) / 60)}m`;\n  } else {\n    return `${Math.floor(seconds / 86400)}d ${Math.floor((seconds % 86400) / 3600)}h`;\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/resources/ResourceTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/resources/StandardizedResourceTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/shared/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/ships/CommonShipTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/ships/FactionShipTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/ships/FactionTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/ships/PlayerShipTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/ships/Ship.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/ships/ShipTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/state/TypeSafeStateManagement.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'initialState' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 146,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 146,
        "endColumn": 15
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Type-Safe State Management\n * \n * This module provides utilities for creating strongly typed reducers, actions,\n * and state transitions to enhance the type safety of application state management.\n */\n\nimport React, { Reducer, useReducer, useMemo, useState, useCallback, useContext } from 'react';\n\n/**\n * Base Action interface that all action types should extend\n * Enforces inclusion of a type property for action discrimination\n */\nexport interface Action<T extends string = string> {\n  type: T;\n}\n\n/**\n * Action with payload interface that extends the base Action\n * Provides proper typing for actions that include data\n */\nexport interface PayloadAction<T extends string, P> extends Action<T> {\n  payload: P;\n}\n\n/**\n * Helper type to define a discriminated union of action types based on a record\n * Makes it easy to define all the possible action types for a reducer\n */\nexport type ActionUnion<T extends Record<string, (...args: unknown[]) => Action<string>>> = ReturnType<T[keyof T]>;\n\n/**\n * Type for a function that creates a PayloadAction\n */\nexport type ActionCreator<T extends string, P> = (payload: P) => PayloadAction<T, P>;\n\n/**\n * Type for a function that creates an Action without payload\n */\nexport type SimpleActionCreator<T extends string> = () => Action<T>;\n\n/**\n * Creates an action creator for actions with payloads\n * \n * @param type The action type string\n * @returns An action creator function that takes a payload and returns a properly typed action\n */\nexport function createAction<T extends string, P>(type: T): ActionCreator<T, P> {\n  return (payload: P): PayloadAction<T, P> => ({\n    type,\n    payload\n  });\n}\n\n/**\n * Creates an action creator for actions without payloads\n * \n * @param type The action type string\n * @returns An action creator function that returns a properly typed action\n */\nexport function createSimpleAction<T extends string>(type: T): SimpleActionCreator<T> {\n  return (): Action<T> => ({ type });\n}\n\n/**\n * Helper to create a record of action creators from a record of action types\n * \n * @param actionMap Record of action types mapped to their payload types\n * @returns Record of action creators\n */\nexport function createActionCreators<\n  T extends Record<string, unknown>,\n  K extends keyof T = keyof T\n>(actionMap: { [P in K]: T[P] extends undefined ? string : [string, T[P]] }) {\n  const creators: Record<string, ActionCreator<string, unknown> | SimpleActionCreator<string>> = {};\n\n  for (const key in actionMap) {\n    const value = actionMap[key];\n    if (typeof value === 'string') {\n      creators[key] = createSimpleAction(value);\n    } else {\n      creators[key] = createAction<string, T[K]>(value[0]);\n    }\n  }\n\n  return creators as {\n    [P in K]: T[P] extends undefined\n      ? SimpleActionCreator<string>\n      : ActionCreator<string, T[P]>\n  };\n}\n\n/**\n * Type-safe reducer builder that enforces action type discrimination\n * Ensures that action types are properly typed and matched in the reducer\n */\nexport class ReducerBuilder<S, A extends Action = Action> {\n  private handlers: Partial<Record<A['type'], (state: S, action: unknown) => S>> = {};\n\n  /**\n   * Add a handler for a specific action type\n   * \n   * @param type The action type to handle\n   * @param handler The handler function for this action type\n   * @returns The builder for chaining\n   */\n  addCase<T extends A['type'], AC extends Extract<A, { type: T }>>(\n    type: T,\n    handler: (state: S, action: AC) => S\n  ): ReducerBuilder<S, A> {\n    this.handlers[type] = handler as unknown;\n    return this;\n  }\n\n  /**\n   * Add a default handler for unmatched action types\n   * \n   * @param handler The default handler function\n   * @returns The builder for chaining\n   */\n  addDefaultCase(handler: (state: S) => S): ReducerBuilder<S, A> {\n    this.handlers['DEFAULT'] = (state) => handler(state);\n    return this;\n  }\n\n  /**\n   * Build the reducer function\n   * \n   * @returns A properly typed reducer function\n   */\n  build(): Reducer<S, A> {\n    return (state: S, action: A) => {\n      const handler = this.handlers[action.type] || this.handlers['DEFAULT'];\n      return handler ? handler(state, action) : state;\n    };\n  }\n}\n\n/**\n * Creates a reducer builder for a specific state and action type\n * \n * @param initialState The initial state (used for type inference)\n * @returns A reducer builder instance\n */\nexport function createReducer<S, A extends Action = Action>(\n  initialState: S\n): ReducerBuilder<S, A> {\n  return new ReducerBuilder<S, A>();\n}\n\n/**\n * Hook to create a state slice with type-safe actions and reducer\n * \n * @param reducer The reducer function\n * @param initialState The initial state\n * @param actions Object of action creators\n * @returns Tuple of [state, actions with dispatch bound]\n */\nexport function useTypedReducer<\n  S,\n  A extends Action,\n  AC extends Record<string, (...args: unknown[]) => A>\n>(\n  reducer: Reducer<S, A>,\n  initialState: S,\n  actions: AC\n): [S, { [K in keyof AC]: (...args: Parameters<AC[K]>) => void }] {\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  const boundActions = useMemo(() => {\n    const result: Record<string, unknown> = {};\n    for (const key in actions) {\n      const actionCreator = actions[key];\n      result[key] = (...args: unknown[]) => dispatch(actionCreator(...args));\n    }\n    return result as { [K in keyof AC]: (...args: Parameters<AC[K]>) => void };\n  }, [actions, dispatch]);\n\n  return [state, boundActions];\n}\n\n/**\n * Creates a type-safe state slice\n * Combines reducer creation and action binding in one utility\n * \n * @param initialState The initial state\n * @param reducerMap Map of action type to reducer handlers\n * @param actionMap Map of action creators\n * @returns A hook to use this state slice\n */\nexport function createTypedStateSlice<\n  S,\n  AM extends Record<string, (...args: unknown[]) => Action>,\n  A extends ReturnType<AM[keyof AM]>\n>(\n  initialState: S,\n  reducerMap: Record<A['type'], (state: S, action: A) => S>,\n  actionMap: AM\n) {\n  // Create the reducer\n  const reducer: Reducer<S, A> = (state = initialState, action) => {\n    const handler = reducerMap[action.type];\n    return handler ? handler(state, action) : state;\n  };\n\n  // Return a hook that provides the state and bound actions\n  return () => {\n    const [state, dispatch] = useReducer(reducer, initialState);\n\n    const boundActions = useMemo(() => {\n      const result: Record<string, unknown> = {};\n      for (const key in actionMap) {\n        const actionCreator = actionMap[key];\n        result[key] = (...args: unknown[]) => dispatch(actionCreator(...args));\n      }\n      return result as { [K in keyof AM]: (...args: Parameters<AM[K]>) => void };\n    }, [dispatch]);\n\n    return [state, boundActions] as const;\n  };\n}\n\n/**\n * Type for a complex state transition function\n * Used for multi-step state transitions that involve side effects\n */\nexport type StateTransitionFn<S, R = void> = (\n  getState: () => S,\n  setState: (update: Partial<S> | ((prevState: S) => Partial<S>)) => void\n) => Promise<R> | R;\n\n/**\n * Hook to manage complex state transitions in a type-safe way\n * \n * @param initialState The initial state\n * @returns A tuple of [state, setState, runTransition]\n */\nexport function useTypedTransitions<S>(initialState: S) {\n  const [state, setState] = useState<S>(initialState);\n\n  /**\n   * Set state with type checking\n   */\n  const setTypedState = useCallback((update: Partial<S> | ((prevState: S) => Partial<S>)) => {\n    setState(prev => {\n      const newParts = typeof update === 'function' ? update(prev) : update;\n      return { ...prev, ...newParts };\n    });\n  }, []);\n\n  /**\n   * Run a complex state transition with proper typing\n   */\n  const runTransition = useCallback(<R = void>(\n    transitionFn: StateTransitionFn<S, R>\n  ): Promise<R> => {\n    const getState = () => state;\n    return Promise.resolve(transitionFn(getState, setTypedState));\n  }, [state, setTypedState]);\n\n  return [state, setTypedState, runTransition] as const;\n}\n\n/**\n * Type-safe selector hook\n * \n * @param state The state object\n * @param selector (...args: unknown[]) => unknown to select a portion of state\n * @returns The selected state portion\n */\nexport function useTypedSelector<S, R>(state: S, selector: (state: S) => R): R {\n  return useMemo(() => selector(state), [state, selector]);\n}\n\n/**\n * Creates a type-safe async reducer\n * Handles loading, error, and success states for async operations\n * \n * @param actionType Base action type for the async action\n * @param handler (...args: unknown[]) => unknown that processes the action payload\n * @returns An object with action creators and a reducer\n */\nexport function createAsyncReducer<S, P, R>(\n  actionType: string,\n  handler: (payload: P) => Promise<R>\n) {\n  // Define action types\n  const PENDING = `${actionType}/pending`;\n  const FULFILLED = `${actionType}/fulfilled`;\n  const REJECTED = `${actionType}/rejected`;\n\n  // Create action creators\n  const actionCreators = {\n    pending: createSimpleAction(PENDING),\n    fulfilled: createAction<typeof FULFILLED, R>(FULFILLED),\n    rejected: createAction<typeof REJECTED, Error>(REJECTED),\n    trigger: (payload: P) => async (dispatch: (action: Action) => void) => {\n      dispatch(actionCreators.pending());\n      try {\n        const result = await handler(payload);\n        dispatch(actionCreators.fulfilled(result));\n        return result;\n      } catch (error) {\n        dispatch(actionCreators.rejected(error instanceof Error ? error : new Error(String(error))));\n        throw error;\n      }\n    }\n  };\n\n  // Create reducer\n  type AsyncState = {\n    loading: boolean;\n    error: Error | null;\n    data: R | null;\n  };\n\n  type AsyncReducerState = S & AsyncState;\n\n  const reducer = createReducer<AsyncReducerState, Action>(\n    { loading: false, error: null, data: null } as AsyncReducerState\n  )\n    .addCase(PENDING, (state) => ({\n      ...state,\n      loading: true,\n      error: null\n    }))\n    .addCase(FULFILLED, (state, action) => ({\n      ...state,\n      loading: false,\n      data: action.payload,\n      error: null\n    }))\n    .addCase(REJECTED, (state, action) => ({\n      ...state,\n      loading: false,\n      error: action.payload\n    }))\n    .build();\n\n  return {\n    actions: actionCreators,\n    reducer\n  };\n}\n\n/**\n * Type-safe context state utility\n * Combines the createReducer and useReducer patterns specifically for React contexts\n * \n * @param reducer The reducer function\n * @param initialState The initial state\n * @returns A context provider and hooks to use the state\n */\nexport function createTypedContext<\n  S,\n  A extends Action = Action\n>(\n  reducer: Reducer<S, A>,\n  initialState: S\n) {\n  const StateContext = React.createContext<S | undefined>(undefined);\n  const DispatchContext = React.createContext<React.Dispatch<A> | undefined>(undefined);\n\n  const Provider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n    const [state, dispatch] = useReducer(reducer, initialState);\n\n    return (\n      React.createElement(StateContext.Provider, { value: state },\n        React.createElement(DispatchContext.Provider, { value: dispatch }, children)\n      )\n    );\n  };\n\n  const useStateContext = () => {\n    const context = useContext(StateContext);\n    if (context === undefined) {\n      throw new Error('useStateContext must be used within a Provider');\n    }\n    return context;\n  };\n\n  const useDispatchContext = () => {\n    const context = useContext(DispatchContext);\n    if (context === undefined) {\n      throw new Error('useDispatchContext must be used within a Provider');\n    }\n    return context;\n  };\n\n  return {\n    Provider,\n    useStateContext,\n    useDispatchContext\n  };\n} ",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/types-fix.d.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/ui/UITypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/visualization/CommonTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/visualization/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/visualizations/D3AnimationTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/visualizations/D3DragTypes.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-empty-object-type",
        "severity": 2,
        "message": "An interface declaring no members is equivalent to its supertype.",
        "line": 16,
        "column": 18,
        "nodeType": "Identifier",
        "messageId": "noEmptyInterfaceWithSuper",
        "endLine": 16,
        "endColumn": 32,
        "suggestions": [
          {
            "messageId": "replaceEmptyInterfaceWithSuper",
            "fix": {
              "range": [494, 750],
              "text": "type TypedDragEvent<\n  Datum extends object,\n  ParentDatum extends object = object,\n  ContainerElement extends Element = Element,\n> = d3.D3DragEvent<ContainerElement, Datum, ParentDatum>"
            },
            "desc": "Replace empty interface with a type alias."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * D3 Drag Types\n *\n * This module provides type-safe wrappers and utilities for D3 drag behaviors.\n * It ensures proper typing for drag events, subjects, and related operations\n * while maintaining compatibility with D3's drag behavior API.\n */\n\nimport * as d3 from 'd3';\nimport { SimulationNodeDatum } from './D3Types';\n\n/**\n * Type-safe drag event structure that properly extends D3's drag event\n * with generic type parameters for subject, parent data, and container element\n */\nexport interface TypedDragEvent<\n  Datum extends object,\n  ParentDatum extends object = object,\n  ContainerElement extends Element = Element,\n> extends d3.D3DragEvent<ContainerElement, Datum, ParentDatum> {\n  // Additional type-safe properties can be added here\n}\n\n/**\n * Type-safe drag behavior configuration\n */\nexport interface DragBehaviorConfig<\n  Datum extends object,\n  ParentDatum extends object = object,\n  ContainerElement extends Element = Element,\n> {\n  /**\n   * (...args: unknown[]) => unknown called when drag starts\n   */\n  onDragStart?: (event: TypedDragEvent<Datum, ParentDatum, ContainerElement>) => void;\n\n  /**\n   * (...args: unknown[]) => unknown called during dragging\n   */\n  onDrag?: (event: TypedDragEvent<Datum, ParentDatum, ContainerElement>) => void;\n\n  /**\n   * (...args: unknown[]) => unknown called when drag ends\n   */\n  onDragEnd?: (event: TypedDragEvent<Datum, ParentDatum, ContainerElement>) => void;\n\n  /**\n   * Container to which the drag behavior should listen for events\n   * Defaults to the window if not specified\n   */\n  container?: ContainerElement | null;\n\n  /**\n   * Filter function to determine if a drag should start\n   * Return true to allow the drag, false to prevent it\n   */\n  filter?: (event: Event, datum: Datum) => boolean;\n\n  /**\n   * Whether to enable drag events on touchscreen devices\n   * Defaults to true\n   */\n  touchable?: boolean;\n}\n\n/**\n * Creates a type-safe D3 drag behavior\n *\n * @param config Configuration for the drag behavior\n * @returns A properly typed D3 drag behavior\n */\nexport function createTypedDragBehavior<\n  Datum extends object,\n  ParentDatum extends object = object,\n  ContainerElement extends Element = Element,\n>(\n  config: DragBehaviorConfig<Datum, ParentDatum, ContainerElement> = {}\n): d3.DragBehavior<ContainerElement, Datum, ParentDatum> {\n  // Create the drag behavior\n  const drag = d3.drag<ContainerElement, Datum, ParentDatum>();\n\n  // Configure drag behavior based on provided config\n  if (config.onDragStart) {\n    drag.on('start', config.onDragStart);\n  }\n\n  if (config.onDrag) {\n    drag.on('drag', config.onDrag);\n  }\n\n  if (config.onDragEnd) {\n    drag.on('end', config.onDragEnd);\n  }\n\n  if (config.container) {\n    drag.container(() => config.container as ContainerElement);\n  }\n\n  if (config.filter) {\n    drag.filter((event: unknown, d: Datum) => config.filter!(event, d));\n  }\n\n  if (config.touchable !== undefined) {\n    drag.touchable(config.touchable);\n  }\n\n  return drag;\n}\n\n/**\n * Creates a drag behavior specifically for simulation nodes\n * This is particularly useful for flow diagrams or network visualizations\n *\n * @param simulation The D3 force simulation\n * @param config Additional configuration for the drag behavior\n * @returns A properly typed D3 drag behavior for simulation nodes\n */\nexport function createSimulationDragBehavior<\n  NodeDatum extends SimulationNodeDatum,\n  ContainerElement extends Element = SVGElement,\n>(\n  simulation: d3.Simulation<NodeDatum, undefined>,\n  config: Partial<DragBehaviorConfig<NodeDatum, object, ContainerElement>> = {}\n): d3.DragBehavior<ContainerElement, NodeDatum, object> {\n  // Standard drag behavior for force simulations\n  const handleDragStart = (event: TypedDragEvent<NodeDatum, object, ContainerElement>) => {\n    if (!event.active) simulation.alphaTarget(0.3).restart();\n    // Fix the node position during drag\n    event.subject.fx = event.subject.x;\n    event.subject.fy = event.subject.y;\n\n    // Call custom handler if provided\n    if (config.onDragStart) {\n      config.onDragStart(event);\n    }\n  };\n\n  const handleDrag = (event: TypedDragEvent<NodeDatum, object, ContainerElement>) => {\n    // Update the fixed position to follow the pointer\n    event.subject.fx = event.x;\n    event.subject.fy = event.y;\n\n    // Call custom handler if provided\n    if (config.onDrag) {\n      config.onDrag(event);\n    }\n  };\n\n  const handleDragEnd = (event: TypedDragEvent<NodeDatum, object, ContainerElement>) => {\n    if (!event.active) simulation.alphaTarget(0);\n    // Release the fixed position when drag ends (unless configured otherwise)\n    event.subject.fx = null;\n    event.subject.fy = null;\n\n    // Call custom handler if provided\n    if (config.onDragEnd) {\n      config.onDragEnd(event);\n    }\n  };\n\n  // Create the drag behavior with simulation-specific defaults\n  return createTypedDragBehavior<NodeDatum, object, ContainerElement>({\n    onDragStart: handleDragStart,\n    onDrag: handleDrag,\n    onDragEnd: handleDragEnd,\n    ...config,\n  });\n}\n\n/**\n * Creates a custom drag behavior for visualization elements that need special handling\n *\n * @param options Custom options for specialized drag behavior\n * @returns A properly typed D3 drag behavior\n */\nexport function createCustomDragBehavior<\n  Datum extends object,\n  ParentDatum extends object = object,\n  ContainerElement extends Element = Element,\n>(\n  options: {\n    /** Maintain position relative to container */\n    constrainToContainer?: boolean;\n    /** Snap to grid with specified size */\n    snapToGrid?: number;\n    /** Only allow horizontal movement */\n    horizontalOnly?: boolean;\n    /** Only allow vertical movement */\n    verticalOnly?: boolean;\n    /** Minimum allowed position */\n    minPosition?: { x?: number; y?: number };\n    /** Maximum allowed position */\n    maxPosition?: { x?: number; y?: number };\n  } & DragBehaviorConfig<Datum, ParentDatum, ContainerElement>\n): d3.DragBehavior<ContainerElement, Datum, ParentDatum> {\n  // Wrap the standard drag handlers with custom behavior\n  const onDrag = (event: TypedDragEvent<Datum, ParentDatum, ContainerElement>) => {\n    let x = event.x;\n    let y = event.y;\n\n    // Apply custom constraints\n    if (options.snapToGrid) {\n      const gridSize = options.snapToGrid;\n      x = Math.round(x / gridSize) * gridSize;\n      y = Math.round(y / gridSize) * gridSize;\n    }\n\n    if (options.horizontalOnly) {\n      y = (event.subject as unknown).y;\n    }\n\n    if (options.verticalOnly) {\n      x = (event.subject as unknown).x;\n    }\n\n    if (options.minPosition) {\n      if (options.minPosition.x !== undefined) {\n        x = Math.max(x, options.minPosition.x);\n      }\n      if (options.minPosition.y !== undefined) {\n        y = Math.max(y, options.minPosition.y);\n      }\n    }\n\n    if (options.maxPosition) {\n      if (options.maxPosition.x !== undefined) {\n        x = Math.min(x, options.maxPosition.x);\n      }\n      if (options.maxPosition.y !== undefined) {\n        y = Math.min(y, options.maxPosition.y);\n      }\n    }\n\n    // Update event coordinates with constrained values\n    event.x = x;\n    event.y = y;\n\n    // Call the original drag handler if provided\n    if (options.onDrag) {\n      options.onDrag(event);\n    }\n  };\n\n  // Create a drag behavior with the wrapped handler\n  return createTypedDragBehavior<Datum, ParentDatum, ContainerElement>({\n    ...options,\n    onDrag: onDrag,\n  });\n}\n\n/**\n * Helper for applying a typed drag behavior to a D3 selection\n *\n * @param selection The D3 selection to apply the drag behavior to\n * @param dragBehavior The typed drag behavior to apply\n * @returns The selection with drag behavior applied\n */\nexport function applyDragBehavior<\n  GElement extends Element,\n  Datum extends object,\n  PElement extends Element = Element,\n  PDatum extends object = object,\n>(\n  selection: d3.Selection<GElement, Datum, PElement, PDatum>,\n  dragBehavior: d3.DragBehavior<Element, Datum, PDatum>\n): d3.Selection<GElement, Datum, PElement, PDatum> {\n  return selection.call(dragBehavior as unknown);\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/visualizations/D3SelectionTypes.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'elementType' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 44,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 44,
        "endColumn": 14
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'elementType' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 58,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 58,
        "endColumn": 14
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'elementType' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 96,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 96,
        "endColumn": 14
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * D3 Selection Types\n *\n * This module provides type-safe wrappers and utilities for D3 selections.\n * It ensures proper typing for selection operations, data binding, and DOM manipulations\n * while maintaining compatibility with D3's selection API.\n */\n\nimport * as d3 from 'd3';\n\n/**\n * Type-safe selection creator for SVG elements\n *\n * @param selector CSS selector string\n * @returns A properly typed D3 selection\n */\nexport function selectSvg(\n  selector: string\n): d3.Selection<SVGSVGElement, unknown, HTMLElement, unknown> {\n  return d3.select<SVGSVGElement, unknown>(selector);\n}\n\n/**\n * Type-safe selection creator for SVG group elements\n *\n * @param selector CSS selector string\n * @returns A properly typed D3 selection\n */\nexport function selectGroup(\n  selector: string\n): d3.Selection<SVGGElement, unknown, HTMLElement, unknown> {\n  return d3.select<SVGGElement, unknown>(selector);\n}\n\n/**\n * Type-safe selection creator for any SVG element\n *\n * @param selector CSS selector string\n * @param elementType Type of SVG element to select\n * @returns A properly typed D3 selection\n */\nexport function selectSvgElement<E extends SVGElement>(\n  selector: string,\n  elementType: new () => E\n): d3.Selection<E, unknown, HTMLElement, unknown> {\n  return d3.select<E, unknown>(selector);\n}\n\n/**\n * Type-safe selection creator for HTML elements\n *\n * @param selector CSS selector string\n * @param elementType Type of HTML element to select\n * @returns A properly typed D3 selection\n */\nexport function selectHtmlElement<E extends HTMLElement>(\n  selector: string,\n  elementType: new () => E\n): d3.Selection<E, unknown, HTMLElement, unknown> {\n  return d3.select<E, unknown>(selector);\n}\n\n/**\n * Type-safe selection creator for multiple elements\n *\n * @param selector CSS selector string\n * @returns A properly typed D3 selection\n */\nexport function selectAllSvg(\n  selector: string\n): d3.Selection<SVGSVGElement, unknown, HTMLElement, unknown> {\n  return d3.selectAll<SVGSVGElement, unknown>(selector);\n}\n\n/**\n * Type-safe selection creator for multiple SVG group elements\n *\n * @param selector CSS selector string\n * @returns A properly typed D3 selection\n */\nexport function selectAllGroups(\n  selector: string\n): d3.Selection<SVGGElement, unknown, HTMLElement, unknown> {\n  return d3.selectAll<SVGGElement, unknown>(selector);\n}\n\n/**\n * Type-safe selection creator for any multiple SVG elements\n *\n * @param selector CSS selector string\n * @param elementType Type of SVG element to select\n * @returns A properly typed D3 selection\n */\nexport function selectAllSvgElements<E extends SVGElement>(\n  selector: string,\n  elementType: new () => E\n): d3.Selection<E, unknown, HTMLElement, unknown> {\n  return d3.selectAll<E, unknown>(selector);\n}\n\n/**\n * Type-safe data binding for selections\n *\n * @param selection The D3 selection to bind data to\n * @param data Array of data items to bind\n * @param key Data join key function or string\n * @returns A properly typed update selection\n */\nexport function bindData<GElement extends Element, Datum, PElement extends Element, PDatum>(\n  selection: d3.Selection<GElement, PDatum, PElement, unknown>,\n  data: Datum[],\n  key?: ((datum: Datum, index: number, groups: Datum[]) => string) | string\n): d3.Selection<GElement, Datum, PElement, PDatum> {\n  return selection.data(data, key as unknown);\n}\n\n/**\n * Type-safe join operation for selections\n *\n * @param selection The D3 selection to perform join on\n * @param elementType Tag name for new elements\n * @param enter (...args: unknown[]) => unknown to handle enter selection\n * @param update (...args: unknown[]) => unknown to handle update selection\n * @param exit (...args: unknown[]) => unknown to handle exit selection\n * @returns A merged selection\n */\nexport function joinElements<\n  GElement extends Element,\n  Datum,\n  PElement extends Element,\n  PDatum,\n  NewElement extends Element,\n>(\n  selection: d3.Selection<GElement, Datum, PElement, PDatum>,\n  elementType: string,\n  enter?: (\n    selection: d3.Selection<d3.EnterElement, Datum, PElement, PDatum>\n  ) => d3.Selection<NewElement, Datum, PElement, PDatum>,\n  update?: (\n    selection: d3.Selection<GElement, Datum, PElement, PDatum>\n  ) => d3.Selection<GElement, Datum, PElement, PDatum>,\n  exit?: (selection: d3.Selection<GElement, Datum, PElement, PDatum>) => void\n): d3.Selection<NewElement | GElement, Datum, PElement, PDatum> {\n  return selection.join(elementType, enter as unknown, update, exit) as d3.Selection<\n    NewElement | GElement,\n    Datum,\n    PElement,\n    PDatum\n  >;\n}\n\n/**\n * Type-safe attribute setter for selections\n *\n * @param selection The D3 selection to set attributes on\n * @param attributes Object containing attribute name-value pairs\n * @returns The selection with attributes applied\n */\nexport function setAttributes<GElement extends Element, Datum, PElement extends Element, PDatum>(\n  selection: d3.Selection<GElement, Datum, PElement, PDatum>,\n  attributes: Record<\n    string,\n    string | number | boolean | ((d: Datum, i: number) => string | number | boolean)\n  >\n): d3.Selection<GElement, Datum, PElement, PDatum> {\n  Object.entries(attributes).forEach(([key, value]) => {\n    if (typeof value === 'function') {\n      selection.attr(key, value as (d: Datum, i: number) => string);\n    } else {\n      selection.attr(key, value as string);\n    }\n  });\n\n  return selection;\n}\n\n/**\n * Type-safe style setter for selections\n *\n * @param selection The D3 selection to set styles on\n * @param styles Object containing style name-value pairs\n * @returns The selection with styles applied\n */\nexport function setStyles<GElement extends Element, Datum, PElement extends Element, PDatum>(\n  selection: d3.Selection<GElement, Datum, PElement, PDatum>,\n  styles: Record<\n    string,\n    string | number | boolean | ((d: Datum, i: number) => string | number | boolean)\n  >\n): d3.Selection<GElement, Datum, PElement, PDatum> {\n  Object.entries(styles).forEach(([key, value]) => {\n    if (typeof value === 'function') {\n      selection.style(key, value as (d: Datum, i: number) => string);\n    } else {\n      selection.style(key, value as string);\n    }\n  });\n\n  return selection;\n}\n\n/**\n * Type-safe append operation for selections\n *\n * @param selection The D3 selection to append to\n * @param elementType Type of element to append\n * @returns A selection of the newly appended elements\n */\nexport function appendElement<\n  GElement extends Element,\n  Datum,\n  PElement extends Element,\n  PDatum,\n  NewElement extends Element,\n>(\n  selection: d3.Selection<GElement, Datum, PElement, PDatum>,\n  elementType: string\n): d3.Selection<NewElement, Datum, PElement, PDatum> {\n  return selection.append<NewElement>(elementType);\n}\n\n/**\n * Type-safe event handler attachment for selections\n *\n * @param selection The D3 selection to attach event handlers to\n * @param eventType Type of event to listen for\n * @param listener Event listener function\n * @returns The selection with event handler attached\n */\nexport function addEventHandler<GElement extends Element, Datum, PElement extends Element, PDatum>(\n  selection: d3.Selection<GElement, Datum, PElement, PDatum>,\n  eventType: string,\n  listener: (event: Event, d: Datum, i: number, g: GElement[]) => void\n): d3.Selection<GElement, Datum, PElement, PDatum> {\n  return selection.on(eventType, listener);\n}\n\n/**\n * Type-safe transition creator for selections\n *\n * @param selection The D3 selection to create a transition on\n * @param name Optional name for the transition\n * @returns A properly typed transition\n */\nexport function createTransition<GElement extends Element, Datum, PElement extends Element, PDatum>(\n  selection: d3.Selection<GElement, Datum, PElement, PDatum>,\n  name?: string\n): d3.Transition<GElement, Datum, PElement, PDatum> {\n  return name ? selection.transition(name) : selection.transition();\n}\n\n/**\n * Creates a typed builder for D3 selections to enable fluent chaining of operations\n *\n * @param selection The D3 selection to wrap\n * @returns A builder object with fluent methods\n */\nexport function createSelectionBuilder<\n  GElement extends Element,\n  Datum,\n  PElement extends Element,\n  PDatum,\n>(selection: d3.Selection<GElement, Datum, PElement, PDatum>) {\n  return {\n    /**\n     * The underlying D3 selection\n     */\n    selection,\n\n    /**\n     * Sets attributes on the selection\n     */\n    attr(\n      key: string,\n      value: string | number | boolean | ((d: Datum, i: number) => string | number | boolean)\n    ) {\n      selection.attr(key, value as unknown);\n      return this;\n    },\n\n    /**\n     * Sets multiple attributes from an object\n     */\n    attrs(\n      attributes: Record<\n        string,\n        string | number | boolean | ((d: Datum, i: number) => string | number | boolean)\n      >\n    ) {\n      return setAttributes(selection, attributes), this;\n    },\n\n    /**\n     * Sets a style property on the selection\n     */\n    style(\n      key: string,\n      value: string | number | boolean | ((d: Datum, i: number) => string | number | boolean)\n    ) {\n      selection.style(key, value as unknown);\n      return this;\n    },\n\n    /**\n     * Sets multiple style properties from an object\n     */\n    styles(\n      styles: Record<\n        string,\n        string | number | boolean | ((d: Datum, i: number) => string | number | boolean)\n      >\n    ) {\n      return setStyles(selection, styles), this;\n    },\n\n    /**\n     * Sets text content on the selection\n     */\n    text(value: string | ((d: Datum, i: number) => string)) {\n      selection.text(value as unknown);\n      return this;\n    },\n\n    /**\n     * Sets HTML content on the selection\n     */\n    html(value: string | ((d: Datum, i: number) => string)) {\n      selection.html(value as unknown);\n      return this;\n    },\n\n    /**\n     * Appends a new element to each element in the selection\n     */\n    append<NewElement extends Element>(elementType: string) {\n      const newSelection = appendElement<GElement, Datum, PElement, PDatum, NewElement>(\n        selection,\n        elementType\n      );\n      return createSelectionBuilder(newSelection);\n    },\n\n    /**\n     * Adds an event listener to the selection\n     */\n    on(eventType: string, listener: (event: Event, d: Datum, i: number, g: GElement[]) => void) {\n      selection.on(eventType, listener);\n      return this;\n    },\n\n    /**\n     * Creates a transition on the selection\n     */\n    transition(name?: string) {\n      const transition = createTransition(selection, name);\n      return createTransitionBuilder(transition);\n    },\n\n    /**\n     * Filters the selection\n     */\n    filter(filterFn: (d: Datum, i: number) => boolean) {\n      const filtered = selection.filter(filterFn);\n      return createSelectionBuilder(filtered);\n    },\n\n    /**\n     * Binds new data to the selection\n     */\n    data<NewDatum>(\n      data: NewDatum[],\n      key?: ((datum: NewDatum, index: number, groups: NewDatum[]) => string) | string\n    ) {\n      const newSelection = bindData<GElement, NewDatum, PElement, PDatum>(\n        selection as unknown,\n        data,\n        key\n      );\n      return createSelectionBuilder(newSelection);\n    },\n\n    /**\n     * Joins data with elements\n     */\n    join<NewElement extends Element>(\n      elementType: string,\n      enter?: (\n        selection: d3.Selection<d3.EnterElement, Datum, PElement, PDatum>\n      ) => d3.Selection<NewElement, Datum, PElement, PDatum>,\n      update?: (\n        selection: d3.Selection<GElement, Datum, PElement, PDatum>\n      ) => d3.Selection<GElement, Datum, PElement, PDatum>,\n      exit?: (selection: d3.Selection<GElement, Datum, PElement, PDatum>) => void\n    ) {\n      const joined = joinElements<GElement, Datum, PElement, PDatum, NewElement>(\n        selection,\n        elementType,\n        enter,\n        update,\n        exit\n      );\n      return createSelectionBuilder(joined);\n    },\n\n    /**\n     * Calls a function with the selection\n     */\n    call(fn: (selection: d3.Selection<GElement, Datum, PElement, PDatum>) => void) {\n      selection.call(fn);\n      return this;\n    },\n  };\n}\n\n/**\n * Creates a typed builder for D3 transitions to enable fluent chaining of operations\n *\n * @param transition The D3 transition to wrap\n * @returns A builder object with fluent methods\n */\nexport function createTransitionBuilder<\n  GElement extends Element,\n  Datum,\n  PElement extends Element,\n  PDatum,\n>(transition: d3.Transition<GElement, Datum, PElement, PDatum>) {\n  return {\n    /**\n     * The underlying D3 transition\n     */\n    transition,\n\n    /**\n     * Sets the duration of the transition\n     */\n    duration(milliseconds: number) {\n      transition.duration(milliseconds);\n      return this;\n    },\n\n    /**\n     * Sets the delay of the transition\n     */\n    delay(milliseconds: number | ((d: Datum, i: number) => number)) {\n      transition.delay(milliseconds as unknown);\n      return this;\n    },\n\n    /**\n     * Sets the easing function of the transition\n     */\n    ease(easingFn: d3.EasingFn) {\n      transition.ease(easingFn);\n      return this;\n    },\n\n    /**\n     * Sets an attribute with a transition\n     */\n    attr(\n      key: string,\n      value: string | number | boolean | ((d: Datum, i: number) => string | number | boolean)\n    ) {\n      transition.attr(key, value as unknown);\n      return this;\n    },\n\n    /**\n     * Sets a style property with a transition\n     */\n    style(\n      key: string,\n      value: string | number | boolean | ((d: Datum, i: number) => string | number | boolean)\n    ) {\n      transition.style(key, value as unknown);\n      return this;\n    },\n\n    /**\n     * Adds an event listener for transition events\n     */\n    on(eventType: 'start' | 'end' | 'interrupt', listener: (event: Event, d: Datum) => void) {\n      transition.on(eventType, listener);\n      return this;\n    },\n\n    /**\n     * Calls a function with the transition\n     */\n    call(fn: (transition: d3.Transition<GElement, Datum, PElement, PDatum>) => void) {\n      transition.call(fn);\n      return this;\n    },\n  };\n}\n\n/**\n * Creates a type-safe selection for a new SVG element\n *\n * @param parent The parent element to append the SVG to\n * @param width Width of the SVG\n * @param height Height of the SVG\n * @returns A selection builder for the new SVG\n */\nexport function createSvg(\n  parent: string | d3.Selection<HTMLElement, unknown, HTMLElement, unknown>,\n  width: number,\n  height: number\n) {\n  const parentSelection =\n    typeof parent === 'string' ? d3.select<HTMLElement, unknown>(parent) : parent;\n\n  const svg = parentSelection\n    .append<SVGSVGElement>('svg')\n    .attr('width', width)\n    .attr('height', height)\n    .attr('viewBox', `0 0 ${width} ${height}`)\n    .style('overflow', 'visible');\n\n  return createSelectionBuilder(svg);\n}\n\n/**\n * Creates a defs element for SVG definitions like markers, patterns, etc.\n *\n * @param svg The SVG element to append defs to\n * @returns A selection of the defs element\n */\nexport function createDefs(svg: d3.Selection<SVGSVGElement, unknown, HTMLElement, unknown>) {\n  return svg.append<SVGDefsElement>('defs');\n}\n\n/**\n * Creates a marker definition for arrow heads etc.\n *\n * @param defs The defs element to append the marker to\n * @param id Unique ID for the marker\n * @param options Configuration options for the marker\n * @returns A selection of the marker element\n */\nexport function createMarker(\n  defs: d3.Selection<SVGDefsElement, unknown, HTMLElement, unknown>,\n  id: string,\n  options: {\n    width?: number;\n    height?: number;\n    refX?: number;\n    refY?: number;\n    viewBox?: string;\n    orient?: string;\n    path?: string;\n    color?: string;\n  } = {}\n) {\n  const {\n    width = 10,\n    height = 10,\n    refX = 5,\n    refY = 5,\n    viewBox = '0 0 10 10',\n    orient = 'auto',\n    path = 'M0,0L10,5L0,10z',\n    color = 'black',\n  } = options;\n\n  const marker = defs\n    .append<SVGMarkerElement>('marker')\n    .attr('id', id)\n    .attr('markerWidth', width)\n    .attr('markerHeight', height)\n    .attr('refX', refX)\n    .attr('refY', refY)\n    .attr('viewBox', viewBox)\n    .attr('orient', orient)\n    .attr('markerUnits', 'userSpaceOnUse');\n\n  marker.append<SVGPathElement>('path').attr('d', path).attr('fill', color);\n\n  return marker;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/visualizations/D3Types.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/visualizations/D3ValidationHooks.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/visualizations/D3Validators.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/visualizations/D3ZoomTypes.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'PElement' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 18,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 18,
        "endColumn": 11
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'PDatum' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 19,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 19,
        "endColumn": 9
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 19,
        "column": 12,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 19,
        "endColumn": 15,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [553, 556], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [553, 556], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 28,
        "column": 74,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 28,
        "endColumn": 77,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [803, 806], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [803, 806], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 93,
        "column": 78,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 93,
        "endColumn": 81,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [2244, 2247], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [2244, 2247], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 167,
        "column": 91,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 167,
        "endColumn": 94,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [4383, 4386], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [4383, 4386], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 173,
        "column": 56,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 173,
        "endColumn": 59,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [4665, 4668], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [4665, 4668], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 289,
        "column": 11,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 289,
        "endColumn": 14,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [8171, 8174], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [8171, 8174], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 295,
        "column": 51,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 295,
        "endColumn": 54,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [8356, 8359], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [8356, 8359], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 7,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * D3 Zoom Types\n *\n * This module provides type-safe wrappers and utilities for D3 zoom behaviors.\n * It ensures proper typing for zoom events, transformations, and related operations\n * while maintaining compatibility with D3's zoom behavior API.\n */\n\nimport * as d3 from 'd3';\n\n/**\n * Type-safe zoom event structure that properly extends D3's zoom event\n * with generic type parameters for the container element\n */\nexport interface TypedZoomEvent<\n  Element extends d3.BaseType,\n  Datum,\n  PElement extends d3.BaseType = d3.BaseType,\n  PDatum = any,\n> extends d3.D3ZoomEvent<Element, Datum> {\n  // Additional type-safe properties can be added here\n  sourceEvent: Event;\n}\n\n/**\n * Type-safe zoom behavior configuration\n */\nexport interface ZoomBehaviorConfig<Element extends d3.BaseType, Datum = any> {\n  /**\n   * (...args: unknown[]) => unknown called when zoom starts\n   */\n  onZoomStart?: (event: TypedZoomEvent<Element, Datum>) => void;\n\n  /**\n   * (...args: unknown[]) => unknown called during zooming\n   */\n  onZoom?: (event: TypedZoomEvent<Element, Datum>) => void;\n\n  /**\n   * (...args: unknown[]) => unknown called when zoom ends\n   */\n  onZoomEnd?: (event: TypedZoomEvent<Element, Datum>) => void;\n\n  /**\n   * Minimum zoom scale factor\n   * Defaults to 0.1\n   */\n  scaleExtentMin?: number;\n\n  /**\n   * Maximum zoom scale factor\n   * Defaults to 8\n   */\n  scaleExtentMax?: number;\n\n  /**\n   * Filter function to determine if a zoom should be allowed\n   * Return true to allow the zoom, false to prevent it\n   */\n  filter?: (event: Event) => boolean;\n\n  /**\n   * Whether to enable wheel zooming\n   * Defaults to true\n   */\n  wheelZoom?: boolean;\n\n  /**\n   * Whether to enable double-click to zoom\n   * Defaults to true\n   */\n  dblClickZoom?: boolean;\n\n  /**\n   * Duration of transition for zoom events in milliseconds\n   * Set to 0 to disable transitions\n   * Defaults to 250ms\n   */\n  transitionDuration?: number;\n\n  /**\n   * Initial transform to apply\n   */\n  initialTransform?: d3.ZoomTransform;\n}\n\n/**\n * Creates a type-safe D3 zoom behavior\n *\n * @param config Configuration for the zoom behavior\n * @returns A properly typed D3 zoom behavior\n */\nexport function createTypedZoomBehavior<Element extends d3.BaseType, Datum = any>(\n  config: ZoomBehaviorConfig<Element, Datum> = {}\n): d3.ZoomBehavior<Element, Datum> {\n  // Create the zoom behavior\n  const zoom = d3.zoom<Element, Datum>();\n\n  // Configure zoom behavior based on provided config\n  if (config.onZoomStart) {\n    zoom.on('start', config.onZoomStart);\n  }\n\n  if (config.onZoom) {\n    zoom.on('zoom', config.onZoom);\n  }\n\n  if (config.onZoomEnd) {\n    zoom.on('end', config.onZoomEnd);\n  }\n\n  // Set scale extent (min/max zoom level)\n  const minScale = config.scaleExtentMin ?? 0.1;\n  const maxScale = config.scaleExtentMax ?? 8;\n  zoom.scaleExtent([minScale, maxScale]);\n\n  // Apply filter if provided\n  if (config.filter) {\n    zoom.filter(config.filter);\n  }\n\n  // Configure wheel zoom\n  if (config.wheelZoom !== undefined) {\n    // If wheelZoom is false, we need to filter out wheel events\n    if (!config.wheelZoom) {\n      const originalFilter = zoom.filter();\n      zoom.filter(function (event: unknown) {\n        return event.type !== 'wheel' && originalFilter.call(this, event);\n      });\n    }\n  }\n\n  // Configure double-click zoom\n  if (config.dblClickZoom !== undefined) {\n    zoom.interpolate(config.dblClickZoom ? d3.interpolateZoom : null);\n  }\n\n  return zoom;\n}\n\n/**\n * Helper to apply a typed zoom behavior to a D3 selection\n *\n * @param selection The D3 selection to apply the zoom behavior to\n * @param zoomBehavior The typed zoom behavior to apply\n * @returns The selection with zoom behavior applied\n */\nexport function applyZoomBehavior<\n  GElement extends d3.BaseType,\n  Datum,\n  PElement extends d3.BaseType,\n  PDatum,\n>(\n  selection: d3.Selection<GElement, Datum, PElement, PDatum>,\n  zoomBehavior: d3.ZoomBehavior<GElement, Datum>\n): d3.Selection<GElement, Datum, PElement, PDatum> {\n  return selection.call(zoomBehavior);\n}\n\n/**\n * Creates a zoom behavior specifically for SVG visualizations\n * This is particularly useful for pan/zoom in diagrams or charts\n *\n * @param config Configuration for the SVG zoom behavior\n * @returns A properly typed D3 zoom behavior for SVG elements\n */\nexport function createSvgZoomBehavior<Element extends SVGElement = SVGSVGElement, Datum = any>(\n  config: ZoomBehaviorConfig<Element, Datum> & {\n    /**\n     * Target element (usually a group) to transform during zoom\n     * If not provided, zooming will apply to the element the zoom behavior is attached to\n     */\n    targetElement?: d3.Selection<SVGGElement, unknown, any, unknown>;\n\n    /**\n     * Whether to enable panning\n     * Defaults to true\n     */\n    enablePan?: boolean;\n\n    /**\n     * Whether to constrain panning to prevent the content from leaving the viewport\n     * Defaults to false\n     */\n    constrainPan?: boolean;\n\n    /**\n     * Extent of the viewable area [x, y, width, height]\n     * Defaults to the element's viewport\n     */\n    extent?: [[number, number], [number, number]];\n  } = {}\n): d3.ZoomBehavior<Element, Datum> {\n  // Create base zoom behavior\n  const zoom = createTypedZoomBehavior<Element, Datum>(config);\n\n  // Configure SVG-specific options\n  if (config.enablePan === false) {\n    // Disable panning by only allowing scaling transformations\n    zoom.on('zoom', (event: unknown) => {\n      const transform = event.transform;\n      const newTransform = d3.zoomIdentity.scale(transform.k);\n\n      if (config.targetElement) {\n        config.targetElement.attr('transform', `scale(${transform.k})`);\n      }\n\n      // Call the original zoom handler if provided\n      if (config.onZoom) {\n        // Create a modified event with the new transform\n        const modifiedEvent = Object.assign({}, event, { transform: newTransform });\n        config.onZoom(modifiedEvent as TypedZoomEvent<Element, Datum>);\n      }\n    });\n  } else if (config.targetElement) {\n    // Apply normal pan/zoom transformation to target element\n    zoom.on('zoom', (event: unknown) => {\n      config.targetElement!.attr('transform', event.transform);\n\n      // Call the original zoom handler if provided\n      if (config.onZoom) {\n        config.onZoom(event as TypedZoomEvent<Element, Datum>);\n      }\n    });\n  }\n\n  // Set extent if provided\n  if (config.extent) {\n    zoom.extent(config.extent);\n  }\n\n  // Add constraint handling for panning\n  if (config.constrainPan) {\n    const originalZoom = zoom.on('zoom');\n\n    zoom.on('zoom', (event: unknown) => {\n      // Constrain the transform to prevent content from leaving viewport\n      const transform = event.transform;\n      const constrainedTransform = constrainTransform(transform, config.extent);\n\n      // Update the event transform with the constrained one\n      event.transform = constrainedTransform;\n\n      // Call the original zoom handler\n      if (originalZoom) {\n        originalZoom.call(this, event);\n      }\n    });\n  }\n\n  return zoom;\n}\n\n/**\n * Constrains a zoom transform to keep content within the viewport\n *\n * @param transform The transform to constrain\n * @param extent The extent of the viewable area\n * @returns A constrained transform\n */\nfunction constrainTransform(\n  transform: d3.ZoomTransform,\n  extent?: [[number, number], [number, number]]\n): d3.ZoomTransform {\n  if (!extent) return transform;\n\n  const [[x0, y0], [x1, y1]] = extent;\n  const width = x1 - x0;\n  const height = y1 - y0;\n\n  // Calculate constraints based on scale and extent\n  const maxX = width * (1 - transform.k);\n  const maxY = height * (1 - transform.k);\n\n  // Create a new transform with constrained values\n  return d3.zoomIdentity\n    .translate(Math.min(0, Math.max(transform.x, maxX)), Math.min(0, Math.max(transform.y, maxY)))\n    .scale(transform.k);\n}\n\n/**\n * Creates a zoom behavior for panning and zooming a d3 simulation visualization\n *\n * @param config Configuration for the simulation visualization zoom behavior\n * @returns A properly typed D3 zoom behavior for simulation visualizations\n */\nexport function createSimulationZoomBehavior<\n  Element extends SVGElement = SVGSVGElement,\n  Datum = any,\n>(\n  config: ZoomBehaviorConfig<Element, Datum> & {\n    /**\n     * The container group that holds all simulation elements\n     */\n    container: d3.Selection<SVGGElement, unknown, any, unknown>;\n\n    /**\n     * (...args: unknown[]) => unknown to update the simulation view after zoom/pan\n     */\n    updateView?: (transform: d3.ZoomTransform) => void;\n  }\n): d3.ZoomBehavior<Element, Datum> {\n  const { container, updateView, ...zoomConfig } = config;\n\n  // Handler for zoom events\n  const handleZoom = (event: TypedZoomEvent<Element, Datum>) => {\n    // Apply transform to the container\n    container.attr('transform', event.transform.toString());\n\n    // Call custom update function if provided\n    if (updateView) {\n      updateView(event.transform);\n    }\n\n    // Call original handler if provided\n    if (config.onZoom) {\n      config.onZoom(event);\n    }\n  };\n\n  // Create the zoom behavior\n  return createTypedZoomBehavior<Element, Datum>({\n    ...zoomConfig,\n    onZoom: handleZoom,\n  });\n}\n\n/**\n * Helper function to get the initial transform to fit content within a viewport\n *\n * @param width Width of the viewport\n * @param height Height of the viewport\n * @param contentWidth Width of the content to fit\n * @param contentHeight Height of the content to fit\n * @param padding Padding to add around the content (default: 20)\n * @returns ZoomTransform that will fit the content within the viewport\n */\nexport function getFitToViewportTransform(\n  width: number,\n  height: number,\n  contentWidth: number,\n  contentHeight: number,\n  padding: number = 20\n): d3.ZoomTransform {\n  // Calculate scale to fit content\n  const scaleX = (width - padding * 2) / contentWidth;\n  const scaleY = (height - padding * 2) / contentHeight;\n  const scale = Math.min(scaleX, scaleY, 1); // Don't scale up more than 1x\n\n  // Calculate translation to center content\n  const translateX = (width - contentWidth * scale) / 2;\n  const translateY = (height - contentHeight * scale) / 2;\n\n  return d3.zoomIdentity.translate(translateX, translateY).scale(scale);\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/visualizations/FlowTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/weapons/WeaponTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/weapons/WeaponUpgrades.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/ui/components/Badge/Badge.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/ui/components/Badge/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/ui/components/Badge/variants/StatusBadge.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/ui/components/Badge/variants/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/ui/components/Button/Button.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/ui/components/Button/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/ui/components/Button/variants/AbilityButton.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/ui/components/Card/Card.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/ui/components/Card/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/ui/components/Card/variants/ModuleCard.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/ui/components/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/ResourceTypeConverter.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/ResourceTypeMigration.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/cn.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/combat/scanRadiusUtils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/dataTransforms/chartTransforms.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'AnalysisType' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 19,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 19,
        "endColumn": 15
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Chart Data Transformation Utilities\n * \n * This module provides standardized utilities for transforming data\n * for visualization components. It consolidates common patterns for\n * extracting, processing, and formatting chart data.\n */\n\nimport { \n  ChartDataRecord,\n  ClusterPoint,\n  ForecastPoint,\n  PredictionPoint,\n  ResourceGridCell,\n} from '../../types/exploration/AnalysisComponentTypes';\nimport { \n  AnalysisResult, \n  DataPoint,\n  AnalysisType\n} from '../../types/exploration/DataAnalysisTypes';\nimport { ResourceType } from \"./../../types/resources/ResourceTypes\";\n\n//=============================================================================\n// Type Guards\n//=============================================================================\n\n/**\n * Type guard to check if a value is a number\n */\nexport function isNumber(value: unknown): value is number {\n  return typeof value === 'number' && !isNaN(value);\n}\n\n/**\n * Type guard to check if a value is a string\n */\nexport function isString(value: unknown): value is string {\n  return typeof value === 'string';\n}\n\n/**\n * Type guard to check if a value is an array\n */\nexport function isArray<T = unknown>(value: unknown): value is Array<T> {\n  return Array.isArray(value);\n}\n\n/**\n * Type guard to check if a value is an object\n */\nexport function isObject(value: unknown): value is Record<string, unknown> {\n  return typeof value === 'object' && value !== null && !Array.isArray(value);\n}\n\n//=============================================================================\n// Safe Data Extraction\n//=============================================================================\n\n/**\n * Safely extracts a number value from an object property\n * @param obj The object to extract from\n * @param key The property key\n * @param defaultValue Default value if property doesn't exist or isn't a number\n */\nexport function safelyExtractNumber(\n  obj: Record<string, unknown> | null | undefined,\n  key: string,\n  defaultValue = 0\n): number {\n  if (!obj) return defaultValue;\n  const value = obj[key];\n  return isNumber(value) ? value : defaultValue;\n}\n\n/**\n * Safely extracts a string value from an object property\n * @param obj The object to extract from\n * @param key The property key\n * @param defaultValue Default value if property doesn't exist or isn't a string\n */\nexport function safelyExtractString(\n  obj: Record<string, unknown> | null | undefined,\n  key: string,\n  defaultValue = ''\n): string {\n  if (!obj) return defaultValue;\n  const value = obj[key];\n  return isString(value) ? value : defaultValue;\n}\n\n/**\n * Safely extracts an array from an object property\n * @param obj The object to extract from\n * @param key The property key\n * @param defaultValue Default value if property doesn't exist or isn't an array\n */\nexport function safelyExtractArray<T = unknown>(\n  obj: Record<string, unknown> | null | undefined,\n  key: string,\n  defaultValue: T[] = []\n): T[] {\n  if (!obj) return defaultValue;\n  const value = obj[key];\n  return isArray<T>(value) ? value : defaultValue;\n}\n\n/**\n * Safely extracts an object from an object property\n * @param obj The object to extract from\n * @param key The property key\n * @param defaultValue Default value if property doesn't exist or isn't an object\n */\nexport function safelyExtractObject<T extends Record<string, unknown>>(\n  obj: Record<string, unknown> | null | undefined,\n  key: string,\n  defaultValue: T\n): T {\n  if (!obj) return defaultValue;\n  const value = obj[key];\n  return isObject(value) ? value as T : defaultValue;\n}\n\n/**\n * Safely extracts a property from a nested object structure\n * @param obj The object to extract from\n * @param path Path to the property using dot notation (e.g., 'properties.value')\n * @param defaultValue Default value if path doesn't exist\n */\nexport function safelyExtractPath<T>(\n  obj: Record<string, unknown> | null | undefined,\n  path: string,\n  defaultValue: T\n): T {\n  if (!obj) return defaultValue;\n  \n  const keys = path.split('.');\n  let current: unknown = obj;\n  \n  for (const key of keys) {\n    if (current === null || current === undefined || typeof current !== 'object') {\n      return defaultValue;\n    }\n    current = current[key];\n  }\n  \n  return (current !== null && current !== undefined) ? current as T : defaultValue;\n}\n\n//=============================================================================\n// Domain Calculations\n//=============================================================================\n\n/**\n * Calculates the domain (min/max) for a numeric data field\n * @param data Array of data objects\n * @param key Property key to extract\n * @param padding Optional padding percentage (0-1) to add to the domain\n */\nexport function calculateDomain(\n  data: Record<string, unknown>[],\n  key: string,\n  padding = 0.05\n): [number, number] {\n  if (!data || data.length === 0) {\n    return [0, 1];\n  }\n  \n  let min = Infinity;\n  let max = -Infinity;\n  \n  for (const item of data) {\n    const value = safelyExtractNumber(item, key, NaN);\n    if (!isNaN(value)) {\n      min = Math.min(min, value);\n      max = Math.max(max, value);\n    }\n  }\n  \n  // Handle edge cases\n  if (!isFinite(min) || !isFinite(max) || min === max) {\n    return min === max ? [min - 1, max + 1] : [0, 1];\n  }\n  \n  // Apply padding\n  const range = max - min;\n  const paddingAmount = range * padding;\n  return [min - paddingAmount, max + paddingAmount];\n}\n\n/**\n * Calculates multiple domains at once\n * @param data Array of data objects\n * @param keys Object mapping output keys to data property keys\n * @param padding Optional padding percentage\n */\nexport function calculateDomains(\n  data: Record<string, unknown>[],\n  keys: Record<string, string>,\n  padding = 0.05\n): Record<string, [number, number]> {\n  const domains: Record<string, [number, number]> = {};\n  \n  for (const [outputKey, dataKey] of Object.entries(keys)) {\n    domains[outputKey] = calculateDomain(data, dataKey, padding);\n  }\n  \n  return domains;\n}\n\n//=============================================================================\n// Color Mapping\n//=============================================================================\n\n/**\n * Creates a color scale function that maps numeric values to colors\n * @param domain Min/max value range\n * @param range Array of colors to interpolate between\n */\nexport function createColorScale(\n  domain: [number, number],\n  range: string[]\n): (value: number) => string {\n  return (value: number) => {\n    // Normalize value to 0-1 range\n    const normalizedValue = Math.max(0, Math.min(1, (value - domain[0]) / (domain[1] - domain[0])));\n    \n    // Map to color index\n    const index = Math.min(range.length - 1, Math.floor(normalizedValue * range.length));\n    return range[index];\n  };\n}\n\n/**\n * Maps resource types to standard colors\n * @param resourceType Resource type to get color for\n * @param defaultColor Default color if resource type is not recognized\n */\nexport function getResourceTypeColor(\n  resourceType: ResourceType | ResourceType,\n  defaultColor = '#888888'\n): string {\n  const resourceTypeColors: Record<ResourceType, string> = {\n    minerals: '#3D85C6', // Blue\n    energy: '#F1C232',   // Yellow/gold\n    population: '#6AA84F', // Green\n    research: '#9FC5E8',  // Light blue\n    plasma: '#D5A6BD',   // Purple\n    gas: '#C27BA0',      // Pink\n    exotic: '#CC0000',   // Red\n  };\n  \n  return (resourceTypeColors as Record<string, string>)[resourceType] || defaultColor;\n}\n\n/**\n * Converts a hex color code to RGB components\n * @param hex Hex color code (e.g., '#FF0000')\n */\nexport function hexToRgb(hex: string): { r: number; g: number; b: number } {\n  // Default to black if invalid hex\n  const defaultRgb = { r: 0, g: 0, b: 0 };\n  \n  // Remove # if present\n  const sanitizedHex = hex.replace(/^#/, '');\n  \n  // Handle different hex formats\n  if (!/^[0-9A-Fa-f]{3}$|^[0-9A-Fa-f]{6}$/.test(sanitizedHex)) {\n    return defaultRgb;\n  }\n  \n  let r, g, b;\n  \n  if (sanitizedHex.length === 3) {\n    // Expand shorthand form (e.g. \"03F\") to full form (e.g. \"0033FF\")\n    r = parseInt(sanitizedHex.charAt(0) + sanitizedHex.charAt(0), 16);\n    g = parseInt(sanitizedHex.charAt(1) + sanitizedHex.charAt(1), 16);\n    b = parseInt(sanitizedHex.charAt(2) + sanitizedHex.charAt(2), 16);\n  } else {\n    r = parseInt(sanitizedHex.substring(0, 2), 16);\n    g = parseInt(sanitizedHex.substring(2, 4), 16);\n    b = parseInt(sanitizedHex.substring(4, 6), 16);\n  }\n  \n  return { r, g, b };\n}\n\n//=============================================================================\n// Data Format Transformations\n//=============================================================================\n\n/**\n * Transforms cluster data from analysis results\n * @param result Analysis result containing cluster data\n * @param allData All data points\n */\nexport function transformClusterData(\n  result: AnalysisResult,\n  allData: ChartDataRecord[]\n): {\n  clusters: unknown[];\n  features: string[];\n  clusterPoints: ClusterPoint[];\n} {\n  if (!isArray(result.data.clusters)) {\n    return {\n      clusters: [],\n      features: [],\n      clusterPoints: [],\n    };\n  }\n  \n  const clusters = result.data.clusters as unknown[];\n  const features = safelyExtractArray<string>(result.data, 'features', []);\n  const clusterPoints: ClusterPoint[] = [];\n  \n  clusters.forEach(cluster => {\n    const clusterIndex = safelyExtractNumber(cluster, 'cluster', 0);\n    const pointIds = safelyExtractArray<string>(cluster, 'pointIds', []);\n    \n    pointIds.forEach(pointId => {\n      const originalPoint = allData.find(p => p.id === pointId);\n      if (!originalPoint) return;\n      \n      const featureValues = features.map(feature => {\n        const value = safelyExtractPath<unknown>(\n          originalPoint, \n          feature, \n          safelyExtractPath<unknown>(originalPoint, `properties.${feature}`, null)\n        );\n        \n        return isNumber(value) ? value : null;\n      });\n      \n      clusterPoints.push({\n        id: pointId,\n        name: safelyExtractString(originalPoint, 'name', `Point-${pointId}`),\n        type: safelyExtractString(originalPoint, 'type', 'unknown'),\n        cluster: clusterIndex,\n        features: featureValues,\n        distanceToCentroid: 0, // Default value\n        originalPoint: originalPoint as unknown as DataPoint,\n      });\n    });\n  });\n  \n  return {\n    clusters,\n    features,\n    clusterPoints,\n  };\n}\n\n/**\n * Transforms prediction data from analysis results\n * @param result Analysis result containing prediction data\n */\nexport function transformPredictionData(\n  result: AnalysisResult\n): {\n  predictions: PredictionPoint[];\n  forecast: ForecastPoint[];\n  model: string;\n  targetVariable: string;\n  features: string[];\n  metrics: unknown;\n  modelDetails: unknown;\n} {\n  // Extract data with type safety\n  const predictions = safelyExtractArray<PredictionPoint>(result.data, 'predictions', []);\n  const forecast = safelyExtractArray<ForecastPoint>(result.data, 'forecast', []);\n  const features = safelyExtractArray<string>(result.data, 'features', []);\n  const metrics = safelyExtractObject(result.data, 'metrics', { mse: 0, rmse: 0, mae: 0 });\n  const modelDetails = safelyExtractObject(result.data, 'modelDetails', {});\n  const model = safelyExtractString(result.data, 'model', 'unknown');\n  const targetVariable = safelyExtractString(\n    result.config?.parameters || {}, \n    'target', \n    ''\n  );\n  \n  // Process model details based on model type\n  let typedModelDetails: unknown;\n  \n  if (model === 'linear') {\n    typedModelDetails = {\n      coefficients: safelyExtractArray<number>(modelDetails, 'coefficients', [0]),\n      weights: safelyExtractArray<number>(modelDetails, 'weights', undefined),\n      featureImportance: safelyExtractArray(modelDetails, 'featureImportance', []),\n    };\n  } else if (model === 'neuralNetwork') {\n    const architecture = safelyExtractObject(modelDetails, 'architecture', {\n      inputSize: 0,\n      hiddenUnits: 0,\n      activation: 'relu',\n    });\n    \n    const training = safelyExtractObject(modelDetails, 'training', {\n      epochs: 0,\n      learningRate: 0,\n      batchSize: 0,\n    });\n    \n    const normalization = safelyExtractObject(modelDetails, 'normalization', undefined);\n    \n    typedModelDetails = {\n      architecture: {\n        inputSize: safelyExtractNumber(architecture, 'inputSize', 0),\n        hiddenUnits: safelyExtractNumber(architecture, 'hiddenUnits', 0),\n        activation: safelyExtractString(architecture, 'activation', 'relu'),\n      },\n      training: {\n        epochs: safelyExtractNumber(training, 'epochs', 0),\n        learningRate: safelyExtractNumber(training, 'learningRate', 0),\n        batchSize: safelyExtractNumber(training, 'batchSize', 0),\n      },\n      normalization: normalization ? {\n        means: safelyExtractArray<number>(normalization, 'means', []),\n        stdDevs: safelyExtractArray<number>(normalization, 'stdDevs', []),\n      } : undefined,\n    };\n  } else {\n    typedModelDetails = {\n      coefficients: [0],\n      featureImportance: [],\n    };\n  }\n  \n  return {\n    predictions,\n    forecast,\n    model,\n    targetVariable,\n    features,\n    metrics,\n    modelDetails: typedModelDetails,\n  };\n}\n\n/**\n * Transforms resource mapping data from analysis results\n * @param result Analysis result containing resource mapping data\n */\nexport function transformResourceMappingData(\n  result: AnalysisResult\n): {\n  resourcePoints: DataPoint[];\n  gridCells: ResourceGridCell[];\n  resourceTypes: ResourceType[];\n  valueMetric: string;\n  regionSize: number;\n  xRange: [number, number];\n  yRange: [number, number];\n  density: Record<string, number>;\n  insights: string[];\n  summary: string;\n} {\n  // Safely extract all data with proper type checking\n  const resourcePoints = safelyExtractArray<DataPoint>(result.data, 'resourcePoints', []);\n  const gridCells = safelyExtractArray<ResourceGridCell>(result.data, 'gridCells', []);\n  const resourceTypes = safelyExtractArray<ResourceType>(result.data, 'resourceTypes', []);\n  \n  const valueMetric = safelyExtractString(\n    result.data, \n    'valueMetric', \n    'amount'\n  ) as 'amount' | 'quality' | 'accessibility' | 'estimatedValue';\n  \n  const regionSize = safelyExtractNumber(result.data, 'regionSize', 1);\n  \n  // Ensure ranges are properly formatted\n  let xRange: [number, number] = [0, 0];\n  let yRange: [number, number] = [0, 0];\n  \n  if (\n    isArray(result.data.xRange) &&\n    result.data.xRange.length === 2 &&\n    isNumber(result.data.xRange[0]) &&\n    isNumber(result.data.xRange[1])\n  ) {\n    xRange = result.data.xRange as [number, number];\n  }\n  \n  if (\n    isArray(result.data.yRange) &&\n    result.data.yRange.length === 2 &&\n    isNumber(result.data.yRange[0]) &&\n    isNumber(result.data.yRange[1])\n  ) {\n    yRange = result.data.yRange as [number, number];\n  }\n  \n  // Extract remaining data\n  const density = safelyExtractObject(result.data, 'density', {});\n  const insights = safelyExtractArray<string>(result, 'insights', []);\n  const summary = safelyExtractString(result, 'summary', '');\n  \n  return {\n    resourcePoints,\n    gridCells,\n    resourceTypes,\n    valueMetric,\n    regionSize,\n    xRange,\n    yRange,\n    density,\n    insights,\n    summary,\n  };\n}\n\n/**\n * Transforms raw data points into scatter plot format\n * @param dataPoints Array of data points with coordinates\n * @param valueMetric Metric to use for point value\n */\nexport function transformToScatterFormat(\n  dataPoints: DataPoint[],\n  valueMetric: string = 'amount'\n): Array<{\n  id: string;\n  name: string;\n  x: number;\n  y: number;\n  value: number;\n  type: string;\n  coordinates: { x: number; y: number };\n}> {\n  if (!isArray(dataPoints) || dataPoints.length === 0) {\n    return [];\n  }\n  \n  return dataPoints.map(point => {\n    // Safely extract properties\n    const properties = safelyExtractObject(point, 'properties', {});\n    const resourceType = safelyExtractString(properties, 'resourceType', \n      safelyExtractString(properties, 'type', 'unknown')\n    );\n    \n    const value = safelyExtractNumber(properties, valueMetric, \n      safelyExtractNumber(properties, 'amount', 1)\n    );\n    \n    const coordinates = safelyExtractObject(point, 'coordinates', { x: 0, y: 0 });\n    \n    return {\n      id: safelyExtractString(point, 'id', `point-${Math.random().toString(36).substr(2, 9)}`),\n      name: safelyExtractString(point, 'name', `Resource ${point.id || 'Unknown'}`),\n      x: safelyExtractNumber(coordinates, 'x', 0),\n      y: safelyExtractNumber(coordinates, 'y', 0),\n      value,\n      type: resourceType,\n      coordinates: {\n        x: safelyExtractNumber(coordinates, 'x', 0),\n        y: safelyExtractNumber(coordinates, 'y', 0),\n      },\n    };\n  });\n}\n\n/**\n * Transforms resource grid cells into heat map format\n * @param gridCells Array of grid cells\n * @param valueMetric Metric to use for cell value\n * @param selectedResourceType Type of resource to filter by (or 'all')\n */\nexport function transformToHeatMapFormat(\n  gridCells: ResourceGridCell[],\n  valueMetric: string = 'amount',\n  selectedResourceType: string = 'all'\n): Array<{\n  x: number;\n  y: number;\n  value: number;\n  resources: Array<{\n    type: ResourceType;\n    amount: number;\n    quality?: number;\n    accessibility?: number;\n    estimatedValue?: number;\n  }>;\n}> {\n  if (!isArray(gridCells) || gridCells.length === 0) {\n    return [];\n  }\n  \n  return gridCells.map(cell => {\n    let value = 0;\n    \n    if (selectedResourceType === 'all') {\n      value = safelyExtractNumber(cell, 'totalValue', 0);\n    } else {\n      const resources = safelyExtractArray(cell, 'resources', []);\n      const resourceData = resources.find(r => \n        safelyExtractString(r, 'type', '') === selectedResourceType\n      );\n      \n      if (resourceData) {\n        value = safelyExtractNumber(resourceData, valueMetric, \n          safelyExtractNumber(resourceData, 'amount', 0)\n        );\n      }\n    }\n    \n    return {\n      ...cell,\n      value,\n    };\n  });\n}\n\n//=============================================================================\n// Filtering utilities\n//=============================================================================\n\n/**\n * Type-safe conversion of filter values\n * @param value The value to convert\n * @param operator The filter operator determining the expected type\n */\nexport function convertFilterValue(\n  value: string,\n  operator: string\n): string | number | boolean | [number, number] {\n  // Numeric operators\n  if (['greaterThan', 'lessThan', 'equals', 'notEquals'].includes(operator)) {\n    // Try to convert to number first\n    const num = parseFloat(value);\n    if (!isNaN(num)) {\n      return num;\n    }\n    \n    // Handle boolean values\n    if (value === 'true' || value === 'false') {\n      return value === 'true';\n    }\n  }\n  \n  // Between operator (expects a range)\n  if (operator === 'between' && value.includes(',')) {\n    const [minStr, maxStr] = value.split(',');\n    const min = parseFloat(minStr.trim());\n    const max = parseFloat(maxStr.trim());\n    if (!isNaN(min) && !isNaN(max)) {\n      return [min, max];\n    }\n  }\n  \n  // Default to string\n  return value;\n}\n\n/**\n * Formats a filter value for display\n * @param value The filter value\n */\nexport function formatFilterValue(value: string | number | boolean | [number, number]): string {\n  if (Array.isArray(value)) {\n    return `${value[0]} to ${value[1]}`;\n  }\n  return String(value);\n}\n\n/**\n * Applies filters to a dataset\n * @param data Array of data objects\n * @param filters Array of filter objects\n */\nexport function applyFilters(\n  data: Array<Record<string, unknown>>,\n  filters: Array<{\n    field: string;\n    operator: string;\n    value: string | number | boolean | [number, number];\n  }>\n): Array<Record<string, unknown>> {\n  if (!filters || filters.length === 0) {\n    return data;\n  }\n  \n  return data.filter(item => {\n    // Apply all filters (AND logic)\n    return filters.every(filter => {\n      const { field, operator, value } = filter;\n      \n      // Extract the field value, supporting dot notation for nested properties\n      const fieldValue = safelyExtractPath(item, field, null);\n      \n      // Skip invalid values\n      if (fieldValue === null || fieldValue === undefined) {\n        return false;\n      }\n      \n      // Apply appropriate comparison based on operator\n      switch (operator) {\n        case 'equals':\n          return fieldValue === value;\n        \n        case 'notEquals':\n          return fieldValue !== value;\n        \n        case 'greaterThan':\n          return isNumber(fieldValue) && isNumber(value) && fieldValue > value;\n        \n        case 'lessThan':\n          return isNumber(fieldValue) && isNumber(value) && fieldValue < value;\n        \n        case 'contains':\n          return isString(fieldValue) && isString(value) && \n            fieldValue.toLowerCase().includes(value.toLowerCase());\n        \n        case 'notContains':\n          return isString(fieldValue) && isString(value) && \n            !fieldValue.toLowerCase().includes(value.toLowerCase());\n        \n        case 'between':\n          return isNumber(fieldValue) && Array.isArray(value) && \n            fieldValue >= value[0] && fieldValue <= value[1];\n        \n        default:\n          return true;\n      }\n    });\n  });\n}\n\n//=============================================================================\n// Pagination utilities\n//=============================================================================\n\n/**\n * Creates a paginated subset of data\n * @param data The full dataset\n * @param pageSize Number of items per page\n * @param currentPage Current page number (0-based)\n */\nexport function paginateData<T>(\n  data: T[],\n  pageSize: number,\n  currentPage: number\n): {\n  items: T[];\n  totalItems: number;\n  totalPages: number;\n  currentPage: number;\n  hasNextPage: boolean;\n  hasPreviousPage: boolean;\n} {\n  if (!Array.isArray(data)) {\n    return {\n      items: [],\n      totalItems: 0,\n      totalPages: 0,\n      currentPage: 0,\n      hasNextPage: false,\n      hasPreviousPage: false,\n    };\n  }\n  \n  const totalItems = data.length;\n  const totalPages = Math.max(1, Math.ceil(totalItems / pageSize));\n  const safePage = Math.max(0, Math.min(currentPage, totalPages - 1));\n  \n  const startIndex = safePage * pageSize;\n  const endIndex = Math.min(startIndex + pageSize, totalItems);\n  \n  return {\n    items: data.slice(startIndex, endIndex),\n    totalItems,\n    totalPages,\n    currentPage: safePage,\n    hasNextPage: safePage < totalPages - 1,\n    hasPreviousPage: safePage > 0,\n  };\n}",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/dataTransforms/filterTransforms.ts",
    "messages": [
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 228,
        "column": 5,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 228,
        "endColumn": 35,
        "suggestions": [
          {
            "messageId": "addBrackets",
            "fix": {
              "range": [5482, 5551],
              "text": "{ const num = parseFloat(value);\n      return isNaN(num) ? value : num; }"
            },
            "desc": "Add {} brackets around the case block."
          }
        ]
      },
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 234,
        "column": 7,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 234,
        "endColumn": 40,
        "suggestions": [
          {
            "messageId": "addBrackets",
            "fix": {
              "range": [5646, 5943],
              "text": "{ const numVal = parseFloat(value);\n      if (!isNaN(numVal) && numVal.toString() === value) {\n        return numVal;\n      }\n      // Try to convert to boolean\n      if (value === 'true') return true;\n      if (value === 'false') return false;\n      // Otherwise, keep as string\n      return value; }"
            },
            "desc": "Add {} brackets around the case block."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Filter Transformation Utilities\n * \n * This module provides utilities for filtering and transforming data\n * for use in filter panels, search components, and data tables.\n */\n\nimport { \n  isArray, \n  isNumber, \n  isObject, \n  isString, \n  safelyExtractPath \n} from './chartTransforms';\n\n//=============================================================================\n// Filter Types\n//=============================================================================\n\n/**\n * Supported filter operators\n */\nexport type FilterOperator =\n  | 'equals'\n  | 'notEquals'\n  | 'greaterThan'\n  | 'lessThan'\n  | 'contains'\n  | 'notContains'\n  | 'between'\n  | 'in'\n  | 'notIn'\n  | 'exists'\n  | 'notExists';\n\n/**\n * Filter definition\n */\nexport interface Filter {\n  field: string;\n  operator: FilterOperator;\n  value: string | number | boolean | string[] | [number, number];\n}\n\n/**\n * Filter Group (for complex filtering with AND/OR logic)\n */\nexport interface FilterGroup {\n  type: 'and' | 'or';\n  filters: Array<Filter | FilterGroup>;\n}\n\n//=============================================================================\n// Filter Creation and Validation\n//=============================================================================\n\n/**\n * Creates a filter with type checking and validation\n * @param field Field name to filter on\n * @param operator Filter operator\n * @param value Filter value\n */\nexport function createFilter(\n  field: string,\n  operator: FilterOperator,\n  value: unknown\n): Filter | null {\n  // Validate field\n  if (!field || typeof field !== 'string') {\n    return null;\n  }\n  \n  // Validate and convert value based on operator\n  let validatedValue: string | number | boolean | string[] | [number, number];\n  \n  switch (operator) {\n    case 'equals':\n    case 'notEquals':\n      // Accept string, number, or boolean\n      if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n        validatedValue = value;\n      } else {\n        return null;\n      }\n      break;\n      \n    case 'greaterThan':\n    case 'lessThan':\n      // Only accept numbers\n      if (typeof value === 'number') {\n        validatedValue = value;\n      } else if (typeof value === 'string') {\n        const num = parseFloat(value);\n        if (isNaN(num)) {\n          return null;\n        }\n        validatedValue = num;\n      } else {\n        return null;\n      }\n      break;\n      \n    case 'contains':\n    case 'notContains':\n      // Only accept strings\n      if (typeof value === 'string') {\n        validatedValue = value;\n      } else {\n        return null;\n      }\n      break;\n      \n    case 'between':\n      // Accept numeric range\n      if (Array.isArray(value) && value.length === 2 &&\n          typeof value[0] === 'number' && typeof value[1] === 'number') {\n        validatedValue = value as [number, number];\n      } else if (typeof value === 'string' && value.includes(',')) {\n        // Try to parse as \"min,max\" string\n        const [minStr, maxStr] = value.split(',');\n        const min = parseFloat(minStr.trim());\n        const max = parseFloat(maxStr.trim());\n        if (isNaN(min) || isNaN(max)) {\n          return null;\n        }\n        validatedValue = [min, max];\n      } else {\n        return null;\n      }\n      break;\n      \n    case 'in':\n    case 'notIn':\n      // Accept array or convert comma-separated string\n      if (Array.isArray(value)) {\n        validatedValue = value.map(v => String(v));\n      } else if (typeof value === 'string') {\n        validatedValue = value.split(',').map(v => v.trim());\n      } else {\n        return null;\n      }\n      break;\n      \n    case 'exists':\n    case 'notExists':\n      // These operators don't use values\n      validatedValue = true;\n      break;\n      \n    default:\n      return null;\n  }\n  \n  return {\n    field,\n    operator,\n    value: validatedValue,\n  };\n}\n\n/**\n * Validates a filter object\n * @param filter Filter to validate\n */\nexport function validateFilter(filter: unknown): filter is Filter {\n  if (!isObject(filter)) {\n    return false;\n  }\n  \n  const { field, operator, value } = filter as Record<string, unknown>;\n  \n  if (!isString(field) || !isString(operator)) {\n    return false;\n  }\n  \n  const validOperators: string[] = [\n    'equals', 'notEquals', 'greaterThan', 'lessThan',\n    'contains', 'notContains', 'between', 'in', 'notIn',\n    'exists', 'notExists',\n  ];\n  \n  if (!validOperators.includes(operator)) {\n    return false;\n  }\n  \n  // Check if value is valid based on operator\n  switch (operator) {\n    case 'equals':\n    case 'notEquals':\n      return value !== undefined;\n      \n    case 'greaterThan':\n    case 'lessThan':\n      return isNumber(value);\n      \n    case 'contains':\n    case 'notContains':\n      return isString(value);\n      \n    case 'between':\n      return Array.isArray(value) && value.length === 2 &&\n             isNumber(value[0]) && isNumber(value[1]);\n      \n    case 'in':\n    case 'notIn':\n      return Array.isArray(value) && value.every(isString);\n      \n    case 'exists':\n    case 'notExists':\n      return true; // value not needed\n      \n    default:\n      return false;\n  }\n}\n\n/**\n * Converts a filter value from string input based on operator\n * @param value String value from input\n * @param operator Filter operator\n */\nexport function convertFilterValue(\n  value: string,\n  operator: FilterOperator\n): string | number | boolean | string[] | [number, number] {\n  switch (operator) {\n    case 'greaterThan':\n    const num = parseFloat(value);\n      return isNaN(num) ? value : num;\n      \n    case 'equals':\n    case 'notEquals':\n      // Try to convert to number first\n      const numVal = parseFloat(value);\n      if (!isNaN(numVal) && numVal.toString() === value) {\n        return numVal;\n      }\n      // Try to convert to boolean\n      if (value === 'true') return true;\n      if (value === 'false') return false;\n      // Otherwise, keep as string\n      return value;\n      \n    case 'between':\n      if (value.includes(',')) {\n        const [minStr, maxStr] = value.split(',');\n        const min = parseFloat(minStr.trim());\n        const max = parseFloat(maxStr.trim());\n        if (!isNaN(min) && !isNaN(max)) {\n          return [min, max] as [number, number];\n        }\n      }\n      return value;\n      \n    case 'in':\n    case 'notIn':\n      return value.split(',').map(v => v.trim());\n      \n    default:\n      return value;\n  }\n}\n\n//=============================================================================\n// Filter Formatting\n//=============================================================================\n\n/**\n * Formats a filter value for display\n * @param value Filter value\n */\nexport function formatFilterValue(\n  value: string | number | boolean | string[] | [number, number]\n): string {\n  if (Array.isArray(value)) {\n    // Format range as \"min to max\"\n    if (value.length === 2 && isNumber(value[0]) && isNumber(value[1])) {\n      return `${value[0]} to ${value[1]}`;\n    }\n    // Format array as comma-separated list\n    return value.join(', ');\n  }\n  \n  return String(value);\n}\n\n/**\n * Formats a filter for display\n * @param filter Filter to format\n */\nexport function formatFilter(filter: Filter): string {\n  const operatorLabels: Record<FilterOperator, string> = {\n    equals: '=',\n    notEquals: '≠',\n    greaterThan: '>',\n    lessThan: '<',\n    contains: 'contains',\n    notContains: 'not contains',\n    between: 'between',\n    in: 'in',\n    notIn: 'not in',\n    exists: 'exists',\n    notExists: 'not exists',\n  };\n  \n  const operator = operatorLabels[filter.operator] || filter.operator;\n  \n  // Special case for exists/notExists which don't use values\n  if (filter.operator === 'exists' || filter.operator === 'notExists') {\n    return `${filter.field} ${operator}`;\n  }\n  \n  return `${filter.field} ${operator} ${formatFilterValue(filter.value)}`;\n}\n\n/**\n * Gets appropriate input type based on filter operator\n * @param operator Filter operator\n */\nexport function getInputTypeForOperator(operator: FilterOperator): 'text' | 'number' | 'range' | 'select' | 'none' {\n  switch (operator) {\n    case 'greaterThan':\n    case 'lessThan':\n      return 'number';\n      \n    case 'between':\n      return 'range';\n      \n    case 'in':\n    case 'notIn':\n      return 'select';\n      \n    case 'exists':\n    case 'notExists':\n      return 'none';\n      \n    default:\n      return 'text';\n  }\n}\n\n//=============================================================================\n// Filtering Logic\n//=============================================================================\n\n/**\n * Applies a filter to a single data item\n * @param item Data item to filter\n * @param filter Filter to apply\n */\nexport function applyFilter(\n  item: Record<string, unknown>,\n  filter: Filter\n): boolean {\n  const { field, operator, value } = filter;\n  \n  // Extract field value, supporting dot notation for nested properties\n  const fieldValue = safelyExtractPath(item, field, null);\n  \n  // Skip invalid values (except for exists/notExists operators)\n  if (fieldValue === null || fieldValue === undefined) {\n    return operator === 'notExists';\n  }\n  \n  // Apply appropriate comparison based on operator\n  switch (operator) {\n    case 'equals':\n      return fieldValue === value;\n    \n    case 'notEquals':\n      return fieldValue !== value;\n    \n    case 'greaterThan':\n      return isNumber(fieldValue) && isNumber(value) && fieldValue > value;\n    \n    case 'lessThan':\n      return isNumber(fieldValue) && isNumber(value) && fieldValue < value;\n    \n    case 'contains':\n      return isString(fieldValue) && isString(value) && \n        fieldValue.toLowerCase().includes(value.toLowerCase());\n    \n    case 'notContains':\n      return isString(fieldValue) && isString(value) && \n        !fieldValue.toLowerCase().includes(value.toLowerCase());\n    \n    case 'between':\n      return isNumber(fieldValue) && Array.isArray(value) && \n        fieldValue >= value[0] && fieldValue <= value[1];\n    \n    case 'in':\n      return isArray<string>(value) && \n        value.includes(String(fieldValue));\n    \n    case 'notIn':\n      return isArray<string>(value) && \n        !value.includes(String(fieldValue));\n    \n    case 'exists':\n      return true; // We already checked existence above\n    \n    case 'notExists':\n      return false; // We already checked non-existence above\n    \n    default:\n      return true;\n  }\n}\n\n/**\n * Applies a filter group to a data item\n * @param item Data item to filter\n * @param filterGroup Filter group to apply\n */\nexport function applyFilterGroup(\n  item: Record<string, unknown>,\n  filterGroup: FilterGroup\n): boolean {\n  const { type, filters } = filterGroup;\n  \n  if (filters.length === 0) {\n    return true;\n  }\n  \n  // Apply filters based on group type (AND/OR)\n  if (type === 'and') {\n    return filters.every(filter => {\n      if ('field' in filter) {\n        return applyFilter(item, filter);\n      } else {\n        return applyFilterGroup(item, filter);\n      }\n    });\n  } else {\n    return filters.some(filter => {\n      if ('field' in filter) {\n        return applyFilter(item, filter);\n      } else {\n        return applyFilterGroup(item, filter);\n      }\n    });\n  }\n}\n\n/**\n * Applies filters to a dataset\n * @param data Array of data objects\n * @param filters Array of filter objects\n */\nexport function applyFilters(\n  data: Array<Record<string, unknown>>,\n  filters: Array<Filter>\n): Array<Record<string, unknown>> {\n  if (!filters || filters.length === 0) {\n    return data;\n  }\n  \n  // Create an implicit AND filter group\n  const filterGroup: FilterGroup = {\n    type: 'and',\n    filters,\n  };\n  \n  return data.filter(item => applyFilterGroup(item, filterGroup));\n}\n\n/**\n * Applies complex filter with support for AND/OR logic\n * @param data Array of data objects\n * @param filterGroup Filter group to apply\n */\nexport function applyComplexFilter(\n  data: Array<Record<string, unknown>>,\n  filterGroup: FilterGroup\n): Array<Record<string, unknown>> {\n  if (!filterGroup || !filterGroup.filters || filterGroup.filters.length === 0) {\n    return data;\n  }\n  \n  return data.filter(item => applyFilterGroup(item, filterGroup));\n}\n\n//=============================================================================\n// Field Analysis\n//=============================================================================\n\n/**\n * Detects field types from a dataset\n * @param data Array of data objects\n * @param sampleSize Number of items to sample (for performance with large datasets)\n */\nexport function detectFieldTypes(\n  data: Array<Record<string, unknown>>,\n  sampleSize: number = 100\n): Record<string, 'string' | 'number' | 'boolean' | 'date' | 'array' | 'object' | 'mixed'> {\n  if (!data || data.length === 0) {\n    return {};\n  }\n  \n  // Sample the data for performance\n  const sampleData = data.length <= sampleSize \n    ? data \n    : data.slice(0, sampleSize);\n  \n  // Get all field names from first few records\n  const fieldNames = new Set<string>();\n  sampleData.slice(0, 10).forEach(item => {\n    Object.keys(item).forEach(key => fieldNames.add(key));\n  });\n  \n  // Detect types for each field\n  const fieldTypes: Record<string, 'string' | 'number' | 'boolean' | 'date' | 'array' | 'object' | 'mixed'> = {};\n  \n  fieldNames.forEach(field => {\n    const values = sampleData\n      .map(item => item[field])\n      .filter(val => val !== undefined && val !== null);\n    \n    // Skip empty fields\n    if (values.length === 0) {\n      fieldTypes[field] = 'mixed';\n      return;\n    }\n    \n    // Count occurrences of each type\n    const typeCounts: Record<string, number> = {\n      string: 0,\n      number: 0,\n      boolean: 0,\n      date: 0,\n      array: 0,\n      object: 0,\n    };\n    \n    values.forEach(value => {\n      if (typeof value === 'string') {\n        // Check if string is a date\n        if (!isNaN(Date.parse(value)) && /^[0-9]{4}-[0-9]{2}-[0-9]{2}/.test(value)) {\n          typeCounts.date++;\n        } else {\n          typeCounts.string++;\n        }\n      } else if (typeof value === 'number') {\n        typeCounts.number++;\n      } else if (typeof value === 'boolean') {\n        typeCounts.boolean++;\n      } else if (Array.isArray(value)) {\n        typeCounts.array++;\n      } else if (typeof value === 'object' && value !== null) {\n        typeCounts.object++;\n      }\n    });\n    \n    // Find dominant type (more than 80% of values)\n    const totalValues = Object.values(typeCounts).reduce((sum, count) => sum + count, 0);\n    const dominantType = Object.entries(typeCounts)\n      .filter(([_, count]) => count / totalValues > 0.8)\n      .map(([type]) => type)[0];\n    \n    fieldTypes[field] = (dominantType as 'string' | 'number' | 'boolean' | 'date' | 'array' | 'object') || 'mixed';\n  });\n  \n  return fieldTypes;\n}\n\n/**\n * Gets unique values for a field\n * @param data Array of data objects\n * @param field Field name\n * @param limit Maximum number of unique values to return\n */\nexport function getUniqueValues(\n  data: Array<Record<string, unknown>>,\n  field: string,\n  limit: number = 100\n): Array<string | number | boolean> {\n  if (!data || data.length === 0 || !field) {\n    return [];\n  }\n  \n  // Extract values and convert to strings for comparison\n  const valueSet = new Set<string>();\n  \n  for (const item of data) {\n    const value = safelyExtractPath(item, field, null);\n    if (value === null || value === undefined) {\n      continue;\n    }\n    \n    // Convert to string/number/boolean for storage\n    if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n      valueSet.add(String(value));\n    } else if (Array.isArray(value)) {\n      valueSet.add(`Array(${value.length})`);\n    } else if (typeof value === 'object' && value !== null) {\n      valueSet.add('Object');\n    }\n    \n    // Stop if we reach the limit\n    if (valueSet.size >= limit) {\n      break;\n    }\n  }\n  \n  // Convert back to original types when possible\n  return Array.from(valueSet).map(value => {\n    // Try parsing as number\n    const num = parseFloat(value);\n    if (!isNaN(num) && num.toString() === value) {\n      return num;\n    }\n    \n    // Handle booleans\n    if (value === 'true') return true;\n    if (value === 'false') return false;\n    \n    // Keep as string\n    return value;\n  });\n}\n\n/**\n * Gets the range (min/max) for a numeric field\n * @param data Array of data objects\n * @param field Field name\n */\nexport function getFieldRange(\n  data: Array<Record<string, unknown>>,\n  field: string\n): [number, number] | null {\n  if (!data || data.length === 0 || !field) {\n    return null;\n  }\n  \n  // Extract numeric values\n  const numericValues: number[] = [];\n  \n  for (const item of data) {\n    const value = safelyExtractPath(item, field, null);\n    if (isNumber(value)) {\n      numericValues.push(value);\n    }\n  }\n  \n  // Return null if no numeric values found\n  if (numericValues.length === 0) {\n    return null;\n  }\n  \n  // Calculate min and max\n  const min = Math.min(...numericValues);\n  const max = Math.max(...numericValues);\n  \n  return [min, max];\n}",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/dataTransforms/index.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'ResourceType' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 27,
        "column": 10,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 27,
        "endColumn": 22
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Data Transformation Utilities\n * \n * This module exports consolidated utilities for transforming data\n * for visualization components, filtering, and scientific analysis.\n * \n * Each utility is organized by purpose to make it easier to find\n * and use the appropriate transformation functions.\n */\n\n// Export all chart transformation utilities\nexport * from './chartTransforms';\n\n// Export all scientific transformation utilities\nexport * from './scientificTransforms';\n\n// Export all filter transformation utilities\nexport * from './filterTransforms';\n\n// Re-export specific utilities with more descriptive names to improve discoverability\n\n// Domain calculation\nimport { calculateDomain, calculateDomains } from './chartTransforms';\nexport { calculateDomain, calculateDomains };\n\n// Color utilities\nimport { ResourceType } from \"./../../types/resources/ResourceTypes\";\nexport { createColorScale, getResourceTypeColor, hexToRgb };\n\n// Safe data extraction \nimport { \n  safelyExtractNumber, \n  safelyExtractString, \n  safelyExtractArray, \n  safelyExtractObject, \n  safelyExtractPath \n} from './chartTransforms';\nexport {\n  safelyExtractNumber, \n  safelyExtractString, \n  safelyExtractArray, \n  safelyExtractObject, \n  safelyExtractPath\n};\n\n// Type guards\nimport { isNumber, isString, isArray, isObject } from './chartTransforms';\nexport { isNumber, isString, isArray, isObject };\n\n// Data transformations for specific visualization types\nimport { \n  transformClusterData, \n  transformPredictionData, \n  transformResourceMappingData,\n  transformToScatterFormat,\n  transformToHeatMapFormat\n} from './chartTransforms';\nexport {\n  transformClusterData, \n  transformPredictionData, \n  transformResourceMappingData,\n  transformToScatterFormat,\n  transformToHeatMapFormat\n};\n\n// Pagination\nimport { paginateData } from './chartTransforms';\nexport { paginateData };\n\n// Scientific transformations\nimport { \n  transformTimeSeriesData, \n  calculateResiduals,\n  calculateCorrelationMatrix,\n  calculateStatistics,\n  extractFeatureImportance,\n  isLinearRegressionModel,\n  isNeuralNetworkModel,\n  calculateClusterCentroids,\n  calculateDistancesToCentroids\n} from './scientificTransforms';\nexport {\n  transformTimeSeriesData, \n  calculateResiduals,\n  calculateCorrelationMatrix,\n  calculateStatistics,\n  extractFeatureImportance,\n  isLinearRegressionModel,\n  isNeuralNetworkModel,\n  calculateClusterCentroids,\n  calculateDistancesToCentroids\n};\n\n// Filter transformations \nimport {\n  createFilter,\n  validateFilter,\n  convertFilterValue,\n  formatFilterValue,\n  formatFilter,\n  getInputTypeForOperator,\n  applyFilter,\n  applyFilters, \n  applyComplexFilter,\n  detectFieldTypes,\n  getUniqueValues,\n  getFieldRange\n} from './filterTransforms';\nexport {\n  createFilter,\n  validateFilter,\n  convertFilterValue,\n  formatFilterValue,\n  formatFilter,\n  getInputTypeForOperator,\n  applyFilter,\n  applyFilters, \n  applyComplexFilter,\n  detectFieldTypes,\n  getUniqueValues,\n  getFieldRange\n};",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/dataTransforms/scientificTransforms.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'e' is defined but never used. Allowed unused caught errors must match /^_/u.",
        "line": 115,
        "column": 14,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 115,
        "endColumn": 15
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Scientific Data Transformation Utilities\n * \n * This module provides specialized utilities for scientific data transformations\n * used in advanced analysis visualizations like prediction models, clustering, and\n * statistical analysis.\n */\n\nimport { safelyExtractArray, safelyExtractNumber, safelyExtractObject } from './chartTransforms';\n\n//=============================================================================\n// Time Series Transformations\n//=============================================================================\n\n/**\n * Transforms time series data for visualization\n * @param timePoints Array of time points\n * @param actualValues Array of actual values\n * @param predictedValues Array of predicted values (optional)\n * @param forecastValues Array of forecast values (optional)\n */\nexport function transformTimeSeriesData(\n  timePoints: number[] | string[],\n  actualValues: number[],\n  predictedValues?: number[],\n  forecastValues?: number[]\n): Array<{\n  time: number | string;\n  actual?: number;\n  predicted?: number;\n  forecast?: number;\n}> {\n  // Create time series data points\n  const timeSeriesData: Array<{\n    time: number | string;\n    actual?: number;\n    predicted?: number;\n    forecast?: number;\n  }> = [];\n  \n  // Add actual and predicted values\n  const maxActualLength = Math.min(timePoints.length, actualValues.length);\n  for (let i = 0; i < maxActualLength; i++) {\n    const point: {\n      time: number | string;\n      actual?: number;\n      predicted?: number;\n    } = {\n      time: timePoints[i],\n      actual: actualValues[i],\n    };\n    \n    if (predictedValues && i < predictedValues.length) {\n      point.predicted = predictedValues[i];\n    }\n    \n    timeSeriesData.push(point);\n  }\n  \n  // Add forecast values\n  if (forecastValues && forecastValues.length > 0) {\n    // Calculate the start index for forecast values\n    const forecastStartIndex = timeSeriesData.length;\n    const forecastTimes = timePoints.slice(forecastStartIndex);\n    \n    // Add available forecast times, or generate them if needed\n    for (let i = 0; i < forecastValues.length; i++) {\n      const time = i < forecastTimes.length \n        ? forecastTimes[i] \n        : generateNextTimePoint(timePoints, forecastStartIndex + i);\n      \n      timeSeriesData.push({\n        time,\n        forecast: forecastValues[i],\n      });\n    }\n  }\n  \n  return timeSeriesData;\n}\n\n/**\n * Generates a next time point for forecasting based on pattern detection\n * @param existingTimePoints Array of existing time points\n * @param index Index of the new time point\n */\nfunction generateNextTimePoint(\n  existingTimePoints: Array<number | string>,\n  index: number\n): number | string {\n  if (existingTimePoints.length < 2) {\n    return index; // Default to index if not enough points to detect pattern\n  }\n  \n  // Check if time points are numeric and follow a pattern\n  if (typeof existingTimePoints[0] === 'number' && typeof existingTimePoints[1] === 'number') {\n    const firstPoint = existingTimePoints[0] as number;\n    const lastPoint = existingTimePoints[existingTimePoints.length - 1] as number;\n    const interval = (lastPoint - firstPoint) / (existingTimePoints.length - 1);\n    return lastPoint + interval * (index - existingTimePoints.length + 1);\n  }\n  \n  // Handle date string pattern (assuming ISO format for simplicity)\n  if (typeof existingTimePoints[0] === 'string' && typeof existingTimePoints[1] === 'string') {\n    try {\n      const firstDate = new Date(existingTimePoints[0]);\n      const lastDate = new Date(existingTimePoints[existingTimePoints.length - 1]);\n      \n      // Calculate interval in milliseconds\n      const interval = (lastDate.getTime() - firstDate.getTime()) / (existingTimePoints.length - 1);\n      \n      // Calculate next date\n      const nextDate = new Date(lastDate.getTime() + interval * (index - existingTimePoints.length + 1));\n      return nextDate.toISOString().split('T')[0]; // Return as YYYY-MM-DD\n    } catch (e) {\n      // If date parsing fails, return string representation of index\n      return `Point ${index}`;\n    }\n  }\n  \n  // Default fallback\n  return `Point ${index}`;\n}\n\n/**\n * Calculates residuals (actual - predicted)\n * @param actualValues Array of actual values\n * @param predictedValues Array of predicted values\n */\nexport function calculateResiduals(\n  actualValues: number[],\n  predictedValues: number[]\n): number[] {\n  // Calculate residuals (actual - predicted)\n  const residuals: number[] = [];\n  const minLength = Math.min(actualValues.length, predictedValues.length);\n  \n  for (let i = 0; i < minLength; i++) {\n    residuals.push(actualValues[i] - predictedValues[i]);\n  }\n  \n  return residuals;\n}\n\n//=============================================================================\n// Statistical Transformations\n//=============================================================================\n\n/**\n * Calculates correlation coefficients between variables\n * @param data Array of data objects\n * @param variables Array of variable names to correlate\n */\nexport function calculateCorrelationMatrix(\n  data: Array<Record<string, unknown>>,\n  variables: string[]\n): Array<Array<number>> {\n  if (!data || data.length === 0 || !variables || variables.length === 0) {\n    return [];\n  }\n  \n  // Extract numeric values for each variable\n  const extractedData: Record<string, number[]> = {};\n  \n  // Initialize arrays for each variable\n  variables.forEach(variable => {\n    extractedData[variable] = [];\n  });\n  \n  // Extract values from data\n  data.forEach(item => {\n    variables.forEach(variable => {\n      const value = safelyExtractNumber(item, variable, NaN);\n      if (!isNaN(value)) {\n        extractedData[variable].push(value);\n      }\n    });\n  });\n  \n  // Create correlation matrix\n  const correlationMatrix: number[][] = [];\n  \n  // Calculate correlation for each pair of variables\n  for (let i = 0; i < variables.length; i++) {\n    correlationMatrix[i] = [];\n    for (let j = 0; j < variables.length; j++) {\n      // Diagonal values are always 1 (self-correlation)\n      if (i === j) {\n        correlationMatrix[i][j] = 1;\n        continue;\n      }\n      \n      // Get values for variables\n      const variable1Values = extractedData[variables[i]];\n      const variable2Values = extractedData[variables[j]];\n      \n      // Calculate correlation\n      const correlation = calculatePearsonCorrelation(variable1Values, variable2Values);\n      correlationMatrix[i][j] = correlation;\n    }\n  }\n  \n  return correlationMatrix;\n}\n\n/**\n * Calculates Pearson correlation coefficient between two variables\n * @param values1 Array of values for first variable\n * @param values2 Array of values for second variable\n */\nfunction calculatePearsonCorrelation(values1: number[], values2: number[]): number {\n  // Calculate valid data points (where both values exist)\n  const validPairs: Array<[number, number]> = [];\n  \n  const minLength = Math.min(values1.length, values2.length);\n  for (let i = 0; i < minLength; i++) {\n    if (!isNaN(values1[i]) && !isNaN(values2[i])) {\n      validPairs.push([values1[i], values2[i]]);\n    }\n  }\n  \n  // Handle insufficient data\n  if (validPairs.length < 2) {\n    return NaN;\n  }\n  \n  // Calculate means\n  let sum1 = 0;\n  let sum2 = 0;\n  for (const [val1, val2] of validPairs) {\n    sum1 += val1;\n    sum2 += val2;\n  }\n  const mean1 = sum1 / validPairs.length;\n  const mean2 = sum2 / validPairs.length;\n  \n  // Calculate correlation coefficient\n  let numerator = 0;\n  let denominator1 = 0;\n  let denominator2 = 0;\n  \n  for (const [val1, val2] of validPairs) {\n    const diff1 = val1 - mean1;\n    const diff2 = val2 - mean2;\n    numerator += diff1 * diff2;\n    denominator1 += diff1 * diff1;\n    denominator2 += diff2 * diff2;\n  }\n  \n  // Avoid division by zero\n  if (denominator1 === 0 || denominator2 === 0) {\n    return 0;\n  }\n  \n  return numerator / Math.sqrt(denominator1 * denominator2);\n}\n\n/**\n * Calculates descriptive statistics for a variable\n * @param data Array of data objects\n * @param variable Variable name to analyze\n */\nexport function calculateStatistics(\n  data: Array<Record<string, unknown>>,\n  variable: string\n): {\n  min: number;\n  max: number;\n  mean: number;\n  median: number;\n  standardDeviation: number;\n  count: number;\n  missing: number;\n} {\n  if (!data || data.length === 0) {\n    return {\n      min: NaN,\n      max: NaN,\n      mean: NaN,\n      median: NaN,\n      standardDeviation: NaN,\n      count: 0,\n      missing: 0,\n    };\n  }\n  \n  // Extract values and filter out invalid ones\n  const values: number[] = [];\n  let missing = 0;\n  \n  data.forEach(item => {\n    const value = safelyExtractNumber(item, variable, NaN);\n    if (!isNaN(value)) {\n      values.push(value);\n    } else {\n      missing++;\n    }\n  });\n  \n  // Handle no valid values\n  if (values.length === 0) {\n    return {\n      min: NaN,\n      max: NaN,\n      mean: NaN,\n      median: NaN,\n      standardDeviation: NaN,\n      count: 0,\n      missing,\n    };\n  }\n  \n  // Sort values for min, max, and median calculations\n  values.sort((a, b) => a - b);\n  \n  const min = values[0];\n  const max = values[values.length - 1];\n  \n  // Calculate mean\n  const sum = values.reduce((acc, val) => acc + val, 0);\n  const mean = sum / values.length;\n  \n  // Calculate median\n  let median: number;\n  const middle = Math.floor(values.length / 2);\n  if (values.length % 2 === 0) {\n    median = (values[middle - 1] + values[middle]) / 2;\n  } else {\n    median = values[middle];\n  }\n  \n  // Calculate standard deviation\n  const squaredDiffs = values.map(val => Math.pow(val - mean, 2));\n  const variance = squaredDiffs.reduce((acc, val) => acc + val, 0) / values.length;\n  const standardDeviation = Math.sqrt(variance);\n  \n  return {\n    min,\n    max,\n    mean,\n    median,\n    standardDeviation,\n    count: values.length,\n    missing,\n  };\n}\n\n//=============================================================================\n// Feature Importance and Model Transformations\n//=============================================================================\n\n/**\n * Extracts feature importance from model details\n * @param modelDetails Model details object\n * @param features Array of feature names\n */\nexport function extractFeatureImportance(\n  modelDetails: Record<string, unknown>,\n  features: string[]\n): Array<{ feature: string; importance: number }> {\n  // Try to extract explicit feature importance\n  const explicitImportance = safelyExtractArray<{ feature: string; importance: number }>(\n    modelDetails,\n    'featureImportance',\n    []\n  );\n  \n  if (explicitImportance.length > 0) {\n    return explicitImportance;\n  }\n  \n  // Try to extract coefficients for linear models\n  const coefficients = safelyExtractArray<number>(modelDetails, 'coefficients', []);\n  \n  if (coefficients.length > 0 && features.length > 0) {\n    // Create feature importance from coefficients\n    // Use absolute values as importance measure\n    return features.map((feature, index) => {\n      const coefficient = index < coefficients.length ? Math.abs(coefficients[index]) : 0;\n      return {\n        feature,\n        importance: coefficient,\n      };\n    }).sort((a, b) => b.importance - a.importance);\n  }\n  \n  // Try to extract weights for other models\n  const weights = safelyExtractArray<number>(modelDetails, 'weights', []);\n  \n  if (weights.length > 0 && features.length > 0) {\n    // Create feature importance from weights\n    return features.map((feature, index) => {\n      const weight = index < weights.length ? Math.abs(weights[index]) : 0;\n      return {\n        feature,\n        importance: weight,\n      };\n    }).sort((a, b) => b.importance - a.importance);\n  }\n  \n  // Return empty array if no importance data found\n  return [];\n}\n\n/**\n * Type guard to check if model details are from a linear regression model\n * @param modelDetails Model details object\n */\nexport function isLinearRegressionModel(\n  modelDetails: Record<string, unknown>\n): boolean {\n  // Check for coefficients which are typical for linear models\n  const coefficients = safelyExtractArray(modelDetails, 'coefficients', undefined);\n  return Array.isArray(coefficients) && coefficients.length > 0;\n}\n\n/**\n * Type guard to check if model details are from a neural network model\n * @param modelDetails Model details object\n */\nexport function isNeuralNetworkModel(\n  modelDetails: Record<string, unknown>\n): boolean {\n  // Check for architecture which is typical for neural networks\n  const architecture = safelyExtractObject(modelDetails, 'architecture', undefined);\n  return !!architecture && typeof architecture === 'object';\n}\n\n//=============================================================================\n// Clustering Transformations\n//=============================================================================\n\n/**\n * Calculates cluster centroids from cluster points\n * @param clusterPoints Array of cluster points\n * @param features Array of feature names\n */\nexport function calculateClusterCentroids(\n  clusterPoints: Array<{\n    cluster: number;\n    features: Array<number | null>;\n  }>,\n  features: string[]\n): Array<{\n  cluster: number;\n  centroid: number[];\n  size: number;\n}> {\n  if (!clusterPoints || clusterPoints.length === 0 || !features || features.length === 0) {\n    return [];\n  }\n  \n  // Group points by cluster\n  const clusters: Record<number, Array<Array<number | null>>> = {};\n  \n  clusterPoints.forEach(point => {\n    const { cluster, features: pointFeatures } = point;\n    \n    if (!clusters[cluster]) {\n      clusters[cluster] = [];\n    }\n    \n    clusters[cluster].push(pointFeatures);\n  });\n  \n  // Calculate centroids\n  const centroids: Array<{\n    cluster: number;\n    centroid: number[];\n    size: number;\n  }> = [];\n  \n  for (const [clusterStr, points] of Object.entries(clusters)) {\n    const cluster = parseInt(clusterStr, 10);\n    const numFeatures = features.length;\n    const validCounts: number[] = Array(numFeatures).fill(0);\n    const sums: number[] = Array(numFeatures).fill(0);\n    \n    // Sum values by feature\n    points.forEach(pointFeatures => {\n      pointFeatures.forEach((value, i) => {\n        if (value !== null && !isNaN(value)) {\n          sums[i] += value;\n          validCounts[i]++;\n        }\n      });\n    });\n    \n    // Calculate averages\n    const centroid = sums.map((sum, i) => \n      validCounts[i] > 0 ? sum / validCounts[i] : 0\n    );\n    \n    centroids.push({\n      cluster,\n      centroid,\n      size: points.length,\n    });\n  }\n  \n  return centroids;\n}\n\n/**\n * Calculates distances between points and their cluster centroids\n * @param clusterPoints Array of cluster points\n * @param centroids Array of cluster centroids\n */\nexport function calculateDistancesToCentroids(\n  clusterPoints: Array<{\n    cluster: number;\n    features: Array<number | null>;\n  }>,\n  centroids: Array<{\n    cluster: number;\n    centroid: number[];\n  }>\n): Array<{\n  pointIndex: number;\n  distance: number;\n}> {\n  if (!clusterPoints || clusterPoints.length === 0 || !centroids || centroids.length === 0) {\n    return [];\n  }\n  \n  // Map centroids by cluster for quick lookup\n  const centroidMap = new Map<number, number[]>();\n  centroids.forEach(({ cluster, centroid }) => {\n    centroidMap.set(cluster, centroid);\n  });\n  \n  // Calculate distances\n  return clusterPoints\n    .map((point, index) => {\n      const centroid = centroidMap.get(point.cluster);\n      \n      // Skip if centroid not found\n      if (!centroid) {\n        return {\n          pointIndex: index,\n          distance: Infinity,\n        };\n      }\n      \n      // Calculate Euclidean distance\n      let sum = 0;\n      let validDimensions = 0;\n      \n      point.features.forEach((value, i) => {\n        if (value !== null && !isNaN(value) && i < centroid.length) {\n          sum += Math.pow(value - centroid[i], 2);\n          validDimensions++;\n        }\n      });\n      \n      // Handle case where no valid dimensions exist\n      if (validDimensions === 0) {\n        return {\n          pointIndex: index,\n          distance: Infinity,\n        };\n      }\n      \n      // Normalize by dimensionality for fair comparison\n      const distance = Math.sqrt(sum) / Math.sqrt(validDimensions);\n      \n      return {\n        pointIndex: index,\n        distance,\n      };\n    })\n    .filter(item => isFinite(item.distance))\n    .sort((a, b) => b.distance - a.distance); // Sort descending (most distant first)\n}",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/events/EventBatcher.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/events/EventBatchingRxJS.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/events/EventCommunication.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/events/EventDataTypes.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/events/EventDevTools.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/events/EventDispatcher.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'ResourceType' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 1,
        "column": 10,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 1,
        "endColumn": 22
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { ResourceType } from \"./../../types/resources/ResourceTypes\";\nimport * as React from \"react\";\nimport { createContext, ReactNode, useContext, useEffect, useRef, useState } from 'react';\nimport { ModuleEvent, moduleEventBus, ModuleEventType } from '../../lib/modules/ModuleEvents';\n\n/**\n * Interface defining the context type for the EventDispatcher.\n * Provides methods for subscribing to events, emitting events, accessing event history,\n * filtering events, and accessing the latest events by type.\n *\n * @interface EventDispatcherContextType\n * @property {Function} subscribe - Function to subscribe to specific event types\n * @property {Function} emit - Function to emit events to the event bus\n * @property {Function} getHistory - Function to get the complete event history\n * @property {Function} getModuleHistory - Function to get events for a specific module\n * @property {Function} getEventTypeHistory - Function to get events of a specific type\n * @property {Function} clearHistory - Function to clear the event history\n * @property {Function} getFilteredEvents - Function to get events matching a filter function\n * @property {Map<ModuleEventType, ModuleEvent>} latestEvents - Map of the most recent event of each type\n */\ninterface EventDispatcherContextType {\n  // Event subscription\n  subscribe: (type: ModuleEventType, listener: (event: ModuleEvent) => void) => () => void;\n\n  // Event emission\n  emit: (event: ModuleEvent) => void;\n\n  // Event history\n  getHistory: () => ModuleEvent[];\n  getModuleHistory: (moduleId: string) => ModuleEvent[];\n  getEventTypeHistory: (type: ModuleEventType) => ModuleEvent[];\n  clearHistory: () => void;\n\n  // Event filtering\n  getFilteredEvents: (filter: (event: ModuleEvent) => boolean) => ModuleEvent[];\n\n  // Latest events by type\n  latestEvents: Map<ModuleEventType, ModuleEvent>;\n}\n\n/**\n * Props for the EventDispatcherProvider component.\n *\n * @interface EventDispatcherProviderProps\n * @property {ReactNode} children - Child components that will have access to the event context\n * @property {number} [__maxHistorySize=1000] - Maximum number of events to keep in history\n */\ninterface EventDispatcherProviderProps {\n  children: ReactNode;\n  /**\n   * Maximum number of events to keep in history\n   * Controls the maximum size of the event history to prevent excessive memory usage\n   */\n  __maxHistorySize?: number;\n}\n\n/**\n * React Context for the EventDispatcher.\n * Initially set to null and properly initialized in the EventDispatcherProvider.\n */\nconst EventDispatcherContext = createContext<EventDispatcherContextType | null>(null);\n\n/**\n * Provider component for the event dispatcher system.\n *\n * This component sets up a React context that provides access to the event system\n * throughout the component tree. It handles:\n * - Tracking the latest events by type\n * - Managing history size limits\n * - Subscribing to events from the underlying moduleEventBus\n * - Providing methods to interact with the event system\n *\n * All components that need to work with events should be descendants of this provider.\n *\n * @component\n * @example\n * // In your application's root component\n * import { EventDispatcherProvider } from '../utils/events/EventDispatcher';\n *\n * const App = () => {\n *   return (\n *     <EventDispatcherProvider>\n *       <YourComponents />\n *     </EventDispatcherProvider>\n *   );\n * };\n */\nexport const EventDispatcherProvider: React.FC<EventDispatcherProviderProps> = ({\n  children,\n  __maxHistorySize = 1000,\n}) => {\n  // Store the latest event of each type\n  const [latestEvents, setLatestEvents] = useState<Map<ModuleEventType, ModuleEvent>>(new Map());\n\n  // Reference to track the current max history size\n  const maxHistorySizeRef = useRef<number>(__maxHistorySize);\n\n  // Update the ref when the prop changes\n  useEffect(() => {\n    maxHistorySizeRef.current = __maxHistorySize;\n    console.warn(`[EventDispatcher] Setting max history size to ${__maxHistorySize}`);\n\n    // Update the moduleEventBus maxHistorySize if possible\n    // Note: This is a workaround since we can't directly access the private property\n    try {\n      // @ts-expect-error - Accessing private property for configuration\n      if (moduleEventBus.maxHistorySize !== undefined) {\n        // @ts-expect-error - Accessing private property for configuration\n        moduleEventBus.maxHistorySize = __maxHistorySize;\n        console.warn(\n          `[EventDispatcher] Updated moduleEventBus history size to ${__maxHistorySize}`\n        );\n      }\n    } catch (error) {\n      console.warn('[EventDispatcher] Could not update moduleEventBus history size:', error);\n    }\n  }, [__maxHistorySize]);\n\n  // Subscribe to all module events\n  useEffect(() => {\n    // Create a handler for all events\n    const handleEvent = (event: ModuleEvent) => {\n      setLatestEvents(prev => {\n        const newMap = new Map(prev);\n        newMap.set(event.type, event);\n        return newMap;\n      });\n    };\n\n    // Get all possible event types\n    const eventTypes: ModuleEventType[] = [\n      'MODULE_CREATED',\n      'MODULE_ATTACHED',\n      'MODULE_DETACHED',\n      'MODULE_UPGRADED',\n      'MODULE_ACTIVATED',\n      'MODULE_DEACTIVATED',\n      'ATTACHMENT_STARTED',\n      'ATTACHMENT_CANCELLED',\n      'ATTACHMENT_COMPLETED',\n      'ATTACHMENT_PREVIEW_SHOWN',\n      'RESOURCE_PRODUCED',\n      'RESOURCE_CONSUMED',\n      'RESOURCE_TRANSFERRED',\n      'RESOURCE_PRODUCTION_REGISTERED',\n      'RESOURCE_PRODUCTION_UNREGISTERED',\n      'RESOURCE_CONSUMPTION_REGISTERED',\n      'RESOURCE_CONSUMPTION_UNREGISTERED',\n      'RESOURCE_FLOW_REGISTERED',\n      'RESOURCE_FLOW_UNREGISTERED',\n      'RESOURCE_SHORTAGE',\n      'AUTOMATION_STARTED',\n      'AUTOMATION_STOPPED',\n      'AUTOMATION_CYCLE_COMPLETE',\n      'STATUS_CHANGED',\n      'ERROR_OCCURRED',\n      'MISSION_STARTED',\n      'MISSION_COMPLETED',\n      'MISSION_FAILED',\n      'MISSION_PROGRESS_UPDATED',\n      'MISSION_REWARD_CLAIMED',\n      'SUB_MODULE_CREATED',\n      'SUB_MODULE_ATTACHED',\n      'SUB_MODULE_DETACHED',\n      'SUB_MODULE_UPGRADED',\n      'SUB_MODULE_ACTIVATED',\n      'SUB_MODULE_DEACTIVATED',\n      'SUB_MODULE_EFFECT_APPLIED',\n      'SUB_MODULE_EFFECT_REMOVED',\n    ];\n\n    // Subscribe to all event types\n    const unsubscribers = eventTypes.map(type => moduleEventBus.subscribe(type, handleEvent));\n\n    // Cleanup subscriptions\n    return () => {\n      unsubscribers.forEach(unsubscribe => {\n        if (typeof unsubscribe === 'function') {\n          unsubscribe();\n        }\n      });\n    };\n  }, []);\n\n  // Context value\n  const value: EventDispatcherContextType = {\n    // Event subscription - delegate to moduleEventBus\n    subscribe: (type, listener) => moduleEventBus.subscribe(type, listener),\n\n    // Event emission - delegate to moduleEventBus\n    emit: event => moduleEventBus.emit(event),\n\n    // Event history - delegate to moduleEventBus with size limit\n    getHistory: () => {\n      const history = moduleEventBus.getHistory();\n      // Apply our own size limit if the history is too large\n      return history.length > maxHistorySizeRef.current\n        ? history.slice(history.length - maxHistorySizeRef.current)\n        : history;\n    },\n    getModuleHistory: moduleId => {\n      const history = moduleEventBus.getModuleHistory(moduleId);\n      // Apply our own size limit if the history is too large\n      return history.length > maxHistorySizeRef.current\n        ? history.slice(history.length - maxHistorySizeRef.current)\n        : history;\n    },\n    getEventTypeHistory: type => {\n      const history = moduleEventBus.getEventTypeHistory(type);\n      // Apply our own size limit if the history is too large\n      return history.length > maxHistorySizeRef.current\n        ? history.slice(history.length - maxHistorySizeRef.current)\n        : history;\n    },\n    clearHistory: () => moduleEventBus.clearHistory(),\n\n    // Event filtering with size limit\n    getFilteredEvents: filter => {\n      const history = moduleEventBus.getHistory();\n      const filtered = history.filter(filter);\n      // Apply our own size limit if the filtered history is too large\n      return filtered.length > maxHistorySizeRef.current\n        ? filtered.slice(filtered.length - maxHistorySizeRef.current)\n        : filtered;\n    },\n\n    // Latest events by type\n    latestEvents,\n  };\n\n  return (\n    <EventDispatcherContext.Provider value={value}>{children}</EventDispatcherContext.Provider>\n  );\n};\n\n/**\n * Hook to access the event dispatcher context.\n *\n * Provides access to all event operations such as subscribing to events,\n * emitting events, accessing event history, and viewing the latest events.\n *\n * @returns {EventDispatcherContextType} The event dispatcher context\n * @throws {Error} If used outside of an EventDispatcherProvider\n *\n * @example\n * const MyComponent = () => {\n *   const { emit, getHistory } = useEventDispatcher();\n *\n *   const handleButtonClick = () => {\n *     emit({\n *       type: 'MODULE_ACTIVATED',\n *       moduleId: 'module-1',\n *       moduleType: 'production',\n *       timestamp: Date.now()\n *     });\n *   };\n *\n *   return (\n *     <div>\n *       <button onClick={handleButtonClick}>Activate Module</button>\n *       <div>Total Events: {getHistory().length}</div>\n *     </div>\n *   );\n * };\n */\nexport const useEventDispatcher = (): EventDispatcherContextType => {\n  const context = useContext(EventDispatcherContext);\n\n  if (!context) {\n    throw new Error('useEventDispatcher must be used within an EventDispatcherProvider');\n  }\n\n  return context;\n};\n\n/**\n * Hook to subscribe to a specific event type.\n *\n * This hook simplifies the process of subscribing to events by automatically\n * handling subscription and cleanup. The callback will be called whenever\n * an event of the specified type is emitted.\n *\n * @template T - The specific event type to subscribe to\n * @param {T} eventType - The event type to subscribe to\n * @param {Function} callback - Function to call when an event of this type occurs\n * @param {React.DependencyList} [deps=[]] - Additional dependencies for the effect\n *\n * @example\n * // Subscribe to MODULE_CREATED events\n * const ModuleTracker = () => {\n *   const [moduleCount, setModuleCount] = useState(0);\n *\n *   useEventSubscription('MODULE_CREATED', (event) => {\n *     setModuleCount(prev => prev + 1);\n *     console.warn(`New module created: ${event.moduleId}`);\n *   });\n *\n *   return <div>Total modules created: {moduleCount}</div>;\n * };\n */\nexport const useEventSubscription = <T extends ModuleEventType>(\n  eventType: T,\n  callback: (event: ModuleEvent) => void,\n  deps: React.DependencyList = []\n): void => {\n  const { subscribe } = useEventDispatcher();\n\n  useEffect(() => {\n    return subscribe(eventType, callback);\n  }, [eventType, callback, subscribe, ...deps]);\n};\n\n/**\n * Hook to get the latest event of a specific type.\n *\n * Retrieves the most recent event of the specified type that has been\n * emitted in the system. Returns undefined if no event of that type\n * has been emitted yet.\n *\n * @template T - The specific event type to query\n * @param {T} eventType - The event type to get the latest event for\n * @returns {ModuleEvent | undefined} The latest event of the specified type, or undefined if none exists\n *\n * @example\n * // Display information about the most recent error\n * const ErrorDisplay = () => {\n *   const latestError = useLatestEvent('ERROR_OCCURRED');\n *\n *   if (!latestError) {\n *     return <div>No errors reported</div>;\n *   }\n *\n *   return (\n *     <div className=\"error-panel\">\n *       <h3>Latest Error</h3>\n *       <p>Module: {latestError.moduleId}</p>\n *       <p>Time: {new Date(latestError.timestamp).toLocaleString()}</p>\n *       <p>Message: {latestError.data?.message || 'Unknown error'}</p>\n *     </div>\n *   );\n * };\n */\nexport const useLatestEvent = <T extends ModuleEventType>(\n  eventType: T\n): ModuleEvent | undefined => {\n  const { latestEvents } = useEventDispatcher();\n  return latestEvents.get(eventType);\n};\n\n/**\n * Hook to get events that match a filter function.\n *\n * Allows for complex event filtering beyond just module ID or event type.\n * Automatically updates when new events are emitted that match the filter.\n *\n * @param {Function} filter - Filter function that returns true for events to include\n * @param {React.DependencyList} [deps=[]] - Additional dependencies for the effect\n * @returns {ModuleEvent[]} Array of events that match the filter\n *\n * @example\n * // Display all resource shortage events from the last hour\n * const ResourceShortageMonitor = () => {\n *   const oneHourAgo = Date.now() - 3600000;\n *\n *   const recentShortages = useFilteredEvents(\n *     (event) => (\n *       event.type === 'RESOURCE_SHORTAGE' &&\n *       event.timestamp > oneHourAgo\n *     ),\n *     [oneHourAgo] // Update when oneHourAgo changes\n *   );\n *\n *   return (\n *     <div>\n *       <h3>Recent Resource Shortages: {recentShortages.length}</h3>\n *       <ul>\n *         {recentShortages.map(event => (\n *           <li key={event.timestamp}>\n *             {event.data?.resourceType}: {new Date(event.timestamp).toLocaleTimeString()}\n *           </li>\n *         ))}\n *       </ul>\n *     </div>\n *   );\n * };\n */\nexport const useFilteredEvents = (\n  filter: (event: ModuleEvent) => boolean,\n  deps: React.DependencyList = []\n): ModuleEvent[] => {\n  const { getFilteredEvents } = useEventDispatcher();\n  const [filteredEvents, setFilteredEvents] = useState<ModuleEvent[]>([]);\n\n  useEffect(() => {\n    setFilteredEvents(getFilteredEvents(filter));\n  }, [getFilteredEvents, filter, ...deps]);\n\n  return filteredEvents;\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/events/EventFilter.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/events/EventFiltering.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/events/EventPrioritizer.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/events/EventThrottling.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/events/eventTypeGuards.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/events/rxjsIntegration.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/geometry.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/idGenerator.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/modules/moduleValidation.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/performance/D3AccessorBenchmark.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'transform' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 209,
        "column": 15,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 209,
        "endColumn": 24
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'transform' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 227,
        "column": 15,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 227,
        "endColumn": 24
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'transform' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 262,
        "column": 15,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 262,
        "endColumn": 24
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'transform' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 277,
        "column": 15,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 277,
        "endColumn": 24
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'transform' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 298,
        "column": 15,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 298,
        "endColumn": 24
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'transform' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 313,
        "column": 15,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 313,
        "endColumn": 24
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 6,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * D3 Accessor Benchmark Utility\n *\n * This utility provides benchmarking tools to compare the performance of\n * type-safe accessors versus direct property access in D3 visualizations.\n */\n\nimport { d3Accessors, SimulationNodeDatum } from '../../types/visualizations/D3Types';\n\n/**\n * Test case configuration\n */\nexport interface BenchmarkTestCase {\n  /** Name of the test case */\n  name: string;\n  /** Description of what is being tested */\n  description: string;\n  /** Function to execute for the test */\n  testFn: () => void;\n  /** Number of iterations to run */\n  iterations?: number;\n}\n\n/**\n * Benchmark result\n */\nexport interface BenchmarkResult {\n  /** Name of the test case */\n  name: string;\n  /** Description of what was tested */\n  description: string;\n  /** Average execution time in milliseconds */\n  averageTimeMs: number;\n  /** Median execution time in milliseconds */\n  medianTimeMs: number;\n  /** Total execution time in milliseconds */\n  totalTimeMs: number;\n  /** Number of iterations run */\n  iterations: number;\n  /** Individual execution times */\n  executionTimes: number[];\n  /** Timestamp when the benchmark was run */\n  timestamp: Date;\n}\n\n/**\n * Benchmark comparison result\n */\nexport interface BenchmarkComparison {\n  /** Baseline test case name */\n  baseline: string;\n  /** Comparison test case name */\n  comparison: string;\n  /** Performance difference as a percentage (positive means slower, negative means faster) */\n  percentageDifference: number;\n  /** Absolute time difference in milliseconds */\n  absoluteDifferenceMs: number;\n  /** Whether the comparison is significantly different (>5% difference) */\n  isSignificant: boolean;\n}\n\n/**\n * Run a single benchmark test\n *\n * @param testCase The test case to run\n * @returns Benchmark result\n */\nexport function runBenchmark(testCase: BenchmarkTestCase): BenchmarkResult {\n  const iterations = testCase.iterations || 1000;\n  const executionTimes: number[] = [];\n\n  // Run test iterations\n  for (let i = 0; i < iterations; i++) {\n    const startTime = performance.now();\n    testCase.testFn();\n    const endTime = performance.now();\n    executionTimes.push(endTime - startTime);\n  }\n\n  // Calculate statistics\n  const totalTimeMs = executionTimes.reduce((sum, time) => sum + time, 0);\n  const averageTimeMs = totalTimeMs / iterations;\n\n  // Calculate median (sort first)\n  const sortedTimes = [...executionTimes].sort((a, b) => a - b);\n  const medianTimeMs =\n    iterations % 2 === 0\n      ? (sortedTimes[iterations / 2 - 1] + sortedTimes[iterations / 2]) / 2\n      : sortedTimes[Math.floor(iterations / 2)];\n\n  return {\n    name: testCase.name,\n    description: testCase.description,\n    averageTimeMs,\n    medianTimeMs,\n    totalTimeMs,\n    iterations,\n    executionTimes,\n    timestamp: new Date(),\n  };\n}\n\n/**\n * Compare two benchmark results\n *\n * @param baseline Baseline benchmark result\n * @param comparison Comparison benchmark result\n * @returns Benchmark comparison\n */\nexport function compareBenchmarks(\n  baseline: BenchmarkResult,\n  comparison: BenchmarkResult\n): BenchmarkComparison {\n  const absoluteDifferenceMs = comparison.averageTimeMs - baseline.averageTimeMs;\n  const percentageDifference = (absoluteDifferenceMs / baseline.averageTimeMs) * 100;\n\n  return {\n    baseline: baseline.name,\n    comparison: comparison.name,\n    percentageDifference,\n    absoluteDifferenceMs,\n    isSignificant: Math.abs(percentageDifference) > 5,\n  };\n}\n\n/**\n * Format benchmark results for display\n *\n * @param result Benchmark result\n * @returns Formatted string\n */\nexport function formatBenchmarkResult(result: BenchmarkResult): string {\n  return `\nBenchmark: ${result.name}\nDescription: ${result.description}\nIterations: ${result.iterations}\nAverage Time: ${result.averageTimeMs.toFixed(6)} ms\nMedian Time: ${result.medianTimeMs.toFixed(6)} ms\nTotal Time: ${result.totalTimeMs.toFixed(2)} ms\n  `.trim();\n}\n\n/**\n * Format benchmark comparison for display\n *\n * @param comparison Benchmark comparison\n * @returns Formatted string\n */\nexport function formatBenchmarkComparison(comparison: BenchmarkComparison): string {\n  const differenceDescription =\n    comparison.percentageDifference > 0\n      ? `${comparison.percentageDifference.toFixed(2)}% slower`\n      : `${Math.abs(comparison.percentageDifference).toFixed(2)}% faster`;\n\n  const significance = comparison.isSignificant\n    ? 'Significant difference'\n    : 'No significant difference';\n\n  return `\nComparison: ${comparison.comparison} vs ${comparison.baseline}\nDifference: ${differenceDescription} (${Math.abs(comparison.absoluteDifferenceMs).toFixed(6)} ms)\nAssessment: ${significance}\n  `.trim();\n}\n\n// Simulate typical D3 simulation data\nfunction generateTestNodes(count: number): SimulationNodeDatum[] {\n  const nodes: SimulationNodeDatum[] = [];\n\n  for (let i = 0; i < count; i++) {\n    nodes.push({\n      id: `node-${i}`,\n      x: Math.random() * 100,\n      y: Math.random() * 100,\n      vx: Math.random() * 2 - 1,\n      vy: Math.random() * 2 - 1,\n    });\n  }\n\n  return nodes;\n}\n\n/**\n * Run a benchmark comparing type-safe accessors vs direct property access\n *\n * @param nodeCount Number of nodes to use in the test\n * @param iterations Number of iterations to run\n * @returns Benchmark comparison\n */\nexport function benchmarkAccessors(\n  nodeCount: number = 1000,\n  iterations: number = 10000\n): BenchmarkComparison {\n  const nodes = generateTestNodes(nodeCount);\n\n  // Test case for direct property access\n  const directAccessTest: BenchmarkTestCase = {\n    name: 'Direct Property Access',\n    description: `Access x/y coordinates directly on ${nodeCount} nodes`,\n    iterations,\n    testFn: () => {\n      // Simulate typical D3 simulation tick function with direct access\n      for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        // Direct property access\n        const x = node.x || 0;\n        const y = node.y || 0;\n        // Do something with coordinates (simulate transform application)\n        const transform = `translate(${x}, ${y})`;\n      }\n    },\n  };\n\n  // Test case for type-safe accessor functions\n  const safeAccessTest: BenchmarkTestCase = {\n    name: 'Type-Safe Accessor Functions',\n    description: `Access x/y coordinates via d3Accessors on ${nodeCount} nodes`,\n    iterations,\n    testFn: () => {\n      // Simulate typical D3 simulation tick function with safe accessors\n      for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        // Safe accessor functions\n        const x = d3Accessors.getX(node);\n        const y = d3Accessors.getY(node);\n        // Do something with coordinates (simulate transform application)\n        const transform = `translate(${x}, ${y})`;\n      }\n    },\n  };\n\n  // Run both benchmarks\n  const directResult = runBenchmark(directAccessTest);\n  const safeResult = runBenchmark(safeAccessTest);\n\n  // Compare results\n  return compareBenchmarks(directResult, safeResult);\n}\n\n/**\n * Run a comprehensive set of benchmarks for D3 simulations\n */\nexport function runComprehensiveBenchmarks(): {\n  results: BenchmarkResult[];\n  comparisons: BenchmarkComparison[];\n} {\n  const results: BenchmarkResult[] = [];\n  const comparisons: BenchmarkComparison[] = [];\n\n  // Test scenario 1: Basic coordinate access (small dataset)\n  const nodes100 = generateTestNodes(100);\n\n  // Direct access test (small)\n  const directSmall = runBenchmark({\n    name: 'Direct Access (100 nodes)',\n    description: 'Direct property access on 100 nodes',\n    iterations: 10000,\n    testFn: () => {\n      for (const node of nodes100) {\n        const x = node.x || 0;\n        const y = node.y || 0;\n        const transform = `translate(${x}, ${y})`;\n      }\n    },\n  });\n  results.push(directSmall);\n\n  // Safe access test (small)\n  const safeSmall = runBenchmark({\n    name: 'Safe Access (100 nodes)',\n    description: 'Type-safe accessor functions on 100 nodes',\n    iterations: 10000,\n    testFn: () => {\n      for (const node of nodes100) {\n        const x = d3Accessors.getX(node);\n        const y = d3Accessors.getY(node);\n        const transform = `translate(${x}, ${y})`;\n      }\n    },\n  });\n  results.push(safeSmall);\n\n  // Compare small dataset\n  comparisons.push(compareBenchmarks(directSmall, safeSmall));\n\n  // Test scenario 2: Basic coordinate access (large dataset)\n  const nodes10000 = generateTestNodes(10000);\n\n  // Direct access test (large)\n  const directLarge = runBenchmark({\n    name: 'Direct Access (10000 nodes)',\n    description: 'Direct property access on 10000 nodes',\n    iterations: 100,\n    testFn: () => {\n      for (const node of nodes10000) {\n        const x = node.x || 0;\n        const y = node.y || 0;\n        const transform = `translate(${x}, ${y})`;\n      }\n    },\n  });\n  results.push(directLarge);\n\n  // Safe access test (large)\n  const safeLarge = runBenchmark({\n    name: 'Safe Access (10000 nodes)',\n    description: 'Type-safe accessor functions on 10000 nodes',\n    iterations: 100,\n    testFn: () => {\n      for (const node of nodes10000) {\n        const x = d3Accessors.getX(node);\n        const y = d3Accessors.getY(node);\n        const transform = `translate(${x}, ${y})`;\n      }\n    },\n  });\n  results.push(safeLarge);\n\n  // Compare large dataset\n  comparisons.push(compareBenchmarks(directLarge, safeLarge));\n\n  // Test scenario 3: Simulation tick function (realistic scenario)\n  const simulationNodes = generateTestNodes(500);\n\n  // Direct access simulation test\n  const directSim = runBenchmark({\n    name: 'Direct Access Simulation',\n    description: 'Simulation tick function with direct property access',\n    iterations: 1000,\n    testFn: () => {\n      // Simulate a D3 force simulation tick\n      for (let i = 0; i < simulationNodes.length; i++) {\n        const d = simulationNodes[i];\n        // Direct property access with manual null checking\n        const x = d.x !== undefined ? d.x : 0;\n        const y = d.y !== undefined ? d.y : 0;\n\n        // Apply force simulation logic (simplified)\n        const vx = d.vx || 0;\n        const vy = d.vy || 0;\n        d.x = x + vx * 0.1;\n        d.y = y + vy * 0.1;\n\n        // Constrain to bounds\n        if (d.x! < 0) d.x = 0;\n        if (d.x! > 500) d.x = 500;\n        if (d.y! < 0) d.y = 0;\n        if (d.y! > 500) d.y = 500;\n      }\n    },\n  });\n  results.push(directSim);\n\n  // Safe access simulation test\n  const safeSim = runBenchmark({\n    name: 'Safe Access Simulation',\n    description: 'Simulation tick function with type-safe accessors',\n    iterations: 1000,\n    testFn: () => {\n      // Simulate a D3 force simulation tick\n      for (let i = 0; i < simulationNodes.length; i++) {\n        const d = simulationNodes[i];\n        // Safe accessor functions\n        const x = d3Accessors.getX(d);\n        const y = d3Accessors.getY(d);\n\n        // Apply force simulation logic (simplified)\n        const vx = d.vx || 0;\n        const vy = d.vy || 0;\n        d.x = x + vx * 0.1;\n        d.y = y + vy * 0.1;\n\n        // Constrain to bounds (type-safe version still needs non-null assertion for assignment)\n        if (d.x! < 0) d.x = 0;\n        if (d.x! > 500) d.x = 500;\n        if (d.y! < 0) d.y = 0;\n        if (d.y! > 500) d.y = 500;\n      }\n    },\n  });\n  results.push(safeSim);\n\n  // Compare simulation tests\n  comparisons.push(compareBenchmarks(directSim, safeSim));\n\n  return { results, comparisons };\n}\n\n/**\n * Generate a comprehensive benchmark report\n */\nexport function generateBenchmarkReport(): string {\n  const { results, comparisons } = runComprehensiveBenchmarks();\n\n  let report = `\n# D3 Accessor Performance Benchmark Report\nGenerated: ${new Date().toISOString()}\n\n## Summary\nThis report compares the performance of type-safe accessors versus direct property access\nin D3 visualizations across different scenarios and data sizes.\n\n## Results\n`;\n\n  // Add individual results\n  results.forEach(result => {\n    report += `\\n### ${result.name}\\n`;\n    report += formatBenchmarkResult(result) + '\\n';\n  });\n\n  // Add comparisons\n  report += `\\n## Comparisons\\n`;\n  comparisons.forEach(comparison => {\n    report += `\\n${formatBenchmarkComparison(comparison)}\\n`;\n  });\n\n  // Add recommendations\n  report += `\n## Recommendations\n`;\n\n  // Determine if type-safe accessors have a significant performance impact\n  const hasSignificantImpact = comparisons.some(\n    comp => comp.isSignificant && comp.percentageDifference > 0\n  );\n\n  if (hasSignificantImpact) {\n    report += `\n- Type-safe accessors show a measurable performance impact in some scenarios\n- Consider implementing optimizations such as memoization for performance-critical sections\n- Evaluate usage patterns to determine where direct access might be necessary\n`;\n  } else {\n    report += `\n- Type-safe accessors show minimal performance impact across tested scenarios\n- Continue using type-safe accessors for improved code safety and maintainability\n- No need for extensive optimization at this time\n`;\n  }\n\n  return report;\n}\n\n/**\n * Run all benchmarks and output results to console\n */\nexport function runAndLogBenchmarks(): void {\n  console.warn('Running D3 Accessor Benchmarks...');\n\n  const report = generateBenchmarkReport();\n  console.warn(report);\n\n  console.warn('Benchmark complete.');\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/performance/D3AnimationFrameManager.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'elapsedTime' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 213,
        "column": 11,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 213,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'updateAnimation' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 1124,
        "column": 10,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 1124,
        "endColumn": 25
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * D3 Animation Frame Manager\n *\n * This module provides a centralized system for efficiently coordinating multiple\n * animations. It optimizes performance by:\n *\n * 1. Batching animations in a single requestAnimationFrame loop\n * 2. Prioritizing animations based on visibility and importance\n * 3. Distributing animation work across frames for complex animations\n * 4. Providing synchronization mechanisms between related animations\n * 5. Managing frame budgets to ensure smooth performance\n */\n\nimport * as d3 from 'd3';\nimport {\n  AnimationConfig,\n  TypedAnimationSequence,\n} from '../../types/visualizations/D3AnimationTypes';\nimport { AnimationPerformanceReport, createAnimationProfiler } from './D3AnimationProfiler';\n\n/**\n * Priority level for animations\n */\nexport type AnimationPriority = 'critical' | 'high' | 'medium' | 'low' | 'background';\n\n/**\n * Status of a registered animation\n */\nexport type AnimationStatus = 'idle' | 'running' | 'paused' | 'completed' | 'error';\n\n/**\n * Visibility state of an animation to determine if it should be updated\n */\nexport type AnimationVisibility = 'visible' | 'partially-visible' | 'hidden';\n\n/**\n * Animation type to help optimize similar animations\n */\nexport type AnimationType = 'transition' | 'simulation' | 'timer' | 'sequence' | 'custom';\n\n/**\n * Configuration for registered animations\n */\nexport interface RegisteredAnimationConfig extends AnimationConfig {\n  /** Unique ID for the animation */\n  id: string;\n  /** User-friendly name for the animation */\n  name: string;\n  /** Priority level determines scheduling order */\n  priority: AnimationPriority;\n  /** Animation type for optimization opportunities */\n  type: AnimationType;\n  /** Whether the animation should continue even when off-screen */\n  runWhenHidden?: boolean;\n  /** Maximum amount of time per frame for this animation (ms) */\n  frameTimeBudget?: number;\n  /** Whether to enable profiling for this animation */\n  enableProfiling?: boolean;\n  /** Callback for animation completion */\n  onComplete?: () => void;\n  /** Synchronization group ID to coordinate related animations */\n  syncGroup?: string;\n}\n\n/**\n * The animation frame callback function signature\n */\nexport type AnimationFrameCallback = (\n  elapsed: number,\n  deltaTime: number,\n  frameInfo: FrameInfo\n) => boolean | void;\n\n/**\n * Information about the current animation frame\n */\nexport interface FrameInfo {\n  /** Frame timestamp */\n  timestamp: number;\n  /** Time elapsed since animation start */\n  elapsed: number;\n  /** Time since last frame */\n  deltaTime: number;\n  /** Current frame number */\n  frameCount: number;\n  /** Duration left in the frame budget (ms) */\n  remainingFrameBudget: number;\n  /** Whether the animation should try to finish critical work this frame */\n  isFrameOverBudget: boolean;\n  /** Current FPS based on recent frames */\n  currentFps: number;\n}\n\n/**\n * Registered animation object\n */\nexport interface RegisteredAnimation {\n  /** Animation configuration */\n  config: RegisteredAnimationConfig;\n  /** Frame callback function */\n  callback: AnimationFrameCallback;\n  /** Current animation status */\n  status: AnimationStatus;\n  /** Current visibility state */\n  visibility: AnimationVisibility;\n  /** Start time of the animation */\n  startTime: number;\n  /** Last frame timestamp */\n  lastFrameTime: number;\n  /** Elapsed time since start */\n  elapsedTime: number;\n  /** Elapsed time when paused (to resume from) */\n  pausedElapsedTime?: number;\n  /** Pause start timestamp */\n  pauseStartTime?: number;\n  /** Current frame number */\n  frameCount: number;\n  /** Animation-specific data storage */\n  data?: Record<string, unknown>;\n  /** Performance profiling data if enabled */\n  profilingData?: {\n    /** Animation profiler if enabled */\n    profiler: ReturnType<typeof createAnimationProfiler>;\n    /** Animation performance report if available */\n    report?: AnimationPerformanceReport;\n  };\n}\n\n/**\n * Configuration for the animation frame manager\n */\nexport interface AnimationFrameManagerConfig {\n  /** Target frames per second */\n  targetFps?: number;\n  /** Frame budget in milliseconds (defaults to 16ms for 60fps) */\n  frameBudget?: number;\n  /** Whether to enable auto-pausing of hidden animations */\n  autoPauseHidden?: boolean;\n  /** Maximum animations to process per frame */\n  maxAnimationsPerFrame?: number;\n  /** Whether to enable performance profiling */\n  enableProfiling?: boolean;\n  /** Whether to automatically cancel long-running animations */\n  autoCancelLongRunning?: boolean;\n  /** Time threshold for long-running animations in ms */\n  longRunningThreshold?: number;\n  /** Whether to log diagnostic information to console */\n  debugMode?: boolean;\n}\n\n/**\n * Creates a centralized animation frame manager for coordinating multiple animations\n *\n * @param config Configuration options for the manager\n * @returns Animation frame manager API\n */\nexport function createAnimationFrameManager(config: AnimationFrameManagerConfig = {}) {\n  // Configuration with defaults\n  const {\n    targetFps = 60,\n    frameBudget = (1000 / targetFps) * 0.8, // 80% of frame time\n    autoPauseHidden = true,\n    maxAnimationsPerFrame = 0, // 0 means no limit\n    enableProfiling = false,\n    autoCancelLongRunning = false,\n    longRunningThreshold = 30000, // 30 seconds\n    debugMode = false,\n  } = config;\n\n  // Internal state\n  const animations = new Map<string, RegisteredAnimation>();\n  const syncGroups = new Map<string, Set<string>>();\n  let isRunning = false;\n  let lastFrameTimestamp = 0;\n  let rafId: number | null = null;\n  let frameCount = 0;\n  let frameTimes: number[] = [];\n  let startTime = 0;\n\n  // FPS tracking (last 60 frames)\n  const fpsBufferSize = 60;\n  const fpsBuffer: number[] = Array(fpsBufferSize).fill(0);\n  let fpsBufferIndex = 0;\n  let currentFps = targetFps;\n\n  /**\n   * Update FPS calculation with the latest frame time\n   *\n   * @param deltaTime Time since last frame in ms\n   */\n  function updateFps(deltaTime: number) {\n    // Add latest frame time to buffer\n    fpsBuffer[fpsBufferIndex] = deltaTime > 0 ? 1000 / deltaTime : 0;\n    fpsBufferIndex = (fpsBufferIndex + 1) % fpsBufferSize;\n\n    // Calculate average FPS from buffer, ignoring zeros\n    const validFrames = fpsBuffer.filter(fps => fps > 0);\n    currentFps =\n      validFrames.length > 0\n        ? validFrames.reduce((sum, fps) => sum + fps, 0) / validFrames.length\n        : targetFps;\n  }\n\n  /**\n   * Main animation frame loop\n   *\n   * @param timestamp Current frame timestamp\n   */\n  function animationFrame(timestamp: number) {\n    // Calculate timing information\n    const deltaTime = lastFrameTimestamp ? timestamp - lastFrameTimestamp : 0;\n    lastFrameTimestamp = timestamp;\n    const elapsedTime = timestamp - startTime;\n\n    // Update FPS tracking\n    updateFps(deltaTime);\n    frameCount++;\n\n    // Update frame timing history (keep last 10 frames)\n    frameTimes.push(deltaTime);\n    if (frameTimes.length > 10) {\n      frameTimes.shift();\n    }\n\n    // Process animations in priority order\n    const frameStartTime = performance.now();\n    let frameTimeBudgetRemaining = frameBudget;\n    let animationsProcessed = 0;\n\n    // Sort animations by priority\n    const sortedAnimations = Array.from(animations.values())\n      .filter(anim => anim.status === 'running')\n      .sort((a, b) => {\n        // Order by priority first\n        const priorityOrder = {\n          critical: 0,\n          high: 1,\n          medium: 2,\n          low: 3,\n          background: 4,\n        };\n\n        const priorityDiff = priorityOrder[a.config.priority] - priorityOrder[b.config.priority];\n        if (priorityDiff !== 0) return priorityDiff;\n\n        // Then by visibility\n        const visibilityOrder = {\n          visible: 0,\n          'partially-visible': 1,\n          hidden: 2,\n        };\n\n        return visibilityOrder[a.visibility] - visibilityOrder[b.visibility];\n      });\n\n    // Process each animation\n    for (const animation of sortedAnimations) {\n      // Skip if we've reached the per-frame animation limit\n      if (maxAnimationsPerFrame > 0 && animationsProcessed >= maxAnimationsPerFrame) {\n        if (debugMode) {\n          console.warn(\n            `Animation frame manager: Reached max animations per frame (${maxAnimationsPerFrame})`\n          );\n        }\n        break;\n      }\n\n      // Skip hidden animations if configured to do so\n      if (autoPauseHidden && animation.visibility === 'hidden' && !animation.config.runWhenHidden) {\n        continue;\n      }\n\n      // Check if we have time remaining in the frame budget\n      const now = performance.now();\n      const timeElapsed = now - frameStartTime;\n      frameTimeBudgetRemaining = Math.max(0, frameBudget - timeElapsed);\n\n      // Skip if we're out of time\n      if (frameTimeBudgetRemaining <= 0) {\n        if (debugMode) {\n          console.warn(\n            `Animation frame manager: Frame budget exhausted, skipping remaining animations`\n          );\n        }\n        break;\n      }\n\n      // Prepare frame info\n      const _deltaTime = timestamp - animation.lastFrameTime;\n      const _frameInfo = {\n        timestamp,\n        elapsed: animation.elapsedTime,\n        deltaTime: _deltaTime,\n        frameCount: animation.frameCount,\n        remainingFrameBudget: frameTimeBudgetRemaining,\n        isFrameOverBudget:\n          frameTimeBudgetRemaining < (animation.config.frameTimeBudget || frameBudget * 0.2),\n        currentFps,\n      };\n\n      // Update animation timing info\n      animation.lastFrameTime = timestamp;\n      animation.elapsedTime = timestamp - animation.startTime;\n      animation.frameCount++;\n\n      // Record frame for profiling if enabled\n      if (animation.config.enableProfiling && animation.profilingData?.profiler) {\n        animation.profilingData.profiler.recordFrame();\n      }\n\n      try {\n        // Execute animation callback\n        const callbackStart = performance.now();\n        const result = animation.callback(animation.elapsedTime, _deltaTime, _frameInfo);\n        const _callbackDuration = performance.now() - callbackStart;\n\n        // Handle result (return true to stop the animation)\n        if (result === true) {\n          completeAnimation(animation.config.id);\n        }\n\n        // Auto-cancel long-running animations if enabled\n        if (\n          autoCancelLongRunning &&\n          animation.elapsedTime > longRunningThreshold &&\n          !animation.config.loop\n        ) {\n          if (debugMode) {\n            console.warn(\n              `Animation frame manager: Auto-cancelling long-running animation ${animation.config.id}`\n            );\n          }\n          completeAnimation(animation.config.id);\n        }\n      } catch (error) {\n        console.error(`Error in animation ${animation.config.id}:`, error);\n        animation.status = 'error';\n      }\n\n      animationsProcessed++;\n    }\n\n    // Continue the animation loop if we have active animations\n    if (animations.size > 0 && hasRunningAnimations()) {\n      rafId = requestAnimationFrame(animationFrame);\n    } else {\n      stopAnimationLoop();\n    }\n  }\n\n  /**\n   * Check if there are any running animations\n   */\n  function hasRunningAnimations(): boolean {\n    return Array.from(animations.values()).some(anim => anim.status === 'running');\n  }\n\n  /**\n   * Start the animation frame loop\n   */\n  function startAnimationLoop() {\n    if (isRunning) return;\n\n    isRunning = true;\n    startTime = performance.now();\n    lastFrameTimestamp = 0;\n    frameCount = 0;\n    frameTimes = [];\n\n    if (debugMode) {\n      console.warn('Animation frame manager: Starting animation loop');\n    }\n\n    rafId = requestAnimationFrame(animationFrame);\n  }\n\n  /**\n   * Stop the animation frame loop\n   */\n  function stopAnimationLoop() {\n    if (!isRunning) return;\n\n    isRunning = false;\n\n    if (rafId !== null) {\n      cancelAnimationFrame(rafId);\n      rafId = null;\n    }\n\n    if (debugMode) {\n      console.warn('Animation frame manager: Stopping animation loop');\n    }\n  }\n\n  /**\n   * Register a new animation with the frame manager\n   *\n   * @param config Animation configuration\n   * @param callback Animation frame callback function\n   * @returns Animation ID\n   */\n  function registerAnimation(\n    config: Omit<RegisteredAnimationConfig, 'id'> & { id?: string },\n    callback: AnimationFrameCallback\n  ): string {\n    // Generate ID if not provided\n    const id = config.id || `animation-${Date.now()}-${Math.floor(Math.random() * 10000)}`;\n\n    // Create full configuration with defaults\n    const fullConfig: RegisteredAnimationConfig = {\n      id,\n      name: config.name || `Animation ${id}`,\n      priority: config.priority || 'medium',\n      type: config.type || 'custom',\n      duration: config.duration || 1000,\n      easing: config.easing,\n      loop: config.loop || false,\n      runWhenHidden: config.runWhenHidden || false,\n      frameTimeBudget: config.frameTimeBudget || frameBudget * 0.5,\n      enableProfiling: config.enableProfiling || enableProfiling,\n      onComplete: config.onComplete,\n      syncGroup: config.syncGroup,\n    };\n\n    // Create animation entry\n    const animation: RegisteredAnimation = {\n      config: fullConfig,\n      callback,\n      status: 'idle',\n      visibility: 'visible',\n      startTime: 0,\n      lastFrameTime: 0,\n      elapsedTime: 0,\n      frameCount: 0,\n    };\n\n    // Set up profiling if enabled\n    if (fullConfig.enableProfiling) {\n      animation.profilingData = {\n        profiler: createAnimationProfiler({\n          targetFps,\n          detailedMetrics: true,\n        }),\n      };\n    }\n\n    // Add to sync group if specified\n    if (fullConfig.syncGroup) {\n      let group = syncGroups.get(fullConfig.syncGroup);\n      if (!group) {\n        group = new Set<string>();\n        syncGroups.set(fullConfig.syncGroup, group);\n      }\n      group.add(id);\n    }\n\n    // Store the animation\n    animations.set(id, animation);\n\n    if (debugMode) {\n      console.warn(`Animation frame manager: Registered animation ${id} (${fullConfig.name})`);\n    }\n\n    return id;\n  }\n\n  /**\n   * Start a registered animation\n   *\n   * @param id Animation ID\n   * @param resetTime Whether to reset the animation time\n   */\n  function startAnimation(id: string, resetTime = true): void {\n    const animation = animations.get(id);\n    if (!animation) {\n      if (debugMode) {\n        console.warn(`Animation frame manager: Cannot start animation ${id} - not found`);\n      }\n      return;\n    }\n\n    // Reset or resume timing\n    const now = performance.now();\n    if (resetTime) {\n      animation.startTime = now;\n      animation.lastFrameTime = now;\n      animation.elapsedTime = 0;\n      animation.frameCount = 0;\n    } else if (animation.status === 'paused' && animation.pausedElapsedTime !== undefined) {\n      // Resume from pause - adjust start time to maintain elapsed time\n      animation.startTime = now - animation.pausedElapsedTime;\n      animation.lastFrameTime = now;\n    }\n\n    animation.status = 'running';\n\n    // Reset pause tracking\n    animation.pausedElapsedTime = undefined;\n    animation.pauseStartTime = undefined;\n\n    // Start profiling if enabled\n    if (animation.config.enableProfiling && animation.profilingData?.profiler) {\n      animation.profilingData.profiler.start(\n        animation.config.id,\n        animation.config.name,\n        animation.config\n      );\n    }\n\n    if (debugMode) {\n      console.warn(`Animation frame manager: Started animation ${id} (${animation.config.name})`);\n    }\n\n    // Start the animation loop if needed\n    if (!isRunning) {\n      startAnimationLoop();\n    }\n  }\n\n  /**\n   * Pause a running animation\n   *\n   * @param id Animation ID\n   */\n  function pauseAnimation(id: string): void {\n    const animation = animations.get(id);\n    if (!animation || animation.status !== 'running') {\n      return;\n    }\n\n    animation.status = 'paused';\n    animation.pausedElapsedTime = animation.elapsedTime;\n    animation.pauseStartTime = performance.now();\n\n    if (debugMode) {\n      console.warn(`Animation frame manager: Paused animation ${id} (${animation.config.name})`);\n    }\n  }\n\n  /**\n   * Resume a paused animation\n   *\n   * @param id Animation ID\n   */\n  function resumeAnimation(id: string): void {\n    const animation = animations.get(id);\n    if (!animation || animation.status !== 'paused') {\n      return;\n    }\n\n    startAnimation(id, false);\n\n    if (debugMode) {\n      console.warn(`Animation frame manager: Resumed animation ${id} (${animation.config.name})`);\n    }\n  }\n\n  /**\n   * Stop and complete an animation\n   *\n   * @param id Animation ID\n   */\n  function completeAnimation(id: string): void {\n    const animation = animations.get(id);\n    if (!animation) {\n      return;\n    }\n\n    animation.status = 'completed';\n\n    // Generate final profiling report if enabled\n    if (animation.config.enableProfiling && animation.profilingData?.profiler) {\n      animation.profilingData.report = animation.profilingData.profiler.stop();\n    }\n\n    // Call completion handler if provided\n    if (animation.config.onComplete) {\n      try {\n        animation.config.onComplete();\n      } catch (error) {\n        console.error(`Error in animation completion handler for ${id}:`, error);\n      }\n    }\n\n    if (debugMode) {\n      console.warn(`Animation frame manager: Completed animation ${id} (${animation.config.name})`);\n    }\n  }\n\n  /**\n   * Cancel an animation without completing it\n   *\n   * @param id Animation ID\n   */\n  function cancelAnimation(id: string): void {\n    const animation = animations.get(id);\n    if (!animation) {\n      return;\n    }\n\n    // Stop profiling if active\n    if (\n      animation.config.enableProfiling &&\n      animation.profilingData?.profiler &&\n      animation.profilingData.profiler.getStatus().isRunning\n    ) {\n      animation.profilingData.report = animation.profilingData.profiler.stop();\n    }\n\n    animations.delete(id);\n\n    // Remove from sync group if needed\n    if (animation.config.syncGroup) {\n      const group = syncGroups.get(animation.config.syncGroup);\n      if (group) {\n        group.delete(id);\n        if (group.size === 0) {\n          syncGroups.delete(animation.config.syncGroup);\n        }\n      }\n    }\n\n    if (debugMode) {\n      console.warn(`Animation frame manager: Cancelled animation ${id} (${animation.config.name})`);\n    }\n  }\n\n  /**\n   * Update the visibility state of an animation\n   *\n   * @param id Animation ID\n   * @param visibility New visibility state\n   */\n  function updateVisibility(id: string, visibility: AnimationVisibility): void {\n    const animation = animations.get(id);\n    if (!animation) {\n      return;\n    }\n\n    const oldVisibility = animation.visibility;\n    animation.visibility = visibility;\n\n    // Auto-pause/resume based on visibility if enabled\n    if (autoPauseHidden && !animation.config.runWhenHidden) {\n      if (visibility === 'hidden' && animation.status === 'running') {\n        pauseAnimation(id);\n      } else if (\n        visibility !== 'hidden' &&\n        oldVisibility === 'hidden' &&\n        animation.status === 'paused'\n      ) {\n        resumeAnimation(id);\n      }\n    }\n\n    if (debugMode) {\n      console.warn(`Animation frame manager: Updated visibility for ${id} to ${visibility}`);\n    }\n  }\n\n  /**\n   * Update the priority of an animation\n   *\n   * @param id Animation ID\n   * @param priority New priority level\n   */\n  function updatePriority(id: string, priority: AnimationPriority): void {\n    const animation = animations.get(id);\n    if (!animation) {\n      return;\n    }\n\n    animation.config.priority = priority;\n\n    if (debugMode) {\n      console.warn(`Animation frame manager: Updated priority for ${id} to ${priority}`);\n    }\n  }\n\n  /**\n   * Synchronize multiple animations in the same group\n   *\n   * @param groupId Synchronization group ID\n   * @param action Action to perform on all animations in the group\n   */\n  function syncAnimations(\n    groupId: string,\n    action: 'start' | 'pause' | 'resume' | 'complete' | 'cancel'\n  ): void {\n    const group = syncGroups.get(groupId);\n    if (!group || group.size === 0) {\n      return;\n    }\n\n    for (const animationId of group) {\n      switch (action) {\n        case 'start':\n          startAnimation(animationId);\n          break;\n        case 'pause':\n          pauseAnimation(animationId);\n          break;\n        case 'resume':\n          resumeAnimation(animationId);\n          break;\n        case 'complete':\n          completeAnimation(animationId);\n          break;\n        case 'cancel':\n          cancelAnimation(animationId);\n          break;\n      }\n    }\n\n    if (debugMode) {\n      console.warn(`Animation frame manager: Synchronized group ${groupId} with action ${action}`);\n    }\n  }\n\n  /**\n   * Get performance metrics for an animation\n   *\n   * @param id Animation ID\n   * @returns Performance report if available\n   */\n  function getPerformanceReport(id: string): AnimationPerformanceReport | undefined {\n    const animation = animations.get(id);\n    if (!animation || !animation.profilingData) {\n      return undefined;\n    }\n\n    // If animation is still running, get current report\n    if (\n      animation.status === 'running' &&\n      animation.profilingData.profiler &&\n      animation.profilingData.profiler.getStatus().isRunning\n    ) {\n      return animation.profilingData.profiler.stop();\n    }\n\n    return animation.profilingData.report;\n  }\n\n  /**\n   * Get the current status of the animation frame manager\n   */\n  function getStatus() {\n    return {\n      isRunning,\n      animationCount: animations.size,\n      runningAnimations: Array.from(animations.values()).filter(a => a.status === 'running').length,\n      frameCount,\n      currentFps,\n      syncGroups: syncGroups.size,\n      averageFrameTime:\n        frameTimes.length > 0\n          ? frameTimes.reduce((sum, time) => sum + time, 0) / frameTimes.length\n          : 0,\n    };\n  }\n\n  /**\n   * Get all registered animations\n   */\n  function getAnimations() {\n    return Array.from(animations.entries()).map(([id, anim]) => ({\n      id,\n      name: anim.config.name,\n      status: anim.status,\n      priority: anim.config.priority,\n      visibility: anim.visibility,\n      type: anim.config.type,\n      elapsedTime: anim.elapsedTime,\n      frameCount: anim.frameCount,\n    }));\n  }\n\n  /**\n   * Check whether an animation is visible in the viewport\n   *\n   * @param element Element to check visibility for\n   * @returns Visibility state based on element position\n   */\n  function checkElementVisibility(element: Element): AnimationVisibility {\n    if (!element) {\n      return 'hidden';\n    }\n\n    // Use IntersectionObserver API if available\n    if ('IntersectionObserver' in window) {\n      // This is a simplified version - in practice, you would set up and maintain\n      // observers for elements. For now, we'll use getBoundingClientRect as a fallback.\n    }\n\n    // Fallback to getBoundingClientRect\n    const rect = element.getBoundingClientRect();\n    const windowHeight = window.innerHeight || document.documentElement.clientHeight;\n    const windowWidth = window.innerWidth || document.documentElement.clientWidth;\n\n    // Check if completely visible\n    if (\n      rect.top >= 0 &&\n      rect.left >= 0 &&\n      rect.bottom <= windowHeight &&\n      rect.right <= windowWidth\n    ) {\n      return 'visible';\n    }\n\n    // Check if partially visible\n    if (\n      rect.top <= windowHeight &&\n      rect.bottom >= 0 &&\n      rect.left <= windowWidth &&\n      rect.right >= 0\n    ) {\n      return 'partially-visible';\n    }\n\n    // Not visible at all\n    return 'hidden';\n  }\n\n  /**\n   * Create a utility that automatically updates animation visibility based on element visibility\n   *\n   * @param animationId Animation ID\n   * @param element Element to track\n   * @param options Configuration options\n   * @returns Cleanup function\n   */\n  function createVisibilityTracker(\n    animationId: string,\n    element: Element,\n    options: {\n      checkInterval?: number; // How often to check visibility (ms)\n      autoStartWhenVisible?: boolean; // Whether to auto-start the animation when visible\n      autoPauseWhenHidden?: boolean; // Whether to auto-pause when hidden\n    } = {}\n  ): () => void {\n    const {\n      checkInterval = 500,\n      autoStartWhenVisible = false,\n      autoPauseWhenHidden = true,\n    } = options;\n\n    // Initial visibility check\n    let currentVisibility = checkElementVisibility(element);\n    updateVisibility(animationId, currentVisibility);\n\n    // Set up interval to check visibility\n    const intervalId = setInterval(() => {\n      const newVisibility = checkElementVisibility(element);\n\n      // Only update if visibility changed\n      if (newVisibility !== currentVisibility) {\n        currentVisibility = newVisibility;\n        updateVisibility(animationId, newVisibility);\n\n        // Handle auto-start/pause if configured\n        const animation = animations.get(animationId);\n        if (!animation) return;\n\n        if (\n          autoStartWhenVisible &&\n          (newVisibility === 'visible' || newVisibility === 'partially-visible') &&\n          animation.status === 'idle'\n        ) {\n          startAnimation(animationId);\n        } else if (\n          autoPauseWhenHidden &&\n          newVisibility === 'hidden' &&\n          animation.status === 'running'\n        ) {\n          pauseAnimation(animationId);\n        } else if (\n          autoStartWhenVisible &&\n          (newVisibility === 'visible' || newVisibility === 'partially-visible') &&\n          animation.status === 'paused'\n        ) {\n          resumeAnimation(animationId);\n        }\n      }\n    }, checkInterval);\n\n    // Return cleanup function\n    return () => {\n      clearInterval(intervalId);\n    };\n  }\n\n  /**\n   * Create animation synchronization utility that keeps animations in sync\n   * even when some are paused or resumed at different times\n   *\n   * @param animationIds Animation IDs to synchronize\n   * @returns Synchronized animation control functions\n   */\n  function createSynchronizedAnimations(animationIds: string[]) {\n    // Generate a unique sync group ID\n    const syncGroupId = `sync-group-${Date.now()}-${Math.floor(Math.random() * 10000)}`;\n\n    // Update all animations to use this sync group\n    animationIds.forEach(id => {\n      const animation = animations.get(id);\n      if (animation) {\n        animation.config.syncGroup = syncGroupId;\n\n        // Add to sync group\n        let group = syncGroups.get(syncGroupId);\n        if (!group) {\n          group = new Set<string>();\n          syncGroups.set(syncGroupId, group);\n        }\n        group.add(id);\n      }\n    });\n\n    // Return control functions that operate on the whole group\n    return {\n      startAll: () => syncAnimations(syncGroupId, 'start'),\n      pauseAll: () => syncAnimations(syncGroupId, 'pause'),\n      resumeAll: () => syncAnimations(syncGroupId, 'resume'),\n      completeAll: () => syncAnimations(syncGroupId, 'complete'),\n      cancelAll: () => syncAnimations(syncGroupId, 'cancel'),\n      getSyncGroupId: () => syncGroupId,\n    };\n  }\n\n  // Return the public API\n  return {\n    registerAnimation,\n    startAnimation,\n    pauseAnimation,\n    resumeAnimation,\n    completeAnimation,\n    cancelAnimation,\n    updateVisibility,\n    updatePriority,\n    getPerformanceReport,\n    getStatus,\n    getAnimations,\n    checkElementVisibility,\n    createVisibilityTracker,\n    createSynchronizedAnimations,\n\n    // Direct sync group management\n    syncAnimations,\n  };\n}\n\n/**\n * Singleton instance for simple usage\n */\nexport const animationFrameManager = createAnimationFrameManager();\n\n/**\n * Helper to register a D3 transition with the animation frame manager\n *\n * @param selection D3 selection to animate\n * @param config Animation configuration\n * @returns Animation ID and the selection\n */\nexport function registerD3Transition<\n  GElement extends Element,\n  Datum,\n  PElement extends Element,\n  PDatum,\n>(\n  selection: d3.Selection<GElement, Datum, PElement, PDatum>,\n  config: Omit<RegisteredAnimationConfig, 'id' | 'type'> & { id?: string }\n): { id: string; selection: d3.Selection<GElement, Datum, PElement, PDatum> } {\n  // Create complete configuration\n  const fullConfig: Omit<RegisteredAnimationConfig, 'id'> & { id?: string } = {\n    ...config,\n    type: 'transition',\n  };\n\n  // Store original transition method\n  const _originalTransition = selection.transition;\n\n  // Register animation with frame manager\n  const id = animationFrameManager.registerAnimation(\n    fullConfig,\n    (_elapsed, _deltaTime, _frameInfo) => {\n      // Calculate progress based on elapsed time\n      const duration = fullConfig.duration || 1000;\n      const progress = Math.min(1, _elapsed / duration);\n\n      // Check if animation is complete\n      if (progress >= 1 && !fullConfig.loop) {\n        return true; // Complete the animation\n      }\n\n      return false;\n    }\n  );\n\n  // Start the animation\n  animationFrameManager.startAnimation(id);\n\n  return { id, selection };\n}\n\n/**\n * Helper to register a D3 timer animation with the frame manager\n *\n * @param callback D3 timer callback\n * @param config Animation configuration\n * @returns Animation ID and stop function\n */\nexport function registerD3Timer(\n  callback: (elapsed: number) => boolean | void,\n  config: Omit<RegisteredAnimationConfig, 'id' | 'type'> & { id?: string }\n): { id: string; stop: () => void } {\n  // Create complete configuration\n  const fullConfig: Omit<RegisteredAnimationConfig, 'id'> & { id?: string } = {\n    ...config,\n    type: 'timer',\n  };\n\n  // Register animation with frame manager\n  const id = animationFrameManager.registerAnimation(\n    fullConfig,\n    (elapsed, _deltaTime, _frameInfo) => {\n      // Call the original callback\n      const result = callback(elapsed);\n\n      // Check if animation should complete\n      if (\n        result === true ||\n        (fullConfig.duration && elapsed >= fullConfig.duration && !fullConfig.loop)\n      ) {\n        return true; // Complete the animation\n      }\n\n      return false;\n    }\n  );\n\n  // Start the animation\n  animationFrameManager.startAnimation(id);\n\n  // Return the ID and a stop function\n  return {\n    id,\n    stop: () => animationFrameManager.cancelAnimation(id),\n  };\n}\n\n/**\n * Register a TypedAnimationSequence with the frame manager for optimal performance\n *\n * @param sequence Animation sequence to register\n * @param config Animation configuration\n * @returns Animation ID and sequence controller\n */\nexport function registerAnimationSequence<\n  GElement extends Element,\n  Datum,\n  PElement extends Element,\n  PDatum,\n>(\n  sequence: TypedAnimationSequence<GElement, Datum, PElement, PDatum>,\n  config: Omit<RegisteredAnimationConfig, 'id' | 'type'> & { id?: string }\n): {\n  id: string;\n  controller: { start: () => void; stop: () => void; pause: () => void; resume: () => void };\n} {\n  // Store original sequence methods to intercept them\n  const _originalStart = sequence.start;\n  const _originalStop = sequence.stop;\n\n  // Create complete configuration\n  const fullConfig: Omit<RegisteredAnimationConfig, 'id'> & { id?: string } = {\n    ...config,\n    type: 'sequence',\n  };\n\n  // Register animation with frame manager\n  const id = animationFrameManager.registerAnimation(\n    fullConfig,\n    (elapsed, _deltaTime, _frameInfo) => {\n      // Check if sequence is complete based on its configuration\n      // Since we don't have direct access to sequence's internal state,\n      // we rely on the manager to handle timing\n      const duration = fullConfig.duration || 1000;\n\n      if (elapsed >= duration && !fullConfig.loop) {\n        return true; // Complete the animation\n      }\n\n      return false;\n    }\n  );\n\n  // Create controller\n  const controller = {\n    start: () => {\n      // Start in frame manager\n      animationFrameManager.startAnimation(id);\n      // Start the actual sequence\n      _originalStart.call(sequence);\n    },\n    stop: () => {\n      // Stop in frame manager\n      animationFrameManager.cancelAnimation(id);\n      // Stop the actual sequence\n      _originalStop.call(sequence);\n    },\n    pause: () => {\n      animationFrameManager.pauseAnimation(id);\n      // Note: TypedAnimationSequence doesn't have pause method by default\n    },\n    resume: () => {\n      animationFrameManager.resumeAnimation(id);\n      // Note: TypedAnimationSequence doesn't have resume method by default\n    },\n  };\n\n  return { id, controller };\n}\n\nfunction updateAnimation(\n  animation: RegisteredAnimation,\n  timestamp: number,\n  deltaTime: number,\n  frameInfo: FrameInfo\n): void {\n  // ... existing code ...\n  const _deltaTime = timestamp - animation.lastFrameTime;\n  const _frameInfo = {\n    timestamp,\n    elapsed: animation.elapsedTime,\n    deltaTime: _deltaTime,\n    frameCount: animation.frameCount,\n    remainingFrameBudget: frameInfo.remainingFrameBudget,\n    isFrameOverBudget: frameInfo.isFrameOverBudget,\n    currentFps: frameInfo.currentFps,\n  };\n  // ... existing code ...\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/performance/D3AnimationProfiler.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'detailedMetrics' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 132,
        "column": 5,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 132,
        "endColumn": 20
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'selectionUpdates' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 148,
        "column": 7,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 148,
        "endColumn": 23
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * D3 Animation Performance Profiler\n *\n * This module provides specialized profiling tools for measuring and improving\n * animation performance in D3 visualizations. It includes utilities for:\n *\n * 1. Tracking frame rates and frame timing during animations\n * 2. Measuring interpolation performance\n * 3. Identifying bottlenecks in animation sequences\n * 4. Generating performance reports and recommendations\n */\n\nimport * as d3 from 'd3';\nimport {\n  AnimationConfig,\n  TypedAnimationSequence,\n} from '../../types/visualizations/D3AnimationTypes';\n\n/**\n * Performance metrics for a single animation frame\n */\nexport interface AnimationFrameMetrics {\n  /** Timestamp when the frame started processing */\n  frameStartTime: number;\n  /** Timestamp when the frame was completed */\n  frameEndTime: number;\n  /** Duration of the frame in milliseconds */\n  frameDuration: number;\n  /** Number of DOM updates in this frame */\n  domUpdateCount: number;\n  /** Number of interpolations performed in this frame */\n  interpolationCount: number;\n  /** Time spent on interpolation calculations */\n  interpolationTime: number;\n  /** Time spent on DOM updates */\n  domUpdateTime: number;\n}\n\n/**\n * Performance data for a complete animation\n */\nexport interface AnimationPerformanceData {\n  /** Unique ID for the animation being profiled */\n  animationId: string;\n  /** Name of the animation being profiled */\n  animationName: string;\n  /** When the animation started */\n  startTime: number;\n  /** When the animation ended */\n  endTime: number;\n  /** Total duration of the animation */\n  totalDuration: number;\n  /** Configuration of the animation */\n  animationConfig: AnimationConfig;\n  /** Performance metrics for each frame */\n  frames: AnimationFrameMetrics[];\n  /** Average frame duration */\n  averageFrameDuration: number;\n  /** Minimum frame duration */\n  minFrameDuration: number;\n  /** Maximum frame duration */\n  maxFrameDuration: number;\n  /** Target FPS */\n  targetFps: number;\n  /** Actual average FPS achieved */\n  actualFps: number;\n  /** Number of frames that exceeded target frame duration */\n  droppedFrames: number;\n  /** Percentage of frames that met the target duration */\n  frameSuccessRate: number;\n}\n\n/**\n * Performance bottleneck identification\n */\nexport interface AnimationBottleneck {\n  /** Type of bottleneck */\n  type: 'interpolation' | 'dom_updates' | 'javascript' | 'rendering' | 'unknown';\n  /** Severity level from 0-1 (0 = minor, 1 = severe) */\n  severity: number;\n  /** Description of the bottleneck */\n  description: string;\n  /** Suggested fix */\n  suggestion: string;\n  /** Frame indices where this bottleneck occurred */\n  affectedFrames: number[];\n}\n\n/**\n * Animation performance report\n */\nexport interface AnimationPerformanceReport {\n  /** Performance data for the animation */\n  performanceData: AnimationPerformanceData;\n  /** Identified bottlenecks */\n  bottlenecks: AnimationBottleneck[];\n  /** Overall performance score (0-100) */\n  performanceScore: number;\n  /** Specific recommendations to improve performance */\n  recommendations: string[];\n  /** Whether the animation meets performance targets */\n  meetsTargets: boolean;\n}\n\n/**\n * Configuration for animation profiling\n */\nexport interface AnimationProfilerConfig {\n  /** Target FPS to maintain */\n  targetFps?: number;\n  /** Enable detailed per-frame metrics */\n  detailedMetrics?: boolean;\n  /** Duration to profile (ms) - undefined for entire animation */\n  profileDuration?: number;\n  /** Whether to track DOM updates */\n  trackDomUpdates?: boolean;\n  /** Whether to track interpolation performance */\n  trackInterpolation?: boolean;\n  /** Callback to execute when profiling is complete */\n  onComplete?: (report: AnimationPerformanceReport) => void;\n}\n\n/**\n * Creates a profiler for measuring animation performance\n *\n * @param config Profiler configuration\n * @returns Animation profiler object\n */\nexport function createAnimationProfiler(config: AnimationProfilerConfig = {}) {\n  const {\n    targetFps = 60,\n    detailedMetrics = true,\n    profileDuration,\n    trackDomUpdates = true,\n    trackInterpolation = true,\n    onComplete,\n  } = config;\n\n  // Initialize profiling state\n  let animationId = `animation-${Date.now()}`;\n  let animationName = 'Unnamed Animation';\n  let isRunning = false;\n  let startTime = 0;\n  let frameCount = 0;\n  let frames: AnimationFrameMetrics[] = [];\n  let lastFrameTime = 0;\n  let animationConfig: AnimationConfig = { duration: 0 };\n  let selectionUpdates = 0;\n  let interpolationMeasurements: Array<{ count: number; duration: number }> = [];\n\n  const targetFrameDuration = 1000 / targetFps;\n\n  /**\n   * Starts profiling an animation\n   *\n   * @param id Optional custom ID for the animation\n   * @param name Optional name for the animation\n   * @param config Configuration of the animation being profiled\n   */\n  function start(id?: string, name?: string, config?: AnimationConfig) {\n    if (isRunning) {\n      stop();\n    }\n\n    if (id) {\n      animationId = id;\n    }\n\n    if (name) {\n      animationName = name;\n    }\n\n    if (config) {\n      animationConfig = config;\n    }\n\n    isRunning = true;\n    startTime = performance.now();\n    lastFrameTime = startTime;\n    frameCount = 0;\n    frames = [];\n    selectionUpdates = 0;\n    interpolationMeasurements = [];\n\n    // Set up duration-limited profiling if requested\n    if (profileDuration) {\n      setTimeout(() => {\n        if (isRunning) {\n          stop();\n        }\n      }, profileDuration);\n    }\n  }\n\n  /**\n   * Records metrics for a single animation frame\n   *\n   * @param frameMetrics Optional metrics to include\n   */\n  function recordFrame(frameMetrics?: Partial<AnimationFrameMetrics>) {\n    if (!isRunning) return;\n\n    const now = performance.now();\n    const frameDuration = now - lastFrameTime;\n\n    const metrics: AnimationFrameMetrics = {\n      frameStartTime: lastFrameTime,\n      frameEndTime: now,\n      frameDuration,\n      domUpdateCount: frameMetrics?.domUpdateCount || 0,\n      interpolationCount: frameMetrics?.interpolationCount || 0,\n      interpolationTime: frameMetrics?.interpolationTime || 0,\n      domUpdateTime: frameMetrics?.domUpdateTime || 0,\n    };\n\n    frames.push(metrics);\n    frameCount++;\n    lastFrameTime = now;\n  }\n\n  /**\n   * Records DOM update performance\n   *\n   * @param updateCount Number of elements updated\n   * @param duration Time taken for the updates\n   */\n  function recordDomUpdates(updateCount: number, duration: number) {\n    if (!isRunning || !trackDomUpdates) return;\n\n    selectionUpdates += updateCount;\n\n    // Update the last frame with DOM update information\n    if (frames.length > 0) {\n      const lastFrame = frames[frames.length - 1];\n      lastFrame.domUpdateCount += updateCount;\n      lastFrame.domUpdateTime += duration;\n    }\n  }\n\n  /**\n   * Records interpolation performance\n   *\n   * @param count Number of interpolations performed\n   * @param duration Time taken for the interpolations\n   */\n  function recordInterpolation(count: number, duration: number) {\n    if (!isRunning || !trackInterpolation) return;\n\n    interpolationMeasurements.push({ count, duration });\n\n    // Update the last frame with interpolation information\n    if (frames.length > 0) {\n      const lastFrame = frames[frames.length - 1];\n      lastFrame.interpolationCount += count;\n      lastFrame.interpolationTime += duration;\n    }\n  }\n\n  /**\n   * Stops profiling and generates a performance report\n   *\n   * @returns A performance report for the animation\n   */\n  function stop(): AnimationPerformanceReport {\n    if (!isRunning) {\n      return createEmptyReport();\n    }\n\n    isRunning = false;\n    const endTime = performance.now();\n    const totalDuration = endTime - startTime;\n\n    // Calculate frame statistics\n    const frameDurations = frames.map(f => f.frameDuration);\n    const averageFrameDuration =\n      frameDurations.reduce((sum, duration) => sum + duration, 0) / frames.length || 0;\n    const minFrameDuration = Math.min(...frameDurations) || 0;\n    const maxFrameDuration = Math.max(...frameDurations) || 0;\n    const actualFps = 1000 / averageFrameDuration || 0;\n    const droppedFrames = frames.filter(f => f.frameDuration > targetFrameDuration).length;\n    const frameSuccessRate = 1 - droppedFrames / frames.length || 0;\n\n    // Create performance data object\n    const performanceData: AnimationPerformanceData = {\n      animationId,\n      animationName,\n      startTime,\n      endTime,\n      totalDuration,\n      animationConfig,\n      frames,\n      averageFrameDuration,\n      minFrameDuration,\n      maxFrameDuration,\n      targetFps,\n      actualFps,\n      droppedFrames,\n      frameSuccessRate,\n    };\n\n    // Identify bottlenecks\n    const bottlenecks = identifyBottlenecks(performanceData);\n\n    // Calculate overall performance score (0-100)\n    const performanceScore = calculatePerformanceScore(performanceData, bottlenecks);\n\n    // Generate recommendations\n    const recommendations = generateRecommendations(performanceData, bottlenecks);\n\n    // Determine if performance targets are met\n    const meetsTargets = performanceScore >= 80 && frameSuccessRate >= 0.95;\n\n    // Create the full report\n    const report: AnimationPerformanceReport = {\n      performanceData,\n      bottlenecks,\n      performanceScore,\n      recommendations,\n      meetsTargets,\n    };\n\n    // Call the completion callback if provided\n    if (onComplete) {\n      onComplete(report);\n    }\n\n    return report;\n  }\n\n  /**\n   * Creates an empty performance report\n   */\n  function createEmptyReport(): AnimationPerformanceReport {\n    return {\n      performanceData: {\n        animationId,\n        animationName,\n        startTime: 0,\n        endTime: 0,\n        totalDuration: 0,\n        animationConfig,\n        frames: [],\n        averageFrameDuration: 0,\n        minFrameDuration: 0,\n        maxFrameDuration: 0,\n        targetFps,\n        actualFps: 0,\n        droppedFrames: 0,\n        frameSuccessRate: 0,\n      },\n      bottlenecks: [],\n      performanceScore: 0,\n      recommendations: ['No performance data available.'],\n      meetsTargets: false,\n    };\n  }\n\n  /**\n   * Identifies performance bottlenecks in the animation\n   */\n  function identifyBottlenecks(data: AnimationPerformanceData): AnimationBottleneck[] {\n    const bottlenecks: AnimationBottleneck[] = [];\n\n    // Check for frame rate issues\n    if (data.actualFps < targetFps * 0.9) {\n      bottlenecks.push({\n        type: 'unknown',\n        severity: Math.min(1, (targetFps - data.actualFps) / targetFps),\n        description: `Frame rate below target (${data.actualFps.toFixed(1)} fps vs target ${targetFps} fps)`,\n        suggestion: 'Review the animation for complexity and optimize rendering performance',\n        affectedFrames: frames.map((_, index) => index),\n      });\n    }\n\n    // Check for DOM update bottlenecks\n    const domHeavyFrames = frames\n      .map((frame, index) => ({\n        index,\n        ratio: frame.domUpdateTime / frame.frameDuration,\n      }))\n      .filter(frame => frame.ratio > 0.5);\n\n    if (domHeavyFrames.length > frames.length * 0.2) {\n      bottlenecks.push({\n        type: 'dom_updates',\n        severity: Math.min(1, domHeavyFrames.length / frames.length),\n        description: `DOM updates consuming >50% of frame time in ${domHeavyFrames.length} frames`,\n        suggestion: 'Reduce DOM updates by batching changes or using virtual DOM techniques',\n        affectedFrames: domHeavyFrames.map(f => f.index),\n      });\n    }\n\n    // Check for interpolation bottlenecks\n    const interpolationHeavyFrames = frames\n      .map((frame, index) => ({\n        index,\n        ratio: frame.interpolationTime / frame.frameDuration,\n      }))\n      .filter(frame => frame.ratio > 0.3);\n\n    if (interpolationHeavyFrames.length > frames.length * 0.2) {\n      bottlenecks.push({\n        type: 'interpolation',\n        severity: Math.min(1, interpolationHeavyFrames.length / frames.length),\n        description: `Interpolation consuming >30% of frame time in ${interpolationHeavyFrames.length} frames`,\n        suggestion:\n          'Implement memoization for interpolation results or reduce interpolation complexity',\n        affectedFrames: interpolationHeavyFrames.map(f => f.index),\n      });\n    }\n\n    // Check for rendering issues (high variance in frame times)\n    const frameDurationStdDev = calculateStandardDeviation(frames.map(f => f.frameDuration));\n\n    if (frameDurationStdDev > targetFrameDuration * 0.5) {\n      bottlenecks.push({\n        type: 'rendering',\n        severity: Math.min(1, frameDurationStdDev / targetFrameDuration),\n        description: 'High variance in frame times indicates inconsistent rendering performance',\n        suggestion:\n          'Look for layout thrashing, implement requestAnimationFrame properly, or use CSS transitions where possible',\n        affectedFrames: frames\n          .map((frame, index) => ({ index, duration: frame.frameDuration }))\n          .filter(\n            frame => Math.abs(frame.duration - data.averageFrameDuration) > targetFrameDuration\n          )\n          .map(frame => frame.index),\n      });\n    }\n\n    return bottlenecks;\n  }\n\n  /**\n   * Calculates standard deviation for an array of numbers\n   */\n  function calculateStandardDeviation(values: number[]): number {\n    const avg = values.reduce((sum, val) => sum + val, 0) / values.length;\n    const squareDiffs = values.map(value => Math.pow(value - avg, 2));\n    const avgSquareDiff = squareDiffs.reduce((sum, val) => sum + val, 0) / squareDiffs.length;\n    return Math.sqrt(avgSquareDiff);\n  }\n\n  /**\n   * Calculates an overall performance score based on metrics and bottlenecks\n   */\n  function calculatePerformanceScore(\n    data: AnimationPerformanceData,\n    bottlenecks: AnimationBottleneck[]\n  ): number {\n    // Base score from frame success rate (0-50 points)\n    const frameRateScore = data.frameSuccessRate * 50;\n\n    // Score from actual FPS vs target FPS (0-20 points)\n    const fpsRatio = Math.min(1, data.actualFps / targetFps);\n    const fpsScore = fpsRatio * 20;\n\n    // Penalty from bottlenecks (0-30 points)\n    const bottleneckPenalty = bottlenecks.reduce(\n      (penalty, bottleneck) => penalty + bottleneck.severity * 10,\n      0\n    );\n    const bottleneckScore = Math.max(0, 30 - bottleneckPenalty);\n\n    // Calculate total score (0-100)\n    return Math.round(frameRateScore + fpsScore + bottleneckScore);\n  }\n\n  /**\n   * Generates performance improvement recommendations\n   */\n  function generateRecommendations(\n    data: AnimationPerformanceData,\n    bottlenecks: AnimationBottleneck[]\n  ): string[] {\n    const recommendations: string[] = [];\n\n    // Add bottleneck-specific recommendations\n    bottlenecks.forEach(bottleneck => {\n      recommendations.push(bottleneck.suggestion);\n    });\n\n    // Add general recommendations based on performance data\n    if (data.actualFps < targetFps * 0.8) {\n      recommendations.push('Consider reducing animation complexity or extending duration');\n    }\n\n    if (data.frames.some(f => f.domUpdateCount > 50)) {\n      recommendations.push('Limit DOM updates per frame to improve performance');\n    }\n\n    if (data.frames.some(f => f.interpolationCount > 100)) {\n      recommendations.push(\n        'Reduce the number of interpolations per frame or implement memoization'\n      );\n    }\n\n    // If performance is good, acknowledge it\n    if (data.frameSuccessRate > 0.95 && data.actualFps >= targetFps * 0.95) {\n      recommendations.push('Animation performance is good, no critical issues detected');\n    }\n\n    return [...new Set(recommendations)]; // Remove duplicates\n  }\n\n  /**\n   * Wraps a selection's transition method to enable profiling\n   *\n   * @param selection D3 selection to profile\n   * @returns The modified selection\n   */\n  function wrapSelection<GElement extends Element, Datum, PElement extends Element, PDatum>(\n    selection: d3.Selection<GElement, Datum, PElement, PDatum>\n  ): d3.Selection<GElement, Datum, PElement, PDatum> {\n    if (!isRunning || !trackDomUpdates) {\n      return selection;\n    }\n\n    // Store the original methods\n    const originalTransition = selection.transition;\n    const originalAttr = selection.attr;\n    const originalStyle = selection.style;\n\n    // Wrap transition method\n    selection.transition = function (...args: unknown[]): unknown {\n      const startTime = performance.now();\n      const result = originalTransition.apply(this, args);\n      const duration = performance.now() - startTime;\n\n      // Record transition creation\n      recordDomUpdates(1, duration);\n\n      return result;\n    } as unknown;\n\n    // Wrap attr method\n    selection.attr = function (...args: unknown[]): unknown {\n      const startTime = performance.now();\n      const result = originalAttr.apply(this, args);\n      const duration = performance.now() - startTime;\n\n      // Record attribute updates\n      recordDomUpdates(selection.size(), duration);\n\n      return result;\n    } as unknown;\n\n    // Wrap style method\n    selection.style = function (...args: unknown[]): unknown {\n      const startTime = performance.now();\n      const result = originalStyle.apply(this, args);\n      const duration = performance.now() - startTime;\n\n      // Record style updates\n      recordDomUpdates(selection.size(), duration);\n\n      return result;\n    } as unknown;\n\n    return selection;\n  }\n\n  /**\n   * Creates a wrapped interpolator for performance measurement\n   *\n   * @param interpolator Original interpolator function\n   * @returns Wrapped interpolator that measures performance\n   */\n  function wrapInterpolator<T>(interpolator: (t: number) => T): (t: number) => T {\n    if (!isRunning || !trackInterpolation) {\n      return interpolator;\n    }\n\n    return (t: number): T => {\n      const startTime = performance.now();\n      const result = interpolator(t);\n      const duration = performance.now() - startTime;\n\n      recordInterpolation(1, duration);\n\n      return result;\n    };\n  }\n\n  /**\n   * Gets the current profiling status\n   */\n  function getStatus() {\n    return {\n      isRunning,\n      frameCount,\n      elapsedTime: isRunning ? performance.now() - startTime : 0,\n      currentFps:\n        isRunning && frameCount > 0 ? frameCount / ((performance.now() - startTime) / 1000) : 0,\n    };\n  }\n\n  // Return the profiler API\n  return {\n    start,\n    stop,\n    recordFrame,\n    recordDomUpdates,\n    recordInterpolation,\n    wrapSelection,\n    wrapInterpolator,\n    getStatus,\n  };\n}\n\n/**\n * Helper to profile a D3AnimationSequence\n *\n * @param sequence Animation sequence to profile\n * @param config Profiler configuration\n * @returns Promise that resolves to a performance report\n */\nexport function profileAnimationSequence<\n  GElement extends Element,\n  Datum,\n  PElement extends Element,\n  PDatum,\n>(\n  sequence: TypedAnimationSequence<GElement, Datum, PElement, PDatum>,\n  config: AnimationProfilerConfig = {}\n): Promise<AnimationPerformanceReport> {\n  return new Promise(resolve => {\n    const profiler = createAnimationProfiler({\n      ...config,\n      onComplete: report => resolve(report),\n    });\n\n    // Start profiling\n    profiler.start(\n      'sequence-' + Date.now(),\n      'Animation Sequence',\n      // Extract duration from the first transition if available\n      sequence['config'] && sequence['config'].transitions && sequence['config'].transitions[0]\n        ? { duration: sequence['config'].transitions[0].duration || 0 }\n        : { duration: 0 }\n    );\n\n    // Create a frame tracking wrapper\n    const frameTracker = () => {\n      profiler.recordFrame();\n      if (profiler.getStatus().isRunning) {\n        requestAnimationFrame(frameTracker);\n      }\n    };\n\n    // Start frame tracking\n    requestAnimationFrame(frameTracker);\n\n    // Start the sequence\n    sequence.start();\n\n    // Stop profiling when sequence completes or after timeout\n    const stopTimeout = setTimeout(() => {\n      if (profiler.getStatus().isRunning) {\n        profiler.stop();\n      }\n    }, config.profileDuration || 10000); // Default to 10 seconds max\n\n    // Try to access private property to detect completion\n    const privateConfig = (sequence as unknown).config;\n    if (privateConfig && !privateConfig.loop && privateConfig.onComplete) {\n      const originalOnComplete = privateConfig.onComplete;\n      privateConfig.onComplete = () => {\n        originalOnComplete();\n        clearTimeout(stopTimeout);\n        if (profiler.getStatus().isRunning) {\n          profiler.stop();\n        }\n      };\n    }\n  });\n}\n\n/**\n * Formats a performance report as a readable string\n *\n * @param report Animation performance report\n * @returns Formatted report as string\n */\nexport function formatPerformanceReport(report: AnimationPerformanceReport): string {\n  const { performanceData, bottlenecks, performanceScore, recommendations } = report;\n\n  const lines = [\n    `# Animation Performance Report for \"${performanceData.animationName}\"`,\n    ``,\n    `## Overview`,\n    `- **Performance Score**: ${performanceScore}/100${performanceScore >= 80 ? ' ✅' : ' ⚠️'}`,\n    `- **Target FPS**: ${performanceData.targetFps}`,\n    `- **Actual FPS**: ${performanceData.actualFps.toFixed(1)}${performanceData.actualFps >= performanceData.targetFps * 0.95 ? ' ✅' : ' ⚠️'}`,\n    `- **Duration**: ${performanceData.totalDuration.toFixed(0)}ms`,\n    `- **Frame Success Rate**: ${(performanceData.frameSuccessRate * 100).toFixed(1)}%`,\n    `- **Dropped Frames**: ${performanceData.droppedFrames} of ${performanceData.frames.length}`,\n    ``,\n    `## Performance Bottlenecks`,\n  ];\n\n  if (bottlenecks.length === 0) {\n    lines.push('No significant bottlenecks detected.');\n  } else {\n    bottlenecks.forEach((bottleneck, i) => {\n      lines.push(`### Bottleneck ${i + 1}: ${bottleneck.type.replace('_', ' ').toUpperCase()}`);\n      lines.push(`- **Severity**: ${(bottleneck.severity * 100).toFixed(0)}%`);\n      lines.push(`- **Description**: ${bottleneck.description}`);\n      lines.push(`- **Suggestion**: ${bottleneck.suggestion}`);\n      lines.push(``);\n    });\n  }\n\n  lines.push(`## Recommendations`);\n  if (recommendations.length === 0) {\n    lines.push('No specific recommendations.');\n  } else {\n    recommendations.forEach((rec, i) => {\n      lines.push(`${i + 1}. ${rec}`);\n    });\n  }\n\n  return lines.join('\\n');\n}\n\n/**\n * Default profiler instance for simple usage\n */\nexport const defaultAnimationProfiler = createAnimationProfiler();\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/performance/D3AnimationQualityManager.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'e' is defined but never used. Allowed unused caught errors must match /^_/u.",
        "line": 357,
        "column": 14,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 357,
        "endColumn": 15
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 364,
        "column": 45,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 364,
        "endColumn": 48,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [9890, 9893], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [9890, 9893], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'e' is defined but never used. Allowed unused caught errors must match /^_/u.",
        "line": 375,
        "column": 16,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 375,
        "endColumn": 17
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 398,
        "column": 40,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 398,
        "endColumn": 43,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [11101, 11104], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [11101, 11104], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'benchmarkResult' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 415,
        "column": 7,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 415,
        "endColumn": 22
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 434,
        "column": 42,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 434,
        "endColumn": 45,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [12291, 12294], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [12291, 12294], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 3,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * D3 Animation Quality Manager\n *\n * This module provides a system for dynamically adjusting animation quality based on\n * device performance capabilities. It detects device performance characteristics and\n * automatically adjusts visualization complexity to maintain smooth animation experiences.\n *\n * Key features:\n * 1. Performance detection and categorization\n * 2. Quality presets for different device capabilities\n * 3. Dynamic quality adjustment based on real-time FPS\n * 4. Integration with existing animation systems\n * 5. User preference overrides\n */\n\nimport * as d3 from 'd3';\n\n/**\n * Performance tier categorization\n */\nexport type PerformanceTier = 'ultra' | 'high' | 'medium' | 'low' | 'minimal';\n\n/**\n * Quality settings that can be adjusted\n */\nexport interface QualitySettings {\n  /** Maximum number of animated elements */\n  maxElementCount: number;\n\n  /** Target frames per second */\n  targetFps: number;\n\n  /** Animation smoothness (1 = every frame, 2 = every other frame, etc.) */\n  animationStepFactor: number;\n\n  /** Visual complexity level (0-1) affecting details like shadows, gradients */\n  visualComplexity: number;\n\n  /** Whether to use WebGL acceleration when available */\n  useWebGLWhenAvailable: boolean;\n\n  /** Number of intermediate animation steps */\n  interpolationSteps: number;\n\n  /** Whether to use physics simulation */\n  enablePhysics: boolean;\n\n  /** Physics simulation detail level */\n  physicsDetail: number;\n\n  /** Whether to enable visual effects */\n  enableEffects: boolean;\n\n  /** Whether to enable batching for DOM operations */\n  enableBatching: boolean;\n\n  /** Whether to enable animation memoization */\n  enableMemoization: boolean;\n\n  /** Whether transitions should follow precise timing */\n  preciseTiming: boolean;\n}\n\n/**\n * Device capability information\n */\nexport interface DeviceCapabilities {\n  /** CPU benchmark score */\n  cpuScore: number;\n\n  /** GPU benchmark score */\n  gpuScore: number;\n\n  /** Memory available (approximation) */\n  memoryScore: number;\n\n  /** Connection speed category */\n  connectionType: 'slow' | 'medium' | 'fast' | 'unknown';\n\n  /** Whether the device is a mobile device */\n  isMobile: boolean;\n\n  /** Whether the device supports WebGL */\n  hasWebGL: boolean;\n\n  /** Whether the device is in battery saving mode */\n  isBatterySaving: boolean;\n\n  /** Screen resolution category */\n  screenCategory: 'low' | 'medium' | 'high' | 'ultra';\n\n  /** Browser performance capability */\n  browserPerformance: 'low' | 'medium' | 'high';\n}\n\n/**\n * Quality management configuration\n */\nexport interface QualityManagerConfig {\n  /** Whether to enable automatic quality adjustment */\n  enableAutoAdjustment?: boolean;\n\n  /** Minimum acceptable FPS before reducing quality */\n  minAcceptableFps?: number;\n\n  /** How often to check performance (ms) */\n  performanceCheckInterval?: number;\n\n  /** How quickly to adjust quality (0-1, higher = faster) */\n  adjustmentResponsiveness?: number;\n\n  /** Whether to respect prefers-reduced-motion */\n  respectPrefersReducedMotion?: boolean;\n\n  /** Whether to respect battery saving modes */\n  respectBatterySaving?: boolean;\n\n  /** Whether to save quality settings to local storage */\n  persistSettings?: boolean;\n\n  /** Initial quality tier override */\n  initialQualityTier?: PerformanceTier;\n\n  /** Maximum allowed elements regardless of performance */\n  absoluteMaxElementCount?: number;\n\n  /** Debug mode */\n  debugMode?: boolean;\n}\n\n/**\n * Performance monitoring state\n */\ninterface PerformanceState {\n  currentFps: number;\n  fpsHistory: number[];\n  lastAdjustmentTime: number;\n  adjustmentCount: number;\n  currentTier: PerformanceTier;\n  detectedCapabilities: DeviceCapabilities;\n  isInitialized: boolean;\n  isAdjusting: boolean;\n}\n\n/**\n * Animation quality manager for D3 visualizations\n */\nexport class D3AnimationQualityManager {\n  /** Default quality presets for each performance tier */\n  private qualityPresets: Record<PerformanceTier, QualitySettings> = {\n    ultra: {\n      maxElementCount: 10000,\n      targetFps: 60,\n      animationStepFactor: 1,\n      visualComplexity: 1.0,\n      useWebGLWhenAvailable: true,\n      interpolationSteps: 60,\n      enablePhysics: true,\n      physicsDetail: 1.0,\n      enableEffects: true,\n      enableBatching: true,\n      enableMemoization: true,\n      preciseTiming: true,\n    },\n    high: {\n      maxElementCount: 5000,\n      targetFps: 60,\n      animationStepFactor: 1,\n      visualComplexity: 0.8,\n      useWebGLWhenAvailable: true,\n      interpolationSteps: 45,\n      enablePhysics: true,\n      physicsDetail: 0.8,\n      enableEffects: true,\n      enableBatching: true,\n      enableMemoization: true,\n      preciseTiming: true,\n    },\n    medium: {\n      maxElementCount: 2000,\n      targetFps: 40,\n      animationStepFactor: 2,\n      visualComplexity: 0.6,\n      useWebGLWhenAvailable: true,\n      interpolationSteps: 30,\n      enablePhysics: true,\n      physicsDetail: 0.5,\n      enableEffects: false,\n      enableBatching: true,\n      enableMemoization: true,\n      preciseTiming: false,\n    },\n    low: {\n      maxElementCount: 1000,\n      targetFps: 30,\n      animationStepFactor: 2,\n      visualComplexity: 0.4,\n      useWebGLWhenAvailable: true,\n      interpolationSteps: 20,\n      enablePhysics: false,\n      physicsDetail: 0.3,\n      enableEffects: false,\n      enableBatching: true,\n      enableMemoization: true,\n      preciseTiming: false,\n    },\n    minimal: {\n      maxElementCount: 500,\n      targetFps: 20,\n      animationStepFactor: 3,\n      visualComplexity: 0.2,\n      useWebGLWhenAvailable: false,\n      interpolationSteps: 10,\n      enablePhysics: false,\n      physicsDetail: 0.1,\n      enableEffects: false,\n      enableBatching: true,\n      enableMemoization: false,\n      preciseTiming: false,\n    },\n  };\n\n  /** Current quality settings */\n  private currentSettings: QualitySettings;\n\n  /** User preference overrides */\n  private userOverrides: Partial<QualitySettings> = {};\n\n  /** Current performance state */\n  private performanceState: PerformanceState = {\n    currentFps: 0,\n    fpsHistory: [],\n    lastAdjustmentTime: 0,\n    adjustmentCount: 0,\n    currentTier: 'medium',\n    detectedCapabilities: this.getDefaultCapabilities(),\n    isInitialized: false,\n    isAdjusting: false,\n  };\n\n  /** Performance monitoring interval */\n  private monitoringInterval: number | null = null;\n\n  /** Animation callbacks by ID */\n  private qualityChangeCallbacks: Map<string, (settings: QualitySettings) => void> = new Map();\n\n  /** Animation quality overrides by ID */\n  private animationQualityOverrides: Map<string, Partial<QualitySettings>> = new Map();\n\n  /** Animation FPS history */\n  private animationFpsTracking: Map<string, number[]> = new Map();\n\n  /**\n   * Create a new animation quality manager\n   */\n  constructor(private config: QualityManagerConfig = {}) {\n    // Set up default configuration\n    this.config = {\n      enableAutoAdjustment: true,\n      minAcceptableFps: 30,\n      performanceCheckInterval: 5000,\n      adjustmentResponsiveness: 0.5,\n      respectPrefersReducedMotion: true,\n      respectBatterySaving: true,\n      persistSettings: true,\n      initialQualityTier: undefined,\n      absoluteMaxElementCount: 20000,\n      debugMode: false,\n      ...config,\n    };\n\n    // Initialize with medium settings first (will be adjusted)\n    this.currentSettings = this.qualityPresets.medium;\n\n    // Load saved settings if enabled\n    if (this.config.persistSettings) {\n      this.loadSavedSettings();\n    }\n\n    // Apply initial quality tier if specified\n    if (this.config.initialQualityTier) {\n      this.setQualityTier(this.config.initialQualityTier);\n    }\n\n    // Initialize the system\n    this.initialize();\n  }\n\n  /**\n   * Initialize the quality management system\n   */\n  private async initialize(): Promise<void> {\n    // Load browser capability detection\n    await this.detectDeviceCapabilities();\n\n    // Set initial quality based on detected capabilities\n    if (!this.config.initialQualityTier) {\n      const detectedTier = this.detectOptimalQualityTier();\n      this.setQualityTier(detectedTier);\n    }\n\n    // Start monitoring if auto-adjustment is enabled\n    if (this.config.enableAutoAdjustment) {\n      this.startPerformanceMonitoring();\n    }\n\n    // Monitor system events that might affect performance\n    this.setupSystemEventListeners();\n\n    // Mark as initialized\n    this.performanceState.isInitialized = true;\n\n    if (this.config.debugMode) {\n      console.warn('D3AnimationQualityManager initialized', {\n        capabilities: this.performanceState.detectedCapabilities,\n        qualityTier: this.performanceState.currentTier,\n        settings: this.currentSettings,\n      });\n    }\n  }\n\n  /**\n   * Get default capabilities when proper detection isn't available\n   */\n  private getDefaultCapabilities(): DeviceCapabilities {\n    return {\n      cpuScore: 50,\n      gpuScore: 50,\n      memoryScore: 50,\n      connectionType: 'unknown',\n      isMobile: false,\n      hasWebGL: false,\n      isBatterySaving: false,\n      screenCategory: 'medium',\n      browserPerformance: 'medium',\n    };\n  }\n\n  /**\n   * Detect device capabilities\n   */\n  private async detectDeviceCapabilities(): Promise<void> {\n    const capabilities: DeviceCapabilities = this.getDefaultCapabilities();\n\n    // Mobile detection\n    capabilities.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(\n      navigator.userAgent\n    );\n\n    // WebGL support\n    try {\n      const canvas = document.createElement('canvas');\n      capabilities.hasWebGL = !!(\n        window.WebGLRenderingContext &&\n        (canvas.getContext('webgl') || canvas.getContext('experimental-webgl'))\n      );\n    } catch (e) {\n      capabilities.hasWebGL = false;\n    }\n\n    // Battery API check\n    if ('getBattery' in navigator) {\n      try {\n        const battery = await (navigator as any).getBattery();\n        capabilities.isBatterySaving = battery.charging === false && battery.level < 0.2;\n\n        // Listen for battery changes\n        battery.addEventListener('levelchange', () => {\n          this.performanceState.detectedCapabilities.isBatterySaving =\n            battery.charging === false && battery.level < 0.2;\n          if (this.config.respectBatterySaving) {\n            this.adjustQualityIfNeeded();\n          }\n        });\n      } catch (e) {\n        // Battery API not available\n      }\n    }\n\n    // Screen resolution category\n    const pixelRatio = window.devicePixelRatio || 1;\n    const screenWidth = window.screen.width * pixelRatio;\n    const screenHeight = window.screen.height * pixelRatio;\n    const resolution = screenWidth * screenHeight;\n\n    if (resolution > 4000 * 3000) {\n      capabilities.screenCategory = 'ultra';\n    } else if (resolution > 2000 * 1500) {\n      capabilities.screenCategory = 'high';\n    } else if (resolution > 1000 * 750) {\n      capabilities.screenCategory = 'medium';\n    } else {\n      capabilities.screenCategory = 'low';\n    }\n\n    // Connection type detection\n    if ('connection' in navigator) {\n      const connection = (navigator as any).connection;\n      if (connection) {\n        const effectiveType = connection.effectiveType;\n        if (effectiveType === '4g') {\n          capabilities.connectionType = 'fast';\n        } else if (effectiveType === '3g') {\n          capabilities.connectionType = 'medium';\n        } else {\n          capabilities.connectionType = 'slow';\n        }\n      }\n    }\n\n    // Perform quick CPU benchmark\n    const cpuBenchmarkStart = performance.now();\n    let benchmarkResult = 0;\n    for (let i = 0; i < 1000000; i++) {\n      benchmarkResult += Math.sqrt(i);\n    }\n    const cpuBenchmarkTime = performance.now() - cpuBenchmarkStart;\n\n    // Normalize CPU score (lower is better, so invert)\n    capabilities.cpuScore = Math.min(100, Math.max(0, 100 - cpuBenchmarkTime / 50));\n\n    // GPU benchmarking is more complex and would require WebGL,\n    // for simplicity we'll estimate based on other factors\n    capabilities.gpuScore = capabilities.hasWebGL\n      ? capabilities.isMobile\n        ? 60\n        : 80\n      : capabilities.isMobile\n        ? 30\n        : 50;\n\n    // Attempt to estimate available memory\n    if ('deviceMemory' in navigator) {\n      const deviceMemory = (navigator as any).deviceMemory;\n      if (typeof deviceMemory === 'number') {\n        // deviceMemory is in GB, normalize to 0-100 scale\n        // Assuming 8GB as high-end, 16GB+ as maximum\n        capabilities.memoryScore = Math.min(100, Math.max(0, (deviceMemory / 16) * 100));\n      }\n    } else {\n      // Default assumption based on device type\n      capabilities.memoryScore = capabilities.isMobile ? 40 : 70;\n    }\n\n    // Browser performance estimation\n    // This is a very rough heuristic\n    const browserScore =\n      (capabilities.cpuScore + capabilities.gpuScore + capabilities.memoryScore) / 3;\n    if (browserScore > 70) {\n      capabilities.browserPerformance = 'high';\n    } else if (browserScore > 40) {\n      capabilities.browserPerformance = 'medium';\n    } else {\n      capabilities.browserPerformance = 'low';\n    }\n\n    // Update the state\n    this.performanceState.detectedCapabilities = capabilities;\n  }\n\n  /**\n   * Determine the optimal quality tier based on detected capabilities\n   */\n  private detectOptimalQualityTier(): PerformanceTier {\n    const caps = this.performanceState.detectedCapabilities;\n\n    // Basic score combining all factors\n    const overallScore =\n      caps.cpuScore * 0.3 +\n      caps.gpuScore * 0.3 +\n      caps.memoryScore * 0.2 +\n      (caps.isMobile ? 0 : 20) +\n      (caps.hasWebGL ? 10 : 0) +\n      (caps.isBatterySaving ? -15 : 0) +\n      (caps.screenCategory === 'ultra'\n        ? 10\n        : caps.screenCategory === 'high'\n          ? 5\n          : caps.screenCategory === 'low'\n            ? -5\n            : 0);\n\n    // Map overall score to quality tier\n    if (overallScore >= 80) {\n      return 'ultra';\n    } else if (overallScore >= 60) {\n      return 'high';\n    } else if (overallScore >= 40) {\n      return 'medium';\n    } else if (overallScore >= 20) {\n      return 'low';\n    } else {\n      return 'minimal';\n    }\n  }\n\n  /**\n   * Start monitoring performance to adjust quality dynamically\n   */\n  private startPerformanceMonitoring(): void {\n    if (this.monitoringInterval !== null) {\n      return; // Already monitoring\n    }\n\n    let lastFrameTime = performance.now();\n    let frameCount = 0;\n\n    // FPS monitoring function\n    const measureFps = () => {\n      frameCount++;\n      const now = performance.now();\n      const elapsed = now - lastFrameTime;\n\n      if (elapsed >= 1000) {\n        const currentFps = Math.round((frameCount * 1000) / elapsed);\n        this.performanceState.currentFps = currentFps;\n        this.performanceState.fpsHistory.push(currentFps);\n\n        // Keep only the last 10 measurements\n        if (this.performanceState.fpsHistory.length > 10) {\n          this.performanceState.fpsHistory.shift();\n        }\n\n        frameCount = 0;\n        lastFrameTime = now;\n      }\n\n      requestAnimationFrame(measureFps);\n    };\n\n    // Start measuring FPS\n    requestAnimationFrame(measureFps);\n\n    // Start the periodic quality adjustment check\n    this.monitoringInterval = window.setInterval(() => {\n      this.adjustQualityIfNeeded();\n    }, this.config.performanceCheckInterval);\n  }\n\n  /**\n   * Stop performance monitoring\n   */\n  private stopPerformanceMonitoring(): void {\n    if (this.monitoringInterval !== null) {\n      clearInterval(this.monitoringInterval);\n      this.monitoringInterval = null;\n    }\n  }\n\n  /**\n   * Set up listeners for system events that might affect performance\n   */\n  private setupSystemEventListeners(): void {\n    // Listen for reduced motion preference\n    if (this.config.respectPrefersReducedMotion) {\n      const motionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n\n      const handleMotionChange = (e: MediaQueryListEvent | MediaQueryList) => {\n        if (e.matches) {\n          // User prefers reduced motion, force lower quality\n          this.setQualityTier('low');\n        } else {\n          // User doesn't prefer reduced motion, redetect optimal quality\n          this.setQualityTier(this.detectOptimalQualityTier());\n        }\n      };\n\n      // Check initial state\n      handleMotionChange(motionQuery);\n\n      // Listen for changes\n      if (typeof motionQuery.addEventListener === 'function') {\n        motionQuery.addEventListener('change', handleMotionChange);\n      } else if (typeof motionQuery.addListener === 'function') {\n        // Older browsers\n        motionQuery.addListener(handleMotionChange);\n      }\n    }\n\n    // Listen for visibility changes to adjust quality when tab becomes visible again\n    document.addEventListener('visibilitychange', () => {\n      if (document.visibilityState === 'visible') {\n        // Page is now visible, check if we need to adjust quality\n        this.adjustQualityIfNeeded();\n      }\n    });\n\n    // Listen for window resize events, which might affect performance\n    let resizeTimeout: number | null = null;\n    window.addEventListener('resize', () => {\n      if (resizeTimeout !== null) {\n        clearTimeout(resizeTimeout);\n      }\n\n      // Debounce resize events\n      resizeTimeout = window.setTimeout(() => {\n        this.adjustQualityIfNeeded();\n        resizeTimeout = null;\n      }, 500);\n    });\n  }\n\n  /**\n   * Adjust quality settings if needed based on performance\n   */\n  private adjustQualityIfNeeded(): void {\n    if (!this.config.enableAutoAdjustment || this.performanceState.isAdjusting) {\n      return;\n    }\n\n    this.performanceState.isAdjusting = true;\n\n    try {\n      // Get average FPS from recent history\n      const avgFps =\n        this.performanceState.fpsHistory.length > 0\n          ? this.performanceState.fpsHistory.reduce((sum, fps) => sum + fps, 0) /\n            this.performanceState.fpsHistory.length\n          : this.performanceState.currentFps;\n\n      const currentTierIndex = this.getTierIndex(this.performanceState.currentTier);\n      const minAcceptableFps = this.config.minAcceptableFps || 30;\n\n      // Check if we need to adjust quality\n      if (avgFps < minAcceptableFps && currentTierIndex > 0) {\n        // Performance is poor, reduce quality\n        const newTier = this.getTierByIndex(currentTierIndex - 1);\n        this.setQualityTier(newTier);\n\n        if (this.config.debugMode) {\n          console.warn(`Reducing quality to ${newTier} due to low FPS (${avgFps.toFixed(1)})`);\n        }\n      } else if (avgFps > minAcceptableFps * 1.5 && currentTierIndex < 4) {\n        // Performance is good, we might be able to increase quality\n        // But do this cautiously and less frequently\n\n        const timeSinceLastAdjustment =\n          performance.now() - this.performanceState.lastAdjustmentTime;\n        const requiredTimeBetweenUpgrades = 30000; // 30 seconds between upgrades\n\n        if (timeSinceLastAdjustment > requiredTimeBetweenUpgrades) {\n          const newTier = this.getTierByIndex(currentTierIndex + 1);\n          this.setQualityTier(newTier);\n\n          if (this.config.debugMode) {\n            console.warn(`Increasing quality to ${newTier} due to good FPS (${avgFps.toFixed(1)})`);\n          }\n        }\n      }\n    } finally {\n      this.performanceState.isAdjusting = false;\n    }\n  }\n\n  /**\n   * Get the index of a quality tier\n   */\n  private getTierIndex(tier: PerformanceTier): number {\n    const tiers: PerformanceTier[] = ['minimal', 'low', 'medium', 'high', 'ultra'];\n    return tiers.indexOf(tier);\n  }\n\n  /**\n   * Get a quality tier by index\n   */\n  private getTierByIndex(index: number): PerformanceTier {\n    const tiers: PerformanceTier[] = ['minimal', 'low', 'medium', 'high', 'ultra'];\n    return tiers[Math.max(0, Math.min(tiers.length - 1, index))];\n  }\n\n  /**\n   * Set quality tier\n   */\n  public setQualityTier(tier: PerformanceTier): void {\n    // Update the current tier\n    this.performanceState.currentTier = tier;\n\n    // Get the preset for this tier\n    const presetSettings = this.qualityPresets[tier];\n\n    // Apply user overrides\n    this.currentSettings = {\n      ...presetSettings,\n      ...this.userOverrides,\n    };\n\n    // Apply the new settings to all registered animations\n    this.applyQualitySettingsToAnimations();\n\n    // Save settings if persistence is enabled\n    if (this.config.persistSettings) {\n      this.saveSettings();\n    }\n\n    // Update last adjustment time\n    this.performanceState.lastAdjustmentTime = performance.now();\n    this.performanceState.adjustmentCount++;\n  }\n\n  /**\n   * Apply current quality settings to all registered animations\n   */\n  private applyQualitySettingsToAnimations(): void {\n    // Notify all registered animations of quality changes\n    this.qualityChangeCallbacks.forEach((callback, animationId) => {\n      try {\n        // Apply global settings with any animation-specific overrides\n        const animationSettings = {\n          ...this.currentSettings,\n          ...(this.animationQualityOverrides.get(animationId) || {}),\n        };\n\n        callback(animationSettings);\n      } catch (err) {\n        console.error(`Error applying quality settings to animation ${animationId}:`, err);\n      }\n    });\n  }\n\n  /**\n   * Register an animation for quality management\n   */\n  public registerAnimation(\n    animationId: string,\n    onQualityChange: (settings: QualitySettings) => void,\n    animationSpecificOverrides?: Partial<QualitySettings>\n  ): void {\n    // Store the callback\n    this.qualityChangeCallbacks.set(animationId, onQualityChange);\n\n    // Store any animation-specific overrides\n    if (animationSpecificOverrides) {\n      this.animationQualityOverrides.set(animationId, animationSpecificOverrides);\n    }\n\n    // Initialize FPS tracking for this animation\n    this.animationFpsTracking.set(animationId, []);\n\n    // Apply current settings immediately\n    const settings = {\n      ...this.currentSettings,\n      ...(animationSpecificOverrides || {}),\n    };\n\n    onQualityChange(settings);\n  }\n\n  /**\n   * Unregister an animation\n   */\n  public unregisterAnimation(animationId: string): void {\n    this.qualityChangeCallbacks.delete(animationId);\n    this.animationQualityOverrides.delete(animationId);\n    this.animationFpsTracking.delete(animationId);\n  }\n\n  /**\n   * Update FPS for a specific animation\n   */\n  public updateAnimationFps(animationId: string, fps: number): void {\n    const fpsHistory = this.animationFpsTracking.get(animationId);\n    if (fpsHistory) {\n      fpsHistory.push(fps);\n\n      // Keep only the last 10 measurements\n      if (fpsHistory.length > 10) {\n        fpsHistory.shift();\n      }\n    }\n  }\n\n  /**\n   * Set user preference override for specific settings\n   */\n  public setUserPreference(settingKey: keyof QualitySettings, value: unknown): void {\n    this.userOverrides[settingKey] = value;\n\n    // Apply the change immediately\n    this.currentSettings = {\n      ...this.qualityPresets[this.performanceState.currentTier],\n      ...this.userOverrides,\n    };\n\n    // Apply to all animations\n    this.applyQualitySettingsToAnimations();\n\n    // Save settings if persistence is enabled\n    if (this.config.persistSettings) {\n      this.saveSettings();\n    }\n  }\n\n  /**\n   * Clears all user preference overrides\n   */\n  public clearUserPreferences(): void {\n    this.userOverrides = {};\n\n    // Reapply preset settings\n    this.currentSettings = this.qualityPresets[this.performanceState.currentTier];\n\n    // Apply to all animations\n    this.applyQualitySettingsToAnimations();\n\n    // Save settings if persistence is enabled\n    if (this.config.persistSettings) {\n      this.saveSettings();\n    }\n  }\n\n  /**\n   * Save settings to localStorage\n   */\n  private saveSettings(): void {\n    try {\n      const settingsToSave = {\n        qualityTier: this.performanceState.currentTier,\n        userOverrides: this.userOverrides,\n      };\n\n      localStorage.setItem('d3-animation-quality-settings', JSON.stringify(settingsToSave));\n    } catch (err) {\n      console.error('Error saving animation quality settings:', err);\n    }\n  }\n\n  /**\n   * Load saved settings from localStorage\n   */\n  private loadSavedSettings(): void {\n    try {\n      const savedSettings = localStorage.getItem('d3-animation-quality-settings');\n\n      if (savedSettings) {\n        const parsed = JSON.parse(savedSettings);\n\n        // Apply saved tier if it exists\n        if (parsed.qualityTier && typeof parsed.qualityTier === 'string') {\n          this.performanceState.currentTier = parsed.qualityTier as PerformanceTier;\n        }\n\n        // Apply saved user overrides\n        if (parsed.userOverrides && typeof parsed.userOverrides === 'object') {\n          this.userOverrides = parsed.userOverrides;\n        }\n      }\n    } catch (err) {\n      console.error('Error loading animation quality settings:', err);\n    }\n  }\n\n  /**\n   * Get current quality settings\n   */\n  public getCurrentSettings(): QualitySettings {\n    return { ...this.currentSettings };\n  }\n\n  /**\n   * Get current performance state\n   */\n  public getPerformanceState(): Readonly<PerformanceState> {\n    return { ...this.performanceState };\n  }\n\n  /**\n   * Get detected device capabilities\n   */\n  public getDeviceCapabilities(): Readonly<DeviceCapabilities> {\n    return { ...this.performanceState.detectedCapabilities };\n  }\n\n  /**\n   * Enable or disable auto-adjustment\n   */\n  public setAutoAdjustment(enabled: boolean): void {\n    this.config.enableAutoAdjustment = enabled;\n\n    if (enabled && this.monitoringInterval === null) {\n      this.startPerformanceMonitoring();\n    } else if (!enabled && this.monitoringInterval !== null) {\n      this.stopPerformanceMonitoring();\n    }\n  }\n}\n\n// Singleton instance for easier access\nexport const animationQualityManager = new D3AnimationQualityManager();\n\n/**\n * Helper to create a quality-adaptive D3 visualization\n */\nexport function createQualityAdaptiveVisualization<GElement extends Element = SVGSVGElement>(\n  selector: string | GElement,\n  animationId: string,\n  setup: (\n    container: d3.Selection<GElement, unknown, null, undefined>,\n    settings: QualitySettings\n  ) => void,\n  qualityOverrides?: Partial<QualitySettings>\n): d3.Selection<GElement, unknown, null, undefined> {\n  // Select the container element\n  const selection = d3.select(selector) as d3.Selection<GElement, unknown, null, undefined>;\n\n  // Register with the quality manager\n  animationQualityManager.registerAnimation(\n    animationId,\n    settings => {\n      // Clear previous content\n      selection.selectAll('*').remove();\n\n      // Set up visualization with current quality settings\n      setup(selection, settings);\n    },\n    qualityOverrides\n  );\n\n  return selection;\n}\n\n/**\n * Create quality-adaptive D3 transitions\n */\nexport function createQualityAdaptiveTransition<\n  GElement extends Element,\n  Datum,\n  PElement extends Element,\n  PDatum,\n>(\n  selection: d3.Selection<GElement, Datum, PElement, PDatum>,\n  duration?: number\n): d3.Transition<GElement, Datum, PElement, PDatum> {\n  const settings = animationQualityManager.getCurrentSettings();\n\n  // Adjust duration based on quality settings\n  let adjustedDuration = duration;\n  if (duration !== undefined) {\n    // Scale duration by animation step factor\n    // If animationStepFactor is 2, transitions will take twice as long but use half as many frames\n    adjustedDuration = duration * settings.animationStepFactor;\n  }\n\n  // Create transition with quality-appropriate settings\n  const transition = selection.transition().duration(adjustedDuration);\n\n  // If precise timing isn't needed, use a more efficient easing function\n  if (!settings.preciseTiming) {\n    transition.ease(d3.easeLinear); // Linear is most efficient\n  }\n\n  return transition;\n}\n\n/**\n * Helper to create a quality-adaptive data binding\n */\nexport function bindDataWithQualityAdjustment<\n  GElement extends Element,\n  OldDatum,\n  NewDatum,\n  PElement extends Element,\n  PDatum,\n>(\n  selection: d3.Selection<GElement, OldDatum, PElement, PDatum>,\n  data: NewDatum[],\n  key?: (d: NewDatum, i: number, data: NewDatum[]) => string\n): d3.Selection<GElement, NewDatum, PElement, PDatum> {\n  const settings = animationQualityManager.getCurrentSettings();\n\n  // If we need to reduce the number of elements for performance reasons\n  const maxElements = settings.maxElementCount;\n  let limitedData = data;\n\n  if (data.length > maxElements) {\n    // Limit the number of elements based on quality settings\n    limitedData = data.slice(0, maxElements);\n  }\n\n  // Bind the data, potentially with a key function\n  return key ? selection.data(limitedData, key) : selection.data(limitedData);\n}\n\n/**\n * Helper to create a quality-adaptive simulation\n */\nexport function createQualityAdaptiveSimulation<NodeDatum extends d3.SimulationNodeDatum>(\n  nodes: NodeDatum[]\n): d3.Simulation<NodeDatum, undefined> {\n  const settings = animationQualityManager.getCurrentSettings();\n\n  // Create simulation with quality-adaptive settings\n  const simulation = d3.forceSimulation<NodeDatum>().nodes(nodes);\n\n  // Adjust simulation parameters based on quality settings\n  const alphaDecay = settings.physicsDetail < 0.5 ? 0.1 : 0.02; // Faster convergence for low quality\n  const velocityDecay = settings.physicsDetail < 0.5 ? 0.5 : 0.4; // More damping for low quality\n  const iterations = Math.max(1, Math.round(settings.physicsDetail * 4)); // Fewer iterations for low quality\n\n  simulation.alphaDecay(alphaDecay).velocityDecay(velocityDecay).alphaTarget(0).alphaMin(0.001);\n\n  // Set tick iterations based on quality\n  if (typeof simulation.tick === 'function') {\n    const originalTick = simulation.tick;\n    simulation.tick = function () {\n      for (let i = 0; i < iterations; i++) {\n        originalTick.call(this);\n      }\n      return this;\n    };\n  }\n\n  return simulation;\n}\n\n/**\n * Helper to create a quality-adaptive interpolator\n */\nexport function createQualityAdaptiveInterpolator<T>(\n  a: T,\n  b: T,\n  interpolatorFactory: (a: T, b: T) => (t: number) => T = d3.interpolate\n): (t: number) => T {\n  const settings = animationQualityManager.getCurrentSettings();\n  const baseInterpolator = interpolatorFactory(a, b);\n\n  // For high quality settings, use the full interpolator\n  if (settings.interpolationSteps >= 60) {\n    return baseInterpolator;\n  }\n\n  // For lower quality, create a stepped interpolator with fewer intermediate values\n  return (t: number) => {\n    // Quantize the t value to reduce the number of unique outputs\n    const steps = settings.interpolationSteps;\n    const steppedT = Math.round(t * steps) / steps;\n    return baseInterpolator(steppedT);\n  };\n}\n\n/**\n * React hook for using quality-adaptive D3 visualizations\n */\nexport function useQualityAdaptiveD3(\n  animationId: string,\n  qualityOverrides?: Partial<QualitySettings>\n) {\n  const [qualitySettings, setQualitySettings] = React.useState<QualitySettings>(\n    animationQualityManager.getCurrentSettings()\n  );\n\n  React.useEffect(() => {\n    // Register with quality manager\n    animationQualityManager.registerAnimation(\n      animationId,\n      newSettings => {\n        setQualitySettings(newSettings);\n      },\n      qualityOverrides\n    );\n\n    // Unregister on cleanup\n    return () => {\n      animationQualityManager.unregisterAnimation(animationId);\n    };\n  }, [animationId, qualityOverrides]);\n\n  return qualitySettings;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/performance/D3BatchedUpdates.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 611,
        "column": 46,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 611,
        "endColumn": 49,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [17752, 17755], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [17752, 17755], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * D3 Batched Updates System\n *\n * This module provides utilities for batching multiple DOM updates into a single render cycle,\n * reducing layout thrashing and improving animation performance. Key features include:\n *\n * 1. Update batching across multiple animations and selections\n * 2. Prioritized update scheduling based on visibility and importance\n * 3. DOM read/write separation to prevent layout thrashing\n * 4. Automatic microtask scheduling for optimal performance\n * 5. Integration with existing animation frame manager\n */\n\nimport * as d3 from 'd3';\nimport { animationFrameManager, AnimationPriority } from './D3AnimationFrameManager';\n\n/**\n * Type for DOM operations that need to be scheduled together\n */\ntype BatchOperation = {\n  /** Operation type - read operations execute before write operations */\n  type: 'read' | 'write';\n  /** The operation's unique ID */\n  id: string;\n  /** The callback function to execute */\n  callback: () => void;\n  /** Priority level for the operation */\n  priority: BatchOperationPriority;\n  /** When the operation was scheduled (for ordering operations with same priority) */\n  timestamp: number;\n  /** Element the operation is associated with (for grouping) */\n  element?: Element;\n  /** Animation ID this operation is associated with (for grouping) */\n  animationId?: string;\n};\n\n/**\n * Priority levels for batch operations\n */\nexport type BatchOperationPriority = 'critical' | 'high' | 'normal' | 'low' | 'idle';\n\n/**\n * Scheduling mode for batched updates\n */\nexport type BatchSchedulingMode = 'immediate' | 'animation-frame' | 'microtask' | 'idle-callback';\n\n/**\n * Configuration options for the batch update system\n */\nexport interface BatchSystemConfig {\n  /** Default scheduling mode */\n  defaultSchedulingMode?: BatchSchedulingMode;\n  /** Whether to automatically optimize the scheduling mode based on browser conditions */\n  autoOptimize?: boolean;\n  /** Maximum operations to process per batch before forcing a flush */\n  maxOperationsPerBatch?: number;\n  /** Whether to separate read and write operations to prevent layout thrashing */\n  separateReadsWrites?: boolean;\n  /** Whether to group operations by element */\n  groupByElement?: boolean;\n  /** Whether to enable debug logging */\n  debugMode?: boolean;\n}\n\n/**\n * Options for batched operations\n */\nexport interface BatchOperationOptions {\n  /** Operation priority */\n  priority?: BatchOperationPriority;\n  /** Element the operation is associated with */\n  element?: Element;\n  /** Animation ID this operation is associated with */\n  animationId?: string;\n  /** Scheduling mode for this operation */\n  schedulingMode?: BatchSchedulingMode;\n  /** Custom ID for the operation (for deduplication) */\n  id?: string;\n}\n\n/**\n * Options for flushing batched operations\n */\nexport interface FlushOptions {\n  /** Only flush operations for a specific element */\n  forElement?: Element;\n  /** Only flush operations for a specific animation */\n  forAnimation?: string;\n  /** Only flush operations with priority >= the specified level */\n  minPriority?: BatchOperationPriority;\n  /** Only flush read operations */\n  readOnly?: boolean;\n  /** Only flush write operations */\n  writeOnly?: boolean;\n}\n\n/**\n * Stateful batch update manager for D3 animations\n */\nexport class D3BatchUpdateManager {\n  /** Queue of pending read operations */\n  private readQueue: BatchOperation[] = [];\n\n  /** Queue of pending write operations */\n  private writeQueue: BatchOperation[] = [];\n\n  /** Whether a batch flush is scheduled */\n  private flushScheduled = false;\n\n  /** Current batch ID for tracking which batch operations belong to */\n  private currentBatchId = 0;\n\n  /** Whether the system is currently flushing operations */\n  private isFlushing = false;\n\n  /** Completed operation count for statistics */\n  private completedOperations = 0;\n\n  /** Map of operation IDs to avoid duplicates */\n  private operationIds = new Set<string>();\n\n  /** Priority order for sorting operations */\n  private priorityOrder: Record<BatchOperationPriority, number> = {\n    critical: 0,\n    high: 1,\n    normal: 2,\n    low: 3,\n    idle: 4,\n  };\n\n  /**\n   * Create a new batch update manager\n   */\n  constructor(private config: BatchSystemConfig = {}) {\n    this.config = {\n      defaultSchedulingMode: 'microtask',\n      autoOptimize: true,\n      maxOperationsPerBatch: 100,\n      separateReadsWrites: true,\n      groupByElement: true,\n      debugMode: false,\n      ...config,\n    };\n  }\n\n  /**\n   * Determine the best scheduling mode based on browser conditions\n   */\n  private determineBestSchedulingMode(): BatchSchedulingMode {\n    if (!this.config.autoOptimize) {\n      return this.config.defaultSchedulingMode!;\n    }\n\n    // Use immediate mode for small batches or if we're already in a requestAnimationFrame\n    if (this.getTotalPendingOperations() < 10) {\n      return 'immediate';\n    }\n\n    // Use requestAnimationFrame for larger batches\n    if (this.getTotalPendingOperations() >= 10 && this.getTotalPendingOperations() < 50) {\n      return 'animation-frame';\n    }\n\n    // Use idle callback for background operations if available\n    if (\n      typeof window.requestIdleCallback === 'function' &&\n      this.readQueue.every(op => op.priority === 'idle' || op.priority === 'low') &&\n      this.writeQueue.every(op => op.priority === 'idle' || op.priority === 'low')\n    ) {\n      return 'idle-callback';\n    }\n\n    // Default to microtask for most cases\n    return 'microtask';\n  }\n\n  /**\n   * Schedule a batch flush with the appropriate timing\n   */\n  private scheduleFlush(mode?: BatchSchedulingMode): void {\n    if (this.flushScheduled) return;\n\n    this.flushScheduled = true;\n    const schedulingMode = mode || this.determineBestSchedulingMode();\n\n    switch (schedulingMode) {\n      case 'immediate':\n        this.flush();\n        break;\n\n      case 'animation-frame':\n        requestAnimationFrame(() => this.flush());\n        break;\n\n      case 'microtask':\n        Promise.resolve().then(() => this.flush());\n        break;\n\n      case 'idle-callback':\n        if (typeof window.requestIdleCallback === 'function') {\n          window.requestIdleCallback(\n            deadline => {\n              const timeRemaining = deadline.timeRemaining();\n              // Only process if we have enough time\n              if (timeRemaining > 10 || deadline.didTimeout) {\n                this.flush();\n              } else {\n                // If not enough time, reschedule with animation frame\n                this.flushScheduled = false;\n                this.scheduleFlush('animation-frame');\n              }\n            },\n            { timeout: 100 }\n          ); // Give it a reasonable timeout\n        } else {\n          // Fall back to requestAnimationFrame if requestIdleCallback is not available\n          requestAnimationFrame(() => this.flush());\n        }\n        break;\n    }\n  }\n\n  /**\n   * Flush all pending operations\n   */\n  private flush(options?: FlushOptions): void {\n    this.isFlushing = true;\n    this.flushScheduled = false;\n\n    // Track the current batch\n    const batchId = this.currentBatchId++;\n\n    // Filter operations based on options\n    const filterOperation = (op: BatchOperation): boolean => {\n      if (options?.forElement && op.element !== options.forElement) return false;\n      if (options?.forAnimation && op.animationId !== options.forAnimation) return false;\n      if (\n        options?.minPriority &&\n        this.priorityOrder[op.priority] > this.priorityOrder[options.minPriority]\n      )\n        return false;\n      return true;\n    };\n\n    // Get operations to flush\n    const readOps = options?.writeOnly ? [] : this.readQueue.filter(filterOperation);\n    const writeOps = options?.readOnly ? [] : this.writeQueue.filter(filterOperation);\n\n    // Sort operations by priority and timestamp\n    const sortOperations = (a: BatchOperation, b: BatchOperation) => {\n      if (a.priority !== b.priority) {\n        return this.priorityOrder[a.priority] - this.priorityOrder[b.priority];\n      }\n      return a.timestamp - b.timestamp;\n    };\n\n    readOps.sort(sortOperations);\n    writeOps.sort(sortOperations);\n\n    // Remember operations we're going to process\n    const readOpsToProcess = readOps;\n    const writeOpsToProcess = writeOps;\n\n    // Remove operations we're about to process from the queues\n    this.readQueue = this.readQueue.filter(op => !readOpsToProcess.includes(op));\n    this.writeQueue = this.writeQueue.filter(op => !writeOpsToProcess.includes(op));\n\n    try {\n      // Process read operations first to prevent layout thrashing\n      readOpsToProcess.forEach(op => {\n        try {\n          op.callback();\n          this.completedOperations++;\n        } catch (err) {\n          console.error(`Error in read operation ${op.id}:`, err);\n        }\n      });\n\n      // Then process write operations\n      writeOpsToProcess.forEach(op => {\n        try {\n          op.callback();\n          this.completedOperations++;\n        } catch (err) {\n          console.error(`Error in write operation ${op.id}:`, err);\n        }\n      });\n    } finally {\n      this.isFlushing = false;\n\n      // Clear processed operation IDs\n      readOpsToProcess.concat(writeOpsToProcess).forEach(op => {\n        this.operationIds.delete(op.id);\n      });\n    }\n\n    // If there are still operations pending, schedule another flush\n    if (this.getTotalPendingOperations() > 0) {\n      this.scheduleFlush();\n    }\n\n    if (this.config.debugMode) {\n      console.warn(\n        `Batch #${batchId} processed: ${readOpsToProcess.length} reads, ${writeOpsToProcess.length} writes`\n      );\n    }\n  }\n\n  /**\n   * Get the total number of pending operations\n   */\n  private getTotalPendingOperations(): number {\n    return this.readQueue.length + this.writeQueue.length;\n  }\n\n  /**\n   * Add a read operation to the batch queue\n   */\n  public read<T>(callback: () => T, options: BatchOperationOptions = {}): T | undefined {\n    return this.addOperation('read', callback, options);\n  }\n\n  /**\n   * Add a write operation to the batch queue\n   */\n  public write<T>(callback: () => T, options: BatchOperationOptions = {}): T | undefined {\n    return this.addOperation('write', callback, options);\n  }\n\n  /**\n   * Add an operation to the appropriate queue\n   */\n  private addOperation<T>(\n    type: 'read' | 'write',\n    callback: () => T,\n    options: BatchOperationOptions\n  ): T | undefined {\n    const { priority = 'normal', element, animationId, schedulingMode, id: customId } = options;\n\n    // Generate a unique ID for the operation\n    const baseId = customId || `${type}-${Date.now()}-${Math.round(Math.random() * 10000)}`;\n\n    // For element-specific operations, make the ID element-specific to enable deduplication\n    const id = element ? `${baseId}-${element.tagName}-${priority}` : baseId;\n\n    // Skip if this exact operation was already scheduled (deduplication)\n    if (this.operationIds.has(id)) {\n      if (this.config.debugMode) {\n        console.warn(`Skipping duplicate operation ${id}`);\n      }\n      return undefined;\n    }\n\n    // If we're already flushing and this is an immediate operation, execute it directly\n    if (this.isFlushing && schedulingMode === 'immediate') {\n      try {\n        return callback();\n      } catch (err) {\n        console.error(`Error in immediate ${type} operation:`, err);\n        return undefined;\n      }\n    }\n\n    // Create the operation\n    const operation: BatchOperation = {\n      type,\n      id,\n      callback: () => callback(),\n      priority,\n      timestamp: Date.now(),\n      element,\n      animationId,\n    };\n\n    // Add to the appropriate queue\n    if (type === 'read') {\n      this.readQueue.push(operation);\n    } else {\n      this.writeQueue.push(operation);\n    }\n\n    // Record the operation ID\n    this.operationIds.add(id);\n\n    // Schedule a flush if needed\n    if (!this.flushScheduled) {\n      this.scheduleFlush(schedulingMode);\n    } else if (priority === 'critical' && schedulingMode === 'immediate') {\n      // Force an immediate flush for critical operations\n      this.flush({\n        minPriority: 'critical',\n      });\n    }\n\n    // For immediate operations, we can return the result\n    if (schedulingMode === 'immediate') {\n      return callback();\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Manually flush all pending operations\n   */\n  public flushAll(): void {\n    this.flush();\n  }\n\n  /**\n   * Manually flush operations for a specific element\n   */\n  public flushForElement(element: Element): void {\n    this.flush({ forElement: element });\n  }\n\n  /**\n   * Manually flush operations for a specific animation\n   */\n  public flushForAnimation(animationId: string): void {\n    this.flush({ forAnimation: animationId });\n  }\n\n  /**\n   * Get statistics about the batch manager\n   */\n  public getStats() {\n    return {\n      pendingReads: this.readQueue.length,\n      pendingWrites: this.writeQueue.length,\n      totalPending: this.getTotalPendingOperations(),\n      completedOperations: this.completedOperations,\n      isFlushing: this.isFlushing,\n      flushScheduled: this.flushScheduled,\n      batchCount: this.currentBatchId,\n    };\n  }\n\n  /**\n   * Cancel all pending operations\n   */\n  public cancelAll(): void {\n    this.readQueue = [];\n    this.writeQueue = [];\n    this.operationIds.clear();\n    this.flushScheduled = false;\n  }\n}\n\n/**\n * Singleton instance for easy access\n */\nexport const batchUpdateManager = new D3BatchUpdateManager();\n\n/**\n * Helper to batch read operations related to DOM measurements\n */\nexport function batchRead<T>(\n  callback: () => T,\n  options: BatchOperationOptions = {}\n): T | undefined {\n  return batchUpdateManager.read(callback, options);\n}\n\n/**\n * Helper to batch write operations related to DOM modifications\n */\nexport function batchWrite<T>(\n  callback: () => T,\n  options: BatchOperationOptions = {}\n): T | undefined {\n  return batchUpdateManager.write(callback, options);\n}\n\n/**\n * Creates optimized D3 selection methods that use batched updates\n */\nexport function createBatchedSelection<\n  GElement extends Element,\n  Datum,\n  PElement extends Element,\n  PDatum,\n>(\n  selection: d3.Selection<GElement, Datum, PElement, PDatum>,\n  options: BatchOperationOptions = {}\n): d3.Selection<GElement, Datum, PElement, PDatum> {\n  // Clone the selection to avoid modifying the original\n  const batchedSelection = selection.clone() as d3.Selection<GElement, Datum, PElement, PDatum>;\n\n  // Store original methods\n  const originalAttr = batchedSelection.attr;\n  const originalStyle = batchedSelection.style;\n  const originalProperty = batchedSelection.property;\n  const originalHtml = batchedSelection.html;\n  const originalText = batchedSelection.text;\n\n  // Override attr to use batched writes\n  batchedSelection.attr = function (...args: unknown[]): unknown {\n    if (args.length === 1) {\n      // Read operation - needs to execute right away to return the value\n      return originalAttr.apply(this, args);\n    }\n\n    // Write operation - can be batched\n    batchWrite(\n      () => {\n        originalAttr.apply(batchedSelection, args);\n      },\n      {\n        ...options,\n        element: (batchedSelection.node() as Element) || undefined,\n      }\n    );\n\n    return batchedSelection;\n  } as unknown;\n\n  // Override style to use batched writes\n  batchedSelection.style = function (...args: unknown[]): unknown {\n    if (args.length === 1) {\n      // Read operation - needs to execute right away to return the value\n      return originalStyle.apply(this, args);\n    }\n\n    // Write operation - can be batched\n    batchWrite(\n      () => {\n        originalStyle.apply(batchedSelection, args);\n      },\n      {\n        ...options,\n        element: (batchedSelection.node() as Element) || undefined,\n      }\n    );\n\n    return batchedSelection;\n  } as unknown;\n\n  // Override property to use batched writes\n  batchedSelection.property = function (...args: unknown[]): unknown {\n    if (args.length === 1) {\n      // Read operation - needs to execute right away to return the value\n      return originalProperty.apply(this, args);\n    }\n\n    // Write operation - can be batched\n    batchWrite(\n      () => {\n        originalProperty.apply(batchedSelection, args);\n      },\n      {\n        ...options,\n        element: (batchedSelection.node() as Element) || undefined,\n      }\n    );\n\n    return batchedSelection;\n  } as unknown;\n\n  // Override html to use batched writes\n  batchedSelection.html = function (...args: unknown[]): unknown {\n    if (args.length === 0) {\n      // Read operation - needs to execute right away to return the value\n      return originalHtml.apply(this, args);\n    }\n\n    // Write operation - can be batched\n    batchWrite(\n      () => {\n        originalHtml.apply(batchedSelection, args);\n      },\n      {\n        ...options,\n        element: (batchedSelection.node() as Element) || undefined,\n      }\n    );\n\n    return batchedSelection;\n  } as unknown;\n\n  // Override text to use batched writes\n  batchedSelection.text = function (...args: unknown[]): unknown {\n    if (args.length === 0) {\n      // Read operation - needs to execute right away to return the value\n      return originalText.apply(this, args);\n    }\n\n    // Write operation - can be batched\n    batchWrite(\n      () => {\n        originalText.apply(batchedSelection, args);\n      },\n      {\n        ...options,\n        element: (batchedSelection.node() as Element) || undefined,\n      }\n    );\n\n    return batchedSelection;\n  } as unknown;\n\n  return batchedSelection;\n}\n\n/**\n * Enhances a D3 selection factory function to use batched updates\n */\nexport function createBatchedSelectionFactory<GElement extends Element = HTMLElement>(\n  options: BatchOperationOptions = {}\n) {\n  return function selectWithBatching<Datum = any>(\n    selector: string | GElement\n  ): d3.Selection<GElement, Datum, null, undefined> {\n    const selection = d3.select(selector) as d3.Selection<GElement, Datum, null, undefined>;\n    return createBatchedSelection(selection, options);\n  };\n}\n\n/**\n * Enhances D3 transitions with batched updates\n */\nexport function createBatchedTransition<\n  GElement extends Element,\n  Datum,\n  PElement extends Element,\n  PDatum,\n>(\n  selection: d3.Selection<GElement, Datum, PElement, PDatum>,\n  options: BatchOperationOptions = {}\n): d3.Selection<GElement, Datum, PElement, PDatum> {\n  // Store original transition method\n  const originalTransition = selection.transition;\n\n  // Override transition to batch operations\n  selection.transition = function (...args: unknown[]): unknown {\n    const transition = originalTransition.apply(this, args);\n\n    // Store original methods\n    const originalAttr = transition.attr;\n    const originalStyle = transition.style;\n\n    // Override attr to use batched writes\n    transition.attr = function (name: string, value?: unknown): unknown {\n      if (arguments.length === 1) {\n        return originalAttr.call(this, name);\n      }\n\n      // Schedule the update to happen at each tick of the transition\n      const _originalTween = transition.attrTween;\n      transition.attrTween(\n        name,\n        function (\n          this: d3.Transition<GElement, Datum, PElement, PDatum>,\n          d: Datum,\n          i: number,\n          nodes: GElement[]\n        ) {\n          const node = nodes[i];\n          const interpolator =\n            typeof value === 'function'\n              ? d3.interpolate(originalAttr.call(d3.select(node), name), value(d, i, nodes))\n              : d3.interpolate(originalAttr.call(d3.select(node), name), value);\n\n          return function (t: number) {\n            const interpolated = interpolator(t);\n            // Batch the DOM update\n            batchWrite(\n              () => {\n                d3.select(node).attr(name, interpolated);\n              },\n              {\n                ...options,\n                element: node,\n                priority: t === 1 || t === 0 ? 'high' : 'normal', // Prioritize start and end values\n              }\n            );\n            return interpolated;\n          };\n        }\n      );\n\n      return this;\n    } as unknown;\n\n    // Override style to use batched writes\n    transition.style = function (name: string, value?: unknown, priority?: string): unknown {\n      if (arguments.length === 1) {\n        return originalStyle.call(this, name);\n      }\n\n      // Schedule the update to happen at each tick of the transition\n      const _originalTween = transition.styleTween;\n      transition.styleTween(\n        name,\n        function (\n          this: d3.Transition<GElement, Datum, PElement, PDatum>,\n          d: Datum,\n          i: number,\n          nodes: GElement[]\n        ) {\n          const node = nodes[i];\n          const interpolator =\n            typeof value === 'function'\n              ? d3.interpolate(originalStyle.call(d3.select(node), name), value(d, i, nodes))\n              : d3.interpolate(originalStyle.call(d3.select(node), name), value);\n\n          return function (t: number) {\n            const interpolated = interpolator(t);\n            // Batch the DOM update\n            batchWrite(\n              () => {\n                d3.select(node).style(name, interpolated, priority);\n              },\n              {\n                ...options,\n                element: node,\n                priority: t === 1 || t === 0 ? 'high' : 'normal', // Prioritize start and end values\n              }\n            );\n            return interpolated;\n          };\n        }\n      );\n\n      return this;\n    } as unknown;\n\n    return transition;\n  } as unknown;\n\n  return selection;\n}\n\n/**\n * Integrates batch update manager with the animation frame manager\n */\nexport function registerBatchUpdateSystem(\n  animationId: string,\n  priority: AnimationPriority = 'high'\n): void {\n  animationFrameManager.registerAnimation(\n    {\n      id: `batch-updater-${animationId}`,\n      name: 'Batch Update Processor',\n      priority,\n      type: 'custom',\n      duration: 0, // Runs indefinitely\n      loop: true,\n    },\n    (_elapsed, _deltaTime, frameInfo) => {\n      // Flush batched operations on each animation frame\n      // Use frame budget to determine how much we can process\n      if (frameInfo.remainingFrameBudget > 2) {\n        // Only flush if we have time left in the frame\n        batchUpdateManager.flushAll();\n      }\n\n      return false; // Never complete this animation\n    }\n  );\n\n  // Start the animation\n  animationFrameManager.startAnimation(`batch-updater-${animationId}`);\n}\n\n/**\n * Helper to optimize a D3 visualization with batched updates\n */\nexport function optimizeWithBatchedUpdates<\n  GElement extends Element,\n  Datum,\n  PElement extends Element,\n  PDatum,\n>(\n  selection: d3.Selection<GElement, Datum, PElement, PDatum>,\n  animationId: string,\n  options: BatchOperationOptions = {}\n): d3.Selection<GElement, Datum, PElement, PDatum> {\n  // Set up batching integration with animation frame manager\n  registerBatchUpdateSystem(animationId);\n\n  // Set up default options\n  const batchOptions: BatchOperationOptions = {\n    animationId,\n    priority: 'normal',\n    ...options,\n  };\n\n  // Apply batched selections\n  const batchedSelection = createBatchedSelection(selection, batchOptions);\n\n  // Apply batched transitions\n  const transitionSelection = createBatchedTransition(batchedSelection, batchOptions);\n\n  return transitionSelection;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/performance/D3InterpolationCache.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/performance/D3PerformanceOptimizations.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 164,
        "column": 86,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 164,
        "endColumn": 89,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5023, 5026], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5023, 5026], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * D3 Performance Optimizations\n *\n * This utility provides optimizations for D3 visualizations to address\n * common performance bottlenecks identified by the profiler.\n */\n\nimport * as d3 from 'd3';\nimport { memoizedD3Accessors } from './D3PerformanceProfiler';\n\n/**\n * Configuration options for D3 performance optimizations\n */\nexport interface PerformanceOptimizationConfig {\n  /** Whether to use memoized accessors */\n  useMemoizedAccessors: boolean;\n  /** Whether to use optimized simulation tick logic */\n  useOptimizedSimulation: boolean;\n  /** Whether to batch DOM updates */\n  useBatchedDOMUpdates: boolean;\n  /** Whether to use throttled rendering */\n  useThrottledRendering: boolean;\n  /** Minimum frame time in ms (for throttling) */\n  minFrameTimeMs: number;\n  /** Whether to use worker-based simulation */\n  useWorkerSimulation: boolean;\n}\n\n/**\n * Default optimization configuration\n */\nexport const defaultOptimizationConfig: PerformanceOptimizationConfig = {\n  useMemoizedAccessors: true,\n  useOptimizedSimulation: true,\n  useBatchedDOMUpdates: true,\n  useThrottledRendering: false,\n  minFrameTimeMs: 16, // ~60fps\n  useWorkerSimulation: false,\n};\n\n/**\n * Apply optimizations to a D3 force simulation\n *\n * @param simulation The simulation to optimize\n * @param config Optimization configuration\n */\nexport function optimizeForceSimulation(\n  simulation: d3.Simulation<d3.SimulationNodeDatum, undefined>,\n  config: Partial<PerformanceOptimizationConfig> = {}\n): void {\n  const mergedConfig = { ...defaultOptimizationConfig, ...config };\n\n  // Set optimal alpha decay for faster convergence\n  if (mergedConfig.useOptimizedSimulation) {\n    simulation.alphaDecay(0.03); // Faster convergence\n    simulation.alphaMin(0.001); // Stop at lower energy\n  }\n\n  // Optimize force distances based on node count\n  const nodeCount = simulation.nodes().length;\n  const linkForce = simulation.force('link');\n  const chargeForce = simulation.force('charge') as d3.ForceManyBody<d3.SimulationNodeDatum>;\n\n  if (linkForce && 'distance' in linkForce) {\n    // Adjust link distance based on node count\n    (linkForce as unknown).distance(nodeCount > 100 ? 30 : nodeCount > 50 ? 40 : 50);\n  }\n\n  if (chargeForce) {\n    // Adjust charge strength based on node count\n    const chargeStrength = nodeCount > 200 ? -30 : nodeCount > 100 ? -50 : -70;\n\n    chargeForce.strength(chargeStrength);\n\n    // Use theta for approximation in large simulations\n    if (nodeCount > 100) {\n      chargeForce.theta(0.9); // Higher theta = more approximation = faster but less accurate\n    }\n  }\n}\n\n/**\n * Create a throttled tick function for improved rendering performance\n *\n * @param simulation The simulation to optimize\n * @param tickCallback The function to call on each tick\n * @param config Optimization configuration\n * @returns A function to start/stop the optimized simulation\n */\nexport function createOptimizedTicker(\n  simulation: d3.Simulation<d3.SimulationNodeDatum, undefined>,\n  tickCallback: () => void,\n  config: Partial<PerformanceOptimizationConfig> = {}\n): { start: () => void; stop: () => void } {\n  const mergedConfig = { ...defaultOptimizationConfig, ...config };\n\n  let rafId: number | null = null;\n  let lastFrameTime = 0;\n\n  // Optimized ticker function\n  const ticker = () => {\n    const currentTime = performance.now();\n    const elapsed = currentTime - lastFrameTime;\n\n    // Run multiple simulation steps for complex simulations with throttled rendering\n    if (mergedConfig.useOptimizedSimulation) {\n      const iterations = Math.min(\n        4, // Max iterations per frame\n        Math.max(\n          1, // At least one iteration\n          Math.floor(elapsed / 8) // ~8ms per iteration target\n        )\n      );\n\n      // Run simulation steps\n      for (let i = 0; i < iterations; i++) {\n        simulation.tick();\n      }\n    } else {\n      // Standard single tick\n      simulation.tick();\n    }\n\n    // Throttle rendering for performance\n    if (!mergedConfig.useThrottledRendering || elapsed >= mergedConfig.minFrameTimeMs) {\n      tickCallback();\n      lastFrameTime = currentTime;\n    }\n\n    // Continue animation if simulation is still active\n    if (simulation.alpha() > simulation.alphaMin()) {\n      rafId = requestAnimationFrame(ticker);\n    } else {\n      // Ensure one final render when simulation ends\n      tickCallback();\n      rafId = null;\n    }\n  };\n\n  return {\n    start: () => {\n      if (rafId === null) {\n        lastFrameTime = performance.now();\n        simulation.alpha(1).restart();\n        rafId = requestAnimationFrame(ticker);\n      }\n    },\n    stop: () => {\n      if (rafId !== null) {\n        cancelAnimationFrame(rafId);\n        rafId = null;\n      }\n    },\n  };\n}\n\n/**\n * Optimize D3 selection updates for performance\n *\n * @param selection The D3 selection to optimize\n * @param updateFn The function that performs updates on the selection\n * @param config Optimization configuration\n */\nexport function optimizeSelectionUpdates<T extends d3.Selection<SVGElement, unknown, any, unknown>>(\n  selection: T,\n  updateFn: (selection: T) => void,\n  config: Partial<PerformanceOptimizationConfig> = {}\n): void {\n  const mergedConfig = { ...defaultOptimizationConfig, ...config };\n\n  if (mergedConfig.useBatchedDOMUpdates) {\n    // Temporarily detach elements from DOM for batch updates\n    // This only works for SVG elements that are already in the DOM\n    const parent = selection.node()?.parentNode;\n    const nextSibling = selection.node()?.nextSibling;\n\n    if (parent) {\n      const fragment = document.createDocumentFragment();\n      selection.each(function () {\n        fragment.appendChild(this);\n      });\n\n      // Apply updates to detached elements\n      updateFn(selection);\n\n      // Reattach elements\n      if (nextSibling) {\n        parent.insertBefore(fragment, nextSibling);\n      } else {\n        parent.appendChild(fragment);\n      }\n    } else {\n      // Fall back to normal updates if parent not found\n      updateFn(selection);\n    }\n  } else {\n    // Standard updates\n    updateFn(selection);\n  }\n}\n\n/**\n * Create a data structure index for faster lookups\n *\n * @param data Array of data items\n * @param keyFn (...args: unknown[]) => unknown to extract a key from each item\n * @returns An object mapping keys to data items\n */\nexport function createDataIndex<T>(data: T[], keyFn: (item: T) => string): Record<string, T> {\n  return data.reduce(\n    (index, item) => {\n      const key = keyFn(item);\n      index[key] = item;\n      return index;\n    },\n    {} as Record<string, T>\n  );\n}\n\n/**\n * Create an optimized D3 accessor function for node properties\n *\n * @param propName The property name to access\n * @param defaultValue Default value to return if property not found\n * @param useMemoized Whether to use memoization\n * @returns An accessor function for the specified property\n */\nexport function createOptimizedAccessor<T>(\n  propName: string,\n  defaultValue: T,\n  useMemoized = true\n): (node: unknown) => T {\n  // Use WeakMap for memoization if requested\n  const cache = new WeakMap<object, T>();\n\n  // Create the accessor function\n  const accessor = (node: unknown): T => {\n    if (!node || typeof node !== 'object') {\n      return defaultValue;\n    }\n\n    // Type-safe property access\n    return (node as unknown)[propName] !== undefined ? (node as unknown)[propName] : defaultValue;\n  };\n\n  // Return memoized version if requested\n  if (useMemoized) {\n    return (node: unknown): T => {\n      if (!node || typeof node !== 'object') {\n        return defaultValue;\n      }\n\n      // Check cache first\n      if (cache.has(node as object)) {\n        return cache.get(node as object) as T;\n      }\n\n      // Calculate and cache result\n      const result = accessor(node);\n      cache.set(node as object, result);\n      return result;\n    };\n  }\n\n  return accessor;\n}\n\n/**\n * Optimize node coordinates by pre-computing for the current frame\n *\n * @param nodes Array of simulation nodes\n * @returns Object with optimized coordinate getters\n */\nexport function createCoordinateCache(nodes: d3.SimulationNodeDatum[]): {\n  getX: (node: d3.SimulationNodeDatum) => number;\n  getY: (node: d3.SimulationNodeDatum) => number;\n} {\n  // Pre-compute and cache coordinates\n  const xCache = new Map<string, number>();\n  const yCache = new Map<string, number>();\n\n  // Populate caches\n  nodes.forEach(node => {\n    const id = (node as unknown).id || Math.random().toString();\n    xCache.set(id, memoizedD3Accessors.getX(node));\n    yCache.set(id, memoizedD3Accessors.getY(node));\n  });\n\n  return {\n    getX: (node: d3.SimulationNodeDatum): number => {\n      const id = (node as unknown).id || '';\n      return xCache.has(id) ? xCache.get(id) || 0 : memoizedD3Accessors.getX(node);\n    },\n    getY: (node: d3.SimulationNodeDatum): number => {\n      const id = (node as unknown).id || '';\n      return yCache.has(id) ? yCache.get(id) || 0 : memoizedD3Accessors.getY(node);\n    },\n  };\n}\n\n/**\n * Optimize data transformations by memoizing results\n *\n * @param transformFn The function that transforms the data\n * @returns A memoized version of the transform function\n */\nexport function memoizeTransform<T, R>(transformFn: (data: T) => R): (data: T) => R {\n  const cache = new Map<string, R>();\n\n  return (data: T): R => {\n    // Create a cache key based on JSON stringification\n    // Note: This assumes data is serializable and not too large\n    const key = JSON.stringify(data);\n\n    if (cache.has(key)) {\n      return cache.get(key) as R;\n    }\n\n    const result = transformFn(data);\n    cache.set(key, result);\n    return result;\n  };\n}\n\n/**\n * Apply all available performance optimizations to a D3 visualization\n *\n * @param simulation The force simulation to optimize\n * @param selectionUpdater (...args: unknown[]) => unknown that updates the visualization's DOM elements\n * @param config Optimization configuration\n * @returns Controls for the optimized simulation\n */\nexport function optimizeVisualization(\n  simulation: d3.Simulation<d3.SimulationNodeDatum, undefined>,\n  selectionUpdater: () => void,\n  config: Partial<PerformanceOptimizationConfig> = {}\n): { start: () => void; stop: () => void } {\n  const mergedConfig = { ...defaultOptimizationConfig, ...config };\n\n  // 1. Optimize the force simulation parameters\n  optimizeForceSimulation(simulation, mergedConfig);\n\n  // 2. Create optimized ticker with throttled rendering\n  const optimizedTicker = createOptimizedTicker(\n    simulation,\n    () => {\n      // Clear accessor caches on each frame\n      if (mergedConfig.useMemoizedAccessors) {\n        memoizedD3Accessors.clearAllCache();\n      }\n\n      // Call the selection updater function to render changes\n      selectionUpdater();\n    },\n    mergedConfig\n  );\n\n  return optimizedTicker;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/performance/D3PerformanceProfiler.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'totalDurationMs' is defined but never used. Allowed unused args must match /^_/u.",
        "line": 182,
        "column": 5,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 182,
        "endColumn": 20
      },
      {
        "ruleId": "@typescript-eslint/no-this-alias",
        "severity": 2,
        "message": "Unexpected aliasing of 'this' to local variable.",
        "line": 274,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "thisAssignment",
        "endLine": 274,
        "endColumn": 19
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'transform' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 539,
        "column": 17,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 539,
        "endColumn": 26
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'transform' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 555,
        "column": 17,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 555,
        "endColumn": 26
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * D3 Performance Profiler\n *\n * This utility provides tools for profiling D3 visualizations to identify\n * performance bottlenecks in simulation ticks and rendering operations.\n */\n\nimport * as d3 from 'd3';\nimport { d3Accessors, SimulationNodeDatum } from '../../types/visualizations/D3Types';\n\n/**\n * Types of performance measurements\n */\nexport enum ProfilerMeasurementType {\n  SIMULATION_TICK = 'simulation_tick',\n  FORCE_CALCULATION = 'force_calculation',\n  COORDINATE_ACCESS = 'coordinate_access',\n  DOM_MANIPULATION = 'dom_manipulation',\n  ATTRIBUTE_UPDATE = 'attribute_update',\n  TRANSITION = 'transition',\n  DATA_PREPARATION = 'data_preparation',\n  OTHER = 'other',\n}\n\n/**\n * Performance measurement result\n */\nexport interface PerformanceMeasurement {\n  /** Type of operation measured */\n  type: ProfilerMeasurementType;\n  /** Name/description of the specific operation */\n  name: string;\n  /** Duration in milliseconds */\n  durationMs: number;\n  /** Number of operations performed */\n  operationCount: number;\n  /** Whether this operation is a bottleneck */\n  isBottleneck: boolean;\n  /** Additional metadata */\n  metadata?: Record<string, unknown>;\n  /** Timestamp when the measurement was taken */\n  timestamp: Date;\n}\n\n/**\n * A section of code to profile\n */\nexport interface ProfilerSection {\n  /** Name/description of the section */\n  name: string;\n  /** Type of operation */\n  type: ProfilerMeasurementType;\n  /** (...args: unknown[]) => unknown to execute */\n  fn: () => void;\n  /** Operation count (e.g., number of nodes processed) */\n  operationCount: number;\n  /** Additional metadata */\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Performance profile result\n */\nexport interface PerformanceProfile {\n  /** All measurements taken */\n  measurements: PerformanceMeasurement[];\n  /** Total duration of all measurements */\n  totalDurationMs: number;\n  /** Identified bottlenecks */\n  bottlenecks: PerformanceMeasurement[];\n  /** Start time of the profile */\n  startTime: Date;\n  /** End time of the profile */\n  endTime: Date;\n  /** Recommendations for performance optimization */\n  recommendations: string[];\n}\n\n/**\n * Methods for profiling D3 visualization performance\n */\nexport class D3Profiler {\n  private measurements: PerformanceMeasurement[] = [];\n  private startTime: Date | null = null;\n  private endTime: Date | null = null;\n  private bottleneckThreshold = 5; // ms\n\n  /**\n   * Create a new profiler instance\n   *\n   * @param bottleneckThreshold Threshold in ms to consider an operation a bottleneck\n   */\n  constructor(bottleneckThreshold?: number) {\n    if (bottleneckThreshold !== undefined) {\n      this.bottleneckThreshold = bottleneckThreshold;\n    }\n  }\n\n  /**\n   * Start a profiling session\n   */\n  startProfiling(): void {\n    this.measurements = [];\n    this.startTime = new Date();\n  }\n\n  /**\n   * End a profiling session and return the profile\n   *\n   * @returns The performance profile\n   */\n  endProfiling(): PerformanceProfile {\n    this.endTime = new Date();\n\n    if (!this.startTime) {\n      throw new Error('Cannot end profiling session that has not been started');\n    }\n\n    // Calculate total duration\n    const totalDurationMs = this.measurements.reduce(\n      (total, measurement) => total + measurement.durationMs,\n      0\n    );\n\n    // Identify bottlenecks\n    const bottlenecks = this.measurements.filter(\n      measurement =>\n        measurement.durationMs > this.bottleneckThreshold ||\n        measurement.durationMs / totalDurationMs > 0.1 // >10% of total time\n    );\n\n    // Generate recommendations\n    const recommendations = this.generateRecommendations(bottlenecks, totalDurationMs);\n\n    return {\n      measurements: this.measurements,\n      totalDurationMs,\n      bottlenecks,\n      startTime: this.startTime,\n      endTime: this.endTime,\n      recommendations,\n    };\n  }\n\n  /**\n   * Measure the performance of a section of code\n   *\n   * @param section The section to profile\n   * @returns The performance measurement\n   */\n  measureSection(section: ProfilerSection): PerformanceMeasurement {\n    const startTime = performance.now();\n    section.fn();\n    const endTime = performance.now();\n\n    const durationMs = endTime - startTime;\n    const isBottleneck = durationMs > this.bottleneckThreshold;\n\n    const measurement: PerformanceMeasurement = {\n      type: section.type,\n      name: section.name,\n      durationMs,\n      operationCount: section.operationCount,\n      isBottleneck,\n      metadata: section.metadata,\n      timestamp: new Date(),\n    };\n\n    this.measurements.push(measurement);\n    return measurement;\n  }\n\n  /**\n   * Generate optimization recommendations based on the profile\n   *\n   * @param bottlenecks The identified bottlenecks\n   * @param totalDurationMs Total duration of all measurements\n   * @returns Array of recommendation strings\n   */\n  private generateRecommendations(\n    bottlenecks: PerformanceMeasurement[],\n    totalDurationMs: number\n  ): string[] {\n    const recommendations: string[] = [];\n\n    if (bottlenecks.length === 0) {\n      recommendations.push('No significant bottlenecks detected.');\n      return recommendations;\n    }\n\n    // Group bottlenecks by type\n    const bottlenecksByType = bottlenecks.reduce(\n      (groups, bottleneck) => {\n        const group = groups[bottleneck.type] || [];\n        group.push(bottleneck);\n        groups[bottleneck.type] = group;\n        return groups;\n      },\n      {} as Record<ProfilerMeasurementType, PerformanceMeasurement[]>\n    );\n\n    // Generate recommendations for each type of bottleneck\n    if (bottlenecksByType[ProfilerMeasurementType.SIMULATION_TICK]) {\n      recommendations.push(\n        'Optimize simulation tick function by reducing complexity or frequency of updates.'\n      );\n      recommendations.push(\n        'Consider using a lower alpha decay rate to reduce the number of simulation ticks.'\n      );\n    }\n\n    if (bottlenecksByType[ProfilerMeasurementType.COORDINATE_ACCESS]) {\n      recommendations.push(\n        'Consider memoizing coordinate accessors for frequently accessed nodes.'\n      );\n      recommendations.push(\n        'In performance-critical loops, use direct property access with proper type checking.'\n      );\n    }\n\n    if (bottlenecksByType[ProfilerMeasurementType.DOM_MANIPULATION]) {\n      recommendations.push('Reduce DOM manipulation frequency by batching updates.');\n      recommendations.push(\n        \"Use D3's enter/update/exit pattern efficiently to minimize DOM operations.\"\n      );\n    }\n\n    if (bottlenecksByType[ProfilerMeasurementType.ATTRIBUTE_UPDATE]) {\n      recommendations.push('Reduce the number of attribute updates during animation frames.');\n      recommendations.push(\n        'Consider using CSS transitions for simple animations instead of JavaScript.'\n      );\n    }\n\n    if (bottlenecksByType[ProfilerMeasurementType.DATA_PREPARATION]) {\n      recommendations.push('Cache transformed data to avoid recalculating on each render.');\n      recommendations.push('Implement lazy evaluation for data transformations when possible.');\n    }\n\n    // General recommendations\n    recommendations.push(\n      'Consider using React.memo or useMemo for components that render D3 visualizations.'\n    );\n\n    return recommendations;\n  }\n}\n\n/**\n * Specialized profiler for D3 force simulations\n */\nexport class ForceSimulationProfiler {\n  private profiler: D3Profiler;\n  private originalTick: (...args: unknown[]) => unknown | null = null;\n  private simulation: d3.Simulation<d3.SimulationNodeDatum, undefined> | null = null;\n  private tickMeasurements: PerformanceMeasurement[] = [];\n  private forceMeasurements: Record<string, PerformanceMeasurement[]> = {};\n\n  constructor(bottleneckThreshold?: number) {\n    this.profiler = new D3Profiler(bottleneckThreshold);\n  }\n\n  /**\n   * Attach the profiler to a D3 force simulation\n   *\n   * @param simulation The D3 force simulation to profile\n   */\n  attachToSimulation(simulation: d3.Simulation<d3.SimulationNodeDatum, undefined>): void {\n    this.simulation = simulation;\n    this.originalTick = simulation.tick;\n\n    // Wrap the tick function to measure performance\n    const originalTick = this.originalTick;\n    const profiler = this;\n\n    // Need to use a proper type that matches D3's expected return type\n    simulation.tick = function customTick() {\n      const startTime = performance.now();\n      // Call original tick in the context of the simulation\n      const result = originalTick?.apply(simulation);\n      const endTime = performance.now();\n\n      profiler.tickMeasurements.push({\n        type: ProfilerMeasurementType.SIMULATION_TICK,\n        name: 'Simulation Tick',\n        durationMs: endTime - startTime,\n        operationCount: simulation.nodes().length,\n        isBottleneck: endTime - startTime > (profiler.profiler as unknown).bottleneckThreshold,\n        metadata: {\n          nodeCount: simulation.nodes().length,\n          alpha: simulation.alpha(),\n        },\n        timestamp: new Date(),\n      });\n\n      return result;\n    };\n\n    // Wrap each force to measure performance\n    // Use proper typings for on() method (which is available in D3 force objects)\n    const linkForce = simulation.force('link');\n    const chargeForce = simulation.force('charge');\n    const centerForce = simulation.force('center');\n    const collisionForce = simulation.force('collision');\n\n    if (linkForce && 'on' in linkForce) {\n      (linkForce as unknown).on('tick.profile', this.measureForce('link'));\n    }\n\n    if (chargeForce && 'on' in chargeForce) {\n      (chargeForce as unknown).on('tick.profile', this.measureForce('charge'));\n    }\n\n    if (centerForce && 'on' in centerForce) {\n      (centerForce as unknown).on('tick.profile', this.measureForce('center'));\n    }\n\n    if (collisionForce && 'on' in collisionForce) {\n      (collisionForce as unknown).on('tick.profile', this.measureForce('collision'));\n    }\n  }\n\n  /**\n   * Generate a function to measure force calculation performance\n   *\n   * @param forceName The name of the force to measure\n   * @returns A function to measure the force\n   */\n  private measureForce(forceName: string): () => void {\n    return () => {\n      const startTime = performance.now();\n      // The force calculation happens automatically\n      const endTime = performance.now();\n\n      if (!this.forceMeasurements[forceName]) {\n        this.forceMeasurements[forceName] = [];\n      }\n\n      this.forceMeasurements[forceName].push({\n        type: ProfilerMeasurementType.FORCE_CALCULATION,\n        name: `${forceName} Force Calculation`,\n        durationMs: endTime - startTime,\n        operationCount: this.simulation?.nodes().length || 0,\n        isBottleneck: endTime - startTime > (this.profiler as unknown).bottleneckThreshold,\n        metadata: {\n          forceName,\n          nodeCount: this.simulation?.nodes().length || 0,\n          alpha: this.simulation?.alpha() || 0,\n        },\n        timestamp: new Date(),\n      });\n    };\n  }\n\n  /**\n   * Detach the profiler from the simulation\n   */\n  detachFromSimulation(): void {\n    if (!this.simulation || !this.originalTick) return;\n\n    // Restore original tick function\n    this.simulation.tick = this.originalTick as unknown;\n\n    // Remove event listeners from forces\n    const linkForce = this.simulation.force('link');\n    const chargeForce = this.simulation.force('charge');\n    const centerForce = this.simulation.force('center');\n    const collisionForce = this.simulation.force('collision');\n\n    if (linkForce && 'on' in linkForce) {\n      (linkForce as unknown).on('tick.profile', null);\n    }\n\n    if (chargeForce && 'on' in chargeForce) {\n      (chargeForce as unknown).on('tick.profile', null);\n    }\n\n    if (centerForce && 'on' in centerForce) {\n      (centerForce as unknown).on('tick.profile', null);\n    }\n\n    if (collisionForce && 'on' in collisionForce) {\n      (collisionForce as unknown).on('tick.profile', null);\n    }\n\n    this.simulation = null;\n    this.originalTick = null;\n  }\n\n  /**\n   * Get the profile results\n   *\n   * @returns The performance profile\n   */\n  getProfile(): PerformanceProfile {\n    const allMeasurements = [\n      ...this.tickMeasurements,\n      ...Object.values(this.forceMeasurements).flat(),\n    ];\n\n    const totalDurationMs = allMeasurements.reduce(\n      (total, measurement) => total + measurement.durationMs,\n      0\n    );\n\n    const bottlenecks = allMeasurements.filter(\n      measurement =>\n        measurement.durationMs > (this.profiler as unknown).bottleneckThreshold ||\n        measurement.durationMs / totalDurationMs > 0.1 // >10% of total time\n    );\n\n    // Calculate average tick time\n    const avgTickTime =\n      this.tickMeasurements.length > 0\n        ? this.tickMeasurements.reduce((sum, m) => sum + m.durationMs, 0) /\n          this.tickMeasurements.length\n        : 0;\n\n    // Generate specialized recommendations\n    const recommendations = this.generateForceRecommendations(bottlenecks, avgTickTime);\n\n    // Sort measurements by time (most expensive first)\n    const sortedMeasurements = allMeasurements.sort((a, b) => b.durationMs - a.durationMs);\n\n    return {\n      measurements: sortedMeasurements,\n      totalDurationMs,\n      bottlenecks,\n      startTime: this.tickMeasurements.length > 0 ? this.tickMeasurements[0].timestamp : new Date(),\n      endTime:\n        this.tickMeasurements.length > 0\n          ? this.tickMeasurements[this.tickMeasurements.length - 1].timestamp\n          : new Date(),\n      recommendations,\n    };\n  }\n\n  /**\n   * Generate recommendations for force simulation optimization\n   *\n   * @param bottlenecks The identified bottlenecks\n   * @param avgTickTime Average tick time in milliseconds\n   * @returns Array of recommendation strings\n   */\n  private generateForceRecommendations(\n    bottlenecks: PerformanceMeasurement[],\n    avgTickTime: number\n  ): string[] {\n    const recommendations: string[] = [];\n\n    // Check for slow tick performance\n    if (avgTickTime > 16) {\n      // 16ms = 60fps threshold\n      recommendations.push(\n        `Simulation tick performance is below 60fps (${avgTickTime.toFixed(2)}ms per tick). Consider the following optimizations:`\n      );\n\n      recommendations.push('- Reduce the number of nodes in the simulation');\n      recommendations.push('- Use a higher alpha decay rate to converge faster');\n      recommendations.push('- Implement a step-based simulation instead of continuous');\n    }\n\n    // Identify problematic forces\n    const forceBottlenecks = bottlenecks.filter(\n      b => b.type === ProfilerMeasurementType.FORCE_CALCULATION\n    );\n\n    if (forceBottlenecks.length > 0) {\n      // Group by force name\n      const forceGroups = forceBottlenecks.reduce(\n        (groups, bottleneck) => {\n          const forceName = (bottleneck.metadata?.forceName as string) || 'unknown';\n          const group = groups[forceName] || [];\n          group.push(bottleneck);\n          groups[forceName] = group;\n          return groups;\n        },\n        {} as Record<string, PerformanceMeasurement[]>\n      );\n\n      // Generate recommendations for each slow force\n      Object.entries(forceGroups).forEach(([forceName, measurements]) => {\n        const avgForceTime =\n          measurements.reduce((sum, m) => sum + m.durationMs, 0) / measurements.length;\n\n        recommendations.push(\n          `Force '${forceName}' is taking ${avgForceTime.toFixed(2)}ms on average. Consider:`\n        );\n\n        if (forceName === 'link') {\n          recommendations.push('- Reduce the number of links or link distance');\n          recommendations.push('- Use a more efficient link force implementation');\n        } else if (forceName === 'charge') {\n          recommendations.push('- Reduce charge strength or increase distance cutoff');\n          recommendations.push('- Use a more approximate charge calculation (higher theta value)');\n        } else if (forceName === 'collision') {\n          recommendations.push('- Reduce collision radius or iteration count');\n          recommendations.push('- Consider using a simpler collision detection strategy');\n        }\n      });\n    }\n\n    return recommendations;\n  }\n\n  /**\n   * Reset the profiler\n   */\n  reset(): void {\n    this.tickMeasurements = [];\n    this.forceMeasurements = {};\n  }\n}\n\n/**\n * Profile the performance of coordinate access methods\n *\n * @param nodes The nodes to test coordinate access on\n * @param iterations Number of iterations to run\n * @returns The performance measurement\n */\nexport function profileCoordinateAccess(\n  nodes: SimulationNodeDatum[],\n  iterations: number = 1000\n): PerformanceProfile {\n  const profiler = new D3Profiler();\n  profiler.startProfiling();\n\n  // Profile direct property access\n  profiler.measureSection({\n    name: 'Direct Property Access',\n    type: ProfilerMeasurementType.COORDINATE_ACCESS,\n    operationCount: nodes.length * iterations,\n    fn: () => {\n      for (let i = 0; i < iterations; i++) {\n        for (const node of nodes) {\n          const x = node.x || 0;\n          const y = node.y || 0;\n          const transform = `translate(${x}, ${y})`;\n        }\n      }\n    },\n  });\n\n  // Profile type-safe accessor functions\n  profiler.measureSection({\n    name: 'Type-Safe Accessor (...args: unknown[]) => unknowns',\n    type: ProfilerMeasurementType.COORDINATE_ACCESS,\n    operationCount: nodes.length * iterations,\n    fn: () => {\n      for (let i = 0; i < iterations; i++) {\n        for (const node of nodes) {\n          const x = d3Accessors.getX(node);\n          const y = d3Accessors.getY(node);\n          const transform = `translate(${x}, ${y})`;\n        }\n      }\n    },\n  });\n\n  return profiler.endProfiling();\n}\n\n/**\n * Profile DOM manipulation performance\n *\n * @param containerSelector The CSS selector for the container element\n * @param nodeCount Number of nodes to create\n * @returns The performance measurement\n */\nexport function profileDOMOperations(\n  containerSelector: string,\n  nodeCount: number = 1000\n): PerformanceProfile {\n  const profiler = new D3Profiler();\n  profiler.startProfiling();\n\n  const container = d3.select(containerSelector);\n\n  // Generate test data\n  const nodes = Array.from({ length: nodeCount }, (_, i) => ({\n    id: `node-${i}`,\n    x: Math.random() * 500,\n    y: Math.random() * 500,\n    value: Math.random() * 100,\n  }));\n\n  // Profile DOM creation\n  profiler.measureSection({\n    name: 'DOM Creation',\n    type: ProfilerMeasurementType.DOM_MANIPULATION,\n    operationCount: nodeCount,\n    fn: () => {\n      container.selectAll('*').remove();\n      const svg = container.append('svg').attr('width', 500).attr('height', 500);\n\n      svg\n        .selectAll('circle')\n        .data(nodes)\n        .enter()\n        .append('circle')\n        .attr('cx', d => (d as unknown).x)\n        .attr('cy', d => (d as unknown).y)\n        .attr('r', d => (d as unknown).value / 10)\n        .attr('fill', 'steelblue');\n    },\n  });\n\n  // Profile attribute updates\n  profiler.measureSection({\n    name: 'Attribute Updates',\n    type: ProfilerMeasurementType.ATTRIBUTE_UPDATE,\n    operationCount: nodeCount,\n    fn: () => {\n      container\n        .selectAll('circle')\n        .attr('cx', d => (d as unknown).x + Math.random() * 10 - 5)\n        .attr('cy', d => (d as unknown).y + Math.random() * 10 - 5)\n        .attr('r', d => (d as unknown).value / 10 + Math.random() * 2);\n    },\n  });\n\n  // Profile transitions\n  profiler.measureSection({\n    name: 'Transitions',\n    type: ProfilerMeasurementType.TRANSITION,\n    operationCount: nodeCount,\n    fn: () => {\n      container\n        .selectAll('circle')\n        .transition()\n        .duration(500)\n        .attr('cx', d => (d as unknown).x + Math.random() * 20 - 10)\n        .attr('cy', d => (d as unknown).y + Math.random() * 20 - 10);\n    },\n  });\n\n  // Profile DOM removal\n  profiler.measureSection({\n    name: 'DOM Removal',\n    type: ProfilerMeasurementType.DOM_MANIPULATION,\n    operationCount: nodeCount,\n    fn: () => {\n      container.selectAll('*').remove();\n    },\n  });\n\n  return profiler.endProfiling();\n}\n\n/**\n * Create a memoized version of the D3 accessor functions\n */\nexport const memoizedD3Accessors = {\n  // Cache for getX results\n  xCache: new WeakMap<object, number>(),\n\n  // Cache for getY results\n  yCache: new WeakMap<object, number>(),\n\n  /**\n   * Get the x coordinate of a node (with memoization)\n   */\n  getX: (node: unknown): number => {\n    if (!node || typeof node !== 'object') {\n      return 0;\n    }\n\n    // Check cache first\n    if (memoizedD3Accessors.xCache.has(node)) {\n      return memoizedD3Accessors.xCache.get(node) || 0;\n    }\n\n    // Calculate and cache result\n    const result = d3Accessors.getX(node);\n    memoizedD3Accessors.xCache.set(node, result);\n    return result;\n  },\n\n  /**\n   * Get the y coordinate of a node (with memoization)\n   */\n  getY: (node: unknown): number => {\n    if (!node || typeof node !== 'object') {\n      return 0;\n    }\n\n    // Check cache first\n    if (memoizedD3Accessors.yCache.has(node)) {\n      return memoizedD3Accessors.yCache.get(node) || 0;\n    }\n\n    // Calculate and cache result\n    const result = d3Accessors.getY(node);\n    memoizedD3Accessors.yCache.set(node, result);\n    return result;\n  },\n\n  /**\n   * Clear the cache for a specific node\n   */\n  clearCache: (node: object): void => {\n    memoizedD3Accessors.xCache.delete(node);\n    memoizedD3Accessors.yCache.delete(node);\n  },\n\n  /**\n   * Clear the entire cache\n   */\n  clearAllCache: (): void => {\n    memoizedD3Accessors.xCache = new WeakMap<object, number>();\n    memoizedD3Accessors.yCache = new WeakMap<object, number>();\n  },\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/performance/HookPerformanceDashboard.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'showDetails' is assigned a value but never used. Allowed unused args must match /^_/u.",
        "line": 58,
        "column": 3,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 58,
        "endColumn": 14
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * @file HookPerformanceDashboard.tsx\n * A React component for visualizing hook performance data.\n *\n * This component provides:\n * 1. Real-time visualization of hook performance metrics\n * 2. Filtering and sorting of performance data\n * 3. Performance optimization recommendations\n */\n\nimport * as React from \"react\";\nimport { ChangeEvent, useEffect, useMemo, useState } from 'react';\nimport {\n  clearAllHooksPerformanceData,\n  clearHookPerformanceData,\n  getAllHooksPerformanceData,\n  getHookPerformanceReport,\n  HookPerformanceData,\n} from './hookPerformanceMonitor';\n\ninterface HookPerformanceDashboardProps {\n  /**\n   * Whether to auto-refresh the dashboard data\n   */\n  autoRefresh?: boolean;\n\n  /**\n   * Refresh interval in milliseconds\n   */\n  refreshInterval?: number;\n\n  /**\n   * Whether to show the dashboard in a collapsed state initially\n   */\n  initiallyCollapsed?: boolean;\n\n  /**\n   * Whether to show detailed data for each hook\n   */\n  showDetails?: boolean;\n\n  /**\n   * Filter hooks by name\n   */\n  filterByHook?: string;\n}\n\n// Type for the sort options\ntype SortOption = 'name' | 'renders' | 'selectors' | 'computations';\n\n/**\n * Hook Performance Dashboard component\n */\nconst HookPerformanceDashboard: React.FC<HookPerformanceDashboardProps> = ({\n  autoRefresh = true,\n  refreshInterval = 1000,\n  initiallyCollapsed = true,\n  showDetails = false,\n  filterByHook,\n}) => {\n  const [collapsed, setCollapsed] = useState(initiallyCollapsed);\n  const [performanceData, setPerformanceData] = useState<Record<string, HookPerformanceData>>({});\n  const [selectedHook, setSelectedHook] = useState<string | null>(null);\n  const [sortBy, setSortBy] = useState<SortOption>('renders');\n  const [filterText, setFilterText] = useState(filterByHook || '');\n  const [showOnlySlowHooks, setShowOnlySlowHooks] = useState(false);\n\n  // Refresh performance data\n  useEffect(() => {\n    const refreshData = () => {\n      setPerformanceData(getAllHooksPerformanceData());\n    };\n\n    // Initial refresh\n    refreshData();\n\n    // Auto-refresh if enabled\n    let interval: NodeJS.Timeout | null = null;\n    if (autoRefresh) {\n      interval = setInterval(refreshData, refreshInterval);\n    }\n\n    return () => {\n      if (interval) {\n        clearInterval(interval);\n      }\n    };\n  }, [autoRefresh, refreshInterval]);\n\n  // Calculate derived data\n  const filteredAndSortedHooks = useMemo(() => {\n    // Convert to array for filtering and sorting\n    let hooks = Object.entries(performanceData).map(([hookName, data]) => ({\n      hookName,\n      renderCount: data.renderCount,\n      selectorCount: Object.keys(data.selectorTimes).length,\n      computationCount: Object.keys(data.computationTimes).length,\n      avgSelectorTime: calculateAverageTime(data.selectorTimes),\n      avgComputationTime: calculateAverageTime(data.computationTimes),\n      data,\n    }));\n\n    // Filter by name if filterText is provided\n    if (filterText) {\n      hooks = hooks.filter(hook => hook.hookName.toLowerCase().includes(filterText.toLowerCase()));\n    }\n\n    // Filter slow hooks if showOnlySlowHooks is true\n    if (showOnlySlowHooks) {\n      hooks = hooks.filter(hook => hook.avgSelectorTime > 2 || hook.avgComputationTime > 5);\n    }\n\n    // Sort hooks\n    switch (sortBy) {\n      case 'name':\n        hooks.sort((a, b) => a.hookName.localeCompare(b.hookName));\n        break;\n      case 'renders':\n        hooks.sort((a, b) => b.renderCount - a.renderCount);\n        break;\n      case 'selectors':\n        hooks.sort((a, b) => b.avgSelectorTime - a.avgSelectorTime);\n        break;\n      case 'computations':\n        hooks.sort((a, b) => b.avgComputationTime - a.avgComputationTime);\n        break;\n    }\n\n    return hooks;\n  }, [performanceData, sortBy, filterText, showOnlySlowHooks]);\n\n  // Get selected hook report\n  const selectedHookReport = useMemo(() => {\n    if (!selectedHook) return null;\n    return getHookPerformanceReport(selectedHook);\n  }, [selectedHook]);\n\n  // Calculate average time from a record of arrays\n  function calculateAverageTime(timeRecord: Record<string, number[]>): number {\n    const allTimes = Object.values(timeRecord).flat();\n    if (allTimes.length === 0) return 0;\n    return allTimes.reduce((sum, time) => sum + time, 0) / allTimes.length;\n  }\n\n  // Handle sort option change\n  const handleSortChange = (e: ChangeEvent<HTMLSelectElement>) => {\n    setSortBy(e.target.value as SortOption);\n  };\n\n  // Clear all performance data\n  const handleClearAll = () => {\n    clearAllHooksPerformanceData();\n    setPerformanceData({});\n    setSelectedHook(null);\n  };\n\n  // Clear selected hook performance data\n  const handleClearSelected = () => {\n    if (selectedHook) {\n      clearHookPerformanceData(selectedHook);\n      setPerformanceData(prevData => {\n        const newData = { ...prevData };\n        delete newData[selectedHook];\n        return newData;\n      });\n      setSelectedHook(null);\n    }\n  };\n\n  // If collapsed, only show the header\n  if (collapsed) {\n    return (\n      <div\n        style={{\n          position: 'fixed',\n          bottom: '10px',\n          right: '10px',\n          backgroundColor: 'rgba(0, 0, 0, 0.8)',\n          color: 'white',\n          padding: '10px',\n          borderRadius: '5px',\n          zIndex: 9999,\n          cursor: 'pointer',\n        }}\n        onClick={() => setCollapsed(false)}\n      >\n        <h3 style={{ margin: 0 }}>\n          📊 Hook Performance Monitor ({Object.keys(performanceData).length} hooks)\n        </h3>\n      </div>\n    );\n  }\n\n  return (\n    <div\n      style={{\n        position: 'fixed',\n        bottom: '10px',\n        right: '10px',\n        width: '600px',\n        maxHeight: '80vh',\n        backgroundColor: 'rgba(0, 0, 0, 0.8)',\n        color: 'white',\n        padding: '15px',\n        borderRadius: '5px',\n        zIndex: 9999,\n        overflowY: 'auto',\n        fontFamily: 'monospace',\n      }}\n    >\n      <div\n        style={{\n          display: 'flex',\n          justifyContent: 'space-between',\n          alignItems: 'center',\n          marginBottom: '10px',\n        }}\n      >\n        <h3 style={{ margin: 0 }}>\n          📊 Hook Performance Monitor ({filteredAndSortedHooks.length} hooks)\n        </h3>\n        <div>\n          <button\n            onClick={handleClearAll}\n            style={{\n              marginRight: '5px',\n              padding: '5px',\n              backgroundColor: '#d9534f',\n              border: 'none',\n              borderRadius: '3px',\n              color: 'white',\n            }}\n          >\n            Clear All\n          </button>\n          <button\n            onClick={() => setCollapsed(true)}\n            style={{\n              padding: '5px',\n              backgroundColor: '#5bc0de',\n              border: 'none',\n              borderRadius: '3px',\n              color: 'white',\n            }}\n          >\n            Minimize\n          </button>\n        </div>\n      </div>\n\n      <div style={{ display: 'flex', gap: '10px', marginBottom: '10px' }}>\n        <input\n          type=\"text\"\n          placeholder=\"Filter hooks...\"\n          value={filterText}\n          onChange={e => setFilterText(e.target.value)}\n          style={{ padding: '5px', flex: 1 }}\n        />\n\n        <select value={sortBy} onChange={handleSortChange} style={{ padding: '5px' }}>\n          <option value=\"name\">Sort by Name</option>\n          <option value=\"renders\">Sort by Renders</option>\n          <option value=\"selectors\">Sort by Selector Time</option>\n          <option value=\"computations\">Sort by Computation Time</option>\n        </select>\n\n        <label style={{ display: 'flex', alignItems: 'center' }}>\n          <input\n            type=\"checkbox\"\n            checked={showOnlySlowHooks}\n            onChange={e => setShowOnlySlowHooks(e.target.checked)}\n          />\n          Slow Hooks Only\n        </label>\n      </div>\n\n      <div\n        style={{\n          marginBottom: '15px',\n          maxHeight: '200px',\n          overflowY: 'auto',\n          border: '1px solid #444',\n          borderRadius: '3px',\n        }}\n      >\n        <table style={{ width: '100%', borderCollapse: 'collapse' }}>\n          <thead>\n            <tr style={{ backgroundColor: '#333', position: 'sticky', top: 0 }}>\n              <th style={{ padding: '8px', textAlign: 'left' }}>Hook</th>\n              <th style={{ padding: '8px', textAlign: 'right' }}>Renders</th>\n              <th style={{ padding: '8px', textAlign: 'right' }}>Selector Avg (ms)</th>\n              <th style={{ padding: '8px', textAlign: 'right' }}>Compute Avg (ms)</th>\n              <th style={{ padding: '8px', textAlign: 'center' }}>Actions</th>\n            </tr>\n          </thead>\n          <tbody>\n            {filteredAndSortedHooks.map(hook => (\n              <tr\n                key={hook.hookName}\n                style={{\n                  backgroundColor: selectedHook === hook.hookName ? '#1e5f74' : 'transparent',\n                  cursor: 'pointer',\n                  borderBottom: '1px solid #444',\n                }}\n                onClick={() => setSelectedHook(hook.hookName)}\n              >\n                <td style={{ padding: '8px' }}>{hook.hookName}</td>\n                <td style={{ padding: '8px', textAlign: 'right' }}>{hook.renderCount}</td>\n                <td\n                  style={{\n                    padding: '8px',\n                    textAlign: 'right',\n                    color: hook.avgSelectorTime > 2 ? '#ff6b6b' : 'inherit',\n                  }}\n                >\n                  {hook.avgSelectorTime.toFixed(2)}\n                </td>\n                <td\n                  style={{\n                    padding: '8px',\n                    textAlign: 'right',\n                    color: hook.avgComputationTime > 5 ? '#ff6b6b' : 'inherit',\n                  }}\n                >\n                  {hook.avgComputationTime.toFixed(2)}\n                </td>\n                <td style={{ padding: '8px', textAlign: 'center' }}>\n                  <button\n                    onClick={e => {\n                      e.stopPropagation();\n                      clearHookPerformanceData(hook.hookName);\n                      setPerformanceData(prevData => {\n                        const newData = { ...prevData };\n                        delete newData[hook.hookName];\n                        return newData;\n                      });\n                      if (selectedHook === hook.hookName) {\n                        setSelectedHook(null);\n                      }\n                    }}\n                    style={{\n                      padding: '2px 5px',\n                      backgroundColor: 'transparent',\n                      border: '1px solid #999',\n                      borderRadius: '3px',\n                      color: 'white',\n                    }}\n                  >\n                    Clear\n                  </button>\n                </td>\n              </tr>\n            ))}\n            {filteredAndSortedHooks.length === 0 && (\n              <tr>\n                <td colSpan={5} style={{ padding: '20px', textAlign: 'center' }}>\n                  No performance data available\n                </td>\n              </tr>\n            )}\n          </tbody>\n        </table>\n      </div>\n\n      {selectedHook && (\n        <div style={{ borderTop: '1px solid #444', paddingTop: '10px' }}>\n          <div\n            style={{\n              display: 'flex',\n              justifyContent: 'space-between',\n              alignItems: 'center',\n              marginBottom: '10px',\n            }}\n          >\n            <h4 style={{ margin: 0 }}>Hook Details: {selectedHook}</h4>\n            <button\n              onClick={handleClearSelected}\n              style={{\n                padding: '5px',\n                backgroundColor: '#f0ad4e',\n                border: 'none',\n                borderRadius: '3px',\n                color: 'white',\n              }}\n            >\n              Clear Selected\n            </button>\n          </div>\n\n          <pre\n            style={{\n              maxHeight: '200px',\n              overflowY: 'auto',\n              backgroundColor: '#222',\n              padding: '10px',\n              borderRadius: '3px',\n              margin: 0,\n              fontSize: '12px',\n            }}\n          >\n            {selectedHookReport}\n          </pre>\n        </div>\n      )}\n\n      <div\n        style={{\n          marginTop: '15px',\n          borderTop: '1px solid #444',\n          paddingTop: '10px',\n          fontSize: '12px',\n        }}\n      >\n        <p>\n          <strong>Performance Tips:</strong>\n          <br />\n          • Slow selectors (&gt;2ms) may indicate inefficient state access\n          <br />\n          • Slow computations (&gt;5ms) may be causing render delays\n          <br />• High render counts may indicate missing dependency arrays in useEffect/useMemo\n        </p>\n      </div>\n    </div>\n  );\n};\n\nexport default HookPerformanceDashboard;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/performance/animationFrameManagerInstance.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/performance/benchmarks/DynamicBudgetAdjustment.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/performance/benchmarks/PerformanceBenchmarkTools.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'converters' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 321,
        "column": 9,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 321,
        "endColumn": 19
      },
      {
        "ruleId": "no-console",
        "severity": 1,
        "message": "Unexpected console statement. Only these console methods are allowed: warn, error.",
        "line": 923,
        "column": 5,
        "nodeType": "MemberExpression",
        "messageId": "limited",
        "endLine": 923,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "removeConsole",
            "data": { "propertyName": "table" },
            "fix": { "range": [24939, 24975], "text": "" },
            "desc": "Remove the console.table()."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Performance Benchmarking Tools\n *\n * This file provides a comprehensive set of tools for benchmarking and analyzing\n * performance across different systems in the application, with a particular focus on:\n *\n * - ResourceFlowManager optimization\n * - Event System processing\n * - React component rendering\n * - Memory usage analysis\n *\n * Use these tools to establish performance baselines, detect regressions,\n * and validate performance optimizations.\n */\n\nimport * as d3 from 'd3';\nimport { performance } from 'perf_hooks';\nimport { ResourceFlowManager } from '../../../managers/resource/ResourceFlowManager';\nimport { FlowNodeType } from '../../../types/resources/FlowTypes';\nimport { ResourceType } from \"./../../../types/resources/ResourceTypes\";\n\n/**\n * Performance benchmark result\n */\nexport interface BenchmarkResult {\n  name: string;\n  description?: string;\n  executionTimeMs: number;\n  memoryUsageMB?: number;\n  operationsCount?: number;\n  operationsPerSecond?: number;\n  additionalMetrics?: Record<string, number>;\n  timestamp: Date;\n}\n\n/**\n * System-specific benchmark results\n */\nexport interface ResourceFlowBenchmarkResult extends BenchmarkResult {\n  nodeCount: number;\n  connectionCount: number;\n  nodesProcessed: number;\n  connectionsProcessed: number;\n  transfersGenerated: number;\n  optimizationCycles: number;\n}\n\nexport interface EventSystemBenchmarkResult extends BenchmarkResult {\n  eventCount: number;\n  eventsPerSecond: number;\n  listenersTriggered: number;\n  averageEventProcessingTimeMs: number;\n  batchCount?: number;\n  batchSize?: number;\n}\n\nexport interface RenderingBenchmarkResult extends BenchmarkResult {\n  componentCount: number;\n  renderCount: number;\n  fps: number;\n  frameTimeMs: number;\n  maxFrameTimeMs: number;\n  minFrameTimeMs: number;\n  jankFrames: number; // Frames exceeding 16ms\n}\n\n/**\n * Options for benchmark execution\n */\nexport interface BenchmarkOptions {\n  iterations?: number;\n  warmupIterations?: number;\n  setupFn?: () => void;\n  teardownFn?: () => void;\n  memoryMeasurement?: boolean;\n  timeout?: number;\n}\n\n/**\n * Benchmark test case\n */\nexport interface BenchmarkTestCase<T extends BenchmarkResult = BenchmarkResult> {\n  name: string;\n  description?: string;\n  run: () => Promise<T> | T;\n  options?: BenchmarkOptions;\n}\n\n/**\n * Record of memory usage before and after a benchmark\n */\ninterface MemoryMeasurement {\n  before: NodeJS.MemoryUsage;\n  after: NodeJS.MemoryUsage;\n  diffHeapUsed: number;\n  diffHeapTotal: number;\n  diffExternal: number;\n  diffRss: number;\n}\n\n/**\n * Measures the memory usage of a function\n * @param fn Function to measure\n * @returns Memory measurement\n */\nexport function measureMemoryUsage(fn: () => void): MemoryMeasurement {\n  // Force garbage collection if available\n  if (global.gc) {\n    global.gc();\n  }\n\n  // Measure memory before\n  const before = process.memoryUsage();\n\n  // Run the function\n  fn();\n\n  // Measure memory after\n  const after = process.memoryUsage();\n\n  // Calculate difference\n  return {\n    before,\n    after,\n    diffHeapUsed: (after.heapUsed - before.heapUsed) / (1024 * 1024), // MB\n    diffHeapTotal: (after.heapTotal - before.heapTotal) / (1024 * 1024), // MB\n    diffExternal: (after.external - before.external) / (1024 * 1024), // MB\n    diffRss: (after.rss - before.rss) / (1024 * 1024), // MB\n  };\n}\n\n/**\n * Runs a benchmark for a synchronous function\n * @param fn Function to benchmark\n * @param options Benchmark options\n * @returns Benchmark results\n */\nexport function runBenchmark<T>(fn: () => T, options: BenchmarkOptions = {}): BenchmarkResult {\n  const {\n    iterations = 100,\n    warmupIterations = 10,\n    setupFn,\n    teardownFn,\n    memoryMeasurement = false,\n  } = options;\n\n  // Run warmup iterations\n  for (let i = 0; i < warmupIterations; i++) {\n    if (setupFn) setupFn();\n    fn();\n    if (teardownFn) teardownFn();\n  }\n\n  // Prepare for actual benchmark\n  const executionTimes: number[] = [];\n  let memoryUsage: MemoryMeasurement | null = null;\n\n  // Execute the benchmark\n  for (let i = 0; i < iterations; i++) {\n    if (setupFn) setupFn();\n\n    if (memoryMeasurement && i === Math.floor(iterations / 2)) {\n      // Measure memory usage halfway through the iterations\n      memoryUsage = measureMemoryUsage(fn);\n    } else {\n      const startTime = performance.now();\n      fn();\n      const endTime = performance.now();\n      executionTimes.push(endTime - startTime);\n    }\n\n    if (teardownFn) teardownFn();\n  }\n\n  // Calculate statistics\n  const totalTime = executionTimes.reduce((sum, time) => sum + time, 0);\n  const averageTime = totalTime / executionTimes.length;\n  const sortedTimes = [...executionTimes].sort((a, b) => a - b);\n  const medianTime =\n    sortedTimes.length % 2 === 0\n      ? (sortedTimes[sortedTimes.length / 2 - 1] + sortedTimes[sortedTimes.length / 2]) / 2\n      : sortedTimes[Math.floor(sortedTimes.length / 2)];\n\n  return {\n    name: 'Benchmark',\n    executionTimeMs: averageTime,\n    memoryUsageMB: memoryUsage?.diffHeapUsed,\n    operationsCount: iterations,\n    operationsPerSecond: (1000 * iterations) / totalTime,\n    additionalMetrics: {\n      medianTimeMs: medianTime,\n      minTimeMs: Math.min(...executionTimes),\n      maxTimeMs: Math.max(...executionTimes),\n      stdDevMs: calculateStandardDeviation(executionTimes),\n    },\n    timestamp: new Date(),\n  };\n}\n\n/**\n * Runs an async benchmark\n * @param fn Async function to benchmark\n * @param options Benchmark options\n * @returns Promise resolving to benchmark results\n */\nexport async function runAsyncBenchmark<T>(\n  fn: () => Promise<T>,\n  options: BenchmarkOptions = {}\n): Promise<BenchmarkResult> {\n  const {\n    iterations = 100,\n    warmupIterations = 10,\n    setupFn,\n    teardownFn,\n    memoryMeasurement = false,\n    timeout = 30000,\n  } = options;\n\n  // Create a timeout promise\n  const timeoutPromise = new Promise<never>((_, reject) => {\n    setTimeout(() => {\n      reject(new Error(`Benchmark timed out after ${timeout}ms`));\n    }, timeout);\n  });\n\n  // Run warmup iterations\n  for (let i = 0; i < warmupIterations; i++) {\n    if (setupFn) setupFn();\n    await fn();\n    if (teardownFn) teardownFn();\n  }\n\n  // Prepare for actual benchmark\n  const executionTimes: number[] = [];\n  let memoryUsage: MemoryMeasurement | null = null;\n\n  // Execute the benchmark\n  for (let i = 0; i < iterations; i++) {\n    if (setupFn) setupFn();\n\n    if (memoryMeasurement && i === Math.floor(iterations / 2)) {\n      // Measure memory usage halfway through the iterations\n      const memoryFn = async () => {\n        await Promise.race([fn(), timeoutPromise]);\n      };\n      memoryUsage = measureMemoryUsage(() => {\n        // This is a sync function that wraps the async function\n        // We can't measure memory usage of an async function directly\n        // But we can trigger it to run and measure the initial setup\n        memoryFn();\n      });\n    } else {\n      const startTime = performance.now();\n      await Promise.race([fn(), timeoutPromise]);\n      const endTime = performance.now();\n      executionTimes.push(endTime - startTime);\n    }\n\n    if (teardownFn) teardownFn();\n  }\n\n  // Calculate statistics\n  const totalTime = executionTimes.reduce((sum, time) => sum + time, 0);\n  const averageTime = totalTime / executionTimes.length;\n  const sortedTimes = [...executionTimes].sort((a, b) => a - b);\n  const medianTime =\n    sortedTimes.length % 2 === 0\n      ? (sortedTimes[sortedTimes.length / 2 - 1] + sortedTimes[sortedTimes.length / 2]) / 2\n      : sortedTimes[Math.floor(sortedTimes.length / 2)];\n\n  return {\n    name: 'Async Benchmark',\n    executionTimeMs: averageTime,\n    memoryUsageMB: memoryUsage?.diffHeapUsed,\n    operationsCount: iterations,\n    operationsPerSecond: (1000 * iterations) / totalTime,\n    additionalMetrics: {\n      medianTimeMs: medianTime,\n      minTimeMs: Math.min(...executionTimes),\n      maxTimeMs: Math.max(...executionTimes),\n      stdDevMs: calculateStandardDeviation(executionTimes),\n    },\n    timestamp: new Date(),\n  };\n}\n\n/**\n * Calculate standard deviation of an array of numbers\n */\nfunction calculateStandardDeviation(values: number[]): number {\n  const average = values.reduce((sum, value) => sum + value, 0) / values.length;\n  const squareDiffs = values.map(value => Math.pow(value - average, 2));\n  const avgSquareDiff =\n    squareDiffs.reduce((sum, squareDiff) => sum + squareDiff, 0) / squareDiffs.length;\n  return Math.sqrt(avgSquareDiff);\n}\n\n/**\n * Creates a test ResourceFlowManager with specified number of nodes and connections\n */\nexport function createTestResourceNetwork(\n  nodeCount: number,\n  connectionCount: number,\n  resourceTypes: ResourceType[] = [\n    ResourceType.IRON,\n    ResourceType.COPPER,\n    ResourceType.OXYGEN,\n    ResourceType.SILICON,\n  ]\n): ResourceFlowManager {\n  // Create a resource flow manager\n  const manager = new ResourceFlowManager(100, 1000, 50);\n\n  // Generate node IDs\n  const nodeIds = Array.from({ length: nodeCount }, (_, i) => `node-${i}`);\n\n  // Create nodes with different types\n  const producers = Math.floor(nodeCount * 0.3);\n  const consumers = Math.floor(nodeCount * 0.3);\n  const storage = Math.floor(nodeCount * 0.2);\n  const converters = nodeCount - producers - consumers - storage;\n\n  // Add nodes to manager\n  for (let i = 0; i < nodeCount; i++) {\n    const nodeId = nodeIds[i];\n    let nodeType: FlowNodeType;\n\n    if (i < producers) {\n      nodeType = 'producer';\n    } else if (i < producers + consumers) {\n      nodeType = 'consumer';\n    } else if (i < producers + consumers + storage) {\n      nodeType = 'storage';\n    } else {\n      nodeType = 'converter';\n    }\n\n    // Determine resource type\n    const resourceType = resourceTypes[i % resourceTypes.length];\n\n    // Create and register node\n    manager.registerNode({\n      id: nodeId,\n      type: nodeType,\n      active: true,\n      resources: [resourceType],\n      capacity: 1000,\n      rate: 10,\n      priority: Math.floor(Math.random() * 10),\n      efficiency: 0.8 + Math.random() * 0.2,\n    });\n  }\n\n  // Create connections\n  for (let i = 0; i < connectionCount; i++) {\n    const sourceIndex = Math.floor(Math.random() * nodeCount);\n    let targetIndex = Math.floor(Math.random() * nodeCount);\n\n    // Avoid self-connections\n    while (targetIndex === sourceIndex) {\n      targetIndex = Math.floor(Math.random() * nodeCount);\n    }\n\n    const sourceId = nodeIds[sourceIndex];\n    const targetId = nodeIds[targetIndex];\n    const resourceType = resourceTypes[i % resourceTypes.length];\n\n    manager.createConnection({\n      id: `connection-${i}`,\n      sourceId,\n      targetId,\n      resourceType,\n      flowRate: 5 + Math.random() * 10,\n      active: true,\n      maxFlowRate: 20,\n    });\n  }\n\n  return manager;\n}\n\n/**\n * Run ResourceFlowManager benchmark\n */\nexport function runResourceFlowBenchmark(\n  benchmarkName: string,\n  nodeCount: number,\n  connectionCount: number,\n  options: {\n    batchSize?: number;\n    cacheTTL?: number;\n    iterations?: number;\n    optimizationInterval?: number;\n  } = {}\n): Promise<ResourceFlowBenchmarkResult> {\n  const { batchSize = 50, cacheTTL = 1000, iterations = 10, optimizationInterval = 100 } = options;\n\n  return new Promise(resolve => {\n    // Create benchmark function\n    const benchmarkFn = () => {\n      // Create manager with specified options\n      const manager = new ResourceFlowManager(optimizationInterval, cacheTTL, batchSize);\n\n      // Add test network\n      createTestResourceNetwork(nodeCount, connectionCount);\n\n      // Run optimization\n      const result = manager.optimizeFlows(true);\n\n      // Clean up\n      manager.cleanup();\n\n      return {\n        nodeCount,\n        connectionCount,\n        nodesProcessed: result.performanceMetrics?.nodesProcessed || 0,\n        connectionsProcessed: result.performanceMetrics?.connectionsProcessed || 0,\n        transfersGenerated: result.performanceMetrics?.transfersGenerated || 0,\n        optimizationCycles: 1,\n        executionTimeMs: result.performanceMetrics?.executionTimeMs || 0,\n      };\n    };\n\n    // Run the benchmark\n    const basicResult = runBenchmark(benchmarkFn, {\n      iterations,\n      warmupIterations: 2,\n      memoryMeasurement: true,\n    });\n\n    // Create the complete result\n    const result: ResourceFlowBenchmarkResult = {\n      ...basicResult,\n      name: benchmarkName,\n      nodeCount,\n      connectionCount,\n      nodesProcessed: 0,\n      connectionsProcessed: 0,\n      transfersGenerated: 0,\n      optimizationCycles: iterations,\n    };\n\n    resolve(result);\n  });\n}\n\n/**\n * Creates a visual performance report from benchmark results\n * @param results Benchmark results\n * @param targetElement DOM element to render the visualization\n */\nexport function createPerformanceVisualization(\n  results: BenchmarkResult[],\n  targetElement: HTMLElement\n): void {\n  // Set up SVG dimensions\n  const margin = { top: 30, right: 30, bottom: 70, left: 60 };\n  const width = 800 - margin.left - margin.right;\n  const height = 400 - margin.top - margin.bottom;\n\n  // Create SVG\n  const svg = d3\n    .select(targetElement)\n    .append('svg')\n    .attr('width', width + margin.left + margin.right)\n    .attr('height', height + margin.top + margin.bottom)\n    .append('g')\n    .attr('transform', `translate(${margin.left},${margin.top})`);\n\n  // Create scales\n  const x = d3\n    .scaleBand()\n    .domain(results.map(d => d.name))\n    .range([0, width])\n    .padding(0.2);\n\n  const y = d3\n    .scaleLinear()\n    .domain([0, d3.max(results, d => d.executionTimeMs) || 0])\n    .nice()\n    .range([height, 0]);\n\n  // Add X axis\n  svg\n    .append('g')\n    .attr('transform', `translate(0,${height})`)\n    .call(d3.axisBottom(x))\n    .selectAll('text')\n    .attr('transform', 'translate(-10,0)rotate(-45)')\n    .style('text-anchor', 'end');\n\n  // Add Y axis\n  svg.append('g').call(d3.axisLeft(y));\n\n  // Add bars\n  svg\n    .selectAll('rect')\n    .data(results)\n    .enter()\n    .append('rect')\n    .attr('x', d => x(d.name) || 0)\n    .attr('y', d => y(d.executionTimeMs))\n    .attr('width', x.bandwidth())\n    .attr('height', d => height - y(d.executionTimeMs))\n    .attr('fill', '#4dabf7');\n\n  // Add title\n  svg\n    .append('text')\n    .attr('x', width / 2)\n    .attr('y', -10)\n    .attr('text-anchor', 'middle')\n    .style('font-size', '16px')\n    .text('Performance Benchmark Results');\n\n  // Add labels\n  svg\n    .selectAll('.label')\n    .data(results)\n    .enter()\n    .append('text')\n    .attr('class', 'label')\n    .attr('x', d => (x(d.name) || 0) + x.bandwidth() / 2)\n    .attr('y', d => y(d.executionTimeMs) - 5)\n    .attr('text-anchor', 'middle')\n    .text(d => `${d.executionTimeMs.toFixed(2)}ms`);\n}\n\n/**\n * Generates a comprehensive benchmark report\n * @param results Benchmark results\n * @returns HTML report\n */\nexport function generateBenchmarkReport(results: BenchmarkResult[]): string {\n  const reportDate = new Date().toISOString().split('T')[0];\n  const reportTime = new Date().toTimeString().split(' ')[0];\n\n  // Generate HTML report\n  return `\n    <!DOCTYPE html>\n    <html>\n    <head>\n      <title>Performance Benchmark Report - ${reportDate}</title>\n      <style>\n        body {\n          font-family: Arial, sans-serif;\n          margin: 20px;\n          color: #333;\n        }\n        h1, h2, h3 {\n          color: #222;\n        }\n        table {\n          border-collapse: collapse;\n          width: 100%;\n          margin-bottom: 20px;\n        }\n        th, td {\n          border: 1px solid #ddd;\n          padding: 8px;\n          text-align: left;\n        }\n        th {\n          background-color: #f2f2f2;\n        }\n        tr:nth-child(even) {\n          background-color: #f9f9f9;\n        }\n        .metrics {\n          display: flex;\n          flex-wrap: wrap;\n          gap: 20px;\n          margin-bottom: 20px;\n        }\n        .metric-card {\n          border: 1px solid #ddd;\n          border-radius: 4px;\n          padding: 15px;\n          width: 200px;\n        }\n        .metric-title {\n          font-weight: bold;\n          margin-bottom: 5px;\n        }\n        .metric-value {\n          font-size: 24px;\n          color: #0066cc;\n        }\n        .chart-container {\n          width: 100%;\n          height: 400px;\n          margin-bottom: 20px;\n        }\n      </style>\n    </head>\n    <body>\n      <h1>Performance Benchmark Report</h1>\n      <p>Generated on ${reportDate} at ${reportTime}</p>\n      \n      <h2>Summary</h2>\n      <div class=\"metrics\">\n        <div class=\"metric-card\">\n          <div class=\"metric-title\">Total Benchmarks</div>\n          <div class=\"metric-value\">${results.length}</div>\n        </div>\n        <div class=\"metric-card\">\n          <div class=\"metric-title\">Average Execution Time</div>\n          <div class=\"metric-value\">${(\n            results.reduce((sum, r) => sum + r.executionTimeMs, 0) / results.length\n          ).toFixed(2)} ms</div>\n        </div>\n        <div class=\"metric-card\">\n          <div class=\"metric-title\">Min Execution Time</div>\n          <div class=\"metric-value\">${Math.min(...results.map(r => r.executionTimeMs)).toFixed(\n            2\n          )} ms</div>\n        </div>\n        <div class=\"metric-card\">\n          <div class=\"metric-title\">Max Execution Time</div>\n          <div class=\"metric-value\">${Math.max(...results.map(r => r.executionTimeMs)).toFixed(\n            2\n          )} ms</div>\n        </div>\n      </div>\n      \n      <h2>Detailed Results</h2>\n      <table>\n        <thead>\n          <tr>\n            <th>Name</th>\n            <th>Execution Time (ms)</th>\n            <th>Operations/Second</th>\n            <th>Memory Usage (MB)</th>\n            <th>Description</th>\n          </tr>\n        </thead>\n        <tbody>\n          ${results\n            .map(\n              r => `\n            <tr>\n              <td>${r.name}</td>\n              <td>${r.executionTimeMs.toFixed(2)}</td>\n              <td>${r.operationsPerSecond?.toFixed(2) || 'N/A'}</td>\n              <td>${r.memoryUsageMB?.toFixed(2) || 'N/A'}</td>\n              <td>${r.description || ''}</td>\n            </tr>\n          `\n            )\n            .join('')}\n        </tbody>\n      </table>\n      \n      <h2>Visualizations</h2>\n      <div class=\"chart-container\" id=\"executionTimeChart\"></div>\n      <div class=\"chart-container\" id=\"memoryUsageChart\"></div>\n      \n      <h2>Additional Metrics</h2>\n      <table>\n        <thead>\n          <tr>\n            <th>Name</th>\n            ${Object.keys(results[0]?.additionalMetrics || {})\n              .map(key => `<th>${key}</th>`)\n              .join('')}\n          </tr>\n        </thead>\n        <tbody>\n          ${results\n            .map(\n              r => `\n            <tr>\n              <td>${r.name}</td>\n              ${Object.values(r.additionalMetrics || {})\n                .map(value => `<td>${typeof value === 'number' ? value.toFixed(2) : value}</td>`)\n                .join('')}\n            </tr>\n          `\n            )\n            .join('')}\n        </tbody>\n      </table>\n      \n      <script src=\"https://d3js.org/d3.v7.min.js\"></script>\n      <script>\n        // This would be filled with the D3 visualization code\n        // but we'll skip it for brevity\n      </script>\n    </body>\n    </html>\n  `;\n}\n\n/**\n * Detects performance regressions by comparing benchmark results\n * @param newResults New benchmark results\n * @param baselineResults Baseline benchmark results\n * @param threshold Regression threshold (percentage)\n * @returns Regression analysis\n */\nexport function detectPerformanceRegressions(\n  newResults: BenchmarkResult[],\n  baselineResults: BenchmarkResult[],\n  threshold = 5\n): {\n  regressions: Array<{\n    name: string;\n    baselineTime: number;\n    newTime: number;\n    percentChange: number;\n  }>;\n  improvements: Array<{\n    name: string;\n    baselineTime: number;\n    newTime: number;\n    percentChange: number;\n  }>;\n  summary: {\n    totalTests: number;\n    regressionCount: number;\n    improvementCount: number;\n    unchangedCount: number;\n  };\n} {\n  const regressions: Array<{\n    name: string;\n    baselineTime: number;\n    newTime: number;\n    percentChange: number;\n  }> = [];\n\n  const improvements: Array<{\n    name: string;\n    baselineTime: number;\n    newTime: number;\n    percentChange: number;\n  }> = [];\n\n  // Create a map of baseline results for easy lookup\n  const baselineMap = new Map(baselineResults.map(result => [result.name, result]));\n\n  // Compare each new result with its baseline\n  for (const newResult of newResults) {\n    const baselineResult = baselineMap.get(newResult.name);\n    if (!baselineResult) continue;\n\n    const baselineTime = baselineResult.executionTimeMs;\n    const newTime = newResult.executionTimeMs;\n    const percentChange = ((newTime - baselineTime) / baselineTime) * 100;\n\n    if (percentChange > threshold) {\n      regressions.push({\n        name: newResult.name,\n        baselineTime,\n        newTime,\n        percentChange,\n      });\n    } else if (percentChange < -threshold) {\n      improvements.push({\n        name: newResult.name,\n        baselineTime,\n        newTime,\n        percentChange,\n      });\n    }\n  }\n\n  return {\n    regressions,\n    improvements,\n    summary: {\n      totalTests: newResults.length,\n      regressionCount: regressions.length,\n      improvementCount: improvements.length,\n      unchangedCount: newResults.length - regressions.length - improvements.length,\n    },\n  };\n}\n\n/**\n * Saves benchmark results to localStorage\n * @param results Benchmark results\n * @param key Storage key\n */\nexport function saveBenchmarkResults(results: BenchmarkResult[], key: string): void {\n  if (typeof localStorage !== 'undefined') {\n    localStorage.setItem(key, JSON.stringify(results));\n  }\n}\n\n/**\n * Loads benchmark results from localStorage\n * @param key Storage key\n * @returns Benchmark results\n */\nexport function loadBenchmarkResults(key: string): BenchmarkResult[] {\n  if (typeof localStorage !== 'undefined') {\n    const stored = localStorage.getItem(key);\n    if (stored) {\n      try {\n        return JSON.parse(stored);\n      } catch (e) {\n        console.error('Failed to parse stored benchmark results', e);\n      }\n    }\n  }\n  return [];\n}\n\n/**\n * Schedulable benchmark job\n */\nexport interface BenchmarkJob {\n  id: string;\n  name: string;\n  description?: string;\n  schedule: 'daily' | 'weekly' | 'onDemand';\n  lastRun?: Date;\n  benchmarks: BenchmarkTestCase[];\n  notifyOnRegression?: boolean;\n  regressionThreshold?: number;\n  baselineKey?: string;\n}\n\n/**\n * Performance Benchmark Manager\n * Manages scheduling and execution of benchmark jobs\n */\nexport class PerformanceBenchmarkManager {\n  private jobs: Map<string, BenchmarkJob> = new Map();\n  private results: Map<string, BenchmarkResult[]> = new Map();\n\n  /**\n   * Registers a benchmark job\n   * @param job Benchmark job\n   */\n  registerJob(job: BenchmarkJob): void {\n    this.jobs.set(job.id, job);\n  }\n\n  /**\n   * Unregisters a benchmark job\n   * @param jobId Job ID\n   */\n  unregisterJob(jobId: string): void {\n    this.jobs.delete(jobId);\n  }\n\n  /**\n   * Gets all registered jobs\n   */\n  getJobs(): BenchmarkJob[] {\n    return Array.from(this.jobs.values());\n  }\n\n  /**\n   * Runs a benchmark job\n   * @param jobId Job ID\n   * @returns Promise resolving to benchmark results\n   */\n  async runJob(jobId: string): Promise<BenchmarkResult[]> {\n    const job = this.jobs.get(jobId);\n    if (!job) {\n      throw new Error(`Job with ID ${jobId} not found`);\n    }\n\n    const results: BenchmarkResult[] = [];\n\n    // Run each benchmark in the job\n    for (const benchmark of job.benchmarks) {\n      try {\n        const result = await Promise.resolve(benchmark.run());\n        results.push({\n          ...result,\n          name: benchmark.name,\n          description: benchmark.description,\n          timestamp: new Date(),\n        });\n      } catch (error) {\n        console.error(`Error running benchmark ${benchmark.name}:`, error);\n      }\n    }\n\n    // Save results\n    this.results.set(jobId, results);\n    job.lastRun = new Date();\n\n    // Check for regressions if needed\n    if (job.notifyOnRegression && job.baselineKey) {\n      const baselineResults = this.results.get(job.baselineKey) || [];\n      const regressionAnalysis = detectPerformanceRegressions(\n        results,\n        baselineResults,\n        job.regressionThreshold\n      );\n\n      if (regressionAnalysis.regressions.length > 0) {\n        this.notifyRegressions(jobId, regressionAnalysis);\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Gets results for a job\n   * @param jobId Job ID\n   */\n  getJobResults(jobId: string): BenchmarkResult[] {\n    return this.results.get(jobId) || [];\n  }\n\n  /**\n   * Notifies about performance regressions\n   * @param jobId Job ID\n   * @param analysis Regression analysis\n   */\n  private notifyRegressions(\n    jobId: string,\n    analysis: ReturnType<typeof detectPerformanceRegressions>\n  ): void {\n    console.warn(`Performance regression detected in job ${jobId}:`);\n    console.table(analysis.regressions);\n    // In a real application, this could send an email, create a Slack notification, etc.\n  }\n}\n\n// Export a singleton instance of the benchmark manager\nexport const benchmarkManager = new PerformanceBenchmarkManager();\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/performance/benchmarks/PerformanceBudgets.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/performance/hookPerformanceMonitor.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/performance/longsession/LongSessionMemoryTracker.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'e' is defined but never used. Allowed unused caught errors must match /^_/u.",
        "line": 332,
        "column": 16,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 332,
        "endColumn": 17
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'e' is defined but never used. Allowed unused caught errors must match /^_/u.",
        "line": 646,
        "column": 16,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 646,
        "endColumn": 17
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * LongSessionMemoryTracker\n *\n * A utility for tracking memory usage over extended application sessions.\n * It helps identify memory leaks and gradual performance degradation that\n * only become apparent with prolonged application use.\n *\n * Features:\n * - Periodic memory snapshots\n * - Memory growth trend analysis\n * - Leak detection with statistical analysis\n * - Timeline visualization data\n * - Memory allocation and garbage collection tracking\n */\n\nimport { moduleEventBus } from '../../../lib/modules/ModuleEvents';\nimport { ModuleType } from '../../../types/events/ModuleEventTypes';\n\n// Define TypeScript interfaces for browser APIs that might not have type definitions\ninterface PerformanceMemory {\n  usedJSHeapSize: number;\n  totalJSHeapSize: number;\n  jsHeapSizeLimit: number;\n}\n\n// Extend the Performance interface to include the memory property\n// Use a module augmentation approach to avoid conflicts with existing definitions\ndeclare global {\n  interface Performance {\n    // Use a non-colliding property name\n    memory?: PerformanceMemory;\n  }\n}\n\n// Extend the Window interface to potentially support manual GC\ndeclare global {\n  interface Window {\n    gc?: () => void;\n  }\n}\n\n/** Memory snapshot data structure */\nexport interface MemorySnapshot {\n  /** Timestamp when the snapshot was taken (ms since epoch) */\n  timestamp: number;\n\n  /** Used JavaScript heap size (MB) */\n  usedHeapSizeMB: number;\n\n  /** Total allocated JavaScript heap size (MB) */\n  totalHeapSizeMB: number;\n\n  /** Maximum JavaScript heap size limit (MB) */\n  heapLimitMB: number;\n\n  /** DOM node count (if available) */\n  domNodeCount?: number;\n\n  /** Number of detached DOM nodes (if available) */\n  detachedDomNodes?: number;\n\n  /** Event listeners count (if available) */\n  eventListenerCount?: number;\n\n  /** Active timers count (if available) */\n  timerCount?: number;\n\n  /** Active animation frames (if available) */\n  animationFrameCount?: number;\n\n  /** Number of large arrays (>10K elements) in memory (if available) */\n  largeArrayCount?: number;\n\n  /** Number of active XHR objects (if available) */\n  xhrCount?: number;\n\n  /** Number of active fetch requests (if available) */\n  fetchCount?: number;\n\n  /** Custom metadata for this snapshot */\n  metadata?: Record<string, unknown>;\n}\n\n/** Memory trend analysis result */\nexport interface MemoryTrendAnalysis {\n  /** Overall trend (positive means growth, negative means reduction) */\n  overallTrend: number;\n\n  /** Growth rate per minute (MB/min) */\n  growthRatePerMinute: number;\n\n  /** Growth rate per hour (MB/hour) */\n  growthRatePerHour: number;\n\n  /** Extrapolated time until memory limit is reached (ms) */\n  estimatedTimeToLimit: number;\n\n  /** Whether memory growth is accelerating */\n  isAccelerating: boolean;\n\n  /** Confidence in this analysis (0-1) */\n  confidence: number;\n\n  /** Whether there is a suspected memory leak */\n  suspectedLeak: boolean;\n\n  /** Potential leak cause if identified */\n  leakCause?: string;\n\n  /** Leak severity (1-5, 5 being most severe) */\n  leakSeverity?: number;\n}\n\n/** Configuration options for the memory tracker */\nexport interface MemoryTrackerOptions {\n  /** Interval between memory snapshots (ms) */\n  snapshotIntervalMs?: number;\n\n  /** Maximum number of snapshots to keep */\n  maxSnapshots?: number;\n\n  /** Whether to attempt to get detailed memory info */\n  detailedMemoryInfo?: boolean;\n\n  /** Whether to track DOM nodes */\n  trackDomNodes?: boolean;\n\n  /** Whether to track detached DOM nodes */\n  trackDetachedNodes?: boolean;\n\n  /** Whether to attempt garbage collection before snapshots */\n  attemptGarbageCollection?: boolean;\n\n  /** Whether to periodically send memory reports to the event bus */\n  reportToEventBus?: boolean;\n\n  /** Report interval in ms (how often to send reports) */\n  reportIntervalMs?: number;\n\n  /** Threshold for leak detection (growth rate in MB/min) */\n  leakThresholdMBPerMinute?: number;\n\n  /** Logging level (0=none, 1=errors, 2=warnings, 3=info) */\n  loggingLevel?: number;\n\n  /** Callback when a memory snapshot is taken */\n  onSnapshot?: (snapshot: MemorySnapshot) => void;\n\n  /** Callback when memory analysis is updated */\n  onAnalysisUpdate?: (analysis: MemoryTrendAnalysis) => void;\n\n  /** Callback when a potential memory leak is detected */\n  onLeakDetected?: (analysis: MemoryTrendAnalysis) => void;\n}\n\n/**\n * Default configuration for memory tracking\n */\nconst DEFAULT_OPTIONS: MemoryTrackerOptions = {\n  snapshotIntervalMs: 60000, // 1 minute\n  maxSnapshots: 120, // 2 hours of data at 1 snapshot per minute\n  detailedMemoryInfo: true,\n  trackDomNodes: true,\n  trackDetachedNodes: false, // Expensive operation, off by default\n  attemptGarbageCollection: false,\n  reportToEventBus: true,\n  reportIntervalMs: 300000, // 5 minutes\n  leakThresholdMBPerMinute: 0.5, // 0.5 MB per minute sustained growth could indicate a leak\n  loggingLevel: 2,\n  onSnapshot: undefined,\n  onAnalysisUpdate: undefined,\n  onLeakDetected: undefined,\n};\n\n/**\n * Core class for tracking memory usage over extended sessions\n */\nexport class LongSessionMemoryTracker {\n  /** Memory snapshots collected over time */\n  private snapshots: MemorySnapshot[] = [];\n\n  /** Timestamp when tracking started */\n  private startTime: number;\n\n  /** Latest memory analysis */\n  private latestAnalysis: MemoryTrendAnalysis | null = null;\n\n  /** Configuration options */\n  private options: MemoryTrackerOptions;\n\n  /** Interval ID for snapshots */\n  private snapshotIntervalId: number | null = null;\n\n  /** Interval ID for reporting */\n  private reportIntervalId: number | null = null;\n\n  /** Whether tracking is currently active */\n  private isTracking = false;\n\n  /** Browser support info */\n  private browserSupport = {\n    memoryAPI: false,\n    performanceAPI: false,\n    domCountAPI: false,\n    gc: false,\n  };\n\n  /** Session markers for significant events */\n  private sessionMarkers: {\n    timestamp: number;\n    name: string;\n    metadata?: Record<string, unknown>;\n  }[] = [];\n\n  /**\n   * Create a new memory tracker\n   */\n  constructor(options: MemoryTrackerOptions = {}) {\n    this.options = { ...DEFAULT_OPTIONS, ...options };\n    this.startTime = Date.now();\n    this.detectBrowserSupport();\n  }\n\n  /**\n   * Detect browser API support\n   */\n  private detectBrowserSupport(): void {\n    // Check Performance API support\n    this.browserSupport.performanceAPI = typeof performance !== 'undefined';\n\n    // Check Memory API support (Chrome)\n    this.browserSupport.memoryAPI =\n      this.browserSupport.performanceAPI && typeof (performance as unknown).memory !== 'undefined';\n\n    // Check DOM Count API support\n    this.browserSupport.domCountAPI =\n      typeof document !== 'undefined' && typeof document.querySelectorAll === 'function';\n\n    // Check GC support (rarely available in browsers)\n    this.browserSupport.gc = typeof window !== 'undefined' && typeof window.gc === 'function';\n\n    if (this.options.loggingLevel && this.options.loggingLevel >= 3) {\n      console.warn('[LongSessionMemoryTracker] Browser support detected:', this.browserSupport);\n    }\n\n    // Warn if memory API not available\n    if (\n      !this.browserSupport.memoryAPI &&\n      this.options.loggingLevel &&\n      this.options.loggingLevel >= 2\n    ) {\n      console.warn(\n        '[LongSessionMemoryTracker] Performance.memory API not available in this browser. Memory tracking will be limited.'\n      );\n    }\n  }\n\n  /**\n   * Start tracking memory usage\n   */\n  public startTracking(): void {\n    if (this.isTracking) return;\n\n    this.isTracking = true;\n    this.startTime = Date.now();\n    this.snapshots = [];\n    this.sessionMarkers = [];\n\n    // Take initial snapshot\n    this.takeSnapshot();\n\n    // Set up periodic snapshots\n    this.snapshotIntervalId = window.setInterval(\n      () => this.takeSnapshot(),\n      this.options.snapshotIntervalMs!\n    );\n\n    // Set up periodic reporting if enabled\n    if (this.options.reportToEventBus) {\n      this.reportIntervalId = window.setInterval(\n        () => this.sendMemoryReport(),\n        this.options.reportIntervalMs!\n      );\n    }\n\n    if (this.options.loggingLevel && this.options.loggingLevel >= 3) {\n      console.warn('[LongSessionMemoryTracker] Started tracking memory usage');\n    }\n\n    // Add session start marker\n    this.addSessionMarker('tracking_started');\n  }\n\n  /**\n   * Stop tracking memory usage\n   */\n  public stopTracking(): void {\n    if (!this.isTracking) return;\n\n    // Clear intervals\n    if (this.snapshotIntervalId !== null) {\n      clearInterval(this.snapshotIntervalId);\n      this.snapshotIntervalId = null;\n    }\n\n    if (this.reportIntervalId !== null) {\n      clearInterval(this.reportIntervalId);\n      this.reportIntervalId = null;\n    }\n\n    this.isTracking = false;\n\n    // Take one final snapshot\n    this.takeSnapshot();\n\n    // Add session end marker\n    this.addSessionMarker('tracking_stopped');\n\n    if (this.options.loggingLevel && this.options.loggingLevel >= 3) {\n      console.warn('[LongSessionMemoryTracker] Stopped tracking memory usage');\n    }\n  }\n\n  /**\n   * Take a memory snapshot\n   */\n  public takeSnapshot(): MemorySnapshot {\n    // Attempt garbage collection if configured and supported\n    if (this.options.attemptGarbageCollection && this.browserSupport.gc) {\n      try {\n        window.gc!();\n      } catch (e) {\n        // Ignore, GC might fail or be unavailable\n      }\n    }\n\n    // Create base snapshot\n    const snapshot: MemorySnapshot = {\n      timestamp: Date.now(),\n      usedHeapSizeMB: 0,\n      totalHeapSizeMB: 0,\n      heapLimitMB: 0,\n    };\n\n    // Add memory info if available\n    if (this.browserSupport.memoryAPI) {\n      // Use explicit casting to access the browser-specific memory properties\n      // This avoids TypeScript errors while still allowing us to access these properties\n      const memoryInfo = (performance as unknown).memory as PerformanceMemory;\n      snapshot.usedHeapSizeMB = memoryInfo.usedJSHeapSize / (1024 * 1024);\n      snapshot.totalHeapSizeMB = memoryInfo.totalJSHeapSize / (1024 * 1024);\n      snapshot.heapLimitMB = memoryInfo.jsHeapSizeLimit / (1024 * 1024);\n    }\n\n    // Count DOM nodes if configured and supported\n    if (this.options.trackDomNodes && this.browserSupport.domCountAPI) {\n      snapshot.domNodeCount = document.querySelectorAll('*').length;\n    }\n\n    // Add to snapshots array, ensuring we don't exceed maximum\n    this.snapshots.push(snapshot);\n    if (this.snapshots.length > this.options.maxSnapshots!) {\n      this.snapshots.shift();\n    }\n\n    // Run analysis after sufficient data is collected\n    if (this.snapshots.length >= 3) {\n      this.analyzeMemoryTrend();\n    }\n\n    // Notify via callback if configured\n    if (this.options.onSnapshot) {\n      this.options.onSnapshot(snapshot);\n    }\n\n    return snapshot;\n  }\n\n  /**\n   * Analyze memory usage trend\n   */\n  private analyzeMemoryTrend(): void {\n    // Need at least 3 snapshots for basic trend analysis\n    if (this.snapshots.length < 3) return;\n\n    const snapshots = this.snapshots;\n    const timeSpanMs = snapshots[snapshots.length - 1].timestamp - snapshots[0].timestamp;\n\n    // Skip analysis if time span is too short (avoid division by zero issues)\n    if (timeSpanMs < 10000) return; // Need at least 10 seconds of data\n\n    // Extract memory usage values\n    const memoryValues = snapshots.map(s => s.usedHeapSizeMB);\n    const timestamps = snapshots.map(s => s.timestamp);\n\n    // Calculate overall trend (linear regression)\n    const { slope, correlation } = this.calculateLinearRegression(timestamps, memoryValues);\n\n    // Calculate rates\n    const growthRatePerMinute = slope * 60000; // Convert to MB per minute\n    const growthRatePerHour = growthRatePerMinute * 60; // Convert to MB per hour\n\n    // Skip processing if we don't have memory limit data\n    let estimatedTimeToLimit = Number.POSITIVE_INFINITY;\n    if (snapshots[snapshots.length - 1].heapLimitMB > 0 && growthRatePerMinute > 0) {\n      const latestSnapshot = snapshots[snapshots.length - 1];\n      const remainingMemoryMB = latestSnapshot.heapLimitMB - latestSnapshot.usedHeapSizeMB;\n      estimatedTimeToLimit = (remainingMemoryMB / growthRatePerMinute) * 60000; // in ms\n    }\n\n    // Detect if growth is accelerating\n    const isAccelerating = this.isGrowthAccelerating(timestamps, memoryValues);\n\n    // Determine confidence level (based on data points and correlation strength)\n    const confidence =\n      Math.min(\n        snapshots.length / 10, // More data points = higher confidence, max at 10 points\n        1 // Cap at 1.0\n      ) * Math.abs(correlation); // Scale by correlation strength\n\n    // Detect potential memory leak\n    const suspectedLeak =\n      growthRatePerMinute > this.options.leakThresholdMBPerMinute! &&\n      confidence > 0.7 &&\n      snapshots.length >= 5; // Need at least 5 data points\n\n    // Create analysis result\n    const analysis: MemoryTrendAnalysis = {\n      overallTrend: slope,\n      growthRatePerMinute,\n      growthRatePerHour,\n      estimatedTimeToLimit,\n      isAccelerating,\n      confidence,\n      suspectedLeak,\n      leakSeverity: suspectedLeak ? this.calculateLeakSeverity(growthRatePerMinute) : undefined,\n    };\n\n    this.latestAnalysis = analysis;\n\n    // Trigger callbacks if configured\n    if (this.options.onAnalysisUpdate) {\n      this.options.onAnalysisUpdate(analysis);\n    }\n\n    // Log potential leak detection\n    if (suspectedLeak) {\n      if (this.options.loggingLevel && this.options.loggingLevel >= 2) {\n        console.warn(\n          `[LongSessionMemoryTracker] Potential memory leak detected! Memory growing at ${growthRatePerMinute.toFixed(2)} MB/minute`\n        );\n      }\n\n      if (this.options.onLeakDetected) {\n        this.options.onLeakDetected(analysis);\n      }\n\n      // Add marker for leak detection\n      this.addSessionMarker('leak_detected', {\n        growthRatePerMinute,\n        severity: analysis.leakSeverity,\n      });\n    }\n  }\n\n  /**\n   * Calculate linear regression on time series data\n   */\n  private calculateLinearRegression(\n    xValues: number[],\n    yValues: number[]\n  ): { slope: number; intercept: number; correlation: number } {\n    const n = xValues.length;\n\n    if (n === 0 || xValues.length !== yValues.length) {\n      return { slope: 0, intercept: 0, correlation: 0 };\n    }\n\n    // Convert timestamps to seconds from start to avoid precision issues\n    const startTime = xValues[0];\n    const xValuesNormalized = xValues.map(x => (x - startTime) / 1000);\n\n    // Calculate means\n    const meanX = xValuesNormalized.reduce((sum, x) => sum + x, 0) / n;\n    const meanY = yValues.reduce((sum, y) => sum + y, 0) / n;\n\n    // Calculate sums for regression formula\n    let numerator = 0;\n    let denominator = 0;\n    let sumSquaredErrors = 0;\n    let totalSumOfSquares = 0;\n\n    for (let i = 0; i < n; i++) {\n      const x = xValuesNormalized[i];\n      const y = yValues[i];\n\n      const xDiff = x - meanX;\n      const yDiff = y - meanY;\n\n      numerator += xDiff * yDiff;\n      denominator += xDiff * xDiff;\n      totalSumOfSquares += yDiff * yDiff;\n    }\n\n    // Avoid division by zero\n    if (denominator === 0) {\n      return { slope: 0, intercept: meanY, correlation: 0 };\n    }\n\n    // Calculate regression parameters\n    const slope = numerator / denominator;\n    const intercept = meanY - slope * meanX;\n\n    // Calculate predicted values and sum of squared errors\n    for (let i = 0; i < n; i++) {\n      const predicted = slope * xValuesNormalized[i] + intercept;\n      sumSquaredErrors += Math.pow(yValues[i] - predicted, 2);\n    }\n\n    // Calculate correlation coefficient\n    let correlation = 0;\n    if (totalSumOfSquares > 0) {\n      correlation = Math.sqrt(1 - sumSquaredErrors / totalSumOfSquares);\n\n      // Adjust sign based on slope\n      if (slope < 0) correlation = -correlation;\n    }\n\n    // Convert slope back to original time units (MB per ms)\n    const originalSlope = slope / 1000;\n\n    return { slope: originalSlope, intercept, correlation };\n  }\n\n  /**\n   * Determine if memory growth is accelerating\n   */\n  private isGrowthAccelerating(timestamps: number[], memoryValues: number[]): boolean {\n    if (timestamps.length < 6) return false; // Need at least 6 points for reliable acceleration detection\n\n    // Split data into first and second half\n    const midpoint = Math.floor(timestamps.length / 2);\n    const firstHalfX = timestamps.slice(0, midpoint);\n    const firstHalfY = memoryValues.slice(0, midpoint);\n    const secondHalfX = timestamps.slice(midpoint);\n    const secondHalfY = memoryValues.slice(midpoint);\n\n    // Calculate growth rate for each half\n    const firstHalfRegression = this.calculateLinearRegression(firstHalfX, firstHalfY);\n    const secondHalfRegression = this.calculateLinearRegression(secondHalfX, secondHalfY);\n\n    // Compare slopes\n    return secondHalfRegression.slope > firstHalfRegression.slope * 1.2; // 20% faster growth = acceleration\n  }\n\n  /**\n   * Calculate leak severity on a scale of 1-5\n   */\n  private calculateLeakSeverity(growthRatePerMinute: number): number {\n    // Scale from 1-5 based on growth rate\n    // 1: slow leak (<1MB/min)\n    // 2: moderate leak (1-2MB/min)\n    // 3: significant leak (2-5MB/min)\n    // 4: serious leak (5-10MB/min)\n    // 5: critical leak (>10MB/min)\n\n    if (growthRatePerMinute >= 10) return 5;\n    if (growthRatePerMinute >= 5) return 4;\n    if (growthRatePerMinute >= 2) return 3;\n    if (growthRatePerMinute >= 1) return 2;\n    return 1;\n  }\n\n  /**\n   * Get all collected memory snapshots\n   */\n  public getSnapshots(): MemorySnapshot[] {\n    return [...this.snapshots];\n  }\n\n  /**\n   * Get the latest memory analysis\n   */\n  public getLatestAnalysis(): MemoryTrendAnalysis | null {\n    return this.latestAnalysis;\n  }\n\n  /**\n   * Add a session marker for significant events\n   */\n  public addSessionMarker(name: string, metadata?: Record<string, unknown>): void {\n    this.sessionMarkers.push({\n      timestamp: Date.now(),\n      name,\n      metadata,\n    });\n  }\n\n  /**\n   * Get all session markers\n   */\n  public getSessionMarkers(): {\n    timestamp: number;\n    name: string;\n    metadata?: Record<string, unknown>;\n  }[] {\n    return [...this.sessionMarkers];\n  }\n\n  /**\n   * Send memory report to event bus\n   */\n  private sendMemoryReport(): void {\n    if (!this.options.reportToEventBus || !this.isTracking || !this.latestAnalysis) return;\n\n    moduleEventBus.emit({\n      type: 'STATUS_CHANGED',\n      moduleId: 'long-session-memory-tracker',\n      moduleType: 'resource-manager' as ModuleType, // Use a valid ModuleType\n      timestamp: Date.now(),\n      data: {\n        type: 'memory_report',\n        snapshots: this.snapshots.slice(-10), // Only send most recent 10 snapshots\n        analysis: this.latestAnalysis,\n        markers: this.sessionMarkers.slice(-5), // Only send most recent 5 markers\n        sessionDurationMs: Date.now() - this.startTime,\n      },\n    });\n  }\n\n  /**\n   * Get total session duration in milliseconds\n   */\n  public getSessionDurationMs(): number {\n    return Date.now() - this.startTime;\n  }\n\n  /**\n   * Force run garbage collection (if supported)\n   */\n  public attemptGarbageCollection(): boolean {\n    if (this.browserSupport.gc && window.gc) {\n      try {\n        window.gc();\n        return true;\n      } catch (e) {\n        // GC failed or unavailable\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Clear all accumulated data (snapshots and markers)\n   */\n  public clearData(): void {\n    this.snapshots = [];\n    this.sessionMarkers = [];\n    this.latestAnalysis = null;\n  }\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/performance/multitab/MultitabCommunicationChannel.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/performance/network/NetworkDegradationSimulator.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'originalOnload' is assigned a value but never used. Allowed unused vars must match /^_/u.",
        "line": 405,
        "column": 11,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 405,
        "endColumn": 25
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'e' is defined but never used. Allowed unused caught errors must match /^_/u.",
        "line": 544,
        "column": 20,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 544,
        "endColumn": 21
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 2,
        "message": "Unexpected any. Specify a different type.",
        "line": 699,
        "column": 74,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 699,
        "endColumn": 77,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [20314, 20317], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [20314, 20317], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'e' is defined but never used. Allowed unused caught errors must match /^_/u.",
        "line": 726,
        "column": 16,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 726,
        "endColumn": 17
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Network Degradation Simulator\n *\n * This utility provides tools for simulating various network conditions to test\n * application performance and resilience under different network scenarios.\n *\n * Key capabilities:\n * - Simulate latency, bandwidth limitations, and packet loss\n * - Apply network degradation to fetch, WebSocket, and XMLHttpRequest\n * - Create realistic network profiles matching common scenarios\n * - Offer programmatic and declarative APIs for testing\n */\n\nexport interface NetworkCondition {\n  /** Name describing this network condition */\n  name: string;\n\n  /** Description with more details about the network condition */\n  description: string;\n\n  /** Network latency in milliseconds (one-way) */\n  latencyMs: number;\n\n  /** Throughput in kilobits per second */\n  throughputKbps: number;\n\n  /** Packet loss probability (0-1) */\n  packetLoss: number;\n\n  /** Latency jitter in milliseconds (variance in latency) */\n  jitterMs: number;\n\n  /** Whether to simulate connection pauses/stalls */\n  enableConnectionStalls: boolean;\n\n  /** Duration of connection stalls in milliseconds */\n  stallDurationMs?: number;\n\n  /** Probability of a stall occurring (0-1) */\n  stallProbability?: number;\n}\n\n/**\n * Pre-defined network condition profiles based on real-world scenarios\n */\nexport const NetworkProfiles: Record<string, NetworkCondition> = {\n  PERFECT: {\n    name: 'Perfect Connection',\n    description: 'Ideal network conditions with no degradation',\n    latencyMs: 0,\n    throughputKbps: 1000000, // 1 Gbps\n    packetLoss: 0,\n    jitterMs: 0,\n    enableConnectionStalls: false,\n  },\n\n  FAST_WIFI: {\n    name: 'Fast WiFi',\n    description: 'Strong, fast home WiFi connection',\n    latencyMs: 5,\n    throughputKbps: 50000, // 50 Mbps\n    packetLoss: 0.001, // 0.1%\n    jitterMs: 2,\n    enableConnectionStalls: false,\n  },\n\n  AVERAGE_WIFI: {\n    name: 'Average WiFi',\n    description: 'Typical home WiFi connection',\n    latencyMs: 20,\n    throughputKbps: 15000, // 15 Mbps\n    packetLoss: 0.005, // 0.5%\n    jitterMs: 5,\n    enableConnectionStalls: false,\n  },\n\n  SLOW_WIFI: {\n    name: 'Slow WiFi',\n    description: 'Weak or distant WiFi connection',\n    latencyMs: 40,\n    throughputKbps: 3000, // 3 Mbps\n    packetLoss: 0.02, // 2%\n    jitterMs: 10,\n    enableConnectionStalls: true,\n    stallDurationMs: 500,\n    stallProbability: 0.01,\n  },\n\n  FIVE_G: {\n    name: '5G Connection',\n    description: 'Strong 5G mobile connection',\n    latencyMs: 30,\n    throughputKbps: 30000, // 30 Mbps\n    packetLoss: 0.003, // 0.3%\n    jitterMs: 8,\n    enableConnectionStalls: false,\n  },\n\n  FOUR_G: {\n    name: '4G Connection',\n    description: 'Typical 4G/LTE mobile connection',\n    latencyMs: 80,\n    throughputKbps: 5000, // 5 Mbps\n    packetLoss: 0.01, // 1%\n    jitterMs: 15,\n    enableConnectionStalls: true,\n    stallDurationMs: 300,\n    stallProbability: 0.015,\n  },\n\n  THREE_G: {\n    name: '3G Connection',\n    description: 'Older 3G mobile connection',\n    latencyMs: 200,\n    throughputKbps: 750, // 750 Kbps\n    packetLoss: 0.03, // 3%\n    jitterMs: 25,\n    enableConnectionStalls: true,\n    stallDurationMs: 800,\n    stallProbability: 0.03,\n  },\n\n  EDGE: {\n    name: 'EDGE Connection',\n    description: 'Edge/2G mobile connection in rural areas',\n    latencyMs: 400,\n    throughputKbps: 250, // 250 Kbps\n    packetLoss: 0.05, // 5%\n    jitterMs: 40,\n    enableConnectionStalls: true,\n    stallDurationMs: 1500,\n    stallProbability: 0.05,\n  },\n\n  SATELLITE: {\n    name: 'Satellite Connection',\n    description: 'High-latency satellite internet',\n    latencyMs: 600,\n    throughputKbps: 1000, // 1 Mbps\n    packetLoss: 0.02, // 2%\n    jitterMs: 50,\n    enableConnectionStalls: true,\n    stallDurationMs: 2000,\n    stallProbability: 0.025,\n  },\n\n  POOR_NETWORK: {\n    name: 'Poor Network',\n    description: 'Unreliable network with high packet loss',\n    latencyMs: 300,\n    throughputKbps: 500, // 500 Kbps\n    packetLoss: 0.1, // 10%\n    jitterMs: 100,\n    enableConnectionStalls: true,\n    stallDurationMs: 3000,\n    stallProbability: 0.08,\n  },\n\n  AIRPLANE_WIFI: {\n    name: 'Airplane WiFi',\n    description: 'Typical in-flight WiFi connection',\n    latencyMs: 750,\n    throughputKbps: 300, // 300 Kbps\n    packetLoss: 0.08, // 8%\n    jitterMs: 150,\n    enableConnectionStalls: true,\n    stallDurationMs: 5000,\n    stallProbability: 0.1,\n  },\n\n  INTERNATIONAL: {\n    name: 'International Connection',\n    description: 'Connection to server in a different continent',\n    latencyMs: 350,\n    throughputKbps: 2000, // 2 Mbps\n    packetLoss: 0.03, // 3%\n    jitterMs: 30,\n    enableConnectionStalls: true,\n    stallDurationMs: 1000,\n    stallProbability: 0.02,\n  },\n\n  // This is effectively a disconnected state with occasional successful packets\n  SEVERELY_DEGRADED: {\n    name: 'Severely Degraded',\n    description: 'Almost unusable connection with extreme packet loss',\n    latencyMs: 1000,\n    throughputKbps: 50, // 50 Kbps\n    packetLoss: 0.5, // 50%\n    jitterMs: 500,\n    enableConnectionStalls: true,\n    stallDurationMs: 10000,\n    stallProbability: 0.2,\n  },\n\n  OFFLINE: {\n    name: 'Offline',\n    description: 'No connectivity (100% packet loss)',\n    latencyMs: 0,\n    throughputKbps: 0,\n    packetLoss: 1.0, // 100%\n    jitterMs: 0,\n    enableConnectionStalls: false,\n  },\n};\n\n/**\n * Stores original network-related methods to restore them later\n */\nconst originalMethods = {\n  fetch: typeof window !== 'undefined' ? window.fetch : null,\n  XMLHttpRequest:\n    typeof XMLHttpRequest !== 'undefined'\n      ? {\n          open: XMLHttpRequest.prototype.open,\n          send: XMLHttpRequest.prototype.send,\n        }\n      : null,\n  setTimeout: setTimeout,\n  WebSocket: typeof WebSocket !== 'undefined' ? WebSocket : null,\n};\n\n/**\n * Network degradation simulation state\n */\ninterface SimulationState {\n  enabled: boolean;\n  currentCondition: NetworkCondition | null;\n  proxiedFetch: boolean;\n  proxiedXHR: boolean;\n  proxiedWebSocket: boolean;\n}\n\n/**\n * Current state of the network degradation simulator\n */\nconst simulationState: SimulationState = {\n  enabled: false,\n  currentCondition: null,\n  proxiedFetch: false,\n  proxiedXHR: false,\n  proxiedWebSocket: false,\n};\n\n/**\n * Calculate actual delay based on network condition parameters\n * @param condition The network condition\n */\nfunction calculateDelay(condition: NetworkCondition): number {\n  if (!condition) return 0;\n\n  // Base latency\n  let delay = condition.latencyMs;\n\n  // Add jitter (random variance in latency)\n  if (condition.jitterMs > 0) {\n    delay += (Math.random() * 2 - 1) * condition.jitterMs;\n  }\n\n  // Ensure delay is never negative\n  return Math.max(0, delay);\n}\n\n/**\n * Simulate connection stall if enabled in the network condition\n * @param condition The network condition\n */\nfunction simulateConnectionStall(condition: NetworkCondition): Promise<void> {\n  if (\n    !condition.enableConnectionStalls ||\n    typeof condition.stallProbability !== 'number' ||\n    typeof condition.stallDurationMs !== 'number'\n  ) {\n    return Promise.resolve();\n  }\n\n  // Determine if a stall should occur\n  if (Math.random() < condition.stallProbability) {\n    return new Promise(resolve => {\n      setTimeout(resolve, condition.stallDurationMs);\n    });\n  }\n\n  return Promise.resolve();\n}\n\n/**\n * Simulate packet loss based on the network condition\n * @param condition The network condition\n * @throws Error if packet is \"lost\"\n */\nfunction simulatePacketLoss(condition: NetworkCondition): void {\n  if (Math.random() < condition.packetLoss) {\n    throw new Error(`Network error: Simulated packet loss (${condition.name})`);\n  }\n}\n\n/**\n * Calculate delay for a data transfer based on throughput\n * @param byteSize Size of data in bytes\n * @param condition The network condition\n */\nfunction calculateThroughputDelay(byteSize: number, condition: NetworkCondition): number {\n  if (!condition || condition.throughputKbps <= 0) return 0;\n\n  // Convert bytes to bits and calculate transfer time in seconds\n  const bits = byteSize * 8;\n  const seconds = bits / (condition.throughputKbps * 1000);\n\n  // Convert to milliseconds\n  return seconds * 1000;\n}\n\n/**\n * Apply network degradation to fetch API\n * @param condition The network condition to apply\n */\nfunction proxyFetch(condition: NetworkCondition): void {\n  if (typeof window === 'undefined' || !window.fetch || simulationState.proxiedFetch) return;\n\n  // Store original fetch\n  const originalFetch = window.fetch;\n\n  // Override fetch with degraded version\n  window.fetch = async (input: RequestInfo | URL, init?: RequestInit) => {\n    if (!simulationState.enabled) {\n      return originalFetch(input, init);\n    }\n\n    try {\n      // Simulate initial latency (request)\n      const latency = calculateDelay(condition);\n      await new Promise(resolve => setTimeout(resolve, latency));\n\n      // Simulate connection stalls\n      await simulateConnectionStall(condition);\n\n      // Simulate packet loss\n      simulatePacketLoss(condition);\n\n      // Make the actual request\n      const response = await originalFetch(input, init);\n\n      // Clone the response to access its body\n      const clone = response.clone();\n      const text = await clone.text();\n\n      // Calculate throughput delay based on response size\n      const byteSize = new TextEncoder().encode(text).length;\n      const throughputDelay = calculateThroughputDelay(byteSize, condition);\n\n      // Simulate response latency + throughput delay\n      await new Promise(resolve => setTimeout(resolve, latency + throughputDelay));\n\n      // Simulate packet loss again (for response)\n      simulatePacketLoss(condition);\n\n      // Create a new response with the same data\n      return new Response(text, {\n        status: response.status,\n        statusText: response.statusText,\n        headers: response.headers,\n      });\n    } catch (error) {\n      if (error.message.includes('Simulated packet loss')) {\n        throw new TypeError('NetworkError when attempting to fetch resource');\n      }\n      throw error;\n    }\n  };\n\n  simulationState.proxiedFetch = true;\n}\n\n/**\n * Apply network degradation to XMLHttpRequest\n * @param condition The network condition to apply\n */\nfunction proxyXHR(condition: NetworkCondition): void {\n  if (typeof XMLHttpRequest === 'undefined' || simulationState.proxiedXHR) return;\n\n  // Store original XHR methods\n  const originalOpen = XMLHttpRequest.prototype.open;\n  const originalSend = XMLHttpRequest.prototype.send;\n\n  // Override XHR open method\n  XMLHttpRequest.prototype.open = function (this: XMLHttpRequest, ...args: unknown[]) {\n    // Store network condition in the XHR instance\n    (this as unknown).__networkCondition = simulationState.enabled ? condition : null;\n    return originalOpen.apply(this, args);\n  };\n\n  // Override XHR send method\n  XMLHttpRequest.prototype.send = function (this: XMLHttpRequest, ...args: unknown[]) {\n    const xhrNetworkCondition = (this as unknown).__networkCondition;\n\n    if (!xhrNetworkCondition) {\n      return originalSend.apply(this, args);\n    }\n\n    // Calculate request latency\n    const latency = calculateDelay(xhrNetworkCondition);\n\n    // Store original callbacks\n    const originalOnload = this.onload;\n    const originalOnerror = this.onerror;\n    const originalOnreadystatechange = this.onreadystatechange;\n\n    // Simulate packet loss\n    if (Math.random() < xhrNetworkCondition.packetLoss) {\n      setTimeout(() => {\n        if (typeof originalOnerror === 'function') {\n          const errorEvent = new ErrorEvent('error', {\n            message: 'Simulated packet loss',\n          });\n          originalOnerror.call(this, errorEvent);\n        }\n      }, latency);\n\n      return;\n    }\n\n    // Handle readystatechange\n    this.onreadystatechange = function (this: XMLHttpRequest, ...rsArgs: unknown[]) {\n      if (this.readyState === 4) {\n        // Calculate throughput delay for the response\n        let throughputDelay = 0;\n        if (this.responseText) {\n          const byteSize = new TextEncoder().encode(this.responseText).length;\n          throughputDelay = calculateThroughputDelay(byteSize, xhrNetworkCondition);\n        }\n\n        // Delay the readystatechange with both latency and throughput delay\n        setTimeout(() => {\n          if (typeof originalOnreadystatechange === 'function') {\n            originalOnreadystatechange.apply(this, rsArgs);\n          }\n        }, latency + throughputDelay);\n\n        return;\n      }\n\n      if (typeof originalOnreadystatechange === 'function') {\n        originalOnreadystatechange.apply(this, rsArgs);\n      }\n    };\n\n    // Delay the actual send\n    setTimeout(() => {\n      originalSend.apply(this, args);\n    }, latency);\n  };\n\n  simulationState.proxiedXHR = true;\n}\n\n/**\n * Apply network degradation to WebSocket\n * @param condition The network condition to apply\n */\nfunction proxyWebSocket(condition: NetworkCondition): void {\n  if (typeof WebSocket === 'undefined' || simulationState.proxiedWebSocket) return;\n\n  // Store original WebSocket constructor\n  const OriginalWebSocket = WebSocket;\n\n  // Create a proxy WebSocket class\n  class DegradedWebSocket extends OriginalWebSocket {\n    constructor(...args: unknown[]) {\n      super(...args);\n\n      if (!simulationState.enabled) return;\n\n      // Store original event handlers\n      const originalOnopen = this.onopen;\n      const originalOnmessage = this.onmessage;\n      const originalOnclose = this.onclose;\n      const originalOnerror = this.onerror;\n\n      // Apply connection latency for open event\n      this.onopen = function (this: WebSocket, ev: Event) {\n        setTimeout(() => {\n          if (typeof originalOnopen === 'function') {\n            originalOnopen.call(this, ev);\n          }\n        }, calculateDelay(condition));\n      };\n\n      // Apply latency and packet loss to messages\n      this.onmessage = function (this: WebSocket, ev: MessageEvent) {\n        // Simulate packet loss\n        if (Math.random() < condition.packetLoss) {\n          return; // Message lost\n        }\n\n        // Calculate message throughput delay\n        let throughputDelay = 0;\n        if (typeof ev.data === 'string') {\n          const byteSize = new TextEncoder().encode(ev.data).length;\n          throughputDelay = calculateThroughputDelay(byteSize, condition);\n        } else if (ev.data instanceof Blob) {\n          throughputDelay = calculateThroughputDelay(ev.data.size, condition);\n        } else if (ev.data instanceof ArrayBuffer) {\n          throughputDelay = calculateThroughputDelay(ev.data.byteLength, condition);\n        }\n\n        // Delay message by latency + throughput\n        setTimeout(\n          () => {\n            if (typeof originalOnmessage === 'function') {\n              originalOnmessage.call(this, ev);\n            }\n          },\n          calculateDelay(condition) + throughputDelay\n        );\n      };\n\n      // Store other callbacks\n      this.onclose = originalOnclose;\n      this.onerror = originalOnerror;\n\n      // Override send method to add latency and packet loss\n      const originalSend = this.send;\n      this.send = function (\n        this: WebSocket,\n        data: string | ArrayBufferLike | Blob | ArrayBufferView\n      ) {\n        // Simulate packet loss for outgoing messages\n        if (Math.random() < condition.packetLoss) {\n          // Trigger error for lost packet\n          if (typeof this.onerror === 'function') {\n            const errorEvent = new ErrorEvent('error', {\n              message: 'Simulated packet loss for outgoing message',\n            });\n            this.onerror.call(this, errorEvent as Event);\n          }\n          return;\n        }\n\n        // Calculate latency\n        setTimeout(() => {\n          try {\n            originalSend.call(this, data);\n          } catch (e) {\n            if (typeof this.onerror === 'function') {\n              this.onerror.call(this, new Event('error'));\n            }\n          }\n        }, calculateDelay(condition));\n      };\n    }\n  }\n\n  // Replace global WebSocket with our degraded version\n  window.WebSocket = DegradedWebSocket as unknown;\n\n  simulationState.proxiedWebSocket = true;\n}\n\n/**\n * Interface for options when enabling network degradation\n */\nexport interface EnableOptions {\n  /** Whether to proxy fetch API */\n  proxyFetch?: boolean;\n\n  /** Whether to proxy XMLHttpRequest */\n  proxyXHR?: boolean;\n\n  /** Whether to proxy WebSocket */\n  proxyWebSocket?: boolean;\n}\n\n/**\n * Enable network degradation simulation with specified conditions\n * @param condition The network condition to simulate\n * @param options Options for enabling network degradation\n */\nexport function enableNetworkDegradation(\n  condition: NetworkCondition,\n  options: EnableOptions = { proxyFetch: true, proxyXHR: true, proxyWebSocket: true }\n): void {\n  // Already enabled with same condition - do nothing\n  if (simulationState.enabled && simulationState.currentCondition?.name === condition.name) {\n    return;\n  }\n\n  // If previously enabled with different condition, disable first\n  if (simulationState.enabled) {\n    disableNetworkDegradation();\n  }\n\n  // Update simulation state\n  simulationState.enabled = true;\n  simulationState.currentCondition = condition;\n\n  // Apply proxies based on options\n  if (options.proxyFetch !== false) {\n    proxyFetch(condition);\n  }\n\n  if (options.proxyXHR !== false) {\n    proxyXHR(condition);\n  }\n\n  if (options.proxyWebSocket !== false) {\n    proxyWebSocket(condition);\n  }\n\n  console.warn(`Network degradation simulation enabled: ${condition.name}`);\n  console.warn(\n    `  Latency: ${condition.latencyMs}ms, Throughput: ${condition.throughputKbps}Kbps, Packet Loss: ${condition.packetLoss * 100}%`\n  );\n}\n\n/**\n * Disable network degradation simulation and restore original behavior\n */\nexport function disableNetworkDegradation(): void {\n  if (!simulationState.enabled) return;\n\n  // Restore original methods\n  if (simulationState.proxiedFetch && typeof window !== 'undefined' && originalMethods.fetch) {\n    window.fetch = originalMethods.fetch;\n    simulationState.proxiedFetch = false;\n  }\n\n  if (\n    simulationState.proxiedXHR &&\n    typeof XMLHttpRequest !== 'undefined' &&\n    originalMethods.XMLHttpRequest\n  ) {\n    XMLHttpRequest.prototype.open = originalMethods.XMLHttpRequest.open;\n    XMLHttpRequest.prototype.send = originalMethods.XMLHttpRequest.send;\n    simulationState.proxiedXHR = false;\n  }\n\n  if (\n    simulationState.proxiedWebSocket &&\n    typeof window !== 'undefined' &&\n    originalMethods.WebSocket\n  ) {\n    window.WebSocket = originalMethods.WebSocket;\n    simulationState.proxiedWebSocket = false;\n  }\n\n  // Reset simulation state\n  simulationState.enabled = false;\n  simulationState.currentCondition = null;\n\n  console.warn('Network degradation simulation disabled');\n}\n\n/**\n * Get the current network condition being simulated\n * @returns The current network condition or null if disabled\n */\nexport function getCurrentNetworkCondition(): NetworkCondition | null {\n  return simulationState.enabled ? simulationState.currentCondition : null;\n}\n\n/**\n * Check if network degradation simulation is enabled\n * @returns True if enabled, false otherwise\n */\nexport function isNetworkDegradationEnabled(): boolean {\n  return simulationState.enabled;\n}\n\n/**\n * Create a custom network condition\n * @param config Configuration for the custom network condition\n * @returns A new NetworkCondition object\n */\nexport function createCustomNetworkCondition(\n  config: Partial<NetworkCondition> & { name: string }\n): NetworkCondition {\n  return {\n    description: config.description || 'Custom network condition',\n    latencyMs: config.latencyMs || 0,\n    throughputKbps: config.throughputKbps || 1000000,\n    packetLoss: config.packetLoss || 0,\n    jitterMs: config.jitterMs || 0,\n    enableConnectionStalls: config.enableConnectionStalls || false,\n    stallDurationMs: config.stallDurationMs,\n    stallProbability: config.stallProbability,\n    ...config,\n  };\n}\n\n/**\n * Apply network degradation to a specific function or Promise\n * Useful for targeted testing without affecting the entire application\n *\n * @param condition The network condition to simulate\n * @param fn The function to degrade\n * @returns A new function with network degradation applied\n */\nexport function withNetworkDegradation<T extends (...args: unknown[]) => any>(\n  condition: NetworkCondition,\n  fn: T\n): (...args: Parameters<T>) => Promise<ReturnType<T>> {\n  return async (...args: Parameters<T>): Promise<ReturnType<T>> => {\n    // Initial request latency\n    const latency = calculateDelay(condition);\n    await new Promise(resolve => setTimeout(resolve, latency));\n\n    // Simulate connection stall\n    await simulateConnectionStall(condition);\n\n    // Simulate packet loss\n    if (Math.random() < condition.packetLoss) {\n      throw new Error(`Network error: Simulated packet loss (${condition.name})`);\n    }\n\n    // Call the original function\n    const result = await fn(...args);\n\n    // Calculate response size for throughput\n    let byteSize = 1000; // Default size estimate\n\n    if (result && typeof result === 'object') {\n      try {\n        const resultString = JSON.stringify(result);\n        byteSize = new TextEncoder().encode(resultString).length;\n      } catch (e) {\n        // Ignore, use default size\n      }\n    } else if (typeof result === 'string') {\n      byteSize = new TextEncoder().encode(result).length;\n    }\n\n    // Calculate throughput delay\n    const throughputDelay = calculateThroughputDelay(byteSize, condition);\n\n    // Response latency\n    await new Promise(resolve => setTimeout(resolve, latency + throughputDelay));\n\n    // Response packet loss\n    if (Math.random() < condition.packetLoss) {\n      throw new Error(`Network error: Simulated packet loss (${condition.name})`);\n    }\n\n    return result;\n  };\n}\n\n/**\n * Run a test under simulated network conditions\n * @param condition The network condition to simulate\n * @param testFn The test function to run\n * @param options Options for enabling network degradation\n * @returns The result of the test function\n */\nexport async function runWithNetworkCondition<T>(\n  condition: NetworkCondition,\n  testFn: () => Promise<T>,\n  options?: EnableOptions\n): Promise<T> {\n  try {\n    // Enable network degradation\n    enableNetworkDegradation(condition, options);\n\n    // Run the test\n    return await testFn();\n  } finally {\n    // Always disable network degradation when done\n    disableNetworkDegradation();\n  }\n}\n\n/**\n * Run the same test across multiple network conditions\n * @param testFn The test function to run\n * @param conditions The network conditions to test with\n * @param options Options for enabling network degradation\n * @returns Array of results for each network condition\n */\nexport async function runAcrossNetworkConditions<T>(\n  testFn: (condition: NetworkCondition) => Promise<T>,\n  conditions: NetworkCondition[] = Object.values(NetworkProfiles),\n  options?: EnableOptions\n): Promise<Array<{ condition: NetworkCondition; result: T }>> {\n  const results: Array<{ condition: NetworkCondition; result: T }> = [];\n\n  for (const condition of conditions) {\n    try {\n      // Enable network degradation for this condition\n      enableNetworkDegradation(condition, options);\n\n      // Run the test\n      const result = await testFn(condition);\n\n      // Store result\n      results.push({ condition, result });\n    } catch (error) {\n      // Store error as result\n      results.push({\n        condition,\n        result: { error, message: error.message } as unknown as T,\n      });\n    } finally {\n      // Disable network degradation between tests\n      disableNetworkDegradation();\n    }\n  }\n\n  return results;\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/preload.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/profiling/applicationProfiler.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/profiling/componentProfiler.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/profiling/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/resources/ResourceTypeConverter.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/resources/ResourceTypeMigration.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'EnumResourceType' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 12,
        "column": 6,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 12,
        "endColumn": 22
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Resource Type Migration Utility\n *\n * This utility provides functions to help migrate from string-based resource types\n * to enum-based resource types. It includes functions for converting string literals,\n * object keys, arrays, and more.\n */\n\nimport { ResourceType, ResourceTypeString } from './../../types/resources/ResourceTypes';\n\n// Define type aliases for clarity in migration functions\ntype EnumResourceType = ResourceType;\ntype StringResourceType = ResourceTypeString;\n\n/**\n * Generates a migration guide for resource types\n * @returns A markdown string with a migration guide\n */\nexport function generateMigrationGuide(): string {\n  let guide = `# Resource Type Migration Guide\\n\\n`;\n  guide += `This guide helps you migrate from string-based resource types to enum-based resource types.\\n\\n`;\n  guide += `## Mapping Table\\n\\n`;\n  guide += `| String Type | Enum Type |\\n`;\n  guide += `|------------|----------|\\n`;\n\n  // Manually create the mapping table to avoid type issues\n  guide += `| ResourceType.MINERALS | ResourceType.MINERALS |\\n`;\n  guide += `| ResourceType.ENERGY | ResourceType.ENERGY |\\n`;\n  guide += `| ResourceType.POPULATION | ResourceType.POPULATION |\\n`;\n  guide += `| ResourceType.RESEARCH | ResourceType.RESEARCH |\\n`;\n  guide += `| ResourceType.PLASMA | ResourceType.PLASMA |\\n`;\n  guide += `| ResourceType.GAS | ResourceType.GAS |\\n`;\n  guide += `| ResourceType.EXOTIC | ResourceType.EXOTIC |\\n`;\n\n  guide += `\\n## Migration Steps\\n\\n`;\n  guide += `1. Update imports to use ResourceTypes instead of any other resource type definition\\n`;\n  guide += `2. Replace string literals with enum values using the mapping table above\\n`;\n  guide += `3. Update function signatures to use the enum type\\n`;\n  guide += `4. Use the migration utility functions for complex cases\\n`;\n\n  return guide;\n}\n\n/**\n * Maps string resource types to enum resource types\n */\nconst STRING_TO_ENUM_MAP: Record<StringResourceType, ResourceType> = {\n  minerals: ResourceType.MINERALS,\n  energy: ResourceType.ENERGY,\n  population: ResourceType.POPULATION,\n  research: ResourceType.RESEARCH,\n  plasma: ResourceType.PLASMA,\n  gas: ResourceType.GAS,\n  exotic: ResourceType.EXOTIC,\n};\n\n/**\n * Maps enum resource types to string resource types\n */\nconst ENUM_TO_STRING_MAP: Record<ResourceType, StringResourceType | string> = {\n  [ResourceType.MINERALS]: ResourceType.MINERALS,\n  [ResourceType.ENERGY]: ResourceType.ENERGY,\n  [ResourceType.POPULATION]: ResourceType.POPULATION,\n  [ResourceType.RESEARCH]: ResourceType.RESEARCH,\n  [ResourceType.PLASMA]: ResourceType.PLASMA,\n  [ResourceType.GAS]: ResourceType.GAS,\n  [ResourceType.EXOTIC]: ResourceType.EXOTIC,\n  // Map additional types to their closest string equivalent or default\n  [ResourceType.IRON]: ResourceType.MINERALS,\n  [ResourceType.COPPER]: ResourceType.MINERALS,\n  [ResourceType.TITANIUM]: ResourceType.MINERALS,\n  [ResourceType.URANIUM]: ResourceType.MINERALS,\n  [ResourceType.WATER]: ResourceType.MINERALS,\n  [ResourceType.HELIUM]: ResourceType.GAS,\n  [ResourceType.DEUTERIUM]: ResourceType.GAS,\n  [ResourceType.ANTIMATTER]: ResourceType.EXOTIC,\n  [ResourceType.DARK_MATTER]: ResourceType.EXOTIC,\n  [ResourceType.EXOTIC_MATTER]: ResourceType.EXOTIC,\n};\n\n/**\n * Converts a string resource type to an enum resource type\n * @param resourceType The string resource type\n * @returns The enum ResourceType\n */\nexport function toEnumResourceType(resourceType: StringResourceType): ResourceType {\n  if (!(resourceType in STRING_TO_ENUM_MAP)) {\n    console.warn(`Unknown resource type: ${resourceType}, defaulting to MINERALS`);\n    return ResourceType.MINERALS;\n  }\n  return STRING_TO_ENUM_MAP[resourceType];\n}\n\n/**\n * Converts an enum resource type to a string resource type\n * @param resourceType The enum resource type\n * @returns The string resource type\n */\nexport function toStringResourceType(resourceType: ResourceType): StringResourceType | string {\n  if (!(resourceType in ENUM_TO_STRING_MAP)) {\n    console.warn(`Unknown resource type: ${resourceType}, defaulting to minerals`);\n    return ResourceType.MINERALS;\n  }\n  return ENUM_TO_STRING_MAP[resourceType];\n}\n\n/**\n * Checks if a value is a valid string resource type\n * @param value The value to check\n * @returns Whether the value is a valid string resource type\n */\nexport function isStringResourceType(value: unknown): value is StringResourceType {\n  return typeof value === 'string' && value in STRING_TO_ENUM_MAP;\n}\n\n/**\n * Checks if a value is a valid enum resource type\n * @param value The value to check\n * @returns Whether the value is a valid enum resource type\n */\nexport function isEnumResourceType(value: unknown): value is ResourceType {\n  return typeof value === 'string' && Object.values(ResourceType).includes(value as ResourceType);\n}\n\n/**\n * Ensures a value is an enum resource type\n * @param resourceType Either a string resource type or an enum resource type\n * @returns The enum ResourceType\n */\nexport function ensureEnumResourceType(\n  resourceType: StringResourceType | ResourceType\n): ResourceType {\n  // If it's already an enum type, return it\n  if (Object.values(ResourceType).includes(resourceType as ResourceType)) {\n    return resourceType as ResourceType;\n  }\n\n  // Otherwise, convert it\n  return toEnumResourceType(resourceType as StringResourceType);\n}\n\n/**\n * Ensures a value is a string resource type\n * @param value The value to ensure is a string resource type\n * @returns The string resource type\n * @throws Error if the value cannot be converted to a string resource type\n */\nexport function ensureStringResourceType(value: unknown): StringResourceType | string {\n  if (isStringResourceType(value)) {\n    return value;\n  }\n\n  if (isEnumResourceType(value)) {\n    return toStringResourceType(value);\n  }\n\n  console.warn(`Unknown resource type: ${value}, defaulting to minerals`);\n  return ResourceType.MINERALS;\n}\n\n/**\n * Converts an array of items with resource types from string to enum\n * @param array The array to convert\n * @param converter The conversion function\n * @returns The converted array\n */\nexport function convertArrayResourceTypes<T>(array: T[], converter: (item: T) => T): T[] {\n  return array.map(converter);\n}\n\n/**\n * Converts a record with string resource type keys to enum resource type keys\n * @param record The record to convert\n * @returns The converted record\n */\nexport function convertRecordResourceTypes<T>(\n  record: Record<StringResourceType, T>\n): Record<ResourceType, T> {\n  const result: Record<ResourceType, T> = {} as Record<ResourceType, T>;\n  for (const [key, value] of Object.entries(record)) {\n    if (isStringResourceType(key)) {\n      result[toEnumResourceType(key)] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * Converts a map with string resource type keys to enum resource type keys\n * @param map The map to convert\n * @returns The converted map\n */\nexport function convertMapResourceTypes<T>(map: Map<StringResourceType, T>): Map<ResourceType, T> {\n  const result = new Map<ResourceType, T>();\n  // Use Array.from to avoid iterator issues\n  Array.from(map.entries()).forEach(([key, value]) => {\n    result.set(toEnumResourceType(key), value);\n  });\n  return result;\n}\n\n/**\n * Analyzes a file for resource type migration needs\n * @param fileContent The file content to analyze\n * @returns Analysis results\n */\nexport function analyzeMigrationNeeds(fileContent: string): {\n  stringResourceTypes: number;\n  enumResourceTypes: number;\n  mixedUsage: boolean;\n} {\n  const stringMatches = (\n    fileContent.match(\n      /['\"]minerals['\"]|['\"]energy['\"]|['\"]population['\"]|['\"]research['\"]|['\"]plasma['\"]|['\"]gas['\"]|['\"]exotic['\"]/g\n    ) || []\n  ).length;\n  const enumMatches = (\n    fileContent.match(\n      /ResourceType\\.MINERALS|ResourceType\\.ENERGY|ResourceType\\.POPULATION|ResourceType\\.RESEARCH|ResourceType\\.PLASMA|ResourceType\\.GAS|ResourceType\\.EXOTIC/g\n    ) || []\n  ).length;\n\n  return {\n    stringResourceTypes: stringMatches,\n    enumResourceTypes: enumMatches,\n    mixedUsage: stringMatches > 0 && enumMatches > 0,\n  };\n}\n\n/**\n * Applies migration to a file content\n * @param fileContent The file content to migrate\n * @returns The migrated file content\n */\nexport function applyMigration(fileContent: string): string {\n  let result = fileContent;\n\n  // Replace string literals with enum values\n  result = result.replace(/['\"]minerals['\"]/g, 'ResourceType.MINERALS');\n  result = result.replace(/['\"]energy['\"]/g, 'ResourceType.ENERGY');\n  result = result.replace(/['\"]population['\"]/g, 'ResourceType.POPULATION');\n  result = result.replace(/['\"]research['\"]/g, 'ResourceType.RESEARCH');\n  result = result.replace(/['\"]plasma['\"]/g, 'ResourceType.PLASMA');\n  result = result.replace(/['\"]gas['\"]/g, 'ResourceType.GAS');\n  result = result.replace(/['\"]exotic['\"]/g, 'ResourceType.EXOTIC');\n\n  return result;\n}\n\n/**\n * Checks if a file needs migration\n * @param fileContent The file content to check\n * @returns Whether the file needs migration\n */\nexport function needsMigration(fileContent: string): boolean {\n  const { stringResourceTypes, enumResourceTypes } = analyzeMigrationNeeds(fileContent);\n  return stringResourceTypes > 0 && enumResourceTypes === 0;\n}\n\n/**\n * Creates a compatibility layer for functions that need to work with both string and enum resource types\n * @param original The original function\n * @param parameterIndices The indices of parameters to convert\n * @param convertToEnum Whether to convert to enum (true) or string (false)\n * @returns The wrapped function\n */\nexport function createResourceTypeCompatibilityLayer<T extends (...args: unknown[]) => unknown>(\n  original: T,\n  parameterIndices: number[],\n  convertToEnum: boolean\n): T {\n  return ((...args: unknown[]) => {\n    const newArgs = [...args];\n    for (const index of parameterIndices) {\n      if (index >= args.length) continue;\n\n      if (convertToEnum) {\n        newArgs[index] = ensureEnumResourceType(args[index] as StringResourceType | ResourceType);\n      } else {\n        newArgs[index] = ensureStringResourceType(args[index]);\n      }\n    }\n    return original(...newArgs);\n  }) as T;\n}\n\n/**\n * Migrates object keys from string resource types to enum resource types\n * @param obj The object to migrate\n * @returns The migrated object\n */\nexport function migrateObjectKeys<T>(obj: Record<StringResourceType, T>): Record<ResourceType, T> {\n  const result: Partial<Record<ResourceType, T>> = {};\n\n  for (const [key, value] of Object.entries(obj)) {\n    if (isStringResourceType(key)) {\n      result[toEnumResourceType(key as StringResourceType)] = value;\n    }\n  }\n\n  return result as Record<ResourceType, T>;\n}\n\n/**\n * Migrates resource types in an array of objects\n * @param arr The array to migrate\n * @param propertyName The property name containing the resource type\n * @returns The migrated array\n */\nexport function migrateArrayResourceTypes<T extends Record<string, unknown>>(\n  arr: T[],\n  propertyName: string = 'type'\n): T[] {\n  return arr.map(item => {\n    if (\n      propertyName in item &&\n      typeof item[propertyName] === 'string' &&\n      isStringResourceType(item[propertyName] as string)\n    ) {\n      return {\n        ...item,\n        [propertyName]: toEnumResourceType(item[propertyName] as StringResourceType),\n      };\n    }\n    return item;\n  });\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/resources/resourceUtils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/resources/resourceValidation.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/services/ServiceAccess.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/ships/shipClassUtils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/ships/shipUtils.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/spatial/SpatialPartitioning.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/state/contextSelectors.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/state/stateMigration.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/state/statePersistence.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/typeConversions.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/vpr-diagnostic.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/weapons/weaponEffectUtils.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'CommonShipAbility' is defined but never used. Allowed unused vars must match /^_/u.",
        "line": 38,
        "column": 11,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 38,
        "endColumn": 28
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import {\n  AreaEffect,\n  DamageEffect,\n  StatusEffect,\n  WeaponEffect,\n  WeaponEffectType,\n} from '../../effects/types_effects/WeaponEffects';\nimport { Effect } from '../../types/core/GameTypes';\nimport { ResourceType } from '../../types/resources/ResourceTypes';\nimport { WeaponCategory, WeaponSystem } from '../../types/weapons/WeaponTypes';\n\ninterface WeaponLike {\n  id: string;\n  type: WeaponCategory | string;\n  damage?: number;\n  cooldown: number;\n  displayName?: string;\n}\n\n/**\n * Common ship ability interface for standardizing ship special abilities\n *\n * This interface will be used in future implementations to:\n * 1. Standardize the structure of ship special abilities across different ship classes\n * 2. Enable ability sharing and inheritance between related ship types\n * 3. Support the upcoming ship ability customization system\n * 4. Provide consistent ability parameters for UI display and tooltips\n * 5. Facilitate ability cooldown and activation state tracking\n *\n * Properties:\n * - id: Unique identifier for the ability\n * - name: Display name of the ability\n * - type: Category of ability (offensive, defensive, utility, etc.)\n * - cooldown: Time in seconds before the ability can be used again\n * - damage: Base damage value for offensive abilities\n */\n\ninterface CommonShipAbility {\n  id?: string;\n  name: string;\n  type?: string;\n  cooldown: number;\n  damage?: number;\n}\n\n/**\n * Creates a weapon-like object from parameters\n */\nexport function createWeaponLike(params: {\n  id: string;\n  type: WeaponCategory | string;\n  damage?: number;\n  cooldown: number;\n  displayName?: string;\n}): WeaponLike {\n  return params;\n}\n\n/**\n * Converts a HangarWeaponSystem to WeaponLike\n */\nexport function convertToWeaponLike(weapon: WeaponSystem & { name?: string }): WeaponLike {\n  return {\n    id: weapon.id,\n    type: weapon.type,\n    damage: weapon.damage,\n    cooldown: weapon.cooldown,\n    displayName: 'name' in weapon ? weapon.name : undefined,\n  };\n}\n\n/**\n * Creates a base weapon effect\n */\nexport function createBaseWeaponEffect(params: {\n  id: string;\n  type: 'damage' | 'area' | 'status';\n  magnitude: number;\n  duration: number;\n  strength: number;\n  name?: string;\n  description?: string;\n}): WeaponEffect {\n  return {\n    id: params.id,\n    type: params.type,\n    magnitude: params.magnitude,\n    duration: params.duration,\n    strength: params.strength,\n    name: params.name || params.id,\n    description: params.description || `${params.type} effect with magnitude ${params.magnitude}`,\n  };\n}\n\n/**\n * Creates a damage effect with the specified parameters\n */\nexport function createDamageEffect(params: {\n  id: string;\n  magnitude: number;\n  duration: number;\n  strength: number;\n  damageType: 'physical' | ResourceType.ENERGY | 'explosive';\n  penetration: number;\n  name?: string;\n  description?: string;\n}): DamageEffect {\n  const baseEffect = createBaseWeaponEffect({\n    id: params.id,\n    type: 'damage',\n    magnitude: params.magnitude,\n    duration: params.duration,\n    strength: params.strength,\n    name: params.name,\n    description: params.description,\n  });\n\n  return {\n    ...baseEffect,\n    type: 'damage' as const,\n    damageType: params.damageType,\n    penetration: params.penetration,\n  };\n}\n\n/**\n * Creates an area effect with the specified parameters\n */\nexport function createAreaEffect(params: {\n  id: string;\n  magnitude: number;\n  duration: number;\n  strength: number;\n  radius: number;\n  falloff: number;\n  name?: string;\n  description?: string;\n}): AreaEffect {\n  const baseEffect = createBaseWeaponEffect({\n    id: params.id,\n    type: 'area',\n    magnitude: params.magnitude,\n    duration: params.duration,\n    strength: params.strength,\n    name: params.name,\n    description: params.description,\n  });\n\n  return {\n    ...baseEffect,\n    type: 'area' as const,\n    radius: params.radius,\n    falloff: params.falloff,\n  };\n}\n\n/**\n * Creates a status effect with the specified parameters\n */\nexport function createStatusEffect(params: {\n  id: string;\n  magnitude: number;\n  duration: number;\n  strength: number;\n  statusType: 'burn' | 'emp' | 'slow' | 'stun';\n  name?: string;\n  description?: string;\n}): StatusEffect {\n  const baseEffect = createBaseWeaponEffect({\n    id: params.id,\n    type: 'status',\n    magnitude: params.magnitude,\n    duration: params.duration,\n    strength: params.strength,\n    name: params.name,\n    description: params.description,\n  });\n\n  return {\n    ...baseEffect,\n    type: 'status' as const,\n    statusType: params.statusType,\n  };\n}\n\n/**\n * Creates a weapon effect from a weapon system or ability\n */\nexport function createWeaponEffect(source: WeaponLike): WeaponEffectType {\n  return createDamageEffect({\n    id: `${source.id}-effect`,\n    magnitude: source.damage || 0,\n    duration: source.cooldown,\n    strength: source.damage || 0,\n    damageType: 'physical',\n    penetration: 0,\n    name: source.displayName || `${source.type} Effect`,\n    description: `Effect from ${source.displayName || source.type}`,\n  });\n}\n\n/**\n * Creates a weapon effect with custom parameters\n */\nexport function createCustomWeaponEffect(params: {\n  id: string;\n  type: 'damage' | 'area' | 'status';\n  magnitude: number;\n  duration: number;\n  strength: number;\n  damageType?: 'physical' | ResourceType.ENERGY | 'explosive';\n  penetration?: number;\n  radius?: number;\n  falloff?: number;\n  statusType?: 'burn' | 'emp' | 'slow' | 'stun';\n  name?: string;\n  description?: string;\n}): WeaponEffectType {\n  switch (params.type) {\n    case 'damage':\n      return createDamageEffect({\n        id: params.id,\n        magnitude: params.magnitude,\n        duration: params.duration,\n        strength: params.strength,\n        damageType: params.damageType || 'physical',\n        penetration: params.penetration || 0,\n        name: params.name,\n        description: params.description,\n      });\n    case 'area':\n      return createAreaEffect({\n        id: params.id,\n        magnitude: params.magnitude,\n        duration: params.duration,\n        strength: params.strength,\n        radius: params.radius || 0,\n        falloff: params.falloff || 0,\n        name: params.name,\n        description: params.description,\n      });\n    case 'status':\n      return createStatusEffect({\n        id: params.id,\n        magnitude: params.magnitude,\n        duration: params.duration,\n        strength: params.strength,\n        statusType: params.statusType || 'stun',\n        name: params.name,\n        description: params.description,\n      });\n  }\n}\n\n/**\n * Creates a weapon effect from a weapon system with scaling\n */\nexport function createScaledWeaponEffect(\n  weapon: WeaponSystem & { name?: string },\n  scale: number = 1\n): WeaponEffectType {\n  return createDamageEffect({\n    id: `${weapon.id}-scaled-effect`,\n    magnitude: weapon.damage * scale,\n    duration: weapon.cooldown,\n    strength: weapon.damage * scale,\n    damageType: 'physical',\n    penetration: 0,\n    name: weapon.name || `Scaled ${weapon.type}`,\n    description: `Scaled effect (${scale}x) from ${weapon.name || weapon.type}`,\n  });\n}\n\n/**\n * Creates a combined weapon effect from multiple weapons\n */\nexport function createCombinedWeaponEffect(weapons: WeaponSystem[]): WeaponEffectType {\n  if (weapons.length === 0) {\n    throw new Error('Cannot create combined effect from empty weapons array');\n  }\n\n  // Calculate combined damage and cooldown\n  const totalDamage = weapons.reduce((sum, weapon) => sum + weapon.damage, 0);\n  const avgCooldown = weapons.reduce((sum, weapon) => sum + weapon.cooldown, 0) / weapons.length;\n\n  // Create a combined weapon-like object\n  const combinedWeapon: WeaponLike = {\n    id: `combined-${weapons[0].id}`,\n    type: weapons[0].type,\n    damage: totalDamage,\n    cooldown: avgCooldown,\n    displayName: `Combined ${weapons[0].type}`,\n  };\n\n  // Create effect from the combined weapon\n  return createWeaponEffect(combinedWeapon);\n}\n\n/**\n * Checks if an object is a valid Effect\n */\nexport function isValidEffect(effect: unknown): effect is Effect {\n  if (!effect || typeof effect !== 'object') {\n    return false;\n  }\n\n  const effectObj = effect as Partial<Effect>;\n  return (\n    typeof effectObj.id === 'string' &&\n    typeof effectObj.type === 'string' &&\n    typeof effectObj.magnitude === 'number' &&\n    typeof effectObj.duration === 'number'\n  );\n}\n\n/**\n * Validates and normalizes an effect\n */\nexport function validateEffect(effect: Partial<Effect>): Effect {\n  if (!effect.id) {\n    throw new Error('Effect must have an id');\n  }\n\n  if (!effect.type) {\n    throw new Error('Effect must have a type');\n  }\n\n  return {\n    id: effect.id,\n    type: effect.type,\n    magnitude: effect.magnitude || 0,\n    duration: effect.duration || 0,\n  };\n}\n\n/**\n * Combines multiple effects into a single effect\n */\nexport function combineEffects(effects: Effect[]): Effect {\n  if (effects.length === 0) {\n    throw new Error('Cannot combine empty effects array');\n  }\n\n  // Use the first effect as a base\n  const baseEffect = effects[0];\n\n  // Combine magnitudes and take the longest duration\n  const combinedMagnitude = effects.reduce((sum, effect) => sum + effect.magnitude, 0);\n  const maxDuration = Math.max(...effects.map(effect => effect.duration));\n\n  // Create a new effect with combined values\n  return {\n    id: `combined-${baseEffect.id}`,\n    type: baseEffect.type,\n    magnitude: combinedMagnitude,\n    duration: maxDuration,\n  };\n}\n\n/**\n * Scales an effect by a factor\n */\nexport function scaleEffect(effect: Effect, factor: number): Effect {\n  // Create a new effect with scaled values\n  return {\n    id: `scaled-${effect.id}`,\n    type: effect.type,\n    magnitude: effect.magnitude * factor,\n    duration: effect.duration,\n  };\n}\n\n/**\n * Creates a chain of effects that trigger sequentially\n */\nexport function createEffectChain(effects: Effect[]): Effect[] {\n  if (effects.length <= 1) {\n    return effects;\n  }\n\n  // Create a new array of effects with sequential triggers\n  return effects.map((effect, index) => {\n    if (index === 0) {\n      return effect;\n    }\n\n    // Each subsequent effect is triggered by the previous one\n    return {\n      ...effect,\n      id: `chain-${index}-${effect.id}`,\n      trigger: {\n        type: 'effect-complete',\n        effectId: effects[index - 1].id,\n      },\n    };\n  });\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/weapons/weaponTypeConversions.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/workers/ResourceFlowWorkerUtil.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/visualization/Chart.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-unused-vars",
        "severity": 1,
        "message": "'e' is defined but never used. Allowed unused caught errors must match /^_/u.",
        "line": 247,
        "column": 16,
        "nodeType": null,
        "messageId": "unusedVar",
        "endLine": 247,
        "endColumn": 17
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import * as React from \"react\";\nimport { useMemo, useState, useEffect, useRef } from 'react';\nimport { CanvasRenderer } from './renderers/CanvasRenderer';\nimport { SVGRenderer } from './renderers/SVGRenderer';\nimport { WebGLRenderer } from './renderers/WebGLRenderer';\nimport { errorLoggingService, ErrorType } from '../services/ErrorLoggingService';\n\n/**\n * Common chart data point interface\n */\nexport interface ChartDataPoint {\n  x: number | string | Date;\n  y: number;\n  [key: string]: unknown;\n}\n\n/**\n * Chart data interface\n */\nexport interface ChartData {\n  datasets: {\n    label: string;\n    data: ChartDataPoint[];\n    color?: string;\n    [key: string]: unknown;\n  }[];\n  annotations?: {\n    type: 'line' | 'box' | 'point';\n    position: { x?: number | string | Date; y?: number };\n    color?: string;\n    label?: string;\n    [key: string]: unknown;\n  }[];\n}\n\n/**\n * Chart axes configuration\n */\nexport interface ChartAxes {\n  x: {\n    type: 'linear' | 'time' | 'category' | 'log';\n    label?: string;\n    min?: number | string | Date;\n    max?: number | string | Date;\n    tickCount?: number;\n    tickFormat?: (value: unknown) => string;\n    grid?: boolean;\n  };\n  y: {\n    type: 'linear' | 'log';\n    label?: string;\n    min?: number;\n    max?: number;\n    tickCount?: number;\n    tickFormat?: (value: number) => string;\n    grid?: boolean;\n  };\n}\n\n/**\n * Chart legend configuration\n */\nexport interface ChartLegend {\n  visible: boolean;\n  position: 'top' | 'right' | 'bottom' | 'left';\n  align?: 'start' | 'center' | 'end';\n}\n\n/**\n * Chart tooltip configuration\n */\nexport interface ChartTooltip {\n  enabled: boolean;\n  mode: 'point' | 'nearest' | 'dataset';\n  intersect?: boolean;\n  format?: (point: ChartDataPoint, dataset: ChartData['datasets'][0]) => string;\n}\n\n/**\n * Chart animation configuration\n */\nexport interface ChartAnimation {\n  enabled: boolean;\n  duration?: number;\n  easing?: 'linear' | 'easeInOut' | 'easeIn' | 'easeOut';\n}\n\n/**\n * Chart options interface\n */\nexport interface ChartOptions {\n  width?: number | string;\n  height?: number | string;\n  renderer?: 'canvas' | 'svg' | 'webgl';\n  responsive?: boolean;\n  maintainAspectRatio?: boolean;\n  axes?: ChartAxes;\n  legend?: ChartLegend;\n  tooltip?: ChartTooltip;\n  animation?: ChartAnimation;\n  backgroundColor?: string;\n  padding?: {\n    top?: number;\n    right?: number;\n    bottom?: number;\n    left?: number;\n  };\n  enablePanning?: boolean;\n  enableZooming?: boolean;\n  theme?: 'light' | 'dark' | 'auto';\n  memoryOptimized?: boolean;\n  renderOptimization?: boolean;\n  optimizationThreshold?: number;\n}\n\n/**\n * Default chart options\n */\nconst DEFAULT_CHART_OPTIONS: ChartOptions = {\n  width: '100%',\n  height: 300,\n  renderer: 'canvas',\n  responsive: true,\n  maintainAspectRatio: true,\n  axes: {\n    x: {\n      type: 'linear',\n      grid: true,\n    },\n    y: {\n      type: 'linear',\n      grid: true,\n    }\n  },\n  legend: {\n    visible: true,\n    position: 'top',\n    align: 'center',\n  },\n  tooltip: {\n    enabled: true,\n    mode: 'nearest',\n    intersect: true,\n  },\n  animation: {\n    enabled: true,\n    duration: 300,\n    easing: 'easeInOut',\n  },\n  backgroundColor: 'transparent',\n  padding: {\n    top: 10,\n    right: 10,\n    bottom: 20,\n    left: 30,\n  },\n  enablePanning: false,\n  enableZooming: false,\n  theme: 'light',\n  memoryOptimized: false,\n  renderOptimization: true,\n  optimizationThreshold: 1000,\n};\n\n/**\n * Chart renderer interface\n */\nexport interface ChartRenderer {\n  render: (\n    container: HTMLElement,\n    data: ChartData,\n    options: ChartOptions,\n    type: ChartType\n  ) => void;\n  update: (\n    container: HTMLElement,\n    data: ChartData,\n    options: ChartOptions,\n    type: ChartType\n  ) => void;\n  destroy: () => void;\n  getStatus: () => { isInitialized: boolean; lastRenderTime?: number };\n}\n\n/**\n * Chart type\n */\nexport type ChartType = 'line' | 'bar' | 'scatter' | 'area' | 'pie' | 'radar' | 'heatmap';\n\n/**\n * Chart component props\n */\nexport interface ChartProps {\n  data: ChartData;\n  options?: Partial<ChartOptions>;\n  type: ChartType;\n  className?: string;\n  onRender?: (renderer: ChartRenderer) => void;\n  onError?: (error: Error) => void;\n}\n\n/**\n * Chart component that uses a strategy pattern for different rendering methods\n */\nexport const Chart: React.FC<ChartProps> = ({\n  data,\n  options = {},\n  type,\n  className = '',\n  onRender,\n  onError,\n}) => {\n  // Merge options with defaults\n  const mergedOptions: ChartOptions = useMemo(() => ({\n    ...DEFAULT_CHART_OPTIONS,\n    ...options,\n  }), [options]);\n\n  // Container ref for rendering\n  const containerRef = useRef<HTMLDivElement>(null);\n  \n  // Chart renderer ref\n  const rendererRef = useRef<ChartRenderer | null>(null);\n  \n  // Error state\n  const [error, setError] = useState<Error | null>(null);\n  \n  // Auto-select renderer based on data size and device capabilities if not specified\n  const renderer = useMemo(() => {\n    // Count total data points\n    const totalDataPoints = data.datasets.reduce((acc, dataset) => acc + dataset.data.length, 0);\n    \n    // If renderer is explicitly set, use that\n    if (mergedOptions.renderer) {\n      return mergedOptions.renderer;\n    }\n    \n    // Auto-select based on data size and optimization settings\n    if (mergedOptions.memoryOptimized || totalDataPoints > (mergedOptions.optimizationThreshold || 1000)) {\n      // Check if WebGL is available\n      try {\n        const canvas = document.createElement('canvas');\n        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\n        if (gl) {\n          return 'webgl';\n        }\n      } catch (e) {\n        // WebGL not available, fall back to canvas\n      }\n      \n      return 'canvas';\n    }\n    \n    // For smaller datasets, SVG provides better interactivity\n    return 'svg';\n  }, [mergedOptions.renderer, mergedOptions.memoryOptimized, mergedOptions.optimizationThreshold, data]);\n  \n  // Initialize renderer\n  useEffect(() => {\n    if (!containerRef.current) return;\n    \n    try {\n      // Destroy previous renderer if it exists\n      if (rendererRef.current) {\n        rendererRef.current.destroy();\n        rendererRef.current = null;\n      }\n      \n      // Create new renderer based on selected strategy\n      switch (renderer) {\n        case 'canvas':\n          rendererRef.current = new CanvasRenderer();\n          break;\n        case 'webgl':\n          rendererRef.current = new WebGLRenderer();\n          break;\n        case 'svg':\n        default:\n          rendererRef.current = new SVGRenderer();\n          break;\n      }\n      \n      // Initial render\n      rendererRef.current.render(containerRef.current, data, mergedOptions, type);\n      \n      // Call onRender callback if provided\n      if (onRender) {\n        onRender(rendererRef.current);\n      }\n      \n      // Clear any previous errors\n      if (error) {\n        setError(null);\n      }\n    } catch (err) {\n      const error = err instanceof Error ? err : new Error(String(err));\n      \n      // Log error\n      errorLoggingService.logError(error, ErrorType.RUNTIME, undefined, {\n        component: 'Chart',\n        renderer,\n        chartType: type,\n        dataSize: data.datasets.reduce((acc, dataset) => acc + dataset.data.length, 0),\n      });\n      \n      // Set error state\n      setError(error);\n      \n      // Call onError callback if provided\n      if (onError) {\n        onError(error);\n      }\n    }\n    \n    // Cleanup\n    return () => {\n      if (rendererRef.current) {\n        rendererRef.current.destroy();\n        rendererRef.current = null;\n      }\n    };\n  }, [renderer, type]);\n  \n  // Update chart when data or options change\n  useEffect(() => {\n    if (!containerRef.current || !rendererRef.current) return;\n    \n    try {\n      rendererRef.current.update(containerRef.current, data, mergedOptions, type);\n      \n      // Clear any previous errors\n      if (error) {\n        setError(null);\n      }\n    } catch (err) {\n      const error = err instanceof Error ? err : new Error(String(err));\n      \n      // Log error\n      errorLoggingService.logError(error, ErrorType.RUNTIME, undefined, {\n        component: 'Chart',\n        renderer,\n        chartType: type,\n        dataSize: data.datasets.reduce((acc, dataset) => acc + dataset.data.length, 0),\n        action: 'update',\n      });\n      \n      // Set error state\n      setError(error);\n      \n      // Call onError callback if provided\n      if (onError) {\n        onError(error);\n      }\n    }\n  }, [data, mergedOptions]);\n  \n  // Handle container resize\n  useEffect(() => {\n    if (!containerRef.current || !rendererRef.current || !mergedOptions.responsive) return;\n    \n    const resizeObserver = new ResizeObserver(() => {\n      if (containerRef.current && rendererRef.current) {\n        try {\n          rendererRef.current.update(containerRef.current, data, mergedOptions, type);\n        } catch (err) {\n          console.error('Error resizing chart:', err);\n        }\n      }\n    });\n    \n    resizeObserver.observe(containerRef.current);\n    \n    return () => {\n      resizeObserver.disconnect();\n    };\n  }, [mergedOptions.responsive]);\n  \n  // Fallback UI for errors\n  if (error) {\n    return (\n      <div \n        className={`chart-error ${className}`}\n        style={{\n          width: mergedOptions.width,\n          height: mergedOptions.height,\n          display: 'flex',\n          flexDirection: 'column',\n          alignItems: 'center',\n          justifyContent: 'center',\n          border: '1px solid #ff6b6b',\n          borderRadius: '4px',\n          padding: '1rem',\n          backgroundColor: '#fff1f1',\n          color: '#d63031',\n        }}\n      >\n        <h4>Chart Error</h4>\n        <p style={{ fontSize: '0.875rem' }}>{error.message}</p>\n        <button \n          onClick={() => {\n            setError(null);\n            if (containerRef.current && rendererRef.current) {\n              try {\n                rendererRef.current.render(containerRef.current, data, mergedOptions, type);\n              } catch (err) {\n                setError(err instanceof Error ? err : new Error(String(err)));\n              }\n            }\n          }}\n          style={{\n            marginTop: '0.5rem',\n            padding: '0.25rem 0.75rem',\n            border: '1px solid #d63031',\n            borderRadius: '4px',\n            backgroundColor: 'white',\n            color: '#d63031',\n            cursor: 'pointer',\n          }}\n        >\n          Retry\n        </button>\n      </div>\n    );\n  }\n  \n  return (\n    <div\n      ref={containerRef}\n      className={`chart-container ${className}`}\n      style={{\n        width: mergedOptions.width,\n        height: mergedOptions.height,\n        position: 'relative',\n      }}\n      data-chart-type={type}\n      data-chart-renderer={renderer}\n    />\n  );\n};\n\nexport default Chart;",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/visualization/index.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/visualization/renderers/CanvasRenderer.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/visualization/renderers/SVGRenderer.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/visualization/renderers/WebGLRenderer.tsx",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/vite-env.d.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/workers/DataProcessingWorker.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/workers/ResourceFlowWorker.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/workers/combatWorker.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/workers/worker.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  }
]
