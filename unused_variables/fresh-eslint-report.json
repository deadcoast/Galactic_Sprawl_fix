[{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/docs/changelog/Error_Correction/March17_Error_Directory/Tests/essential/test_resource_types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/docs/changelog/Error_Correction/March17_Error_Directory/Tests/essential/test_unused_vars.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":8,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":8,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[227,230],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[227,230],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_options' is defined but never used.","line":8,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":41},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":8,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":8,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[242,245],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[242,245],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":10,"column":3,"nodeType":"MemberExpression","messageId":"limited","endLine":10,"endColumn":14,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[284,324],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_count' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":15,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_email' is defined but never used.","line":26,"column":35,"nodeType":null,"messageId":"unusedVar","endLine":26,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_length' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":36,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":36,"endColumn":16},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":42,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":42,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1091,1094],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1091,1094],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":43,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":43,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1115,1118],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1115,1118],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":45,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1165,1168],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1165,1168],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":45,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1178,1181],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1178,1181],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":51,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":51,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1263,1303],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_index' is defined but never used.","line":63,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":63,"endColumn":38},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":65,"column":3,"nodeType":"MemberExpression","messageId":"limited","endLine":65,"endColumn":14,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1614,1643],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":74,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":74,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1788,1821],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":79,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":79,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1886,1889],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1886,1889],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":79,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":79,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1900,1903],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1900,1903],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_item' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":81,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":81,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_city' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":91,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":91,"endColumn":25},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":92,"column":1,"nodeType":"MemberExpression","messageId":"limited","endLine":92,"endColumn":12,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2244,2287],"text":""},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Test file for unused variables\n * This file contains common patterns of unused variables\n * that should be detected and fixed by the fix_unused_vars.sh script\n */\n\n// Unused function parameter\nfunction processData(data: any, _options: any): void {\n  // options is never used\n  console.log(`Processing data: ${data}`);\n}\n\n// Unused variable in function body\nfunction calculateTotal(prices: number[]): number {\n  const _count = prices.length; // count is never used\n  let sum = 0;\n\n  for (let i = 0; i < prices.length; i++) {\n    sum += prices[i];\n  }\n\n  return sum;\n}\n\n// Unused destructured variable\nfunction getUserInfo({ name, age, _email }: { name: string; age: number; email: string }): string {\n  // email is never used\n  return `${name}, ${age} years old`;\n}\n\n// Unused import (would be detected by ESLint)\n// import { Something } from './something';\n\n// Unused variable in arrow function\nconst getFirstItem = (items: string[]) => {\n  const _length = items.length; // length is never used\n  return items[0];\n};\n\n// Unused variable in class\nclass DataProcessor {\n  private data: any;\n  private _config: any; // config is never used\n\n  constructor(data: any, config: any) {\n    this.data = data;\n    this._config = config;\n  }\n\n  process(): void {\n    console.log(`Processing: ${this.data}`);\n  }\n}\n\n// Unused function parameter in callback\nfunction processArray<T>(array: T[], callback: (item: T, index: number) => void): void {\n  array.forEach((item, index) => {\n    callback(item, index);\n  });\n}\n\n// Usage with unused parameter\nprocessArray([1, 2, 3], (item, _index) => {\n  // index is never used\n  console.log(`Item: ${item}`);\n});\n\n// Unused catch error\nfunction safelyProcess(fn: () => void): void {\n  try {\n    fn();\n  } catch (_error) {\n    // error is never used\n    console.log('An error occurred');\n  }\n}\n\n// Unused variable in for loop\nfunction findIndex(array: any[], value: any): number {\n  for (let i = 0; i < array.length; i++) {\n    const _item = array[i]; // Could use array[i] directly\n    if (array[i] === value) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n// Unused variable in destructuring\nconst person = { name: 'John', age: 30, city: 'New York' };\nconst { name, age, _city } = person; // city is never used\nconsole.log(`${name} is ${age} years old`);\n\n// Export to avoid unused export warnings\nexport {\n  DataProcessor,\n  calculateTotal,\n  findIndex,\n  getFirstItem,\n  getUserInfo,\n  processArray,\n  processData,\n  safelyProcess,\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/eslint.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/jest-setup.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/jest.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/playwright.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/postcss.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/App.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'profiler' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":355,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":355,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'profilerRef' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":372,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":372,"endColumn":20},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":384,"column":7,"nodeType":"MemberExpression","messageId":"limited","endLine":384,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"debug"},"fix":{"range":[13970,14165],"text":""},"desc":"Remove the console.debug()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as React from 'react';\nimport { lazy, Suspense, useEffect } from 'react';\nimport { SystemIntegration } from './components/core/SystemIntegration';\nimport { ThresholdIntegration } from './components/core/ThresholdIntegration';\nimport { GameStateMonitor } from './components/debug/GameStateMonitor';\nimport { TooltipProvider } from './components/ui/TooltipProvider';\nimport { defaultColony, defaultMothership } from './config/buildings/defaultBuildings';\nimport { defaultModuleConfigs } from './config/modules/defaultModuleConfigs';\nimport { GameActionType, GameProvider, useGameDispatch } from './contexts/GameContext';\nimport { ModuleActionType, ModuleProvider, useModuleDispatch } from './contexts/ModuleContext';\nimport { ResourceRatesProvider } from './contexts/ResourceRatesContext';\nimport { ThresholdProvider } from './contexts/ThresholdContext';\nimport { assetManager } from './managers/game/assetManager';\nimport { ResourceManager } from './managers/game/ResourceManager';\n// import { TechTreeManager } from './managers/game/techTreeManager';\nimport { moduleManager } from './managers/module/ModuleManager';\nimport { OfficerManager } from './managers/module/OfficerManager';\nimport { ShipHangarManager } from './managers/module/ShipHangarManager';\nimport { ModuleType } from './types/buildings/ModuleTypes';\nimport { ModuleStatus } from './types/modules/ModuleTypes';\nimport { ResourceType } from './types/resources/ResourceTypes';\nimport { getTechTreeManager } from './managers/ManagerRegistry';\nimport { TechNode } from './managers/game/techTreeManager';\nimport { Profiler } from 'react';\n\n// Import the GlobalErrorBoundary component\nimport { GlobalErrorBoundary } from './components/ui/GlobalErrorBoundary';\n// Import error services\nimport { IntegrationErrorHandler } from './components/core/IntegrationErrorHandler';\nimport ResourceVisualization from './components/ui/ResourceVisualization';\nimport { useComponentProfiler } from './hooks/ui/useComponentProfiler';\nimport { useProfilingOverlay } from './hooks/ui/useProfilingOverlay';\nimport { errorLoggingService, ErrorSeverity, ErrorType } from './services/ErrorLoggingService';\nimport { eventPropagationService } from './services/EventPropagationService';\nimport { recoveryService } from './services/RecoveryService';\nimport { BaseEvent } from './types/events/EventTypes';\n\n// Lazy load components that aren't needed on initial render\nconst GameLayout = lazy(() =>\n  import('./components/ui/GameLayout').then(module => ({ default: module.GameLayout }))\n);\n\n// Loading component\nconst LoadingComponent = () => (\n  <div className=\"flex h-screen w-full flex-col items-center justify-center bg-gray-900 text-white\">\n    <div className=\"mb-4 h-12 w-12 animate-spin rounded-full border-4 border-blue-500 border-t-transparent\"></div>\n    <h2 className=\"mb-2 text-xl font-medium\">Loading Game Components...</h2>\n    <p className=\"text-gray-400\">Preparing your galactic adventure</p>\n  </div>\n);\n\n// Initial tech tree setup\nconst initialTechs: TechNode[] = [\n  {\n    id: 'basic-ship-hangar',\n    name: 'Basic Ship Hangar',\n    description: 'Enables basic ship construction',\n    type: 'hangar',\n    tier: 1 as const,\n    requirements: [],\n    unlocked: true,\n    category: 'infrastructure',\n  },\n  {\n    id: 'basic-weapons',\n    name: 'Basic Weapons',\n    description: 'Enables basic weapon systems',\n    type: 'weapons',\n    tier: 1 as const,\n    requirements: ['basic-ship-hangar'],\n    unlocked: false,\n    category: 'weapons',\n  },\n  {\n    id: 'basic-sensors',\n    name: 'Basic Sensors',\n    description: 'Enables basic scanning capabilities',\n    type: 'recon',\n    tier: 1 as const,\n    requirements: ['basic-ship-hangar'],\n    unlocked: false,\n    category: 'reconFleet',\n  },\n];\n\ninterface ResourceEvent extends BaseEvent {\n  moduleId: string;\n  data: {\n    resources: {\n      current: number;\n      [key: string]: unknown;\n    };\n  };\n}\n\ninterface ThresholdEvent extends BaseEvent {\n  resourceId: ResourceType;\n  details: {\n    type: 'below_minimum' | 'above_maximum';\n    current: number;\n    min?: number;\n    max?: number;\n  };\n}\n\n// GameInitializer component to handle game initialization\nconst GameInitializer = ({ children }: { children: React.ReactNode }) => {\n  const dispatch = useGameDispatch();\n  const [isInitialized, setIsInitialized] = React.useState(false);\n  const moduleDispatch = useModuleDispatch();\n  const [resourceManagerInstance] = React.useState(() => new ResourceManager());\n\n  useEffect(() => {\n    const initializeGame = async () => {\n      if (!isInitialized) {\n        console.warn('Starting game initialization...');\n        try {\n          // Initialize resource manager\n          console.warn('Initializing resource manager...');\n          // ResourceManager is already initialized via useState\n\n          // Register module configurations\n          console.warn('Registering module configurations...');\n          if (defaultModuleConfigs) {\n            Object.values(defaultModuleConfigs).forEach(config => {\n              if (config) {\n                console.warn(`Registering module config: ${config.type}`);\n                moduleManager.registerModuleConfig(config);\n              }\n            });\n          } else {\n            console.warn('defaultModuleConfigs is null or undefined');\n          }\n\n          // Register default buildings\n          console.warn('Registering default buildings...');\n          if (defaultMothership) {\n            console.warn(`Registering mothership: ${defaultMothership.id}`);\n            moduleManager.registerBuilding(defaultMothership);\n\n            // Also register the building with the ModuleContext\n            moduleDispatch({\n              type: ModuleActionType.ADD_MODULE,\n              payload: {\n                module: {\n                  ...defaultMothership,\n                  name: 'Mothership',\n                  position: { x: 0, y: 0 },\n                  isActive: true,\n                  status: ModuleStatus.ACTIVE,\n                  type: 'resource-manager' as ModuleType,\n                },\n              },\n            });\n          }\n\n          if (defaultColony) {\n            console.warn(`Registering colony: ${defaultColony.id}`);\n            moduleManager.registerBuilding(defaultColony);\n\n            // Also register the building with the ModuleContext\n            moduleDispatch({\n              type: ModuleActionType.ADD_MODULE,\n              payload: {\n                module: {\n                  ...defaultColony,\n                  name: 'Colony',\n                  position: { x: 0, y: 0 },\n                  isActive: true,\n                  status: ModuleStatus.ACTIVE,\n                  type: 'resource-manager' as ModuleType,\n                },\n              },\n            });\n          }\n\n          // Initialize asset manager\n          console.warn('Initializing asset manager...');\n          await assetManager.initialize();\n\n          // Register initial technologies\n          console.warn('Registering initial technologies...');\n          if (initialTechs) {\n            initialTechs.forEach(tech => {\n              if (tech) {\n                console.warn(`Registering tech: ${tech.id}`);\n                getTechTreeManager().registerNode(tech);\n              }\n            });\n          } else {\n            console.warn('initialTechs is null or undefined');\n          }\n\n          // Add initial resources\n          console.warn('Adding initial resources...');\n          dispatch({\n            type: GameActionType.UPDATE_RESOURCES,\n            payload: {\n              minerals: 2000, // Increased initial resources to allow for early module building\n              energy: 2000,\n              research: 0,\n              population: 100,\n            },\n          });\n\n          // Update systems count\n          console.warn('Updating system counts...');\n          dispatch({\n            type: GameActionType.UPDATE_SYSTEMS,\n            payload: {\n              total: 1,\n              colonized: 1,\n              explored: 1,\n            },\n          });\n\n          // Initialize the officer manager\n          console.warn('Initializing officer manager...');\n          const officerManager = new OfficerManager();\n\n          // Initialize the ship hangar manager\n          console.warn('Initializing ship hangar manager...');\n          const shipHangarManager = new ShipHangarManager(resourceManagerInstance, officerManager);\n\n          // Register the ship hangar manager with the global window object for development access\n          if (process.env.NODE_ENV === 'development') {\n            // Make manager available for debugging\n            (\n              window as Window & typeof globalThis & { shipHangarManager: ShipHangarManager }\n            ).shipHangarManager = shipHangarManager;\n          }\n\n          // Initialize event propagation service\n          console.warn('Initializing event propagation service...');\n\n          // Register event mappings\n          eventPropagationService.subscribe({\n            eventType: 'RESOURCE_UPDATED',\n            priority: 1,\n            callback: (eventData: unknown) => {\n              const event = eventData as ResourceEvent;\n              const resources = event?.data?.resources;\n              const {current} = resources;\n\n              return {\n                resourceId: event?.moduleId,\n                details: {\n                  current,\n                  type: 'below_minimum',\n                },\n                timestamp: Date.now(),\n              };\n            },\n          });\n\n          // Register threshold to module mappings\n          eventPropagationService.subscribe({\n            eventType: 'THRESHOLD_VIOLATED',\n            priority: 1,\n            callback: (eventData: unknown) => {\n              const event = eventData as ThresholdEvent;\n              return {\n                moduleId: 'threshold-service',\n                moduleType: 'resource' as ModuleType,\n                timestamp: Date.now(),\n                data: {\n                  resourceType: event?.resourceId,\n                  thresholdType: event?.details.type === 'below_minimum' ? 'min' : 'max',\n                  current: event?.details.current,\n                  threshold:\n                    event?.details.type === 'below_minimum'\n                      ? event?.details.min\n                      : event?.details.max,\n                },\n              };\n            },\n          });\n\n          // Initialize the service\n          eventPropagationService.initialize();\n\n          // Set initialization flag\n          console.warn('Game initialization complete!');\n\n          // Log the current state of the module manager\n          console.warn('Module manager state:', {\n            buildings: moduleManager.getBuildings(),\n            modules: moduleManager.getActiveModules(),\n            configs: 'Module configurations registered',\n          });\n\n          setIsInitialized(true);\n        } catch (error) {\n          console.error('Error during game initialization:', error);\n          errorLoggingService.logError(\n            error instanceof Error ? error : new Error(String(error)),\n            ErrorType.INITIALIZATION,\n            ErrorSeverity.HIGH,\n            {\n              action: 'initialization',\n            }\n          );\n\n          // Attempt recovery\n          const snapshot = {\n            gameState: 'error',\n            error: error instanceof Error ? error.message : String(error),\n          };\n          recoveryService.createSnapshot(snapshot, { reason: 'Error during initialization' });\n        }\n      }\n    };\n\n    initializeGame();\n  }, [dispatch, isInitialized, moduleDispatch]);\n\n  if (!isInitialized) {\n    return (\n      <div className=\"flex h-screen w-full flex-col items-center justify-center bg-gray-900 text-white\">\n        <div className=\"mb-4 h-12 w-12 animate-spin rounded-full border-4 border-blue-500 border-t-transparent\"></div>\n        <h2 className=\"mb-2 text-xl font-medium\">Initializing Game Systems...</h2>\n        <p className=\"text-gray-400\">Preparing galaxy for exploration</p>\n      </div>\n    );\n  }\n\n  return (\n    <IntegrationErrorHandler componentName=\"SystemIntegration\">\n      <SystemIntegration resourceManager={resourceManagerInstance}>\n        <IntegrationErrorHandler componentName=\"ThresholdIntegration\">\n          <ThresholdIntegration resourceManager={resourceManagerInstance}>\n            {children}\n          </ThresholdIntegration>\n        </IntegrationErrorHandler>\n      </SystemIntegration>\n    </IntegrationErrorHandler>\n  );\n};\n\n// Handler for global errors\nconst handleGlobalError = (error: Error, errorInfo: React.ErrorInfo) => {\n  // Log the error using our error logging service\n  errorLoggingService.logError(error, ErrorType.RUNTIME, ErrorSeverity.HIGH, {\n    componentName: 'GlobalErrorBoundary',\n    errorInfo,\n  });\n\n  // Log to console for development purposes\n  console.error('Global error caught:', error, errorInfo);\n};\n\n// A wrapper for the GameLayout component to provide the required props\nconst GameLayoutWrapper = () => {\n  // Use component profiler to track performance\n  const profiler = useComponentProfiler('GameLayoutWrapper', {\n    enabled: process.env.NODE_ENV === 'development',\n    logToConsole: true,\n    slowRenderThreshold: 16\n  });\n\n  return (\n    <GameLayout empireName=\"Stellar Dominion\" bannerColor=\"#4FD1C5\">\n      <div className=\"min-h-screen bg-gray-900\">\n        <ResourceVisualization type={ResourceType.ENERGY} value={100} />\n      </div>\n    </GameLayout>\n  );\n};\n\nexport default function App() {\n  // Enable app-level profiling with React Profiler API\n  const profilerRef = React.createRef<typeof Profiler>();\n  \n  // Set up callback for the React Profiler\n  const handleProfilerRender = (\n    id: string,\n    phase: string,\n    actualDuration: number,\n    baseDuration: number,\n    startTime: number,\n    commitTime: number\n  ) => {\n    if (process.env.NODE_ENV === 'development') {\n      console.debug(\n        `[Profiler] ${id} ${phase}: actual=${actualDuration.toFixed(2)}ms, ` +\n        `base=${baseDuration.toFixed(2)}ms, at ${new Date(commitTime).toLocaleTimeString()}`\n      );\n    }\n  };\n\n  // Show profiling overlay in development\n  useProfilingOverlay({\n    enabledByDefault: process.env.NODE_ENV === 'development',\n    enableInProduction: false,\n    toggleKey: 'p',\n    persistState: true,\n  });\n\n  // Make the ResourceManager accessible in development\n  const [resourceManager] = React.useState(() => new ResourceManager());\n\n  if (process.env.NODE_ENV === 'development') {\n    // Make ResourceManager available for debugging\n    (window as Window & typeof globalThis & { resourceManager: ResourceManager }).resourceManager =\n      resourceManager;\n  }\n\n  // Development mode debug tools\n  const showDebugTools = process.env.NODE_ENV === 'development';\n\n  return (\n    <div className=\"app-container\">\n      <Profiler id=\"GalacticSprawl-App\" onRender={handleProfilerRender}>\n        <GlobalErrorBoundary onError={handleGlobalError}>\n          <GameProvider>\n            <ModuleProvider>\n              <ResourceRatesProvider>\n                <ThresholdProvider>\n                  <TooltipProvider>\n                    <GameInitializer>\n                      <Suspense fallback={<LoadingComponent />}>\n                        <GameLayoutWrapper />\n                        {showDebugTools && <GameStateMonitor expanded={false} />}\n                      </Suspense>\n                    </GameInitializer>\n                  </TooltipProvider>\n                </ThresholdProvider>\n              </ResourceRatesProvider>\n            </ModuleProvider>\n          </GameProvider>\n        </GlobalErrorBoundary>\n      </Profiler>\n    </div>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/api/TypeSafeApiClient.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ResourceRegistryUI.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/colony/AutomatedExpansion.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/colony/AutomatedPopulationManager.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'colonyName' is defined but never used.","line":53,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":53,"endColumn":13},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'subscribe' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":73,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":73,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { motion } from 'framer-motion';\nimport {\n  AlertTriangle,\n  CheckCircle,\n  ChevronDown,\n  ChevronUp,\n  Clock,\n  Pause,\n  Play,\n  RotateCcw,\n  Settings,\n  TrendingUp,\n  Users,\n} from 'lucide-react';\nimport { useCallback, useEffect, useState } from 'react';\nimport { useModuleEvents } from '../../../hooks/events/useModuleEvents';\nimport { moduleEventBus } from '../../../lib/events/ModuleEventBus';\nimport { EventType } from '../../../types/events/EventTypes';\nimport { StandardizedEvent } from '../../../types/events/StandardizedEvents';\nimport { ResourceType } from '../../../types/resources/ResourceTypes';\n\ninterface PopulationEvent {\n  id: string;\n  timestamp: number;\n  type: 'growth' | 'decline' | 'migration' | 'disaster' | 'policy';\n  amount: number;\n  reason: string;\n}\n\ninterface AutomatedPopulationManagerProps {\n  colonyId: string;\n  colonyName: string;\n  currentPopulation: number;\n  maxPopulation: number;\n  growthRate: number; // Effective growth rate per cycle\n  cycleLength: number; // Length of a growth cycle in milliseconds\n  autoGrowthEnabled?: boolean; // Whether automatic growth is enabled\n  events?: PopulationEvent[]; // Population events history\n  onPopulationChange?: (newPopulation: number) => void;\n  onAutoGrowthToggle?: (enabled: boolean) => void;\n  onCycleComplete?: (cycleCount: number) => void;\n  onSettingsChange?: (settings: { cycleLength: number }) => void;\n}\n\n/**\n * AutomatedPopulationManager component\n *\n * Manages automated population growth for a colony.\n * Handles growth cycles, population events, and provides controls for automation.\n */\nexport function AutomatedPopulationManager({\n  colonyId,\n  colonyName,\n  currentPopulation,\n  maxPopulation,\n  growthRate,\n  cycleLength,\n  autoGrowthEnabled = false,\n  events = [],\n  onPopulationChange,\n  onAutoGrowthToggle,\n  onCycleComplete,\n  onSettingsChange,\n}: AutomatedPopulationManagerProps) {\n  const [isRunning, setIsRunning] = useState(autoGrowthEnabled);\n  const [cycleProgress, setCycleProgress] = useState(0);\n  const [cycleCount, setCycleCount] = useState(0);\n  const [nextGrowthAmount, setNextGrowthAmount] = useState(0);\n  const [showSettings, setShowSettings] = useState(false);\n  const [customCycleLength, setCustomCycleLength] = useState(cycleLength);\n  const [showEvents, setShowEvents] = useState(false);\n\n  const { subscribe } = useModuleEvents();\n\n  // Calculate the next growth amount based on current population and growth rate\n  const calculateNextGrowthAmount = useCallback(() => {\n    if (currentPopulation >= maxPopulation) {\n      return 0;\n    }\n\n    // Calculate raw growth\n    const rawGrowth = Math.floor(currentPopulation * growthRate);\n\n    // Ensure we don't exceed max population\n    const adjustedGrowth = Math.min(rawGrowth, maxPopulation - currentPopulation);\n\n    // Ensure at least 1 population growth if any growth is possible\n    return Math.max(1, adjustedGrowth);\n  }, [currentPopulation, maxPopulation, growthRate]);\n\n  // Update next growth amount when dependencies change\n  useEffect(() => {\n    setNextGrowthAmount(calculateNextGrowthAmount());\n  }, [calculateNextGrowthAmount]);\n\n  // Emit population update event\n  const emitPopulationUpdate = useCallback(\n    (newPopulation: number) => {\n      const event: StandardizedEvent = {\n        type: EventType.MODULE_UPDATED,\n        moduleId: colonyId,\n        moduleType: ResourceType.POPULATION,\n        timestamp: Date.now(),\n        data: {\n          stats: {\n            [ResourceType.POPULATION]: newPopulation,\n          },\n        },\n      };\n      moduleEventBus.emit(event);\n    },\n    [colonyId]\n  );\n\n  // Handle population growth cycle\n  useEffect(() => {\n    if (!isRunning) {\n      return;\n    }\n\n    let lastUpdate = Date.now();\n    let progress = 0;\n\n    const updateInterval = setInterval(() => {\n      const now = Date.now();\n      const delta = now - lastUpdate;\n      lastUpdate = now;\n\n      progress += delta;\n      const progressPercent = (progress / customCycleLength) * 100;\n      setCycleProgress(progressPercent);\n\n      if (progress >= customCycleLength) {\n        // Reset progress\n        progress = 0;\n        setCycleProgress(0);\n        setCycleCount(prev => prev + 1);\n\n        // Calculate and apply population growth\n        const growthAmount = calculateNextGrowthAmount();\n        if (growthAmount > 0) {\n          const newPopulation = currentPopulation + growthAmount;\n          onPopulationChange?.(newPopulation);\n          emitPopulationUpdate(newPopulation);\n        }\n\n        // Notify cycle completion\n        onCycleComplete?.(cycleCount + 1);\n      }\n    }, 100); // Update progress every 100ms\n\n    return () => {\n      clearInterval(updateInterval);\n    };\n  }, [\n    isRunning,\n    customCycleLength,\n    currentPopulation,\n    calculateNextGrowthAmount,\n    onPopulationChange,\n    onCycleComplete,\n    cycleCount,\n    colonyId,\n    emitPopulationUpdate,\n  ]);\n\n  // Handle automation toggle\n  const handleAutomationToggle = useCallback(() => {\n    const newState = !isRunning;\n    setIsRunning(newState);\n    onAutoGrowthToggle?.(newState);\n  }, [isRunning, onAutoGrowthToggle]);\n\n  // Handle cycle length change\n  const handleCycleLengthChange = useCallback(\n    (newLength: number) => {\n      setCustomCycleLength(newLength);\n      onSettingsChange?.({ cycleLength: newLength });\n    },\n    [onSettingsChange]\n  );\n\n  // Format time in minutes and seconds\n  const formatTime = (ms: number) => {\n    const totalSeconds = Math.floor(ms / 1000);\n    const minutes = Math.floor(totalSeconds / 60);\n    const seconds = totalSeconds % 60;\n\n    return `${minutes}:${seconds.toString().padStart(2, '0')}`;\n  };\n\n  // Format timestamp to readable date/time\n  const formatTimestamp = (timestamp: number) => {\n    const date = new Date(timestamp);\n    return date.toLocaleString();\n  };\n\n  // Get color for population percentage\n  const getPopulationColor = () => {\n    const percentage = (currentPopulation / maxPopulation) * 100;\n\n    if (percentage >= 90) {\n      return 'text-red-400';\n    } else if (percentage >= 75) {\n      return 'text-amber-400';\n    } else if (percentage >= 50) {\n      return 'text-green-400';\n    } else if (percentage >= 25) {\n      return 'text-blue-400';\n    }\n\n    return 'text-gray-400';\n  };\n\n  // Get icon for event type\n  const getEventIcon = (type: PopulationEvent['type']) => {\n    switch (type) {\n      case 'growth':\n        return <TrendingUp className=\"h-4 w-4 text-green-400\" />;\n      case 'decline':\n        return <TrendingUp className=\"h-4 w-4 rotate-180 transform text-red-400\" />;\n      case 'migration':\n        return <Users className=\"h-4 w-4 text-blue-400\" />;\n      case 'disaster':\n        return <AlertTriangle className=\"h-4 w-4 text-amber-400\" />;\n      case 'policy':\n        return <CheckCircle className=\"h-4 w-4 text-purple-400\" />;\n      default:\n        return <Users className=\"h-4 w-4 text-gray-400\" />;\n    }\n  };\n\n  return (\n    <div className=\"rounded-lg border border-gray-700 bg-gray-800 p-4\">\n      <div className=\"mb-4 flex items-center justify-between\">\n        <h3 className=\"text-lg font-medium text-white\">Population Management</h3>\n        <div className=\"flex items-center space-x-2\">\n          <button\n            className=\"rounded-md border border-gray-700 bg-gray-900 p-1 text-gray-400 hover:bg-gray-700 hover:text-white\"\n            onClick={() => setShowSettings(!showSettings)}\n            title=\"Settings\"\n          >\n            <Settings className=\"h-4 w-4\" />\n          </button>\n        </div>\n      </div>\n\n      {/* Population Stats */}\n      <div className=\"mb-4 grid grid-cols-2 gap-4\">\n        <div className=\"rounded-md border border-gray-700 bg-gray-900 p-3\">\n          <div className=\"mb-1 text-xs text-gray-400\">Current Population</div>\n          <div className=\"flex items-end justify-between\">\n            <div className=\"flex items-center\">\n              <Users className=\"mr-2 h-5 w-5 text-blue-400\" />\n              <span className={`text-xl font-bold ${getPopulationColor()}`}>\n                {currentPopulation.toLocaleString()}\n              </span>\n            </div>\n            <div className=\"text-xs text-gray-500\">\n              {((currentPopulation / maxPopulation) * 100).toFixed(1)}% of capacity\n            </div>\n          </div>\n          <div className=\"mt-2 h-2 w-full overflow-hidden rounded-full bg-gray-800\">\n            <motion.div\n              className=\"h-full bg-blue-500\"\n              style={{ width: `${(currentPopulation / maxPopulation) * 100}%` }}\n              initial={{ width: 0 }}\n              animate={{ width: `${(currentPopulation / maxPopulation) * 100}%` }}\n              transition={{ duration: 1 }}\n            />\n          </div>\n        </div>\n\n        <div className=\"rounded-md border border-gray-700 bg-gray-900 p-3\">\n          <div className=\"mb-1 text-xs text-gray-400\">Growth Rate</div>\n          <div className=\"flex items-end justify-between\">\n            <div className=\"flex items-center\">\n              <TrendingUp className=\"mr-2 h-5 w-5 text-green-400\" />\n              <span className=\"text-xl font-bold text-green-400\">\n                {(growthRate * 100).toFixed(2)}%\n              </span>\n            </div>\n            <div className=\"text-xs text-gray-500\">per cycle ({formatTime(cycleLength)})</div>\n          </div>\n          <div className=\"mt-2 flex items-center justify-between\">\n            <span className=\"text-xs text-gray-400\">Next growth:</span>\n            <span className=\"text-xs font-medium text-green-400\">\n              +{nextGrowthAmount.toLocaleString()}\n            </span>\n          </div>\n        </div>\n      </div>\n\n      {/* Growth Cycle Progress */}\n      <div className=\"mb-4 rounded-md border border-gray-700 bg-gray-900 p-3\">\n        <div className=\"mb-2 flex items-center justify-between\">\n          <div className=\"flex items-center\">\n            <Clock className=\"mr-2 h-4 w-4 text-blue-400\" />\n            <span className=\"text-sm font-medium text-white\">Growth Cycle</span>\n          </div>\n          <div className=\"text-xs text-gray-400\">\n            {isRunning ? 'Running' : 'Paused'} â€¢ Cycle #{cycleCount}\n          </div>\n        </div>\n\n        <div className=\"mb-2 h-2 w-full overflow-hidden rounded-full bg-gray-800\">\n          <motion.div\n            className=\"h-full bg-blue-500\"\n            style={{ width: `${cycleProgress}%` }}\n            animate={{ width: `${cycleProgress}%` }}\n            transition={{ duration: 0.5 }}\n          />\n        </div>\n\n        <div className=\"flex items-center justify-between\">\n          <div className=\"flex space-x-2\">\n            <button\n              className={`flex items-center space-x-1 rounded-md px-2 py-1 text-xs ${\n                isRunning\n                  ? 'bg-red-900/30 text-red-400 hover:bg-red-800/50'\n                  : 'bg-green-900/30 text-green-400 hover:bg-green-800/50'\n              }`}\n              onClick={handleAutomationToggle}\n            >\n              {isRunning ? (\n                <>\n                  <Pause className=\"h-3 w-3\" />\n                  <span>Pause</span>\n                </>\n              ) : (\n                <>\n                  <Play className=\"h-3 w-3\" />\n                  <span>Start</span>\n                </>\n              )}\n            </button>\n\n            <button\n              className=\"flex items-center space-x-1 rounded-md bg-gray-800 px-2 py-1 text-xs text-gray-400 hover:bg-gray-700\"\n              onClick={() => {\n                setCycleCount(0);\n                onCycleComplete?.(0);\n              }}\n            >\n              <RotateCcw className=\"h-3 w-3\" />\n              <span>Reset</span>\n            </button>\n          </div>\n\n          <div className=\"text-xs text-gray-400\">\n            {formatTime(cycleLength * (1 - cycleProgress / 100))} remaining\n          </div>\n        </div>\n      </div>\n\n      {/* Settings Panel */}\n      {showSettings && (\n        <motion.div\n          className=\"mb-4 rounded-md border border-gray-700 bg-gray-900 p-3\"\n          initial={{ opacity: 0, height: 0 }}\n          animate={{ opacity: 1, height: 'auto' }}\n          exit={{ opacity: 0, height: 0 }}\n        >\n          <div className=\"mb-3 text-sm font-medium text-white\">Growth Settings</div>\n\n          <div className=\"mb-3\">\n            <label className=\"mb-1 block text-xs text-gray-400\">Cycle Length (milliseconds)</label>\n            <div className=\"flex items-center space-x-2\">\n              <input\n                type=\"number\"\n                min=\"1000\"\n                step=\"1000\"\n                value={customCycleLength}\n                onChange={e => handleCycleLengthChange(Number(e.target.value))}\n                className=\"w-full rounded-md border border-gray-700 bg-gray-800 px-3 py-1 text-sm text-white\"\n              />\n              <button\n                className=\"rounded-md bg-blue-900/30 px-2 py-1 text-xs text-blue-400 hover:bg-blue-800/50\"\n                onClick={() => handleCycleLengthChange(customCycleLength)}\n              >\n                Apply\n              </button>\n            </div>\n            <div className=\"mt-1 text-xs text-gray-500\">\n              {formatTime(customCycleLength)} per cycle\n            </div>\n          </div>\n        </motion.div>\n      )}\n\n      {/* Population Events */}\n      <div className=\"overflow-hidden rounded-md border border-gray-700 bg-gray-900\">\n        <div\n          className=\"flex cursor-pointer items-center justify-between p-3\"\n          onClick={() => setShowEvents(!showEvents)}\n        >\n          <div className=\"flex items-center space-x-2\">\n            <Users className=\"h-4 w-4 text-blue-400\" />\n            <span className=\"text-sm font-medium text-white\">Population Events</span>\n          </div>\n          {showEvents ? (\n            <ChevronUp className=\"h-4 w-4 text-gray-400\" />\n          ) : (\n            <ChevronDown className=\"h-4 w-4 text-gray-400\" />\n          )}\n        </div>\n\n        {showEvents && (\n          <div className=\"border-t border-gray-700\">\n            {events.length === 0 ? (\n              <div className=\"p-3 text-center text-sm text-gray-500\">\n                No population events recorded\n              </div>\n            ) : (\n              <div className=\"max-h-48 overflow-y-auto\">\n                {events.map(event => (\n                  <div key={event?.id} className=\"border-b border-gray-700 p-3 last:border-b-0\">\n                    <div className=\"flex items-center justify-between\">\n                      <div className=\"flex items-center space-x-2\">\n                        {getEventIcon(event?.type)}\n                        <span className=\"text-sm font-medium capitalize text-white\">\n                          {event?.type}\n                        </span>\n                      </div>\n                      <span\n                        className={`text-sm font-medium ${\n                          event?.amount > 0 ? 'text-green-400' : 'text-red-400'\n                        }`}\n                      >\n                        {event?.amount > 0 ? '+' : ''}\n                        {event?.amount.toLocaleString()}\n                      </span>\n                    </div>\n                    <div className=\"mt-1 text-xs text-gray-400\">{event?.reason}</div>\n                    <div className=\"mt-1 text-xs text-gray-500\">\n                      {formatTimestamp(event?.timestamp)}\n                    </div>\n                  </div>\n                ))}\n              </div>\n            )}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/colony/BiodomeModule.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/colony/ColonyCore.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/colony/ColonyManagementSystem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/colony/ColonyMap.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_colonyId' is defined but never used.","line":31,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":31,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_population' is defined but never used.","line":33,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":33,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_maxPopulation' is defined but never used.","line":34,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":34,"endColumn":32},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_quality' is defined but never used.","line":35,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":35,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as React from 'react';\nimport { useEffect, useRef, useState } from 'react';\nimport { ResourceType } from './../../../types/resources/ResourceTypes';\ninterface BuildingData {\n  id: string;\n  type:\n    | 'housing'\n    | 'industry'\n    | 'agriculture'\n    | ResourceType.ENERGY\n    | ResourceType.RESEARCH\n    | 'infrastructure';\n  name: string;\n  level: number;\n  position: { x: number; y: number };\n  size: { width: number; height: number };\n  status: 'operational' | 'constructing' | 'upgrading' | 'damaged' | 'inactive';\n}\n\ninterface ColonyMapProps {\n  colonyId: string;\n  buildings: BuildingData[];\n  population: number;\n  maxPopulation: number;\n  quality: 'low' | 'medium' | 'high';\n  onBuildingClick?: (buildingId: string) => void;\n  onMapClick?: (position: { x: number; y: number }) => void;\n}\n\nexport function ColonyMap({\n  colonyId: _colonyId,\n  buildings,\n  population: _population,\n  maxPopulation: _maxPopulation,\n  quality: _quality,\n  onBuildingClick,\n  onMapClick,\n}: ColonyMapProps) {\n  const mapRef = useRef<HTMLDivElement>(null);\n  const [_dimensions, setDimensions] = useState({ width: 0, height: 0 });\n  const [scale, setScale] = useState(1);\n  const [position, setPosition] = useState({ x: 0, y: 0 });\n  const [isDragging, setIsDragging] = useState(false);\n  const [dragStart, setDragStart] = useState({ x: 0, y: 0 });\n  const [hoveredBuilding, setHoveredBuilding] = useState<string | null>(null);\n\n  // Set up map dimensions\n  useEffect(() => {\n    if (mapRef.current) {\n      const { width, height } = mapRef.current.getBoundingClientRect();\n      setDimensions({ width, height });\n    }\n\n    const handleResize = () => {\n      if (mapRef.current) {\n        const { width, height } = mapRef.current.getBoundingClientRect();\n        setDimensions({ width, height });\n      }\n    };\n\n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, []);\n\n  // Handle map dragging\n  const handleMouseDown = (e: React.MouseEvent) => {\n    setIsDragging(true);\n    setDragStart({ x: e.clientX - position.x, y: e.clientY - position.y });\n  };\n\n  const handleMouseMove = (e: React.MouseEvent) => {\n    if (isDragging) {\n      setPosition({\n        x: e.clientX - dragStart.x,\n        y: e.clientY - dragStart.y,\n      });\n    }\n  };\n\n  const handleMouseUp = () => {\n    setIsDragging(false);\n  };\n\n  // Handle map zooming\n  const handleWheel = (e: React.WheelEvent) => {\n    e.preventDefault();\n    const newScale = Math.max(0.5, Math.min(2, scale - e.deltaY * 0.001));\n    setScale(newScale);\n  };\n\n  // Get building color based on type\n  const getBuildingColor = (type: BuildingData['type']) => {\n    switch (type) {\n      case 'housing':\n        return 'bg-blue-800 border-blue-600';\n      case 'industry':\n        return 'bg-amber-800 border-amber-600';\n      case 'agriculture':\n        return 'bg-green-800 border-green-600';\n      case ResourceType.ENERGY:\n        return 'bg-yellow-800 border-yellow-600';\n      case ResourceType.RESEARCH:\n        return 'bg-purple-800 border-purple-600';\n      case 'infrastructure':\n        return 'bg-gray-800 border-gray-600';\n      default:\n        return 'bg-gray-800 border-gray-600';\n    }\n  };\n\n  // Get building status indicator\n  const getBuildingStatusIndicator = (status: BuildingData['status']) => {\n    switch (status) {\n      case 'operational':\n        return <div className=\"absolute right-1 top-1 h-2 w-2 rounded-full bg-green-500\"></div>;\n      case 'constructing':\n        return <div className=\"absolute right-1 top-1 h-2 w-2 rounded-full bg-blue-500\"></div>;\n      case 'upgrading':\n        return <div className=\"absolute right-1 top-1 h-2 w-2 rounded-full bg-purple-500\"></div>;\n      case 'damaged':\n        return <div className=\"absolute right-1 top-1 h-2 w-2 rounded-full bg-red-500\"></div>;\n      case 'inactive':\n        return <div className=\"absolute right-1 top-1 h-2 w-2 rounded-full bg-gray-500\"></div>;\n      default:\n        return null;\n    }\n  };\n\n  return (\n    <div className=\"rounded-lg border border-gray-700 bg-gray-800 p-4\">\n      <div className=\"mb-4 flex items-center justify-between\">\n        <h3 className=\"text-lg font-medium text-white\">Colony Map</h3>\n        <div className=\"flex items-center space-x-2\">\n          <button\n            className=\"rounded-md border border-gray-700 bg-gray-900 p-1 text-gray-400 hover:bg-gray-700\"\n            onClick={() => setScale(Math.min(2, scale + 0.1))}\n            title=\"Zoom In\"\n          >\n            <svg className=\"h-4 w-4\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n              <path\n                strokeLinecap=\"round\"\n                strokeLinejoin=\"round\"\n                strokeWidth={2}\n                d=\"M12 6v6m0 0v6m0-6h6m-6 0H6\"\n              />\n            </svg>\n          </button>\n          <button\n            className=\"rounded-md border border-gray-700 bg-gray-900 p-1 text-gray-400 hover:bg-gray-700\"\n            onClick={() => setScale(Math.max(0.5, scale - 0.1))}\n            title=\"Zoom Out\"\n          >\n            <svg className=\"h-4 w-4\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M18 12H6\" />\n            </svg>\n          </button>\n          <button\n            className=\"rounded-md border border-gray-700 bg-gray-900 p-1 text-gray-400 hover:bg-gray-700\"\n            onClick={() => {\n              setScale(1);\n              setPosition({ x: 0, y: 0 });\n            }}\n            title=\"Reset View\"\n          >\n            <svg className=\"h-4 w-4\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n              <path\n                strokeLinecap=\"round\"\n                strokeLinejoin=\"round\"\n                strokeWidth={2}\n                d=\"M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15\"\n              />\n            </svg>\n          </button>\n        </div>\n      </div>\n\n      <div\n        ref={mapRef}\n        className=\"relative h-96 overflow-hidden rounded-lg border border-gray-700 bg-gray-950\"\n        onMouseDown={handleMouseDown}\n        onMouseMove={handleMouseMove}\n        onMouseUp={handleMouseUp}\n        onMouseLeave={handleMouseUp}\n        onWheel={handleWheel}\n        onClick={e => {\n          if (!isDragging && onMapClick) {\n            const rect = mapRef.current?.getBoundingClientRect();\n            if (rect) {\n              const x = (e.clientX - rect.left - position.x) / scale;\n              const y = (e.clientY - rect.top - position.y) / scale;\n              onMapClick({ x, y });\n            }\n          }\n        }}\n      >\n        {/* Map Grid */}\n        <div\n          className=\"absolute left-0 top-0 grid\"\n          style={{\n            transform: `translate(${position.x}px, ${position.y}px) scale(${scale})`,\n            transformOrigin: '0 0',\n            gridTemplateColumns: 'repeat(20, 20px)',\n            gridTemplateRows: 'repeat(20, 20px)',\n            width: '400px',\n            height: '400px',\n          }}\n        >\n          {/* Grid Lines */}\n          {Array.from({ length: 21 }).map((_, i) => (\n            <div\n              key={`h-${i}`}\n              className=\"absolute border-t border-gray-800\"\n              style={{ top: `${i * 20}px`, left: 0, width: '100%' }}\n            />\n          ))}\n          {Array.from({ length: 21 }).map((_, i) => (\n            <div\n              key={`v-${i}`}\n              className=\"absolute border-l border-gray-800\"\n              style={{ left: `${i * 20}px`, top: 0, height: '100%' }}\n            />\n          ))}\n\n          {/* Buildings */}\n          {buildings.map(building => (\n            <div\n              key={building.id}\n              className={`absolute cursor-pointer border ${getBuildingColor(building.type)} ${\n                hoveredBuilding === building.id ? 'ring-2 ring-white' : ''\n              }`}\n              style={{\n                left: `${building.position.x}px`,\n                top: `${building.position.y}px`,\n                width: `${building.size.width}px`,\n                height: `${building.size.height}px`,\n              }}\n              onClick={e => {\n                e.stopPropagation();\n                onBuildingClick?.(building.id);\n              }}\n              onMouseEnter={() => setHoveredBuilding(building.id)}\n              onMouseLeave={() => setHoveredBuilding(null)}\n            >\n              {getBuildingStatusIndicator(building.status)}\n\n              <div className=\"absolute bottom-1 left-1 text-xs font-medium text-white\">\n                {building.name}\n              </div>\n\n              {building.level > 1 && (\n                <div className=\"absolute bottom-1 right-1 rounded-full bg-gray-900 px-1 text-xs font-medium text-white\">\n                  {building.level}\n                </div>\n              )}\n            </div>\n          ))}\n        </div>\n\n        {/* Building Tooltip */}\n        {hoveredBuilding && (\n          <div className=\"absolute right-2 top-2 w-48 rounded-md border border-gray-700 bg-gray-800 p-2 shadow-lg\">\n            {(() => {\n              const building = buildings.find(b => b.id === hoveredBuilding);\n              if (!building) {\n                return null;\n              }\n\n              return (\n                <>\n                  <div className=\"mb-1 text-sm font-medium text-white\">{building.name}</div>\n                  <div className=\"mb-1 text-xs text-gray-400\">\n                    Type: {building.type.charAt(0).toUpperCase() + building.type.slice(1)}\n                  </div>\n                  <div className=\"mb-1 text-xs text-gray-400\">Level: {building.level}</div>\n                  <div className=\"text-xs text-gray-400\">\n                    Status: {building.status.charAt(0).toUpperCase() + building.status.slice(1)}\n                  </div>\n                </>\n              );\n            })()}\n          </div>\n        )}\n      </div>\n\n      {/* Legend */}\n      <div className=\"mt-4 grid grid-cols-3 gap-2\">\n        <div className=\"flex items-center space-x-2\">\n          <div className=\"h-3 w-3 rounded-sm border border-blue-600 bg-blue-800\"></div>\n          <span className=\"text-xs text-gray-400\">Housing</span>\n        </div>\n        <div className=\"flex items-center space-x-2\">\n          <div className=\"h-3 w-3 rounded-sm border border-amber-600 bg-amber-800\"></div>\n          <span className=\"text-xs text-gray-400\">Industry</span>\n        </div>\n        <div className=\"flex items-center space-x-2\">\n          <div className=\"h-3 w-3 rounded-sm border border-green-600 bg-green-800\"></div>\n          <span className=\"text-xs text-gray-400\">Agriculture</span>\n        </div>\n        <div className=\"flex items-center space-x-2\">\n          <div className=\"h-3 w-3 rounded-sm border border-yellow-600 bg-yellow-800\"></div>\n          <span className=\"text-xs text-gray-400\">Energy</span>\n        </div>\n        <div className=\"flex items-center space-x-2\">\n          <div className=\"h-3 w-3 rounded-sm border border-purple-600 bg-purple-800\"></div>\n          <span className=\"text-xs text-gray-400\">Research</span>\n        </div>\n        <div className=\"flex items-center space-x-2\">\n          <div className=\"h-3 w-3 rounded-sm border border-gray-600 bg-gray-800\"></div>\n          <span className=\"text-xs text-gray-400\">Infrastructure</span>\n        </div>\n      </div>\n    </div>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/colony/CulturalCenter.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/colony/EconomicHub.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/colony/GrowthRateModifiers.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_colonyId' is defined but never used.","line":42,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":42,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { motion } from 'framer-motion';\nimport {\n  Apple,\n  ChevronDown,\n  ChevronUp,\n  Heart,\n  Home,\n  Info,\n  Leaf,\n  Minus,\n  Plus,\n  Zap,\n} from 'lucide-react';\nimport { useState } from 'react';\nimport { ResourceType } from './../../../types/resources/ResourceTypes';\ninterface GrowthModifier {\n  id: string;\n  name: string;\n  description: string;\n  effect: number; // Percentage modifier (e.g., 1.1 = +10%)\n  type: ResourceType.FOOD | 'housing' | 'healthcare' | 'environment' | ResourceType.ENERGY;\n  active: boolean;\n}\n\ninterface GrowthRateModifiersProps {\n  colonyId: string;\n  baseGrowthRate: number; // Base growth rate per cycle (e.g., 0.05 = 5%)\n  modifiers: GrowthModifier[];\n  onModifierToggle?: (modifierId: string, active: boolean) => void;\n  onModifierAdd?: (type: GrowthModifier['type']) => void;\n  onModifierRemove?: (modifierId: string) => void;\n}\n\n/**\n * GrowthRateModifiers component\n *\n * Displays and manages growth rate modifiers for a colony.\n * Shows the effective growth rate based on active modifiers.\n * Allows toggling modifiers on/off and adding/removing modifiers.\n */\nexport function GrowthRateModifiers({\n  colonyId: _colonyId,\n  baseGrowthRate,\n  modifiers,\n  onModifierToggle,\n  onModifierAdd,\n  onModifierRemove,\n}: GrowthRateModifiersProps) {\n  const [expandedSection, setExpandedSection] = useState<string | null>(null);\n  const [hoveredModifier, setHoveredModifier] = useState<string | null>(null);\n\n  // Calculate effective growth rate based on active modifiers\n  const calculateEffectiveGrowthRate = () => {\n    const activeModifiers = modifiers.filter(m => m.active);\n\n    if (activeModifiers.length === 0) {\n      return baseGrowthRate;\n    }\n\n    const totalEffect = activeModifiers.reduce((total, modifier) => {\n      return total * modifier.effect;\n    }, 1);\n\n    return baseGrowthRate * totalEffect;\n  };\n\n  const effectiveGrowthRate = calculateEffectiveGrowthRate();\n\n  // Format growth rate as percentage\n  const formatGrowthRate = (rate: number) => {\n    return `${(rate * 100).toFixed(2)}%`;\n  };\n\n  // Get growth rate change from base\n  const getGrowthRateChange = () => {\n    const change = effectiveGrowthRate - baseGrowthRate;\n    const percentChange = (change / baseGrowthRate) * 100;\n\n    if (Math.abs(percentChange) < 0.01) {\n      return 'No change';\n    }\n\n    return `${percentChange > 0 ? '+' : ''}${percentChange.toFixed(2)}%`;\n  };\n\n  // Get color based on growth rate change\n  const getGrowthRateColor = () => {\n    const change = effectiveGrowthRate - baseGrowthRate;\n\n    if (change > 0) {\n      return 'text-green-400';\n    } else if (change < 0) {\n      return 'text-red-400';\n    }\n\n    return 'text-gray-400';\n  };\n\n  // Toggle section expansion\n  const toggleSection = (section: string) => {\n    if (expandedSection === section) {\n      setExpandedSection(null);\n    } else {\n      setExpandedSection(section);\n    }\n  };\n\n  // Get icon for modifier type\n  const getModifierIcon = (type: GrowthModifier['type']) => {\n    switch (type) {\n      case ResourceType.FOOD:\n        return <Apple className=\"h-4 w-4 text-amber-400\" />;\n      case 'housing':\n        return <Home className=\"h-4 w-4 text-blue-400\" />;\n      case 'healthcare':\n        return <Heart className=\"h-4 w-4 text-red-400\" />;\n      case 'environment':\n        return <Leaf className=\"h-4 w-4 text-green-400\" />;\n      case ResourceType.ENERGY:\n        return <Zap className=\"h-4 w-4 text-yellow-400\" />;\n      default:\n        return <Info className=\"h-4 w-4 text-gray-400\" />;\n    }\n  };\n\n  // Get color for modifier type\n  const getModifierTypeColor = (type: GrowthModifier['type']) => {\n    switch (type) {\n      case ResourceType.FOOD:\n        return 'bg-amber-900/30 text-amber-400 border-amber-700';\n      case 'housing':\n        return 'bg-blue-900/30 text-blue-400 border-blue-700';\n      case 'healthcare':\n        return 'bg-red-900/30 text-red-400 border-red-700';\n      case 'environment':\n        return 'bg-green-900/30 text-green-400 border-green-700';\n      case ResourceType.ENERGY:\n        return 'bg-yellow-900/30 text-yellow-400 border-yellow-700';\n      default:\n        return 'bg-gray-900/30 text-gray-400 border-gray-700';\n    }\n  };\n\n  // Group modifiers by type\n  const modifiersByType = modifiers.reduce(\n    (groups, modifier) => {\n      if (!groups[modifier.type]) {\n        groups[modifier.type] = [];\n      }\n\n      groups[modifier.type].push(modifier);\n      return groups;\n    },\n    {} as Record<GrowthModifier['type'], GrowthModifier[]>\n  );\n\n  // Get available modifier types for adding\n  const availableModifierTypes: GrowthModifier['type'][] = [\n    ResourceType.FOOD,\n    'housing',\n    'healthcare',\n    'environment',\n    ResourceType.ENERGY,\n  ];\n\n  return (\n    <div className=\"rounded-lg border border-gray-700 bg-gray-800 p-4\">\n      <div className=\"mb-4\">\n        <h3 className=\"text-lg font-medium text-white\">Growth Rate Modifiers</h3>\n        <div className=\"mt-2 flex items-center justify-between\">\n          <div className=\"flex items-center space-x-2\">\n            <span className=\"text-sm text-gray-400\">Base Rate:</span>\n            <span className=\"text-sm font-medium text-white\">\n              {formatGrowthRate(baseGrowthRate)}\n            </span>\n          </div>\n          <div className=\"flex items-center space-x-2\">\n            <span className=\"text-sm text-gray-400\">Effective Rate:</span>\n            <span className={`text-sm font-medium ${getGrowthRateColor()}`}>\n              {formatGrowthRate(effectiveGrowthRate)}\n            </span>\n            <span className={`text-xs ${getGrowthRateColor()}`}>({getGrowthRateChange()})</span>\n          </div>\n        </div>\n      </div>\n\n      {/* Modifiers by Type */}\n      <div className=\"space-y-3\">\n        {Object.entries(modifiersByType).map(([type, typeModifiers]) => (\n          <div key={type} className=\"overflow-hidden rounded-md border border-gray-700 bg-gray-900\">\n            <div\n              className=\"flex cursor-pointer items-center justify-between p-3\"\n              onClick={() => toggleSection(type)}\n            >\n              <div className=\"flex items-center space-x-2\">\n                {getModifierIcon(type as GrowthModifier['type'])}\n                <span className=\"text-sm font-medium capitalize text-white\">{type}</span>\n                <span className=\"text-xs text-gray-400\">\n                  ({typeModifiers.filter(m => m.active).length}/{typeModifiers.length} active)\n                </span>\n              </div>\n              <div className=\"flex items-center space-x-2\">\n                <span\n                  className={`text-xs ${typeModifiers.some(m => m.active) ? 'text-green-400' : 'text-gray-500'}`}\n                >\n                  {typeModifiers.some(m => m.active)\n                    ? `+${((typeModifiers.filter(m => m.active).reduce((total, m) => total * m.effect, 1) - 1) * 100).toFixed(2)}%`\n                    : 'No effect'}\n                </span>\n                {expandedSection === type ? (\n                  <ChevronUp className=\"h-4 w-4 text-gray-400\" />\n                ) : (\n                  <ChevronDown className=\"h-4 w-4 text-gray-400\" />\n                )}\n              </div>\n            </div>\n\n            {expandedSection === type && (\n              <div className=\"border-t border-gray-700 p-3\">\n                <div className=\"space-y-2\">\n                  {typeModifiers.map(modifier => (\n                    <div\n                      key={modifier.id}\n                      className={`relative rounded-md border p-2 transition-all ${\n                        modifier.active\n                          ? getModifierTypeColor(modifier.type)\n                          : 'border-gray-700 bg-gray-800/50 text-gray-400'\n                      } ${hoveredModifier === modifier.id ? 'scale-[1.02]' : 'scale-100'}`}\n                      onMouseEnter={() => setHoveredModifier(modifier.id)}\n                      onMouseLeave={() => setHoveredModifier(null)}\n                    >\n                      <div className=\"flex items-center justify-between\">\n                        <div className=\"flex items-center space-x-2\">\n                          {getModifierIcon(modifier.type)}\n                          <span className=\"text-sm font-medium\">{modifier.name}</span>\n                        </div>\n                        <div className=\"flex items-center space-x-3\">\n                          <span\n                            className={`text-xs ${modifier.effect > 1 ? 'text-green-400' : modifier.effect < 1 ? 'text-red-400' : 'text-gray-400'}`}\n                          >\n                            {modifier.effect > 1 ? '+' : ''}\n                            {((modifier.effect - 1) * 100).toFixed(2)}%\n                          </span>\n                          <button\n                            className={`flex h-6 w-6 items-center justify-center rounded-full transition-colors ${\n                              modifier.active\n                                ? 'bg-gray-700 hover:bg-gray-600'\n                                : 'bg-gray-800 hover:bg-gray-700'\n                            }`}\n                            onClick={() => onModifierToggle?.(modifier.id, !modifier.active)}\n                          >\n                            {modifier.active ? (\n                              <Minus className=\"h-3 w-3 text-gray-300\" />\n                            ) : (\n                              <Plus className=\"h-3 w-3 text-gray-300\" />\n                            )}\n                          </button>\n                          {onModifierRemove && (\n                            <button\n                              className=\"flex h-6 w-6 items-center justify-center rounded-full bg-red-900/30 text-red-400 hover:bg-red-800/50\"\n                              onClick={() => onModifierRemove(modifier.id)}\n                            >\n                              <svg\n                                className=\"h-3 w-3\"\n                                fill=\"none\"\n                                viewBox=\"0 0 24 24\"\n                                stroke=\"currentColor\"\n                              >\n                                <path\n                                  strokeLinecap=\"round\"\n                                  strokeLinejoin=\"round\"\n                                  strokeWidth={2}\n                                  d=\"M6 18L18 6M6 6l12 12\"\n                                />\n                              </svg>\n                            </button>\n                          )}\n                        </div>\n                      </div>\n\n                      {hoveredModifier === modifier.id && (\n                        <motion.div\n                          initial={{ opacity: 0, y: 5 }}\n                          animate={{ opacity: 1, y: 0 }}\n                          className=\"mt-2 text-xs text-gray-400\"\n                        >\n                          {modifier.description}\n                        </motion.div>\n                      )}\n                    </div>\n                  ))}\n                </div>\n\n                {onModifierAdd && (\n                  <div className=\"mt-3 flex justify-end\">\n                    <button\n                      className=\"flex items-center space-x-1 rounded-md border border-gray-700 bg-gray-800 px-2 py-1 text-xs text-gray-300 hover:bg-gray-700\"\n                      onClick={() => onModifierAdd(type as GrowthModifier['type'])}\n                    >\n                      <Plus className=\"h-3 w-3\" />\n                      <span>Add {type} modifier</span>\n                    </button>\n                  </div>\n                )}\n              </div>\n            )}\n          </div>\n        ))}\n      </div>\n\n      {/* Add New Modifier Type */}\n      {onModifierAdd && (\n        <div className=\"mt-4 border-t border-gray-700 pt-4\">\n          <div className=\"flex flex-wrap gap-2\">\n            {availableModifierTypes\n              .filter(type => !modifiersByType[type] || modifiersByType[type].length === 0)\n              .map(type => (\n                <button\n                  key={type}\n                  className={`flex items-center space-x-1 rounded-md border px-2 py-1 text-xs ${getModifierTypeColor(type)}`}\n                  onClick={() => onModifierAdd(type)}\n                >\n                  {getModifierIcon(type)}\n                  <span>Add {type}</span>\n                </button>\n              ))}\n          </div>\n        </div>\n      )}\n\n      {/* Growth Rate Visualization */}\n      <div className=\"mt-4 border-t border-gray-700 pt-4\">\n        <div className=\"mb-2 flex items-center justify-between\">\n          <span className=\"text-xs text-gray-400\">Growth Rate Impact</span>\n          <span className=\"text-xs text-gray-400\">\n            Base: {formatGrowthRate(baseGrowthRate)} â†’ Effective:{' '}\n            {formatGrowthRate(effectiveGrowthRate)}\n          </span>\n        </div>\n\n        <div className=\"h-8 w-full overflow-hidden rounded-md bg-gray-900\">\n          <div className=\"relative h-full w-full\">\n            {/* Base Growth Rate Marker */}\n            <div\n              className=\"absolute bottom-0 top-0 border-r border-dashed border-white/30\"\n              style={{ left: `${Math.min(100, baseGrowthRate * 1000)}%` }}\n            >\n              <div className=\"absolute -right-1 -top-1 h-2 w-2 rounded-full bg-white\"></div>\n            </div>\n\n            {/* Effective Growth Rate Bar */}\n            <motion.div\n              className={`absolute bottom-0 h-full ${effectiveGrowthRate > baseGrowthRate ? 'bg-green-500/30' : 'bg-red-500/30'}`}\n              style={{\n                width: `${Math.min(100, effectiveGrowthRate * 1000)}%`,\n                borderRight: '2px solid',\n                borderColor:\n                  effectiveGrowthRate > baseGrowthRate ? 'rgb(34, 197, 94)' : 'rgb(239, 68, 68)',\n              }}\n              initial={{ width: `${Math.min(100, baseGrowthRate * 1000)}%` }}\n              animate={{ width: `${Math.min(100, effectiveGrowthRate * 1000)}%` }}\n              transition={{ duration: 1, ease: 'easeOut' }}\n            >\n              <div\n                className=\"absolute -right-1 -top-1 h-2 w-2 rounded-full\"\n                style={{\n                  backgroundColor:\n                    effectiveGrowthRate > baseGrowthRate ? 'rgb(34, 197, 94)' : 'rgb(239, 68, 68)',\n                }}\n              ></div>\n            </motion.div>\n\n            {/* Modifier Impact Indicators */}\n            {modifiers\n              .filter(m => m.active)\n              .map((modifier, index) => {\n                // Calculate position based on impact\n                const position = Math.min(\n                  100,\n                  baseGrowthRate *\n                    1000 *\n                    modifiers\n                      .filter(m => m.active)\n                      .slice(0, index + 1)\n                      .reduce((total, m) => total * m.effect, 1)\n                );\n\n                return (\n                  <div\n                    key={modifier.id}\n                    className=\"absolute bottom-0 top-0 border-r border-dotted\"\n                    style={{\n                      left: `${position}%`,\n                      borderColor:\n                        modifier.effect > 1 ? 'rgba(34, 197, 94, 0.5)' : 'rgba(239, 68, 68, 0.5)',\n                    }}\n                  >\n                    <div\n                      className=\"absolute -top-1 h-2 w-2 -translate-x-1/2 rounded-full\"\n                      style={{\n                        backgroundColor:\n                          modifier.effect > 1 ? 'rgba(34, 197, 94, 0.5)' : 'rgba(239, 68, 68, 0.5)',\n                      }}\n                    ></div>\n                  </div>\n                );\n              })}\n          </div>\n        </div>\n\n        <div className=\"mt-2 flex justify-between\">\n          <span className=\"text-xs text-gray-500\">0%</span>\n          <span className=\"text-xs text-gray-500\">0.1%</span>\n          <span className=\"text-xs text-gray-500\">0.2%</span>\n          <span className=\"text-xs text-gray-500\">0.3%</span>\n          <span className=\"text-xs text-gray-500\">0.4%</span>\n          <span className=\"text-xs text-gray-500\">0.5%+</span>\n        </div>\n      </div>\n    </div>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/colony/HabitableWorld.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/colony/PopulationGrowthModule.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_quality' is defined but never used.","line":44,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":44,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'subscribe' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":55,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":55,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { AnimatePresence, motion } from 'framer-motion';\nimport { AlertTriangle, Droplet, Leaf, TrendingUp, Users, Zap } from 'lucide-react';\nimport { useCallback, useEffect, useState } from 'react';\nimport { useModuleEvents } from '../../../hooks/events/useModuleEvents';\nimport { moduleEventBus } from '../../../lib/events/ModuleEventBus';\nimport { EventType } from '../../../types/events/EventTypes';\nimport { StandardizedEvent } from '../../../types/events/StandardizedEvents';\nimport { ResourceType } from '../../../types/resources/ResourceTypes';\n\ninterface GrowthModifier {\n  id: string;\n  name: string;\n  description: string;\n  effect: number; // Percentage modifier (e.g., 1.1 = +10%)\n  type: ResourceType.FOOD | 'housing' | 'healthcare' | 'environment' | ResourceType.ENERGY;\n  active: boolean;\n}\n\ninterface PopulationGrowthModuleProps {\n  colonyId: string;\n  currentPopulation: number;\n  maxPopulation: number;\n  baseGrowthRate: number; // Base growth rate per cycle (e.g., 0.05 = 5%)\n  growthModifiers: GrowthModifier[];\n  cycleLength: number; // Length of a growth cycle in milliseconds\n  quality: 'low' | 'medium' | 'high';\n  onPopulationChange?: (newPopulation: number) => void;\n  onModifierToggle?: (modifierId: string, active: boolean) => void;\n}\n\n/**\n * PopulationGrowthModule component\n *\n * Displays and manages population growth mechanics for a colony.\n * Shows growth rate, modifiers, and provides controls for adjusting growth parameters.\n */\nexport function PopulationGrowthModule({\n  colonyId,\n  currentPopulation,\n  maxPopulation,\n  baseGrowthRate,\n  growthModifiers,\n  cycleLength,\n  quality: _quality,\n  onPopulationChange,\n  onModifierToggle,\n}: PopulationGrowthModuleProps) {\n  const [population, setPopulation] = useState(currentPopulation);\n  const [isGrowing, setIsGrowing] = useState(false);\n  const [growthHistory, setGrowthHistory] = useState<number[]>([]);\n  const [showModifiers, setShowModifiers] = useState(false);\n  const [autoGrowth, setAutoGrowth] = useState(false);\n  const [growthInterval, setGrowthInterval] = useState<NodeJS.Timeout | null>(null);\n\n  const { subscribe } = useModuleEvents();\n\n  // Calculate effective growth rate with all active modifiers\n  const effectiveGrowthRate = useCallback(() => {\n    const activeModifiers = growthModifiers.filter(m => m.active);\n    if (activeModifiers.length === 0) {\n      return baseGrowthRate;\n    }\n\n    const totalEffect = activeModifiers.reduce((total, modifier) => {\n      return total * modifier.effect;\n    }, 1);\n\n    return baseGrowthRate * totalEffect;\n  }, [baseGrowthRate, growthModifiers]);\n\n  // Format growth rate as percentage\n  const formattedGrowthRate = `${(effectiveGrowthRate() * 100).toFixed(2)}%`;\n\n  // Population percentage of maximum\n  const populationPercentage = Math.min(100, Math.round((population / maxPopulation) * 100));\n\n  // Population status\n  const getPopulationStatus = useCallback(() => {\n    if (populationPercentage < 30) {\n      return 'low';\n    }\n    if (populationPercentage > 90) {\n      return 'critical';\n    }\n    return 'normal';\n  }, [populationPercentage]);\n\n  const populationStatus = getPopulationStatus();\n\n  // Handle manual population growth\n  const handleGrowthCycle = useCallback(() => {\n    if (population >= maxPopulation) {\n      setIsGrowing(false);\n      return;\n    }\n\n    setIsGrowing(true);\n\n    // Calculate growth amount\n    const growthAmount = Math.floor(population * effectiveGrowthRate());\n    const newPopulation = Math.min(maxPopulation, population + growthAmount);\n\n    // Update population\n    setPopulation(newPopulation);\n    onPopulationChange?.(newPopulation);\n\n    // Update growth history\n    setGrowthHistory(prev => [...prev.slice(-9), growthAmount]);\n\n    // Emit population update event\n    const event: StandardizedEvent = {\n      type: EventType.MODULE_UPDATED,\n      moduleId: colonyId,\n      moduleType: ResourceType.POPULATION,\n      timestamp: Date.now(),\n      data: {\n        stats: {\n          [ResourceType.POPULATION]: newPopulation,\n        },\n      },\n    };\n    moduleEventBus.emit(event);\n\n    setTimeout(() => {\n      setIsGrowing(false);\n    }, 1000);\n  }, [population, maxPopulation, effectiveGrowthRate, colonyId, onPopulationChange]);\n\n  // Handle modifier toggle\n  const handleModifierToggle = useCallback(\n    (modifierId: string) => {\n      const modifier = growthModifiers.find(m => m.id === modifierId);\n      if (modifier) {\n        onModifierToggle?.(modifierId, !modifier.active);\n      }\n    },\n    [growthModifiers, onModifierToggle]\n  );\n\n  // Handle auto growth toggle\n  useEffect(() => {\n    if (autoGrowth) {\n      const interval = setInterval(() => {\n        handleGrowthCycle();\n      }, cycleLength);\n\n      setGrowthInterval(interval);\n\n      return () => {\n        clearInterval(interval);\n        setGrowthInterval(null);\n      };\n    } else if (growthInterval) {\n      clearInterval(growthInterval);\n      setGrowthInterval(null);\n    }\n  }, [autoGrowth, cycleLength, handleGrowthCycle]);\n\n  // Update local population when prop changes\n  useEffect(() => {\n    setPopulation(currentPopulation);\n  }, [currentPopulation]);\n\n  // Get icon for modifier type\n  const getModifierIcon = useCallback((type: GrowthModifier['type']) => {\n    switch (type) {\n      case ResourceType.FOOD:\n        return <Droplet className=\"h-4 w-4 text-blue-400\" />;\n      case 'housing':\n        return <Users className=\"h-4 w-4 text-indigo-400\" />;\n      case 'healthcare':\n        return <AlertTriangle className=\"h-4 w-4 text-red-400\" />;\n      case 'environment':\n        return <Leaf className=\"h-4 w-4 text-green-400\" />;\n      case ResourceType.ENERGY:\n        return <Zap className=\"h-4 w-4 text-yellow-400\" />;\n    }\n  }, []);\n\n  return (\n    <div className=\"rounded-lg border border-gray-700 bg-gray-800 p-4\">\n      <div className=\"mb-4 flex items-center justify-between\">\n        <h3 className=\"text-lg font-medium text-white\">Population Growth</h3>\n        <div className=\"flex items-center space-x-2\">\n          <span className=\"text-sm text-gray-400\">Auto Growth</span>\n          <button\n            className={`h-6 w-12 rounded-full ${\n              autoGrowth ? 'bg-green-600' : 'bg-gray-600'\n            } relative transition-colors`}\n            onClick={() => setAutoGrowth(!autoGrowth)}\n          >\n            <span\n              className={`absolute top-1 h-4 w-4 rounded-full bg-white transition-all ${\n                autoGrowth ? 'left-7' : 'left-1'\n              }`}\n            />\n          </button>\n        </div>\n      </div>\n\n      {/* Population Display */}\n      <div className=\"mb-6\">\n        <div className=\"mb-1 flex items-center justify-between\">\n          <div className=\"flex items-center space-x-2\">\n            <Users className=\"h-5 w-5 text-blue-400\" />\n            <span className=\"text-sm font-medium text-gray-300\">Current Population</span>\n          </div>\n          <span className=\"text-sm font-medium text-white\">{population.toLocaleString()}</span>\n        </div>\n\n        <div className=\"mb-1 flex justify-between text-xs\">\n          <span className=\"text-gray-400\">Capacity</span>\n          <span\n            className={`${\n              populationStatus === 'critical'\n                ? 'text-red-400'\n                : populationStatus === 'low'\n                  ? 'text-yellow-400'\n                  : 'text-gray-300'\n            }`}\n          >\n            {populationPercentage}%\n          </span>\n        </div>\n\n        <div className=\"h-2 overflow-hidden rounded-full bg-gray-700\">\n          <motion.div\n            className={`h-full rounded-full ${\n              populationStatus === 'critical'\n                ? 'bg-red-500'\n                : populationStatus === 'low'\n                  ? 'bg-yellow-500'\n                  : 'bg-blue-500'\n            }`}\n            initial={{ width: 0 }}\n            animate={{ width: `${populationPercentage}%` }}\n            transition={{ duration: 0.5 }}\n          />\n        </div>\n\n        <div className=\"mt-1 flex justify-between text-xs text-gray-500\">\n          <span>0</span>\n          <span>{maxPopulation.toLocaleString()}</span>\n        </div>\n      </div>\n\n      {/* Growth Rate */}\n      <div className=\"mb-4\">\n        <div className=\"mb-1 flex items-center justify-between\">\n          <div className=\"flex items-center space-x-2\">\n            <TrendingUp className=\"h-5 w-5 text-green-400\" />\n            <span className=\"text-sm font-medium text-gray-300\">Growth Rate</span>\n          </div>\n          <div className=\"flex items-center space-x-1\">\n            <span className=\"text-sm font-medium text-green-400\">{formattedGrowthRate}</span>\n            <span className=\"text-xs text-gray-500\">per cycle</span>\n          </div>\n        </div>\n\n        {/* Growth History Chart */}\n        <div className=\"mt-2 h-12 w-full\">\n          <div className=\"flex h-full items-end justify-between\">\n            {growthHistory.length === 0 ? (\n              <div className=\"flex h-full w-full items-center justify-center\">\n                <span className=\"text-xs text-gray-500\">No growth data yet</span>\n              </div>\n            ) : (\n              growthHistory.map((amount, index) => {\n                const percentage = Math.min(100, (amount / (maxPopulation * 0.1)) * 100);\n                return (\n                  <motion.div\n                    key={index}\n                    className=\"w-[8%] bg-green-500\"\n                    initial={{ height: 0 }}\n                    animate={{ height: `${percentage}%` }}\n                    transition={{ duration: 0.3, delay: index * 0.05 }}\n                  />\n                );\n              })\n            )}\n          </div>\n        </div>\n      </div>\n\n      {/* Growth Controls */}\n      <div className=\"mb-4\">\n        <button\n          className={`w-full rounded-md py-2 text-sm font-medium transition-colors ${\n            isGrowing || population >= maxPopulation\n              ? 'cursor-not-allowed bg-gray-700 text-gray-500'\n              : 'bg-blue-600 text-white hover:bg-blue-700'\n          }`}\n          onClick={handleGrowthCycle}\n          disabled={isGrowing || population >= maxPopulation}\n        >\n          {isGrowing\n            ? 'Growing...'\n            : population >= maxPopulation\n              ? 'Maximum Population Reached'\n              : 'Trigger Growth Cycle'}\n        </button>\n      </div>\n\n      {/* Growth Modifiers */}\n      <div>\n        <button\n          className=\"mb-2 flex w-full items-center justify-between rounded-md bg-gray-700 px-3 py-2 text-sm font-medium text-gray-300 hover:bg-gray-600\"\n          onClick={() => setShowModifiers(!showModifiers)}\n        >\n          <span>Growth Modifiers</span>\n          <span className=\"text-xs text-gray-400\">\n            {growthModifiers.filter(m => m.active).length} Active\n          </span>\n        </button>\n\n        <AnimatePresence>\n          {showModifiers && (\n            <motion.div\n              initial={{ height: 0, opacity: 0 }}\n              animate={{ height: 'auto', opacity: 1 }}\n              exit={{ height: 0, opacity: 0 }}\n              transition={{ duration: 0.3 }}\n              className=\"overflow-hidden\"\n            >\n              <div className=\"space-y-2 rounded-md bg-gray-900 p-3\">\n                {growthModifiers.map(modifier => (\n                  <div\n                    key={modifier.id}\n                    className=\"flex items-center justify-between rounded-md bg-gray-800 p-2\"\n                  >\n                    <div className=\"flex items-center space-x-2\">\n                      {getModifierIcon(modifier.type)}\n                      <div>\n                        <div className=\"text-sm font-medium text-gray-300\">{modifier.name}</div>\n                        <div className=\"text-xs text-gray-500\">{modifier.description}</div>\n                      </div>\n                    </div>\n                    <div className=\"flex items-center space-x-3\">\n                      <span\n                        className={`text-sm ${\n                          modifier.effect > 1 ? 'text-green-400' : 'text-red-400'\n                        }`}\n                      >\n                        {modifier.effect > 1 ? '+' : ''}\n                        {((modifier.effect - 1) * 100).toFixed(0)}%\n                      </span>\n                      <button\n                        className={`h-5 w-10 rounded-full ${\n                          modifier.active ? 'bg-green-600' : 'bg-gray-600'\n                        } relative transition-colors`}\n                        onClick={() => handleModifierToggle(modifier.id)}\n                      >\n                        <span\n                          className={`absolute top-0.5 h-4 w-4 rounded-full bg-white transition-all ${\n                            modifier.active ? 'left-5' : 'left-1'\n                          }`}\n                        />\n                      </button>\n                    </div>\n                  </div>\n                ))}\n              </div>\n            </motion.div>\n          )}\n        </AnimatePresence>\n      </div>\n    </div>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/colony/PopulationProjectionChart.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/colony/ResourceDashboard.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_colonyId' is defined but never used.","line":37,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":37,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  AlertTriangle,\n  Battery,\n  Beaker,\n  CheckCircle,\n  Cpu,\n  Leaf,\n  Package,\n  TrendingDown,\n  TrendingUp,\n  Users,\n} from 'lucide-react';\nimport { ResourceType } from './../../../types/resources/ResourceTypes';\n\ninterface ResourceData {\n  type:\n    | ResourceType.ENERGY\n    | 'materials'\n    | ResourceType.FOOD\n    | ResourceType.RESEARCH\n    | 'technology'\n    | ResourceType.POPULATION;\n  name: string;\n  production: number;\n  consumption: number;\n  storage: number;\n  capacity: number;\n}\n\ninterface ResourceDashboardProps {\n  colonyId: string;\n  resources: ResourceData[];\n  onResourceClick?: (resourceType: ResourceData['type']) => void;\n}\n\nexport function ResourceDashboard({\n  colonyId: _colonyId,\n  resources,\n  onResourceClick,\n}: ResourceDashboardProps) {\n  // Get resource icon\n  const getResourceIcon = (type: ResourceData['type']) => {\n    switch (type) {\n      case ResourceType.ENERGY:\n        return <Battery className=\"h-5 w-5 text-yellow-400\" />;\n      case 'materials':\n        return <Package className=\"h-5 w-5 text-amber-400\" />;\n      case ResourceType.FOOD:\n        return <Leaf className=\"h-5 w-5 text-green-400\" />;\n      case ResourceType.RESEARCH:\n        return <Beaker className=\"h-5 w-5 text-blue-400\" />;\n      case 'technology':\n        return <Cpu className=\"h-5 w-5 text-purple-400\" />;\n      case ResourceType.POPULATION:\n        return <Users className=\"h-5 w-5 text-indigo-400\" />;\n      default:\n        return <Package className=\"h-5 w-5 text-gray-400\" />;\n    }\n  };\n\n  // Calculate net change\n  const getNetChange = (resource: ResourceData) => {\n    return resource.production - resource.consumption;\n  };\n\n  // Get status indicator\n  const getStatusIndicator = (resource: ResourceData) => {\n    const netChange = getNetChange(resource);\n    const storagePercentage = (resource.storage / resource.capacity) * 100;\n\n    if (netChange < 0 && resource.storage < Math.abs(netChange) * 10) {\n      // Critical: Negative change and less than 10 cycles of resources left\n      return (\n        <div className=\"flex items-center space-x-1 text-red-400\">\n          <AlertTriangle className=\"h-4 w-4\" />\n          <span className=\"text-xs\">Critical</span>\n        </div>\n      );\n    } else if (netChange < 0) {\n      // Warning: Negative change\n      return (\n        <div className=\"flex items-center space-x-1 text-amber-400\">\n          <TrendingDown className=\"h-4 w-4\" />\n          <span className=\"text-xs\">Depleting</span>\n        </div>\n      );\n    } else if (storagePercentage > 90) {\n      // Warning: Almost full\n      return (\n        <div className=\"flex items-center space-x-1 text-amber-400\">\n          <AlertTriangle className=\"h-4 w-4\" />\n          <span className=\"text-xs\">Storage Full</span>\n        </div>\n      );\n    } else if (netChange > 0) {\n      // Good: Positive change\n      return (\n        <div className=\"flex items-center space-x-1 text-green-400\">\n          <TrendingUp className=\"h-4 w-4\" />\n          <span className=\"text-xs\">Growing</span>\n        </div>\n      );\n    } else {\n      // Neutral: No change\n      return (\n        <div className=\"flex items-center space-x-1 text-gray-400\">\n          <CheckCircle className=\"h-4 w-4\" />\n          <span className=\"text-xs\">Stable</span>\n        </div>\n      );\n    }\n  };\n\n  return (\n    <div className=\"rounded-lg border border-gray-700 bg-gray-800 p-4\">\n      <h3 className=\"mb-4 text-lg font-medium text-white\">Resource Dashboard</h3>\n\n      <div className=\"space-y-4\">\n        {resources.map(resource => (\n          <div\n            key={resource.type}\n            className=\"rounded-md border border-gray-700 bg-gray-900 p-3 transition-colors hover:bg-gray-800\"\n            onClick={() => onResourceClick?.(resource.type)}\n          >\n            <div className=\"flex items-center justify-between\">\n              <div className=\"flex items-center space-x-2\">\n                {getResourceIcon(resource.type)}\n                <span className=\"text-sm font-medium text-white\">{resource.name}</span>\n              </div>\n              {getStatusIndicator(resource)}\n            </div>\n\n            <div className=\"mt-2 grid grid-cols-3 gap-2\">\n              <div>\n                <div className=\"text-xs text-gray-400\">Storage</div>\n                <div className=\"text-sm font-medium text-white\">\n                  {resource.storage.toLocaleString()} / {resource.capacity.toLocaleString()}\n                </div>\n              </div>\n\n              <div>\n                <div className=\"text-xs text-gray-400\">Production</div>\n                <div className=\"text-sm font-medium text-green-400\">\n                  +{resource.production.toLocaleString()}/cycle\n                </div>\n              </div>\n\n              <div>\n                <div className=\"text-xs text-gray-400\">Consumption</div>\n                <div className=\"text-sm font-medium text-red-400\">\n                  -{resource.consumption.toLocaleString()}/cycle\n                </div>\n              </div>\n            </div>\n\n            {/* Storage Bar */}\n            <div className=\"mt-2\">\n              <div className=\"h-2 w-full overflow-hidden rounded-full bg-gray-800\">\n                <div\n                  className={`h-full ${\n                    resource.storage / resource.capacity > 0.9\n                      ? 'bg-amber-500'\n                      : resource.storage / resource.capacity > 0.5\n                        ? 'bg-green-500'\n                        : resource.storage / resource.capacity < 0.2\n                          ? 'bg-red-500'\n                          : 'bg-blue-500'\n                  }`}\n                  style={{ width: `${(resource.storage / resource.capacity) * 100}%` }}\n                ></div>\n              </div>\n            </div>\n\n            {/* Net Change */}\n            <div className=\"mt-2 flex items-center justify-end\">\n              <div className=\"flex items-center space-x-1\">\n                <span className=\"text-xs text-gray-400\">Net:</span>\n                <span\n                  className={`text-xs font-medium ${\n                    getNetChange(resource) > 0\n                      ? 'text-green-400'\n                      : getNetChange(resource) < 0\n                        ? 'text-red-400'\n                        : 'text-gray-400'\n                  }`}\n                >\n                  {getNetChange(resource) > 0 ? '+' : ''}\n                  {getNetChange(resource).toLocaleString()}/cycle\n                </span>\n              </div>\n            </div>\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/colony/ResourceTransferAnimation.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/colony/SatisfactionMeter.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_colonyId' is defined but never used.","line":30,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":30,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { motion } from 'framer-motion';\nimport {\n  Frown,\n  Heart,\n  Home,\n  Meh,\n  Shield,\n  Smile,\n  ThumbsDown,\n  ThumbsUp,\n  Utensils,\n  Zap,\n} from 'lucide-react';\nimport { ResourceType } from './../../../types/resources/ResourceTypes';\n\ninterface SatisfactionFactor {\n  type: 'housing' | ResourceType.FOOD | 'healthcare' | ResourceType.ENERGY | 'security';\n  name: string;\n  value: number; // 0-100\n  weight: number; // 0-1, sum of all weights should be 1\n}\n\ninterface SatisfactionMeterProps {\n  colonyId: string;\n  factors: SatisfactionFactor[];\n  onFactorClick?: (factorType: SatisfactionFactor['type']) => void;\n}\n\nexport function SatisfactionMeter({\n  colonyId: _colonyId,\n  factors,\n  onFactorClick,\n}: SatisfactionMeterProps) {\n  // Calculate overall satisfaction\n  const overallSatisfaction = factors.reduce(\n    (sum, factor) => sum + factor.value * factor.weight,\n    0\n  );\n\n  // Get satisfaction icon\n  const getSatisfactionIcon = (value: number) => {\n    if (value >= 80) {\n      return <Smile className=\"h-6 w-6 text-green-400\" />;\n    } else if (value >= 50) {\n      return <Meh className=\"h-6 w-6 text-amber-400\" />;\n    } else {\n      return <Frown className=\"h-6 w-6 text-red-400\" />;\n    }\n  };\n\n  // Get satisfaction color\n  const getSatisfactionColor = (value: number) => {\n    if (value >= 80) {\n      return 'text-green-400';\n    } else if (value >= 50) {\n      return 'text-amber-400';\n    } else {\n      return 'text-red-400';\n    }\n  };\n\n  // Get factor icon\n  const getFactorIcon = (type: SatisfactionFactor['type']) => {\n    switch (type) {\n      case 'housing':\n        return <Home className=\"h-4 w-4 text-blue-400\" />;\n      case ResourceType.FOOD:\n        return <Utensils className=\"h-4 w-4 text-green-400\" />;\n      case 'healthcare':\n        return <Heart className=\"h-4 w-4 text-red-400\" />;\n      case ResourceType.ENERGY:\n        return <Zap className=\"h-4 w-4 text-yellow-400\" />;\n      case 'security':\n        return <Shield className=\"h-4 w-4 text-purple-400\" />;\n      default:\n        return <ThumbsUp className=\"h-4 w-4 text-gray-400\" />;\n    }\n  };\n\n  return (\n    <div className=\"rounded-lg border border-gray-700 bg-gray-800 p-4\">\n      <h3 className=\"mb-4 text-lg font-medium text-white\">Colony Satisfaction</h3>\n\n      {/* Overall Satisfaction */}\n      <div className=\"mb-4 flex items-center justify-between rounded-md border border-gray-700 bg-gray-900 p-3\">\n        <div className=\"flex items-center space-x-3\">\n          {getSatisfactionIcon(overallSatisfaction)}\n          <div>\n            <div className=\"text-sm font-medium text-white\">Overall Satisfaction</div>\n            <div className={`text-xs ${getSatisfactionColor(overallSatisfaction)}`}>\n              {overallSatisfaction >= 80\n                ? 'Excellent'\n                : overallSatisfaction >= 60\n                  ? 'Good'\n                  : overallSatisfaction >= 40\n                    ? 'Average'\n                    : overallSatisfaction >= 20\n                      ? 'Poor'\n                      : 'Critical'}\n            </div>\n          </div>\n        </div>\n\n        <div className={`text-xl font-bold ${getSatisfactionColor(overallSatisfaction)}`}>\n          {Math.round(overallSatisfaction)}%\n        </div>\n      </div>\n\n      {/* Satisfaction Meter */}\n      <div className=\"mb-4\">\n        <div className=\"h-4 w-full overflow-hidden rounded-full bg-gray-900\">\n          <motion.div\n            className=\"h-full bg-gradient-to-r from-red-500 via-amber-500 to-green-500\"\n            style={{ width: `${overallSatisfaction}%` }}\n            initial={{ width: 0 }}\n            animate={{ width: `${overallSatisfaction}%` }}\n            transition={{ duration: 1, ease: 'easeOut' }}\n          />\n        </div>\n\n        <div className=\"mt-1 flex justify-between text-xs text-gray-500\">\n          <span>0%</span>\n          <span>25%</span>\n          <span>50%</span>\n          <span>75%</span>\n          <span>100%</span>\n        </div>\n      </div>\n\n      {/* Individual Factors */}\n      <div className=\"space-y-3\">\n        {factors.map(factor => (\n          <div\n            key={factor.type}\n            className=\"rounded-md border border-gray-700 bg-gray-900 p-2 transition-colors hover:bg-gray-800\"\n            onClick={() => onFactorClick?.(factor.type)}\n          >\n            <div className=\"flex items-center justify-between\">\n              <div className=\"flex items-center space-x-2\">\n                {getFactorIcon(factor.type)}\n                <span className=\"text-sm text-white\">{factor.name}</span>\n              </div>\n              <div className={`text-sm font-medium ${getSatisfactionColor(factor.value)}`}>\n                {Math.round(factor.value)}%\n              </div>\n            </div>\n\n            <div className=\"mt-2 h-2 w-full overflow-hidden rounded-full bg-gray-800\">\n              <div\n                className={`h-full ${\n                  factor.value >= 80\n                    ? 'bg-green-500'\n                    : factor.value >= 50\n                      ? 'bg-amber-500'\n                      : 'bg-red-500'\n                }`}\n                style={{ width: `${factor.value}%` }}\n              />\n            </div>\n\n            <div className=\"mt-1 flex justify-between text-xs text-gray-500\">\n              <span>Impact: {Math.round(factor.weight * 100)}%</span>\n              <span className=\"flex items-center space-x-1\">\n                {factor.value >= 60 ? (\n                  <>\n                    <ThumbsUp className=\"h-3 w-3 text-green-400\" />\n                    <span className=\"text-green-400\">Good</span>\n                  </>\n                ) : factor.value >= 40 ? (\n                  <>\n                    <Meh className=\"h-3 w-3 text-amber-400\" />\n                    <span className=\"text-amber-400\">Average</span>\n                  </>\n                ) : (\n                  <>\n                    <ThumbsDown className=\"h-3 w-3 text-red-400\" />\n                    <span className=\"text-red-400\">Poor</span>\n                  </>\n                )}\n              </span>\n            </div>\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/colony/TradeRouteVisualization.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_colonyId' is defined but never used.","line":47,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":47,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { motion } from 'framer-motion';\nimport { Package, TrendingDown, TrendingUp, Truck } from 'lucide-react';\nimport * as React from 'react';\nimport { useEffect, useRef, useState } from 'react';\n\ninterface TradePartner {\n  id: string;\n  name: string;\n  distance: number; // Distance in light years or other unit\n  position: { x: number; y: number }; // Relative position for visualization\n}\n\ninterface TradeResource {\n  id: string;\n  name: string;\n  type: 'import' | 'export';\n  amount: number;\n  value: number;\n}\n\ninterface TradeRoute {\n  id: string;\n  partnerId: string;\n  status: 'active' | 'pending' | 'disrupted';\n  resources: TradeResource[];\n  efficiency: number; // 0-1 efficiency factor\n  lastTradeTime: number; // Timestamp of last trade\n}\n\ninterface TradeRouteVisualizationProps {\n  colonyId: string;\n  colonyName: string;\n  tradePartners: TradePartner[];\n  tradeRoutes: TradeRoute[];\n  quality: 'low' | 'medium' | 'high';\n  onRouteClick?: (routeId: string) => void;\n  onPartnerClick?: (partnerId: string) => void;\n}\n\n/**\n * TradeRouteVisualization component\n *\n * Visualizes trade routes between the colony and its trade partners.\n * Shows resource flows, trade efficiency, and allows interaction with routes.\n */\nexport function TradeRouteVisualization({\n  colonyId: _colonyId,\n  colonyName,\n  tradePartners,\n  tradeRoutes,\n  quality,\n  onRouteClick,\n  onPartnerClick,\n}: TradeRouteVisualizationProps) {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const [hoveredRoute, setHoveredRoute] = useState<string | null>(null);\n  const [hoveredPartner, setHoveredPartner] = useState<string | null>(null);\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });\n\n  // Set up canvas dimensions\n  useEffect(() => {\n    if (containerRef.current) {\n      const { width, height } = containerRef.current.getBoundingClientRect();\n      setDimensions({ width, height });\n    }\n\n    const handleResize = () => {\n      if (containerRef.current) {\n        const { width, height } = containerRef.current.getBoundingClientRect();\n        setDimensions({ width, height });\n      }\n    };\n\n    window.addEventListener('resize', handleResize);\n    return () => window.removeEventListener('resize', handleResize);\n  }, []);\n\n  // Calculate trade metrics\n  const totalImports = tradeRoutes.reduce(\n    (sum, route) =>\n      sum +\n      route.resources.filter(r => r.type === 'import').reduce((total, r) => total + r.value, 0),\n    0\n  );\n\n  const totalExports = tradeRoutes.reduce(\n    (sum, route) =>\n      sum +\n      route.resources.filter(r => r.type === 'export').reduce((total, r) => total + r.value, 0),\n    0\n  );\n\n  const tradeBalance = totalExports - totalImports;\n\n  // Determine particle count based on quality\n  const getParticleCount = (routeId: string) => {\n    const route = tradeRoutes.find(r => r.id === routeId);\n    if (!route) {\n      return 0;\n    }\n\n    const baseCount = quality === 'high' ? 8 : quality === 'medium' ? 5 : 3;\n    return Math.max(1, Math.round(baseCount * route.efficiency));\n  };\n\n  // Get route color based on status\n  const getRouteColor = (status: TradeRoute['status']) => {\n    switch (status) {\n      case 'active':\n        return 'rgba(52, 211, 153, 0.7)'; // Green\n      case 'pending':\n        return 'rgba(251, 191, 36, 0.7)'; // Yellow\n      case 'disrupted':\n        return 'rgba(239, 68, 68, 0.7)'; // Red\n      default:\n        return 'rgba(156, 163, 175, 0.7)'; // Gray\n    }\n  };\n\n  // Get resource icon\n  const getResourceIcon = (type: TradeResource['type']) => {\n    return type === 'import' ? (\n      <TrendingDown className=\"h-3 w-3 text-blue-400\" />\n    ) : (\n      <TrendingUp className=\"h-3 w-3 text-green-400\" />\n    );\n  };\n\n  // Format value with + or - sign\n  const formatValue = (value: number, type: TradeResource['type']) => {\n    return type === 'import' ? `-${value}` : `+${value}`;\n  };\n\n  return (\n    <div className=\"rounded-lg border border-gray-700 bg-gray-800 p-4\">\n      <div className=\"mb-4 flex items-center justify-between\">\n        <h3 className=\"text-lg font-medium text-white\">Trade Routes</h3>\n        <div className=\"flex items-center space-x-4\">\n          <div className=\"flex items-center space-x-1\">\n            <TrendingDown className=\"h-4 w-4 text-blue-400\" />\n            <span className=\"text-sm text-blue-400\">{totalImports}</span>\n          </div>\n          <div className=\"flex items-center space-x-1\">\n            <TrendingUp className=\"h-4 w-4 text-green-400\" />\n            <span className=\"text-sm text-green-400\">{totalExports}</span>\n          </div>\n          <div className=\"flex items-center space-x-1\">\n            <span className=\"text-sm font-medium text-gray-300\">Balance:</span>\n            <span\n              className={`text-sm font-medium ${\n                tradeBalance > 0\n                  ? 'text-green-400'\n                  : tradeBalance < 0\n                    ? 'text-red-400'\n                    : 'text-gray-400'\n              }`}\n            >\n              {tradeBalance > 0 ? '+' : ''}\n              {tradeBalance}\n            </span>\n          </div>\n        </div>\n      </div>\n\n      {/* Trade Route Map */}\n      <div\n        ref={containerRef}\n        className=\"relative mb-4 h-64 rounded-lg border border-gray-700 bg-gray-900\"\n      >\n        {/* Colony (Center) */}\n        <div className=\"absolute left-1/2 top-1/2 flex h-12 w-12 -translate-x-1/2 -translate-y-1/2 transform items-center justify-center rounded-full bg-indigo-900 shadow-lg\">\n          <div className=\"text-center\">\n            <div className=\"text-xs font-medium text-white\">{colonyName}</div>\n            <div className=\"text-[10px] text-indigo-300\">{tradeRoutes.length} Routes</div>\n          </div>\n        </div>\n\n        {/* Trade Partners and Routes */}\n        {tradePartners.map(partner => {\n          const route = tradeRoutes.find(r => r.partnerId === partner.id);\n          const isHovered = hoveredPartner === partner.id || (route && hoveredRoute === route.id);\n\n          // Calculate position within container\n          const centerX = dimensions.width / 2;\n          const centerY = dimensions.height / 2;\n          const x = centerX + partner.position.x * (dimensions.width / 3);\n          const y = centerY + partner.position.y * (dimensions.height / 3);\n\n          return (\n            <React.Fragment key={partner.id}>\n              {/* Trade Route Line */}\n              {route && (\n                <div\n                  className=\"absolute left-1/2 top-1/2 h-0.5 origin-left transform\"\n                  style={{\n                    width: Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2)),\n                    transform: `rotate(${Math.atan2(y - centerY, x - centerX)}rad) translateX(6px)`,\n                    backgroundColor: getRouteColor(route.status),\n                    opacity: isHovered ? 1 : 0.6,\n                    zIndex: isHovered ? 10 : 1,\n                  }}\n                  onMouseEnter={() => route && setHoveredRoute(route.id)}\n                  onMouseLeave={() => setHoveredRoute(null)}\n                  onClick={() => route && onRouteClick?.(route.id)}\n                >\n                  {/* Resource Flow Particles */}\n                  {route.status === 'active' &&\n                    Array.from({ length: getParticleCount(route.id) }).map((_, i) => {\n                      const isImport = i % 2 === 0;\n                      return (\n                        <motion.div\n                          key={`particle-${route.id}-${i}`}\n                          className={`absolute h-2 w-2 rounded-full ${\n                            isImport ? 'bg-blue-500' : 'bg-green-500'\n                          }`}\n                          animate={{\n                            left: isImport ? ['0%', '100%'] : ['100%', '0%'],\n                          }}\n                          transition={{\n                            duration: 2 + (i % 3),\n                            repeat: Infinity,\n                            ease: 'linear',\n                            delay: i * 0.5,\n                          }}\n                          style={{\n                            top: '-3px',\n                          }}\n                        />\n                      );\n                    })}\n                </div>\n              )}\n\n              {/* Trade Partner Node */}\n              <div\n                className={`absolute flex h-10 w-10 cursor-pointer items-center justify-center rounded-full transition-all ${\n                  isHovered ? 'scale-110' : 'scale-100'\n                } ${\n                  route\n                    ? route.status === 'active'\n                      ? 'bg-green-800'\n                      : route.status === 'pending'\n                        ? 'bg-yellow-800'\n                        : 'bg-red-800'\n                    : 'bg-gray-700'\n                }`}\n                style={{\n                  left: x,\n                  top: y,\n                  transform: 'translate(-50%, -50%)',\n                  zIndex: isHovered ? 20 : 2,\n                }}\n                onMouseEnter={() => setHoveredPartner(partner.id)}\n                onMouseLeave={() => setHoveredPartner(null)}\n                onClick={() => onPartnerClick?.(partner.id)}\n              >\n                <Truck className=\"h-5 w-5 text-white\" />\n              </div>\n\n              {/* Partner Label */}\n              <div\n                className={`absolute whitespace-nowrap text-center text-xs transition-opacity ${\n                  isHovered ? 'opacity-100' : 'opacity-70'\n                }`}\n                style={{\n                  left: x,\n                  top: y + 20,\n                  transform: 'translate(-50%, 0)',\n                  zIndex: isHovered ? 20 : 2,\n                }}\n              >\n                <div className=\"font-medium text-white\">{partner.name}</div>\n                <div className=\"text-[10px] text-gray-400\">{partner.distance} LY</div>\n              </div>\n\n              {/* Route Details Tooltip */}\n              {route && hoveredRoute === route.id && (\n                <div\n                  className=\"absolute z-30 w-48 rounded-md border border-gray-700 bg-gray-800 p-2 shadow-lg\"\n                  style={{\n                    left: (x + centerX) / 2,\n                    top: (y + centerY) / 2,\n                    transform: 'translate(-50%, -50%)',\n                  }}\n                >\n                  <div className=\"mb-1 text-center text-sm font-medium text-white\">\n                    {colonyName} â†” {partner.name}\n                  </div>\n                  <div className=\"mb-2 flex justify-between text-xs\">\n                    <span className=\"text-gray-400\">Status:</span>\n                    <span\n                      className={\n                        route.status === 'active'\n                          ? 'text-green-400'\n                          : route.status === 'pending'\n                            ? 'text-yellow-400'\n                            : 'text-red-400'\n                      }\n                    >\n                      {route.status.charAt(0).toUpperCase() + route.status.slice(1)}\n                    </span>\n                  </div>\n                  <div className=\"mb-1 text-xs text-gray-400\">Resources:</div>\n                  <div className=\"max-h-20 overflow-y-auto\">\n                    {route.resources.map(resource => (\n                      <div\n                        key={resource.id}\n                        className=\"flex items-center justify-between border-t border-gray-700 py-1 text-xs\"\n                      >\n                        <div className=\"flex items-center space-x-1\">\n                          {getResourceIcon(resource.type)}\n                          <span className=\"text-gray-300\">{resource.name}</span>\n                        </div>\n                        <div\n                          className={\n                            resource.type === 'import' ? 'text-blue-400' : 'text-green-400'\n                          }\n                        >\n                          {formatValue(resource.value, resource.type)}\n                        </div>\n                      </div>\n                    ))}\n                  </div>\n                  <div className=\"mt-2 flex justify-between border-t border-gray-700 pt-1 text-xs\">\n                    <span className=\"text-gray-400\">Efficiency:</span>\n                    <span className=\"text-gray-300\">{Math.round(route.efficiency * 100)}%</span>\n                  </div>\n                </div>\n              )}\n            </React.Fragment>\n          );\n        })}\n      </div>\n\n      {/* Trade Routes List */}\n      <div className=\"max-h-48 overflow-y-auto rounded-lg border border-gray-700\">\n        {tradeRoutes.length === 0 ? (\n          <div className=\"flex h-16 items-center justify-center text-sm text-gray-500\">\n            No active trade routes\n          </div>\n        ) : (\n          <table className=\"w-full\">\n            <thead className=\"bg-gray-900\">\n              <tr>\n                <th className=\"px-3 py-2 text-left text-xs font-medium text-gray-400\">Partner</th>\n                <th className=\"px-3 py-2 text-left text-xs font-medium text-gray-400\">Status</th>\n                <th className=\"px-3 py-2 text-left text-xs font-medium text-gray-400\">Resources</th>\n                <th className=\"px-3 py-2 text-right text-xs font-medium text-gray-400\">Balance</th>\n              </tr>\n            </thead>\n            <tbody>\n              {tradeRoutes.map(route => {\n                const partner = tradePartners.find(p => p.id === route.partnerId);\n                if (!partner) return null;\n\n                const imports = route.resources\n                  .filter(r => r.type === 'import')\n                  .reduce((sum, r) => sum + r.value, 0);\n\n                const exports = route.resources\n                  .filter(r => r.type === 'export')\n                  .reduce((sum, r) => sum + r.value, 0);\n\n                const balance = exports - imports;\n\n                return (\n                  <tr\n                    key={route.id}\n                    className={`border-t border-gray-700 transition-colors ${\n                      hoveredRoute === route.id ? 'bg-gray-700' : 'hover:bg-gray-700/50'\n                    }`}\n                    onMouseEnter={() => setHoveredRoute(route.id)}\n                    onMouseLeave={() => setHoveredRoute(null)}\n                    onClick={() => onRouteClick?.(route.id)}\n                  >\n                    <td className=\"px-3 py-2 text-sm text-white\">{partner.name}</td>\n                    <td className=\"px-3 py-2\">\n                      <span\n                        className={`inline-flex items-center rounded-full px-2 py-0.5 text-xs ${\n                          route.status === 'active'\n                            ? 'bg-green-900/30 text-green-400'\n                            : route.status === 'pending'\n                              ? 'bg-yellow-900/30 text-yellow-400'\n                              : 'bg-red-900/30 text-red-400'\n                        }`}\n                      >\n                        {route.status}\n                      </span>\n                    </td>\n                    <td className=\"px-3 py-2\">\n                      <div className=\"flex items-center space-x-1\">\n                        <Package className=\"h-3 w-3 text-gray-400\" />\n                        <span className=\"text-xs text-gray-300\">\n                          {route.resources.length} types\n                        </span>\n                      </div>\n                    </td>\n                    <td className=\"px-3 py-2 text-right\">\n                      <span\n                        className={`text-sm font-medium ${\n                          balance > 0\n                            ? 'text-green-400'\n                            : balance < 0\n                              ? 'text-red-400'\n                              : 'text-gray-400'\n                        }`}\n                      >\n                        {balance > 0 ? '+' : ''}\n                        {balance}\n                      </span>\n                    </td>\n                  </tr>\n                );\n              })}\n            </tbody>\n          </table>\n        )}\n      </div>\n    </div>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/ExplorationHub/ExplorationControls.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/ExplorationHub/ExplorationHub.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_ReconShipStatusProps' is defined but never used. Allowed unused vars must match /^ignored|^temp/u.","line":76,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":76,"endColumn":32}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  AlertTriangle,\n  Filter,\n  Flag,\n  History,\n  Map,\n  Radar,\n  Rocket,\n  Search,\n  Target,\n  ZoomIn,\n  ZoomOut,\n} from 'lucide-react';\nimport * as React from 'react';\nimport { memo, useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { ContextMenuItem, useContextMenu } from '../../../../components/ui/ContextMenu';\nimport { Draggable, DragItem, DropTarget } from '../../../../components/ui/DragAndDrop';\nimport { useTooltipContext } from '../../../../components/ui/tooltip-context';\nimport { explorationRules } from '../../../../config/automation/explorationRules';\nimport { StarSystem } from '../../../../managers/exploration/ExplorationManagerImpl';\nimport {\n  ReconShipManagerImpl,\n  Ship as ReconShipType,\n  ShipEvent,\n} from '../../../../managers/exploration/ReconShipManagerImpl';\nimport { automationManager } from '../../../../managers/game/AutomationManager';\nimport { BaseEvent, EventType } from '../../../../types/events/EventTypes';\nimport { SectorType } from '../../../../types/exploration/ExplorationTypes';\nimport { ResourceType } from '../../../../types/resources/ResourceTypes';\nimport { ResourceTransfer } from '../MiningHub/ResourceTransfer';\nimport { ExplorationControls } from './ExplorationControls';\nimport { ExplorationTutorial } from './ExplorationTutorial';\nimport { MissionLog } from './MissionLog';\nimport { ReconShipStatus } from './ReconShipStatus';\n\ninterface Anomaly {\n  id: string;\n  type: 'artifact' | 'signal' | 'phenomenon';\n  severity: 'low' | 'medium' | 'high';\n  description: string;\n  investigated: boolean;\n}\n\n// Update sector status type\ntype SectorStatus = 'unmapped' | 'mapped' | 'scanning';\n\n// Update ship status type\ntype ShipStatus = 'idle' | 'scanning' | 'returning' | 'assigned';\n\ninterface Sector extends Omit<StarSystem, 'status'> {\n  resourcePotential: number;\n  habitabilityScore: number;\n  anomalies: Anomaly[];\n  position: { x: number; y: number };\n  coordinates: { x: number; y: number };\n  assignedShips: string[];\n  status: SectorStatus;\n}\n\n// Update ship status type to match ReconShipStatus component\ntype ReconShipStatusType = 'idle' | 'scanning' | 'returning' | 'investigating';\n\ninterface ReconShip extends Omit<ReconShipType, 'status'> {\n  id: string;\n  name: string;\n  type: 'recon';\n  experience: number;\n  specialization: 'mapping' | 'anomaly' | 'resource';\n  efficiency: number;\n  lastUpdate?: number;\n  status: ShipStatus;\n  targetSector?: string;\n}\n\n// Interface for ReconShipStatus component - prefix with underscore since it's used for type documentation\ninterface _ReconShipStatusProps {\n  id: string;\n  name: string;\n  status: ReconShipStatusType;\n  targetSector?: string;\n  experience: number;\n  specialization: 'mapping' | 'anomaly' | 'resource';\n  efficiency: number;\n}\n\ninterface MapOffset {\n  x: number;\n  y: number;\n}\n\ninterface AdvancedFilters {\n  minResourcePotential: number;\n  minHabitabilityScore: number;\n  hasAnomalies: boolean;\n  anomalySeverity: 'any' | 'low' | 'medium' | 'high';\n  lastScannedWithin: number; // hours\n  resourceTypes: string[];\n}\n\n// Add type for context menu items\ninterface ShipMenuItem extends ContextMenuItem {\n  id: string;\n  label: string;\n  icon: React.ReactNode;\n  action: () => void;\n}\n\n// Mock data for demonstration\nconst mockSectors: Sector[] = [\n  {\n    id: 'alpha-sector',\n    name: 'Alpha Sector',\n    type: SectorType.PLANETARY_SYSTEM,\n    status: 'mapped',\n    position: { x: 0, y: 0 },\n    coordinates: { x: 0, y: 0 },\n    resourcePotential: 0.8,\n    habitabilityScore: 0.6,\n    anomalies: [\n      {\n        id: 'ancient-ruins',\n        type: 'artifact',\n        severity: 'high',\n        description: 'Ancient ruins of unknown origin',\n        investigated: false,\n      },\n    ],\n    lastScanned: Date.now() - 3600000,\n    assignedShips: [],\n  },\n  {\n    id: 'beta-sector',\n    name: 'Beta Sector',\n    type: SectorType.ASTEROID_FIELD,\n    status: 'scanning',\n    position: { x: 200, y: -150 },\n    coordinates: { x: 200, y: -150 },\n    resourcePotential: 0.5,\n    habitabilityScore: 0.3,\n    anomalies: [],\n    lastScanned: Date.now(),\n    assignedShips: [],\n  },\n  {\n    id: 'gamma-sector',\n    name: 'Gamma Sector',\n    type: SectorType.DEEP_SPACE,\n    status: 'unmapped',\n    position: { x: -180, y: 120 },\n    coordinates: { x: -180, y: 120 },\n    resourcePotential: 0.4,\n    habitabilityScore: 0.7,\n    anomalies: [],\n    assignedShips: [],\n  },\n];\n\n// Update mock ships to use correct status values\nconst mockShips: ReconShip[] = [\n  {\n    id: 'recon-1',\n    name: 'Pathfinder Alpha',\n    type: 'recon',\n    status: 'scanning' as ShipStatus,\n    assignedSectorId: 'beta-sector',\n    experience: 1250,\n    specialization: 'mapping',\n    efficiency: 0.9,\n    sensorRange: 100,\n    speed: 1.0,\n    capabilities: {\n      canScan: true,\n      canSalvage: false,\n      canMine: false,\n      canJump: true,\n    },\n  },\n  {\n    id: 'recon-2',\n    name: 'Signal Hunter Beta',\n    type: 'recon',\n    status: 'assigned' as ShipStatus,\n    assignedSectorId: 'alpha-sector',\n    experience: 800,\n    specialization: 'anomaly',\n    efficiency: 0.85,\n    sensorRange: 120,\n    speed: 0.8,\n    capabilities: {\n      canScan: true,\n      canSalvage: true,\n      canMine: false,\n      canJump: false,\n    },\n  },\n];\n\n// Mock transfer data for exploration discoveries\nconst mockExplorationTransfers = [\n  {\n    id: 'discovery-1',\n    sourceId: 'alpha-sector',\n    targetId: 'storage',\n    resourceType: ResourceType.DARK_MATTER,\n    amount: 100,\n    progress: 0.5,\n  },\n];\n\ntype FilterType = 'all' | 'unmapped' | 'anomalies';\n\n// Memoized Sector Component\nconst SectorComponent = memo(\n  ({\n    sector,\n    isSelected,\n    showHeatMap,\n    onSelect,\n    onHover,\n    getSectorHeat,\n    ships,\n    onShipAssign,\n  }: {\n    sector: Sector;\n    isSelected: boolean;\n    showHeatMap: boolean;\n    onSelect: (sector: Sector) => void;\n    onHover: (show: boolean, sector: Sector) => void;\n    getSectorHeat: (sector: Sector) => number;\n    ships: ReconShip[];\n    onShipAssign: (shipId: string, sectorId: string) => void;\n  }) => {\n    const scanningShip = ships.find(ship => ship.targetSector === sector.id);\n    const heatValue = getSectorHeat(sector);\n\n    // Update getSectorMenuItems to use proper types\n    const getSectorMenuItems = (): ShipMenuItem[] => {\n      const assignedShip = ships.find(ship => ship.targetSector === sector.id);\n      return [\n        {\n          id: 'info',\n          label: 'View Details',\n          icon: <Map className=\"h-4 w-4\" />,\n          action: () => onSelect(sector),\n        },\n        {\n          id: 'assign-ship',\n          label: assignedShip ? 'Reassign Ship' : 'Assign Ship',\n          icon: <Rocket className=\"h-4 w-4\" />,\n          action: () => {}, // No-op action for parent menu\n          children: ships\n            .filter(ship => ship.status === 'idle' || ship.targetSector === sector.id)\n            .map(ship => ({\n              id: ship.id,\n              label: ship.name,\n              icon: <Target className=\"h-4 w-4\" />,\n              action: () => onShipAssign(ship.id, sector.id),\n            })),\n        },\n        {\n          id: 'mark-priority',\n          label: 'Mark as Priority',\n          icon: <Flag className=\"h-4 w-4\" />,\n          action: () => {\n            // Handle priority marking\n            console.warn(`Marking ${sector.name} as priority`);\n          },\n        },\n      ];\n    };\n\n    const { handleContextMenu, ContextMenuComponent } = useContextMenu({\n      items: getSectorMenuItems(),\n    });\n\n    return (\n      <div\n        className=\"absolute\"\n        style={{\n          left: `calc(50% + ${sector.position.x}px)`,\n          top: `calc(50% + ${sector.position.y}px)`,\n          transform: 'translate(-50%, -50%)',\n        }}\n      >\n        <DropTarget\n          accept={['ship']}\n          onDrop={(item: DragItem) => {\n            if (item?.type === 'ship' && typeof item?.data?.id === 'string') {\n              const shipId = item?.data?.id;\n              onShipAssign(shipId, sector.id);\n            }\n          }}\n          className=\"group relative\"\n        >\n          <div\n            onContextMenu={handleContextMenu}\n            onClick={() => onSelect(sector)}\n            onMouseEnter={() => onHover(true, sector)}\n            onMouseLeave={() => onHover(false, sector)}\n          >\n            {/* Sector Visualization */}\n            <div\n              className={`h-24 w-24 rounded-lg transition-all duration-300 ${\n                sector.status === 'unmapped'\n                  ? 'bg-gray-800/50'\n                  : sector.status === 'scanning'\n                    ? 'animate-pulse bg-teal-900/50'\n                    : 'bg-teal-800/30'\n              } relative ${\n                isSelected ? 'ring-2 ring-teal-400 ring-offset-2 ring-offset-gray-900' : ''\n              }`}\n            >\n              {/* Heat Map Overlay */}\n              {showHeatMap && sector.status !== 'unmapped' && (\n                <div\n                  className=\"absolute inset-0 rounded-lg mix-blend-overlay\"\n                  style={{\n                    background: `rgba(${Math.round(heatValue * 255)}, ${Math.round(heatValue * 100)}, 0, ${heatValue * 0.8})`,\n                  }}\n                />\n              )}\n\n              {/* Resource Potential Indicator */}\n              {sector.status !== 'unmapped' && (\n                <div\n                  className=\"absolute inset-2 rounded border-2 border-teal-500/30 transition-all\"\n                  style={{\n                    clipPath: `polygon(0 ${100 - sector.resourcePotential * 100}%, 100% ${100 - sector.resourcePotential * 100}%, 0%, 0 100%)`,\n                  }}\n                />\n              )}\n\n              {/* Habitability Score Ring */}\n              {sector.status !== 'unmapped' && (\n                <div\n                  className=\"absolute inset-0 rounded-lg border-4 border-teal-400/20 transition-all\"\n                  style={{\n                    clipPath: `polygon(0 0, ${sector.habitabilityScore * 100}% 0, ${sector.habitabilityScore * 100}% 100%, 0 100%)`,\n                  }}\n                />\n              )}\n\n              {/* Anomaly Indicators */}\n              {sector.anomalies?.length > 0 && (\n                <div className=\"mb-3\">\n                  <div className=\"mb-2 text-xs font-medium text-gray-300\">Detected Anomalies</div>\n                  <div className=\"space-y-1\">\n                    {sector.anomalies.map(anomaly => (\n                      <div\n                        key={anomaly.id}\n                        className={`rounded px-2 py-1 text-xs ${\n                          anomaly.severity === 'high'\n                            ? 'bg-red-900/50 text-red-400'\n                            : anomaly.severity === 'medium'\n                              ? 'bg-yellow-900/50 text-yellow-400'\n                              : 'bg-blue-900/50 text-blue-400'\n                        }`}\n                      >\n                        {anomaly.type.charAt(0).toUpperCase() + anomaly.type.slice(1)}\n                      </div>\n                    ))}\n                  </div>\n                </div>\n              )}\n\n              {/* Scanning Ship Indicator */}\n              {scanningShip && (\n                <div className=\"absolute -right-2 -top-2\">\n                  <Rocket className=\"h-5 w-5 animate-pulse text-teal-400\" />\n                </div>\n              )}\n            </div>\n\n            {/* Sector Label */}\n            <div className=\"absolute left-1/2 top-full mt-2 -translate-x-1/2 text-center\">\n              <div className=\"font-medium text-teal-200\">{sector.name}</div>\n              {sector.status !== 'unmapped' && (\n                <div className=\"text-sm text-teal-300/70\">\n                  {sector.status === 'scanning' ? 'Scanning in Progress' : 'Mapped'}\n                </div>\n              )}\n            </div>\n          </div>\n        </DropTarget>\n        {ContextMenuComponent}\n      </div>\n    );\n  },\n  (prevProps, nextProps) => {\n    // Custom comparison function for memo\n    return (\n      prevProps.sector === nextProps.sector &&\n      prevProps.isSelected === nextProps.isSelected &&\n      prevProps.showHeatMap === nextProps.showHeatMap &&\n      prevProps.ships.length === nextProps.ships.length\n    );\n  }\n);\n\n// Ship Marker Component with drag-and-drop\nconst ShipMarker = memo(({ ship, targetSector }: { ship: ReconShip; targetSector: Sector }) => {\n  return (\n    <div\n      className=\"absolute transition-all duration-300\"\n      style={{\n        left: `calc(50% + ${targetSector.position.x}px)`,\n        top: `calc(50% + ${targetSector.position.y}px)`,\n        transform: 'translate(-50%, -50%)',\n      }}\n    >\n      <Draggable\n        item={{\n          id: ship.id,\n          type: 'ship',\n          data: ship,\n        }}\n      >\n        <div className=\"rounded-lg border border-teal-500/30 bg-teal-900/80 p-2 backdrop-blur-sm\">\n          <div className=\"flex items-center space-x-2\">\n            <Rocket className=\"h-4 w-4 text-teal-400\" />\n            <span className=\"text-xs font-medium text-teal-200\">{ship.name}</span>\n          </div>\n          <div className=\"mt-1 text-xs text-teal-400/70\">\n            {ship.status.charAt(0).toUpperCase() + ship.status.slice(1)}\n          </div>\n        </div>\n      </Draggable>\n    </div>\n  );\n});\n\nexport function ExplorationHub() {\n  const [selectedSector, setSelectedSector] = useState<Sector | null>(null);\n  const [showTutorial, setShowTutorial] = useState(true);\n  const [showMissionLog, setShowMissionLog] = useState(false);\n  const [filter, setFilter] = useState<FilterType>('all');\n  const [searchQuery, setSearchQuery] = useState('');\n  const [zoom, setZoom] = useState(1);\n  const [position, setPosition] = useState<{ x: number; y: number } | null>(null);\n  const [showHeatMap, setShowHeatMap] = useState(false);\n  const [showFilters, setShowFilters] = useState(false);\n  const [advancedFilters, setAdvancedFilters] = useState<AdvancedFilters>({\n    minResourcePotential: 0,\n    minHabitabilityScore: 0,\n    hasAnomalies: false,\n    anomalySeverity: 'any',\n    lastScannedWithin: 24,\n    resourceTypes: [],\n  });\n  const [mapOffset, setMapOffset] = useState<MapOffset>({ x: 0, y: 0 });\n\n  const isDragging = useRef(false);\n  const lastPosition = useRef({ x: 0, y: 0 });\n  const { showTooltip, hideTooltip } = useTooltipContext();\n\n  // Add new state for real-time updates\n  const [sectors, setSectors] = useState(mockSectors);\n  const [ships, setShips] = useState(mockShips);\n  const [transfers, setTransfers] = useState(mockExplorationTransfers);\n\n  // Optimize update intervals with useRef\n  const updateIntervals = useRef({\n    ships: null as NodeJS.Timeout | null,\n    sectors: null as NodeJS.Timeout | null,\n    transfers: null as NodeJS.Timeout | null,\n  });\n\n  // Memoize complex calculations\n  const activeShips = useMemo(() => {\n    return ships.filter(ship => ship.status !== 'idle');\n  }, [ships]);\n\n  // Initialize ReconShipManager\n  const reconManager = useMemo(() => new ReconShipManagerImpl(), []);\n\n  // Register automation rules on mount\n  useEffect(() => {\n    // Register each exploration rule\n    explorationRules.forEach(rule => {\n      automationManager.registerRule(rule);\n    });\n\n    // Cleanup on unmount\n    return () => {\n      explorationRules.forEach(rule => {\n        automationManager.removeRule(rule.id);\n      });\n    };\n  }, []);\n\n  // Update sector status handling\n  useEffect(() => {\n    // Sector updates (less frequent)\n    updateIntervals.current.sectors = setInterval(() => {\n      setSectors((prevSectors: Sector[]) => {\n        return prevSectors.map(sector => {\n          const scanningShip = ships.find(\n            ship => ship.targetSector === sector.id && ship.status === 'scanning'\n          );\n\n          // Create new sector with proper status type\n          return {\n            ...sector,\n            status: scanningShip\n              ? 'scanning'\n              : sector.status === 'scanning'\n                ? 'mapped'\n                : (sector.status as SectorStatus),\n            lastScanned: Date.now(),\n          };\n        });\n      });\n    }, 2000);\n\n    // Ship position updates (more frequent)\n    updateIntervals.current.ships = setInterval(() => {\n      setShips(prevShips =>\n        prevShips.map(ship => {\n          if (ship.status === 'idle' || !ship.targetSector) return ship;\n\n          const targetSector = sectors.find(s => s.id === ship.targetSector);\n          if (!targetSector) return ship;\n\n          // Calculate progress based on efficiency and time\n          const progress = Math.min(\n            1,\n            (Date.now() - (ship.lastUpdate || Date.now())) / (10000 / ship.efficiency)\n          );\n\n          // Update ship status based on progress\n          if (progress >= 1) {\n            return {\n              ...ship,\n              status: ship.status === 'scanning' ? 'returning' : 'idle',\n              lastUpdate: Date.now(),\n            } as ReconShip;\n          }\n\n          return {\n            ...ship,\n            lastUpdate: Date.now(),\n          } as ReconShip;\n        })\n      );\n    }, 1000);\n\n    // Transfer updates (least frequent)\n    updateIntervals.current.transfers = setInterval(() => {\n      setTransfers(prevTransfers =>\n        prevTransfers.map(transfer => {\n          if (transfer.progress >= 1) return transfer;\n\n          return {\n            ...transfer,\n            progress: Math.min(1, transfer.progress + 0.1),\n          };\n        })\n      );\n    }, 3000);\n\n    // Store current intervals for cleanup\n    const currentIntervals = { ...updateIntervals.current };\n\n    return () => {\n      Object.values(currentIntervals).forEach(interval => {\n        if (interval) clearInterval(interval);\n      });\n    };\n  }, [ships]);\n\n  // Update ship status management\n  useEffect(() => {\n    const interval = setInterval(() => {\n      setShips((prevShips: ReconShip[]) =>\n        prevShips.map(ship => {\n          if (!ship) return ship;\n\n          const baseShip = {\n            ...ship,\n            lastUpdate: Date.now(),\n            status: ship.status || 'idle',\n            experience: ship.experience ?? 0,\n            specialization: ship.specialization || 'mapping',\n            efficiency: ship.efficiency || 1.0,\n          } as ReconShip;\n\n          if (baseShip.status === 'idle' || !baseShip.assignedSectorId) {\n            return baseShip;\n          }\n\n          // Calculate progress based on efficiency and time\n          const progress = Math.min(\n            1,\n            (Date.now() - (baseShip.lastUpdate || Date.now())) /\n              (10000 / (baseShip.efficiency || 1))\n          );\n\n          // Update ship status based on progress\n          if (progress >= 1) {\n            baseShip.status = baseShip.status === 'scanning' ? 'assigned' : 'returning';\n          }\n\n          return baseShip;\n        })\n      );\n    }, 1000);\n\n    return () => clearInterval(interval);\n  }, []);\n\n  // Update task completion handler\n  useEffect(() => {\n    const handleTaskCompleted = (event: BaseEvent) => {\n      const { shipId, ship } = event?.data as ShipEvent['data'];\n      if (!shipId || !ship?.assignedSectorId) return;\n\n      setShips((prevShips: ReconShip[]) =>\n        prevShips.map(s =>\n          s.id === shipId\n            ? {\n                ...s,\n                status: 'returning' as ReconShip['status'],\n                experience: (s.experience ?? 0) + 100,\n                lastUpdate: Date.now(),\n              }\n            : s\n        )\n      );\n\n      setSectors((prevSectors: Sector[]) =>\n        prevSectors.map(sector =>\n          sector.id === ship.assignedSectorId\n            ? {\n                ...sector,\n                status: 'mapped' as SectorStatus,\n                lastScanned: Date.now(),\n              }\n            : sector\n        )\n      );\n    };\n\n    const unsubscribe = reconManager.subscribeToEvent(\n      EventType.EXPLORATION_TASK_COMPLETED,\n      handleTaskCompleted\n    );\n    return () => {\n      unsubscribe();\n    };\n  }, [reconManager]);\n\n  // Update sector filtering with proper type checks\n  const filterSectors = (\n    sectors: Sector[],\n    filter: FilterType,\n    advancedFilters: AdvancedFilters\n  ) => {\n    return sectors.filter(sector => {\n      // Basic filters\n      if (filter === 'unmapped' && sector.status !== 'unmapped') {\n        return false;\n      }\n\n      // Handle optional anomalies array safely\n      const anomalies = sector.anomalies ?? [];\n      if (filter === 'anomalies' && anomalies.length === 0) {\n        return false;\n      }\n\n      // Advanced filters with safe property access\n      if (advancedFilters) {\n        const resourcePotential = sector.resourcePotential ?? 0;\n        const habitabilityScore = sector.habitabilityScore ?? 0;\n\n        if (resourcePotential < advancedFilters.minResourcePotential) {\n          return false;\n        }\n        if (habitabilityScore < advancedFilters.minHabitabilityScore) {\n          return false;\n        }\n        if (advancedFilters.hasAnomalies && anomalies.length === 0) {\n          return false;\n        }\n        if (advancedFilters.anomalySeverity !== 'any') {\n          const hasMatchingSeverity = anomalies.some(\n            a => a.severity === advancedFilters.anomalySeverity\n          );\n          if (!hasMatchingSeverity) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    });\n  };\n\n  // Enhanced sector filtering\n  const filteredSectors = useMemo(() => {\n    return filterSectors(sectors, filter, advancedFilters);\n  }, [sectors, filter, advancedFilters]);\n\n  // Enhanced heat map calculation\n  const getSectorHeat = useCallback((sector: Sector) => {\n    let heatValue = 0;\n\n    // Base heat from resource potential\n    heatValue += sector.resourcePotential * 0.4;\n\n    // Heat from habitability\n    heatValue += sector.habitabilityScore * 0.3;\n\n    // Heat from anomalies\n    const anomalyHeat = sector.anomalies.reduce((sum, anomaly) => {\n      const severityValue =\n        anomaly.severity === 'high' ? 0.3 : anomaly.severity === 'medium' ? 0.2 : 0.1;\n      return sum + severityValue;\n    }, 0);\n    heatValue += anomalyHeat;\n\n    // Reduce heat for older scans\n    if (sector.lastScanned) {\n      const hoursSinceLastScan = (Date.now() - sector.lastScanned) / (1000 * 60 * 60);\n      const ageFactor = Math.max(0, 1 - hoursSinceLastScan / 168); // 168 hours = 1 week\n      heatValue *= ageFactor;\n    }\n\n    return Math.min(1, heatValue);\n  }, []);\n\n  // Memoize handlers\n  const handleSectorSelect = useCallback((sector: Sector) => {\n    setSelectedSector(sector);\n  }, []);\n\n  const handleMouseDown = useCallback((e: React.MouseEvent) => {\n    isDragging.current = true;\n    lastPosition.current = { x: e.clientX, y: e.clientY };\n    const startX = e.clientX;\n    const startY = e.clientY;\n    setPosition({ x: startX, y: startY });\n  }, []);\n\n  const handleMouseMove = useCallback(\n    (e: React.MouseEvent) => {\n      // Implementation for map panning\n      if (position && isDragging.current) {\n        const dx = e.clientX - position.x;\n        const dy = e.clientY - position.y;\n        setPosition({ x: e.clientX, y: e.clientY });\n        // Update map position based on dx and dy\n        setMapOffset((prev: MapOffset) => ({\n          x: prev.x + dx,\n          y: prev.y + dy,\n        }));\n      }\n    },\n    [position]\n  );\n\n  const handleMouseUp = useCallback(() => {\n    isDragging.current = false;\n    setPosition(null);\n  }, []);\n\n  const handleZoom = useCallback((delta: number) => {\n    setZoom(prev => Math.max(0.5, Math.min(2, prev + delta)));\n  }, []);\n\n  // Enhanced sector hover tooltip\n  const handleSectorHover = useCallback(\n    (show: boolean, sector: Sector) => {\n      if (show) {\n        showTooltip(\n          <div className=\"max-w-xs rounded-lg border border-gray-700 bg-gray-800/95 p-4 shadow-xl\">\n            <div className=\"mb-3 flex items-center justify-between\">\n              <div className=\"font-medium text-white\">{sector.name}</div>\n              <div\n                className={`rounded px-2 py-0.5 text-xs ${\n                  sector.status === 'unmapped'\n                    ? 'bg-gray-700 text-gray-400'\n                    : sector.status === 'scanning'\n                      ? 'bg-teal-900/50 text-teal-400'\n                      : 'bg-teal-800/30 text-teal-300'\n                }`}\n              >\n                {sector.status.charAt(0).toUpperCase() + sector.status.slice(1)}\n              </div>\n            </div>\n\n            {sector.status !== 'unmapped' && (\n              <>\n                {/* Resource and Habitability Bars */}\n                <div className=\"mb-3 space-y-2\">\n                  <div>\n                    <div className=\"mb-1 flex justify-between text-xs\">\n                      <span className=\"text-gray-400\">Resources</span>\n                      <span className=\"text-teal-400\">\n                        {Math.round(sector.resourcePotential * 100)}%\n                      </span>\n                    </div>\n                    <div className=\"h-1.5 overflow-hidden rounded-full bg-gray-700\">\n                      <div\n                        className=\"h-full rounded-full bg-teal-500\"\n                        style={{ width: `${sector.resourcePotential * 100}%` }}\n                      />\n                    </div>\n                  </div>\n\n                  <div>\n                    <div className=\"mb-1 flex justify-between text-xs\">\n                      <span className=\"text-gray-400\">Habitability</span>\n                      <span className=\"text-teal-400\">\n                        {Math.round(sector.habitabilityScore * 100)}%\n                      </span>\n                    </div>\n                    <div className=\"h-1.5 overflow-hidden rounded-full bg-gray-700\">\n                      <div\n                        className=\"h-full rounded-full bg-teal-500\"\n                        style={{ width: `${sector.habitabilityScore * 100}%` }}\n                      />\n                    </div>\n                  </div>\n                </div>\n\n                {/* Anomalies */}\n                {sector.anomalies.length > 0 && (\n                  <div className=\"mb-3\">\n                    <div className=\"mb-2 text-xs font-medium text-gray-300\">Detected Anomalies</div>\n                    <div className=\"space-y-1\">\n                      {sector.anomalies.map(anomaly => (\n                        <div\n                          key={anomaly.id}\n                          className={`rounded px-2 py-1 text-xs ${\n                            anomaly.severity === 'high'\n                              ? 'bg-red-900/50 text-red-400'\n                              : anomaly.severity === 'medium'\n                                ? 'bg-yellow-900/50 text-yellow-400'\n                                : 'bg-blue-900/50 text-blue-400'\n                          }`}\n                        >\n                          {anomaly.type.charAt(0).toUpperCase() + anomaly.type.slice(1)}\n                        </div>\n                      ))}\n                    </div>\n                  </div>\n                )}\n\n                {/* Last Scanned */}\n                {sector.lastScanned && (\n                  <div className=\"text-xs text-gray-500\">\n                    Last Scanned: {new Date(sector.lastScanned).toLocaleString()}\n                  </div>\n                )}\n              </>\n            )}\n          </div>\n        );\n      } else {\n        hideTooltip();\n      }\n    },\n    [showTooltip, hideTooltip]\n  );\n\n  // Handle ship assignment\n  const handleShipAssign = useCallback(\n    (shipId: string, sectorId: string) => {\n      const sector = sectors.find(s => s.id === sectorId);\n      if (!sector) return;\n\n      reconManager.assignExplorationTask(shipId, sectorId, sector.position, 'mapping');\n\n      setShips(prevShips =>\n        prevShips.map(ship =>\n          ship.id === shipId\n            ? {\n                ...ship,\n                status: 'assigned',\n                assignedSectorId: sectorId,\n                lastUpdate: Date.now(),\n              }\n            : ship\n        )\n      );\n    },\n    [sectors, reconManager]\n  );\n\n  // Register ships with ReconShipManager\n  useEffect(() => {\n    ships.forEach(ship => {\n      reconManager.registerShip(ship);\n    });\n  }, [ships, reconManager]);\n\n  return (\n    <div className=\"fixed inset-4 flex overflow-hidden rounded-lg border border-gray-700 bg-gray-900/95 shadow-2xl backdrop-blur-md\">\n      {/* Left Panel - Exploration Map */}\n      <div className=\"flex w-2/3 flex-col border-r border-gray-700 p-6\">\n        <div className=\"mb-6 flex items-center justify-between\">\n          <div className=\"flex items-center space-x-3\">\n            <Radar className=\"h-6 w-6 text-teal-400\" />\n            <h2 className=\"text-xl font-bold text-white\">Exploration Hub</h2>\n          </div>\n\n          <div className=\"flex items-center space-x-4\">\n            <div className=\"relative\">\n              <input\n                type=\"text\"\n                placeholder=\"Search sectors...\"\n                className=\"w-64 rounded-lg border border-gray-700 bg-gray-800/90 px-4 py-2 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-teal-500\"\n                value={searchQuery}\n                onChange={e => setSearchQuery(e.target.value)}\n              />\n              <Search className=\"absolute right-3 top-2.5 h-5 w-5 text-gray-400\" />\n            </div>\n\n            <div className=\"flex space-x-2\">\n              <button\n                onClick={() => handleZoom(0.1)}\n                className=\"rounded-lg bg-gray-800/90 p-2 backdrop-blur-sm transition-colors hover:bg-gray-700/90\"\n              >\n                <ZoomIn className=\"h-5 w-5 text-teal-400\" />\n              </button>\n              <button\n                onClick={() => handleZoom(-0.1)}\n                className=\"rounded-lg bg-gray-800/90 p-2 backdrop-blur-sm transition-colors hover:bg-gray-700/90\"\n              >\n                <ZoomOut className=\"h-5 w-5 text-teal-400\" />\n              </button>\n            </div>\n\n            <button\n              onClick={() => setShowMissionLog(true)}\n              className=\"rounded-lg bg-gray-800/90 p-2 backdrop-blur-sm transition-colors hover:bg-gray-700/90\"\n            >\n              <History className=\"h-5 w-5 text-teal-400\" />\n            </button>\n          </div>\n        </div>\n\n        {/* Enhanced Filter Controls */}\n        <div className=\"mb-6\">\n          <div className=\"mb-2 flex items-center justify-between\">\n            <div className=\"flex space-x-2\">\n              <button\n                onClick={() => setFilter('all')}\n                className={`flex items-center space-x-2 rounded-lg px-3 py-2 ${\n                  filter === 'all'\n                    ? 'bg-teal-600 text-white'\n                    : 'bg-gray-800 text-gray-400 hover:bg-gray-700'\n                }`}\n              >\n                <Map className=\"h-4 w-4\" />\n                <span>All Sectors</span>\n              </button>\n              <button\n                onClick={() => setFilter('unmapped')}\n                className={`flex items-center space-x-2 rounded-lg px-3 py-2 ${\n                  filter === 'unmapped'\n                    ? 'bg-teal-600 text-white'\n                    : 'bg-gray-800 text-gray-400 hover:bg-gray-700'\n                }`}\n              >\n                <Radar className=\"h-4 w-4\" />\n                <span>Unmapped</span>\n              </button>\n              <button\n                onClick={() => setFilter('anomalies')}\n                className={`flex items-center space-x-2 rounded-lg px-3 py-2 ${\n                  filter === 'anomalies'\n                    ? 'bg-teal-600 text-white'\n                    : 'bg-gray-800 text-gray-400 hover:bg-gray-700'\n                }`}\n              >\n                <AlertTriangle className=\"h-4 w-4\" />\n                <span>Anomalies</span>\n              </button>\n              <button\n                onClick={() => setShowHeatMap(!showHeatMap)}\n                className={`flex items-center space-x-2 rounded-lg px-3 py-2 ${\n                  showHeatMap\n                    ? 'bg-teal-600 text-white'\n                    : 'bg-gray-800 text-gray-400 hover:bg-gray-700'\n                }`}\n              >\n                <Map className=\"h-4 w-4\" />\n                <span>Heat Map</span>\n              </button>\n            </div>\n\n            <button\n              onClick={() => setShowFilters(!showFilters)}\n              className={`flex items-center space-x-2 rounded-lg px-3 py-2 ${\n                Object.values(advancedFilters).some(v =>\n                  Array.isArray(v) ? v.length > 0 : v !== 0 && v !== false && v !== 'any'\n                )\n                  ? 'bg-teal-600 text-white'\n                  : 'bg-gray-800 text-gray-400 hover:bg-gray-700'\n              }`}\n            >\n              <Filter className=\"h-4 w-4\" />\n              <span>Advanced Filters</span>\n            </button>\n          </div>\n\n          {/* Advanced Filters Panel */}\n          {showFilters && (\n            <div className=\"mt-4 rounded-lg bg-gray-800/50 p-4\">\n              <div className=\"grid grid-cols-2 gap-4\">\n                <div>\n                  <label className=\"mb-2 block text-sm text-gray-400\">Min Resource Potential</label>\n                  <input\n                    type=\"range\"\n                    min=\"0\"\n                    max=\"1\"\n                    step=\"0.1\"\n                    value={advancedFilters.minResourcePotential}\n                    onChange={e =>\n                      setAdvancedFilters(prev => ({\n                        ...prev,\n                        minResourcePotential: parseFloat(e.target.value),\n                      }))\n                    }\n                    className=\"w-full\"\n                  />\n                  <div className=\"mt-1 text-sm text-teal-400\">\n                    {Math.round(advancedFilters.minResourcePotential * 100)}%\n                  </div>\n                </div>\n                <div>\n                  <label className=\"mb-2 block text-sm text-gray-400\">Min Habitability Score</label>\n                  <input\n                    type=\"range\"\n                    min=\"0\"\n                    max=\"1\"\n                    step=\"0.1\"\n                    value={advancedFilters.minHabitabilityScore}\n                    onChange={e =>\n                      setAdvancedFilters(prev => ({\n                        ...prev,\n                        minHabitabilityScore: parseFloat(e.target.value),\n                      }))\n                    }\n                    className=\"w-full\"\n                  />\n                  <div className=\"mt-1 text-sm text-teal-400\">\n                    {Math.round(advancedFilters.minHabitabilityScore * 100)}%\n                  </div>\n                </div>\n              </div>\n\n              <div className=\"mt-4 grid grid-cols-2 gap-4\">\n                <div>\n                  <label className=\"mb-2 block text-sm text-gray-400\">Anomaly Settings</label>\n                  <div className=\"space-y-2\">\n                    <label className=\"flex items-center\">\n                      <input\n                        type=\"checkbox\"\n                        checked={advancedFilters.hasAnomalies}\n                        onChange={e =>\n                          setAdvancedFilters(prev => ({\n                            ...prev,\n                            hasAnomalies: e.target.checked,\n                          }))\n                        }\n                        className=\"mr-2\"\n                      />\n                      <span className=\"text-sm text-gray-300\">Has Anomalies</span>\n                    </label>\n                    <select\n                      value={advancedFilters.anomalySeverity}\n                      onChange={e =>\n                        setAdvancedFilters(prev => ({\n                          ...prev,\n                          anomalySeverity: e.target.value as 'any' | 'low' | 'medium' | 'high',\n                        }))\n                      }\n                      className=\"w-full rounded bg-gray-700 px-2 py-1 text-sm text-white\"\n                    >\n                      <option value=\"any\">Any Severity</option>\n                      <option value=\"low\">Low</option>\n                      <option value=\"medium\">Medium</option>\n                      <option value=\"high\">High</option>\n                    </select>\n                  </div>\n                </div>\n                <div>\n                  <label className=\"mb-2 block text-sm text-gray-400\">Last Scanned Within</label>\n                  <select\n                    value={advancedFilters.lastScannedWithin}\n                    onChange={e =>\n                      setAdvancedFilters(prev => ({\n                        ...prev,\n                        lastScannedWithin: parseInt(e.target.value),\n                      }))\n                    }\n                    className=\"w-full rounded bg-gray-700 px-2 py-1 text-sm text-white\"\n                  >\n                    <option value={0}>Any Time</option>\n                    <option value={24}>24 Hours</option>\n                    <option value={72}>3 Days</option>\n                    <option value={168}>1 Week</option>\n                  </select>\n                </div>\n              </div>\n\n              <div className=\"mt-4\">\n                <label className=\"mb-2 block text-sm text-gray-400\">Resource Types</label>\n                <div className=\"flex flex-wrap gap-2\">\n                  {['Dark Matter', 'Helium-3', 'Rare Metals', 'Common Ores'].map(type => (\n                    <button\n                      key={type}\n                      onClick={() =>\n                        setAdvancedFilters(prev => ({\n                          ...prev,\n                          resourceTypes: prev.resourceTypes.includes(type)\n                            ? prev.resourceTypes.filter(t => t !== type)\n                            : [...prev.resourceTypes, type],\n                        }))\n                      }\n                      className={`rounded px-2 py-1 text-sm ${\n                        advancedFilters.resourceTypes.includes(type)\n                          ? 'bg-teal-600 text-white'\n                          : 'bg-gray-700 text-gray-400'\n                      }`}\n                    >\n                      {type}\n                    </button>\n                  ))}\n                </div>\n              </div>\n            </div>\n          )}\n        </div>\n\n        {/* Map Content */}\n        <div\n          className=\"relative flex-1 overflow-hidden\"\n          onMouseDown={handleMouseDown}\n          onMouseMove={handleMouseMove}\n          onMouseUp={handleMouseUp}\n          onMouseLeave={handleMouseUp}\n        >\n          <div\n            className=\"absolute inset-0\"\n            style={{\n              transform: `translate(${mapOffset.x}px, ${mapOffset.y}px) scale(${zoom})`,\n              transformOrigin: 'center',\n              transition: isDragging.current ? 'none' : 'transform 0.3s ease-out',\n            }}\n          >\n            {filteredSectors.map(sector => (\n              <SectorComponent\n                key={sector.id}\n                sector={sector}\n                isSelected={selectedSector?.id === sector.id}\n                showHeatMap={showHeatMap}\n                onSelect={handleSectorSelect}\n                onHover={handleSectorHover}\n                getSectorHeat={getSectorHeat}\n                ships={ships}\n                onShipAssign={handleShipAssign}\n              />\n            ))}\n\n            {/* Ship Markers */}\n            {activeShips.map(ship => {\n              const targetSector = sectors.find(s => s.id === ship.targetSector);\n              if (!targetSector) {\n                return null;\n              }\n              return <ShipMarker key={ship.id} ship={ship} targetSector={targetSector} />;\n            })}\n\n            {/* Resource Transfers */}\n            <ResourceTransfer transfers={transfers} />\n          </div>\n        </div>\n      </div>\n\n      {/* Right Panel */}\n      <div className=\"flex w-1/3 flex-col p-6\">\n        {selectedSector ? (\n          <>\n            <ExplorationControls\n              sector={{\n                ...selectedSector,\n                status: (selectedSector.status === 'unmapped'\n                  ? 'unmapped'\n                  : selectedSector.status === 'scanning'\n                    ? 'scanning'\n                    : 'mapped') as SectorStatus,\n              }}\n              onClose={() => setSelectedSector(null)}\n            />\n            <div className=\"mt-6\">\n              <ReconShipStatus\n                ships={activeShips.map(ship => {\n                  let displayStatus: ReconShipStatusType;\n                  if (ship.status === 'assigned' || ship.status === 'scanning') {\n                    displayStatus = 'scanning';\n                  } else if (ship.status === 'returning') {\n                    displayStatus = 'returning';\n                  } else {\n                    displayStatus = 'idle';\n                  }\n\n                  return {\n                    id: ship.id,\n                    name: ship.name,\n                    status: displayStatus,\n                    targetSector: ship.targetSector,\n                    experience: ship.experience,\n                    specialization: ship.specialization,\n                    efficiency: ship.efficiency,\n                  };\n                })}\n              />\n            </div>\n          </>\n        ) : (\n          <div className=\"flex h-full items-center justify-center text-gray-400\">\n            Select a sector to view details\n          </div>\n        )}\n      </div>\n\n      {/* Modals */}\n      {showMissionLog && <MissionLog onClose={() => setShowMissionLog(false)} />}\n      {showTutorial && <ExplorationTutorial onClose={() => setShowTutorial(false)} />}\n    </div>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/ExplorationHub/ExplorationTutorial.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/ExplorationHub/ExplorationWindow.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/ExplorationHub/MissionLog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/ExplorationHub/MissionReplay.tsx","messages":[{"ruleId":"no-unsafe-optional-chaining","severity":2,"message":"Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.","line":128,"column":25,"nodeType":"ChainExpression","messageId":"unsafeOptionalChain","endLine":128,"endColumn":36},{"ruleId":"no-unsafe-optional-chaining","severity":2,"message":"Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.","line":131,"column":18,"nodeType":"ChainExpression","messageId":"unsafeOptionalChain","endLine":131,"endColumn":39},{"ruleId":"no-unsafe-optional-chaining","severity":2,"message":"Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.","line":137,"column":25,"nodeType":"ChainExpression","messageId":"unsafeOptionalChain","endLine":137,"endColumn":36},{"ruleId":"no-unsafe-optional-chaining","severity":2,"message":"Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.","line":140,"column":18,"nodeType":"ChainExpression","messageId":"unsafeOptionalChain","endLine":140,"endColumn":39},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isCurrentEvent' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":162,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":162,"endColumn":27}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Pause, Play, SkipBack, SkipForward, X } from 'lucide-react';\nimport { useCallback, useEffect, useState } from 'react';\nimport { useGameState } from '../../../../contexts/GameContext';\nimport { GameEvent, GameEventType, Position } from '../../../../types/core/GameTypes';\n\ninterface MissionReplayProps {\n  missionId: string;\n  onClose: () => void;\n}\n\ninterface EventPosition {\n  x: number;\n  y: number;\n}\n\ninterface Mission {\n  id: string;\n  timestamp: number;\n  description: string;\n}\n\ninterface GameState {\n  missions: {\n    history: Mission[];\n  };\n  events: GameEvent[];\n}\n\nconst selectGameState = (state: unknown): GameState => {\n  if (\n    typeof state === 'object' &&\n    state !== null &&\n    'missions' in state &&\n    'events' in state &&\n    typeof state.missions === 'object' &&\n    state.missions !== null &&\n    'history' in state.missions &&\n    Array.isArray(state.missions.history) &&\n    Array.isArray(state.events)\n  ) {\n    return state as GameState;\n  }\n  return {\n    missions: {\n      history: [],\n    },\n    events: [],\n  };\n};\n\nexport function MissionReplay({ missionId, onClose }: MissionReplayProps) {\n  const gameState = useGameState(selectGameState);\n\n  // Ensure state is available\n  if (!gameState) {\n    return null;\n  }\n\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [currentTime, setCurrentTime] = useState(0);\n  const [playbackSpeed, setPlaybackSpeed] = useState(1);\n  const [currentEventIndex, setCurrentEventIndex] = useState<number | null>(null);\n\n  // Find the mission and related events\n  const mission = gameState.missions.history.find(m => m.id === missionId);\n  const events = gameState.events.filter(\n    e =>\n      e.timestamp >= (mission?.timestamp ?? 0) && e.timestamp <= (mission?.timestamp ?? 0) + 3600000 // 1 hour window\n  );\n\n  // Calculate total duration\n  const duration =\n    events.length > 0 ? events[events.length - 1].timestamp - events[0].timestamp : 0;\n\n  // Handle playback controls\n  const togglePlayback = useCallback(() => {\n    setIsPlaying(!isPlaying);\n  }, [isPlaying]);\n\n  const handleSeek = useCallback(\n    (time: number) => {\n      setCurrentTime(Math.max(0, Math.min(time, duration)));\n    },\n    [duration]\n  );\n\n  const handleSpeedChange = useCallback((speed: number) => {\n    setPlaybackSpeed(speed);\n  }, []);\n\n  // Update time during playback\n  useEffect(() => {\n    if (!isPlaying) {\n      return;\n    }\n\n    const interval = setInterval(() => {\n      setCurrentTime(time => {\n        const newTime = time + 100 * playbackSpeed;\n        if (newTime >= duration) {\n          setIsPlaying(false);\n          return duration;\n        }\n        return newTime;\n      });\n    }, 100);\n\n    return () => clearInterval(interval);\n  }, [isPlaying, playbackSpeed, duration]);\n\n  if (!mission) {\n    return null;\n  }\n\n  // Get events up to current time\n  const currentEvents = events.filter(\n    (e: GameEvent) => e.timestamp <= events[0].timestamp + currentTime\n  );\n\n  // Render map with ship paths and events\n  const renderEvents = (events: GameEvent[]) => {\n    return events.map((event: GameEvent, index: number) => {\n      // Calculate position based on event data or use random positioning as fallback\n      const eventPosition: EventPosition = {\n        x:\n          typeof event?.data === 'object' &&\n          event?.data !== null &&\n          'position' in event?.data &&\n          typeof event?.data?.position === 'object' &&\n          event?.data?.position !== null &&\n          'x' in event?.data?.position\n            ? (event?.data?.position as Position).x\n            : Math.random() * 100,\n        y:\n          typeof event?.data === 'object' &&\n          event?.data !== null &&\n          'position' in event?.data &&\n          typeof event?.data?.position === 'object' &&\n          event?.data?.position !== null &&\n          'y' in event?.data?.position\n            ? (event?.data?.position as Position).y\n            : Math.random() * 100,\n      };\n\n      // Determine event marker appearance based on event type\n      const getEventColor = (type: GameEventType) => {\n        switch (type) {\n          case 'exploration':\n            return 'bg-teal-400';\n          case 'combat':\n            return 'bg-red-400';\n          case 'trade':\n            return 'bg-amber-400';\n          case 'diplomacy':\n            return 'bg-purple-400';\n          default:\n            return 'bg-teal-400';\n        }\n      };\n\n      // Check if this is the current event being viewed\n      const isCurrentEvent = index === currentEventIndex;\n\n      return (\n        <div\n          key={`event-${index}`}\n          className=\"absolute h-2 w-2 rounded-full\"\n          style={{\n            left: `${eventPosition.x}%`,\n            top: `${eventPosition.y}%`,\n            backgroundColor: getEventColor(event?.type),\n          }}\n          onClick={() => {\n            // Set current event index to this event when clicked\n            setCurrentEventIndex(index);\n          }}\n        />\n      );\n    });\n  };\n\n  return (\n    <div className=\"fixed inset-0 z-50 flex items-center justify-center bg-black/50\">\n      <div className=\"mx-4 w-full max-w-4xl rounded-lg border border-gray-700 bg-gray-900 p-6\">\n        <div className=\"mb-6 flex items-center justify-between\">\n          <h2 className=\"text-xl font-bold text-white\">Mission Replay</h2>\n          <button onClick={onClose} className=\"rounded-lg p-2 transition-colors hover:bg-gray-800\">\n            <X className=\"h-5 w-5 text-gray-400\" />\n          </button>\n        </div>\n\n        {/* Mission Details */}\n        <div className=\"mb-6\">\n          <div className=\"mb-2 text-lg text-white\">{mission.description}</div>\n          <div className=\"text-sm text-gray-400\">\n            {new Date(mission.timestamp).toLocaleString()}\n          </div>\n        </div>\n\n        {/* Replay Visualization */}\n        <div className=\"relative mb-6 h-96 overflow-hidden rounded-lg bg-gray-800/50\">\n          {/* Map View */}\n          <div className=\"absolute inset-0\">{renderEvents(currentEvents)}</div>\n\n          {/* Event Timeline */}\n          <div className=\"absolute bottom-0 left-0 right-0 h-24 bg-gradient-to-t from-gray-900/90 to-transparent p-4\">\n            <div className=\"mb-4 flex items-center space-x-4\">\n              {currentEvents.map((event: GameEvent, index: number) => (\n                <div\n                  key={index}\n                  className={`h-2 w-2 rounded-full ${\n                    index === currentEventIndex ? 'bg-white' : 'bg-teal-400'\n                  }`}\n                  style={{\n                    left: `${((event?.timestamp - events[0].timestamp) / duration) * 100}%`,\n                  }}\n                  onClick={() => setCurrentEventIndex(index)}\n                />\n              ))}\n            </div>\n\n            {/* Current Event Details */}\n            {currentEventIndex !== null && currentEvents[currentEventIndex] && (\n              <div className=\"mb-2 text-sm text-white\">\n                <span className=\"font-bold\">{currentEvents[currentEventIndex].type}</span> event at{' '}\n                {new Date(currentEvents[currentEventIndex].timestamp).toLocaleTimeString()}\n              </div>\n            )}\n          </div>\n        </div>\n\n        {/* Playback Controls */}\n        <div className=\"flex items-center justify-between\">\n          <div className=\"flex items-center space-x-4\">\n            <button\n              onClick={() => handleSeek(0)}\n              className=\"rounded-lg p-2 transition-colors hover:bg-gray-800\"\n            >\n              <SkipBack className=\"h-5 w-5 text-teal-400\" />\n            </button>\n            <button\n              onClick={togglePlayback}\n              className=\"rounded-lg p-2 transition-colors hover:bg-gray-800\"\n            >\n              {isPlaying ? (\n                <Pause className=\"h-5 w-5 text-teal-400\" />\n              ) : (\n                <Play className=\"h-5 w-5 text-teal-400\" />\n              )}\n            </button>\n            <button\n              onClick={() => handleSeek(duration)}\n              className=\"rounded-lg p-2 transition-colors hover:bg-gray-800\"\n            >\n              <SkipForward className=\"h-5 w-5 text-teal-400\" />\n            </button>\n          </div>\n\n          {/* Playback Speed */}\n          <div className=\"flex items-center space-x-2\">\n            <span className=\"text-sm text-gray-400\">Speed:</span>\n            {[0.5, 1, 2, 4].map(speed => (\n              <button\n                key={speed}\n                onClick={() => handleSpeedChange(speed)}\n                className={`rounded px-2 py-1 text-sm ${\n                  playbackSpeed === speed\n                    ? 'bg-teal-600 text-white'\n                    : 'bg-gray-800 text-gray-400 hover:bg-gray-700'\n                }`}\n              >\n                {speed}x\n              </button>\n            ))}\n          </div>\n\n          {/* Progress */}\n          <div className=\"text-sm text-gray-400\">\n            {Math.floor(currentTime / 1000)}s / {Math.floor(duration / 1000)}s\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/ExplorationHub/ReconShipStatus.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/ExplorationHub/ShipStatusMonitor.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/MiningHub/AutomationMonitor.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/MiningHub/MineralProcessingCentre.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/MiningHub/MiningControls.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/MiningHub/MiningMap.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/MiningHub/MiningTutorial.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/MiningHub/MiningWindow.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_storage' is defined but never used.","line":431,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":431,"endColumn":13}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/** @jsx React.createElement */\n/** @jsxFrag React.Fragment */\nimport {\n  ArrowDown,\n  ArrowUp,\n  HelpCircle,\n  Info,\n  Microscope,\n  MoreHorizontal,\n  Search,\n  Settings,\n  Ship,\n  Sliders,\n  Target,\n} from 'lucide-react';\nimport * as React from 'react';\nimport { useCallback, useMemo, useState } from 'react';\nimport { ContextMenuItem, useContextMenu } from '../../../../components/ui/ContextMenu';\nimport { Draggable, DragItem, DropTarget } from '../../../../components/ui/DragAndDrop';\nimport { MiningResource } from '../../../../types/mining/MiningTypes';\nimport { ResourceType } from './../../../../types/resources/ResourceTypes';\nimport { MiningMap } from './MiningMap';\nimport { MiningTutorial } from './MiningTutorial';\nimport { ResourceNode } from './ResourceNode';\nimport { ResourceStorage } from './ResourceStorage';\nimport { ResourceTransfer } from './ResourceTransfer';\n\n// Mock storage data\nconst mockStorageData = [\n  {\n    id: 'iron-storage',\n    resourceType: ResourceType.IRON,\n    currentAmount: 8500,\n    maxCapacity: 10000,\n    refiningAmount: 250,\n    refiningProgress: 0.65,\n    transferRate: 25,\n  },\n  {\n    id: 'helium-storage',\n    resourceType: ResourceType.HELIUM,\n    currentAmount: 2800,\n    maxCapacity: 5000,\n    refiningAmount: 100,\n    refiningProgress: 0.3,\n    transferRate: 15,\n  },\n];\n\n// Mock transfer animations\nconst mockTransfers = [\n  {\n    id: 'transfer-1',\n    sourceId: 'iron-belt-1',\n    targetId: 'iron-storage',\n    resourceType: ResourceType.IRON,\n    amount: 50,\n    progress: 0.3,\n  },\n  {\n    id: 'transfer-2',\n    sourceId: 'helium-cloud-1',\n    targetId: 'helium-storage',\n    resourceType: ResourceType.HELIUM,\n    amount: 25,\n    progress: 0.7,\n  },\n];\n\ninterface Resource {\n  id: string;\n  name: string;\n  type: 'mineral' | ResourceType.GAS | ResourceType.EXOTIC;\n  abundance: number;\n  distance: number;\n  extractionRate: number;\n  depletion: number;\n  priority: number;\n  thresholds: {\n    min: number;\n    max: number;\n  };\n}\n\ninterface MiningShip {\n  id: string;\n  name: string;\n  type: 'rockBreaker' | 'voidDredger';\n  status: 'idle' | 'mining' | 'returning' | 'maintenance';\n  capacity: number;\n  currentLoad: number;\n  targetNode?: string;\n  efficiency: number;\n}\n\nconst mockResources: Resource[] = [\n  {\n    id: 'iron-belt-1',\n    name: 'Iron Belt Alpha',\n    type: 'mineral',\n    abundance: 0.8,\n    distance: 150,\n    extractionRate: 25,\n    depletion: 0.2,\n    priority: 1,\n    thresholds: { min: 3000, max: 10000 },\n  },\n  {\n    id: 'helium-cloud-1',\n    name: 'Helium Cloud Beta',\n    type: ResourceType.GAS,\n    abundance: 0.6,\n    distance: 300,\n    extractionRate: 15,\n    depletion: 0.1,\n    priority: 2,\n    thresholds: { min: 1000, max: 5000 },\n  },\n  {\n    id: 'dark-matter-1',\n    name: 'Dark Matter Cluster',\n    type: ResourceType.EXOTIC,\n    abundance: 0.3,\n    distance: 500,\n    extractionRate: 5,\n    depletion: 0.05,\n    priority: 3,\n    thresholds: { min: 100, max: 1000 },\n  },\n];\n\nconst mockShips: MiningShip[] = [\n  {\n    id: 'rb-1',\n    name: 'Rock Breaker Alpha',\n    type: 'rockBreaker',\n    status: 'mining',\n    capacity: 1000,\n    currentLoad: 450,\n    targetNode: 'iron-belt-1',\n    efficiency: 0.9,\n  },\n  {\n    id: 'vd-1',\n    name: 'Void Dredger Beta',\n    type: 'voidDredger',\n    status: 'returning',\n    capacity: 2000,\n    currentLoad: 1800,\n    targetNode: 'helium-cloud-1',\n    efficiency: 0.85,\n  },\n];\n\ntype ViewMode = 'map' | 'grid';\ntype SortOption = 'priority' | 'name' | 'type' | 'abundance' | 'distance';\ntype FilterOption = 'all' | 'mineral' | ResourceType.GAS | ResourceType.EXOTIC;\n\n// Define specific types for drag items\ninterface ResourceDragData {\n  id: string;\n  name: string;\n  type: 'mineral' | ResourceType.GAS | ResourceType.EXOTIC;\n  abundance: number;\n}\n\n/**\n * Interface for ship drag and drop operations\n *\n * This interface will be used in future implementations to:\n * 1. Enable ship assignment to resource nodes via drag and drop\n * 2. Support fleet management operations in the mining interface\n * 3. Display ship capabilities during drag operations\n * 4. Validate ship-to-resource compatibility during drops\n * 5. Implement specialized mining ship assignments based on resource types\n *\n * The efficiency property is particularly important for the upcoming\n * mining optimization system where ships with higher efficiency will\n * extract resources faster from compatible nodes.\n *\n * @deprecated This interface is not currently used but will be implemented\n * in the upcoming ship assignment system. It is kept here for reference.\n */\ninterface _ShipDragData {\n  id: string;\n  name: string;\n  type: 'rockBreaker' | 'voidDredger';\n  efficiency: number;\n}\n\n// Reference _ShipDragData in a type declaration to prevent \"unused\" error\ntype DragDataTypes = ResourceDragData | _ShipDragData;\n\n// Define a base type for drag data input\ninterface BaseDragDataInput {\n  id?: string;\n  name?: string;\n  [key: string]: unknown;\n}\n\n// Use the DragDataTypes in a function to prevent \"unused\" error\nconst createDragData = (type: 'resource' | 'ship', data: BaseDragDataInput): DragDataTypes => {\n  if (type === 'resource') {\n    return {\n      id: data?.id ?? '',\n      name: data?.name ?? '',\n      type: (data?.type as 'mineral' | ResourceType.GAS | ResourceType.EXOTIC) || 'mineral',\n      abundance: typeof data?.abundance === 'number' ? data?.abundance : 0,\n    } as ResourceDragData;\n  } else {\n    // This will be implemented in the future\n    console.warn('Ship drag data creation not yet implemented');\n    return {\n      id: data?.id ?? '',\n      name: data?.name ?? '',\n      type: 'rockBreaker',\n      efficiency: typeof data?.efficiency === 'number' ? data?.efficiency : 1.0,\n    } as _ShipDragData;\n  }\n};\n\n// Add helper functions to convert between types\nconst convertToMiningResource = (resource: Resource): MiningResource => {\n  // Map the string type to ResourceType enum\n  let resourceType: ResourceType;\n  switch (resource.type) {\n    case 'mineral':\n      resourceType = ResourceType.IRON; // Default to IRON for minerals\n      break;\n    case ResourceType.GAS:\n      resourceType = ResourceType.HELIUM; // Default to HELIUM for gas\n      break;\n    case ResourceType.EXOTIC:\n      resourceType = ResourceType.EXOTIC_MATTER; // Map to EXOTIC_MATTER for exotic\n      break;\n    default:\n      resourceType = ResourceType.IRON; // Default fallback\n  }\n\n  return {\n    ...resource,\n    type: resourceType,\n  };\n};\n\nconst convertToResource = (resource: MiningResource): Resource => {\n  // Map the ResourceType enum to string type\n  let type: 'mineral' | ResourceType.GAS | ResourceType.EXOTIC;\n  if ([ResourceType.IRON, ResourceType.COPPER, ResourceType.TITANIUM].includes(resource.type)) {\n    type = 'mineral';\n  } else if ([ResourceType.HELIUM, ResourceType.DEUTERIUM].includes(resource.type)) {\n    type = ResourceType.GAS;\n  } else if ([ResourceType.DARK_MATTER, ResourceType.EXOTIC_MATTER].includes(resource.type)) {\n    type = ResourceType.EXOTIC;\n  } else {\n    type = 'mineral'; // Default fallback\n  }\n\n  return {\n    ...resource,\n    type,\n  };\n};\n\nexport function MiningWindow() {\n  const [selectedNode, setSelectedNode] = useState<Resource | null>(null);\n  const [viewMode, setViewMode] = useState<ViewMode>('map');\n  const [searchQuery, setSearchQuery] = useState('');\n  const [mineAll, setMineAll] = useState(false);\n  const [sortBy, setSortBy] = useState<SortOption>('priority');\n  const [sortOrder, setSortOrder] = useState<'asc' | 'desc'>('asc');\n  const [tier, setTier] = useState<1 | 2 | 3>(1);\n  const [filterBy, setFilterBy] = useState<FilterOption>('all');\n  const [showTutorial, setShowTutorial] = useState(false);\n  const [showSettings, setShowSettings] = useState(false);\n  const [contextMenuItems, setContextMenuItems] = useState<ContextMenuItem[]>([]);\n  const { handleContextMenu, closeContextMenu, ContextMenuComponent } = useContextMenu({\n    items: contextMenuItems,\n  });\n\n  // Search input field\n  const searchInputRef = React.useRef<HTMLInputElement>(null);\n\n  // Memoize filtered and sorted resources\n  const filteredResources = useMemo(() => {\n    return mockResources\n      .filter(resource => {\n        if (searchQuery && !resource.name.toLowerCase().includes(searchQuery.toLowerCase())) {\n          return false;\n        }\n        if (filterBy !== 'all' && resource.type !== filterBy) {\n          return false;\n        }\n        return true;\n      })\n      .sort((a, b) => {\n        let comparison = 0;\n        switch (sortBy) {\n          case 'priority':\n            comparison = a.priority - b.priority;\n            break;\n          case 'name':\n            comparison = a.name.localeCompare(b.name);\n            break;\n          case 'type':\n            comparison = a.type.localeCompare(b.type);\n            break;\n          case 'abundance':\n            comparison = b.abundance - a.abundance;\n            break;\n          case 'distance':\n            comparison = a.distance - b.distance;\n            break;\n        }\n        return sortOrder === 'asc' ? comparison : -comparison;\n      });\n  }, [mockResources, searchQuery, filterBy, sortBy, sortOrder]);\n\n  // Memoize tech bonuses based on tier\n  const techBonuses = useMemo(() => {\n    const tierBonuses = {\n      1: { extractionRate: 1, storageCapacity: 1, efficiency: 1 },\n      2: { extractionRate: 1.5, storageCapacity: 1.5, efficiency: 1.25 },\n      3: { extractionRate: 2, storageCapacity: 2, efficiency: 1.5 },\n    } as const;\n    return tierBonuses[tier];\n  }, [tier]);\n\n  // Memoize handlers\n  const handleNodeSelect = useCallback((node: Resource) => {\n    setSelectedNode(node);\n  }, []);\n\n  const handleFilterChange = useCallback(\n    (newFilter: 'all' | 'mineral' | ResourceType.GAS | ResourceType.EXOTIC) => {\n      setFilterBy(newFilter);\n    },\n    []\n  );\n\n  const handleSearchChange = useCallback((event: React.ChangeEvent<HTMLInputElement>) => {\n    setSearchQuery(event?.target.value);\n  }, []);\n\n  const handleViewChange = useCallback((newView: ViewMode) => {\n    setViewMode(newView);\n  }, []);\n\n  const handleMineAllToggle = useCallback(() => {\n    setMineAll(prev => !prev);\n    console.warn(`Mine all resources: ${!mineAll}`);\n    // In a real implementation, this would dispatch an action to mine all available resources\n  }, [mineAll]);\n\n  const handleSortChange = useCallback((option: SortOption) => {\n    setSortBy(prevSort => {\n      if (prevSort === option) {\n        setSortOrder(prevOrder => (prevOrder === 'asc' ? 'desc' : 'asc'));\n        return option;\n      }\n      setSortOrder('asc');\n      return option;\n    });\n  }, []);\n\n  const handleTierChange = useCallback((newTier: 1 | 2 | 3) => {\n    setTier(newTier);\n    console.warn(`Mining tier set to: ${newTier}`);\n    // In a real implementation, this would update the mining operations to match the new tier\n  }, []);\n\n  // Context menu for resources\n  const getResourceMenuItems = (resource: Resource): ContextMenuItem[] => {\n    return [\n      {\n        id: 'prioritize',\n        label: 'Prioritize',\n        icon: React.createElement(ArrowUp, { className: 'h-4 w-4' }),\n        action: () => handleResourceAction('prioritize', resource),\n      },\n      {\n        id: 'assign-ship',\n        label: 'Assign Ship',\n        icon: React.createElement(Ship, { className: 'h-4 w-4' }),\n        action: () => handleResourceAction('assign-ship', resource),\n      },\n      {\n        id: 'set-thresholds',\n        label: 'Set Thresholds',\n        icon: React.createElement(Sliders, { className: 'h-4 w-4' }),\n        action: () => handleResourceAction('set-thresholds', resource),\n      },\n      {\n        id: 'view-details',\n        label: 'View Details',\n        icon: React.createElement(Info, { className: 'h-4 w-4' }),\n        action: () => handleResourceAction('view-details', resource),\n      },\n      {\n        id: 'resource-actions',\n        label: 'Resource Actions',\n        icon: React.createElement(MoreHorizontal, { className: 'h-4 w-4' }),\n        action: () => {}, // No-op action for parent menu\n        children: [\n          {\n            id: 'scan-deposits',\n            label: 'Scan for Deposits',\n            icon: React.createElement(Search, { className: 'h-4 w-4' }),\n            action: () => handleResourceAction('scan-deposits', resource),\n          },\n          {\n            id: 'analyze-composition',\n            label: 'Analyze Composition',\n            icon: React.createElement(Microscope, { className: 'h-4 w-4' }),\n            action: () => handleResourceAction('analyze-composition', resource),\n          },\n          {\n            id: 'mark-extraction',\n            label: 'Mark for Extraction',\n            icon: React.createElement(Target, { className: 'h-4 w-4' }),\n            action: () => handleResourceAction('mark-extraction', resource),\n          },\n        ],\n      },\n    ];\n  };\n\n  // Handle resource drop on storage\n  const handleResourceDrop = (\n    item: DragItem<ResourceDragData>,\n    _storage: (typeof mockStorageData)[0]\n  ) => {\n    if (item?.type === 'resource') {\n      // Create a properly typed drag data object\n      const resourceData = createDragData('resource', item?.data as unknown as BaseDragDataInput);\n\n      // Handle resource transfer\n      console.warn(`Transferring ${(resourceData as ResourceDragData).type} resource to storage`);\n    }\n  };\n\n  const toggleViewMode = () => {\n    const newMode: ViewMode = viewMode === 'map' ? 'grid' : 'map';\n    handleViewChange(newMode);\n    console.warn(`View mode changed to: ${newMode}`);\n  };\n\n  const toggleSortDirection = () => {\n    setSortOrder(prev => (prev === 'asc' ? 'desc' : 'asc'));\n  };\n\n  // Toggle settings panel visibility\n  const toggleSettings = () => {\n    setShowSettings(prev => !prev);\n  };\n\n  // Context menu handler for resources\n  const handleContextMenuEvent = (e: React.MouseEvent, resource: Resource) => {\n    e.preventDefault();\n    // Set the context menu items based on the resource\n    setContextMenuItems(getResourceMenuItems(resource));\n    // Show the context menu at the event position\n    handleContextMenu(e);\n  };\n\n  // Close context menu when clicking on a resource action\n  const handleResourceAction = (action: string, resource: Resource) => {\n    // Close the context menu first\n    closeContextMenu();\n\n    // Then perform the action\n    switch (action) {\n      case 'prioritize':\n        console.warn(`Prioritizing resource: ${resource.name}`);\n        break;\n      case 'assign-ship':\n        console.warn(`Assigning ship to resource: ${resource.name}`);\n        break;\n      case 'set-thresholds':\n        console.warn(`Setting thresholds for resource: ${resource.name}`);\n        break;\n      case 'view-details':\n        setSelectedNode(resource);\n        break;\n      case 'scan-deposits':\n        console.warn(`Scanning for deposits around resource: ${resource.name}`);\n        break;\n      case 'analyze-composition':\n        console.warn(`Analyzing composition of resource: ${resource.name}`);\n        break;\n      case 'mark-extraction':\n        console.warn(`Marking resource for extraction: ${resource.name}`);\n        break;\n      default:\n        console.warn(`Unknown action: ${action}`);\n    }\n  };\n\n  // Add this to the render section where appropriate, after the filter dropdown and before the view mode toggle\n  const renderSearchAndControls = () => {\n    return React.createElement(\n      'div',\n      { className: 'mb-4 flex flex-wrap items-center gap-3' },\n      // Search box\n      React.createElement(\n        'div',\n        { className: 'relative w-64' },\n        React.createElement('input', {\n          ref: searchInputRef,\n          type: 'text',\n          placeholder: 'Search resources...',\n          className:\n            'w-full rounded-md border border-gray-700 bg-gray-800 px-4 py-2 pl-10 text-sm text-white',\n          value: searchQuery,\n          onChange: handleSearchChange,\n        }),\n        React.createElement(Search, {\n          className: 'absolute left-3 top-1/2 h-4 w-4 -translate-y-1/2 text-gray-400',\n        })\n      ),\n      // Mine All toggle\n      React.createElement(\n        'div',\n        { className: 'flex items-center space-x-2' },\n        React.createElement('span', { className: 'text-sm text-gray-300' }, 'Mine All'),\n        React.createElement(\n          'button',\n          {\n            className: `relative h-6 w-11 rounded-full ${\n              mineAll ? 'bg-blue-600' : 'bg-gray-700'\n            } transition-colors`,\n            onClick: handleMineAllToggle,\n          },\n          React.createElement('span', {\n            className: `absolute top-0.5 left-0.5 h-5 w-5 transform rounded-full bg-white transition-transform ${\n              mineAll ? 'translate-x-5' : ''\n            }`,\n          })\n        )\n      ),\n      // Tier selector\n      React.createElement(\n        'div',\n        { className: 'flex items-center space-x-2' },\n        React.createElement('span', { className: 'text-sm text-gray-300' }, 'Tier:'),\n        React.createElement(\n          'div',\n          { className: 'flex rounded-md bg-gray-800' },\n          [1, 2, 3].map(t =>\n            React.createElement(\n              'button',\n              {\n                key: `tier-${t}`,\n                className: `px-3 py-1 text-sm ${\n                  tier === t\n                    ? 'bg-blue-600 text-white'\n                    : 'bg-gray-800 text-gray-400 hover:bg-gray-700'\n                } ${t === 1 ? 'rounded-l-md' : ''} ${t === 3 ? 'rounded-r-md' : ''}`,\n                onClick: () => handleTierChange(t as 1 | 2 | 3),\n              },\n              `T${t}`\n            )\n          )\n        )\n      )\n    );\n  };\n\n  // Now add a call to this function in the main render\n  // Modify the existing render to include our new function where appropriate\n  // In the main return, where it makes sense to have search and mine all controls\n  // This should be inserted after the main header and before the resource listing\n  React.useEffect(() => {\n    // Apply the node selection when selectedNode changes\n    if (selectedNode) {\n      handleNodeSelect(selectedNode);\n    }\n  }, [selectedNode, handleNodeSelect]);\n\n  return React.createElement(\n    'div',\n    { className: 'h-full overflow-hidden rounded-lg border border-gray-700 bg-gray-800' },\n\n    // Add the context menu component\n    ContextMenuComponent,\n\n    React.createElement(\n      'div',\n      { className: 'flex h-full flex-col' },\n\n      React.createElement(\n        'div',\n        { className: 'mb-6 flex items-center justify-between' },\n        React.createElement(\n          'div',\n          { className: 'flex items-center space-x-4' },\n          React.createElement(\n            'h2',\n            { className: 'text-xl font-bold text-white' },\n            'Mineral Processing'\n          ),\n          React.createElement(\n            'button',\n            {\n              className: 'p-2 text-gray-400 hover:text-gray-300',\n              onClick: () => setShowTutorial(true),\n            },\n            React.createElement(HelpCircle, { className: 'h-5 w-5' })\n          )\n        ),\n        React.createElement(\n          'div',\n          { className: 'flex items-center space-x-4' },\n          // Filter dropdown\n          React.createElement(\n            'div',\n            { className: 'flex items-center' },\n            React.createElement(\n              'label',\n              { htmlFor: 'resource-filter', className: 'mr-2 text-sm text-gray-400' },\n              'Filter:'\n            ),\n            React.createElement(\n              'select',\n              {\n                id: 'resource-filter',\n                className: 'rounded bg-gray-700 px-2 py-1 text-sm text-white',\n                value: filterBy,\n                onChange: (e: React.ChangeEvent<HTMLSelectElement>) =>\n                  handleFilterChange(e.target.value as FilterOption),\n              },\n              React.createElement('option', { value: 'all' }, 'All Resources'),\n              React.createElement('option', { value: 'mineral' }, 'Minerals'),\n              React.createElement('option', { value: ResourceType.GAS }, 'Gas'),\n              React.createElement('option', { value: ResourceType.EXOTIC }, 'Exotic')\n            )\n          ),\n          // View mode toggle\n          React.createElement(\n            'button',\n            {\n              className: 'rounded bg-blue-600 px-3 py-1 text-sm text-white hover:bg-blue-700',\n              onClick: toggleViewMode,\n            },\n            viewMode === 'map' ? 'Grid View' : 'Map View'\n          ),\n          // Settings button\n          React.createElement(\n            'button',\n            {\n              className: 'rounded bg-gray-700 px-3 py-1 text-sm text-white hover:bg-gray-600',\n              onClick: toggleSettings,\n              title: 'Mining Settings',\n            },\n            React.createElement(Settings, { className: 'h-4 w-4' })\n          )\n        )\n      ),\n\n      // Insert the search, mine all, and tier controls\n      renderSearchAndControls(),\n\n      React.createElement(\n        'div',\n        { className: 'mb-4 flex items-center space-x-4' },\n        React.createElement(\n          'select',\n          {\n            className:\n              'rounded-md border border-gray-700 bg-gray-800 px-3 py-1 text-sm text-gray-300',\n            value: sortBy,\n            onChange: (e: React.ChangeEvent<HTMLSelectElement>) =>\n              handleSortChange(e.target.value as SortOption),\n          },\n          React.createElement('option', { value: 'priority' }, 'Sort by Priority'),\n          React.createElement('option', { value: 'name' }, 'Sort by Name'),\n          React.createElement('option', { value: 'type' }, 'Sort by Type'),\n          React.createElement('option', { value: 'abundance' }, 'Sort by Abundance'),\n          React.createElement('option', { value: 'distance' }, 'Sort by Distance')\n        ),\n        React.createElement(\n          'button',\n          {\n            className:\n              'rounded-md border border-gray-700 bg-gray-800 px-3 py-1 text-sm text-gray-300',\n            onClick: toggleSortDirection,\n          },\n          sortOrder === 'asc'\n            ? React.createElement(ArrowUp, { className: 'h-4 w-4' })\n            : React.createElement(ArrowDown, { className: 'h-4 w-4' })\n        )\n      ),\n\n      viewMode === 'map' &&\n        React.createElement(\n          React.Fragment,\n          null,\n          React.createElement(MiningMap, {\n            resources: filteredResources.map(r => convertToMiningResource(r)),\n            selectedNode: selectedNode ? convertToMiningResource(selectedNode) : null,\n            onSelectNode: (resource: MiningResource) => {\n              const converted = convertToResource(resource);\n              setSelectedNode(converted);\n            },\n            techBonuses: techBonuses,\n            ships: mockShips,\n            quality: 'high',\n          }),\n          React.createElement(ResourceTransfer, { transfers: mockTransfers })\n        ),\n\n      viewMode === 'grid' &&\n        React.createElement(\n          'div',\n          { className: 'grid flex-1 grid-cols-2 gap-4 overflow-y-auto' },\n          filteredResources\n            .sort((a, b) => {\n              let comparison = 0;\n              switch (sortBy) {\n                case 'priority':\n                  comparison = a.priority - b.priority;\n                  break;\n                case 'name':\n                  comparison = a.name.localeCompare(b.name);\n                  break;\n                case 'type':\n                  comparison = a.type.localeCompare(b.type);\n                  break;\n                case 'abundance':\n                  comparison = b.abundance - a.abundance;\n                  break;\n                case 'distance':\n                  comparison = a.distance - b.distance;\n                  break;\n              }\n              return sortOrder === 'asc' ? comparison : -comparison;\n            })\n            .map(resource => {\n              return React.createElement(\n                'div',\n                { key: resource.id },\n                React.createElement(Draggable, {\n                  item: {\n                    id: resource.id,\n                    type: 'resource',\n                    data: resource,\n                  },\n                  onDragStart: () => console.warn('Drag started', resource.id),\n                  onDragEnd: () => console.warn('Drag ended', resource.id),\n                  children: React.createElement(\n                    'div',\n                    { onContextMenu: e => handleContextMenuEvent(e, resource) },\n                    React.createElement(ResourceNode, {\n                      resource: resource,\n                      isSelected: selectedNode?.id === resource.id,\n                      techBonuses: techBonuses,\n                      onClick: () => setSelectedNode(resource as Resource),\n                      assignedShip:\n                        mockShips.find(ship => ship.targetNode === resource.id)?.id ?? '',\n                    })\n                  ),\n                })\n              );\n            })\n        ),\n\n      React.createElement(\n        'div',\n        { className: 'mt-4 grid grid-cols-2 gap-4' },\n        React.createElement(DropTarget, {\n          accept: ['resource'],\n          onDrop: (item: DragItem<unknown>) =>\n            handleResourceDrop(item as DragItem<ResourceDragData>, mockStorageData[0]),\n          className: 'rounded-lg border-2 border-dashed border-gray-700 p-4',\n          children: React.createElement(ResourceStorage, { storageData: mockStorageData }),\n        })\n      ),\n\n      React.createElement(\n        'div',\n        { className: 'mt-4' },\n        React.createElement(\n          'h3',\n          { className: 'mb-3 text-lg font-medium text-white' },\n          'Mining Fleet'\n        ),\n        React.createElement(\n          'div',\n          { className: 'grid grid-cols-2 gap-4' },\n          mockShips.map(ship => {\n            const assignedResource = mockResources.find(r => r.id === ship.targetNode);\n\n            return React.createElement(\n              'div',\n              { key: ship.id },\n              React.createElement(Draggable, {\n                item: {\n                  id: ship.id,\n                  type: 'ship',\n                  data: ship,\n                },\n                onDragStart: () => console.warn('Drag started', ship.id),\n                onDragEnd: () => console.warn('Drag ended', ship.id),\n                children: React.createElement(\n                  'div',\n                  { className: 'rounded-lg bg-gray-800 p-4' },\n                  React.createElement(\n                    'div',\n                    { className: 'mb-2 flex items-center justify-between' },\n                    React.createElement(\n                      'div',\n                      { className: 'flex items-center space-x-2' },\n                      React.createElement(Ship, { className: 'h-4 w-4 text-cyan-400' }),\n                      React.createElement(\n                        'span',\n                        { className: 'font-medium text-gray-200' },\n                        ship.name\n                      )\n                    ),\n                    React.createElement(\n                      'span',\n                      {\n                        className: `rounded-full px-2 py-0.5 text-xs ${\n                          ship.status === 'mining'\n                            ? 'bg-green-900/50 text-green-400'\n                            : ship.status === 'returning'\n                              ? 'bg-blue-900/50 text-blue-400'\n                              : 'bg-gray-900/50 text-gray-400'\n                        }`,\n                      },\n                      ship.status\n                    )\n                  ),\n                  React.createElement(\n                    'div',\n                    { className: 'text-sm text-gray-400' },\n                    assignedResource\n                      ? React.createElement(React.Fragment, null, 'Mining: ', assignedResource.name)\n                      : React.createElement(React.Fragment, null, 'No assignment')\n                  ),\n                  React.createElement(\n                    'div',\n                    { className: 'mt-2 text-xs text-gray-500' },\n                    `Capacity: ${ship.currentLoad}/${ship.capacity} â€¢ Efficiency: ${Math.round(ship.efficiency * 100)}%`\n                  )\n                ),\n              })\n            );\n          })\n        )\n      ),\n\n      showTutorial &&\n        React.createElement(MiningTutorial, { onClose: () => setShowTutorial(false) }),\n\n      // Settings panel (conditionally rendered)\n      showSettings &&\n        React.createElement(\n          'div',\n          { className: 'border-b border-gray-700 bg-gray-800 p-4' },\n          React.createElement(\n            'h3',\n            { className: 'mb-2 text-lg font-semibold text-white' },\n            'Mining Settings'\n          ),\n          React.createElement(\n            'div',\n            { className: 'grid grid-cols-2 gap-4' },\n\n            // Auto-assign setting\n            React.createElement(\n              'div',\n              { className: 'flex items-center' },\n              React.createElement('input', {\n                type: 'checkbox',\n                id: 'autoAssign',\n                className: 'mr-2 h-4 w-4',\n              }),\n              React.createElement(\n                'label',\n                { htmlFor: 'autoAssign', className: 'text-white' },\n                'Auto-assign ships to nodes'\n              )\n            ),\n\n            // Prioritize setting\n            React.createElement(\n              'div',\n              { className: 'flex items-center' },\n              React.createElement('input', {\n                type: 'checkbox',\n                id: 'prioritizeExotic',\n                className: 'mr-2 h-4 w-4',\n              }),\n              React.createElement(\n                'label',\n                { htmlFor: 'prioritizeExotic', className: 'text-white' },\n                'Prioritize exotic resources'\n              )\n            ),\n\n            // Extraction rate slider\n            React.createElement(\n              'div',\n              { className: 'col-span-2' },\n              React.createElement(\n                'label',\n                { htmlFor: 'extractionRate', className: 'block text-white' },\n                'Default Extraction Rate'\n              ),\n              React.createElement('input', {\n                type: 'range',\n                id: 'extractionRate',\n                min: '1',\n                max: '10',\n                className: 'mt-1 w-full',\n              })\n            )\n          )\n        )\n    )\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/MiningHub/ResourceNode.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/MiningHub/ResourceStorage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/MiningHub/ResourceTransfer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/MiningHub/TechBonus.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/MiningHub/ThresholdManager.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/MiningHub/ThresholdPresetsPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/MiningHub/ThresholdStatusIndicator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/academy/HiringPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/academy/OfficerAcademy.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/academy/OfficerCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/academy/OfficerDetails.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/hangar/HangarModule.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/hangar/ShipBuildingInterface.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/hangar/ShipHangar.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_mockShips' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":74,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":74,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as React from 'react';\nimport { useEffect, useState } from 'react';\nimport ResourceVisualization from '../../../../components/ui/ResourceVisualization';\nimport {\n  Ship,\n  ShipHangarManager,\n  ShipStatus,\n  ShipType,\n} from '../../../../managers/ships/ShipHangarManager';\nimport { Effect } from '../../../../types/core/GameTypes';\nimport { WeaponCategory, WeaponStatus } from '../../../../types/weapons/WeaponTypes';\nimport { ResourceType } from './../../../../types/resources/ResourceTypes';\n\ninterface HangarWeaponSystem {\n  id: string;\n  name: string;\n  damage: number;\n  range: number;\n  cooldown: number;\n  type: WeaponCategory;\n  status: WeaponStatus;\n}\n\n// Extended Ability interface with id\ninterface ShipAbility {\n  id: string;\n  name: string;\n  description: string;\n  cooldown: number;\n  duration: number;\n  effect: Effect;\n  active: boolean;\n}\n\n// Custom ship interface for UI purposes\ninterface CustomShip {\n  id: string;\n  name: string;\n  type: string; // Using string to allow for custom ship types in the UI\n  level: number;\n  health: number;\n  maxHealth: number;\n  fuel: number;\n  maxFuel: number;\n  crew: number;\n  maxCrew: number;\n  status: string; // Using string to allow for custom statuses in the UI\n  location?: string;\n  destination?: string;\n  cargo?: {\n    capacity: number;\n    resources: Map<ResourceType, number>;\n  };\n  weapons?: HangarWeaponSystem[];\n  shields?: number;\n  maxShields?: number;\n  speed?: number;\n  range?: number;\n  description?: string;\n  image?: string;\n  effects?: Effect[];\n  isSelected?: boolean;\n  // Additional UI properties\n  tier?: number;\n  hull?: number;\n  maxHull?: number;\n  shield?: number;\n  maxShield?: number;\n  abilities?: ShipAbility[];\n  alerts?: string[];\n}\n\n// Mock data for development and testing purposes\nconst _mockShips: CustomShip[] = [\n  {\n    id: '1',\n    name: 'Spitfire Alpha',\n    type: ShipType.FIGHTER,\n    tier: 1,\n    status: ShipStatus.DOCKED,\n    hull: 100,\n    maxHull: 100,\n    shield: 50,\n    maxShield: 50,\n    weapons: [\n      {\n        id: '1',\n        name: 'Laser Cannon',\n        damage: 10,\n        range: 5,\n        cooldown: 2,\n        type: 'beamWeapon',\n        status: 'ready',\n      },\n    ],\n    abilities: [\n      {\n        id: '1',\n        name: 'Boost',\n        description: 'Increases speed by 50% for 5 seconds',\n        cooldown: 10,\n        duration: 5,\n        active: false,\n        effect: {\n          id: 'boost-effect',\n          type: 'speed',\n          duration: 5,\n          magnitude: 1.5,\n        },\n      },\n    ],\n    alerts: ['Low fuel', 'Shield damaged'],\n    level: 1,\n    health: 100,\n    maxHealth: 100,\n    fuel: 50,\n    maxFuel: 100,\n    crew: 5,\n    maxCrew: 5,\n    cargo: {\n      resources: new Map([\n        [ResourceType.IRON, 10],\n        [ResourceType.COPPER, 5],\n      ]),\n      capacity: 100,\n    },\n  },\n  {\n    id: '2',\n    name: 'Star Voyager',\n    type: ShipType.CRUISER,\n    tier: 2,\n    status: ShipStatus.DEPLOYED,\n    hull: 80,\n    maxHull: 150,\n    shield: 30,\n    maxShield: 100,\n    weapons: [\n      {\n        id: '1',\n        name: 'Plasma Cannon',\n        damage: 20,\n        range: 8,\n        cooldown: 3,\n        type: 'plasmaCannon',\n        status: 'charging',\n      },\n      {\n        id: '2',\n        name: 'Missile Launcher',\n        damage: 30,\n        range: 10,\n        cooldown: 5,\n        type: 'rockets',\n        status: 'ready',\n      },\n    ],\n    abilities: [\n      {\n        id: '1',\n        name: 'Shield Boost',\n        description: 'Regenerates shields by 20%',\n        cooldown: 15,\n        duration: 0,\n        active: false,\n        effect: {\n          id: 'shield-boost-effect',\n          type: 'shield',\n          duration: 0,\n          magnitude: 0.2,\n        },\n      },\n    ],\n    level: 2,\n    health: 80,\n    maxHealth: 150,\n    fuel: 70,\n    maxFuel: 150,\n    crew: 15,\n    maxCrew: 20,\n    cargo: {\n      resources: new Map([\n        [ResourceType.TITANIUM, 20],\n        [ResourceType.URANIUM, 5],\n      ]),\n      capacity: 200,\n    },\n    destination: 'Alpha Centauri',\n  },\n];\n\ninterface ShipHangarProps {\n  hangarId: string;\n  capacity?: number;\n}\n\n/**\n * ShipHangar Component\n *\n * This component demonstrates how to use the ShipHangarManager with the standardized event system.\n */\nconst ShipHangar: React.FC<ShipHangarProps> = ({ hangarId, capacity = 10 }) => {\n  // Create a state to store the ships\n  const [ships, setShips] = useState<CustomShip[]>([]);\n  // Create a state to store the selected ship\n  const [selectedShip, setSelectedShip] = useState<CustomShip | null>(null);\n  // Create a state to store the hangar manager\n  const [hangarManager] = useState(() => new ShipHangarManager(hangarId, capacity));\n  // Create a state to track if the component is mounted\n  const [isMounted, setIsMounted] = useState(false);\n\n  // Initialize the component\n  useEffect(() => {\n    setIsMounted(true);\n\n    // Subscribe to events\n    const shipAddedUnsubscribe = hangarManager.on('ship:added', ({ ship }) => {\n      if (isMounted) {\n        setShips(prevShips => [...prevShips, toCustomShip(ship)]);\n      }\n    });\n\n    const shipRemovedUnsubscribe = hangarManager.on('ship:removed', ({ shipId }) => {\n      if (isMounted) {\n        setShips(prevShips => prevShips.filter(ship => ship.id !== shipId));\n        if (selectedShip && selectedShip.id === shipId) {\n          setSelectedShip(null);\n        }\n      }\n    });\n\n    const shipUpdatedUnsubscribe = hangarManager.on('ship:updated', ({ ship }) => {\n      if (isMounted) {\n        setShips(prevShips => prevShips.map(s => (s.id === ship.id ? toCustomShip(ship) : s)));\n        if (selectedShip && selectedShip.id === ship.id) {\n          setSelectedShip(ship);\n        }\n      }\n    });\n\n    // Add some sample ships\n    const scout = hangarManager.createShip('Scout Alpha', ShipType.SCOUT);\n    const fighter = hangarManager.createShip('Fighter Beta', ShipType.FIGHTER);\n    const cruiser = hangarManager.createShip('Cruiser Gamma', ShipType.CRUISER);\n\n    hangarManager.addShip(scout);\n    hangarManager.addShip(fighter);\n    hangarManager.addShip(cruiser);\n\n    // Load some cargo onto the cruiser\n    if (cruiser.cargo) {\n      hangarManager.loadCargo(cruiser.id, ResourceType.MINERALS, 50);\n      hangarManager.loadCargo(cruiser.id, ResourceType.ENERGY, 25);\n    }\n\n    // Cleanup function\n    return () => {\n      shipAddedUnsubscribe();\n      shipRemovedUnsubscribe();\n      shipUpdatedUnsubscribe();\n      setIsMounted(false);\n    };\n  }, [hangarId, capacity, hangarManager, isMounted]);\n\n  // Handle ship selection\n  const handleSelectShip = (ship: CustomShip) => {\n    setSelectedShip(ship);\n  };\n\n  // Handle ship deployment\n  const handleDeployShip = () => {\n    if (selectedShip) {\n      const destination = prompt('Enter destination:');\n      if (destination) {\n        hangarManager.deployShip(toShip(selectedShip).id, destination);\n      }\n    }\n  };\n\n  // Handle ship docking\n  const handleDockShip = () => {\n    if (selectedShip) {\n      hangarManager.dockShip(toShip(selectedShip).id);\n    }\n  };\n\n  // Handle ship repair\n  const handleRepairShip = () => {\n    if (selectedShip) {\n      hangarManager.repairShip(toShip(selectedShip).id, 10);\n    }\n  };\n\n  // Handle ship refueling\n  const handleRefuelShip = () => {\n    if (selectedShip) {\n      hangarManager.refuelShip(toShip(selectedShip).id, 10);\n    }\n  };\n\n  // Handle ship upgrade\n  const handleUpgradeShip = () => {\n    if (selectedShip) {\n      hangarManager.upgradeShip(toShip(selectedShip).id);\n    }\n  };\n\n  // Handle ship removal\n  const handleRemoveShip = () => {\n    if (selectedShip) {\n      if (window.confirm(`Are you sure you want to remove ${selectedShip.name}?`)) {\n        hangarManager.removeShip(toShip(selectedShip).id);\n      }\n    }\n  };\n\n  // Handle creating a new ship\n  const handleCreateShip = () => {\n    const name = prompt('Enter ship name:');\n    if (!name) return;\n\n    const typeOptions = Object.values(ShipType);\n    const typeIndex = parseInt(\n      prompt(\n        `Enter ship type (0-${typeOptions.length - 1}):\\n${typeOptions.map((type, index) => `${index}: ${type}`).join('\\n')}`\n      ) || '0'\n    );\n    const type = typeOptions[typeIndex] || ShipType.SCOUT;\n\n    const newShip = hangarManager.createShip(name, type as ShipType);\n    hangarManager.addShip(newShip);\n  };\n\n  // Convert between Ship and CustomShip\n  const toCustomShip = (ship: Ship): CustomShip => {\n    return {\n      ...ship,\n      // Add any additional UI-specific properties\n      weapons: [],\n      shields: 100,\n      maxShields: 100,\n      speed: 10,\n      range: 5,\n      description: 'A standard ship',\n      image: '',\n      effects: [],\n      isSelected: false,\n    };\n  };\n\n  const toShip = (customShip: CustomShip): Ship => {\n    return {\n      id: customShip.id,\n      name: customShip.name,\n      type: customShip.type as unknown as ShipType, // Convert string to ShipType\n      level: customShip.level,\n      health: customShip.health,\n      maxHealth: customShip.maxHealth,\n      fuel: customShip.fuel,\n      maxFuel: customShip.maxFuel,\n      crew: customShip.crew,\n      maxCrew: customShip.maxCrew,\n      status: customShip.status as unknown as ShipStatus, // Convert string to ShipStatus\n      location: customShip.location,\n      destination: customShip.destination,\n      cargo: customShip.cargo,\n    };\n  };\n\n  // Update the status comparisons\n  const getStatusColor = (status: string) => {\n    if (status === ShipStatus.DOCKED) return 'bg-green-500';\n    if (status === ShipStatus.DEPLOYED) return 'bg-blue-500';\n    if (status === ShipStatus.DAMAGED) return 'bg-red-500';\n    if (status === ShipStatus.REPAIRING) return 'bg-yellow-500';\n    if (status === ShipStatus.REFUELING) return 'bg-purple-500';\n    if (status === ShipStatus.UPGRADING) return 'bg-indigo-500';\n    return 'bg-gray-500';\n  };\n\n  // Render the component\n  return (\n    <div className=\"ship-hangar rounded-lg bg-gray-800 p-4 text-white\">\n      <div className=\"mb-4 flex items-center justify-between\">\n        <h2 className=\"text-xl font-bold\">Ship Hangar: {hangarId}</h2>\n        <div className=\"text-sm\">\n          Ships: {ships.length} / {hangarManager.getCapacity()}\n        </div>\n      </div>\n\n      <div className=\"grid grid-cols-1 gap-4 md:grid-cols-3\">\n        {/* Ship List */}\n        <div className=\"col-span-1 rounded bg-gray-700 p-3\">\n          <h3 className=\"mb-2 text-lg font-semibold\">Ships</h3>\n          <div className=\"max-h-80 space-y-2 overflow-y-auto\">\n            {ships.map(ship => (\n              <div\n                key={ship.id}\n                className={`cursor-pointer rounded p-2 ${selectedShip?.id === ship.id ? 'bg-blue-600' : 'bg-gray-600 hover:bg-gray-500'}`}\n                onClick={() => handleSelectShip(ship)}\n              >\n                <div className=\"font-medium\">{ship.name}</div>\n                <div className=\"flex justify-between text-xs\">\n                  <span>{ship.type}</span>\n                  <span>Level {ship.level}</span>\n                </div>\n                <div className=\"flex justify-between text-xs\">\n                  <span className={getStatusColor(ship.status)}>{ship.status}</span>\n                  {ship.destination && <span>â†’ {ship.destination}</span>}\n                </div>\n              </div>\n            ))}\n          </div>\n          <button\n            className=\"mt-2 w-full rounded bg-green-600 py-1 hover:bg-green-500\"\n            onClick={handleCreateShip}\n          >\n            Create New Ship\n          </button>\n        </div>\n\n        {/* Ship Details */}\n        <div className=\"col-span-2 rounded bg-gray-700 p-3\">\n          {selectedShip ? (\n            <div>\n              <h3 className=\"mb-2 text-lg font-semibold\">{selectedShip.name}</h3>\n\n              <div className=\"mb-4 grid grid-cols-2 gap-2\">\n                <div className=\"rounded bg-gray-600 p-2\">\n                  <div className=\"text-xs text-gray-400\">Type</div>\n                  <div>{selectedShip.type}</div>\n                </div>\n                <div className=\"rounded bg-gray-600 p-2\">\n                  <div className=\"text-xs text-gray-400\">Level</div>\n                  <div>{selectedShip.level}</div>\n                </div>\n                <div className=\"rounded bg-gray-600 p-2\">\n                  <div className=\"text-xs text-gray-400\">Health</div>\n                  <div className=\"flex items-center\">\n                    <div className=\"mr-2 h-2.5 w-full rounded-full bg-gray-300\">\n                      <div\n                        className={`h-2.5 rounded-full ${selectedShip.health === 0 ? 'bg-red-600' : 'bg-green-600'}`}\n                        style={{\n                          width: `${(selectedShip.health / selectedShip.maxHealth) * 100}%`,\n                        }}\n                      ></div>\n                    </div>\n                    <span>\n                      {selectedShip.health} / {selectedShip.maxHealth}\n                    </span>\n                  </div>\n                </div>\n                <div className=\"rounded bg-gray-600 p-2\">\n                  <div className=\"text-xs text-gray-400\">Fuel</div>\n                  <div className=\"flex items-center\">\n                    <div className=\"mr-2 h-2.5 w-full rounded-full bg-gray-300\">\n                      <div\n                        className=\"h-2.5 rounded-full bg-yellow-400\"\n                        style={{ width: `${(selectedShip.fuel / selectedShip.maxFuel) * 100}%` }}\n                      ></div>\n                    </div>\n                    <span>\n                      {selectedShip.fuel} / {selectedShip.maxFuel}\n                    </span>\n                  </div>\n                </div>\n                <div className=\"rounded bg-gray-600 p-2\">\n                  <div className=\"text-xs text-gray-400\">Crew</div>\n                  <div>\n                    {selectedShip.crew} / {selectedShip.maxCrew}\n                  </div>\n                </div>\n                <div className=\"rounded bg-gray-600 p-2\">\n                  <div className=\"text-xs text-gray-400\">Status</div>\n                  <div>{selectedShip.status}</div>\n                </div>\n              </div>\n\n              {/* Cargo Section */}\n              {selectedShip.cargo && (\n                <div className=\"mb-4\">\n                  <h4 className=\"mb-1 font-medium\">Cargo</h4>\n                  <div className=\"rounded bg-gray-600 p-2\">\n                    <div className=\"mb-1 text-xs text-gray-400\">\n                      Capacity:{' '}\n                      {Array.from(selectedShip.cargo.resources.values()).reduce(\n                        (sum, amount) => sum + amount,\n                        0\n                      )}{' '}\n                      / {selectedShip.cargo.capacity}\n                    </div>\n                    <div className=\"space-y-1\">\n                      {Array.from(selectedShip.cargo.resources.entries()).map(\n                        ([resourceType, amount]) => (\n                          <div key={resourceType.toString()} className=\"flex items-center\">\n                            <ResourceVisualization type={resourceType} value={amount} />\n                          </div>\n                        )\n                      )}\n                      {selectedShip.cargo.resources.size === 0 && (\n                        <div className=\"text-sm text-gray-400\">No cargo</div>\n                      )}\n                    </div>\n                  </div>\n                </div>\n              )}\n\n              {/* Action Buttons */}\n              <div className=\"grid grid-cols-2 gap-2\">\n                {selectedShip.status === ShipStatus.DOCKED && (\n                  <button\n                    className=\"rounded bg-blue-600 py-1 hover:bg-blue-500\"\n                    onClick={handleDeployShip}\n                  >\n                    Deploy\n                  </button>\n                )}\n                {selectedShip.status === ShipStatus.DEPLOYED && (\n                  <button\n                    className=\"rounded bg-blue-600 py-1 hover:bg-blue-500\"\n                    onClick={handleDockShip}\n                  >\n                    Dock\n                  </button>\n                )}\n                <button\n                  className=\"rounded bg-green-600 py-1 hover:bg-green-500\"\n                  onClick={handleRepairShip}\n                  disabled={selectedShip.health === selectedShip.maxHealth}\n                >\n                  Repair\n                </button>\n                <button\n                  className=\"rounded bg-yellow-600 py-1 hover:bg-yellow-500\"\n                  onClick={handleRefuelShip}\n                  disabled={selectedShip.fuel === selectedShip.maxFuel}\n                >\n                  Refuel\n                </button>\n                <button\n                  className=\"rounded bg-purple-600 py-1 hover:bg-purple-500\"\n                  onClick={handleUpgradeShip}\n                >\n                  Upgrade\n                </button>\n                <button\n                  className=\"rounded bg-red-600 py-1 hover:bg-red-500\"\n                  onClick={handleRemoveShip}\n                >\n                  Remove\n                </button>\n              </div>\n            </div>\n          ) : (\n            <div className=\"py-8 text-center text-gray-400\">Select a ship to view details</div>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default ShipHangar;\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/radar/RadarModule.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/modules/trading/TradingHub.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/buildings/mothership/MothershipCore.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/combat/BattleEnvironment.tsx","messages":[{"ruleId":"no-unsafe-optional-chaining","severity":2,"message":"Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.","line":473,"column":20,"nodeType":"ChainExpression","messageId":"unsafeOptionalChain","endLine":473,"endColumn":41},{"ruleId":"no-unsafe-optional-chaining","severity":2,"message":"Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.","line":474,"column":20,"nodeType":"ChainExpression","messageId":"unsafeOptionalChain","endLine":474,"endColumn":41}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { AlertTriangle, Shield, Zap } from 'lucide-react';\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { CombatAutomationEffect } from '../../effects/component_effects/CombatAutomationEffect';\nimport { useFleetAI } from '../../hooks/factions/useFleetAI';\nimport { useGlobalEvents } from '../../hooks/game/useGlobalEvents';\nimport { useVPR } from '../../hooks/ui/useVPR';\nimport { ModuleEvent, moduleEventBus } from '../../lib/modules/ModuleEvents';\nimport { Position } from '../../types/core/GameTypes';\nimport { FactionId } from '../../types/ships/FactionTypes';\n\ninterface HazardVPR {\n  type: Hazard['type'];\n  severity: Hazard['severity'];\n  effectType: Hazard['effect']['type'];\n  visualTier: 1 | 2 | 3;\n  animationSet: {\n    idle: string;\n    active: string;\n    impact: string;\n  };\n  particleSystem: {\n    density: number;\n    color: string;\n    pattern: 'circular' | 'radial' | 'directed';\n  };\n}\n\ninterface Hazard {\n  id: string;\n  type: 'asteroids' | 'debris' | 'radiation' | 'anomaly';\n  position: { x: number; y: number };\n  radius: number;\n  severity: 'low' | 'medium' | 'high';\n  effect: {\n    type: 'damage' | 'slow' | 'shield' | 'weapon';\n    value: number;\n  };\n  movement?: {\n    speed: number;\n    direction: number;\n  };\n  particles?: number;\n  vpr?: HazardVPR;\n}\n\ninterface TechBonuses {\n  hazardResistance: number;\n  detectionRange: number;\n  effectPotency: number;\n}\n\ninterface CombatUnit {\n  id: string;\n  type:\n    | 'spitflare'\n    | 'starSchooner'\n    | 'orionFrigate'\n    | 'harbringerGalleon'\n    | 'midwayCarrier'\n    | 'motherEarthRevenge';\n  tier: 1 | 2 | 3;\n  position: { x: number; y: number };\n  status: 'idle' | 'patrolling' | 'engaging' | 'returning' | 'damaged';\n  health: number;\n  maxHealth: number;\n  shield: number;\n  maxShield: number;\n  weapons: WeaponSystem[];\n}\n\ninterface WeaponSystem {\n  id: string;\n  type: 'machineGun' | 'gaussCannon' | 'railGun' | 'mgss' | 'rockets';\n  damage: number;\n  range: number;\n  cooldown: number;\n  status: 'ready' | 'charging' | 'cooling';\n  upgrades?: {\n    name: string;\n    description: string;\n    unlocked: boolean;\n  }[];\n}\n\ninterface BattleEnvironmentProps {\n  hazards: Hazard[];\n  units: CombatUnit[];\n  fleetId: string;\n  factionId: FactionId;\n  onHazardEffect: (hazardId: string, shipId: string, effect: Hazard['effect']) => void;\n  onWeaponFire: (weaponId: string, targetId: string) => void;\n  onUnitMove: (unitId: string, position: { x: number; y: number }) => void;\n  quality: 'low' | 'medium' | 'high';\n  tier: 1 | 2 | 3;\n  techBonuses?: TechBonuses;\n  onThreatDetected?: (hazard: Hazard) => void;\n}\n\ninterface FormationLines {\n  points: Array<{ x: number; y: number }>;\n  style: 'solid' | 'dashed';\n  color: string;\n  opacity: number;\n}\n\ninterface RangeCircle {\n  center: { x: number; y: number };\n  radius: number;\n  type: 'engagement' | 'support';\n  opacity: number;\n}\n\n// Interface for AI fleet behavior results - kept for future implementation of advanced fleet AI\n// Will be used when implementing the adaptive fleet behavior system\ninterface __FleetAIResult {\n  formationPatterns: {\n    defensive: {\n      spacing: number;\n      facing: number;\n      pattern: 'defensive';\n      adaptiveSpacing: boolean;\n    };\n    offensive: {\n      spacing: number;\n      facing: number;\n      pattern: 'offensive';\n      adaptiveSpacing: boolean;\n    };\n    balanced: {\n      spacing: number;\n      facing: number;\n      pattern: 'balanced';\n      adaptiveSpacing: boolean;\n    };\n  };\n  adaptiveAI: {\n    experienceLevel: number;\n    performance: {\n      damageEfficiency: number;\n      survivalRate: number;\n    };\n  };\n  factionBehavior: {\n    aggressionLevel: number;\n    territorialControl: {\n      facing: number;\n    };\n  };\n  visualFeedback?: {\n    formationLines: FormationLines;\n    rangeCircles: RangeCircle[];\n  };\n}\n\nexport function BattleEnvironment({\n  hazards,\n  units,\n  fleetId,\n  factionId,\n  onHazardEffect,\n  onWeaponFire,\n  onUnitMove,\n  quality,\n  tier,\n  techBonuses = { hazardResistance: 1, detectionRange: 1, effectPotency: 1 },\n  onThreatDetected,\n}: BattleEnvironmentProps) {\n  // Use refs for mutable state that doesn't need re-renders\n  const activeHazardsRef = useRef(hazards);\n  const particlePositionsRef = useRef<Record<string, Array<{ x: number; y: number }>>>({});\n  const weaponEffectsRef = useRef<Record<string, { active: boolean; type: string }>>({});\n\n  // State that needs re-renders\n  const [impactAnimations, setImpactAnimations] = useState<Record<string, boolean>>({});\n  const [automationEffects, setAutomationEffects] = useState<\n    Array<{\n      id: string;\n      type: 'formation' | 'engagement' | 'repair' | 'shield' | 'attack' | 'retreat';\n      position: Position;\n      timestamp: number;\n    }>\n  >([]);\n\n  // Memoize event handlers\n  const { emitEvent } = useGlobalEvents();\n  const { getVPRAnimationSet } = useVPR();\n  const fleetAIResult = useFleetAI(fleetId, factionId);\n\n  // Memoize fleet AI result\n  const fleetAI = useMemo(\n    () => ({\n      formationPatterns: fleetAIResult.formationPatterns,\n      adaptiveAI: fleetAIResult.adaptiveAI,\n      factionBehavior: {\n        aggressionLevel: fleetAIResult.factionBehavior.behaviorState.aggression,\n        territorialControl: {\n          facing: fleetAIResult.factionBehavior.territory.center.x ?? 0,\n        },\n      },\n      visualFeedback: {\n        formationLines: {\n          points: [],\n          style: 'solid' as 'solid' | 'dashed',\n          color: '#fff',\n          opacity: 0.5,\n        },\n        rangeCircles: [],\n      },\n    }),\n    [fleetAIResult]\n  );\n\n  // Batch updates using requestAnimationFrame and implement advanced fleet AI\n  const requestUpdate = useCallback(() => {\n    // Create a custom fleet AI result for advanced visualization\n    const customFleetAIResult: __FleetAIResult = {\n      formationPatterns: {\n        defensive: {\n          spacing: 50,\n          facing: 0,\n          pattern: 'defensive',\n          adaptiveSpacing: true,\n        },\n        offensive: {\n          spacing: 30,\n          facing: 90,\n          pattern: 'offensive',\n          adaptiveSpacing: false,\n        },\n        balanced: {\n          spacing: 40,\n          facing: 45,\n          pattern: 'balanced',\n          adaptiveSpacing: true,\n        },\n      },\n      adaptiveAI: {\n        experienceLevel: tier,\n        performance: {\n          damageEfficiency: 0.8,\n          survivalRate: 0.9,\n        },\n      },\n      factionBehavior: {\n        aggressionLevel: factionId === 'lost-nova' ? 0.8 : 0.5,\n        territorialControl: {\n          facing: 0,\n        },\n      },\n      visualFeedback: fleetAI.visualFeedback\n        ? {\n            formationLines: fleetAI.visualFeedback.formationLines,\n            rangeCircles: fleetAI.visualFeedback.rangeCircles,\n          }\n        : undefined,\n    };\n\n    // Log the fleet AI result for debugging\n    console.warn('Advanced fleet AI result:', customFleetAIResult);\n\n    // Update active hazards\n    activeHazardsRef.current = hazards;\n\n    requestAnimationFrame(() => {\n      setImpactAnimations(prev => ({ ...prev }));\n    });\n  }, [hazards, fleetAI.visualFeedback, tier, factionId]);\n\n  // Use the requestUpdate function in an effect to demonstrate its usage\n  useEffect(() => {\n    // Request an update when the fleet ID changes\n    requestUpdate();\n\n    // Set up an interval to periodically request updates (for demonstration)\n    const updateInterval = setInterval(() => {\n      if (units.length > 0 && hazards.length > 0) {\n        requestUpdate();\n      }\n    }, 30000); // Every 30 seconds\n\n    return () => {\n      clearInterval(updateInterval);\n    };\n  }, [fleetId, requestUpdate, units.length, hazards.length]);\n\n  // Memoize tech-enhanced values\n  const enhancedValues = useMemo(\n    () => ({\n      detectionRadius: 1000 * techBonuses.detectionRange,\n      hazardResistance: Math.min(0.9, techBonuses.hazardResistance),\n      effectMultiplier: Math.max(0.1, techBonuses.effectPotency),\n    }),\n    [techBonuses]\n  );\n\n  // Optimize collision detection with spatial partitioning\n  const spatialGrid = useMemo(() => {\n    const grid: Record<string, Set<string>> = {};\n    const cellSize = 100; // Adjust based on typical unit sizes\n\n    units.forEach(unit => {\n      const cellX = Math.floor(unit.position.x / cellSize);\n      const cellY = Math.floor(unit.position.y / cellSize);\n      const cellKey = `${cellX},${cellY}`;\n\n      if (!grid[cellKey]) {\n        grid[cellKey] = new Set();\n      }\n      grid[cellKey].add(unit.id);\n    });\n\n    return grid;\n  }, [units]);\n\n  // Optimize particle system - kept for future implementation of enhanced visual effects\n  // Will be used when implementing the dynamic particle system for hazards\n  const __updateParticles = useCallback(() => {\n    if (quality === 'low') {\n      return;\n    }\n\n    const newPositions: Record<string, Array<{ x: number; y: number }>> = {};\n    activeHazardsRef.current.forEach(hazard => {\n      const baseParticleCount = quality === 'high' ? 20 : 10;\n      const tierMultiplier = 1 + (tier - 1) * 0.5;\n      const particleCount = Math.floor(baseParticleCount * tierMultiplier);\n\n      // Use object pooling for particles\n      const particles = particlePositionsRef.current[hazard.id] ?? [];\n      while (particles.length < particleCount) {\n        particles.push({ x: 0, y: 0 });\n      }\n\n      // Update particle positions\n      for (let i = 0; i < particleCount; i++) {\n        const angle = Math.random() * Math.PI * 2;\n        const distance = Math.random() * hazard.radius;\n        particles[i].x = hazard.position.x + Math.cos(angle) * distance;\n        particles[i].y = hazard.position.y + Math.sin(angle) * distance;\n      }\n\n      newPositions[hazard.id] = particles;\n    });\n\n    particlePositionsRef.current = newPositions;\n  }, [quality, tier, activeHazardsRef, particlePositionsRef]);\n\n  // Enhanced collision effect handling - kept for future implementation of advanced collision system\n  // Will be used when implementing the physics-based collision and damage system\n  const __handleCollisionEffect = useCallback(\n    (hazardId: string, shipId: string, effect: Hazard['effect']) => {\n      // Apply tech bonuses to effect\n      const modifiedEffect = {\n        ...effect,\n        value:\n          effect.value * enhancedValues.effectMultiplier * (1 - enhancedValues.hazardResistance),\n      };\n\n      // Trigger impact animation\n      setImpactAnimations(prev => ({ ...prev, [hazardId]: true }));\n      setTimeout(() => {\n        setImpactAnimations(prev => ({ ...prev, [hazardId]: false }));\n      }, 1000);\n\n      onHazardEffect(hazardId, shipId, modifiedEffect);\n    },\n    [enhancedValues, onHazardEffect]\n  );\n\n  // Handle weapon firing with visual effects\n  const handleWeaponFire = useCallback(\n    (weaponId: string, targetId: string, type: string) => {\n      onWeaponFire(weaponId, targetId);\n      weaponEffectsRef.current[weaponId] = { active: true, type };\n      setTimeout(() => {\n        weaponEffectsRef.current[weaponId] = { active: false, type };\n      }, 1000);\n    },\n    [onWeaponFire]\n  );\n\n  // Optimize combat loop with worker\n  useEffect(() => {\n    const worker = new Worker(new URL('../../workers/combatWorker.ts', import.meta.url));\n\n    worker.onmessage = e => {\n      const { type, data } = e.data;\n      switch (type) {\n        case 'WEAPON_FIRE':\n          handleWeaponFire(data?.weaponId, data?.targetId, data?.weaponType);\n          break;\n        case 'UNIT_MOVE':\n          onUnitMove(data?.unitId, data?.position);\n          break;\n      }\n    };\n\n    const interval = setInterval(() => {\n      worker.postMessage({\n        type: 'UPDATE',\n        units: units,\n        hazards: activeHazardsRef.current,\n        spatialGrid,\n      });\n    }, 100);\n\n    return () => {\n      clearInterval(interval);\n      worker.terminate();\n    };\n  }, [units, onUnitMove, handleWeaponFire, spatialGrid]);\n\n  // Optimize render with virtualization\n  const virtualizedUnits = useMemo(() => {\n    return units.filter(unit => {\n      return (\n        unit.position.x >= 0 &&\n        unit.position.x <= window.innerWidth &&\n        unit.position.y >= 0 &&\n        unit.position.y <= window.innerHeight\n      );\n    });\n  }, [units]);\n\n  // Handle hazard detection and threat response - kept for future implementation of threat response system\n  // Will be used when implementing the AI-driven threat assessment and response system\n  const __handleThreatDetection = useCallback(\n    (hazard: Hazard) => {\n      if (onThreatDetected) {\n        onThreatDetected(hazard);\n      }\n\n      // Emit global event for fleet response\n      emitEvent('THREAT_DETECTED', {\n        hazardId: hazard.id,\n        position: hazard.position,\n        severity: hazard.severity,\n        type: hazard.type,\n      });\n    },\n    [onThreatDetected, emitEvent]\n  );\n\n  // Combat automation effect\n  useEffect(() => {\n    const subscription = moduleEventBus.subscribe('AUTOMATION_STARTED', (event: ModuleEvent) => {\n      if (\n        event?.type === 'AUTOMATION_STARTED' &&\n        event?.moduleType === 'hangar' &&\n        event?.data?.type\n      ) {\n        // Define the valid automation effect types\n        const validTypes = [\n          'shield',\n          'formation',\n          'engagement',\n          'repair',\n          'attack',\n          'retreat',\n        ] as const;\n        type AutomationEffectType = (typeof validTypes)[number];\n\n        // Check if the type is valid\n        const effectType = event?.data?.type;\n        if (\n          typeof effectType === 'string' &&\n          validTypes.includes(effectType as AutomationEffectType)\n        ) {\n          // Create a properly typed position object\n          const position: Position =\n            event?.data?.position &&\n            typeof event?.data?.position === 'object' &&\n            'x' in event?.data?.position &&\n            'y' in event?.data?.position\n              ? { x: Number(event?.data?.position.x), y: Number(event?.data?.position.y) }\n              : { x: 50, y: 50 };\n\n          setAutomationEffects(prev => [\n            ...prev,\n            {\n              id: `${event?.moduleId}-${Date.now()}`,\n              type: effectType as AutomationEffectType,\n              position,\n              timestamp: Date.now(),\n            },\n          ]);\n        }\n\n        // Cleanup old effects\n        setTimeout(() => {\n          setAutomationEffects(prev => prev.filter(effect => Date.now() - effect.timestamp < 2000));\n        }, 2000);\n      }\n    });\n\n    return () => {\n      subscription();\n    };\n  }, []);\n\n  // Get enhanced hazard visuals based on tier and type\n  const getHazardVisuals = useCallback(\n    (hazard: Hazard) => {\n      const baseColor = getHazardColor(hazard.type);\n      const vprAnimations = getVPRAnimationSet(hazard.type, tier);\n\n      return {\n        color: baseColor,\n        glowIntensity: tier * (hazard.severity === 'high' ? 1.5 : 1),\n        animations: vprAnimations,\n        particlePattern: hazard.vpr?.particleSystem.pattern || 'circular',\n      };\n    },\n    [tier, getVPRAnimationSet]\n  );\n\n  const getHazardColor = (type: Hazard['type']) => {\n    switch (type) {\n      case 'asteroids':\n        return 'amber';\n      case 'debris':\n        return 'gray';\n      case 'radiation':\n        return 'green';\n      case 'anomaly':\n        return 'purple';\n      default:\n        return 'blue';\n    }\n  };\n\n  // Add unit movement handling\n  useEffect(() => {\n    const moveInterval = setInterval(() => {\n      units.forEach(unit => {\n        if (unit.status === 'engaging') {\n          const nearestHazard = activeHazardsRef.current.reduce(\n            (nearest, current) => {\n              const currentDist = Math.sqrt(\n                Math.pow(current.position.x - unit.position.x, 2) +\n                  Math.pow(current.position.y - unit.position.y, 2)\n              );\n              const nearestDist = nearest\n                ? Math.sqrt(\n                    Math.pow(nearest.position.x - unit.position.x, 2) +\n                      Math.pow(nearest.position.y - unit.position.y, 2)\n                  )\n                : Infinity;\n              return currentDist < nearestDist ? current : nearest;\n            },\n            null as Hazard | null\n          );\n\n          if (nearestHazard) {\n            const newPosition = {\n              x: unit.position.x + (nearestHazard.position.x - unit.position.x) * 0.1,\n              y: unit.position.y + (nearestHazard.position.y - unit.position.y) * 0.1,\n            };\n            onUnitMove(unit.id, newPosition);\n          }\n        }\n      });\n    }, 100);\n\n    return () => clearInterval(moveInterval);\n  }, [units, onUnitMove]);\n\n  // Add implementation to use the previously unused variables\n  useEffect(() => {\n    // Set up particle system update interval\n    const particleInterval = setInterval(() => {\n      __updateParticles();\n    }, 100);\n\n    return () => {\n      clearInterval(particleInterval);\n    };\n  }, [__updateParticles]);\n\n  // Use the collision effect handler for hazard collisions\n  useEffect(() => {\n    // Check for collisions between units and hazards\n    const checkCollisions = () => {\n      units.forEach(unit => {\n        hazards.forEach(hazard => {\n          const distance = Math.sqrt(\n            Math.pow(unit.position.x - hazard.position.x, 2) +\n              Math.pow(unit.position.y - hazard.position.y, 2)\n          );\n\n          if (distance < hazard.radius) {\n            __handleCollisionEffect(hazard.id, unit.id, hazard.effect);\n          }\n        });\n      });\n    };\n\n    // Set up collision detection interval\n    const collisionInterval = setInterval(checkCollisions, 1000);\n\n    return () => {\n      clearInterval(collisionInterval);\n    };\n  }, [units, hazards, __handleCollisionEffect]);\n\n  // Add the missing previousHazardsRef\n  const previousHazardsRef = useRef<Set<string>>(new Set());\n\n  // Use the threat detection system\n  useEffect(() => {\n    // Detect new hazards that enter the detection range\n    const detectThreats = () => {\n      hazards.forEach(hazard => {\n        // Check if this is a new hazard\n        if (!previousHazardsRef.current.has(hazard.id)) {\n          __handleThreatDetection(hazard);\n          previousHazardsRef.current.add(hazard.id);\n        }\n      });\n    };\n\n    detectThreats();\n  }, [hazards, __handleThreatDetection]);\n\n  // Update fleet AI result based on current battle state\n  useEffect(() => {\n    if (units.length > 0) {\n      // Update formation lines based on unit positions\n      const points = units.map(unit => ({ x: unit.position.x, y: unit.position.y }));\n\n      // Update range circles based on unit weapons\n      const rangeCircles = units.map(unit => {\n        const maxRange = Math.max(...unit.weapons.map(w => w.range));\n        return {\n          center: unit.position,\n          radius: maxRange,\n          type: 'engagement' as const,\n          opacity: 0.3,\n        };\n      });\n\n      // Use the existing fleetAIResult from useFleetAI hook\n      // This is just for demonstration - we're not actually modifying the fleetAIResult\n      // since it comes from a hook and we can't directly modify it\n      console.warn('Fleet AI visualization updated with', {\n        formationLines: {\n          points,\n          style: 'solid' as const,\n          color: '#00ff00',\n          opacity: 0.5,\n        },\n        rangeCircles,\n      });\n    }\n  }, [units]);\n\n  return (\n    <div className=\"relative h-full w-full overflow-hidden\">\n      {/* Combat HUD - Only render visible units */}\n      <div className=\"absolute left-4 top-4 space-y-2\">\n        {virtualizedUnits.map(unit => (\n          <div\n            key={unit.id}\n            className={`rounded-lg border bg-gray-900/80 px-3 py-2 backdrop-blur-sm ${\n              unit.status === 'engaging'\n                ? 'border-red-500'\n                : unit.status === 'damaged'\n                  ? 'border-yellow-500'\n                  : 'border-gray-700'\n            }`}\n          >\n            <div className=\"flex items-center justify-between text-sm\">\n              <span className=\"text-gray-300\">{unit.type}</span>\n              <span\n                className={`rounded-full px-2 py-0.5 text-xs ${\n                  unit.status === 'engaging'\n                    ? 'bg-red-900/50 text-red-400'\n                    : unit.status === 'damaged'\n                      ? 'bg-yellow-900/50 text-yellow-400'\n                      : 'bg-gray-800 text-gray-400'\n                }`}\n              >\n                {unit.status}\n              </span>\n            </div>\n            {/* Health and Shield Bars */}\n            <div className=\"mt-1 space-y-1\">\n              <div className=\"h-1 overflow-hidden rounded-full bg-gray-700\">\n                <div\n                  className=\"h-full bg-green-500 transition-all\"\n                  style={{ width: `${(unit.health / unit.maxHealth) * 100}%` }}\n                />\n              </div>\n              <div className=\"h-1 overflow-hidden rounded-full bg-gray-700\">\n                <div\n                  className=\"h-full bg-blue-500 transition-all\"\n                  style={{ width: `${(unit.shield / unit.maxShield) * 100}%` }}\n                />\n              </div>\n            </div>\n          </div>\n        ))}\n      </div>\n\n      {/* Hazards */}\n      {hazards.map(hazard => {\n        const visuals = getHazardVisuals(hazard);\n\n        return (\n          <div\n            key={hazard.id}\n            className=\"absolute\"\n            style={{\n              left: `${hazard.position.x}%`,\n              top: `${hazard.position.y}%`,\n              transform: 'translate(-50%, -50%)',\n            }}\n          >\n            {/* Enhanced Hazard Visualization */}\n            <div\n              className={`animate-pulse rounded-full bg-${visuals.color}-500/20 relative overflow-hidden ${impactAnimations[hazard.id] ? visuals.animations.impact : visuals.animations.idle} `}\n              style={{\n                width: `${hazard.radius * 2}px`,\n                height: `${hazard.radius * 2}px`,\n                boxShadow: `0 0 ${hazard.severity === 'high' ? '20px' : '10px'} ${visuals.color}-500/${30 * visuals.glowIntensity}`,\n              }}\n            >\n              {/* Enhanced Particle Effects */}\n              {quality !== 'low' &&\n                particlePositionsRef.current[hazard.id]?.map((particle, index) => (\n                  <div\n                    key={index}\n                    className={`absolute h-1 w-1 rounded-full bg-${visuals.color}-400/50 ${visuals.animations.active} `}\n                    style={{\n                      left: `${particle.x}%`,\n                      top: `${particle.y}%`,\n                      animation: `float ${1 + Math.random()}s infinite`,\n                    }}\n                  />\n                ))}\n\n              {/* Hazard Icon with Tier-based Effects */}\n              <div\n                className={`absolute inset-0 flex items-center justify-center ${visuals.animations.idle}`}\n              >\n                {hazard.type === 'asteroids' && (\n                  <AlertTriangle className={`h-8 w-8 text-${visuals.color}-400`} />\n                )}\n                {hazard.type === 'radiation' && (\n                  <Zap className={`h-8 w-8 text-${visuals.color}-400`} />\n                )}\n                {hazard.type === 'anomaly' && (\n                  <Shield className={`h-8 w-8 text-${visuals.color}-400`} />\n                )}\n              </div>\n            </div>\n\n            {/* Enhanced Effect Indicator */}\n            <div\n              className={`absolute left-1/2 top-full mt-2 -translate-x-1/2 rounded-full px-2 py-1 bg-${visuals.color}-900/80 border border-${visuals.color}-500/50 text-${visuals.color}-200 whitespace-nowrap text-xs ${hazard.severity === 'high' ? 'animate-pulse' : ''} ${visuals.animations.active}`}\n            >\n              {hazard.effect.type.charAt(0).toUpperCase() + hazard.effect.type.slice(1)}:{' '}\n              {Math.round(\n                hazard.effect.value *\n                  enhancedValues.effectMultiplier *\n                  (1 - enhancedValues.hazardResistance)\n              )}\n              {hazard.severity === 'high' && ' âš ï¸'}\n              {tier > 1 && ` (Tier ${tier})`}\n            </div>\n          </div>\n        );\n      })}\n\n      {/* Weapon Effects */}\n      {Object.entries(weaponEffectsRef.current).map(([weaponId, effect]) => {\n        if (!effect.active) return null;\n\n        const weapon = units.flatMap(u => u.weapons).find(w => w.id === weaponId);\n        if (!weapon) return null;\n\n        return (\n          <div\n            key={weaponId}\n            className={`absolute transition-opacity ${\n              effect.type === 'machineGun'\n                ? 'bg-yellow-500/50'\n                : effect.type === 'gaussCannon'\n                  ? 'bg-cyan-500/50'\n                  : effect.type === 'railGun'\n                    ? 'bg-violet-500/50'\n                    : effect.type === 'mgss'\n                      ? 'bg-red-500/50'\n                      : 'bg-orange-500/50'\n            }`}\n            style={{\n              width: '4px',\n              height: weapon.range,\n              transformOrigin: 'center',\n              opacity: effect.active ? 1 : 0,\n            }}\n          />\n        );\n      })}\n\n      {/* Formation Lines */}\n      {fleetAI.visualFeedback && (\n        <svg className=\"pointer-events-none absolute inset-0\">\n          <path\n            d={`M ${fleetAI.visualFeedback.formationLines.points.map((p: { x: number; y: number }) => `${p.x},${p.y}`).join(' L ')}`}\n            stroke={fleetAI.visualFeedback.formationLines.color}\n            strokeWidth=\"2\"\n            fill=\"none\"\n            strokeDasharray={\n              fleetAI.visualFeedback.formationLines.style === 'dashed' ? '4 4' : 'none'\n            }\n            opacity={fleetAI.visualFeedback.formationLines.opacity}\n          />\n        </svg>\n      )}\n\n      {/* Range Circles */}\n      {fleetAI.visualFeedback?.rangeCircles.map((circle: RangeCircle, index: number) => (\n        <div\n          key={index}\n          className=\"absolute rounded-full border-2 transition-all\"\n          style={{\n            left: circle.center.x,\n            top: circle.center.y,\n            width: circle.radius * 2,\n            height: circle.radius * 2,\n            transform: 'translate(-50%, -50%)',\n            borderColor:\n              circle.type === 'engagement' ? 'rgba(239, 68, 68, 0.5)' : 'rgba(59, 130, 246, 0.5)',\n            opacity: circle.opacity,\n          }}\n        />\n      ))}\n\n      {/* Combat Automation Effects */}\n      {automationEffects.map(effect => (\n        <CombatAutomationEffect\n          key={effect.id}\n          type={effect.type}\n          position={effect.position}\n          quality={quality}\n          intensity={techBonuses.effectPotency}\n        />\n      ))}\n    </div>\n  );\n}\n\n// Enhanced animation keyframes with tier-based variations\nconst style = document.createElement('style');\nstyle.textContent = `\n  @keyframes float {\n    0%, 100% { transform: translate(0, 0); }\n    50% { transform: translate(3px, -3px); }\n  }\n  \n  @keyframes impact {\n    0% { transform: scale(1); opacity: 1; }\n    50% { transform: scale(1.2); opacity: 0.8; }\n    100% { transform: scale(1); opacity: 1; }\n  }\n  \n  @keyframes pulse {\n    0%, 100% { opacity: 1; }\n    50% { opacity: 0.6; }\n  }\n`;\ndocument.head.appendChild(style);\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/combat/BattleView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/combat/CombatDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/combat/CombatLayout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/combat/CombatSystemDemo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/combat/FleetDetails.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/combat/SalvageSystem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/combat/alerts/AlertSystemUI.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/combat/formations/FormationEditor.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/combat/formations/FormationPresetList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/combat/formations/FormationTacticsContainer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/combat/formations/FormationTacticsPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/combat/formations/FormationTacticsPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/combat/formations/FormationVisualizer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/combat/formations/TacticalBehaviorSelector.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/combat/formations/TacticalBonusCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/combat/radar/DetectionVisualization.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/combat/radar/RadarSweepAnimation.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/combat/radar/RangeIndicators.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/core/IntegrationErrorHandler.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/core/SystemIntegration.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ModuleEventType' is defined but never used. Allowed unused vars must match /^ignored|^temp/u.","line":39,"column":6,"nodeType":null,"messageId":"unusedVar","endLine":39,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_event' is defined but never used.","line":201,"column":72,"nodeType":null,"messageId":"unusedVar","endLine":201,"endColumn":78}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ReactNode, useCallback, useEffect, useRef, useState } from 'react';\nimport { GameActionType, useGameDispatch } from '../../contexts/GameContext';\nimport { ModuleActionType, useModuleContext } from '../../contexts/ModuleContext';\nimport { moduleEventBus } from '../../lib/modules/ModuleEvents';\nimport { GameLoopManager, UpdatePriority } from '../../managers/game/GameLoopManager';\nimport { ResourceManager } from '../../managers/game/ResourceManager';\nimport { moduleManager } from '../../managers/module/ModuleManager';\nimport { ModuleType } from '../../types/buildings/ModuleTypes';\nimport { BaseEvent, EventType } from '../../types/events/EventTypes';\nimport { Module } from '../../types/modules/ModuleTypes';\nimport { ResourceType } from './../../types/resources/ResourceTypes';\n\ninterface SystemIntegrationProps {\n  children: ReactNode;\n  resourceManager: ResourceManager;\n  gameLoopManager?: GameLoopManager;\n  updateInterval?: number;\n}\n\n// Types of resource events to listen for\nconst RESOURCE_EVENT_TYPES = [\n  EventType.RESOURCE_PRODUCED,\n  EventType.RESOURCE_CONSUMED,\n  EventType.RESOURCE_TRANSFERRED,\n  EventType.RESOURCE_SHORTAGE,\n  EventType.RESOURCE_PRODUCTION_REGISTERED,\n  EventType.RESOURCE_CONSUMPTION_REGISTERED,\n];\n\n// Types of module events to listen for\nconst MODULE_EVENT_TYPES = [\n  'MODULE_CREATED',\n  'MODULE_UPDATED',\n  'STATUS_CHANGED',\n  'MODULE_ACTIVATED',\n  'MODULE_DEACTIVATED',\n] as const;\n\ntype ModuleEventType = (typeof MODULE_EVENT_TYPES)[number];\n\n/**\n * SystemIntegration component\n *\n * This component serves as a bridge between the frontend React contexts and\n * the backend manager classes. It synchronizes state between them and ensures\n * that updates from managers are propagated to the UI.\n */\nexport function SystemIntegration({\n  children,\n  resourceManager,\n  gameLoopManager,\n  updateInterval = 1000,\n}: SystemIntegrationProps) {\n  const gameDispatch = useGameDispatch();\n  const { dispatch: moduleDispatch } = useModuleContext();\n\n  const lastResourceState = useRef<Record<string, number>>({});\n  const intervalRef = useRef<NodeJS.Timeout | null>(null);\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n\n  // Initialize managers\n  useEffect(() => {\n    const initializeManagers = async () => {\n      try {\n        // Initialize the resource manager\n        await resourceManager.initialize();\n\n        // Connect resource manager to game loop if provided\n        if (gameLoopManager) {\n          gameLoopManager.registerUpdate(\n            resourceManager.id,\n            deltaTime => resourceManager.update(deltaTime),\n            UpdatePriority.NORMAL\n          );\n        }\n\n        setIsInitialized(true);\n        console.warn('Managers initialized successfully');\n      } catch (err) {\n        console.error('Failed to initialize managers:', err);\n        setError(err instanceof Error ? err : new Error(String(err)));\n      }\n    };\n\n    initializeManagers();\n\n    // Cleanup on unmount\n    return () => {\n      if (gameLoopManager) {\n        gameLoopManager.unregisterUpdate(resourceManager.id);\n      }\n      resourceManager.dispose();\n    };\n  }, [resourceManager, gameLoopManager]);\n\n  // Sync resource state from ResourceManager to GameContext\n  const syncResourceState = useCallback(() => {\n    if (!gameDispatch) return;\n\n    // Get current resources from manager\n    const currentResources = resourceManager.getAllResources();\n    const lastResourceStateValue = lastResourceState.current;\n\n    // Check if resources have changed\n    const hasChanges =\n      !lastResourceStateValue ||\n      Object.entries(currentResources).some(\n        ([key, value]) => lastResourceStateValue[key] !== value\n      );\n\n    // Only update if there are changes\n    if (hasChanges) {\n      console.warn('Syncing resource state:', currentResources);\n\n      // Add resource rates to the update if we can calculate them\n      let resourceRates = {};\n\n      if (resourceManager.getAllResourceStates) {\n        const states = resourceManager.getAllResourceStates();\n\n        // Calculate rates from production and consumption\n        resourceRates = {\n          mineralRate:\n            (states[ResourceType.MINERALS]?.production ?? 0) -\n            (states[ResourceType.MINERALS]?.consumption ?? 0),\n          energyRate:\n            (states[ResourceType.ENERGY]?.production ?? 0) -\n            (states[ResourceType.ENERGY]?.consumption ?? 0),\n          populationRate:\n            (states[ResourceType.POPULATION]?.production ?? 0) -\n            (states[ResourceType.POPULATION]?.consumption ?? 0),\n          researchRate:\n            (states[ResourceType.RESEARCH]?.production ?? 0) -\n            (states[ResourceType.RESEARCH]?.consumption ?? 0),\n        };\n      }\n\n      // Update resources with the calculated values\n      gameDispatch({\n        type: GameActionType.UPDATE_RESOURCES,\n        payload: {\n          minerals: currentResources[ResourceType.MINERALS] ?? 0,\n          energy: currentResources[ResourceType.ENERGY] ?? 0,\n          population: currentResources[ResourceType.POPULATION] ?? 0,\n          research: currentResources[ResourceType.RESEARCH] ?? 0,\n          ...resourceRates, // Add rates if available\n        },\n      });\n\n      lastResourceState.current = { ...currentResources };\n    }\n  }, [gameDispatch, resourceManager]);\n\n  // Sync module state from ModuleManager to ModuleContext\n  const syncModuleState = useCallback(() => {\n    if (!moduleDispatch) return;\n\n    const moduleBuildings = moduleManager.getBuildings();\n    const modules = moduleManager.getActiveModules();\n\n    // Only update if there are modules available\n    if (modules.length > 0) {\n      moduleDispatch({\n        type: ModuleActionType.SET_ACTIVE_MODULES,\n        payload: { activeModuleIds: modules.map(m => m.id) },\n      });\n    }\n\n    // Update buildings if available\n    if (moduleBuildings.length > 0) {\n      // Register each building individually\n      moduleBuildings.forEach(building => {\n        // Convert building to Module type\n        const moduleData: Module = {\n          id: building.id,\n          name: building.id, // Use ID as name if not available\n          type: 'resource-manager' as ModuleType, // Default to resource-manager type\n          status: 'active', // Default to active\n          position: { x: 0, y: 0 }, // Default position\n          isActive: true, // Default to active\n          level: 1, // Default level\n        };\n\n        moduleDispatch({\n          type: ModuleActionType.ADD_MODULE,\n          payload: { module: moduleData },\n        });\n      });\n    }\n  }, [moduleDispatch]);\n\n  // Set up event listeners and sync intervals\n  useEffect(() => {\n    if (!isInitialized || !gameDispatch || !moduleDispatch) return;\n\n    const unsubscribes: Array<() => void> = [];\n\n    // Subscribe to resource events from the resource manager\n    RESOURCE_EVENT_TYPES.forEach(eventType => {\n      const unsubscribe = resourceManager.subscribeToEvent(eventType, (_event: BaseEvent) => {\n        syncResourceState();\n      });\n      unsubscribes.push(unsubscribe);\n    });\n\n    // Listen for module events\n    MODULE_EVENT_TYPES.forEach(eventType => {\n      const unsubscribe = moduleEventBus.subscribe(eventType, () => {\n        syncModuleState();\n      });\n      unsubscribes.push(unsubscribe);\n    });\n\n    // Only set up interval if we don't have a game loop manager\n    if (!gameLoopManager) {\n      // Set up interval for periodic updates\n      intervalRef.current = setInterval(() => {\n        syncResourceState();\n        syncModuleState();\n\n        // Manually call update on resource manager since we don't have a game loop\n        resourceManager.update(updateInterval);\n      }, updateInterval);\n    }\n\n    // Initial sync\n    syncResourceState();\n    syncModuleState();\n\n    // Cleanup\n    return () => {\n      if (intervalRef.current) {\n        clearInterval(intervalRef.current);\n      }\n      unsubscribes.forEach(unsubscribe => unsubscribe());\n    };\n  }, [\n    syncResourceState,\n    syncModuleState,\n    updateInterval,\n    isInitialized,\n    resourceManager,\n    gameLoopManager,\n    gameDispatch,\n    moduleDispatch,\n  ]);\n\n  // Show loading state while initializing\n  if (!isInitialized) {\n    return (\n      <div className=\"flex h-20 items-center justify-center rounded bg-gray-100 p-4 shadow-sm\">\n        <span className=\"text-gray-700\">Initializing game systems...</span>\n      </div>\n    );\n  }\n\n  // Show error state if initialization failed\n  if (error) {\n    return (\n      <div className=\"flex h-20 items-center justify-center rounded bg-red-100 p-4 shadow-sm\">\n        <span className=\"text-red-700\">Error initializing systems: {error.message}</span>\n      </div>\n    );\n  }\n\n  // Return children since this component doesn't render anything itself when initialized\n  return <>{children}</>;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/core/ThresholdIntegration.tsx","messages":[{"ruleId":"no-unsafe-optional-chaining","severity":2,"message":"Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.","line":78,"column":38,"nodeType":"ChainExpression","messageId":"unsafeOptionalChain","endLine":78,"endColumn":49}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as React from 'react';\nimport { useEffect, useState } from 'react';\nimport { useThreshold } from '../../contexts/ThresholdContext';\nimport { ResourceManager } from '../../managers/game/ResourceManager';\nimport { BaseEvent, EventType } from '../../types/events/EventTypes';\nimport { ResourceType } from './../../types/resources/ResourceTypes';\n\ninterface ThresholdIntegrationProps {\n  resourceManager: ResourceManager;\n  children: React.ReactNode;\n}\n\n/**\n * ThresholdIntegration component\n *\n * Connects the ResourceManager to the ThresholdContext, enabling:\n * - Synchronization of resource amounts from ResourceManager to ThresholdContext\n * - Propagation of threshold violations from ThresholdContext to ResourceManager\n * - Automatic resource management based on threshold settings\n */\nexport function ThresholdIntegration({ resourceManager, children }: ThresholdIntegrationProps) {\n  const { state, dispatch } = useThreshold();\n  const [isInitialized, setIsInitialized] = useState(false);\n\n  // Initialize connection between ResourceManager and ThresholdContext\n  useEffect(() => {\n    const setupConnection = async () => {\n      try {\n        // Register for resource update events from ResourceManager\n        const unsubscribe = resourceManager.subscribeToEvent(\n          EventType.RESOURCE_UPDATED,\n          handleResourceUpdate\n        );\n\n        // Initial synchronization of all resources\n        synchronizeAllResources();\n\n        setIsInitialized(true);\n\n        // Cleanup on unmount\n        return () => {\n          unsubscribe();\n        };\n      } catch (error) {\n        console.error('Failed to connect ThresholdContext to ResourceManager:', error);\n      }\n    };\n\n    setupConnection();\n  }, [resourceManager]);\n\n  // Synchronize all resources from ResourceManager to ThresholdContext\n  const synchronizeAllResources = () => {\n    const resourceStates = resourceManager.getAllResourceStates();\n\n    if (!resourceStates) {\n      return;\n    }\n\n    // Update each resource in the ThresholdContext\n    Object.entries(resourceStates).forEach(([type, state]) => {\n      if (state) {\n        dispatch({\n          type: 'UPDATE_AMOUNT',\n          payload: {\n            resourceId: type,\n            amount: state.current,\n          },\n        });\n      }\n    });\n  };\n\n  // Handle resource update events from ResourceManager\n  const handleResourceUpdate = (event: BaseEvent) => {\n    if (!event?.data || typeof event?.data !== 'object') return;\n\n    const resources = 'resources' in event?.data ? event?.data?.resources : null;\n\n    if (!resources || typeof resources !== 'object') return;\n\n    // Update each resource in the ThresholdContext\n    Object.entries(resources).forEach(([type, data]) => {\n      if (typeof data === 'object' && data !== null && 'current' in data) {\n        const current = data?.current as number;\n        dispatch({\n          type: 'UPDATE_AMOUNT',\n          payload: {\n            resourceId: type,\n            amount: current,\n          },\n        });\n      }\n    });\n  };\n\n  // Listen for threshold changes and handle threshold violations\n  useEffect(() => {\n    if (!isInitialized) return;\n\n    // Setup automatic resource management based on thresholds\n    const checkThresholds = () => {\n      Object.entries(state.resources).forEach(([resourceId, resource]) => {\n        const { currentAmount, thresholds, autoMine } = resource;\n\n        // Handle threshold violations\n        if (currentAmount < thresholds.min) {\n          // Publish threshold violation event\n          resourceManager.publishEvent({\n            type: EventType.RESOURCE_THRESHOLD_TRIGGERED,\n            moduleId: resourceManager.id,\n            moduleType: 'resource-manager',\n            timestamp: Date.now(),\n            data: {\n              resourceType: resourceId as ResourceType,\n              thresholdType: 'min',\n              current: currentAmount,\n              threshold: thresholds.min,\n              violation: true,\n            },\n          });\n\n          // If auto-mining is enabled, try to produce more of this resource\n          if (autoMine) {\n            // Here we would implement logic to automatically produce more of this resource\n            console.warn(`Auto-mining resource ${resourceId} due to threshold violation`);\n          }\n        } else if (currentAmount > thresholds.max) {\n          // Publish threshold violation event\n          resourceManager.publishEvent({\n            type: EventType.RESOURCE_THRESHOLD_TRIGGERED,\n            moduleId: resourceManager.id,\n            moduleType: 'resource-manager',\n            timestamp: Date.now(),\n            data: {\n              resourceType: resourceId as ResourceType,\n              thresholdType: 'max',\n              current: currentAmount,\n              threshold: thresholds.max,\n              violation: true,\n            },\n          });\n\n          // Stop production if we're over the maximum\n          if (autoMine) {\n            console.warn(\n              `Stopping resource ${resourceId} production due to max threshold violation`\n            );\n          }\n        }\n      });\n    };\n\n    // Check thresholds when the state changes\n    checkThresholds();\n\n    // Also set up an interval to regularly check thresholds\n    const intervalId = setInterval(checkThresholds, 10000); // Check every 10 seconds\n\n    return () => {\n      clearInterval(intervalId);\n    };\n  }, [state, isInitialized, resourceManager]);\n\n  return (\n    <>\n      {!isInitialized ? (\n        <div className=\"threshold-integration-loading\">Connecting resource thresholds...</div>\n      ) : (\n        children\n      )}\n    </>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/debug/AIDebugOverlay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/debug/GameStateMonitor.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/AdvancedFilteringSystem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/AnalysisConfigManager.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'onUpdateConfig' is defined but never used.","line":45,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":45,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import AddIcon from '@mui/icons-material/Add';\nimport DeleteIcon from '@mui/icons-material/Delete';\nimport {\n  Button,\n  Dialog,\n  DialogActions,\n  DialogContent,\n  DialogTitle,\n  FormControl,\n  IconButton,\n  InputLabel,\n  List,\n  ListItem,\n  ListItemText,\n  MenuItem,\n  Select,\n  TextField,\n  Typography,\n} from '@mui/material';\nimport * as React from 'react';\nimport { useState } from 'react';\nimport {\n  AnalysisConfig,\n  AnalysisType,\n  Dataset,\n  VisualizationType,\n} from '../../types/exploration/DataAnalysisTypes';\n\ninterface AnalysisConfigManagerProps {\n  configs: AnalysisConfig[];\n  datasets: Dataset[];\n  selectedConfig: AnalysisConfig | null;\n  onSelectConfig: (config: AnalysisConfig) => void;\n  onCreateConfig: (config: Omit<AnalysisConfig, 'id' | 'createdAt' | 'updatedAt'>) => string;\n  onUpdateConfig: (id: string, updates: Partial<AnalysisConfig>) => void;\n  onDeleteConfig: (id: string) => void;\n}\n\nconst AnalysisConfigManager: React.FC<AnalysisConfigManagerProps> = ({\n  configs,\n  datasets,\n  selectedConfig,\n  onSelectConfig,\n  onCreateConfig,\n  onUpdateConfig,\n  onDeleteConfig,\n}) => {\n  const [openDialog, setOpenDialog] = useState(false);\n  const [newConfigName, setNewConfigName] = useState('');\n  const [newConfigDescription, setNewConfigDescription] = useState('');\n  const [newConfigType, setNewConfigType] = useState<AnalysisType>('trend');\n  const [newConfigDatasetId, setNewConfigDatasetId] = useState('');\n  const [newVisualizationType, setNewVisualizationType] = useState<VisualizationType>('lineChart');\n\n  const handleCreateConfig = () => {\n    if (!newConfigName.trim() || !newConfigDatasetId) return;\n\n    // Generate default parameters based on analysis type\n    const parameters = generateDefaultParameters(newConfigType);\n\n    // Generate default visualization config\n    const visualizationConfig = generateDefaultVisualizationConfig(newVisualizationType);\n\n    onCreateConfig({\n      name: newConfigName,\n      description: newConfigDescription,\n      type: newConfigType,\n      datasetId: newConfigDatasetId,\n      parameters,\n      visualizationType: newVisualizationType,\n      visualizationConfig,\n    });\n\n    setNewConfigName('');\n    setNewConfigDescription('');\n    setNewConfigType('trend');\n    setNewConfigDatasetId('');\n    setNewVisualizationType('lineChart');\n    setOpenDialog(false);\n  };\n\n  // Generate default parameters based on analysis type\n  const generateDefaultParameters = (type: AnalysisType): Record<string, unknown> => {\n    switch (type) {\n      case 'trend':\n        return {\n          xAxis: 'date',\n          yAxis: 'value',\n          groupBy: 'type',\n          timeRange: [Date.now() - 30 * 86400000, Date.now()], // Last 30 days\n          aggregation: 'average',\n        };\n      case 'correlation':\n        return {\n          variables: ['resourcePotential', 'habitabilityScore', 'anomalyCount'],\n          method: 'pearson',\n          threshold: 0.5,\n        };\n      case 'distribution':\n        return {\n          variable: 'resourcePotential',\n          bins: 10,\n          normalize: true,\n        };\n      case 'clustering':\n        return {\n          variables: ['resourcePotential', 'habitabilityScore'],\n          clusters: 3,\n          method: 'kmeans',\n        };\n      case 'prediction':\n        return {\n          target: 'resourcePotential',\n          features: ['habitabilityScore', 'anomalyCount'],\n          method: 'linear',\n          testSize: 0.2,\n        };\n      default:\n        return {};\n    }\n  };\n\n  // Generate default visualization config based on visualization type\n  const generateDefaultVisualizationConfig = (type: VisualizationType): Record<string, unknown> => {\n    switch (type) {\n      case 'lineChart':\n        return {\n          xAxisLabel: 'Date',\n          yAxisLabel: 'Value',\n          showLegend: true,\n          showGrid: true,\n          colors: ['#4299E1', '#48BB78', '#F6AD55', '#F56565'],\n        };\n      case 'barChart':\n        return {\n          xAxisLabel: 'Category',\n          yAxisLabel: 'Value',\n          showLegend: true,\n          showGrid: true,\n          colors: ['#4299E1', '#48BB78', '#F6AD55', '#F56565'],\n          barSize: 20,\n        };\n      case 'scatterPlot':\n        return {\n          xAxisLabel: 'X',\n          yAxisLabel: 'Y',\n          showLegend: true,\n          showGrid: true,\n          colors: ['#4299E1', '#48BB78', '#F6AD55', '#F56565'],\n          pointSize: 5,\n        };\n      case 'pieChart':\n        return {\n          showLegend: true,\n          colors: ['#4299E1', '#48BB78', '#F6AD55', '#F56565', '#9F7AEA', '#ED64A6'],\n          innerRadius: 0,\n          outerRadius: 80,\n        };\n      default:\n        return {};\n    }\n  };\n\n  return (\n    <div>\n      <Button\n        variant=\"outlined\"\n        startIcon={<AddIcon />}\n        onClick={() => setOpenDialog(true)}\n        sx={{ mb: 2 }}\n      >\n        Create Analysis Config\n      </Button>\n\n      {configs.length === 0 ? (\n        <Typography variant=\"body2\" color=\"text.secondary\" align=\"center\">\n          No analysis configurations available. Create one to get started.\n        </Typography>\n      ) : (\n        <List sx={{ maxHeight: 400, overflow: 'auto' }}>\n          {configs.map(config => (\n            <ListItem\n              key={config.id}\n              button\n              selected={selectedConfig?.id === config.id}\n              onClick={() => onSelectConfig(config)}\n              secondaryAction={\n                <IconButton\n                  edge=\"end\"\n                  aria-label=\"delete\"\n                  onClick={(e: React.MouseEvent) => {\n                    e.stopPropagation();\n                    onDeleteConfig(config.id);\n                  }}\n                >\n                  <DeleteIcon />\n                </IconButton>\n              }\n            >\n              <ListItemText\n                primary={config.name}\n                secondary={\n                  <>\n                    <Typography component=\"span\" variant=\"body2\" color=\"text.primary\">\n                      {config.type}\n                    </Typography>\n                    {` â€” ${datasets.find(d => d.id === config.datasetId)?.name || 'Unknown dataset'}`}\n                  </>\n                }\n              />\n            </ListItem>\n          ))}\n        </List>\n      )}\n\n      {/* Create Config Dialog */}\n      <Dialog open={openDialog} onClose={() => setOpenDialog(false)}>\n        <DialogTitle>Create New Analysis Configuration</DialogTitle>\n        <DialogContent>\n          <TextField\n            autoFocus\n            margin=\"dense\"\n            label=\"Configuration Name\"\n            fullWidth\n            value={newConfigName}\n            onChange={(e: React.ChangeEvent<HTMLInputElement>) => setNewConfigName(e.target.value)}\n          />\n          <TextField\n            margin=\"dense\"\n            label=\"Description\"\n            fullWidth\n            value={newConfigDescription}\n            onChange={(e: React.ChangeEvent<HTMLInputElement>) =>\n              setNewConfigDescription(e.target.value)\n            }\n          />\n          <FormControl fullWidth margin=\"dense\">\n            <InputLabel>Dataset</InputLabel>\n            <Select\n              value={newConfigDatasetId}\n              label=\"Dataset\"\n              onChange={e => setNewConfigDatasetId(e.target.value as string)}\n            >\n              <MenuItem value=\"\">\n                <em>Select a dataset</em>\n              </MenuItem>\n              {datasets.map(dataset => (\n                <MenuItem key={dataset.id} value={dataset.id}>\n                  {dataset.name} ({dataset.source}, {dataset.dataPoints.length} points)\n                </MenuItem>\n              ))}\n            </Select>\n          </FormControl>\n          <FormControl fullWidth margin=\"dense\">\n            <InputLabel>Analysis Type</InputLabel>\n            <Select\n              value={newConfigType}\n              label=\"Analysis Type\"\n              onChange={e => setNewConfigType(e.target.value as AnalysisType)}\n            >\n              <MenuItem value=\"trend\">Trend Analysis</MenuItem>\n              <MenuItem value=\"correlation\">Correlation Analysis</MenuItem>\n              <MenuItem value=\"distribution\">Distribution Analysis</MenuItem>\n              <MenuItem value=\"clustering\">Clustering Analysis</MenuItem>\n              <MenuItem value=\"prediction\">Prediction Analysis</MenuItem>\n              <MenuItem value=\"comparison\">Comparison Analysis</MenuItem>\n              <MenuItem value=\"anomalyDetection\">Anomaly Detection</MenuItem>\n              <MenuItem value=\"resourceMapping\">Resource Mapping</MenuItem>\n              <MenuItem value=\"sectorAnalysis\">Sector Analysis</MenuItem>\n            </Select>\n          </FormControl>\n          <FormControl fullWidth margin=\"dense\">\n            <InputLabel>Visualization Type</InputLabel>\n            <Select\n              value={newVisualizationType}\n              label=\"Visualization Type\"\n              onChange={e => setNewVisualizationType(e.target.value as VisualizationType)}\n            >\n              <MenuItem value=\"lineChart\">Line Chart</MenuItem>\n              <MenuItem value=\"barChart\">Bar Chart</MenuItem>\n              <MenuItem value=\"scatterPlot\">Scatter Plot</MenuItem>\n              <MenuItem value=\"pieChart\">Pie Chart</MenuItem>\n              <MenuItem value=\"heatMap\">Heat Map</MenuItem>\n              <MenuItem value=\"radar\">Radar Chart</MenuItem>\n              <MenuItem value=\"histogram\">Histogram</MenuItem>\n              <MenuItem value=\"boxPlot\">Box Plot</MenuItem>\n              <MenuItem value=\"table\">Table</MenuItem>\n              <MenuItem value=\"map\">Map</MenuItem>\n              <MenuItem value=\"network\">Network Graph</MenuItem>\n            </Select>\n          </FormControl>\n        </DialogContent>\n        <DialogActions>\n          <Button onClick={() => setOpenDialog(false)}>Cancel</Button>\n          <Button\n            onClick={handleCreateConfig}\n            disabled={!newConfigName.trim() || !newConfigDatasetId}\n          >\n            Create\n          </Button>\n        </DialogActions>\n      </Dialog>\n    </div>\n  );\n};\n\nexport default AnalysisConfigManager;\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/AnomalyAnalysis.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_quality' is assigned a value but never used.","line":52,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":52,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  AlertTriangle,\n  ArrowRight,\n  ChevronDown,\n  ChevronUp,\n  Clock,\n  Database,\n  FileText,\n  MapIcon,\n  Microscope,\n  Zap,\n} from 'lucide-react';\nimport * as React from 'react';\nimport { useState } from 'react';\n\ninterface Anomaly {\n  id: string;\n  type: 'artifact' | 'signal' | 'phenomenon';\n  severity: 'low' | 'medium' | 'high';\n  description: string;\n  investigated: boolean;\n  discoveryDate: number;\n  sectorId: string;\n  sectorName: string;\n  coordinates: { x: number; y: number };\n  analysisProgress?: number;\n  analysisResults?: {\n    composition?: string[];\n    origin?: string;\n    age?: string;\n    energySignature?: string;\n    potentialUses?: string[];\n    dangerLevel?: number;\n    notes?: string;\n  };\n  images?: string[];\n}\n\ninterface AnomalyAnalysisProps {\n  anomalies: Anomaly[];\n  onInvestigate: (anomalyId: string) => void;\n  onAnalysisComplete: (anomalyId: string, results: Anomaly['analysisResults']) => void;\n  className?: string;\n  quality?: 'low' | 'medium' | 'high';\n}\n\nexport function AnomalyAnalysis({\n  anomalies,\n  onInvestigate,\n  onAnalysisComplete,\n  className = '',\n  quality: _quality = 'medium',\n}: AnomalyAnalysisProps) {\n  const [selectedAnomalyId, setSelectedAnomalyId] = useState<string | null>(null);\n  const [sortBy, setSortBy] = useState<'date' | 'severity' | 'type'>('severity');\n  const [sortOrder, setSortOrder] = useState<'asc' | 'desc'>('desc');\n  const [filter, setFilter] = useState<'all' | 'investigated' | 'uninvestigated'>('all');\n  const [analysisInProgress, setAnalysisInProgress] = useState<Record<string, boolean>>({});\n  const [expandedSections, setExpandedSections] = useState<Record<string, boolean>>({});\n\n  // Sort and filter anomalies\n  const sortedAnomalies = React.useMemo(() => {\n    let filtered = [...anomalies];\n\n    // Apply filter\n    if (filter === 'investigated') {\n      filtered = filtered.filter(a => a.investigated);\n    } else if (filter === 'uninvestigated') {\n      filtered = filtered.filter(a => !a.investigated);\n    }\n\n    // Apply sort\n    return filtered.sort((a, b) => {\n      let comparison = 0;\n\n      if (sortBy === 'date') {\n        comparison = a.discoveryDate - b.discoveryDate;\n      } else if (sortBy === 'severity') {\n        const severityValue = { low: 1, medium: 2, high: 3 };\n        comparison = severityValue[a.severity] - severityValue[b.severity];\n      } else if (sortBy === 'type') {\n        comparison = a.type.localeCompare(b.type);\n      }\n\n      return sortOrder === 'asc' ? comparison : -comparison;\n    });\n  }, [anomalies, sortBy, sortOrder, filter]);\n\n  // Get the selected anomaly\n  const selectedAnomaly = React.useMemo(() => {\n    return anomalies.find(a => a.id === selectedAnomalyId) || null;\n  }, [anomalies, selectedAnomalyId]);\n\n  // Handle sort change\n  const handleSortChange = (newSortBy: 'date' | 'severity' | 'type') => {\n    if (sortBy === newSortBy) {\n      setSortOrder(sortOrder === 'asc' ? 'desc' : 'asc');\n    } else {\n      setSortBy(newSortBy);\n      setSortOrder('desc');\n    }\n  };\n\n  // Handle investigation\n  const handleInvestigate = (anomalyId: string) => {\n    setAnalysisInProgress(prev => ({ ...prev, [anomalyId]: true }));\n    onInvestigate(anomalyId);\n\n    // Simulate analysis progress\n    const duration = Math.random() * 3000 + 2000; // 2-5 seconds\n    setTimeout(() => {\n      setAnalysisInProgress(prev => ({ ...prev, [anomalyId]: false }));\n\n      // Generate analysis results based on anomaly type and severity\n      const anomaly = anomalies.find(a => a.id === anomalyId);\n      if (anomaly) {\n        const results: Anomaly['analysisResults'] = {};\n\n        if (anomaly.type === 'artifact') {\n          results.composition = ['Titanium', 'Unknown alloy', 'Trace elements'];\n          results.origin = Math.random() > 0.7 ? 'Unknown' : 'Ancient civilization';\n          results.age = `${Math.floor(Math.random() * 10000 + 1000)} years`;\n          results.potentialUses = ['Research', 'Technology advancement'];\n          results.dangerLevel = Math.random() * 10;\n        } else if (anomaly.type === 'signal') {\n          results.energySignature = `${Math.random() * 100 + 50} THz`;\n          results.origin = Math.random() > 0.5 ? 'Deep space' : 'Nearby star system';\n          results.potentialUses = ['Communication', 'Navigation'];\n          results.dangerLevel = Math.random() * 5;\n        } else if (anomaly.type === 'phenomenon') {\n          results.energySignature = `${Math.random() * 1000 + 100} PJ`;\n          results.composition = ['Energy fluctuations', 'Spatial distortions'];\n          results.potentialUses = ['Energy harvesting', 'Spatial research'];\n          results.dangerLevel = Math.random() * 8 + 2;\n        }\n\n        results.notes = 'Further investigation recommended.';\n\n        onAnalysisComplete(anomalyId, results);\n      }\n    }, duration);\n  };\n\n  // Toggle section expansion\n  const toggleSection = (sectionId: string) => {\n    setExpandedSections(prev => ({\n      ...prev,\n      [sectionId]: !prev[sectionId],\n    }));\n  };\n\n  // Get severity color\n  const getSeverityColor = (severity: Anomaly['severity']) => {\n    switch (severity) {\n      case 'high':\n        return 'text-red-500';\n      case 'medium':\n        return 'text-yellow-500';\n      case 'low':\n        return 'text-blue-500';\n      default:\n        return 'text-gray-500';\n    }\n  };\n\n  // Get type icon\n  const getTypeIcon = (type: Anomaly['type']) => {\n    switch (type) {\n      case 'artifact':\n        return <Database className=\"h-4 w-4\" />;\n      case 'signal':\n        return <Zap className=\"h-4 w-4\" />;\n      case 'phenomenon':\n        return <Microscope className=\"h-4 w-4\" />;\n      default:\n        return <AlertTriangle className=\"h-4 w-4\" />;\n    }\n  };\n\n  // Format date\n  const formatDate = (timestamp: number) => {\n    return new Date(timestamp).toLocaleDateString('en-US', {\n      year: 'numeric',\n      month: 'short',\n      day: 'numeric',\n    });\n  };\n\n  return (\n    <div className={`flex h-full flex-col bg-gray-900 ${className}`}>\n      {/* Header */}\n      <div className=\"flex items-center justify-between border-b border-gray-700 bg-gray-800 p-3\">\n        <div className=\"flex items-center space-x-2\">\n          <AlertTriangle className=\"h-5 w-5 text-yellow-500\" />\n          <h2 className=\"text-lg font-bold text-white\">Anomaly Analysis</h2>\n        </div>\n\n        <div className=\"flex items-center space-x-2\">\n          <select\n            value={filter}\n            onChange={e => setFilter(e.target.value as 'all' | 'investigated' | 'uninvestigated')}\n            className=\"rounded border border-gray-600 bg-gray-700 px-2 py-1 text-xs text-gray-300\"\n          >\n            <option value=\"all\">All Anomalies</option>\n            <option value=\"investigated\">Investigated</option>\n            <option value=\"uninvestigated\">Uninvestigated</option>\n          </select>\n        </div>\n      </div>\n\n      <div className=\"flex flex-grow overflow-hidden\">\n        {/* Anomaly list */}\n        <div className=\"w-1/3 overflow-y-auto border-r border-gray-700\">\n          {/* Sort controls */}\n          <div className=\"flex items-center justify-between border-b border-gray-700 bg-gray-800 p-2 text-xs text-gray-300\">\n            <button\n              onClick={() => handleSortChange('date')}\n              className={`flex items-center space-x-1 rounded px-2 py-1 ${\n                sortBy === 'date' ? 'bg-blue-900 text-blue-200' : 'hover:bg-gray-700'\n              }`}\n            >\n              <Clock className=\"h-3 w-3\" />\n              <span>Date</span>\n              {sortBy === 'date' && <span>{sortOrder === 'asc' ? 'â†‘' : 'â†“'}</span>}\n            </button>\n\n            <button\n              onClick={() => handleSortChange('severity')}\n              className={`flex items-center space-x-1 rounded px-2 py-1 ${\n                sortBy === 'severity' ? 'bg-blue-900 text-blue-200' : 'hover:bg-gray-700'\n              }`}\n            >\n              <AlertTriangle className=\"h-3 w-3\" />\n              <span>Severity</span>\n              {sortBy === 'severity' && <span>{sortOrder === 'asc' ? 'â†‘' : 'â†“'}</span>}\n            </button>\n\n            <button\n              onClick={() => handleSortChange('type')}\n              className={`flex items-center space-x-1 rounded px-2 py-1 ${\n                sortBy === 'type' ? 'bg-blue-900 text-blue-200' : 'hover:bg-gray-700'\n              }`}\n            >\n              <FileText className=\"h-3 w-3\" />\n              <span>Type</span>\n              {sortBy === 'type' && <span>{sortOrder === 'asc' ? 'â†‘' : 'â†“'}</span>}\n            </button>\n          </div>\n\n          {/* Anomaly items */}\n          <div className=\"divide-y divide-gray-700\">\n            {sortedAnomalies.length === 0 ? (\n              <div className=\"p-4 text-center text-gray-400\">\n                No anomalies found matching the current filter.\n              </div>\n            ) : (\n              sortedAnomalies.map(anomaly => (\n                <div\n                  key={anomaly.id}\n                  className={`cursor-pointer p-3 transition-colors ${\n                    selectedAnomalyId === anomaly.id ? 'bg-blue-900/30' : 'hover:bg-gray-800'\n                  }`}\n                  onClick={() => setSelectedAnomalyId(anomaly.id)}\n                >\n                  <div className=\"flex items-start justify-between\">\n                    <div className=\"flex items-start space-x-2\">\n                      <div className={`mt-0.5 ${getSeverityColor(anomaly.severity)}`}>\n                        {getTypeIcon(anomaly.type)}\n                      </div>\n                      <div>\n                        <h3 className=\"text-sm font-medium text-white\">\n                          {anomaly.description.length > 30\n                            ? `${anomaly.description.substring(0, 30)}...`\n                            : anomaly.description}\n                        </h3>\n                        <p className=\"text-xs text-gray-400\">\n                          {anomaly.sectorName} â€¢ {formatDate(anomaly.discoveryDate)}\n                        </p>\n                      </div>\n                    </div>\n\n                    <div className=\"flex flex-col items-end\">\n                      <span\n                        className={`rounded px-1.5 py-0.5 text-xs font-medium ${\n                          anomaly.severity === 'high'\n                            ? 'bg-red-900/50 text-red-300'\n                            : anomaly.severity === 'medium'\n                              ? 'bg-yellow-900/50 text-yellow-300'\n                              : 'bg-blue-900/50 text-blue-300'\n                        }`}\n                      >\n                        {anomaly.severity}\n                      </span>\n\n                      <span className=\"mt-1 text-xs text-gray-400\">\n                        {anomaly.investigated ? 'Investigated' : 'Uninvestigated'}\n                      </span>\n                    </div>\n                  </div>\n                </div>\n              ))\n            )}\n          </div>\n        </div>\n\n        {/* Anomaly details */}\n        <div className=\"flex-grow overflow-y-auto\">\n          {selectedAnomaly ? (\n            <div className=\"p-4\">\n              <div className=\"mb-4 flex items-start justify-between\">\n                <div>\n                  <h2 className=\"mb-1 text-xl font-bold text-white\">\n                    {selectedAnomaly.description}\n                  </h2>\n                  <p className=\"text-sm text-gray-400\">\n                    Discovered on {formatDate(selectedAnomaly.discoveryDate)} in{' '}\n                    {selectedAnomaly.sectorName}\n                  </p>\n                </div>\n\n                <div\n                  className={`rounded px-2 py-1 text-sm font-medium ${\n                    selectedAnomaly.severity === 'high'\n                      ? 'bg-red-900/50 text-red-300'\n                      : selectedAnomaly.severity === 'medium'\n                        ? 'bg-yellow-900/50 text-yellow-300'\n                        : 'bg-blue-900/50 text-blue-300'\n                  }`}\n                >\n                  {selectedAnomaly.severity.toUpperCase()} {selectedAnomaly.type.toUpperCase()}\n                </div>\n              </div>\n\n              {/* Coordinates */}\n              <div className=\"mb-4 rounded-lg bg-gray-800 p-3\">\n                <div className=\"flex items-center justify-between\">\n                  <div className=\"flex items-center space-x-2\">\n                    <MapIcon className=\"h-4 w-4 text-blue-400\" />\n                    <span className=\"text-sm text-gray-300\">Coordinates</span>\n                  </div>\n                  <div className=\"font-mono text-sm text-white\">\n                    X: {selectedAnomaly.coordinates.x.toFixed(2)}, Y:{' '}\n                    {selectedAnomaly.coordinates.y.toFixed(2)}\n                  </div>\n                </div>\n              </div>\n\n              {/* Analysis section */}\n              <div className=\"mb-4 overflow-hidden rounded-lg bg-gray-800\">\n                <div\n                  className=\"flex cursor-pointer items-center justify-between p-3\"\n                  onClick={() => toggleSection('analysis')}\n                >\n                  <div className=\"flex items-center space-x-2\">\n                    <Microscope className=\"h-4 w-4 text-purple-400\" />\n                    <span className=\"text-sm font-medium text-white\">Analysis</span>\n                  </div>\n                  {expandedSections['analysis'] ? (\n                    <ChevronUp className=\"h-4 w-4 text-gray-400\" />\n                  ) : (\n                    <ChevronDown className=\"h-4 w-4 text-gray-400\" />\n                  )}\n                </div>\n\n                {expandedSections['analysis'] && (\n                  <div className=\"border-t border-gray-700 p-3 pt-0\">\n                    {selectedAnomaly.investigated ? (\n                      <div className=\"space-y-3\">\n                        {selectedAnomaly.analysisResults?.composition && (\n                          <div>\n                            <h4 className=\"mb-1 text-xs text-gray-400\">Composition</h4>\n                            <div className=\"flex flex-wrap gap-1\">\n                              {selectedAnomaly.analysisResults.composition.map((item, index) => (\n                                <span\n                                  key={index}\n                                  className=\"rounded bg-gray-700 px-2 py-0.5 text-xs text-gray-300\"\n                                >\n                                  {item}\n                                </span>\n                              ))}\n                            </div>\n                          </div>\n                        )}\n\n                        {selectedAnomaly.analysisResults?.origin && (\n                          <div>\n                            <h4 className=\"mb-1 text-xs text-gray-400\">Origin</h4>\n                            <p className=\"text-sm text-white\">\n                              {selectedAnomaly.analysisResults.origin}\n                            </p>\n                          </div>\n                        )}\n\n                        {selectedAnomaly.analysisResults?.age && (\n                          <div>\n                            <h4 className=\"mb-1 text-xs text-gray-400\">Estimated Age</h4>\n                            <p className=\"text-sm text-white\">\n                              {selectedAnomaly.analysisResults.age}\n                            </p>\n                          </div>\n                        )}\n\n                        {selectedAnomaly.analysisResults?.energySignature && (\n                          <div>\n                            <h4 className=\"mb-1 text-xs text-gray-400\">Energy Signature</h4>\n                            <p className=\"text-sm text-white\">\n                              {selectedAnomaly.analysisResults.energySignature}\n                            </p>\n                          </div>\n                        )}\n\n                        {selectedAnomaly.analysisResults?.potentialUses && (\n                          <div>\n                            <h4 className=\"mb-1 text-xs text-gray-400\">Potential Uses</h4>\n                            <div className=\"flex flex-wrap gap-1\">\n                              {selectedAnomaly.analysisResults.potentialUses.map((use, index) => (\n                                <span\n                                  key={index}\n                                  className=\"rounded bg-blue-900/30 px-2 py-0.5 text-xs text-blue-300\"\n                                >\n                                  {use}\n                                </span>\n                              ))}\n                            </div>\n                          </div>\n                        )}\n\n                        {selectedAnomaly.analysisResults?.dangerLevel !== undefined && (\n                          <div>\n                            <h4 className=\"mb-1 text-xs text-gray-400\">Danger Level</h4>\n                            <div className=\"h-2 w-full overflow-hidden rounded-full bg-gray-700\">\n                              <div\n                                className={`h-full ${\n                                  selectedAnomaly.analysisResults.dangerLevel > 7\n                                    ? 'bg-red-500'\n                                    : selectedAnomaly.analysisResults.dangerLevel > 4\n                                      ? 'bg-yellow-500'\n                                      : 'bg-green-500'\n                                }`}\n                                style={{\n                                  width: `${selectedAnomaly.analysisResults.dangerLevel * 10}%`,\n                                }}\n                              ></div>\n                            </div>\n                            <div className=\"mt-1 flex justify-between text-xs text-gray-500\">\n                              <span>Safe</span>\n                              <span>Moderate</span>\n                              <span>Dangerous</span>\n                            </div>\n                          </div>\n                        )}\n\n                        {selectedAnomaly.analysisResults?.notes && (\n                          <div>\n                            <h4 className=\"mb-1 text-xs text-gray-400\">Notes</h4>\n                            <p className=\"text-sm text-white\">\n                              {selectedAnomaly.analysisResults.notes}\n                            </p>\n                          </div>\n                        )}\n                      </div>\n                    ) : (\n                      <div className=\"py-4 text-center\">\n                        {analysisInProgress[selectedAnomaly.id] ? (\n                          <div className=\"space-y-3\">\n                            <div className=\"mx-auto h-8 w-8 animate-spin rounded-full border-2 border-blue-500 border-t-transparent\"></div>\n                            <p className=\"text-sm text-gray-300\">Analysis in progress...</p>\n                          </div>\n                        ) : (\n                          <div className=\"space-y-3\">\n                            <p className=\"text-sm text-gray-300\">\n                              This anomaly has not been investigated yet.\n                            </p>\n                            <button\n                              onClick={() => handleInvestigate(selectedAnomaly.id)}\n                              className=\"rounded bg-blue-700 px-3 py-1.5 text-white transition-colors hover:bg-blue-600\"\n                            >\n                              Begin Analysis\n                            </button>\n                          </div>\n                        )}\n                      </div>\n                    )}\n                  </div>\n                )}\n              </div>\n\n              {/* Visuals section */}\n              <div className=\"mb-4 overflow-hidden rounded-lg bg-gray-800\">\n                <div\n                  className=\"flex cursor-pointer items-center justify-between p-3\"\n                  onClick={() => toggleSection('visuals')}\n                >\n                  <div className=\"flex items-center space-x-2\">\n                    <FileText className=\"h-4 w-4 text-green-400\" />\n                    <span className=\"text-sm font-medium text-white\">Visual Data</span>\n                  </div>\n                  {expandedSections['visuals'] ? (\n                    <ChevronUp className=\"h-4 w-4 text-gray-400\" />\n                  ) : (\n                    <ChevronDown className=\"h-4 w-4 text-gray-400\" />\n                  )}\n                </div>\n\n                {expandedSections['visuals'] && (\n                  <div className=\"border-t border-gray-700 p-3 pt-0\">\n                    {selectedAnomaly.images && selectedAnomaly.images.length > 0 ? (\n                      <div className=\"grid grid-cols-2 gap-2\">\n                        {selectedAnomaly.images.map((image, index) => (\n                          <div key={index} className=\"overflow-hidden rounded bg-gray-700\">\n                            <img\n                              src={image}\n                              alt={`Anomaly visual ${index + 1}`}\n                              className=\"h-auto w-full\"\n                            />\n                          </div>\n                        ))}\n                      </div>\n                    ) : (\n                      <div className=\"py-4 text-center\">\n                        <p className=\"text-sm text-gray-300\">No visual data available.</p>\n                        {!selectedAnomaly.investigated && (\n                          <p className=\"mt-1 text-xs text-gray-400\">\n                            Visual data will be available after investigation.\n                          </p>\n                        )}\n                      </div>\n                    )}\n                  </div>\n                )}\n              </div>\n\n              {/* Recommendations section */}\n              <div className=\"overflow-hidden rounded-lg bg-gray-800\">\n                <div\n                  className=\"flex cursor-pointer items-center justify-between p-3\"\n                  onClick={() => toggleSection('recommendations')}\n                >\n                  <div className=\"flex items-center space-x-2\">\n                    <ArrowRight className=\"h-4 w-4 text-yellow-400\" />\n                    <span className=\"text-sm font-medium text-white\">Recommendations</span>\n                  </div>\n                  {expandedSections['recommendations'] ? (\n                    <ChevronUp className=\"h-4 w-4 text-gray-400\" />\n                  ) : (\n                    <ChevronDown className=\"h-4 w-4 text-gray-400\" />\n                  )}\n                </div>\n\n                {expandedSections['recommendations'] && (\n                  <div className=\"border-t border-gray-700 p-3 pt-0\">\n                    {selectedAnomaly.investigated ? (\n                      <div className=\"space-y-2\">\n                        {selectedAnomaly.type === 'artifact' && (\n                          <>\n                            <div className=\"flex items-start space-x-2\">\n                              <div className=\"mt-1 h-4 w-4 flex-shrink-0 rounded-full bg-blue-500\"></div>\n                              <p className=\"text-sm text-gray-300\">\n                                Dispatch research team to study the artifact's composition and\n                                technology.\n                              </p>\n                            </div>\n                            <div className=\"flex items-start space-x-2\">\n                              <div className=\"mt-1 h-4 w-4 flex-shrink-0 rounded-full bg-green-500\"></div>\n                              <p className=\"text-sm text-gray-300\">\n                                Consider establishing a research outpost for long-term study.\n                              </p>\n                            </div>\n                          </>\n                        )}\n\n                        {selectedAnomaly.type === 'signal' && (\n                          <>\n                            <div className=\"flex items-start space-x-2\">\n                              <div className=\"mt-1 h-4 w-4 flex-shrink-0 rounded-full bg-blue-500\"></div>\n                              <p className=\"text-sm text-gray-300\">\n                                Deploy signal amplifiers to enhance and decode the transmission.\n                              </p>\n                            </div>\n                            <div className=\"flex items-start space-x-2\">\n                              <div className=\"mt-1 h-4 w-4 flex-shrink-0 rounded-full bg-green-500\"></div>\n                              <p className=\"text-sm text-gray-300\">\n                                Establish a monitoring station to track signal changes over time.\n                              </p>\n                            </div>\n                          </>\n                        )}\n\n                        {selectedAnomaly.type === 'phenomenon' && (\n                          <>\n                            <div className=\"flex items-start space-x-2\">\n                              <div className=\"mt-1 h-4 w-4 flex-shrink-0 rounded-full bg-blue-500\"></div>\n                              <p className=\"text-sm text-gray-300\">\n                                Deploy sensor array to monitor energy fluctuations and spatial\n                                distortions.\n                              </p>\n                            </div>\n                            <div className=\"flex items-start space-x-2\">\n                              <div className=\"mt-1 h-4 w-4 flex-shrink-0 rounded-full bg-yellow-500\"></div>\n                              <p className=\"text-sm text-gray-300\">\n                                Maintain safe distance until phenomenon stability can be determined.\n                              </p>\n                            </div>\n                          </>\n                        )}\n\n                        <div className=\"flex items-start space-x-2\">\n                          <div className=\"mt-1 h-4 w-4 flex-shrink-0 rounded-full bg-purple-500\"></div>\n                          <p className=\"text-sm text-gray-300\">\n                            Allocate resources for further investigation and potential exploitation.\n                          </p>\n                        </div>\n                      </div>\n                    ) : (\n                      <div className=\"py-4 text-center\">\n                        <p className=\"text-sm text-gray-300\">\n                          Recommendations will be available after investigation.\n                        </p>\n                      </div>\n                    )}\n                  </div>\n                )}\n              </div>\n            </div>\n          ) : (\n            <div className=\"flex h-full flex-col items-center justify-center text-gray-400\">\n              <AlertTriangle className=\"mb-4 h-12 w-12 opacity-50\" />\n              <p className=\"text-lg\">Select an anomaly to view details</p>\n              <p className=\"mt-2 text-sm\">\n                {sortedAnomalies.length === 0\n                  ? 'No anomalies match the current filter'\n                  : `${sortedAnomalies.length} anomalies available`}\n              </p>\n            </div>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/AutomatedSectorScanner.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/CanvasChartExample.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/DataAnalysisSystem.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_DatasetInfo' is defined but never used. Allowed unused vars must match /^ignored|^temp/u.","line":99,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":99,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  Button,\n  CircularProgress,\n  Divider,\n  Grid,\n  Paper,\n  Tab,\n  Tabs,\n  Typography,\n} from '@mui/material';\nimport { Compass, Database, Layers, Map, RadioTower } from 'lucide-react';\nimport * as React from 'react';\nimport { useCallback, useEffect } from 'react';\nimport { useDataAnalysis } from '../../contexts/DataAnalysisContext';\nimport { moduleEventBus } from '../../lib/events/ModuleEventBus';\nimport { EventType } from '../../types/events/EventTypes';\nimport { StandardizedEvent } from '../../types/events/StandardizedEvents';\nimport {\n  AnalysisConfig,\n  AnalysisResult,\n  DataPoint,\n  Dataset,\n} from '../../types/exploration/DataAnalysisTypes';\nimport AnalysisConfigManager from './AnalysisConfigManager';\nimport DataFilterPanel from './DataFilterPanel';\nimport DataPointVirtualList from './DataPointVirtualList';\nimport DatasetManager from './DatasetManager';\nimport ResultsPanel from './ResultsPanel';\nimport { AnalysisVisualization } from './visualizations/AnalysisVisualization';\n\ninterface DataAnalysisSystemProps {\n  className?: string;\n}\n\n// Result visualization component\ninterface ResultVisualizationProps {\n  result: AnalysisResult;\n  config?: AnalysisConfig;\n}\n\nfunction ResultVisualization({ result, config }: ResultVisualizationProps) {\n  // Handle different result states\n  if (result?.status === 'pending' || result?.status === 'processing') {\n    return (\n      <div className=\"flex h-[300px] items-center justify-center\">\n        <CircularProgress />\n        <Typography variant=\"body1\" sx={{ ml: 2 }}>\n          Processing analysis...\n        </Typography>\n      </div>\n    );\n  }\n\n  if (result?.status === 'failed') {\n    return (\n      <div className=\"rounded bg-red-50 p-3\">\n        <Typography variant=\"h6\" color=\"error\">\n          Analysis Failed\n        </Typography>\n        <Typography variant=\"body1\">{result?.error || 'Unknown error occurred'}</Typography>\n      </div>\n    );\n  }\n\n  return (\n    <div>\n      {result?.summary && (\n        <Typography variant=\"body1\" sx={{ mb: 2 }}>\n          {result?.summary}\n        </Typography>\n      )}\n\n      {result?.insights && result?.insights.length > 0 && (\n        <div className=\"mb-2\">\n          <Typography variant=\"h6\">Key Insights</Typography>\n          <ul>\n            {result?.insights.map((insight, index) => (\n              <li key={index}>\n                <Typography variant=\"body2\">{insight}</Typography>\n              </li>\n            ))}\n          </ul>\n        </div>\n      )}\n\n      {config && <AnalysisVisualization result={result} config={config} />}\n      {!config && (\n        <Typography variant=\"body2\">No configuration available for visualization</Typography>\n      )}\n    </div>\n  );\n}\n\n// Dataset info component\ninterface DatasetInfoProps {\n  dataset: Dataset;\n}\n\nfunction _DatasetInfo({ dataset }: DatasetInfoProps) {\n  // Count data points by type\n  const counts = React.useMemo(() => {\n    const typeCounts = {\n      sector: 0,\n      anomaly: 0,\n      resource: 0,\n    };\n\n    dataset.dataPoints.forEach(dp => {\n      if (dp.type in typeCounts) {\n        typeCounts[dp.type as keyof typeof typeCounts]++;\n      }\n    });\n\n    return typeCounts;\n  }, [dataset]);\n\n  // Get icon for dataset source\n  const getSourceIcon = (source: string) => {\n    switch (source) {\n      case 'sectors':\n        return <Map className=\"mr-2\" size={16} />;\n      case 'anomalies':\n        return <RadioTower className=\"mr-2\" size={16} />;\n      case 'resources':\n        return <Layers className=\"mr-2\" size={16} />;\n      case 'mixed':\n        return <Compass className=\"mr-2\" size={16} />;\n      default:\n        return <Database className=\"mr-2\" size={16} />;\n    }\n  };\n\n  return (\n    <div className=\"mb-4 rounded border bg-white p-4\">\n      <div className=\"mb-2 flex items-center\">\n        {getSourceIcon(dataset.source)}\n        <h3 className=\"font-medium\">{dataset.name}</h3>\n      </div>\n\n      <p className=\"mb-2 text-sm text-gray-600\">{dataset.description}</p>\n\n      <div className=\"mb-2 grid grid-cols-3 gap-2 text-sm\">\n        <div className=\"rounded bg-blue-50 p-2 text-center\">\n          <div className=\"font-medium text-blue-700\">{counts.sector}</div>\n          <div className=\"text-xs text-blue-600\">Sectors</div>\n        </div>\n        <div className=\"rounded bg-purple-50 p-2 text-center\">\n          <div className=\"font-medium text-purple-700\">{counts.anomaly}</div>\n          <div className=\"text-xs text-purple-600\">Anomalies</div>\n        </div>\n        <div className=\"rounded bg-green-50 p-2 text-center\">\n          <div className=\"font-medium text-green-700\">{counts.resource}</div>\n          <div className=\"text-xs text-green-600\">Resources</div>\n        </div>\n      </div>\n\n      <div className=\"text-xs text-gray-500\">\n        <div>\n          <span className=\"font-medium\">Created:</span>{' '}\n          {new Date(dataset.createdAt).toLocaleDateString()}\n        </div>\n        <div>\n          <span className=\"font-medium\">Updated:</span>{' '}\n          {new Date(dataset.updatedAt).toLocaleDateString()}\n        </div>\n        <div>\n          <span className=\"font-medium\">Total Points:</span> {dataset.dataPoints.length}\n        </div>\n      </div>\n    </div>\n  );\n}\n\n// Utility function that uses _DatasetInfo for development purposes\nconst _logDatasetDetails = (dataset: Dataset): void => {\n  if (process.env.NODE_ENV === 'development') {\n    console.warn(`Dataset loaded: ${dataset.id} with ${dataset.dataPoints.length} data points`);\n    // In a real implementation, we might render _DatasetInfo to a debug panel\n  }\n};\n\nexport function DataAnalysisSystem({ className = '' }: DataAnalysisSystemProps) {\n  const {\n    datasets,\n    analysisConfigs,\n    analysisResults,\n    createDataset,\n    updateDataset,\n    deleteDataset,\n    createAnalysisConfig,\n    updateAnalysisConfig,\n    deleteAnalysisConfig,\n    runAnalysis,\n    getAnalysisResultsByConfigId,\n    refreshData,\n    filterDataset,\n  } = useDataAnalysis();\n\n  const [selectedDataset, setSelectedDataset] = React.useState<Dataset | null>(null);\n  const [selectedConfig, setSelectedConfig] = React.useState<AnalysisConfig | null>(null);\n  const [activeTab, setActiveTab] = React.useState<number>(0);\n  const [filteredData, setFilteredData] = React.useState<DataPoint[]>([]);\n  const [filters, setFilters] = React.useState<\n    Array<{\n      field: string;\n      operator:\n        | 'equals'\n        | 'notEquals'\n        | 'greaterThan'\n        | 'lessThan'\n        | 'contains'\n        | 'notContains'\n        | 'between';\n      value: string | number | boolean | string[] | [number, number];\n    }>\n  >([]);\n  const [isLoading, setIsLoading] = React.useState<boolean>(false);\n  const [lastRefresh, setLastRefresh] = React.useState<number>(Date.now());\n  const [selectedDataPoint, setSelectedDataPoint] = React.useState<DataPoint | null>(null);\n\n  // Effect to handle initial data loading\n  React.useEffect(() => {\n    refreshDatasets();\n  }, []);\n\n  // Effect to apply filters when they change\n  React.useEffect(() => {\n    if (selectedDataset && filters.length > 0) {\n      const filtered = filterDataset(selectedDataset.id, filters);\n      setFilteredData(filtered);\n    } else if (selectedDataset) {\n      setFilteredData(selectedDataset.dataPoints);\n    } else {\n      setFilteredData([]);\n    }\n  }, [selectedDataset, filters, filterDataset, lastRefresh]);\n\n  // Get latest results for the selected config\n  const currentResults = selectedConfig\n    ? getAnalysisResultsByConfigId(selectedConfig.id).sort(\n        (a, b) => (b.startTime ?? 0) - (a.startTime ?? 0)\n      )\n    : [];\n\n  const latestResult = currentResults.length > 0 ? currentResults[0] : null;\n\n  // Handle tab change\n  const handleTabChange = (_event: React.SyntheticEvent, newValue: number) => {\n    setActiveTab(newValue);\n  };\n\n  // Handle dataset selection with standardized events\n  const handleSelectDataset = useCallback(\n    (dataset: Dataset) => {\n      setSelectedDataset(dataset);\n      if (filters.length > 0) {\n        const filtered = filterDataset(dataset.id, filters);\n        setFilteredData(filtered);\n      } else {\n        setFilteredData(dataset.dataPoints);\n      }\n\n      // Emit dataset selection event\n      const event: StandardizedEvent = {\n        type: EventType.MODULE_UPDATED,\n        moduleId: dataset.id,\n        moduleType: 'exploration',\n        timestamp: Date.now(),\n        data: {\n          action: 'select_dataset',\n          datasetId: dataset.id,\n          filterCount: filters.length,\n        },\n      };\n      moduleEventBus.emit(event);\n    },\n    [filters]\n  );\n\n  // Handle config selection with standardized events\n  const handleSelectConfig = useCallback((config: AnalysisConfig) => {\n    setSelectedConfig(config);\n\n    // Emit config selection event\n    const event: StandardizedEvent = {\n      type: EventType.MODULE_UPDATED,\n      moduleId: config.id,\n      moduleType: 'exploration',\n      timestamp: Date.now(),\n      data: {\n        action: 'select_config',\n        configId: config.id,\n        configType: config.type,\n      },\n    };\n    moduleEventBus.emit(event);\n  }, []);\n\n  // Handle running analysis with standardized events\n  const handleRunAnalysis = useCallback(async () => {\n    if (!selectedConfig) return;\n\n    setIsLoading(true);\n    try {\n      await runAnalysis(selectedConfig.id);\n\n      // Emit analysis complete event\n      const event: StandardizedEvent = {\n        type: EventType.MODULE_UPDATED,\n        moduleId: selectedConfig.id,\n        moduleType: 'exploration',\n        timestamp: Date.now(),\n        data: {\n          action: 'run_analysis',\n          configId: selectedConfig.id,\n          configType: selectedConfig.type,\n          status: 'complete',\n        },\n      };\n      moduleEventBus.emit(event);\n    } catch (error) {\n      console.error('Error running analysis:', error);\n\n      // Emit analysis error event\n      const event: StandardizedEvent = {\n        type: EventType.MODULE_UPDATED,\n        moduleId: selectedConfig.id,\n        moduleType: 'exploration',\n        timestamp: Date.now(),\n        data: {\n          action: 'run_analysis',\n          configId: selectedConfig.id,\n          configType: selectedConfig.type,\n          status: 'error',\n          error: error instanceof Error ? error.message : 'Unknown error',\n        },\n      };\n      moduleEventBus.emit(event);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [selectedConfig]);\n\n  // Refresh datasets from the data collection service\n  const refreshDatasets = () => {\n    setIsLoading(true);\n    refreshData();\n    setLastRefresh(Date.now());\n    setIsLoading(false);\n  };\n\n  // Handle filter changes with standardized events\n  const handleFilterChange = useCallback(\n    (\n      newFilters: Array<{\n        field: string;\n        operator:\n          | 'equals'\n          | 'notEquals'\n          | 'greaterThan'\n          | 'lessThan'\n          | 'contains'\n          | 'notContains'\n          | 'between';\n        value: string | number | boolean | string[] | [number, number];\n      }>\n    ) => {\n      setFilters(newFilters);\n      if (selectedDataset) {\n        const filtered = filterDataset(selectedDataset.id, newFilters);\n        setFilteredData(filtered);\n\n        // Emit filter change event\n        const event: StandardizedEvent = {\n          type: EventType.MODULE_UPDATED,\n          moduleId: selectedDataset.id,\n          moduleType: 'exploration',\n          timestamp: Date.now(),\n          data: {\n            action: 'update_filters',\n            datasetId: selectedDataset.id,\n            filterCount: newFilters.length,\n            filteredCount: filtered.length,\n          },\n        };\n        moduleEventBus.emit(event);\n      }\n    },\n    [selectedDataset]\n  );\n\n  // Handle data point selection with standardized events\n  const handleSelectDataPoint = useCallback(\n    (dataPoint: DataPoint) => {\n      setSelectedDataPoint(dataPoint);\n\n      // Emit data point selection event\n      const event: StandardizedEvent = {\n        type: EventType.MODULE_UPDATED,\n        moduleId: dataPoint.id,\n        moduleType: 'exploration',\n        timestamp: Date.now(),\n        data: {\n          action: 'select_data_point',\n          dataPointId: dataPoint.id,\n          datasetId: selectedDataset?.id,\n        },\n      };\n      moduleEventBus.emit(event);\n    },\n    [selectedDataset]\n  );\n\n  // Use the utility function that references _DatasetInfo\n  React.useEffect(() => {\n    if (selectedDataset) {\n      _logDatasetDetails(selectedDataset);\n    }\n  }, [selectedDataset]);\n\n  // Cleanup subscriptions on unmount\n  useEffect(() => {\n    const cleanup = () => {\n      // Any cleanup needed for event subscriptions\n    };\n\n    return cleanup;\n  }, []);\n\n  return (\n    <div className={className}>\n      <Typography variant=\"h6\" gutterBottom>\n        Data Analysis System\n      </Typography>\n\n      <Tabs value={activeTab} onChange={handleTabChange} sx={{ mb: 2 }}>\n        <Tab label=\"Datasets\" />\n        <Tab label=\"Analysis\" />\n        <Tab label=\"Results\" />\n      </Tabs>\n\n      <Grid container spacing={2}>\n        {/* Left Panel */}\n        <Grid item xs={12} md={3}>\n          {activeTab === 0 && (\n            <Paper sx={{ p: 2 }}>\n              <DatasetManager\n                datasets={datasets}\n                selectedDataset={selectedDataset}\n                onSelectDataset={handleSelectDataset}\n                onCreateDataset={createDataset}\n                onUpdateDataset={updateDataset}\n                onDeleteDataset={deleteDataset}\n              />\n            </Paper>\n          )}\n          {activeTab === 1 && (\n            <Paper sx={{ p: 2 }}>\n              <AnalysisConfigManager\n                configs={analysisConfigs}\n                selectedConfig={selectedConfig}\n                onSelectConfig={handleSelectConfig}\n                onCreateConfig={createAnalysisConfig}\n                onUpdateConfig={updateAnalysisConfig}\n                onDeleteConfig={deleteAnalysisConfig}\n                datasets={datasets}\n              />\n            </Paper>\n          )}\n          {activeTab === 2 && (\n            <Paper sx={{ p: 2 }}>\n              <ResultsPanel\n                results={analysisResults}\n                configs={analysisConfigs}\n                onSelectResult={result => {\n                  // Find and select the config that was used for this result\n                  const config = analysisConfigs.find(c => c.id === result?.analysisConfigId);\n                  if (config) {\n                    setSelectedConfig(config);\n                    setActiveTab(1); // Switch to Analysis tab\n                  }\n                }}\n              />\n            </Paper>\n          )}\n        </Grid>\n\n        {/* Center Panel */}\n        <Grid item xs={12} md={activeTab === 0 ? 5 : 9}>\n          {activeTab === 0 && selectedDataset && (\n            <Paper sx={{ p: 2 }}>\n              <div className=\"mb-2\">\n                <Typography variant=\"h6\">{selectedDataset.name}</Typography>\n                <Typography variant=\"body2\" color=\"text.secondary\">\n                  {selectedDataset.description}\n                </Typography>\n                <div className=\"mt-1 flex items-center\">\n                  <Button\n                    size=\"small\"\n                    onClick={refreshDatasets}\n                    disabled={isLoading}\n                    sx={{ mr: 1 }}\n                  >\n                    {isLoading ? <CircularProgress size={20} /> : 'Refresh'}\n                  </Button>\n                  <Typography variant=\"caption\" color=\"text.secondary\">\n                    {filteredData.length} data points\n                    {filters.length > 0\n                      ? ` (filtered from ${selectedDataset.dataPoints.length})`\n                      : ''}\n                  </Typography>\n                </div>\n              </div>\n\n              <Divider sx={{ my: 2 }} />\n\n              {/* Replace static list with virtualized list */}\n              <div className=\"h-[400px]\">\n                <DataPointVirtualList\n                  dataPoints={filteredData}\n                  isLoading={isLoading}\n                  onSelectDataPoint={handleSelectDataPoint}\n                  selectedDataPointId={selectedDataPoint?.id}\n                  height=\"100%\"\n                />\n              </div>\n            </Paper>\n          )}\n\n          {activeTab === 1 && selectedConfig && (\n            <Paper sx={{ p: 2 }}>\n              <div className=\"mb-2\">\n                <Typography variant=\"h6\">{selectedConfig.name}</Typography>\n                <Typography variant=\"body2\">{selectedConfig.description}</Typography>\n                <div className=\"mt-2\">\n                  <Button variant=\"contained\" onClick={handleRunAnalysis} disabled={isLoading}>\n                    {isLoading ? <CircularProgress size={24} /> : 'Run Analysis'}\n                  </Button>\n                </div>\n              </div>\n\n              <Divider sx={{ my: 2 }} />\n\n              {/* Results visualization */}\n              {latestResult && (\n                <ResultVisualization result={latestResult} config={selectedConfig} />\n              )}\n            </Paper>\n          )}\n        </Grid>\n\n        {/* Right Panel - only visible in dataset tab */}\n        {activeTab === 0 && (\n          <Grid item xs={12} md={4}>\n            <Paper sx={{ p: 2 }}>\n              <Typography variant=\"h6\" gutterBottom>\n                Filters\n              </Typography>\n              <DataFilterPanel\n                _datasetId={selectedDataset?.id ?? ''}\n                filters={filters}\n                onFilterChange={handleFilterChange}\n              />\n\n              {selectedDataPoint && (\n                <>\n                  <Divider sx={{ my: 2 }} />\n                  <Typography variant=\"h6\" gutterBottom>\n                    Selected Data Point\n                  </Typography>\n                  <div className=\"rounded bg-gray-50 p-1\">\n                    <Typography variant=\"subtitle1\">{selectedDataPoint.name}</Typography>\n                    <Typography variant=\"caption\" display=\"block\" color=\"text.secondary\">\n                      Type: {selectedDataPoint.type} | ID: {selectedDataPoint.id}\n                    </Typography>\n                    <Typography variant=\"caption\" display=\"block\" color=\"text.secondary\">\n                      Coordinates: ({selectedDataPoint.coordinates.x},{' '}\n                      {selectedDataPoint.coordinates.y})\n                    </Typography>\n                    <Typography variant=\"caption\" display=\"block\" color=\"text.secondary\">\n                      Date: {new Date(selectedDataPoint.date).toLocaleString()}\n                    </Typography>\n\n                    <Typography variant=\"overline\" display=\"block\" sx={{ mt: 1 }}>\n                      Properties\n                    </Typography>\n\n                    <div className=\"ml-1\">\n                      {Object.entries(selectedDataPoint.properties).map(([key, value]) => (\n                        <Typography key={key} variant=\"body2\">\n                          <strong>{key}:</strong>{' '}\n                          {typeof value === 'object' ? JSON.stringify(value) : String(value)}\n                        </Typography>\n                      ))}\n                    </div>\n\n                    {selectedDataPoint.metadata &&\n                      Object.keys(selectedDataPoint.metadata).length > 0 && (\n                        <>\n                          <Typography variant=\"overline\" display=\"block\" sx={{ mt: 1 }}>\n                            Metadata\n                          </Typography>\n                          <div className=\"ml-1\">\n                            {Object.entries(selectedDataPoint.metadata).map(([key, value]) => (\n                              <Typography key={key} variant=\"body2\">\n                                <strong>{key}:</strong>{' '}\n                                {typeof value === 'object' ? JSON.stringify(value) : String(value)}\n                              </Typography>\n                            ))}\n                          </div>\n                        </>\n                      )}\n                  </div>\n                </>\n              )}\n            </Paper>\n          </Grid>\n        )}\n      </Grid>\n    </div>\n  );\n}\n\nexport default DataAnalysisSystem;\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/DataFilterPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/DataPointVirtualList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/DatasetManager.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'onUpdateDataset' is defined but never used.","line":38,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":38,"endColumn":18}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import AddIcon from '@mui/icons-material/Add';\nimport DeleteIcon from '@mui/icons-material/Delete';\nimport {\n  Button,\n  Dialog,\n  DialogActions,\n  DialogContent,\n  DialogTitle,\n  FormControl,\n  IconButton,\n  InputLabel,\n  List,\n  ListItem,\n  ListItemText,\n  MenuItem,\n  Select,\n  TextField,\n  Typography,\n} from '@mui/material';\nimport * as React from 'react';\nimport { useState } from 'react';\nimport { Dataset } from '../../types/exploration/DataAnalysisTypes';\n\ninterface DatasetManagerProps {\n  datasets: Dataset[];\n  selectedDataset: Dataset | null;\n  onSelectDataset: (dataset: Dataset) => void;\n  onCreateDataset: (dataset: Omit<Dataset, 'id' | 'createdAt' | 'updatedAt'>) => string;\n  onUpdateDataset: (id: string, updates: Partial<Dataset>) => void;\n  onDeleteDataset: (id: string) => void;\n}\n\nconst DatasetManager: React.FC<DatasetManagerProps> = ({\n  datasets,\n  selectedDataset,\n  onSelectDataset,\n  onCreateDataset,\n  onUpdateDataset,\n  onDeleteDataset,\n}) => {\n  const [openDialog, setOpenDialog] = useState(false);\n  const [newDatasetName, setNewDatasetName] = useState('');\n  const [newDatasetDescription, setNewDatasetDescription] = useState('');\n  const [newDatasetSource, setNewDatasetSource] = useState<\n    'sectors' | 'anomalies' | 'resources' | 'mixed'\n  >('sectors');\n\n  const handleCreateDataset = () => {\n    if (!newDatasetName.trim()) return;\n\n    onCreateDataset({\n      name: newDatasetName,\n      description: newDatasetDescription,\n      dataPoints: [],\n      source: newDatasetSource,\n    });\n\n    setNewDatasetName('');\n    setNewDatasetDescription('');\n    setNewDatasetSource('sectors');\n    setOpenDialog(false);\n  };\n\n  return (\n    <div>\n      <Button\n        variant=\"outlined\"\n        startIcon={<AddIcon />}\n        onClick={() => setOpenDialog(true)}\n        sx={{ mb: 2 }}\n      >\n        Create Dataset\n      </Button>\n\n      {datasets.length === 0 ? (\n        <Typography variant=\"body2\" color=\"text.secondary\" align=\"center\">\n          No datasets available. Create one to get started.\n        </Typography>\n      ) : (\n        <List sx={{ maxHeight: 400, overflow: 'auto' }}>\n          {datasets.map(dataset => (\n            <ListItem\n              key={dataset.id}\n              button\n              selected={selectedDataset?.id === dataset.id}\n              onClick={() => onSelectDataset(dataset)}\n              secondaryAction={\n                <IconButton\n                  edge=\"end\"\n                  aria-label=\"delete\"\n                  onClick={e => {\n                    e.stopPropagation();\n                    onDeleteDataset(dataset.id);\n                  }}\n                >\n                  <DeleteIcon />\n                </IconButton>\n              }\n            >\n              <ListItemText\n                primary={dataset.name}\n                secondary={\n                  <>\n                    <Typography component=\"span\" variant=\"body2\" color=\"text.primary\">\n                      {dataset.source}\n                    </Typography>\n                    {` â€” ${dataset.dataPoints.length} data points`}\n                  </>\n                }\n              />\n            </ListItem>\n          ))}\n        </List>\n      )}\n\n      {/* Create Dataset Dialog */}\n      <Dialog open={openDialog} onClose={() => setOpenDialog(false)}>\n        <DialogTitle>Create New Dataset</DialogTitle>\n        <DialogContent>\n          <TextField\n            autoFocus\n            margin=\"dense\"\n            label=\"Dataset Name\"\n            fullWidth\n            value={newDatasetName}\n            onChange={e => setNewDatasetName(e.target.value)}\n          />\n          <TextField\n            margin=\"dense\"\n            label=\"Description\"\n            fullWidth\n            value={newDatasetDescription}\n            onChange={e => setNewDatasetDescription(e.target.value)}\n          />\n          <FormControl fullWidth margin=\"dense\">\n            <InputLabel>Source</InputLabel>\n            <Select\n              value={newDatasetSource}\n              label=\"Source\"\n              onChange={e =>\n                setNewDatasetSource(\n                  e.target.value as 'sectors' | 'anomalies' | 'resources' | 'mixed'\n                )\n              }\n            >\n              <MenuItem value=\"sectors\">Sectors</MenuItem>\n              <MenuItem value=\"anomalies\">Anomalies</MenuItem>\n              <MenuItem value=\"resources\">Resources</MenuItem>\n              <MenuItem value=\"mixed\">Mixed</MenuItem>\n            </Select>\n          </FormControl>\n        </DialogContent>\n        <DialogActions>\n          <Button onClick={() => setOpenDialog(false)}>Cancel</Button>\n          <Button onClick={handleCreateDataset} disabled={!newDatasetName.trim()}>\n            Create\n          </Button>\n        </DialogActions>\n      </Dialog>\n    </div>\n  );\n};\n\nexport default DatasetManager;\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/DetailedAnomalyAnalysis.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_e' is defined but never used.","line":424,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":424,"endColumn":29}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  AlertTriangle,\n  ArrowRight,\n  BarChart2,\n  ChevronDown,\n  ChevronUp,\n  Clock,\n  Compass,\n  Database,\n  Download,\n  FileText,\n  Layers,\n  MapIcon,\n  Microscope,\n  Share2,\n  Shield,\n  Zap,\n} from 'lucide-react';\nimport { useEffect, useMemo, useState } from 'react';\nimport { ResourceType } from './../../types/resources/ResourceTypes';\n// Enhanced Anomaly interface with additional properties for detailed analysis\ninterface Anomaly {\n  id: string;\n  type: 'artifact' | 'signal' | 'phenomenon';\n  severity: 'low' | 'medium' | 'high';\n  description: string;\n  investigated: boolean;\n  discoveryDate: number;\n  sectorId: string;\n  sectorName: string;\n  coordinates: { x: number; y: number };\n  analysisProgress?: number;\n  analysisResults?: {\n    composition?: string[];\n    origin?: string;\n    age?: string;\n    energySignature?: string;\n    potentialUses?: string[];\n    dangerLevel?: number;\n    notes?: string;\n    // Enhanced analysis results\n    spectrumAnalysis?: {\n      frequencies: number[];\n      amplitudes: number[];\n      patterns: string[];\n      anomalies: string[];\n    };\n    materialProperties?: {\n      density?: number;\n      conductivity?: number;\n      radioactivity?: number;\n      magnetism?: number;\n      heatResistance?: number;\n    };\n    spatialDistortion?: {\n      magnitude: number;\n      radius: number;\n      stability: number;\n      fluctuationRate: number;\n    };\n    temporalEffects?: {\n      timeDialation: number;\n      chronoStability: number;\n      temporalFlux: string[];\n    };\n    biologicalImpact?: {\n      toxicity: number;\n      mutagenicPotential: number;\n      biocompatibility: number;\n      lifeformDetection: boolean;\n    };\n  };\n  images?: string[];\n  // Enhanced properties\n  scanHistory?: {\n    date: number;\n    findings: string;\n    scannerType: string;\n  }[];\n  relatedAnomalies?: string[]; // IDs of related anomalies\n  researchProgress?: {\n    currentStage: string;\n    completionPercentage: number;\n    breakthroughs: string[];\n    challenges: string[];\n  };\n  exploitationPotential?: {\n    resourceValue: number;\n    technologicalValue: number;\n    scientificValue: number;\n    strategicValue: number;\n  };\n  classification?: {\n    category: string;\n    subcategory: string;\n    rarity: 'common' | 'uncommon' | 'rare' | 'unique';\n    knownInstances: number;\n  };\n}\n\ninterface DetailedAnomalyAnalysisProps {\n  anomalies: Anomaly[];\n  onInvestigate: (anomalyId: string) => void;\n  onAnalysisComplete: (anomalyId: string, results: Anomaly['analysisResults']) => void;\n  onExport?: (anomalyId: string, format: 'pdf' | 'csv' | 'json') => void;\n  onShare?: (anomalyId: string) => void;\n  onRelatedAnomalySelect?: (anomalyId: string) => void;\n  className?: string;\n  quality?: 'low' | 'medium' | 'high';\n  advancedMode?: boolean;\n}\n\nexport function DetailedAnomalyAnalysis({\n  anomalies,\n  onInvestigate,\n  onAnalysisComplete,\n  onExport,\n  onShare,\n  onRelatedAnomalySelect,\n  className = '',\n  quality = 'medium',\n  advancedMode = false,\n}: DetailedAnomalyAnalysisProps) {\n  // State variables\n  const [selectedAnomalyId, setSelectedAnomalyId] = useState<string | null>(null);\n  const [sortBy, setSortBy] = useState<'date' | 'severity' | 'type' | 'value'>('severity');\n  const [sortOrder, setSortOrder] = useState<'asc' | 'desc'>('desc');\n  const [filter, setFilter] = useState<'all' | 'investigated' | 'uninvestigated' | 'high-value'>(\n    'all'\n  );\n  const [analysisInProgress, setAnalysisInProgress] = useState<Record<string, boolean>>({});\n  const [expandedSections, setExpandedSections] = useState<Record<string, boolean>>({});\n  const [searchQuery, setSearchQuery] = useState<string>('');\n  const [activeTab, setActiveTab] = useState<\n    'overview' | 'detailed' | ResourceType.RESEARCH | 'exploitation'\n  >('overview');\n  const [showAdvancedOptions, setShowAdvancedOptions] = useState<boolean>(false);\n\n  // Initialize expanded sections\n  useEffect(() => {\n    setExpandedSections({\n      analysis: true,\n      visuals: false,\n      recommendations: false,\n      research: false,\n      exploitation: false,\n      related: false,\n    });\n  }, []);\n\n  // Calculate anomaly value score (for sorting by value)\n  const calculateAnomalyValue = (anomaly: Anomaly): number => {\n    if (anomaly.exploitationPotential) {\n      const { resourceValue, technologicalValue, scientificValue, strategicValue } =\n        anomaly.exploitationPotential;\n      return (resourceValue + technologicalValue + scientificValue + strategicValue) / 4;\n    }\n\n    // Fallback calculation based on severity and type\n    const severityValue = { low: 1, medium: 2, high: 3 }[anomaly.severity] || 1;\n    const typeValue = { artifact: 3, signal: 2, phenomenon: 2.5 }[anomaly.type] || 1;\n\n    return severityValue * typeValue;\n  };\n\n  // Sort and filter anomalies\n  const filteredAndSortedAnomalies = useMemo(() => {\n    let filtered = [...anomalies];\n\n    // Apply search query\n    if (searchQuery.trim()) {\n      const query = searchQuery.toLowerCase();\n      filtered = filtered.filter(\n        a =>\n          a.description.toLowerCase().includes(query) ||\n          a.sectorName.toLowerCase().includes(query) ||\n          a.type.toLowerCase().includes(query) ||\n          a.severity.toLowerCase().includes(query) ||\n          (a.classification?.category && a.classification.category.toLowerCase().includes(query)) ||\n          (a.classification?.subcategory &&\n            a.classification.subcategory.toLowerCase().includes(query))\n      );\n    }\n\n    // Apply filter\n    if (filter === 'investigated') {\n      filtered = filtered.filter(a => a.investigated);\n    } else if (filter === 'uninvestigated') {\n      filtered = filtered.filter(a => !a.investigated);\n    } else if (filter === 'high-value') {\n      filtered = filtered.filter(a => calculateAnomalyValue(a) >= 5);\n    }\n\n    // Apply sort\n    return filtered.sort((a, b) => {\n      let comparison = 0;\n\n      if (sortBy === 'date') {\n        comparison = a.discoveryDate - b.discoveryDate;\n      } else if (sortBy === 'severity') {\n        const severityValue = { low: 1, medium: 2, high: 3 };\n        comparison = (severityValue[a.severity] ?? 0) - (severityValue[b.severity] ?? 0);\n      } else if (sortBy === 'type') {\n        comparison = a.type.localeCompare(b.type);\n      } else if (sortBy === 'value') {\n        comparison = calculateAnomalyValue(a) - calculateAnomalyValue(b);\n      }\n\n      return sortOrder === 'asc' ? comparison : -comparison;\n    });\n  }, [anomalies, sortBy, sortOrder, filter, searchQuery]);\n\n  // Get the selected anomaly\n  const selectedAnomaly = useMemo(() => {\n    return anomalies.find(a => a.id === selectedAnomalyId) || null;\n  }, [anomalies, selectedAnomalyId]);\n\n  // Get related anomalies\n  const relatedAnomalies = useMemo(() => {\n    if (!selectedAnomaly || !selectedAnomaly.relatedAnomalies) return [];\n    return anomalies.filter(a => selectedAnomaly.relatedAnomalies?.includes(a.id));\n  }, [anomalies, selectedAnomaly]);\n\n  // Handle sort change\n  const handleSortChange = (newSortBy: 'date' | 'severity' | 'type' | 'value') => {\n    if (sortBy === newSortBy) {\n      setSortOrder(sortOrder === 'asc' ? 'desc' : 'asc');\n    } else {\n      setSortBy(newSortBy);\n      setSortOrder('desc');\n    }\n  };\n\n  // Handle investigation\n  const handleInvestigate = (anomalyId: string) => {\n    setAnalysisInProgress(prev => ({ ...prev, [anomalyId]: true }));\n    onInvestigate(anomalyId);\n\n    // Simulate analysis progress\n    const duration = Math.random() * 3000 + 2000; // 2-5 seconds\n    setTimeout(() => {\n      setAnalysisInProgress(prev => ({ ...prev, [anomalyId]: false }));\n\n      // Generate analysis results based on anomaly type and severity\n      const anomaly = anomalies.find(a => a.id === anomalyId);\n      if (anomaly) {\n        const results: Anomaly['analysisResults'] = {};\n\n        if (anomaly.type === 'artifact') {\n          results.composition = ['Titanium', 'Unknown alloy', 'Trace elements'];\n          results.origin = Math.random() > 0.7 ? 'Unknown' : 'Ancient civilization';\n          results.age = `${Math.floor(Math.random() * 10000 + 1000)} years`;\n          results.potentialUses = ['Research', 'Technology advancement'];\n          results.dangerLevel = Math.random() * 10;\n\n          // Enhanced results\n          results.materialProperties = {\n            density: Math.random() * 20 + 5,\n            conductivity: Math.random() * 100,\n            radioactivity: Math.random() * 5,\n            magnetism: Math.random() * 100,\n            heatResistance: Math.random() * 2000 + 500,\n          };\n\n          results.biologicalImpact = {\n            toxicity: Math.random() * 10,\n            mutagenicPotential: Math.random() * 10,\n            biocompatibility: Math.random() * 100,\n            lifeformDetection: Math.random() > 0.8,\n          };\n        } else if (anomaly.type === 'signal') {\n          results.energySignature = `${Math.random() * 100 + 50} THz`;\n          results.origin = Math.random() > 0.5 ? 'Deep space' : 'Nearby star system';\n          results.potentialUses = ['Communication', 'Navigation'];\n          results.dangerLevel = Math.random() * 5;\n\n          // Enhanced results\n          results.spectrumAnalysis = {\n            frequencies: Array.from({ length: 5 }, () => Math.random() * 1000 + 100),\n            amplitudes: Array.from({ length: 5 }, () => Math.random() * 100),\n            patterns: ['Repeating', 'Structured', 'Non-random'],\n            anomalies: ['Frequency shift', 'Amplitude modulation'],\n          };\n\n          results.temporalEffects = {\n            timeDialation: Math.random() * 0.1,\n            chronoStability: Math.random() * 100,\n            temporalFlux: ['Minimal', 'Localized'],\n          };\n        } else if (anomaly.type === 'phenomenon') {\n          results.energySignature = `${Math.random() * 1000 + 100} PJ`;\n          results.composition = ['Energy fluctuations', 'Spatial distortions'];\n          results.potentialUses = ['Energy harvesting', 'Spatial research'];\n          results.dangerLevel = Math.random() * 8 + 2;\n\n          // Enhanced results\n          results.spatialDistortion = {\n            magnitude: Math.random() * 10,\n            radius: Math.random() * 1000 + 100,\n            stability: Math.random() * 100,\n            fluctuationRate: Math.random() * 10,\n          };\n\n          results.temporalEffects = {\n            timeDialation: Math.random() * 0.5,\n            chronoStability: Math.random() * 50 + 50,\n            temporalFlux: ['Significant', 'Expanding', 'Unstable'],\n          };\n        }\n\n        results.notes = 'Further investigation recommended.';\n\n        onAnalysisComplete(anomalyId, results);\n      }\n    }, duration);\n  };\n\n  // Toggle section expansion\n  const toggleSection = (sectionId: string) => {\n    setExpandedSections(prev => ({\n      ...prev,\n      [sectionId]: !prev[sectionId],\n    }));\n  };\n\n  // Get severity color\n  const getSeverityColor = (severity: Anomaly['severity']) => {\n    switch (severity) {\n      case 'high':\n        return 'text-red-500';\n      case 'medium':\n        return 'text-yellow-500';\n      case 'low':\n        return 'text-blue-500';\n      default:\n        return 'text-gray-500';\n    }\n  };\n\n  // Get type icon\n  const getTypeIcon = (type: Anomaly['type']) => {\n    switch (type) {\n      case 'artifact':\n        return <Database className=\"h-4 w-4\" />;\n      case 'signal':\n        return <Zap className=\"h-4 w-4\" />;\n      case 'phenomenon':\n        return <Microscope className=\"h-4 w-4\" />;\n      default:\n        return <AlertTriangle className=\"h-4 w-4\" />;\n    }\n  };\n\n  // Format date\n  const formatDate = (timestamp: number) => {\n    return new Date(timestamp).toLocaleDateString('en-US', {\n      year: 'numeric',\n      month: 'short',\n      day: 'numeric',\n    });\n  };\n\n  return (\n    <div className={`flex h-full flex-col bg-gray-900 ${className}`}>\n      {/* Header */}\n      <div className=\"flex items-center justify-between border-b border-gray-700 bg-gray-800 p-3\">\n        <div className=\"flex items-center space-x-2\">\n          <AlertTriangle className=\"h-5 w-5 text-yellow-500\" />\n          <h2 className=\"text-lg font-bold text-white\">Detailed Anomaly Analysis</h2>\n          {advancedMode && (\n            <span className=\"ml-2 rounded bg-blue-900 px-2 py-0.5 text-xs text-blue-200\">\n              Advanced Mode\n            </span>\n          )}\n        </div>\n\n        <div className=\"flex items-center space-x-3\">\n          {/* Search input */}\n          <div className=\"relative\">\n            <input\n              type=\"text\"\n              placeholder=\"Search anomalies...\"\n              value={searchQuery}\n              onChange={e => setSearchQuery(e.target.value)}\n              className=\"w-48 rounded border border-gray-600 bg-gray-700 py-1 pl-8 pr-2 text-sm text-gray-300 placeholder-gray-500\"\n            />\n            <FileText className=\"absolute left-2 top-1/2 h-4 w-4 -translate-y-1/2 text-gray-500\" />\n          </div>\n\n          {/* Filter dropdown */}\n          <select\n            value={filter}\n            onChange={e =>\n              setFilter(e.target.value as 'all' | 'investigated' | 'uninvestigated' | 'high-value')\n            }\n            className=\"rounded border border-gray-600 bg-gray-700 px-2 py-1 text-xs text-gray-300\"\n          >\n            <option value=\"all\">All Anomalies</option>\n            <option value=\"investigated\">Investigated</option>\n            <option value=\"uninvestigated\">Uninvestigated</option>\n            <option value=\"high-value\">High Value</option>\n          </select>\n\n          {/* Advanced options toggle */}\n          <button\n            onClick={() => setShowAdvancedOptions(!showAdvancedOptions)}\n            className={`rounded px-2 py-1 text-xs ${\n              showAdvancedOptions ? 'bg-blue-700 text-white' : 'bg-gray-700 text-gray-300'\n            }`}\n          >\n            Advanced Options\n          </button>\n        </div>\n      </div>\n\n      {/* Advanced options panel */}\n      {showAdvancedOptions && (\n        <div className=\"border-b border-gray-700 bg-gray-800 p-3\">\n          <div className=\"flex flex-wrap items-center gap-3\">\n            <div>\n              <label className=\"block text-xs text-gray-400\">Quality Level</label>\n              <select\n                value={quality}\n                onChange={_e => {\n                  // This would typically be handled by a parent component\n                  console.warn('Quality level change would be handled by parent component');\n                }}\n                className=\"mt-1 rounded border border-gray-600 bg-gray-700 px-2 py-1 text-xs text-gray-300\"\n              >\n                <option value=\"low\">Low (Performance)</option>\n                <option value=\"medium\">Medium (Balanced)</option>\n                <option value=\"high\">High (Quality)</option>\n              </select>\n            </div>\n\n            <div>\n              <label className=\"block text-xs text-gray-400\">Display Mode</label>\n              <div className=\"mt-1 flex overflow-hidden rounded border border-gray-600\">\n                <button\n                  onClick={() => setActiveTab('overview')}\n                  className={`px-2 py-1 text-xs ${\n                    activeTab === 'overview'\n                      ? 'bg-blue-700 text-white'\n                      : 'bg-gray-700 text-gray-300'\n                  }`}\n                >\n                  Overview\n                </button>\n                <button\n                  onClick={() => setActiveTab('detailed')}\n                  className={`px-2 py-1 text-xs ${\n                    activeTab === 'detailed'\n                      ? 'bg-blue-700 text-white'\n                      : 'bg-gray-700 text-gray-300'\n                  }`}\n                >\n                  Detailed\n                </button>\n                <button\n                  onClick={() => setActiveTab(ResourceType.RESEARCH)}\n                  className={`px-2 py-1 text-xs ${\n                    activeTab === ResourceType.RESEARCH\n                      ? 'bg-blue-700 text-white'\n                      : 'bg-gray-700 text-gray-300'\n                  }`}\n                >\n                  Research\n                </button>\n                <button\n                  onClick={() => setActiveTab('exploitation')}\n                  className={`px-2 py-1 text-xs ${\n                    activeTab === 'exploitation'\n                      ? 'bg-blue-700 text-white'\n                      : 'bg-gray-700 text-gray-300'\n                  }`}\n                >\n                  Exploitation\n                </button>\n              </div>\n            </div>\n          </div>\n        </div>\n      )}\n\n      <div className=\"flex flex-grow overflow-hidden\">\n        {/* Anomaly list */}\n        <div className=\"w-1/3 overflow-y-auto border-r border-gray-700\">\n          {/* Sort controls */}\n          <div className=\"flex items-center justify-between border-b border-gray-700 bg-gray-800 p-2 text-xs text-gray-300\">\n            <button\n              onClick={() => handleSortChange('date')}\n              className={`flex items-center space-x-1 rounded px-2 py-1 ${\n                sortBy === 'date' ? 'bg-blue-900 text-blue-200' : 'hover:bg-gray-700'\n              }`}\n            >\n              <Clock className=\"h-3 w-3\" />\n              <span>Date</span>\n              {sortBy === 'date' && <span>{sortOrder === 'asc' ? 'â†‘' : 'â†“'}</span>}\n            </button>\n\n            <button\n              onClick={() => handleSortChange('severity')}\n              className={`flex items-center space-x-1 rounded px-2 py-1 ${\n                sortBy === 'severity' ? 'bg-blue-900 text-blue-200' : 'hover:bg-gray-700'\n              }`}\n            >\n              <AlertTriangle className=\"h-3 w-3\" />\n              <span>Severity</span>\n              {sortBy === 'severity' && <span>{sortOrder === 'asc' ? 'â†‘' : 'â†“'}</span>}\n            </button>\n\n            <button\n              onClick={() => handleSortChange('type')}\n              className={`flex items-center space-x-1 rounded px-2 py-1 ${\n                sortBy === 'type' ? 'bg-blue-900 text-blue-200' : 'hover:bg-gray-700'\n              }`}\n            >\n              <FileText className=\"h-3 w-3\" />\n              <span>Type</span>\n              {sortBy === 'type' && <span>{sortOrder === 'asc' ? 'â†‘' : 'â†“'}</span>}\n            </button>\n\n            <button\n              onClick={() => handleSortChange('value')}\n              className={`flex items-center space-x-1 rounded px-2 py-1 ${\n                sortBy === 'value' ? 'bg-blue-900 text-blue-200' : 'hover:bg-gray-700'\n              }`}\n            >\n              <BarChart2 className=\"h-3 w-3\" />\n              <span>Value</span>\n              {sortBy === 'value' && <span>{sortOrder === 'asc' ? 'â†‘' : 'â†“'}</span>}\n            </button>\n          </div>\n\n          {/* Anomaly items */}\n          <div className=\"divide-y divide-gray-700\">\n            {filteredAndSortedAnomalies.length === 0 ? (\n              <div className=\"p-4 text-center text-gray-400\">\n                No anomalies found matching the current filter.\n              </div>\n            ) : (\n              filteredAndSortedAnomalies.map(anomaly => (\n                <div\n                  key={anomaly.id}\n                  className={`cursor-pointer p-3 transition-colors ${\n                    selectedAnomalyId === anomaly.id ? 'bg-blue-900/30' : 'hover:bg-gray-800'\n                  }`}\n                  onClick={() => setSelectedAnomalyId(anomaly.id)}\n                >\n                  <div className=\"flex items-start justify-between\">\n                    <div className=\"flex items-start space-x-2\">\n                      <div className={`mt-0.5 ${getSeverityColor(anomaly.severity)}`}>\n                        {getTypeIcon(anomaly.type)}\n                      </div>\n                      <div>\n                        <h3 className=\"text-sm font-medium text-white\">\n                          {anomaly.description.length > 30\n                            ? `${anomaly.description.substring(0, 30)}...`\n                            : anomaly.description}\n                        </h3>\n                        <p className=\"text-xs text-gray-400\">\n                          {anomaly.sectorName} â€¢ {formatDate(anomaly.discoveryDate)}\n                        </p>\n\n                        {/* Classification tag if available */}\n                        {anomaly.classification && (\n                          <div className=\"mt-1 flex flex-wrap gap-1\">\n                            <span className=\"rounded bg-gray-700 px-1.5 py-0.5 text-xs text-gray-300\">\n                              {anomaly.classification.category}\n                            </span>\n                            {anomaly.classification.rarity && (\n                              <span\n                                className={`rounded px-1.5 py-0.5 text-xs ${\n                                  anomaly.classification.rarity === 'unique'\n                                    ? 'bg-purple-900/50 text-purple-300'\n                                    : anomaly.classification.rarity === 'rare'\n                                      ? 'bg-blue-900/50 text-blue-300'\n                                      : anomaly.classification.rarity === 'uncommon'\n                                        ? 'bg-green-900/50 text-green-300'\n                                        : 'bg-gray-700 text-gray-300'\n                                }`}\n                              >\n                                {anomaly.classification.rarity}\n                              </span>\n                            )}\n                          </div>\n                        )}\n                      </div>\n                    </div>\n\n                    <div className=\"flex flex-col items-end\">\n                      <span\n                        className={`rounded px-1.5 py-0.5 text-xs font-medium ${\n                          anomaly.severity === 'high'\n                            ? 'bg-red-900/50 text-red-300'\n                            : anomaly.severity === 'medium'\n                              ? 'bg-yellow-900/50 text-yellow-300'\n                              : 'bg-blue-900/50 text-blue-300'\n                        }`}\n                      >\n                        {anomaly.severity}\n                      </span>\n\n                      <span className=\"mt-1 text-xs text-gray-400\">\n                        {anomaly.investigated ? 'Investigated' : 'Uninvestigated'}\n                      </span>\n\n                      {/* Value indicator if available */}\n                      {anomaly.exploitationPotential && (\n                        <div className=\"mt-1 flex items-center space-x-1\">\n                          <BarChart2 className=\"h-3 w-3 text-green-500\" />\n                          <span className=\"text-xs text-green-500\">\n                            {Math.round(calculateAnomalyValue(anomaly) * 10) / 10}\n                          </span>\n                        </div>\n                      )}\n                    </div>\n                  </div>\n                </div>\n              ))\n            )}\n          </div>\n        </div>\n\n        {/* Anomaly details */}\n        <div className=\"flex-grow overflow-y-auto\">\n          {selectedAnomaly ? (\n            <div className=\"p-4\">\n              {/* Header with actions */}\n              <div className=\"mb-4 flex items-start justify-between\">\n                <div>\n                  <h2 className=\"mb-1 text-xl font-bold text-white\">\n                    {selectedAnomaly.description}\n                  </h2>\n                  <p className=\"text-sm text-gray-400\">\n                    Discovered on {formatDate(selectedAnomaly.discoveryDate)} in{' '}\n                    {selectedAnomaly.sectorName}\n                  </p>\n                </div>\n\n                <div className=\"flex items-center space-x-2\">\n                  <div\n                    className={`rounded px-2 py-1 text-sm font-medium ${\n                      selectedAnomaly.severity === 'high'\n                        ? 'bg-red-900/50 text-red-300'\n                        : selectedAnomaly.severity === 'medium'\n                          ? 'bg-yellow-900/50 text-yellow-300'\n                          : 'bg-blue-900/50 text-blue-300'\n                    }`}\n                  >\n                    {selectedAnomaly.severity.toUpperCase()} {selectedAnomaly.type.toUpperCase()}\n                  </div>\n\n                  {/* Action buttons */}\n                  {onExport && (\n                    <button\n                      onClick={() => onExport(selectedAnomaly.id, 'pdf')}\n                      className=\"rounded bg-gray-700 p-1 text-gray-300 hover:bg-gray-600\"\n                      title=\"Export data\"\n                    >\n                      <Download className=\"h-4 w-4\" />\n                    </button>\n                  )}\n\n                  {onShare && (\n                    <button\n                      onClick={() => onShare(selectedAnomaly.id)}\n                      className=\"rounded bg-gray-700 p-1 text-gray-300 hover:bg-gray-600\"\n                      title=\"Share analysis\"\n                    >\n                      <Share2 className=\"h-4 w-4\" />\n                    </button>\n                  )}\n                </div>\n              </div>\n\n              {/* Tab navigation */}\n              <div className=\"mb-4 flex border-b border-gray-700\">\n                <button\n                  onClick={() => setActiveTab('overview')}\n                  className={`border-b-2 px-4 py-2 text-sm ${\n                    activeTab === 'overview'\n                      ? 'border-blue-500 text-blue-400'\n                      : 'border-transparent text-gray-400 hover:text-gray-300'\n                  }`}\n                >\n                  Overview\n                </button>\n                <button\n                  onClick={() => setActiveTab('detailed')}\n                  className={`border-b-2 px-4 py-2 text-sm ${\n                    activeTab === 'detailed'\n                      ? 'border-blue-500 text-blue-400'\n                      : 'border-transparent text-gray-400 hover:text-gray-300'\n                  }`}\n                >\n                  Detailed Analysis\n                </button>\n                <button\n                  onClick={() => setActiveTab(ResourceType.RESEARCH)}\n                  className={`border-b-2 px-4 py-2 text-sm ${\n                    activeTab === ResourceType.RESEARCH\n                      ? 'border-blue-500 text-blue-400'\n                      : 'border-transparent text-gray-400 hover:text-gray-300'\n                  }`}\n                >\n                  Research\n                </button>\n                <button\n                  onClick={() => setActiveTab('exploitation')}\n                  className={`border-b-2 px-4 py-2 text-sm ${\n                    activeTab === 'exploitation'\n                      ? 'border-blue-500 text-blue-400'\n                      : 'border-transparent text-gray-400 hover:text-gray-300'\n                  }`}\n                >\n                  Exploitation\n                </button>\n              </div>\n\n              {/* Tab content */}\n              <div>\n                {/* Overview Tab */}\n                {activeTab === 'overview' && (\n                  <div className=\"space-y-4\">\n                    {/* Coordinates */}\n                    <div className=\"rounded-lg bg-gray-800 p-3\">\n                      <div className=\"flex items-center justify-between\">\n                        <div className=\"flex items-center space-x-2\">\n                          <MapIcon className=\"h-4 w-4 text-blue-400\" />\n                          <span className=\"text-sm text-gray-300\">Coordinates</span>\n                        </div>\n                        <div className=\"font-mono text-sm text-white\">\n                          X: {selectedAnomaly.coordinates.x.toFixed(2)}, Y:{' '}\n                          {selectedAnomaly.coordinates.y.toFixed(2)}\n                        </div>\n                      </div>\n                    </div>\n\n                    {/* Analysis section */}\n                    <div className=\"overflow-hidden rounded-lg bg-gray-800\">\n                      <div\n                        className=\"flex cursor-pointer items-center justify-between p-3\"\n                        onClick={() => toggleSection('analysis')}\n                      >\n                        <div className=\"flex items-center space-x-2\">\n                          <Microscope className=\"h-4 w-4 text-purple-400\" />\n                          <span className=\"text-sm font-medium text-white\">Analysis</span>\n                        </div>\n                        {expandedSections['analysis'] ? (\n                          <ChevronUp className=\"h-4 w-4 text-gray-400\" />\n                        ) : (\n                          <ChevronDown className=\"h-4 w-4 text-gray-400\" />\n                        )}\n                      </div>\n\n                      {expandedSections['analysis'] && (\n                        <div className=\"border-t border-gray-700 p-3 pt-0\">\n                          {selectedAnomaly.investigated ? (\n                            <div className=\"space-y-3\">\n                              {selectedAnomaly.analysisResults?.composition && (\n                                <div>\n                                  <h4 className=\"mb-1 text-xs text-gray-400\">Composition</h4>\n                                  <div className=\"flex flex-wrap gap-1\">\n                                    {selectedAnomaly.analysisResults.composition.map(\n                                      (item, index) => (\n                                        <span\n                                          key={index}\n                                          className=\"rounded bg-gray-700 px-2 py-0.5 text-xs text-gray-300\"\n                                        >\n                                          {item}\n                                        </span>\n                                      )\n                                    )}\n                                  </div>\n                                </div>\n                              )}\n\n                              {selectedAnomaly.analysisResults?.origin && (\n                                <div>\n                                  <h4 className=\"mb-1 text-xs text-gray-400\">Origin</h4>\n                                  <p className=\"text-sm text-white\">\n                                    {selectedAnomaly.analysisResults.origin}\n                                  </p>\n                                </div>\n                              )}\n\n                              {selectedAnomaly.analysisResults?.age && (\n                                <div>\n                                  <h4 className=\"mb-1 text-xs text-gray-400\">Estimated Age</h4>\n                                  <p className=\"text-sm text-white\">\n                                    {selectedAnomaly.analysisResults.age}\n                                  </p>\n                                </div>\n                              )}\n\n                              {selectedAnomaly.analysisResults?.energySignature && (\n                                <div>\n                                  <h4 className=\"mb-1 text-xs text-gray-400\">Energy Signature</h4>\n                                  <p className=\"text-sm text-white\">\n                                    {selectedAnomaly.analysisResults.energySignature}\n                                  </p>\n                                </div>\n                              )}\n\n                              {selectedAnomaly.analysisResults?.potentialUses && (\n                                <div>\n                                  <h4 className=\"mb-1 text-xs text-gray-400\">Potential Uses</h4>\n                                  <div className=\"flex flex-wrap gap-1\">\n                                    {selectedAnomaly.analysisResults.potentialUses.map(\n                                      (use, index) => (\n                                        <span\n                                          key={index}\n                                          className=\"rounded bg-blue-900/30 px-2 py-0.5 text-xs text-blue-300\"\n                                        >\n                                          {use}\n                                        </span>\n                                      )\n                                    )}\n                                  </div>\n                                </div>\n                              )}\n\n                              {selectedAnomaly.analysisResults?.dangerLevel !== undefined && (\n                                <div>\n                                  <h4 className=\"mb-1 text-xs text-gray-400\">Danger Level</h4>\n                                  <div className=\"h-2 w-full overflow-hidden rounded-full bg-gray-700\">\n                                    <div\n                                      className={`h-full ${\n                                        selectedAnomaly.analysisResults.dangerLevel > 7\n                                          ? 'bg-red-500'\n                                          : selectedAnomaly.analysisResults.dangerLevel > 4\n                                            ? 'bg-yellow-500'\n                                            : 'bg-green-500'\n                                      }`}\n                                      style={{\n                                        width: `${selectedAnomaly.analysisResults.dangerLevel * 10}%`,\n                                      }}\n                                    ></div>\n                                  </div>\n                                  <div className=\"mt-1 flex justify-between text-xs text-gray-500\">\n                                    <span>Safe</span>\n                                    <span>Moderate</span>\n                                    <span>Dangerous</span>\n                                  </div>\n                                </div>\n                              )}\n\n                              {selectedAnomaly.analysisResults?.notes && (\n                                <div>\n                                  <h4 className=\"mb-1 text-xs text-gray-400\">Notes</h4>\n                                  <p className=\"text-sm text-white\">\n                                    {selectedAnomaly.analysisResults.notes}\n                                  </p>\n                                </div>\n                              )}\n                            </div>\n                          ) : (\n                            <div className=\"py-4 text-center\">\n                              {analysisInProgress[selectedAnomaly.id] ? (\n                                <div className=\"space-y-3\">\n                                  <div className=\"mx-auto h-8 w-8 animate-spin rounded-full border-2 border-blue-500 border-t-transparent\"></div>\n                                  <p className=\"text-sm text-gray-300\">Analysis in progress...</p>\n                                </div>\n                              ) : (\n                                <div className=\"space-y-3\">\n                                  <p className=\"text-sm text-gray-300\">\n                                    This anomaly has not been investigated yet.\n                                  </p>\n                                  <button\n                                    onClick={() => handleInvestigate(selectedAnomaly.id)}\n                                    className=\"rounded bg-blue-700 px-3 py-1.5 text-white transition-colors hover:bg-blue-600\"\n                                  >\n                                    Begin Analysis\n                                  </button>\n                                </div>\n                              )}\n                            </div>\n                          )}\n                        </div>\n                      )}\n                    </div>\n\n                    {/* Visuals section */}\n                    <div className=\"overflow-hidden rounded-lg bg-gray-800\">\n                      <div\n                        className=\"flex cursor-pointer items-center justify-between p-3\"\n                        onClick={() => toggleSection('visuals')}\n                      >\n                        <div className=\"flex items-center space-x-2\">\n                          <FileText className=\"h-4 w-4 text-green-400\" />\n                          <span className=\"text-sm font-medium text-white\">Visual Data</span>\n                        </div>\n                        {expandedSections['visuals'] ? (\n                          <ChevronUp className=\"h-4 w-4 text-gray-400\" />\n                        ) : (\n                          <ChevronDown className=\"h-4 w-4 text-gray-400\" />\n                        )}\n                      </div>\n\n                      {expandedSections['visuals'] && (\n                        <div className=\"border-t border-gray-700 p-3 pt-0\">\n                          {selectedAnomaly.images && selectedAnomaly.images.length > 0 ? (\n                            <div className=\"grid grid-cols-2 gap-2\">\n                              {selectedAnomaly.images.map((image, index) => (\n                                <div key={index} className=\"overflow-hidden rounded bg-gray-700\">\n                                  <img\n                                    src={image}\n                                    alt={`Anomaly visual ${index + 1}`}\n                                    className=\"h-auto w-full\"\n                                  />\n                                </div>\n                              ))}\n                            </div>\n                          ) : (\n                            <div className=\"py-4 text-center\">\n                              <p className=\"text-sm text-gray-300\">No visual data available.</p>\n                              {!selectedAnomaly.investigated && (\n                                <p className=\"mt-1 text-xs text-gray-400\">\n                                  Visual data will be available after investigation.\n                                </p>\n                              )}\n                            </div>\n                          )}\n                        </div>\n                      )}\n                    </div>\n\n                    {/* Recommendations section */}\n                    <div className=\"overflow-hidden rounded-lg bg-gray-800\">\n                      <div\n                        className=\"flex cursor-pointer items-center justify-between p-3\"\n                        onClick={() => toggleSection('recommendations')}\n                      >\n                        <div className=\"flex items-center space-x-2\">\n                          <ArrowRight className=\"h-4 w-4 text-yellow-400\" />\n                          <span className=\"text-sm font-medium text-white\">Recommendations</span>\n                        </div>\n                        {expandedSections['recommendations'] ? (\n                          <ChevronUp className=\"h-4 w-4 text-gray-400\" />\n                        ) : (\n                          <ChevronDown className=\"h-4 w-4 text-gray-400\" />\n                        )}\n                      </div>\n\n                      {expandedSections['recommendations'] && (\n                        <div className=\"border-t border-gray-700 p-3 pt-0\">\n                          {selectedAnomaly.investigated ? (\n                            <div className=\"space-y-2\">\n                              {selectedAnomaly.type === 'artifact' && (\n                                <>\n                                  <div className=\"flex items-start space-x-2\">\n                                    <div className=\"mt-1 h-4 w-4 flex-shrink-0 rounded-full bg-blue-500\"></div>\n                                    <p className=\"text-sm text-gray-300\">\n                                      Dispatch research team to study the artifact's composition and\n                                      technology.\n                                    </p>\n                                  </div>\n                                  <div className=\"flex items-start space-x-2\">\n                                    <div className=\"mt-1 h-4 w-4 flex-shrink-0 rounded-full bg-green-500\"></div>\n                                    <p className=\"text-sm text-gray-300\">\n                                      Consider establishing a research outpost for long-term study.\n                                    </p>\n                                  </div>\n                                </>\n                              )}\n\n                              {selectedAnomaly.type === 'signal' && (\n                                <>\n                                  <div className=\"flex items-start space-x-2\">\n                                    <div className=\"mt-1 h-4 w-4 flex-shrink-0 rounded-full bg-blue-500\"></div>\n                                    <p className=\"text-sm text-gray-300\">\n                                      Deploy signal amplifiers to enhance and decode the\n                                      transmission.\n                                    </p>\n                                  </div>\n                                  <div className=\"flex items-start space-x-2\">\n                                    <div className=\"mt-1 h-4 w-4 flex-shrink-0 rounded-full bg-green-500\"></div>\n                                    <p className=\"text-sm text-gray-300\">\n                                      Establish a monitoring station to track signal changes over\n                                      time.\n                                    </p>\n                                  </div>\n                                </>\n                              )}\n\n                              {selectedAnomaly.type === 'phenomenon' && (\n                                <>\n                                  <div className=\"flex items-start space-x-2\">\n                                    <div className=\"mt-1 h-4 w-4 flex-shrink-0 rounded-full bg-blue-500\"></div>\n                                    <p className=\"text-sm text-gray-300\">\n                                      Deploy sensor array to monitor energy fluctuations and spatial\n                                      distortions.\n                                    </p>\n                                  </div>\n                                  <div className=\"flex items-start space-x-2\">\n                                    <div className=\"mt-1 h-4 w-4 flex-shrink-0 rounded-full bg-yellow-500\"></div>\n                                    <p className=\"text-sm text-gray-300\">\n                                      Maintain safe distance until phenomenon stability can be\n                                      determined.\n                                    </p>\n                                  </div>\n                                </>\n                              )}\n\n                              <div className=\"flex items-start space-x-2\">\n                                <div className=\"mt-1 h-4 w-4 flex-shrink-0 rounded-full bg-purple-500\"></div>\n                                <p className=\"text-sm text-gray-300\">\n                                  Allocate resources for further investigation and potential\n                                  exploitation.\n                                </p>\n                              </div>\n                            </div>\n                          ) : (\n                            <div className=\"py-4 text-center\">\n                              <p className=\"text-sm text-gray-300\">\n                                Recommendations will be available after investigation.\n                              </p>\n                            </div>\n                          )}\n                        </div>\n                      )}\n                    </div>\n\n                    {/* Related anomalies section */}\n                    {relatedAnomalies.length > 0 && (\n                      <div className=\"overflow-hidden rounded-lg bg-gray-800\">\n                        <div\n                          className=\"flex cursor-pointer items-center justify-between p-3\"\n                          onClick={() => toggleSection('related')}\n                        >\n                          <div className=\"flex items-center space-x-2\">\n                            <Layers className=\"h-4 w-4 text-indigo-400\" />\n                            <span className=\"text-sm font-medium text-white\">\n                              Related Anomalies\n                            </span>\n                          </div>\n                          {expandedSections['related'] ? (\n                            <ChevronUp className=\"h-4 w-4 text-gray-400\" />\n                          ) : (\n                            <ChevronDown className=\"h-4 w-4 text-gray-400\" />\n                          )}\n                        </div>\n\n                        {expandedSections['related'] && (\n                          <div className=\"border-t border-gray-700 p-3 pt-0\">\n                            <div className=\"space-y-2\">\n                              {relatedAnomalies.map(anomaly => (\n                                <div\n                                  key={anomaly.id}\n                                  className=\"flex cursor-pointer items-center justify-between rounded bg-gray-700 p-2 hover:bg-gray-600\"\n                                  onClick={() => {\n                                    if (onRelatedAnomalySelect) {\n                                      onRelatedAnomalySelect(anomaly.id);\n                                    }\n                                    setSelectedAnomalyId(anomaly.id);\n                                  }}\n                                >\n                                  <div className=\"flex items-center space-x-2\">\n                                    <div className={getSeverityColor(anomaly.severity)}>\n                                      {getTypeIcon(anomaly.type)}\n                                    </div>\n                                    <span className=\"text-sm text-white\">\n                                      {anomaly.description}\n                                    </span>\n                                  </div>\n                                  <span\n                                    className={`rounded px-1.5 py-0.5 text-xs ${\n                                      anomaly.severity === 'high'\n                                        ? 'bg-red-900/50 text-red-300'\n                                        : anomaly.severity === 'medium'\n                                          ? 'bg-yellow-900/50 text-yellow-300'\n                                          : 'bg-blue-900/50 text-blue-300'\n                                    }`}\n                                  >\n                                    {anomaly.severity}\n                                  </span>\n                                </div>\n                              ))}\n                            </div>\n                          </div>\n                        )}\n                      </div>\n                    )}\n                  </div>\n                )}\n\n                {/* Detailed Analysis Tab */}\n                {activeTab === 'detailed' && (\n                  <div className=\"space-y-4\">\n                    {/* Spectrum Analysis */}\n                    {selectedAnomaly.investigated &&\n                      selectedAnomaly.analysisResults?.spectrumAnalysis && (\n                        <div className=\"overflow-hidden rounded-lg bg-gray-800\">\n                          <div className=\"p-3\">\n                            <div className=\"flex items-center space-x-2\">\n                              <Zap className=\"h-4 w-4 text-blue-400\" />\n                              <span className=\"text-sm font-medium text-white\">\n                                Spectrum Analysis\n                              </span>\n                            </div>\n                          </div>\n                          <div className=\"border-t border-gray-700 p-3\">\n                            <div className=\"space-y-3\">\n                              {/* Frequency visualization */}\n                              <div>\n                                <h4 className=\"mb-2 text-xs text-gray-400\">\n                                  Frequency Distribution\n                                </h4>\n                                <div className=\"h-24 w-full bg-gray-900 p-2\">\n                                  <div className=\"flex h-full items-end justify-between space-x-1\">\n                                    {selectedAnomaly.analysisResults.spectrumAnalysis.frequencies.map(\n                                      (freq, index) => {\n                                        const height = (freq / 1000) * 100;\n                                        return (\n                                          <div\n                                            key={index}\n                                            className=\"w-full bg-blue-500\"\n                                            style={{ height: `${Math.min(height, 100)}%` }}\n                                            title={`${freq.toFixed(2)} Hz`}\n                                          ></div>\n                                        );\n                                      }\n                                    )}\n                                  </div>\n                                </div>\n                              </div>\n\n                              {/* Patterns */}\n                              <div>\n                                <h4 className=\"mb-1 text-xs text-gray-400\">Detected Patterns</h4>\n                                <div className=\"flex flex-wrap gap-1\">\n                                  {selectedAnomaly.analysisResults.spectrumAnalysis.patterns.map(\n                                    (pattern, index) => (\n                                      <span\n                                        key={index}\n                                        className=\"rounded bg-blue-900/30 px-2 py-0.5 text-xs text-blue-300\"\n                                      >\n                                        {pattern}\n                                      </span>\n                                    )\n                                  )}\n                                </div>\n                              </div>\n\n                              {/* Anomalies */}\n                              <div>\n                                <h4 className=\"mb-1 text-xs text-gray-400\">Spectral Anomalies</h4>\n                                <div className=\"flex flex-wrap gap-1\">\n                                  {selectedAnomaly.analysisResults.spectrumAnalysis.anomalies.map(\n                                    (anomaly, index) => (\n                                      <span\n                                        key={index}\n                                        className=\"rounded bg-purple-900/30 px-2 py-0.5 text-xs text-purple-300\"\n                                      >\n                                        {anomaly}\n                                      </span>\n                                    )\n                                  )}\n                                </div>\n                              </div>\n                            </div>\n                          </div>\n                        </div>\n                      )}\n\n                    {/* Material Properties */}\n                    {selectedAnomaly.investigated &&\n                      selectedAnomaly.analysisResults?.materialProperties && (\n                        <div className=\"overflow-hidden rounded-lg bg-gray-800\">\n                          <div className=\"p-3\">\n                            <div className=\"flex items-center space-x-2\">\n                              <Database className=\"h-4 w-4 text-green-400\" />\n                              <span className=\"text-sm font-medium text-white\">\n                                Material Properties\n                              </span>\n                            </div>\n                          </div>\n                          <div className=\"border-t border-gray-700 p-3\">\n                            <div className=\"grid grid-cols-2 gap-4\">\n                              {/* Density */}\n                              {selectedAnomaly.analysisResults.materialProperties.density !==\n                                undefined && (\n                                <div>\n                                  <h4 className=\"mb-1 text-xs text-gray-400\">Density</h4>\n                                  <div className=\"flex items-center justify-between\">\n                                    <span className=\"text-sm text-white\">\n                                      {selectedAnomaly.analysisResults.materialProperties.density.toFixed(\n                                        2\n                                      )}{' '}\n                                      g/cmÂ³\n                                    </span>\n                                    <span className=\"text-xs text-gray-500\">\n                                      {selectedAnomaly.analysisResults.materialProperties.density >\n                                      15\n                                        ? 'Very Dense'\n                                        : selectedAnomaly.analysisResults.materialProperties\n                                              .density > 10\n                                          ? 'Dense'\n                                          : selectedAnomaly.analysisResults.materialProperties\n                                                .density > 5\n                                            ? 'Medium'\n                                            : 'Light'}\n                                    </span>\n                                  </div>\n                                  <div className=\"mt-1 h-1.5 w-full overflow-hidden rounded-full bg-gray-700\">\n                                    <div\n                                      className=\"h-full bg-green-500\"\n                                      style={{\n                                        width: `${Math.min(\n                                          (selectedAnomaly.analysisResults.materialProperties\n                                            .density /\n                                            25) *\n                                            100,\n                                          100\n                                        )}%`,\n                                      }}\n                                    ></div>\n                                  </div>\n                                </div>\n                              )}\n\n                              {/* Conductivity */}\n                              {selectedAnomaly.analysisResults.materialProperties.conductivity !==\n                                undefined && (\n                                <div>\n                                  <h4 className=\"mb-1 text-xs text-gray-400\">Conductivity</h4>\n                                  <div className=\"flex items-center justify-between\">\n                                    <span className=\"text-sm text-white\">\n                                      {selectedAnomaly.analysisResults.materialProperties.conductivity.toFixed(\n                                        2\n                                      )}{' '}\n                                      S/m\n                                    </span>\n                                    <span className=\"text-xs text-gray-500\">\n                                      {selectedAnomaly.analysisResults.materialProperties\n                                        .conductivity > 80\n                                        ? 'Excellent'\n                                        : selectedAnomaly.analysisResults.materialProperties\n                                              .conductivity > 50\n                                          ? 'Good'\n                                          : selectedAnomaly.analysisResults.materialProperties\n                                                .conductivity > 20\n                                            ? 'Fair'\n                                            : 'Poor'}\n                                    </span>\n                                  </div>\n                                  <div className=\"mt-1 h-1.5 w-full overflow-hidden rounded-full bg-gray-700\">\n                                    <div\n                                      className=\"h-full bg-blue-500\"\n                                      style={{\n                                        width: `${Math.min(\n                                          (selectedAnomaly.analysisResults.materialProperties\n                                            .conductivity /\n                                            100) *\n                                            100,\n                                          100\n                                        )}%`,\n                                      }}\n                                    ></div>\n                                  </div>\n                                </div>\n                              )}\n\n                              {/* Radioactivity */}\n                              {selectedAnomaly.analysisResults.materialProperties.radioactivity !==\n                                undefined && (\n                                <div>\n                                  <h4 className=\"mb-1 text-xs text-gray-400\">Radioactivity</h4>\n                                  <div className=\"flex items-center justify-between\">\n                                    <span className=\"text-sm text-white\">\n                                      {selectedAnomaly.analysisResults.materialProperties.radioactivity.toFixed(\n                                        2\n                                      )}{' '}\n                                      mSv/h\n                                    </span>\n                                    <span className=\"text-xs text-gray-500\">\n                                      {selectedAnomaly.analysisResults.materialProperties\n                                        .radioactivity > 4\n                                        ? 'Dangerous'\n                                        : selectedAnomaly.analysisResults.materialProperties\n                                              .radioactivity > 2\n                                          ? 'High'\n                                          : selectedAnomaly.analysisResults.materialProperties\n                                                .radioactivity > 1\n                                            ? 'Moderate'\n                                            : 'Low'}\n                                    </span>\n                                  </div>\n                                  <div className=\"mt-1 h-1.5 w-full overflow-hidden rounded-full bg-gray-700\">\n                                    <div\n                                      className={`h-full ${\n                                        selectedAnomaly.analysisResults.materialProperties\n                                          .radioactivity > 3\n                                          ? 'bg-red-500'\n                                          : selectedAnomaly.analysisResults.materialProperties\n                                                .radioactivity > 1\n                                            ? 'bg-yellow-500'\n                                            : 'bg-green-500'\n                                      }`}\n                                      style={{\n                                        width: `${Math.min(\n                                          (selectedAnomaly.analysisResults.materialProperties\n                                            .radioactivity /\n                                            5) *\n                                            100,\n                                          100\n                                        )}%`,\n                                      }}\n                                    ></div>\n                                  </div>\n                                </div>\n                              )}\n\n                              {/* Heat Resistance */}\n                              {selectedAnomaly.analysisResults.materialProperties.heatResistance !==\n                                undefined && (\n                                <div>\n                                  <h4 className=\"mb-1 text-xs text-gray-400\">Heat Resistance</h4>\n                                  <div className=\"flex items-center justify-between\">\n                                    <span className=\"text-sm text-white\">\n                                      {selectedAnomaly.analysisResults.materialProperties.heatResistance.toFixed(\n                                        0\n                                      )}{' '}\n                                      K\n                                    </span>\n                                    <span className=\"text-xs text-gray-500\">\n                                      {selectedAnomaly.analysisResults.materialProperties\n                                        .heatResistance > 1500\n                                        ? 'Extreme'\n                                        : selectedAnomaly.analysisResults.materialProperties\n                                              .heatResistance > 1000\n                                          ? 'Very High'\n                                          : selectedAnomaly.analysisResults.materialProperties\n                                                .heatResistance > 500\n                                            ? 'High'\n                                            : 'Moderate'}\n                                    </span>\n                                  </div>\n                                  <div className=\"mt-1 h-1.5 w-full overflow-hidden rounded-full bg-gray-700\">\n                                    <div\n                                      className=\"h-full bg-orange-500\"\n                                      style={{\n                                        width: `${Math.min(\n                                          (selectedAnomaly.analysisResults.materialProperties\n                                            .heatResistance /\n                                            2500) *\n                                            100,\n                                          100\n                                        )}%`,\n                                      }}\n                                    ></div>\n                                  </div>\n                                </div>\n                              )}\n                            </div>\n                          </div>\n                        </div>\n                      )}\n\n                    {/* Spatial Distortion */}\n                    {selectedAnomaly.investigated &&\n                      selectedAnomaly.analysisResults?.spatialDistortion && (\n                        <div className=\"overflow-hidden rounded-lg bg-gray-800\">\n                          <div className=\"p-3\">\n                            <div className=\"flex items-center space-x-2\">\n                              <Compass className=\"h-4 w-4 text-purple-400\" />\n                              <span className=\"text-sm font-medium text-white\">\n                                Spatial Distortion\n                              </span>\n                            </div>\n                          </div>\n                          <div className=\"border-t border-gray-700 p-3\">\n                            <div className=\"grid grid-cols-2 gap-4\">\n                              {/* Magnitude */}\n                              <div>\n                                <h4 className=\"mb-1 text-xs text-gray-400\">Magnitude</h4>\n                                <div className=\"flex items-center justify-between\">\n                                  <span className=\"text-sm text-white\">\n                                    {selectedAnomaly.analysisResults.spatialDistortion.magnitude.toFixed(\n                                      2\n                                    )}{' '}\n                                    units\n                                  </span>\n                                  <span className=\"text-xs text-gray-500\">\n                                    {selectedAnomaly.analysisResults.spatialDistortion.magnitude > 7\n                                      ? 'Extreme'\n                                      : selectedAnomaly.analysisResults.spatialDistortion\n                                            .magnitude > 5\n                                        ? 'Severe'\n                                        : selectedAnomaly.analysisResults.spatialDistortion\n                                              .magnitude > 3\n                                          ? 'Moderate'\n                                          : 'Mild'}\n                                  </span>\n                                </div>\n                                <div className=\"mt-1 h-1.5 w-full overflow-hidden rounded-full bg-gray-700\">\n                                  <div\n                                    className={`h-full ${\n                                      selectedAnomaly.analysisResults.spatialDistortion.magnitude >\n                                      7\n                                        ? 'bg-red-500'\n                                        : selectedAnomaly.analysisResults.spatialDistortion\n                                              .magnitude > 4\n                                          ? 'bg-yellow-500'\n                                          : 'bg-blue-500'\n                                    }`}\n                                    style={{\n                                      width: `${Math.min(\n                                        (selectedAnomaly.analysisResults.spatialDistortion\n                                          .magnitude /\n                                          10) *\n                                          100,\n                                        100\n                                      )}%`,\n                                    }}\n                                  ></div>\n                                </div>\n                              </div>\n\n                              {/* Radius */}\n                              <div>\n                                <h4 className=\"mb-1 text-xs text-gray-400\">Affected Radius</h4>\n                                <div className=\"flex items-center justify-between\">\n                                  <span className=\"text-sm text-white\">\n                                    {selectedAnomaly.analysisResults.spatialDistortion.radius.toFixed(\n                                      0\n                                    )}{' '}\n                                    m\n                                  </span>\n                                  <span className=\"text-xs text-gray-500\">\n                                    {selectedAnomaly.analysisResults.spatialDistortion.radius > 800\n                                      ? 'Vast'\n                                      : selectedAnomaly.analysisResults.spatialDistortion.radius >\n                                          500\n                                        ? 'Large'\n                                        : selectedAnomaly.analysisResults.spatialDistortion.radius >\n                                            200\n                                          ? 'Medium'\n                                          : 'Small'}\n                                  </span>\n                                </div>\n                                <div className=\"mt-1 h-1.5 w-full overflow-hidden rounded-full bg-gray-700\">\n                                  <div\n                                    className=\"h-full bg-purple-500\"\n                                    style={{\n                                      width: `${Math.min(\n                                        (selectedAnomaly.analysisResults.spatialDistortion.radius /\n                                          1000) *\n                                          100,\n                                        100\n                                      )}%`,\n                                    }}\n                                  ></div>\n                                </div>\n                              </div>\n\n                              {/* Stability */}\n                              <div>\n                                <h4 className=\"mb-1 text-xs text-gray-400\">Stability</h4>\n                                <div className=\"flex items-center justify-between\">\n                                  <span className=\"text-sm text-white\">\n                                    {selectedAnomaly.analysisResults.spatialDistortion.stability.toFixed(\n                                      0\n                                    )}\n                                    %\n                                  </span>\n                                  <span className=\"text-xs text-gray-500\">\n                                    {selectedAnomaly.analysisResults.spatialDistortion.stability >\n                                    80\n                                      ? 'Very Stable'\n                                      : selectedAnomaly.analysisResults.spatialDistortion\n                                            .stability > 60\n                                        ? 'Stable'\n                                        : selectedAnomaly.analysisResults.spatialDistortion\n                                              .stability > 40\n                                          ? 'Unstable'\n                                          : 'Highly Unstable'}\n                                  </span>\n                                </div>\n                                <div className=\"mt-1 h-1.5 w-full overflow-hidden rounded-full bg-gray-700\">\n                                  <div\n                                    className={`h-full ${\n                                      selectedAnomaly.analysisResults.spatialDistortion.stability >\n                                      70\n                                        ? 'bg-green-500'\n                                        : selectedAnomaly.analysisResults.spatialDistortion\n                                              .stability > 40\n                                          ? 'bg-yellow-500'\n                                          : 'bg-red-500'\n                                    }`}\n                                    style={{\n                                      width: `${Math.min(\n                                        selectedAnomaly.analysisResults.spatialDistortion.stability,\n                                        100\n                                      )}%`,\n                                    }}\n                                  ></div>\n                                </div>\n                              </div>\n\n                              {/* Fluctuation Rate */}\n                              <div>\n                                <h4 className=\"mb-1 text-xs text-gray-400\">Fluctuation Rate</h4>\n                                <div className=\"flex items-center justify-between\">\n                                  <span className=\"text-sm text-white\">\n                                    {selectedAnomaly.analysisResults.spatialDistortion.fluctuationRate.toFixed(\n                                      2\n                                    )}{' '}\n                                    Hz\n                                  </span>\n                                  <span className=\"text-xs text-gray-500\">\n                                    {selectedAnomaly.analysisResults.spatialDistortion\n                                      .fluctuationRate > 7\n                                      ? 'Rapid'\n                                      : selectedAnomaly.analysisResults.spatialDistortion\n                                            .fluctuationRate > 4\n                                        ? 'Moderate'\n                                        : selectedAnomaly.analysisResults.spatialDistortion\n                                              .fluctuationRate > 2\n                                          ? 'Slow'\n                                          : 'Very Slow'}\n                                  </span>\n                                </div>\n                                <div className=\"mt-1 h-1.5 w-full overflow-hidden rounded-full bg-gray-700\">\n                                  <div\n                                    className=\"h-full bg-indigo-500\"\n                                    style={{\n                                      width: `${Math.min(\n                                        (selectedAnomaly.analysisResults.spatialDistortion\n                                          .fluctuationRate /\n                                          10) *\n                                          100,\n                                        100\n                                      )}%`,\n                                    }}\n                                  ></div>\n                                </div>\n                              </div>\n                            </div>\n                          </div>\n                        </div>\n                      )}\n\n                    {/* Biological Impact */}\n                    {selectedAnomaly.investigated &&\n                      selectedAnomaly.analysisResults?.biologicalImpact && (\n                        <div className=\"overflow-hidden rounded-lg bg-gray-800\">\n                          <div className=\"p-3\">\n                            <div className=\"flex items-center space-x-2\">\n                              <Shield className=\"h-4 w-4 text-red-400\" />\n                              <span className=\"text-sm font-medium text-white\">\n                                Biological Impact\n                              </span>\n                            </div>\n                          </div>\n                          <div className=\"border-t border-gray-700 p-3\">\n                            <div className=\"grid grid-cols-2 gap-4\">\n                              {/* Toxicity */}\n                              <div>\n                                <h4 className=\"mb-1 text-xs text-gray-400\">Toxicity</h4>\n                                <div className=\"flex items-center justify-between\">\n                                  <span className=\"text-sm text-white\">\n                                    {selectedAnomaly.analysisResults.biologicalImpact.toxicity.toFixed(\n                                      1\n                                    )}{' '}\n                                    / 10\n                                  </span>\n                                  <span className=\"text-xs text-gray-500\">\n                                    {selectedAnomaly.analysisResults.biologicalImpact.toxicity > 7\n                                      ? 'Lethal'\n                                      : selectedAnomaly.analysisResults.biologicalImpact.toxicity >\n                                          5\n                                        ? 'Severe'\n                                        : selectedAnomaly.analysisResults.biologicalImpact\n                                              .toxicity > 3\n                                          ? 'Moderate'\n                                          : 'Low'}\n                                  </span>\n                                </div>\n                                <div className=\"mt-1 h-1.5 w-full overflow-hidden rounded-full bg-gray-700\">\n                                  <div\n                                    className={`h-full ${\n                                      selectedAnomaly.analysisResults.biologicalImpact.toxicity > 7\n                                        ? 'bg-red-500'\n                                        : selectedAnomaly.analysisResults.biologicalImpact\n                                              .toxicity > 4\n                                          ? 'bg-yellow-500'\n                                          : 'bg-green-500'\n                                    }`}\n                                    style={{\n                                      width: `${Math.min(\n                                        (selectedAnomaly.analysisResults.biologicalImpact.toxicity /\n                                          10) *\n                                          100,\n                                        100\n                                      )}%`,\n                                    }}\n                                  ></div>\n                                </div>\n                              </div>\n\n                              {/* Mutagenic Potential */}\n                              <div>\n                                <h4 className=\"mb-1 text-xs text-gray-400\">Mutagenic Potential</h4>\n                                <div className=\"flex items-center justify-between\">\n                                  <span className=\"text-sm text-white\">\n                                    {selectedAnomaly.analysisResults.biologicalImpact.mutagenicPotential.toFixed(\n                                      1\n                                    )}{' '}\n                                    / 10\n                                  </span>\n                                  <span className=\"text-xs text-gray-500\">\n                                    {selectedAnomaly.analysisResults.biologicalImpact\n                                      .mutagenicPotential > 7\n                                      ? 'Extreme'\n                                      : selectedAnomaly.analysisResults.biologicalImpact\n                                            .mutagenicPotential > 5\n                                        ? 'High'\n                                        : selectedAnomaly.analysisResults.biologicalImpact\n                                              .mutagenicPotential > 3\n                                          ? 'Moderate'\n                                          : 'Low'}\n                                  </span>\n                                </div>\n                                <div className=\"mt-1 h-1.5 w-full overflow-hidden rounded-full bg-gray-700\">\n                                  <div\n                                    className={`h-full ${\n                                      selectedAnomaly.analysisResults.biologicalImpact\n                                        .mutagenicPotential > 7\n                                        ? 'bg-purple-500'\n                                        : selectedAnomaly.analysisResults.biologicalImpact\n                                              .mutagenicPotential > 4\n                                          ? 'bg-yellow-500'\n                                          : 'bg-green-500'\n                                    }`}\n                                    style={{\n                                      width: `${Math.min(\n                                        (selectedAnomaly.analysisResults.biologicalImpact\n                                          .mutagenicPotential /\n                                          10) *\n                                          100,\n                                        100\n                                      )}%`,\n                                    }}\n                                  ></div>\n                                </div>\n                              </div>\n\n                              {/* Biocompatibility */}\n                              <div>\n                                <h4 className=\"mb-1 text-xs text-gray-400\">Biocompatibility</h4>\n                                <div className=\"flex items-center justify-between\">\n                                  <span className=\"text-sm text-white\">\n                                    {selectedAnomaly.analysisResults.biologicalImpact.biocompatibility.toFixed(\n                                      0\n                                    )}\n                                    %\n                                  </span>\n                                  <span className=\"text-xs text-gray-500\">\n                                    {selectedAnomaly.analysisResults.biologicalImpact\n                                      .biocompatibility > 80\n                                      ? 'Excellent'\n                                      : selectedAnomaly.analysisResults.biologicalImpact\n                                            .biocompatibility > 60\n                                        ? 'Good'\n                                        : selectedAnomaly.analysisResults.biologicalImpact\n                                              .biocompatibility > 40\n                                          ? 'Fair'\n                                          : 'Poor'}\n                                  </span>\n                                </div>\n                                <div className=\"mt-1 h-1.5 w-full overflow-hidden rounded-full bg-gray-700\">\n                                  <div\n                                    className={`h-full ${\n                                      selectedAnomaly.analysisResults.biologicalImpact\n                                        .biocompatibility > 70\n                                        ? 'bg-green-500'\n                                        : selectedAnomaly.analysisResults.biologicalImpact\n                                              .biocompatibility > 40\n                                          ? 'bg-yellow-500'\n                                          : 'bg-red-500'\n                                    }`}\n                                    style={{\n                                      width: `${Math.min(\n                                        selectedAnomaly.analysisResults.biologicalImpact\n                                          .biocompatibility,\n                                        100\n                                      )}%`,\n                                    }}\n                                  ></div>\n                                </div>\n                              </div>\n\n                              {/* Lifeform Detection */}\n                              <div>\n                                <h4 className=\"mb-1 text-xs text-gray-400\">Lifeform Detection</h4>\n                                <div className=\"flex items-center space-x-2\">\n                                  <div\n                                    className={`h-3 w-3 rounded-full ${\n                                      selectedAnomaly.analysisResults.biologicalImpact\n                                        .lifeformDetection\n                                        ? 'bg-green-500'\n                                        : 'bg-red-500'\n                                    }`}\n                                  ></div>\n                                  <span className=\"text-sm text-white\">\n                                    {selectedAnomaly.analysisResults.biologicalImpact\n                                      .lifeformDetection\n                                      ? 'Detected'\n                                      : 'Not Detected'}\n                                  </span>\n                                </div>\n                                {selectedAnomaly.analysisResults.biologicalImpact\n                                  .lifeformDetection && (\n                                  <p className=\"mt-1 text-xs text-gray-400\">\n                                    Further analysis recommended to identify lifeform type and\n                                    characteristics.\n                                  </p>\n                                )}\n                              </div>\n                            </div>\n                          </div>\n                        </div>\n                      )}\n\n                    {/* Not investigated message */}\n                    {!selectedAnomaly.investigated && (\n                      <div className=\"flex flex-col items-center justify-center rounded-lg bg-gray-800 p-6 text-center\">\n                        <Microscope className=\"mb-3 h-10 w-10 text-gray-500\" />\n                        <h3 className=\"mb-2 text-lg font-medium text-white\">\n                          Detailed Analysis Unavailable\n                        </h3>\n                        <p className=\"mb-4 text-sm text-gray-400\">\n                          This anomaly has not been investigated yet. Begin analysis to access\n                          detailed information.\n                        </p>\n                        <button\n                          onClick={() => handleInvestigate(selectedAnomaly.id)}\n                          className=\"rounded bg-blue-700 px-4 py-2 text-white transition-colors hover:bg-blue-600\"\n                        >\n                          Begin Analysis\n                        </button>\n                      </div>\n                    )}\n                  </div>\n                )}\n\n                {/* Research tab will be implemented in the next step */}\n                {activeTab === ResourceType.RESEARCH && (\n                  <div className=\"p-4 text-white\">\n                    Research tab content will be implemented in the next step\n                  </div>\n                )}\n\n                {/* Exploitation tab will be implemented in the next step */}\n                {activeTab === 'exploitation' && (\n                  <div className=\"p-4 text-white\">\n                    Exploitation tab content will be implemented in the next step\n                  </div>\n                )}\n              </div>\n            </div>\n          ) : (\n            <div className=\"flex h-full flex-col items-center justify-center text-gray-400\">\n              <AlertTriangle className=\"mb-4 h-12 w-12 opacity-50\" />\n              <p className=\"text-lg\">Select an anomaly to view details</p>\n              <p className=\"mt-2 text-sm\">\n                {filteredAndSortedAnomalies.length === 0\n                  ? 'No anomalies match the current filter'\n                  : `${filteredAndSortedAnomalies.length} anomalies available`}\n              </p>\n            </div>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/DiscoveryClassification.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/ExplorationDataManager.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_onUpdateCategory' is defined but never used.","line":108,"column":21,"nodeType":null,"messageId":"unusedVar","endLine":108,"endColumn":38},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_onDeleteCategory' is defined but never used.","line":109,"column":21,"nodeType":null,"messageId":"unusedVar","endLine":109,"endColumn":38}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  CheckSquare,\n  Database,\n  Download,\n  FileText,\n  Folder,\n  FolderOpen,\n  Search,\n  SortAsc,\n  SortDesc,\n  Square,\n  Star,\n  StarOff,\n  Tag,\n  Trash2,\n  Upload,\n} from 'lucide-react';\nimport * as React from 'react';\nimport { useCallback, useEffect, useState } from 'react';\nimport { moduleEventBus } from '../../lib/events/ModuleEventBus';\nimport { EventType } from '../../types/events/EventTypes';\nimport { StandardizedEvent } from '../../types/events/StandardizedEvents';\nimport { ResourceType } from './../../types/resources/ResourceTypes';\n// Types from other components\ninterface Anomaly {\n  id: string;\n  type: 'artifact' | 'signal' | 'phenomenon';\n  severity: 'low' | 'medium' | 'high';\n  description: string;\n  investigated: boolean;\n  discoveryDate: number;\n  sectorId: string;\n  sectorName: string;\n  coordinates: { x: number; y: number };\n}\n\ninterface Sector {\n  id: string;\n  name: string;\n  status: 'unmapped' | 'mapped' | 'scanning' | 'analyzed';\n  coordinates: { x: number; y: number };\n  resourcePotential: number;\n  habitabilityScore: number;\n  anomalies: Anomaly[];\n  lastScanned?: number;\n}\n\ninterface ResourceData {\n  type:\n    | ResourceType.MINERALS\n    | ResourceType.GAS\n    | ResourceType.ENERGY\n    | 'organic'\n    | ResourceType.EXOTIC;\n  name: string;\n  amount: number;\n  quality: number;\n  accessibility: number;\n  distribution: 'concentrated' | 'scattered' | 'veins';\n  estimatedValue: number;\n  extractionDifficulty: number;\n}\n\n// Exploration data types\ninterface ExplorationRecord {\n  id: string;\n  type: 'sector' | 'anomaly' | 'resource';\n  name: string;\n  date: number;\n  tags: string[];\n  starred: boolean;\n  notes?: string;\n  data: Sector | Anomaly | ResourceData;\n  relatedRecords?: string[];\n  category?: string;\n}\n\ninterface ExplorationCategory {\n  id: string;\n  name: string;\n  color: string;\n  recordCount: number;\n  parentId?: string;\n  subCategories?: string[];\n}\n\ninterface ExplorationDataManagerProps {\n  records: ExplorationRecord[];\n  categories: ExplorationCategory[];\n  onSaveRecord: (record: ExplorationRecord) => void;\n  onDeleteRecord: (recordId: string) => void;\n  onExportData: (recordIds: string[]) => void;\n  onImportData: () => void;\n  onCreateCategory: (category: Omit<ExplorationCategory, 'id' | 'recordCount'>) => void;\n  onUpdateCategory: (category: ExplorationCategory) => void;\n  onDeleteCategory: (categoryId: string) => void;\n  className?: string;\n}\n\nexport function ExplorationDataManager({\n  records,\n  categories,\n  onSaveRecord,\n  onDeleteRecord,\n  onExportData,\n  onImportData,\n  onCreateCategory,\n  onUpdateCategory: _onUpdateCategory,\n  onDeleteCategory: _onDeleteCategory,\n  className = '',\n}: ExplorationDataManagerProps) {\n  // State\n  const [searchTerm, setSearchTerm] = useState('');\n  const [selectedRecordIds, setSelectedRecordIds] = useState<string[]>([]);\n  const [selectedCategoryId, setSelectedCategoryId] = useState<string | null>(null);\n  const [expandedCategories, setExpandedCategories] = useState<Record<string, boolean>>({});\n  const [sortField, setSortField] = useState<'name' | 'date' | 'type'>('date');\n  const [sortDirection, setSortDirection] = useState<'asc' | 'desc'>('desc');\n  const [filterType, setFilterType] = useState<'all' | 'sector' | 'anomaly' | 'resource'>('all');\n  const [filterStarred, setFilterStarred] = useState(false);\n  const [filterTags, setFilterTags] = useState<string[]>([]);\n  const [_editingRecord, _setEditingRecord] = useState<ExplorationRecord | null>(null);\n  const [newCategoryName, setNewCategoryName] = useState('');\n  const [newCategoryColor, setNewCategoryColor] = useState('#3b82f6'); // Default blue\n  const [newCategoryParentId, setNewCategoryParentId] = useState<string | undefined>(undefined);\n\n  // Get all unique tags from records\n  const allTags = React.useMemo(() => {\n    const tags = new Set<string>();\n    records.forEach(record => {\n      record.tags.forEach(tag => tags.add(tag));\n    });\n    return Array.from(tags).sort();\n  }, [records]);\n\n  // Filter and sort records\n  const filteredRecords = React.useMemo(() => {\n    return records\n      .filter(record => {\n        // Search term filter\n        if (searchTerm && !record.name.toLowerCase().includes(searchTerm.toLowerCase())) {\n          return false;\n        }\n\n        // Type filter\n        if (filterType !== 'all' && record.type !== filterType) {\n          return false;\n        }\n\n        // Starred filter\n        if (filterStarred && !record.starred) {\n          return false;\n        }\n\n        // Tags filter\n        if (filterTags.length > 0 && !filterTags.some(tag => record.tags.includes(tag))) {\n          return false;\n        }\n\n        // Category filter\n        if (selectedCategoryId && record.category !== selectedCategoryId) {\n          return false;\n        }\n\n        return true;\n      })\n      .sort((a, b) => {\n        let comparison = 0;\n\n        if (sortField === 'name') {\n          comparison = a.name.localeCompare(b.name);\n        } else if (sortField === 'date') {\n          comparison = a.date - b.date;\n        } else if (sortField === 'type') {\n          comparison = a.type.localeCompare(b.type);\n        }\n\n        return sortDirection === 'asc' ? comparison : -comparison;\n      });\n  }, [\n    records,\n    searchTerm,\n    filterType,\n    filterStarred,\n    filterTags,\n    selectedCategoryId,\n    sortField,\n    sortDirection,\n  ]);\n\n  // Handle sort change\n  const handleSortChange = (field: 'name' | 'date' | 'type') => {\n    if (sortField === field) {\n      setSortDirection(sortDirection === 'asc' ? 'desc' : 'asc');\n    } else {\n      setSortField(field);\n      setSortDirection('asc');\n    }\n  };\n\n  // Handle record selection with standardized events\n  const handleRecordSelect = useCallback((recordId: string, multiSelect = false) => {\n    if (multiSelect) {\n      setSelectedRecordIds(prev => {\n        const newSelection = prev.includes(recordId)\n          ? prev.filter(id => id !== recordId)\n          : [...prev, recordId];\n\n        // Emit selection event\n        const event: StandardizedEvent = {\n          type: EventType.MODULE_UPDATED,\n          moduleId: recordId,\n          moduleType: 'exploration',\n          timestamp: Date.now(),\n          data: {\n            action: 'select',\n            selectionType: 'multi',\n            selectedIds: newSelection,\n          },\n        };\n        moduleEventBus.emit(event);\n\n        return newSelection;\n      });\n    } else {\n      setSelectedRecordIds([recordId]);\n\n      // Emit selection event\n      const event: StandardizedEvent = {\n        type: EventType.MODULE_UPDATED,\n        moduleId: recordId,\n        moduleType: 'exploration',\n        timestamp: Date.now(),\n        data: {\n          action: 'select',\n          selectionType: 'single',\n          selectedIds: [recordId],\n        },\n      };\n      moduleEventBus.emit(event);\n    }\n  }, []);\n\n  // Handle select all\n  const handleSelectAll = () => {\n    if (selectedRecordIds.length === filteredRecords.length) {\n      setSelectedRecordIds([]);\n    } else {\n      setSelectedRecordIds(filteredRecords.map(record => record.id));\n    }\n  };\n\n  // Handle record star toggle with standardized events\n  const handleToggleStar = useCallback(\n    (recordId: string) => {\n      const record = records.find(r => r.id === recordId);\n      if (record) {\n        const updatedRecord = {\n          ...record,\n          starred: !record.starred,\n        };\n        onSaveRecord(updatedRecord);\n\n        // Emit star toggle event\n        const event: StandardizedEvent = {\n          type: EventType.MODULE_UPDATED,\n          moduleId: recordId,\n          moduleType: 'exploration',\n          timestamp: Date.now(),\n          data: {\n            action: 'toggle_star',\n            starred: !record.starred,\n          },\n        };\n        moduleEventBus.emit(event);\n      }\n    },\n    [records, onSaveRecord]\n  );\n\n  // Handle tag toggle\n  const handleToggleTag = (tag: string) => {\n    setFilterTags(prev => {\n      if (prev.includes(tag)) {\n        return prev.filter(t => t !== tag);\n      } else {\n        return [...prev, tag];\n      }\n    });\n  };\n\n  // Handle category toggle with standardized events\n  const handleToggleCategory = useCallback((categoryId: string) => {\n    setExpandedCategories(prev => {\n      const isExpanded = !prev[categoryId];\n\n      // Emit category toggle event\n      const event: StandardizedEvent = {\n        type: EventType.MODULE_UPDATED,\n        moduleId: categoryId,\n        moduleType: 'exploration',\n        timestamp: Date.now(),\n        data: {\n          action: 'toggle_category',\n          expanded: isExpanded,\n        },\n      };\n      moduleEventBus.emit(event);\n\n      return {\n        ...prev,\n        [categoryId]: isExpanded,\n      };\n    });\n  }, []);\n\n  // Handle create category with standardized events\n  const handleCreateCategory = useCallback(() => {\n    if (newCategoryName.trim()) {\n      const categoryData = {\n        name: newCategoryName.trim(),\n        color: newCategoryColor,\n        parentId: newCategoryParentId,\n        subCategories: [],\n      };\n      onCreateCategory(categoryData);\n\n      // Emit category create event\n      const event: StandardizedEvent = {\n        type: EventType.MODULE_UPDATED,\n        moduleId: `category-${Date.now()}`, // Temporary ID until actual category is created\n        moduleType: 'exploration',\n        timestamp: Date.now(),\n        data: {\n          action: 'create_category',\n          categoryData,\n        },\n      };\n      moduleEventBus.emit(event);\n\n      setNewCategoryName('');\n      setNewCategoryColor('#3b82f6');\n      setNewCategoryParentId(undefined);\n    }\n  }, [newCategoryName, newCategoryColor, newCategoryParentId, onCreateCategory]);\n\n  // Format date\n  const formatDate = (timestamp: number) => {\n    return new Date(timestamp).toLocaleDateString('en-US', {\n      year: 'numeric',\n      month: 'short',\n      day: 'numeric',\n    });\n  };\n\n  // Get record icon\n  const getRecordIcon = (type: ExplorationRecord['type']) => {\n    switch (type) {\n      case 'sector':\n        return <Folder className=\"h-4 w-4\" />;\n      case 'anomaly':\n        return <Star className=\"h-4 w-4\" />;\n      case 'resource':\n        return <Database className=\"h-4 w-4\" />;\n    }\n  };\n\n  // Get record type color\n  const getRecordTypeColor = (type: ExplorationRecord['type']) => {\n    switch (type) {\n      case 'sector':\n        return 'text-blue-400';\n      case 'anomaly':\n        return 'text-yellow-400';\n      case 'resource':\n        return 'text-green-400';\n    }\n  };\n\n  // Get category by ID\n  const getCategoryById = (categoryId: string) => {\n    return categories.find(category => category.id === categoryId);\n  };\n\n  // Render category tree\n  const renderCategoryTree = (parentId?: string, depth = 0) => {\n    const categoryItems = categories\n      .filter(category => category.parentId === parentId)\n      .sort((a, b) => a.name.localeCompare(b.name));\n\n    if (categoryItems.length === 0) {\n      return null;\n    }\n\n    return (\n      <ul className={`space-y-1 ${depth > 0 ? 'ml-4' : ''}`}>\n        {categoryItems.map(category => {\n          const hasSubCategories = categories.some(c => c.parentId === category.id);\n          const isExpanded = expandedCategories[category.id];\n\n          return (\n            <li key={category.id}>\n              <div\n                className={`flex cursor-pointer items-center rounded px-2 py-1 ${\n                  selectedCategoryId === category.id ? 'bg-gray-700' : 'hover:bg-gray-800'\n                }`}\n              >\n                <button\n                  className=\"mr-1 text-gray-400 hover:text-gray-300\"\n                  onClick={() => handleToggleCategory(category.id)}\n                  style={{ visibility: hasSubCategories ? 'visible' : 'hidden' }}\n                >\n                  {isExpanded ? <FolderOpen size={14} /> : <Folder size={14} />}\n                </button>\n\n                <div\n                  className=\"flex flex-grow items-center\"\n                  onClick={() =>\n                    setSelectedCategoryId(selectedCategoryId === category.id ? null : category.id)\n                  }\n                >\n                  <div\n                    className=\"mr-2 h-2 w-2 rounded-full\"\n                    style={{ backgroundColor: category.color }}\n                  />\n                  <span className=\"text-sm text-gray-300\">{category.name}</span>\n                  <span className=\"ml-2 text-xs text-gray-500\">{category.recordCount}</span>\n                </div>\n              </div>\n\n              {isExpanded && hasSubCategories && renderCategoryTree(category.id, depth + 1)}\n            </li>\n          );\n        })}\n      </ul>\n    );\n  };\n\n  // Cleanup subscriptions on unmount\n  useEffect(() => {\n    const cleanup = () => {\n      // Any cleanup needed for event subscriptions\n    };\n\n    return cleanup;\n  }, []);\n\n  return (\n    <div className={`flex h-full flex-col bg-gray-900 ${className}`}>\n      {/* Header */}\n      <div className=\"flex items-center justify-between border-b border-gray-700 bg-gray-800 p-3\">\n        <div className=\"flex items-center space-x-2\">\n          <FileText className=\"h-5 w-5 text-blue-400\" />\n          <h2 className=\"text-lg font-bold text-white\">Exploration Data</h2>\n        </div>\n\n        <div className=\"flex items-center space-x-2\">\n          <button\n            className=\"rounded p-1.5 text-gray-400 hover:bg-gray-700\"\n            title=\"Import Data\"\n            onClick={onImportData}\n          >\n            <Upload size={16} />\n          </button>\n\n          <button\n            className={`rounded p-1.5 ${\n              selectedRecordIds.length > 0\n                ? 'text-blue-400 hover:bg-gray-700'\n                : 'cursor-not-allowed text-gray-600'\n            }`}\n            title=\"Export Selected Data\"\n            onClick={() => selectedRecordIds.length > 0 && onExportData(selectedRecordIds)}\n            disabled={selectedRecordIds.length === 0}\n          >\n            <Download size={16} />\n          </button>\n\n          <button\n            className={`rounded p-1.5 ${\n              selectedRecordIds.length > 0\n                ? 'text-red-400 hover:bg-gray-700'\n                : 'cursor-not-allowed text-gray-600'\n            }`}\n            title=\"Delete Selected Records\"\n            onClick={() => {\n              if (\n                selectedRecordIds.length > 0 &&\n                window.confirm(`Delete ${selectedRecordIds.length} selected records?`)\n              ) {\n                selectedRecordIds.forEach(id => onDeleteRecord(id));\n                setSelectedRecordIds([]);\n              }\n            }}\n            disabled={selectedRecordIds.length === 0}\n          >\n            <Trash2 size={16} />\n          </button>\n        </div>\n      </div>\n\n      <div className=\"flex flex-grow overflow-hidden\">\n        {/* Sidebar */}\n        <div className=\"bg-gray-850 flex w-64 flex-col border-r border-gray-700\">\n          {/* Search */}\n          <div className=\"border-b border-gray-700 p-3\">\n            <div className=\"relative\">\n              <input\n                type=\"text\"\n                value={searchTerm}\n                onChange={e => setSearchTerm(e.target.value)}\n                placeholder=\"Search records...\"\n                className=\"w-full rounded border border-gray-600 bg-gray-700 py-1.5 pl-8 pr-3 text-sm text-gray-300\"\n              />\n              <Search\n                size={14}\n                className=\"absolute left-2.5 top-1/2 -translate-y-1/2 transform text-gray-400\"\n              />\n            </div>\n          </div>\n\n          {/* Filters */}\n          <div className=\"border-b border-gray-700 p-3\">\n            <h3 className=\"mb-2 text-xs font-semibold uppercase text-gray-400\">Filters</h3>\n\n            <div className=\"space-y-3\">\n              {/* Type filter */}\n              <div>\n                <label className=\"mb-1 block text-xs text-gray-400\">Record Type</label>\n                <div className=\"flex flex-wrap gap-1\">\n                  <button\n                    onClick={() => setFilterType('all')}\n                    className={`rounded px-2 py-0.5 text-xs ${\n                      filterType === 'all'\n                        ? 'bg-blue-900 text-blue-300'\n                        : 'bg-gray-700 text-gray-300 hover:bg-gray-600'\n                    }`}\n                  >\n                    All\n                  </button>\n\n                  <button\n                    onClick={() => setFilterType('sector')}\n                    className={`flex items-center space-x-1 rounded px-2 py-0.5 text-xs ${\n                      filterType === 'sector'\n                        ? 'bg-blue-900 text-blue-300'\n                        : 'bg-gray-700 text-gray-300 hover:bg-gray-600'\n                    }`}\n                  >\n                    <Folder size={12} />\n                    <span>Sectors</span>\n                  </button>\n\n                  <button\n                    onClick={() => setFilterType('anomaly')}\n                    className={`flex items-center space-x-1 rounded px-2 py-0.5 text-xs ${\n                      filterType === 'anomaly'\n                        ? 'bg-yellow-900 text-yellow-300'\n                        : 'bg-gray-700 text-gray-300 hover:bg-gray-600'\n                    }`}\n                  >\n                    <Star size={12} />\n                    <span>Anomalies</span>\n                  </button>\n\n                  <button\n                    onClick={() => setFilterType('resource')}\n                    className={`flex items-center space-x-1 rounded px-2 py-0.5 text-xs ${\n                      filterType === 'resource'\n                        ? 'bg-green-900 text-green-300'\n                        : 'bg-gray-700 text-gray-300 hover:bg-gray-600'\n                    }`}\n                  >\n                    <Database size={12} />\n                    <span>Resources</span>\n                  </button>\n                </div>\n              </div>\n\n              {/* Starred filter */}\n              <div>\n                <button\n                  onClick={() => setFilterStarred(!filterStarred)}\n                  className={`flex items-center space-x-1 rounded px-2 py-1 text-xs ${\n                    filterStarred\n                      ? 'bg-yellow-900/50 text-yellow-300'\n                      : 'text-gray-400 hover:bg-gray-700'\n                  }`}\n                >\n                  {filterStarred ? (\n                    <Star size={12} className=\"text-yellow-300\" />\n                  ) : (\n                    <StarOff size={12} />\n                  )}\n                  <span>Starred Records</span>\n                </button>\n              </div>\n\n              {/* Tags filter */}\n              <div>\n                <label className=\"mb-1 block text-xs text-gray-400\">Tags</label>\n                <div className=\"flex max-h-24 flex-wrap gap-1 overflow-y-auto\">\n                  {allTags.map(tag => (\n                    <button\n                      key={tag}\n                      onClick={() => handleToggleTag(tag)}\n                      className={`flex items-center space-x-1 rounded px-2 py-0.5 text-xs ${\n                        filterTags.includes(tag)\n                          ? 'bg-purple-900 text-purple-300'\n                          : 'bg-gray-700 text-gray-300 hover:bg-gray-600'\n                      }`}\n                    >\n                      <Tag size={10} />\n                      <span>{tag}</span>\n                    </button>\n                  ))}\n\n                  {allTags.length === 0 && (\n                    <span className=\"text-xs text-gray-500\">No tags available</span>\n                  )}\n                </div>\n              </div>\n            </div>\n          </div>\n\n          {/* Categories */}\n          <div className=\"border-b border-gray-700 p-3\">\n            <div className=\"mb-2 flex items-center justify-between\">\n              <h3 className=\"text-xs font-semibold uppercase text-gray-400\">Categories</h3>\n              <button\n                className=\"text-xs text-blue-400 hover:text-blue-300\"\n                onClick={() => setSelectedCategoryId(null)}\n              >\n                Clear\n              </button>\n            </div>\n\n            <div className=\"mb-3 max-h-48 overflow-y-auto\">\n              {renderCategoryTree()}\n\n              {categories.length === 0 && (\n                <p className=\"text-xs text-gray-500\">No categories available</p>\n              )}\n            </div>\n\n            {/* Create category */}\n            <div className=\"space-y-2\">\n              <input\n                type=\"text\"\n                value={newCategoryName}\n                onChange={e => setNewCategoryName(e.target.value)}\n                placeholder=\"New category name...\"\n                className=\"w-full rounded border border-gray-600 bg-gray-700 px-2 py-1 text-xs text-gray-300\"\n              />\n\n              <div className=\"flex space-x-2\">\n                <input\n                  type=\"color\"\n                  value={newCategoryColor}\n                  onChange={e => setNewCategoryColor(e.target.value)}\n                  className=\"h-6 w-6 cursor-pointer rounded\"\n                />\n\n                <select\n                  value={newCategoryParentId ?? ''}\n                  onChange={e => setNewCategoryParentId(e.target.value || undefined)}\n                  className=\"flex-grow rounded border border-gray-600 bg-gray-700 px-1 py-1 text-xs text-gray-300\"\n                >\n                  <option value=\"\">No parent</option>\n                  {categories.map(category => (\n                    <option key={category.id} value={category.id}>\n                      {category.name}\n                    </option>\n                  ))}\n                </select>\n\n                <button\n                  onClick={handleCreateCategory}\n                  disabled={!newCategoryName.trim()}\n                  className={`rounded px-2 py-1 text-xs ${\n                    newCategoryName.trim()\n                      ? 'bg-blue-700 text-white hover:bg-blue-600'\n                      : 'cursor-not-allowed bg-gray-700 text-gray-500'\n                  }`}\n                >\n                  Add\n                </button>\n              </div>\n            </div>\n          </div>\n\n          {/* Stats */}\n          <div className=\"mt-auto border-t border-gray-700 p-3 text-xs text-gray-400\">\n            <div className=\"mb-1 flex justify-between\">\n              <span>Total Records:</span>\n              <span>{records.length}</span>\n            </div>\n            <div className=\"mb-1 flex justify-between\">\n              <span>Sectors:</span>\n              <span>{records.filter(r => r.type === 'sector').length}</span>\n            </div>\n            <div className=\"mb-1 flex justify-between\">\n              <span>Anomalies:</span>\n              <span>{records.filter(r => r.type === 'anomaly').length}</span>\n            </div>\n            <div className=\"flex justify-between\">\n              <span>Resources:</span>\n              <span>{records.filter(r => r.type === 'resource').length}</span>\n            </div>\n          </div>\n        </div>\n\n        {/* Main content */}\n        <div className=\"flex flex-grow flex-col\">\n          {/* Toolbar */}\n          <div className=\"flex items-center border-b border-gray-700 bg-gray-800 p-2\">\n            <div className=\"flex items-center space-x-2\">\n              <button\n                onClick={handleSelectAll}\n                className=\"p-1 text-gray-400 hover:text-gray-300\"\n                title={\n                  selectedRecordIds.length === filteredRecords.length\n                    ? 'Deselect All'\n                    : 'Select All'\n                }\n              >\n                {selectedRecordIds.length === filteredRecords.length &&\n                filteredRecords.length > 0 ? (\n                  <CheckSquare size={16} />\n                ) : (\n                  <Square size={16} />\n                )}\n              </button>\n\n              <span className=\"text-xs text-gray-400\">\n                {selectedRecordIds.length > 0\n                  ? `${selectedRecordIds.length} selected`\n                  : `${filteredRecords.length} records`}\n              </span>\n            </div>\n\n            <div className=\"ml-auto flex items-center space-x-3\">\n              <button\n                onClick={() => handleSortChange('name')}\n                className={`flex items-center space-x-1 rounded px-2 py-1 text-xs ${\n                  sortField === 'name'\n                    ? 'bg-blue-900/30 text-blue-300'\n                    : 'text-gray-400 hover:bg-gray-700'\n                }`}\n              >\n                <span>Name</span>\n                {sortField === 'name' &&\n                  (sortDirection === 'asc' ? <SortAsc size={12} /> : <SortDesc size={12} />)}\n              </button>\n\n              <button\n                onClick={() => handleSortChange('date')}\n                className={`flex items-center space-x-1 rounded px-2 py-1 text-xs ${\n                  sortField === 'date'\n                    ? 'bg-blue-900/30 text-blue-300'\n                    : 'text-gray-400 hover:bg-gray-700'\n                }`}\n              >\n                <span>Date</span>\n                {sortField === 'date' &&\n                  (sortDirection === 'asc' ? <SortAsc size={12} /> : <SortDesc size={12} />)}\n              </button>\n\n              <button\n                onClick={() => handleSortChange('type')}\n                className={`flex items-center space-x-1 rounded px-2 py-1 text-xs ${\n                  sortField === 'type'\n                    ? 'bg-blue-900/30 text-blue-300'\n                    : 'text-gray-400 hover:bg-gray-700'\n                }`}\n              >\n                <span>Type</span>\n                {sortField === 'type' &&\n                  (sortDirection === 'asc' ? <SortAsc size={12} /> : <SortDesc size={12} />)}\n              </button>\n            </div>\n          </div>\n\n          {/* Records list */}\n          <div className=\"flex-grow overflow-y-auto\">\n            {filteredRecords.length === 0 ? (\n              <div className=\"flex h-full flex-col items-center justify-center text-gray-400\">\n                <FileText className=\"mb-4 h-12 w-12 opacity-50\" />\n                <p className=\"text-lg\">No records found</p>\n                <p className=\"mt-2 text-sm\">Try adjusting your filters or adding new data</p>\n              </div>\n            ) : (\n              <div className=\"divide-y divide-gray-700\">\n                {filteredRecords.map(record => {\n                  const isSelected = selectedRecordIds.includes(record.id);\n                  const category = record.category ? getCategoryById(record.category) : null;\n\n                  return (\n                    <div\n                      key={record.id}\n                      className={`p-3 transition-colors ${\n                        isSelected ? 'bg-blue-900/20' : 'hover:bg-gray-800'\n                      }`}\n                      onClick={e => {\n                        // Don't trigger selection when clicking star button\n                        if ((e.target as HTMLElement).closest('.star-button')) return;\n                        handleRecordSelect(record.id, e.ctrlKey || e.metaKey);\n                      }}\n                    >\n                      <div className=\"flex items-start\">\n                        <div className=\"mr-3 flex h-5 items-center\">\n                          <div className={`${getRecordTypeColor(record.type)}`}>\n                            {getRecordIcon(record.type)}\n                          </div>\n                        </div>\n\n                        <div className=\"min-w-0 flex-grow\">\n                          <div className=\"flex items-start justify-between\">\n                            <div>\n                              <h3 className=\"text-sm font-medium text-white\">{record.name}</h3>\n                              <p className=\"mt-0.5 text-xs text-gray-400\">\n                                {formatDate(record.date)}\n                                {category && (\n                                  <span\n                                    className=\"ml-2 rounded px-1.5 py-0.5 text-xs\"\n                                    style={{\n                                      backgroundColor: `${category.color}30`,\n                                      color: category.color,\n                                    }}\n                                  >\n                                    {category.name}\n                                  </span>\n                                )}\n                              </p>\n                            </div>\n\n                            <button\n                              className=\"star-button p-1 text-gray-400 hover:text-yellow-400\"\n                              onClick={() => handleToggleStar(record.id)}\n                            >\n                              {record.starred ? (\n                                <Star size={16} className=\"fill-yellow-400 text-yellow-400\" />\n                              ) : (\n                                <Star size={16} />\n                              )}\n                            </button>\n                          </div>\n\n                          {record.tags.length > 0 && (\n                            <div className=\"mt-2 flex flex-wrap gap-1\">\n                              {record.tags.map(tag => (\n                                <span\n                                  key={tag}\n                                  className=\"flex items-center rounded bg-gray-700 px-1.5 py-0.5 text-xs text-gray-300\"\n                                >\n                                  <Tag size={10} className=\"mr-1\" />\n                                  {tag}\n                                </span>\n                              ))}\n                            </div>\n                          )}\n\n                          {record.notes && (\n                            <p className=\"mt-2 line-clamp-2 text-xs text-gray-400\">\n                              {record.notes}\n                            </p>\n                          )}\n                        </div>\n                      </div>\n                    </div>\n                  );\n                })}\n              </div>\n            )}\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/ExplorationSystemIntegration.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/GalaxyMapSystem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/GalaxyMappingSystem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/RealTimeMapUpdates.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/ReconShipCoordination.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_onAddShipToFormation' is defined but never used.","line":75,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":75,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_onRemoveShipFromFormation' is defined but never used.","line":76,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":76,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_formationShips' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":98,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":98,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_selectedFormation' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":105,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":105,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_renderTaskSharingControls' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":194,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":194,"endColumn":35},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_getHighPrioritySectors' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":261,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":261,"endColumn":32},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_getFormationsByType' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":319,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":319,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_getShipsByType' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":326,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":326,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_getShipsByStatus' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":333,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":333,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'leader' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":344,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":344,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'renderShipDetails' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":474,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":474,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'handleFormationSelect' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":490,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":490,"endColumn":30}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ChevronUp, Plus, Radar, Users, Zap } from 'lucide-react';\nimport { useCallback, useEffect, useMemo, useState } from 'react';\nimport { moduleEventBus } from '../../lib/events/ModuleEventBus';\nimport { Position } from '../../types/core/GameTypes';\nimport { EventType } from '../../types/events/EventTypes';\nimport { StandardizedEvent } from '../../types/events/StandardizedEvents';\nimport { ExplorationStatus, Sector } from '../../types/exploration/unified/ExplorationTypes';\nimport { cn } from '../../utils/cn';\n\n// Define interfaces based on ReconShipManagerImpl\ninterface ReconShip {\n  id: string;\n  name: string;\n  type: 'AC27G' | 'PathFinder' | 'VoidSeeker' | 'recon' | 'mining' | 'war';\n  status: 'idle' | 'scanning' | 'investigating' | 'returning';\n  targetSector?: string;\n  experience: number;\n  specialization: 'mapping' | 'anomaly' | 'resource';\n  efficiency: number;\n  position: Position;\n  formationId?: string;\n  formationRole?: 'leader' | 'support' | 'scout';\n  coordinationBonus?: number;\n  capabilities: {\n    scanning: number;\n    stealth: number;\n    combat: number;\n    stealthActive?: boolean;\n    speed: number;\n    range: number;\n  };\n  currentTask?: {\n    type: string;\n    target: string;\n    progress: number;\n  };\n  stealthActive?: boolean;\n}\n\ninterface Formation {\n  id: string;\n  name: string;\n  type: string;\n  shipIds: string[];\n  leaderId: string;\n  position: Position;\n  status: 'idle' | 'scanning' | 'moving' | 'combat';\n  effectiveness?: number;\n}\n\ninterface ReconShipCoordinationProps {\n  ships: ReconShip[];\n  sectors: Sector[];\n  formations?: Formation[];\n  onCreateFormation: (name: string, type: string, shipIds: string[], leaderId: string) => void;\n  onDisbandFormation: (formationId: string) => void;\n  _onAddShipToFormation: (shipId: string, formationId: string) => void;\n  _onRemoveShipFromFormation: (shipId: string, formationId: string) => void;\n  onStartCoordinatedScan: (sectorId: string, shipIds: string[]) => void;\n  onShareTask?: (\n    sourceShipId: string,\n    targetShipId: string,\n    taskType: 'explore' | 'investigate' | 'evade'\n  ) => void;\n  onAutoDistributeTasks: (sectorIds: string[], prioritizeFormations: boolean) => void;\n  className?: string;\n}\n\nexport const ReconShipCoordination: React.FC<ReconShipCoordinationProps> = ({\n  ships,\n  sectors,\n  formations = [],\n  onCreateFormation,\n  onDisbandFormation,\n  _onAddShipToFormation,\n  _onRemoveShipFromFormation,\n  onStartCoordinatedScan,\n  onShareTask,\n  onAutoDistributeTasks,\n  className,\n}) => {\n  // State for UI\n  const [activeTab, setActiveTab] = useState<'formations' | 'coordination' | 'auto'>('formations');\n  const [selectedFormationId, setSelectedFormationId] = useState<string>('');\n  const [selectedSectorId, setSelectedSectorId] = useState<string>('');\n  const [showCreateFormation, setShowCreateFormation] = useState(false);\n  const [formationName, setFormationName] = useState('');\n  const [formationType, setFormationType] = useState<string>('exploration');\n  const [selectedShipIds, setSelectedShipIds] = useState<string[]>([]);\n  const [selectedLeaderId, setSelectedLeaderId] = useState<string>('');\n  const [_prioritizeFormations, _setPrioritizeFormations] = useState(true);\n\n  // Derived state\n  const availableShips = useMemo(() => {\n    return ships.filter(ship => ship.status === 'idle' && !ship.formationId);\n  }, [ships]);\n\n  const _formationShips = useMemo(() => {\n    if (!selectedFormationId) return [];\n    const formation = formations.find(f => f.id === selectedFormationId);\n    if (!formation) return [];\n    return ships.filter(ship => formation.shipIds.includes(ship.id));\n  }, [ships, formations, selectedFormationId]);\n\n  const _selectedFormation = useMemo(() => {\n    return formations.find(f => f.id === selectedFormationId) || null;\n  }, [formations, selectedFormationId]);\n\n  // Reset selected leader when selected ships change\n  useEffect(() => {\n    if (selectedShipIds.length > 0 && !selectedShipIds.includes(selectedLeaderId)) {\n      setSelectedLeaderId(selectedShipIds[0]);\n    } else if (selectedShipIds.length === 0) {\n      setSelectedLeaderId('');\n    }\n  }, [selectedShipIds, selectedLeaderId]);\n\n  // Handle form submission for creating a new formation with standardized events\n  const handleCreateFormation = useCallback(\n    (name: string, type: string, shipIds: string[], leaderId: string) => {\n      const event: StandardizedEvent = {\n        type: EventType.MODULE_UPDATED,\n        moduleId: 'recon-coordination',\n        moduleType: 'exploration',\n        timestamp: Date.now(),\n        data: { name, type, shipIds, leaderId, action: 'create_formation' },\n      };\n      moduleEventBus.emit(event);\n      onCreateFormation(name, type, shipIds, leaderId);\n    },\n    [onCreateFormation]\n  );\n\n  // Handle starting a coordinated scan with standardized events\n  const handleStartCoordinatedScan = useCallback(\n    (sectorId: string, shipIds: string[]) => {\n      const event: StandardizedEvent = {\n        type: EventType.EXPLORATION_SCAN_STARTED,\n        moduleId: 'recon-coordination',\n        moduleType: 'exploration',\n        timestamp: Date.now(),\n        data: { sectorId, shipIds },\n      };\n      moduleEventBus.emit(event);\n      onStartCoordinatedScan(sectorId, shipIds);\n    },\n    [onStartCoordinatedScan]\n  );\n\n  // Handle auto-distribution of tasks with standardized events\n  const handleAutoDistributeTasks = useCallback(\n    (sectorIds: string[], prioritizeFormations: boolean) => {\n      const event: StandardizedEvent = {\n        type: EventType.EXPLORATION_TASK_ASSIGNED,\n        moduleId: 'recon-coordination',\n        moduleType: 'exploration',\n        timestamp: Date.now(),\n        data: { sectorIds, prioritizeFormations },\n      };\n      moduleEventBus.emit(event);\n      onAutoDistributeTasks(sectorIds, prioritizeFormations);\n    },\n    [onAutoDistributeTasks]\n  );\n\n  // Handle task sharing with standardized events\n  const handleShareTask = useCallback(\n    (sourceShipId: string, targetShipId: string, taskType: 'explore' | 'investigate' | 'evade') => {\n      if (onShareTask) {\n        const event: StandardizedEvent = {\n          type: EventType.EXPLORATION_TASK_ASSIGNED,\n          moduleId: 'recon-coordination',\n          moduleType: 'exploration',\n          timestamp: Date.now(),\n          data: { sourceShipId, targetShipId, taskType },\n        };\n        moduleEventBus.emit(event);\n        onShareTask(sourceShipId, targetShipId, taskType);\n      }\n    },\n    [onShareTask]\n  );\n\n  // Cleanup subscriptions on unmount\n  useEffect(() => {\n    const cleanup = () => {\n      // Any cleanup needed for event subscriptions\n    };\n\n    return cleanup;\n  }, []);\n\n  // Add a button or UI element to use the handleShareTask function\n  const _renderTaskSharingControls = () => {\n    if (activeTab !== 'coordination' || !selectedShipIds.length) return null;\n\n    return (\n      <div className=\"mt-4 rounded border border-gray-200 p-3\">\n        <h4 className=\"mb-2 text-sm font-semibold\">Share Tasks</h4>\n        <div className=\"space-y-2\">\n          {selectedShipIds.map(shipId => {\n            const ship = ships.find(s => s.id === shipId);\n            if (!ship) return null;\n\n            return (\n              <div key={`share-${shipId}`} className=\"flex items-center justify-between\">\n                <span className=\"text-sm\">{ship.name}</span>\n                <div className=\"flex space-x-1\">\n                  <button\n                    className=\"rounded bg-blue-100 px-2 py-1 text-xs text-blue-700 hover:bg-blue-200\"\n                    onClick={() =>\n                      handleShareTask(\n                        shipId,\n                        selectedShipIds.find(id => id !== shipId) ?? '',\n                        'explore'\n                      )\n                    }\n                    disabled={selectedShipIds.length < 2}\n                  >\n                    Explore\n                  </button>\n                  <button\n                    className=\"rounded bg-purple-100 px-2 py-1 text-xs text-purple-700 hover:bg-purple-200\"\n                    onClick={() =>\n                      handleShareTask(\n                        shipId,\n                        selectedShipIds.find(id => id !== shipId) ?? '',\n                        'investigate'\n                      )\n                    }\n                    disabled={selectedShipIds.length < 2}\n                  >\n                    Investigate\n                  </button>\n                  <button\n                    className=\"rounded bg-red-100 px-2 py-1 text-xs text-red-700 hover:bg-red-200\"\n                    onClick={() =>\n                      handleShareTask(\n                        shipId,\n                        selectedShipIds.find(id => id !== shipId) ?? '',\n                        'evade'\n                      )\n                    }\n                    disabled={selectedShipIds.length < 2}\n                  >\n                    Evade\n                  </button>\n                </div>\n              </div>\n            );\n          })}\n        </div>\n      </div>\n    );\n  };\n\n  const getUnexploredSectors = useCallback(() => {\n    return sectors.filter(sector => sector.explorationStatus === ExplorationStatus.UNDISCOVERED);\n  }, [sectors]);\n\n  const _getHighPrioritySectors = useCallback(() => {\n    return sectors.filter(\n      sector =>\n        sector.explorationStatus !== ExplorationStatus.FULLY_EXPLORED && sector.resources.length > 0\n    );\n  }, [sectors]);\n\n  const getAvailableReconShips = useCallback(() => {\n    return ships.filter(\n      ship =>\n        ship.type === 'recon' &&\n        ship.status === 'idle' &&\n        !formations.some(f => f.shipIds.includes(ship.id))\n    );\n  }, [ships, formations]);\n\n  const getFormationEffectiveness = useCallback(\n    (formation: Formation) => {\n      const formationShips = ships.filter(ship => formation.shipIds.includes(ship.id));\n      return formationShips.reduce((total, ship) => {\n        const baseEffectiveness = ship.capabilities.speed + ship.capabilities.range;\n        const stealthBonus = ship.capabilities.stealth\n          ? ship.capabilities.stealth * (ship.stealthActive ? 2 : 1)\n          : 0;\n        return total + baseEffectiveness + stealthBonus;\n      }, 0);\n    },\n    [ships]\n  );\n\n  const getFormationShips = useCallback(\n    (formation: Formation) => {\n      return ships.filter(ship => formation.shipIds.includes(ship.id));\n    },\n    [ships]\n  );\n\n  const getFormationLeader = useCallback(\n    (formation: Formation) => {\n      return ships.find(ship => ship.id === formation.leaderId);\n    },\n    [ships]\n  );\n\n  const getFormationStatus = useCallback(\n    (formation: Formation) => {\n      const formationShips = getFormationShips(formation);\n      if (formationShips.every(ship => ship.status === 'scanning')) {\n        return 'scanning';\n      }\n      if (formationShips.some(ship => ship.status === 'investigating')) {\n        return 'investigating';\n      }\n      return 'idle';\n    },\n    [getFormationShips]\n  );\n\n  const _getFormationsByType = useCallback(\n    (type: string) => {\n      return formations.filter(f => f.type === type);\n    },\n    [formations]\n  );\n\n  const _getShipsByType = useCallback(\n    (type: 'recon' | 'mining' | 'war') => {\n      return ships.filter(ship => ship.type === type);\n    },\n    [ships]\n  );\n\n  const _getShipsByStatus = useCallback(\n    (status: 'idle' | 'scanning' | 'investigating' | 'returning') => {\n      return ships.filter(ship => ship.status === status);\n    },\n    [ships]\n  );\n\n  const renderFormationList = () => {\n    return (\n      <div className=\"space-y-4\">\n        {formations.map(formation => {\n          const leader = getFormationLeader(formation);\n          const effectiveness = getFormationEffectiveness(formation);\n          const status = getFormationStatus(formation);\n\n          return (\n            <div key={formation.id} className=\"rounded border p-4\">\n              <div className=\"flex items-center justify-between\">\n                <div>\n                  <h4 className=\"font-medium\">{formation.name}</h4>\n                  <p className=\"text-sm text-gray-500\">Type: {formation.type}</p>\n                  <p className=\"text-sm text-gray-500\">Status: {status}</p>\n                  <p className=\"text-sm text-gray-500\">Effectiveness: {effectiveness.toFixed(1)}</p>\n                </div>\n                <div className=\"flex space-x-2\">\n                  <button\n                    className=\"rounded bg-red-500 px-2 py-1 text-white hover:bg-red-600\"\n                    onClick={() => onDisbandFormation(formation.id)}\n                  >\n                    Disband\n                  </button>\n                </div>\n              </div>\n              <div className=\"mt-2\">\n                <h5 className=\"text-sm font-medium\">Ships</h5>\n                <div className=\"mt-1 space-y-1\">\n                  {getFormationShips(formation).map(ship => (\n                    <div key={ship.id} className=\"flex items-center justify-between text-sm\">\n                      <span>{ship.name}</span>\n                      <span className=\"text-gray-500\">{ship.type}</span>\n                      <span className=\"text-gray-500\">\n                        {ship.currentTask ? `Task: ${ship.currentTask}` : 'No task'}\n                      </span>\n                    </div>\n                  ))}\n                </div>\n              </div>\n            </div>\n          );\n        })}\n      </div>\n    );\n  };\n\n  const handleAutoDistributeClick = () => {\n    const unexploredSectorIds = getUnexploredSectors().map(sector => sector.id);\n    handleAutoDistributeTasks(unexploredSectorIds, true);\n  };\n\n  const renderCoordinationTab = () => {\n    return (\n      <div>\n        <div className=\"mb-4\">\n          <h3 className=\"text-lg font-medium\">Coordinated Scanning</h3>\n          <p className=\"text-sm text-gray-500\">\n            Select a formation and sector to begin coordinated scanning\n          </p>\n        </div>\n\n        <div className=\"grid gap-4 md:grid-cols-2\">\n          <div>\n            <h4 className=\"mb-2 font-medium\">Select Formation</h4>\n            <select\n              className=\"w-full rounded border p-2\"\n              value={selectedShipIds.join(',')}\n              onChange={e => setSelectedShipIds(e.target.value ? e.target.value.split(',') : [])}\n            >\n              <option value=\"\">Select a formation...</option>\n              {formations.map(formation => (\n                <option key={formation.id} value={formation.shipIds.join(',')}>\n                  {formation.name} ({formation.shipIds.length} ships)\n                </option>\n              ))}\n            </select>\n          </div>\n\n          <div>\n            <h4 className=\"mb-2 font-medium\">Select Sector</h4>\n            <select\n              className=\"w-full rounded border p-2\"\n              value={selectedSectorId}\n              onChange={e => setSelectedSectorId(e.target.value)}\n            >\n              <option value=\"\">Select a sector...</option>\n              {sectors.map(sector => (\n                <option key={sector.id} value={sector.id}>\n                  {sector.name} - {sector.explorationStatus}\n                </option>\n              ))}\n            </select>\n          </div>\n        </div>\n\n        <div className=\"mt-4\">\n          <button\n            className=\"flex items-center rounded bg-blue-500 px-4 py-2 text-white hover:bg-blue-600\"\n            onClick={() =>\n              selectedSectorId &&\n              selectedShipIds.length > 0 &&\n              handleStartCoordinatedScan(selectedSectorId, selectedShipIds)\n            }\n            disabled={!selectedSectorId || selectedShipIds.length === 0}\n          >\n            Start Coordinated Scan\n          </button>\n        </div>\n      </div>\n    );\n  };\n\n  const renderAutoDistributionTab = () => {\n    return (\n      <div>\n        <div className=\"mb-4\">\n          <h3 className=\"text-lg font-medium\">Auto-Distribution</h3>\n          <p className=\"text-sm text-gray-500\">Automatically distribute tasks to available ships</p>\n        </div>\n\n        <div className=\"mb-4\">\n          <button\n            className=\"flex items-center rounded bg-blue-500 px-4 py-2 text-white hover:bg-blue-600\"\n            onClick={handleAutoDistributeClick}\n            disabled={getUnexploredSectors().length === 0 || getAvailableReconShips().length === 0}\n          >\n            Auto-Distribute Tasks\n          </button>\n        </div>\n      </div>\n    );\n  };\n\n  const renderShipDetails = (ship: ReconShip) => {\n    return (\n      <div key={ship.id} className=\"mb-4 rounded-lg bg-gray-800 p-4\">\n        <h4 className=\"mb-2 text-lg font-semibold text-white\">{ship.name}</h4>\n        <div className=\"grid grid-cols-2 gap-2 text-sm text-gray-300\">\n          <div>Type: {ship.type}</div>\n          <div>Status: {ship.status}</div>\n          <div>Scanning: {ship.capabilities?.scanning ?? 0}</div>\n          <div>Stealth: {ship.capabilities?.stealth ?? 0}</div>\n          <div>Combat: {ship.capabilities?.combat ?? 0}</div>\n          <div>Stealth Active: {ship.capabilities?.stealthActive ? 'Yes' : 'No'}</div>\n        </div>\n      </div>\n    );\n  };\n\n  const handleFormationSelect = (formationId: string) => {\n    setSelectedFormationId(formationId === selectedFormationId ? '' : formationId);\n  };\n\n  return (\n    <div className={cn('flex flex-col space-y-4', className)}>\n      {/* Header */}\n      <div className=\"border-b bg-gray-50 p-4 dark:bg-gray-800\">\n        <h2 className=\"flex items-center text-xl font-semibold\">\n          <Users className=\"mr-2\" />\n          Recon Ship Coordination\n        </h2>\n        <p className=\"mt-1 text-sm text-gray-500 dark:text-gray-400\">\n          Manage fleet formations and coordinate recon ship operations\n        </p>\n      </div>\n\n      {/* Tabs */}\n      <div className=\"flex border-b\">\n        <button\n          className={`px-4 py-2 font-medium ${\n            activeTab === 'formations'\n              ? 'border-b-2 border-blue-500 text-blue-600'\n              : 'text-gray-600 hover:text-gray-800'\n          }`}\n          onClick={() => setActiveTab('formations')}\n        >\n          <div className=\"flex items-center\">\n            <Users size={16} className=\"mr-2\" />\n            Formations\n          </div>\n        </button>\n        <button\n          className={`px-4 py-2 font-medium ${\n            activeTab === 'coordination'\n              ? 'border-b-2 border-blue-500 text-blue-600'\n              : 'text-gray-600 hover:text-gray-800'\n          }`}\n          onClick={() => setActiveTab('coordination')}\n        >\n          <div className=\"flex items-center\">\n            <Radar size={16} className=\"mr-2\" />\n            Coordinated Scanning\n          </div>\n        </button>\n        <button\n          className={`px-4 py-2 font-medium ${\n            activeTab === 'auto'\n              ? 'border-b-2 border-blue-500 text-blue-600'\n              : 'text-gray-600 hover:text-gray-800'\n          }`}\n          onClick={() => setActiveTab('auto')}\n        >\n          <div className=\"flex items-center\">\n            <Zap size={16} className=\"mr-2\" />\n            Auto-Distribution\n          </div>\n        </button>\n      </div>\n\n      {/* Content */}\n      <div className=\"p-4\">\n        {/* Formations Tab */}\n        {activeTab === 'formations' && (\n          <div>\n            {/* Formation List */}\n            <div className=\"mb-4\">\n              <div className=\"mb-2 flex items-center justify-between\">\n                <h3 className=\"text-lg font-medium\">Fleet Formations</h3>\n                <button\n                  className=\"flex items-center rounded bg-blue-500 px-2 py-1 text-white hover:bg-blue-600\"\n                  onClick={() => setShowCreateFormation(!showCreateFormation)}\n                >\n                  {showCreateFormation ? (\n                    <>\n                      <ChevronUp size={16} className=\"mr-1\" />\n                      Cancel\n                    </>\n                  ) : (\n                    <>\n                      <Plus size={16} className=\"mr-1\" />\n                      New Formation\n                    </>\n                  )}\n                </button>\n              </div>\n\n              {/* Create Formation Form */}\n              {showCreateFormation && (\n                <div className=\"mb-4 rounded border bg-gray-50 p-4 dark:bg-gray-800\">\n                  <h4 className=\"mb-2 font-medium\">Create New Formation</h4>\n\n                  <div className=\"mb-3\">\n                    <label className=\"mb-1 block text-sm font-medium\">Formation Name</label>\n                    <input\n                      type=\"text\"\n                      className=\"w-full rounded border p-2\"\n                      value={formationName}\n                      onChange={e => setFormationName(e.target.value)}\n                      placeholder=\"Enter formation name\"\n                    />\n                  </div>\n\n                  <div className=\"mb-3\">\n                    <label className=\"mb-1 block text-sm font-medium\">Formation Type</label>\n                    <select\n                      className=\"w-full rounded border p-2\"\n                      value={formationType}\n                      onChange={e => setFormationType(e.target.value)}\n                    >\n                      <option value=\"exploration\">Exploration</option>\n                      <option value=\"survey\">Survey</option>\n                      <option value=\"defensive\">Defensive</option>\n                    </select>\n                    <p className=\"mt-1 text-xs text-gray-500\">\n                      {formationType === 'exploration'\n                        ? 'Balanced formation for general exploration'\n                        : formationType === 'survey'\n                          ? 'Specialized formation for resource discovery'\n                          : 'Defensive formation with enhanced threat detection'}\n                    </p>\n                  </div>\n\n                  <div className=\"mb-3\">\n                    <label className=\"mb-1 block text-sm font-medium\">Select Ships</label>\n                    <div className=\"max-h-40 overflow-y-auto rounded border p-2\">\n                      {availableShips.length > 0 ? (\n                        availableShips.map(ship => (\n                          <div key={ship.id} className=\"mb-1 flex items-center last:mb-0\">\n                            <input\n                              type=\"checkbox\"\n                              id={`ship-${ship.id}`}\n                              checked={selectedShipIds.includes(ship.id)}\n                              onChange={e => {\n                                if (e.target.checked) {\n                                  setSelectedShipIds([...selectedShipIds, ship.id]);\n                                } else {\n                                  setSelectedShipIds(selectedShipIds.filter(id => id !== ship.id));\n                                }\n                              }}\n                              className=\"mr-2\"\n                            />\n                            <label htmlFor={`ship-${ship.id}`} className=\"flex items-center\">\n                              <span className=\"font-medium\">{ship.name}</span>\n                              <span className=\"ml-2 text-xs text-gray-500\">\n                                ({ship.type} - {ship.specialization})\n                              </span>\n                            </label>\n                          </div>\n                        ))\n                      ) : (\n                        <div className=\"text-sm text-gray-500\">No available ships</div>\n                      )}\n                    </div>\n                  </div>\n\n                  {selectedShipIds.length > 0 && (\n                    <div className=\"mb-3\">\n                      <label className=\"mb-1 block text-sm font-medium\">Formation Leader</label>\n                      <select\n                        className=\"w-full rounded border p-2\"\n                        value={selectedLeaderId}\n                        onChange={e => setSelectedLeaderId(e.target.value)}\n                      >\n                        {selectedShipIds.map(shipId => {\n                          const ship = ships.find(s => s.id === shipId);\n                          return (\n                            <option key={shipId} value={shipId}>\n                              {ship?.name} ({ship?.specialization})\n                            </option>\n                          );\n                        })}\n                      </select>\n                    </div>\n                  )}\n\n                  <div className=\"flex justify-end\">\n                    <button\n                      className=\"flex items-center rounded bg-blue-500 px-3 py-1 text-white hover:bg-blue-600\"\n                      onClick={() =>\n                        handleCreateFormation(\n                          formationName,\n                          formationType,\n                          selectedShipIds,\n                          selectedLeaderId\n                        )\n                      }\n                      disabled={!formationName || selectedShipIds.length === 0 || !selectedLeaderId}\n                    >\n                      <Plus size={16} className=\"mr-1\" />\n                      Create Formation\n                    </button>\n                  </div>\n                </div>\n              )}\n\n              {/* Formations List */}\n              {renderFormationList()}\n            </div>\n          </div>\n        )}\n\n        {/* Coordinated Scanning Tab */}\n        {activeTab === 'coordination' && renderCoordinationTab()}\n\n        {/* Auto-Distribution Tab */}\n        {activeTab === 'auto' && renderAutoDistributionTab()}\n      </div>\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/ResourceDiscoverySystem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/ResourcePotentialVisualization.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/ResourcePotentialVisualizationDemo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/ResultsPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/unified/context/ExplorationContext.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/unified/core/BaseAnalysisVisualizer.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_data' is defined but never used.","line":158,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":158,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_width' is defined but never used.","line":158,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":158,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_height' is defined but never used.","line":158,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":158,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_options' is defined but never used.","line":158,"column":35,"nodeType":null,"messageId":"unusedVar","endLine":158,"endColumn":43},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_data' is defined but never used.","line":164,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":164,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_width' is defined but never used.","line":164,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":164,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_height' is defined but never used.","line":164,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":164,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_options' is defined but never used.","line":164,"column":36,"nodeType":null,"messageId":"unusedVar","endLine":164,"endColumn":44},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_data' is defined but never used.","line":170,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":170,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_width' is defined but never used.","line":170,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":170,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_height' is defined but never used.","line":170,"column":30,"nodeType":null,"messageId":"unusedVar","endLine":170,"endColumn":37},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_options' is defined but never used.","line":170,"column":39,"nodeType":null,"messageId":"unusedVar","endLine":170,"endColumn":47},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_data' is defined but never used.","line":176,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":176,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_width' is defined but never used.","line":176,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":176,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_height' is defined but never used.","line":176,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":176,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_options' is defined but never used.","line":176,"column":35,"nodeType":null,"messageId":"unusedVar","endLine":176,"endColumn":43},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_data' is defined but never used.","line":182,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":182,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_width' is defined but never used.","line":182,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":182,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_height' is defined but never used.","line":182,"column":28,"nodeType":null,"messageId":"unusedVar","endLine":182,"endColumn":35},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_options' is defined but never used.","line":182,"column":37,"nodeType":null,"messageId":"unusedVar","endLine":182,"endColumn":45},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_data' is defined but never used.","line":188,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":188,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_width' is defined but never used.","line":188,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":188,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_height' is defined but never used.","line":188,"column":30,"nodeType":null,"messageId":"unusedVar","endLine":188,"endColumn":37},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_options' is defined but never used.","line":188,"column":39,"nodeType":null,"messageId":"unusedVar","endLine":188,"endColumn":47},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_data' is defined but never used.","line":194,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":194,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_width' is defined but never used.","line":194,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":194,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_height' is defined but never used.","line":194,"column":30,"nodeType":null,"messageId":"unusedVar","endLine":194,"endColumn":37},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_options' is defined but never used.","line":194,"column":39,"nodeType":null,"messageId":"unusedVar","endLine":194,"endColumn":47},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_width' is defined but never used.","line":200,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":200,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_height' is defined but never used.","line":200,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":200,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_options' is defined but never used.","line":200,"column":36,"nodeType":null,"messageId":"unusedVar","endLine":200,"endColumn":44},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_data' is defined but never used.","line":232,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":232,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_width' is defined but never used.","line":232,"column":21,"nodeType":null,"messageId":"unusedVar","endLine":232,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_height' is defined but never used.","line":232,"column":29,"nodeType":null,"messageId":"unusedVar","endLine":232,"endColumn":36},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_options' is defined but never used.","line":232,"column":38,"nodeType":null,"messageId":"unusedVar","endLine":232,"endColumn":46}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":35,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * BaseAnalysisVisualizer Component\n *\n * A unified base component for visualization of analysis results.\n * This component provides:\n * - Standardized rendering of different analysis types\n * - Support for multiple visualization strategies\n * - Common layout and controls for analysis visualizations\n * - Memory optimization for large datasets\n */\n\nimport * as React from 'react';\nimport { useCallback, useMemo, useState } from 'react';\nimport { AnalysisResult, AnalysisType, Insight } from '../../../../types/exploration/unified';\nimport { cn } from '../../../../utils/cn';\n\n// Visualization types\nexport type VisualizationType =\n  | 'bar'\n  | 'line'\n  | 'scatter'\n  | 'pie'\n  | 'radar'\n  | 'heatmap'\n  | 'network'\n  | 'table'\n  | 'custom';\n\n// Visualization renderer\nexport type VisualizationRenderer = (\n  data: Record<string, unknown>,\n  width: number,\n  height: number,\n  options?: VisualizationOptions\n) => React.ReactNode;\n\n// Visualization options\nexport interface VisualizationOptions {\n  colors?: string[];\n  animate?: boolean;\n  showLegend?: boolean;\n  showTooltip?: boolean;\n  showGrid?: boolean;\n  memoryOptimized?: boolean;\n  xAxis?: string;\n  yAxis?: string;\n  [key: string]: unknown;\n}\n\n// BaseAnalysisVisualizer Props\nexport interface BaseAnalysisVisualizerProps {\n  /** Analysis result to visualize */\n  analysis: AnalysisResult;\n\n  /** Width of the visualization */\n  width?: number;\n\n  /** Height of the visualization */\n  height?: number;\n\n  /** Default visualization type */\n  defaultVisualizationType?: VisualizationType;\n\n  /** Available visualization types */\n  availableVisualizationTypes?: VisualizationType[];\n\n  /** Custom visualization renderers */\n  visualizationRenderers?: Record<string, VisualizationRenderer>;\n\n  /** Default visualization options */\n  defaultOptions?: VisualizationOptions;\n\n  /** Whether to show a panel with insights */\n  showInsightsPanel?: boolean;\n\n  /** Whether to show analysis summary */\n  showSummary?: boolean;\n\n  /** Whether to show controls for changing visualization */\n  showControls?: boolean;\n\n  /** Called when an insight is clicked */\n  onInsightClick?: (insight: Insight) => void;\n\n  /** Custom class name */\n  className?: string;\n\n  /** Additional content to display below the visualization */\n  additionalContent?: React.ReactNode;\n}\n\n/**\n * BaseAnalysisVisualizer Component\n */\nexport const BaseAnalysisVisualizer: React.FC<BaseAnalysisVisualizerProps> = ({\n  analysis,\n  width = 800,\n  height = 400,\n  defaultVisualizationType = 'bar',\n  availableVisualizationTypes,\n  visualizationRenderers,\n  defaultOptions = {},\n  showInsightsPanel = true,\n  showSummary = true,\n  showControls = true,\n  onInsightClick,\n  className,\n  additionalContent,\n}) => {\n  // State\n  const [visualizationType, setVisualizationType] =\n    useState<VisualizationType>(defaultVisualizationType);\n\n  const [options, setOptions] = useState<VisualizationOptions>({\n    colors: ['#4C86E0', '#E6772E', '#76D275', '#FBC02D', '#9C64A6', '#455A64'],\n    animate: true,\n    showLegend: true,\n    showTooltip: true,\n    showGrid: true,\n    memoryOptimized: true,\n    ...defaultOptions,\n  });\n\n  // Get available visualization types based on analysis type\n  const availableTypes = useMemo(() => {\n    if (availableVisualizationTypes) {\n      return availableVisualizationTypes;\n    }\n\n    // Default visualization types based on analysis type\n    switch (analysis.type) {\n      case AnalysisType.COMPOSITION:\n        return ['pie', 'bar', 'table'] as VisualizationType[];\n\n      case AnalysisType.ENERGY:\n      case AnalysisType.RESOURCE:\n        return ['bar', 'line', 'radar', 'table'] as VisualizationType[];\n\n      case AnalysisType.SPATIAL:\n        return ['scatter', 'heatmap'] as VisualizationType[];\n\n      case AnalysisType.TEMPORAL:\n        return ['line', 'bar', 'table'] as VisualizationType[];\n\n      case AnalysisType.STRATEGIC:\n        return ['radar', 'heatmap', 'network'] as VisualizationType[];\n\n      case AnalysisType.PREDICTIVE:\n        return ['line', 'scatter', 'table'] as VisualizationType[];\n\n      default:\n        return ['bar', 'line', 'scatter', 'table'] as VisualizationType[];\n    }\n  }, [analysis.type, availableVisualizationTypes]);\n\n  // Default renderers for visualization types\n  const defaultRenderers: Record<VisualizationType, VisualizationRenderer> = {\n    bar: (_data, _width, _height, _options) => (\n      <div className=\"flex h-full items-center justify-center\">\n        <p className=\"italic text-gray-500\">Bar chart visualization (placeholder)</p>\n      </div>\n    ),\n\n    line: (_data, _width, _height, _options) => (\n      <div className=\"flex h-full items-center justify-center\">\n        <p className=\"italic text-gray-500\">Line chart visualization (placeholder)</p>\n      </div>\n    ),\n\n    scatter: (_data, _width, _height, _options) => (\n      <div className=\"flex h-full items-center justify-center\">\n        <p className=\"italic text-gray-500\">Scatter plot visualization (placeholder)</p>\n      </div>\n    ),\n\n    pie: (_data, _width, _height, _options) => (\n      <div className=\"flex h-full items-center justify-center\">\n        <p className=\"italic text-gray-500\">Pie chart visualization (placeholder)</p>\n      </div>\n    ),\n\n    radar: (_data, _width, _height, _options) => (\n      <div className=\"flex h-full items-center justify-center\">\n        <p className=\"italic text-gray-500\">Radar chart visualization (placeholder)</p>\n      </div>\n    ),\n\n    heatmap: (_data, _width, _height, _options) => (\n      <div className=\"flex h-full items-center justify-center\">\n        <p className=\"italic text-gray-500\">Heatmap visualization (placeholder)</p>\n      </div>\n    ),\n\n    network: (_data, _width, _height, _options) => (\n      <div className=\"flex h-full items-center justify-center\">\n        <p className=\"italic text-gray-500\">Network visualization (placeholder)</p>\n      </div>\n    ),\n\n    table: (data, _width, _height, _options) => {\n      // Extract keys and values for table\n      const keys = Object.keys(data);\n\n      return (\n        <div className=\"max-h-full overflow-auto\">\n          <table className=\"min-w-full divide-y divide-gray-200\">\n            <thead className=\"bg-gray-50\">\n              <tr>\n                <th className=\"px-6 py-3 text-left text-xs font-medium uppercase tracking-wider text-gray-500\">\n                  Property\n                </th>\n                <th className=\"px-6 py-3 text-left text-xs font-medium uppercase tracking-wider text-gray-500\">\n                  Value\n                </th>\n              </tr>\n            </thead>\n            <tbody className=\"divide-y divide-gray-200 bg-white\">\n              {keys.map(key => (\n                <tr key={key}>\n                  <td className=\"whitespace-nowrap px-6 py-4 text-sm text-gray-900\">{key}</td>\n                  <td className=\"whitespace-nowrap px-6 py-4 text-sm text-gray-500\">\n                    {formatValue(data[key])}\n                  </td>\n                </tr>\n              ))}\n            </tbody>\n          </table>\n        </div>\n      );\n    },\n\n    custom: (_data, _width, _height, _options) => (\n      <div className=\"flex h-full items-center justify-center\">\n        <p className=\"italic text-gray-500\">Custom visualization</p>\n      </div>\n    ),\n  };\n\n  // Combine default renderers with custom renderers\n  const renderers = useMemo(() => {\n    return {\n      ...defaultRenderers,\n      ...(visualizationRenderers ?? {}),\n    };\n  }, [visualizationRenderers]);\n\n  // Handle visualization type change\n  const handleVisualizationTypeChange = useCallback((type: VisualizationType) => {\n    setVisualizationType(type);\n  }, []);\n\n  // Handle option change\n  const handleOptionChange = useCallback((key: string, value: unknown) => {\n    setOptions(prev => ({\n      ...prev,\n      [key]: value,\n    }));\n  }, []);\n\n  // Render visualization\n  const renderVisualization = () => {\n    const renderer = renderers[visualizationType] || renderers.bar;\n    return renderer(analysis.data, width, height, options);\n  };\n\n  // Render controls\n  const renderControls = () => {\n    if (!showControls) return null;\n\n    return (\n      <div className=\"mb-4 flex flex-wrap items-center gap-2\">\n        <div className=\"flex flex-wrap items-center gap-2\">\n          <label className=\"text-sm font-medium text-gray-700\">Visualization:</label>\n          <select\n            value={visualizationType}\n            onChange={e => handleVisualizationTypeChange(e.target.value as VisualizationType)}\n            className=\"form-select rounded-md border-gray-300 text-sm shadow-sm focus:border-blue-500 focus:ring-blue-500\"\n          >\n            {availableTypes.map(type => (\n              <option key={type} value={type}>\n                {type.charAt(0).toUpperCase() + type.slice(1)}\n              </option>\n            ))}\n          </select>\n        </div>\n\n        <div className=\"flex items-center gap-2\">\n          <label className=\"text-sm font-medium text-gray-700\">Legend:</label>\n          <input\n            type=\"checkbox\"\n            checked={options?.showLegend}\n            onChange={e => handleOptionChange('showLegend', e.target.checked)}\n            className=\"form-checkbox h-4 w-4 rounded text-blue-500 focus:ring-blue-500\"\n          />\n        </div>\n\n        <div className=\"flex items-center gap-2\">\n          <label className=\"text-sm font-medium text-gray-700\">Grid:</label>\n          <input\n            type=\"checkbox\"\n            checked={options?.showGrid}\n            onChange={e => handleOptionChange('showGrid', e.target.checked)}\n            className=\"form-checkbox h-4 w-4 rounded text-blue-500 focus:ring-blue-500\"\n          />\n        </div>\n\n        <div className=\"flex items-center gap-2\">\n          <label className=\"text-sm font-medium text-gray-700\">Animation:</label>\n          <input\n            type=\"checkbox\"\n            checked={options?.animate}\n            onChange={e => handleOptionChange('animate', e.target.checked)}\n            className=\"form-checkbox h-4 w-4 rounded text-blue-500 focus:ring-blue-500\"\n          />\n        </div>\n      </div>\n    );\n  };\n\n  // Render insights panel\n  const renderInsightsPanel = () => {\n    if (!showInsightsPanel) return null;\n\n    const { insights } = analysis;\n\n    if (!insights || insights.length === 0) {\n      return (\n        <div className=\"rounded-md bg-gray-50 p-4\">\n          <p className=\"italic text-gray-500\">No insights available for this analysis.</p>\n        </div>\n      );\n    }\n\n    return (\n      <div className=\"rounded-md bg-gray-50 p-4\">\n        <h3 className=\"mb-3 text-lg font-medium text-gray-900\">Insights</h3>\n        <div className=\"space-y-3\">\n          {insights.map(insight => (\n            <div\n              key={insight.id}\n              className={cn(\n                'rounded-md border border-gray-200 bg-white p-3 shadow-sm',\n                onInsightClick && 'cursor-pointer hover:border-blue-300 hover:bg-blue-50'\n              )}\n              onClick={() => onInsightClick && onInsightClick(insight)}\n            >\n              <h4 className=\"text-md mb-1 font-medium text-gray-900\">{insight.title}</h4>\n              <p className=\"mb-2 text-sm text-gray-600\">{insight.description}</p>\n              <div className=\"flex items-center space-x-2\">\n                <span\n                  className={cn(\n                    'inline-block h-2 w-2 rounded-full',\n                    insight.significance > 75\n                      ? 'bg-red-500'\n                      : insight.significance > 50\n                        ? 'bg-yellow-500'\n                        : insight.significance > 25\n                          ? 'bg-blue-500'\n                          : 'bg-gray-500'\n                  )}\n                />\n                <span className=\"text-xs text-gray-500\">Significance: {insight.significance}%</span>\n                {insight.actionable && (\n                  <span className=\"ml-2 inline-block rounded-full bg-green-100 px-2 py-0.5 text-xs text-green-800\">\n                    Actionable\n                  </span>\n                )}\n              </div>\n            </div>\n          ))}\n        </div>\n      </div>\n    );\n  };\n\n  return (\n    <div className={cn('rounded-lg bg-white shadow', className)}>\n      <div className=\"p-4\">\n        <div className=\"mb-4 flex items-start justify-between\">\n          <div>\n            <h2 className=\"text-xl font-semibold text-gray-900\">{analysis.name}</h2>\n            {showSummary && <p className=\"mt-1 text-sm text-gray-600\">{analysis.summary}</p>}\n          </div>\n          <div className=\"flex items-center space-x-2\">\n            <span className=\"text-sm text-gray-500\">Confidence: {analysis.confidence}%</span>\n            <span\n              className={cn(\n                'inline-block h-3 w-3 rounded-full',\n                analysis.confidence > 80\n                  ? 'bg-green-500'\n                  : analysis.confidence > 60\n                    ? 'bg-blue-500'\n                    : analysis.confidence > 40\n                      ? 'bg-yellow-500'\n                      : 'bg-red-500'\n              )}\n            />\n            <span className=\"text-xs text-gray-500\">\n              {new Date(analysis.createdAt).toLocaleDateString()}\n            </span>\n          </div>\n        </div>\n\n        {/* Visualization Controls */}\n        {renderControls()}\n\n        <div className=\"flex flex-col gap-4 md:flex-row\">\n          {/* Main Visualization */}\n          <div className=\"flex-grow\" style={{ minHeight: `${height}px` }}>\n            {renderVisualization()}\n          </div>\n\n          {/* Insights Panel */}\n          {showInsightsPanel && <div className=\"md:w-80\">{renderInsightsPanel()}</div>}\n        </div>\n\n        {/* Additional Content */}\n        {additionalContent && <div className=\"mt-4\">{additionalContent}</div>}\n      </div>\n    </div>\n  );\n};\n\n// Helper function to format values for display\nfunction formatValue(value: unknown): string {\n  if (value === null || value === undefined) {\n    return '-';\n  }\n\n  if (typeof value === 'boolean') {\n    return value ? 'Yes' : 'No';\n  }\n\n  if (typeof value === 'number') {\n    // Format number with thousands separators and up to 2 decimal places\n    return value.toLocaleString(undefined, {\n      maximumFractionDigits: 2,\n    });\n  }\n\n  if (value instanceof Date) {\n    return value.toLocaleString();\n  }\n\n  if (Array.isArray(value)) {\n    return value.map(v => formatValue(v)).join(', ');\n  }\n\n  if (typeof value === 'object') {\n    return JSON.stringify(value);\n  }\n\n  return String(value);\n}\n\nexport default BaseAnalysisVisualizer;\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/unified/core/BaseDataTable.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/unified/core/BaseMap.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/unified/core/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/unified/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/unified/system/GalaxyExplorationSystem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/visualizations/AnalysisVisualization.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/visualizations/MemoryOptimizedCharts.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/visualizations/VirtualizedDataTable.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/visualizations/charts/BarChart.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/visualizations/charts/BaseChart.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/visualizations/charts/CanvasChartFactory.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/visualizations/charts/CanvasLineChart.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_event' is defined but never used.","line":732,"column":6,"nodeType":null,"messageId":"unusedVar","endLine":732,"endColumn":12}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Typography, useTheme } from '@mui/material';\nimport { debounce } from 'lodash';\nimport * as React from 'react';\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { BaseChartProps } from './BaseChart';\n\n// LTTB (Largest Triangle Three Buckets) algorithm for downsampling time series data\n// This preserves visual characteristics better than naive approaches\nfunction downsampleLTTB(\n  data: Array<Record<string, unknown>>,\n  xKey: string,\n  yKey: string,\n  threshold: number\n): Array<Record<string, unknown>> {\n  if (data?.length <= threshold) {\n    return data;\n  }\n\n  const sampled: Array<Record<string, unknown>> = [];\n\n  // Always add the first point\n  sampled.push(data[0]);\n\n  const bucketSize = (data?.length - 2) / (threshold - 2);\n\n  let a = 0; // Last sampled point index\n  let nextA = 0;\n\n  for (let i = 0; i < threshold - 2; i++) {\n    // Calculate bucket boundaries\n    const bucketStart = Math.floor((i + 0) * bucketSize) + 1;\n    const bucketEnd = Math.floor((i + 1) * bucketSize) + 1;\n\n    // Find the point with the largest triangle area in this bucket\n    let maxArea = -1;\n    let maxAreaIndex = bucketStart;\n\n    const pointA = {\n      x: Number(data[a][xKey] ?? 0),\n      y: Number(data[a][yKey] ?? 0),\n    };\n\n    // For each point in the current bucket\n    for (let j = bucketStart; j < bucketEnd; j++) {\n      // Look ahead to next bucket to get point C\n      const nextBucketStart = Math.floor((i + 1) * bucketSize) + 1;\n      const nextBucketEnd = Math.min(Math.floor((i + 2) * bucketSize) + 1, data?.length);\n\n      const avgX =\n        data\n          .slice(nextBucketStart, nextBucketEnd)\n          .reduce((sum, p) => sum + Number(p[xKey] ?? 0), 0) /\n        (nextBucketEnd - nextBucketStart);\n\n      const avgY =\n        data\n          .slice(nextBucketStart, nextBucketEnd)\n          .reduce((sum, p) => sum + Number(p[yKey] ?? 0), 0) /\n        (nextBucketEnd - nextBucketStart);\n\n      const pointC = { x: avgX, y: avgY };\n      const pointB = {\n        x: Number(data[j][xKey] ?? 0),\n        y: Number(data[j][yKey] ?? 0),\n      };\n\n      // Calculate triangle area\n      const area =\n        Math.abs(\n          (pointA.x - pointC.x) * (pointB.y - pointA.y) -\n            (pointA.x - pointB.x) * (pointC.y - pointA.y)\n        ) / 2;\n\n      if (area > maxArea) {\n        maxArea = area;\n        maxAreaIndex = j;\n        nextA = j;\n      }\n    }\n\n    // Add the point with the largest triangle area\n    sampled.push(data[maxAreaIndex]);\n    a = nextA;\n  }\n\n  // Always add the last point\n  sampled.push(data[data?.length - 1]);\n\n  return sampled;\n}\n\nexport interface CanvasLineChartProps extends BaseChartProps {\n  /** Data to visualize */\n  data: Array<Record<string, unknown>>;\n\n  /** Key for X-axis values (usually time or date) */\n  xAxisKey: string;\n\n  /** Array of keys for Y-axis series to display */\n  yAxisKeys: string[];\n\n  /** Label for X-axis */\n  xAxisLabel?: string;\n\n  /** Label for Y-axis */\n  yAxisLabel?: string;\n\n  /** Optional min/max values for X-axis (if not provided, calculated from data) */\n  xDomain?: [number, number];\n\n  /** Optional min/max values for Y-axis (if not provided, calculated from data) */\n  yDomain?: [number, number];\n\n  /** Colors for each series */\n  seriesColors?: string[];\n\n  /** Whether to show grid lines */\n  showGrid?: boolean;\n\n  /** Whether to show axes */\n  showAxes?: boolean;\n\n  /** Whether to show area fill under lines */\n  showAreaFill?: boolean;\n\n  /** Transparency level for area fill (0-1) */\n  areaFillOpacity?: number;\n\n  /** Whether to show data points */\n  showDataPoints?: boolean;\n\n  /** Radius of data points in pixels */\n  dataPointRadius?: number;\n\n  /** Line width in pixels */\n  lineWidth?: number;\n\n  /** Whether to animate on initial render */\n  animate?: boolean;\n\n  /** Animation duration in milliseconds */\n  animationDuration?: number;\n\n  /** Maximum number of points to render before downsampling */\n  maxPointsBeforeDownsampling?: number;\n\n  /** Whether to allow zooming and panning */\n  interactive?: boolean;\n\n  /** Whether to show axis labels and ticks */\n  showAxisLabels?: boolean;\n\n  /** Legend position */\n  legendPosition?: 'top' | 'bottom' | 'left' | 'right' | 'none';\n\n  /** Date format function for X-axis if it contains date values */\n  formatXAxisDate?: (value: number) => string;\n}\n\n// Define the HoveredPoint type more explicitly\ninterface HoveredPoint {\n  data: Record<string, unknown>;\n  x: number;\n  y: number;\n  seriesIndex: number;\n}\n\n/**\n * CanvasLineChart is a high-performance line chart using Canvas rendering\n * instead of SVG, optimized for time series with many data points.\n */\nexport const CanvasLineChart: React.FC<CanvasLineChartProps> = ({\n  data,\n  xAxisKey,\n  yAxisKeys,\n  width = '100%',\n  height = 400,\n  title,\n  subtitle,\n  xAxisLabel,\n  yAxisLabel,\n  xDomain,\n  yDomain,\n  seriesColors,\n  showGrid = true,\n  showAxes = true,\n  showAreaFill = false,\n  areaFillOpacity = 0.1,\n  showDataPoints = false,\n  dataPointRadius = 3,\n  lineWidth = 2,\n  animate = true,\n  animationDuration = 1000,\n  maxPointsBeforeDownsampling = 1000,\n  interactive = true,\n  showAxisLabels = true,\n  legendPosition = 'top',\n  formatXAxisDate,\n  className = '',\n  errorMessage,\n  onElementClick,\n}) => {\n  const theme = useTheme();\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const containerRef = useRef<HTMLDivElement>(null);\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });\n  const [hoveredPoint, setHoveredPoint] = useState<HoveredPoint | null>(null);\n  const [zoom, setZoom] = useState(1);\n  const [pan, setPan] = useState({ x: 0, y: 0 });\n  const [isDragging, setIsDragging] = useState(false);\n  const [dragStart, setDragStart] = useState({ x: 0, y: 0 });\n  const [animationProgress, setAnimationProgress] = useState(animate ? 0 : 1);\n  const [animationFrame, setAnimationFrame] = useState<number | null>(null);\n  const [downsampledData, setDownsampledData] = useState<Array<Record<string, unknown>>>(data);\n  const [tooltipContent, setTooltipContent] = useState<{\n    title: string;\n    value: string;\n    dataX: number;\n    dataY: number;\n  } | null>(null);\n\n  // Default series colors\n  const defaultColors = [\n    '#4361ee', // Blue\n    '#3a86ff', // Light blue\n    '#4cc9f0', // Cyan\n    '#4895ef', // Sky blue\n    '#560bad', // Purple\n    '#7209b7', // Dark purple\n    '#f72585', // Pink\n    '#b5179e', // Magenta\n  ];\n\n  // Use provided colors or defaults\n  const colors = useMemo(() => {\n    if (seriesColors && seriesColors.length >= yAxisKeys.length) {\n      return seriesColors;\n    }\n\n    // If not enough colors provided, cycle through defaults\n    return yAxisKeys.map((_, i) => defaultColors[i % defaultColors.length]);\n  }, [seriesColors, yAxisKeys, defaultColors]);\n\n  // Downsample data if needed for performance\n  useEffect(() => {\n    if (!data || data?.length === 0) return;\n\n    // Sort data by x-axis value\n    const sortedData = [...data].sort((a, b) => {\n      const aVal = Number(a[xAxisKey] ?? 0);\n      const bVal = Number(b[xAxisKey] ?? 0);\n      return aVal - bVal;\n    });\n\n    if (sortedData.length > maxPointsBeforeDownsampling) {\n      // Apply LTTB for first series (assume all series have same x values)\n      const downsampled = downsampleLTTB(\n        sortedData,\n        xAxisKey,\n        yAxisKeys[0],\n        maxPointsBeforeDownsampling\n      );\n      setDownsampledData(downsampled);\n    } else {\n      setDownsampledData(sortedData);\n    }\n  }, [data, xAxisKey, yAxisKeys, maxPointsBeforeDownsampling]);\n\n  // Calculate domains from data if not provided\n  const calculatedDomains = useMemo(() => {\n    if (!downsampledData || downsampledData.length === 0) {\n      return {\n        x: [0, 1] as [number, number],\n        y: [0, 1] as [number, number],\n      };\n    }\n\n    let xMin = Infinity;\n    let xMax = -Infinity;\n    let yMin = Infinity;\n    let yMax = -Infinity;\n\n    // Find min/max values for all series\n    downsampledData.forEach(item => {\n      // X values\n      const x = Number(item[xAxisKey] ?? 0);\n      xMin = Math.min(xMin, x);\n      xMax = Math.max(xMax, x);\n\n      // Y values for all series\n      yAxisKeys.forEach(key => {\n        const y = Number(item[key] ?? 0);\n        yMin = Math.min(yMin, y);\n        yMax = Math.max(yMax, y);\n      });\n    });\n\n    // Add padding to Y domain (5%)\n    const yRange = yMax - yMin;\n    const yPadding = yRange * 0.05;\n\n    return {\n      x: [xMin, xMax] as [number, number],\n      y: [yMin - yPadding, yMax + yPadding] as [number, number],\n    };\n  }, [downsampledData, xAxisKey, yAxisKeys]);\n\n  // Use provided domains or fall back to calculated ones\n  const domains = {\n    x: xDomain || calculatedDomains.x,\n    y: yDomain || calculatedDomains.y,\n  };\n\n  // Layout measurements\n  const layout = useMemo(() => {\n    const legendHeight = legendPosition === 'top' || legendPosition === 'bottom' ? 30 : 0;\n    const legendWidth = legendPosition === 'left' || legendPosition === 'right' ? 100 : 0;\n\n    return {\n      padding: {\n        left: 50,\n        right: 20,\n        top: legendPosition === 'top' ? legendHeight + 10 : 20,\n        bottom: legendPosition === 'bottom' ? legendHeight + 40 : 40,\n      },\n      legendHeight,\n      legendWidth,\n    };\n  }, [legendPosition]);\n\n  // Create scales for mapping data values to pixel coordinates\n  const scales = useMemo(() => {\n    return {\n      x: (value: number) => {\n        const canvasWidth = dimensions.width - layout.padding.left - layout.padding.right;\n        const normalizedValue = (value - domains.x[0]) / (domains.x[1] - domains.x[0]);\n        return layout.padding.left + normalizedValue * canvasWidth * zoom + pan.x;\n      },\n      y: (value: number) => {\n        const canvasHeight = dimensions.height - layout.padding.top - layout.padding.bottom;\n        // Note: Y is inverted in canvas coordinates (0 is top)\n        const normalizedValue = 1 - (value - domains.y[0]) / (domains.y[1] - domains.y[0]);\n        return layout.padding.top + normalizedValue * canvasHeight * zoom + pan.y;\n      },\n    };\n  }, [dimensions, domains, zoom, pan, layout]);\n\n  // Inverse scales for converting canvas coordinates to data values\n  const inverseScales = useMemo(() => {\n    return {\n      x: (pixelX: number) => {\n        const canvasWidth = dimensions.width - layout.padding.left - layout.padding.right;\n        const normalizedValue = (pixelX - layout.padding.left - pan.x) / (canvasWidth * zoom);\n        return domains.x[0] + normalizedValue * (domains.x[1] - domains.x[0]);\n      },\n      y: (pixelY: number) => {\n        const canvasHeight = dimensions.height - layout.padding.top - layout.padding.bottom;\n        // Note: Y is inverted in canvas coordinates (0 is top)\n        const normalizedValue = (pixelY - layout.padding.top - pan.y) / (canvasHeight * zoom);\n        return domains.y[0] + (1 - normalizedValue) * (domains.y[1] - domains.y[0]);\n      },\n    };\n  }, [dimensions, domains, zoom, pan, layout]);\n\n  // Update canvas dimensions when container size changes\n  const updateDimensions = useCallback(() => {\n    if (!containerRef.current) return;\n\n    const { width, height } = containerRef.current.getBoundingClientRect();\n    setDimensions({ width, height });\n\n    if (canvasRef.current) {\n      canvasRef.current.width = width;\n      canvasRef.current.height = height;\n    }\n  }, []);\n\n  // Debounced version of updateDimensions\n  const debouncedUpdateDimensions = useMemo(\n    () => debounce(updateDimensions, 100),\n    [updateDimensions]\n  );\n\n  // Set up ResizeObserver\n  useEffect(() => {\n    updateDimensions();\n\n    const observer = new ResizeObserver(debouncedUpdateDimensions);\n    if (containerRef.current) {\n      observer.observe(containerRef.current);\n    }\n\n    window.addEventListener('resize', debouncedUpdateDimensions);\n\n    return () => {\n      observer.disconnect();\n      window.removeEventListener('resize', debouncedUpdateDimensions);\n      debouncedUpdateDimensions.cancel();\n    };\n  }, [debouncedUpdateDimensions]);\n\n  // Animation effect\n  useEffect(() => {\n    if (!animate) {\n      setAnimationProgress(1);\n      return;\n    }\n\n    let startTimestamp: number | null = null;\n    const duration = animationDuration;\n\n    const step = (timestamp: number) => {\n      if (!startTimestamp) startTimestamp = timestamp;\n      const elapsed = timestamp - startTimestamp;\n\n      const progress = Math.min(elapsed / duration, 1);\n      setAnimationProgress(progress);\n\n      if (progress < 1) {\n        const frame = requestAnimationFrame(step);\n        setAnimationFrame(frame);\n      }\n    };\n\n    const frame = requestAnimationFrame(step);\n    setAnimationFrame(frame);\n\n    return () => {\n      if (animationFrame !== null) {\n        cancelAnimationFrame(animationFrame);\n      }\n    };\n  }, [animate, animationDuration]);\n\n  // Render the chart\n  const renderChart = useCallback(() => {\n    const canvas = canvasRef.current;\n    if (!canvas || !downsampledData || downsampledData.length === 0) return;\n\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    // Clear canvas\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    // Draw grid\n    if (showGrid) {\n      ctx.strokeStyle = theme.palette.mode === 'dark' ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';\n      ctx.lineWidth = 1;\n\n      // X grid lines (10 vertical lines)\n      for (let i = 0; i <= 10; i++) {\n        const x = domains.x[0] + (i / 10) * (domains.x[1] - domains.x[0]);\n        const xPixel = scales.x(x);\n\n        ctx.beginPath();\n        ctx.moveTo(xPixel, scales.y(domains.y[0]));\n        ctx.lineTo(xPixel, scales.y(domains.y[1]));\n        ctx.stroke();\n      }\n\n      // Y grid lines (5 horizontal lines)\n      for (let i = 0; i <= 5; i++) {\n        const y = domains.y[0] + (i / 5) * (domains.y[1] - domains.y[0]);\n        const yPixel = scales.y(y);\n\n        ctx.beginPath();\n        ctx.moveTo(scales.x(domains.x[0]), yPixel);\n        ctx.lineTo(scales.x(domains.x[1]), yPixel);\n        ctx.stroke();\n      }\n    }\n\n    // Draw axes\n    if (showAxes) {\n      ctx.strokeStyle = theme.palette.mode === 'dark' ? '#fff' : '#000';\n      ctx.lineWidth = 2;\n\n      // X-axis\n      ctx.beginPath();\n      ctx.moveTo(scales.x(domains.x[0]), scales.y(0));\n      ctx.lineTo(scales.x(domains.x[1]), scales.y(0));\n      ctx.stroke();\n\n      // Y-axis\n      ctx.beginPath();\n      ctx.moveTo(scales.x(0), scales.y(domains.y[0]));\n      ctx.lineTo(scales.x(0), scales.y(domains.y[1]));\n      ctx.stroke();\n    }\n\n    // Draw axis labels if enabled\n    if (showAxisLabels) {\n      ctx.fillStyle = theme.palette.mode === 'dark' ? '#fff' : '#000';\n      ctx.font = '12px Arial';\n      ctx.textAlign = 'center';\n\n      // X-axis labels (5 evenly spaced labels)\n      for (let i = 0; i <= 5; i++) {\n        const x = domains.x[0] + (i / 5) * (domains.x[1] - domains.x[0]);\n        const xPixel = scales.x(x);\n\n        let labelText = x.toFixed(1);\n        if (formatXAxisDate) {\n          labelText = formatXAxisDate(x);\n        }\n\n        ctx.fillText(labelText, xPixel, scales.y(domains.y[0]) + 20);\n      }\n\n      // Y-axis labels (5 evenly spaced labels)\n      ctx.textAlign = 'right';\n      for (let i = 0; i <= 5; i++) {\n        const y = domains.y[0] + (i / 5) * (domains.y[1] - domains.y[0]);\n        const yPixel = scales.y(y);\n\n        ctx.fillText(y.toFixed(1), scales.x(domains.x[0]) - 10, yPixel + 4);\n      }\n\n      // Axis titles\n      if (xAxisLabel) {\n        ctx.textAlign = 'center';\n        ctx.fillText(\n          xAxisLabel,\n          scales.x(domains.x[0] + (domains.x[1] - domains.x[0]) / 2),\n          canvas.height - 10\n        );\n      }\n\n      if (yAxisLabel) {\n        ctx.save();\n        ctx.translate(15, scales.y(domains.y[0] + (domains.y[1] - domains.y[0]) / 2));\n        ctx.rotate(-Math.PI / 2);\n        ctx.textAlign = 'center';\n        ctx.fillText(yAxisLabel, 0, 0);\n        ctx.restore();\n      }\n    }\n\n    // Draw legend\n    if (legendPosition !== 'none') {\n      ctx.font = '12px Arial';\n\n      const legendItems = yAxisKeys.map((key, i) => ({\n        label: key,\n        color: colors[i],\n      }));\n\n      if (legendPosition === 'top') {\n        let x = 10;\n        const y = 15;\n\n        legendItems.forEach(item => {\n          // Draw color box\n          ctx.fillStyle = item?.color;\n          ctx.fillRect(x, y - 9, 12, 9);\n          ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';\n          ctx.strokeRect(x, y - 9, 12, 9);\n\n          // Draw label\n          ctx.fillStyle = theme.palette.mode === 'dark' ? '#fff' : '#000';\n          ctx.textAlign = 'left';\n          ctx.fillText(item?.label, x + 16, y);\n\n          x += ctx.measureText(item?.label).width + 30;\n        });\n      } else if (legendPosition === 'bottom') {\n        let x = 10;\n        const y = canvas.height - 10;\n\n        legendItems.forEach(item => {\n          // Draw color box\n          ctx.fillStyle = item?.color;\n          ctx.fillRect(x, y - 9, 12, 9);\n          ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';\n          ctx.strokeRect(x, y - 9, 12, 9);\n\n          // Draw label\n          ctx.fillStyle = theme.palette.mode === 'dark' ? '#fff' : '#000';\n          ctx.textAlign = 'left';\n          ctx.fillText(item?.label, x + 16, y);\n\n          x += ctx.measureText(item?.label).width + 30;\n        });\n      } else if (legendPosition === 'right') {\n        let y = 20;\n        const x = canvas.width - 90;\n\n        legendItems.forEach(item => {\n          // Draw color box\n          ctx.fillStyle = item?.color;\n          ctx.fillRect(x, y - 9, 12, 9);\n          ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';\n          ctx.strokeRect(x, y - 9, 12, 9);\n\n          // Draw label\n          ctx.fillStyle = theme.palette.mode === 'dark' ? '#fff' : '#000';\n          ctx.textAlign = 'left';\n          ctx.fillText(item?.label, x + 16, y);\n\n          y += 20;\n        });\n      } else if (legendPosition === 'left') {\n        let y = 20;\n        const x = 10;\n\n        legendItems.forEach(item => {\n          // Draw color box\n          ctx.fillStyle = item?.color;\n          ctx.fillRect(x, y - 9, 12, 9);\n          ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';\n          ctx.strokeRect(x, y - 9, 12, 9);\n\n          // Draw label\n          ctx.fillStyle = theme.palette.mode === 'dark' ? '#fff' : '#000';\n          ctx.textAlign = 'left';\n          ctx.fillText(item?.label, x + 16, y);\n\n          y += 20;\n        });\n      }\n    }\n\n    // For animation, limit the number of points\n    const animationPointCount = Math.ceil(downsampledData.length * animationProgress);\n    const visibleData = animate ? downsampledData.slice(0, animationPointCount) : downsampledData;\n\n    // Draw each series\n    yAxisKeys.forEach((key, seriesIndex) => {\n      const color = colors[seriesIndex];\n      ctx.strokeStyle = color;\n      ctx.lineWidth = lineWidth;\n      ctx.fillStyle = color;\n\n      // First draw the area fill if enabled\n      if (showAreaFill && visibleData.length > 0) {\n        ctx.beginPath();\n\n        // Start at the first point at the bottom of the chart\n        const firstX = Number(visibleData[0][xAxisKey] ?? 0);\n        ctx.moveTo(scales.x(firstX), scales.y(domains.y[0]));\n\n        // Draw line up to the first data point\n        ctx.lineTo(scales.x(firstX), scales.y(Number(visibleData[0][key] ?? 0)));\n\n        // Draw the line through all points\n        visibleData.forEach(item => {\n          const x = Number(item[xAxisKey] ?? 0);\n          const y = Number(item[key] ?? 0);\n          ctx.lineTo(scales.x(x), scales.y(y));\n        });\n\n        // Draw line down to the bottom of the chart\n        const lastX = Number(visibleData[visibleData.length - 1][xAxisKey] ?? 0);\n        ctx.lineTo(scales.x(lastX), scales.y(domains.y[0]));\n\n        // Fill the path\n        ctx.fillStyle = `${color}${Math.round(areaFillOpacity * 255)\n          .toString(16)\n          .padStart(2, '0')}`;\n        ctx.fill();\n      }\n\n      // Now draw the line\n      ctx.beginPath();\n\n      let isFirstPoint = true;\n      visibleData.forEach(item => {\n        const x = Number(item[xAxisKey] ?? 0);\n        const y = Number(item[key] ?? 0);\n\n        if (isFirstPoint) {\n          ctx.moveTo(scales.x(x), scales.y(y));\n          isFirstPoint = false;\n        } else {\n          ctx.lineTo(scales.x(x), scales.y(y));\n        }\n      });\n\n      ctx.stroke();\n\n      // Draw data points if enabled\n      if (showDataPoints) {\n        visibleData.forEach(item => {\n          const x = Number(item[xAxisKey] ?? 0);\n          const y = Number(item[key] ?? 0);\n\n          ctx.beginPath();\n          ctx.arc(scales.x(x), scales.y(y), dataPointRadius, 0, Math.PI * 2);\n          ctx.fillStyle = color;\n          ctx.fill();\n\n          // Highlight hovered point\n          if (\n            hoveredPoint &&\n            hoveredPoint.data === item &&\n            hoveredPoint.seriesIndex === seriesIndex\n          ) {\n            ctx.strokeStyle = theme.palette.mode === 'dark' ? '#fff' : '#000';\n            ctx.lineWidth = 2;\n            ctx.stroke();\n          }\n        });\n      }\n    });\n  }, [\n    downsampledData,\n    domains,\n    scales,\n    colors,\n    theme.palette.mode,\n    showGrid,\n    showAxes,\n    showAxisLabels,\n    xAxisLabel,\n    yAxisLabel,\n    formatXAxisDate,\n    legendPosition,\n    yAxisKeys,\n    animate,\n    animationProgress,\n    showAreaFill,\n    areaFillOpacity,\n    lineWidth,\n    showDataPoints,\n    dataPointRadius,\n    hoveredPoint,\n  ]);\n\n  // Handle canvas click for point selection\n  const handleClick = useCallback(\n    (_event: React.MouseEvent<HTMLCanvasElement>) => {\n      if (!onElementClick || !hoveredPoint) return;\n\n      // Type assertion to ensure TypeScript knows the structure\n      const point = hoveredPoint as HoveredPoint;\n      onElementClick(point.data, point.seriesIndex);\n    },\n    [onElementClick, hoveredPoint]\n  );\n\n  // Handle mouse down for panning\n  const handleMouseDown = useCallback(\n    (e: React.MouseEvent<HTMLCanvasElement>) => {\n      if (!interactive) return;\n\n      setIsDragging(true);\n      setDragStart({ x: e.clientX, y: e.clientY });\n    },\n    [interactive]\n  );\n\n  // Handle mouse up for panning\n  const handleMouseUp = useCallback(() => {\n    setIsDragging(false);\n  }, []);\n\n  // Handle mouse move for panning\n  const handleMouseMove = useCallback(\n    (e: React.MouseEvent<HTMLCanvasElement>) => {\n      if (!canvasRef.current) return;\n\n      const rect = canvasRef.current.getBoundingClientRect();\n      const x = e.clientX - rect.left;\n      const y = e.clientY - rect.top;\n\n      // Convert canvas coordinates to data values using inverseScales\n      const dataX = inverseScales.x(x);\n      const dataY = inverseScales.y(y);\n\n      // If dragging, handle panning\n      if (isDragging && interactive) {\n        const dx = e.clientX - dragStart.x;\n        const dy = e.clientY - dragStart.y;\n\n        setPan(prev => ({ x: prev.x + dx, y: prev.y + dy }));\n        setDragStart({ x: e.clientX, y: e.clientY });\n        return;\n      }\n\n      // Otherwise, handle hover effects\n      // Find the closest point in the data\n      let closestPoint: HoveredPoint | null = null;\n      let minDistance = Number.MAX_VALUE;\n\n      if (showDataPoints) {\n        downsampledData.forEach((item, seriesIndex) => {\n          const itemX = scales.x(Number(item[xAxisKey]));\n          const itemY = scales.y(Number(item[yAxisKeys[seriesIndex]]));\n          const distance = Math.sqrt((x - itemX) ** 2 + (y - itemY) ** 2);\n\n          if (distance < minDistance && distance < 20) {\n            minDistance = distance;\n            closestPoint = {\n              data: item,\n              x: itemX,\n              y: itemY,\n              seriesIndex,\n            };\n          }\n        });\n      }\n\n      setHoveredPoint(closestPoint);\n\n      // Update tooltip content with data values\n      if (closestPoint) {\n        // Type assertion to ensure TypeScript knows the structure\n        const point = closestPoint as HoveredPoint;\n        const xValue = point.data[xAxisKey];\n        const yValue = point.data[yAxisKeys[point.seriesIndex]];\n\n        // Format the tooltip content using the actual data values\n        // and the converted coordinates from inverseScales\n        setTooltipContent({\n          title: `${xAxisKey}: ${formatXAxisDate ? formatXAxisDate(Number(xValue)) : xValue}`,\n          value: `${yAxisKeys[point.seriesIndex]}: ${yValue}`,\n          dataX,\n          dataY,\n        });\n\n        if (canvasRef.current) {\n          canvasRef.current.style.cursor = 'pointer';\n        }\n      } else {\n        setTooltipContent(null);\n        if (canvasRef.current) {\n          canvasRef.current.style.cursor = 'default';\n        }\n      }\n    },\n    [\n      downsampledData,\n      scales,\n      xAxisKey,\n      yAxisKeys,\n      isDragging,\n      showDataPoints,\n      inverseScales,\n      formatXAxisDate,\n      interactive,\n      dragStart,\n    ]\n  );\n\n  // Handle wheel for zooming\n  const handleWheel = useCallback(\n    (e: React.WheelEvent<HTMLCanvasElement>) => {\n      if (!interactive) return;\n\n      e.preventDefault();\n\n      const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;\n      setZoom(prev => Math.max(0.1, Math.min(10, prev * zoomFactor)));\n    },\n    [interactive]\n  );\n\n  // Render the visualization\n  useEffect(() => {\n    renderChart();\n  }, [renderChart, dimensions, downsampledData, animationProgress]);\n\n  // If no data, show error\n  if (!data || data?.length === 0) {\n    return (\n      <div\n        className={`${className} flex flex-col items-center justify-center rounded border border-solid border-opacity-10`}\n        style={{\n          width: typeof width === 'number' ? `${width}px` : width,\n          height: typeof height === 'number' ? `${height}px` : height,\n        }}\n      >\n        <Typography variant=\"body1\" color=\"text.secondary\">\n          {errorMessage || 'No data available'}\n        </Typography>\n      </div>\n    );\n  }\n\n  return (\n    <div\n      className={`${className} flex flex-col`}\n      style={{\n        width: typeof width === 'number' ? `${width}px` : width,\n        height: typeof height === 'number' ? `${height}px` : height,\n      }}\n    >\n      {/* Chart title and subtitle */}\n      {(title || subtitle) && (\n        <div className=\"mb-2 text-center\">\n          {title && <Typography variant=\"h6\">{title}</Typography>}\n          {subtitle && (\n            <Typography variant=\"body2\" color=\"text.secondary\">\n              {subtitle}\n            </Typography>\n          )}\n        </div>\n      )}\n\n      {/* Legend */}\n      {legendPosition !== 'none' && (\n        <div\n          className={`flex flex-wrap justify-center gap-4 ${\n            legendPosition === 'bottom' ? 'order-last mt-2' : 'mb-2'\n          }`}\n        >\n          {yAxisKeys.map((key, index) => (\n            <div key={key} className=\"flex items-center\">\n              <div\n                className=\"mr-1 h-3 w-3 rounded-full\"\n                style={{\n                  backgroundColor:\n                    seriesColors?.[index] || defaultColors[index % defaultColors.length],\n                }}\n              />\n              <Typography variant=\"caption\">{key}</Typography>\n            </div>\n          ))}\n        </div>\n      )}\n\n      {/* Canvas container */}\n      <div className=\"relative flex-1\" ref={containerRef} style={{ position: 'relative', flex: 1 }}>\n        <canvas\n          ref={canvasRef}\n          width={dimensions.width}\n          height={dimensions.height}\n          onMouseMove={handleMouseMove}\n          onMouseDown={handleMouseDown}\n          onMouseUp={handleMouseUp}\n          onMouseLeave={handleMouseUp}\n          onClick={handleClick}\n          onWheel={handleWheel}\n          style={{\n            width: '100%',\n            height: '100%',\n            display: 'block',\n          }}\n        />\n\n        {/* Tooltip */}\n        {tooltipContent && hoveredPoint && (\n          <div\n            className=\"absolute z-10 rounded bg-white p-2 shadow-md\"\n            style={{\n              left: hoveredPoint.x + 10,\n              top: hoveredPoint.y - 40,\n              pointerEvents: 'none',\n            }}\n          >\n            <Typography variant=\"caption\" component=\"div\" fontWeight=\"bold\">\n              {tooltipContent.title}\n            </Typography>\n            <Typography variant=\"caption\" component=\"div\">\n              {tooltipContent.value}\n            </Typography>\n          </div>\n        )}\n\n        {/* Controls for interactive mode */}\n        {interactive && (\n          <div className=\"absolute bottom-2 right-2 flex gap-1\">\n            <button\n              className=\"flex h-8 w-8 items-center justify-center rounded bg-white/80 text-gray-700 shadow hover:bg-white\"\n              onClick={() => setZoom(prev => Math.min(prev * 1.2, 10))}\n              title=\"Zoom In\"\n            >\n              +\n            </button>\n            <button\n              className=\"flex h-8 w-8 items-center justify-center rounded bg-white/80 text-gray-700 shadow hover:bg-white\"\n              onClick={() => setZoom(prev => Math.max(prev / 1.2, 0.1))}\n              title=\"Zoom Out\"\n            >\n              -\n            </button>\n            <button\n              className=\"flex h-8 w-8 items-center justify-center rounded bg-white/80 text-gray-700 shadow hover:bg-white\"\n              onClick={() => {\n                setPan({ x: 0, y: 0 });\n                setZoom(1);\n              }}\n              title=\"Reset View\"\n            >\n              â†º\n            </button>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default CanvasLineChart;\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/visualizations/charts/CanvasScatterPlot.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_e' is defined but never used.","line":668,"column":6,"nodeType":null,"messageId":"unusedVar","endLine":668,"endColumn":8}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Typography, useTheme } from '@mui/material';\nimport { debounce } from 'lodash';\nimport * as React from 'react';\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { ChartDataRecord } from '../../../../types/exploration/AnalysisComponentTypes';\nimport { BaseChartProps } from './BaseChart';\n\n// Define color scale creator (simplified version of d3 scales)\nfunction createColorScale(domain: [number, number], range: string[]): (value: number) => string {\n  return (value: number) => {\n    // Normalize value to 0-1 range\n    const normalizedValue = Math.max(0, Math.min(1, (value - domain[0]) / (domain[1] - domain[0])));\n    // Map to color index\n    const index = Math.min(range.length - 1, Math.floor(normalizedValue * range.length));\n    return range[index];\n  };\n}\n\nexport interface CanvasScatterPlotProps extends BaseChartProps {\n  /** Key for X-axis values */\n  xAxisKey: string;\n\n  /** Key for Y-axis values */\n  yAxisKey: string;\n\n  /** Optional key for point size */\n  sizeKey?: string;\n\n  /** Optional key for point color */\n  colorKey?: string;\n\n  /** Min/max values for X-axis (if not provided, calculated from data) */\n  xDomain?: [number, number];\n\n  /** Min/max values for Y-axis (if not provided, calculated from data) */\n  yDomain?: [number, number];\n\n  /** Min/max range for point sizes (in pixels) */\n  sizeRange?: [number, number];\n\n  /** Colors for points (or color range if colorKey provided) */\n  colorRange?: string[];\n\n  /** Whether to show axes */\n  showAxes?: boolean;\n\n  /** Whether to show grid lines */\n  showGrid?: boolean;\n\n  /** X-axis label */\n  xAxisLabel?: string;\n\n  /** Y-axis label */\n  yAxisLabel?: string;\n\n  /** Whether to allow zooming and panning */\n  interactive?: boolean;\n\n  /** High performance mode renders less details but handles more points */\n  highPerformanceMode?: boolean;\n\n  /** Maximum number of points to render before switching to high performance mode */\n  performanceThreshold?: number;\n\n  /** Use WebGL for rendering if available */\n  useWebGL?: boolean;\n\n  /** Whether to show axis labels and ticks */\n  showAxisLabels?: boolean;\n}\n\n/**\n * CanvasScatterPlot is a high-performance scatter plot using Canvas rendering\n * instead of SVG for handling very large datasets efficiently.\n */\nexport const CanvasScatterPlot: React.FC<CanvasScatterPlotProps> = ({\n  data,\n  xAxisKey,\n  yAxisKey,\n  sizeKey,\n  colorKey,\n  width = '100%',\n  height = 400,\n  title,\n  subtitle,\n  xDomain,\n  yDomain,\n  sizeRange = [4, 12],\n  colorRange = [\n    '#4361ee', // Blue\n    '#3a86ff', // Light blue\n    '#4cc9f0', // Cyan\n    '#4895ef', // Sky blue\n    '#560bad', // Purple\n    '#7209b7', // Dark purple\n    '#f72585', // Pink\n    '#b5179e', // Magenta\n  ],\n  showAxes = true,\n  showGrid = true,\n  xAxisLabel,\n  yAxisLabel,\n  showAxisLabels = true,\n  interactive = true,\n  highPerformanceMode: forcedHighPerformanceMode = false,\n  performanceThreshold = 5000,\n  useWebGL = true,\n  className = '',\n  errorMessage,\n  onElementClick,\n}) => {\n  const theme = useTheme();\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const webglCanvasRef = useRef<HTMLCanvasElement>(null);\n  const containerRef = useRef<HTMLDivElement>(null);\n  const [dimensions, setDimensions] = useState({ width: 0, height: 0 });\n  const [hoveredPoint, setHoveredPoint] = useState<ChartDataRecord | null>(null);\n  const [mouseDataPosition, setMouseDataPosition] = useState<{ x: number; y: number } | null>(null);\n  const [zoom, setZoom] = useState(1);\n  const [pan, setPan] = useState({ x: 0, y: 0 });\n  const [isDragging, setIsDragging] = useState(false);\n  const [dragStart, setDragStart] = useState({ x: 0, y: 0 });\n  const [canUseWebGL, setCanUseWebGL] = useState(false);\n\n  // WebGL context reference\n  const glRef = useRef<WebGLRenderingContext | null>(null);\n\n  // Calculate domains from data if not provided\n  const calculatedDomains = useMemo(() => {\n    if (!data || data?.length === 0) {\n      return {\n        x: [0, 1] as [number, number],\n        y: [0, 1] as [number, number],\n        size: [1, 1] as [number, number],\n        color: [0, 1] as [number, number],\n      };\n    }\n\n    let xMin = Infinity;\n    let xMax = -Infinity;\n    let yMin = Infinity;\n    let yMax = -Infinity;\n    let sizeMin = Infinity;\n    let sizeMax = -Infinity;\n    let colorMin = Infinity;\n    let colorMax = -Infinity;\n\n    // Find min/max values\n    data?.forEach(item => {\n      // X values\n      const x = Number(item[xAxisKey] ?? 0);\n      xMin = Math.min(xMin, x);\n      xMax = Math.max(xMax, x);\n\n      // Y values\n      const y = Number(item[yAxisKey] ?? 0);\n      yMin = Math.min(yMin, y);\n      yMax = Math.max(yMax, y);\n\n      // Size values (if provided)\n      if (sizeKey && item[sizeKey] !== undefined) {\n        const size = Number(item[sizeKey] ?? 0);\n        sizeMin = Math.min(sizeMin, size);\n        sizeMax = Math.max(sizeMax, size);\n      }\n\n      // Color values (if provided)\n      if (colorKey && item[colorKey] !== undefined) {\n        const color = Number(item[colorKey] ?? 0);\n        colorMin = Math.min(colorMin, color);\n        colorMax = Math.max(colorMax, color);\n      }\n    });\n\n    // Add a small buffer to domains (5%)\n    const xRange = xMax - xMin;\n    const yRange = yMax - yMin;\n\n    return {\n      x: [xMin - xRange * 0.05, xMax + xRange * 0.05] as [number, number],\n      y: [yMin - yRange * 0.05, yMax + yRange * 0.05] as [number, number],\n      size:\n        sizeMin !== Infinity\n          ? ([sizeMin, sizeMax] as [number, number])\n          : ([1, 1] as [number, number]),\n      color:\n        colorMin !== Infinity\n          ? ([colorMin, colorMax] as [number, number])\n          : ([0, 1] as [number, number]),\n    };\n  }, [data, xAxisKey, yAxisKey, sizeKey, colorKey]);\n\n  // Use provided domains or fall back to calculated ones\n  const domains = {\n    x: xDomain || calculatedDomains.x,\n    y: yDomain || calculatedDomains.y,\n    size: calculatedDomains.size,\n    color: calculatedDomains.color,\n  };\n\n  // Determine if we should use high performance mode\n  const highPerformanceMode =\n    forcedHighPerformanceMode || (data && data?.length > performanceThreshold);\n\n  // Check WebGL support\n  useEffect(() => {\n    if (!useWebGL) return;\n\n    const canvas = webglCanvasRef.current;\n    if (!canvas) return;\n\n    try {\n      const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\n      if (gl) {\n        glRef.current = gl as WebGLRenderingContext;\n        setCanUseWebGL(true);\n      } else {\n        console.warn('WebGL not supported, falling back to Canvas 2D rendering');\n        setCanUseWebGL(false);\n      }\n    } catch (e) {\n      console.error('Error initializing WebGL:', e);\n      setCanUseWebGL(false);\n    }\n  }, [useWebGL]);\n\n  // Create scales for mapping data values to pixel coordinates\n  const scales = useMemo(() => {\n    const padding = { left: 50, right: 20, top: 20, bottom: 40 };\n\n    return {\n      x: (value: number) => {\n        const canvasWidth = dimensions.width - padding.left - padding.right;\n        const normalizedValue = (value - domains.x[0]) / (domains.x[1] - domains.x[0]);\n        return padding.left + normalizedValue * canvasWidth * zoom + pan.x;\n      },\n      y: (value: number) => {\n        const canvasHeight = dimensions.height - padding.top - padding.bottom;\n        // Note: Y is inverted in canvas coordinates (0 is top)\n        const normalizedValue = 1 - (value - domains.y[0]) / (domains.y[1] - domains.y[0]);\n        return padding.top + normalizedValue * canvasHeight * zoom + pan.y;\n      },\n      size: (value: number) => {\n        if (!sizeKey) return sizeRange[0];\n        const normalizedValue = (value - domains.size[0]) / (domains.size[1] - domains.size[0]);\n        return sizeRange[0] + normalizedValue * (sizeRange[1] - sizeRange[0]);\n      },\n      color: createColorScale(domains.color, colorRange),\n    };\n  }, [dimensions, domains, sizeRange, colorRange, sizeKey, zoom, pan]);\n\n  // Inverse scales for converting canvas coordinates to data values\n  const inverseScales = useMemo(() => {\n    const padding = { left: 50, right: 20, top: 20, bottom: 40 };\n\n    return {\n      x: (pixelX: number) => {\n        const canvasWidth = dimensions.width - padding.left - padding.right;\n        const normalizedValue = (pixelX - padding.left - pan.x) / (canvasWidth * zoom);\n        return domains.x[0] + normalizedValue * (domains.x[1] - domains.x[0]);\n      },\n      y: (pixelY: number) => {\n        const canvasHeight = dimensions.height - padding.top - padding.bottom;\n        // Note: Y is inverted in canvas coordinates (0 is top)\n        const normalizedValue = 1 - (pixelY - padding.top - pan.y) / (canvasHeight * zoom);\n        return domains.y[0] + normalizedValue * (domains.y[1] - domains.y[0]);\n      },\n    };\n  }, [dimensions, domains, zoom, pan]);\n\n  // Initialize WebGL\n  const initWebGL = useCallback(() => {\n    const gl = glRef.current;\n    if (!gl) return false;\n\n    // Clear to black\n    gl.clearColor(0.0, 0.0, 0.0, 0.0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    // Basic vertex shader (converts 2D points to clip space)\n    const vertexShaderSource = `\n      attribute vec2 a_position;\n      attribute float a_size;\n      attribute vec3 a_color;\n      \n      uniform mat3 u_matrix;\n      \n      varying vec3 v_color;\n      \n      void main() {\n        // Apply transformation matrix\n        vec3 position = u_matrix * vec3(a_position, 1.0);\n        \n        // Convert from pixel space to clip space\n        gl_Position = vec4(position.xy, 0.0, 1.0);\n        gl_PointSize = a_size;\n        \n        // Pass color to fragment shader\n        v_color = a_color;\n      }\n    `;\n\n    // Fragment shader (colors the points)\n    const fragmentShaderSource = `\n      precision mediump float;\n      \n      varying vec3 v_color;\n      \n      void main() {\n        // Draw circle instead of square\n        float dist = distance(gl_PointCoord, vec2(0.5, 0.5));\n        if (dist > 0.5) {\n          discard;\n        }\n        \n        gl_FragColor = vec4(v_color, 1.0);\n      }\n    `;\n\n    // Create shaders\n    const vertexShader = gl.createShader(gl.VERTEX_SHADER);\n    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n\n    if (!vertexShader || !fragmentShader) return false;\n\n    // Set shader source\n    gl.shaderSource(vertexShader, vertexShaderSource);\n    gl.shaderSource(fragmentShader, fragmentShaderSource);\n\n    // Compile shaders\n    gl.compileShader(vertexShader);\n    gl.compileShader(fragmentShader);\n\n    // Check if shaders compiled successfully\n    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\n      console.error('Vertex shader compilation failed:', gl.getShaderInfoLog(vertexShader));\n      return false;\n    }\n\n    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\n      console.error('Fragment shader compilation failed:', gl.getShaderInfoLog(fragmentShader));\n      return false;\n    }\n\n    // Create program\n    const program = gl.createProgram();\n    if (!program) return false;\n\n    // Attach shaders\n    gl.attachShader(program, vertexShader);\n    gl.attachShader(program, fragmentShader);\n\n    // Link program\n    gl.linkProgram(program);\n\n    // Check if program linked successfully\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n      console.error('Program linking failed:', gl.getProgramInfoLog(program));\n      return false;\n    }\n\n    // Use program\n    gl.useProgram(program);\n\n    return true;\n  }, []);\n\n  // Update canvas dimensions when container size changes\n  const updateDimensions = useCallback(() => {\n    if (!containerRef.current) return;\n\n    const { width, height } = containerRef.current.getBoundingClientRect();\n    setDimensions({ width, height });\n\n    if (canvasRef.current) {\n      canvasRef.current.width = width;\n      canvasRef.current.height = height;\n    }\n\n    if (webglCanvasRef.current) {\n      webglCanvasRef.current.width = width;\n      webglCanvasRef.current.height = height;\n    }\n  }, []);\n\n  // Debounced version of updateDimensions\n  const debouncedUpdateDimensions = useMemo(\n    () => debounce(updateDimensions, 100),\n    [updateDimensions]\n  );\n\n  // Set up ResizeObserver\n  useEffect(() => {\n    updateDimensions();\n\n    const observer = new ResizeObserver(debouncedUpdateDimensions);\n    if (containerRef.current) {\n      observer.observe(containerRef.current);\n    }\n\n    window.addEventListener('resize', debouncedUpdateDimensions);\n\n    return () => {\n      observer.disconnect();\n      window.removeEventListener('resize', debouncedUpdateDimensions);\n      debouncedUpdateDimensions.cancel();\n    };\n  }, [debouncedUpdateDimensions]);\n\n  // Render with 2D Canvas context\n  const renderCanvas2D = useCallback(() => {\n    const canvas = canvasRef.current;\n    if (!canvas || !data) return;\n\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    // Clear canvas\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    // Draw grid\n    if (showGrid) {\n      ctx.strokeStyle = theme.palette.mode === 'dark' ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';\n      ctx.lineWidth = 1;\n\n      // Draw X grid lines\n      for (let i = 0; i <= 10; i++) {\n        const x = domains.x[0] + (i / 10) * (domains.x[1] - domains.x[0]);\n        const xPixel = scales.x(x);\n\n        ctx.beginPath();\n        ctx.moveTo(xPixel, scales.y(domains.y[0]));\n        ctx.lineTo(xPixel, scales.y(domains.y[1]));\n        ctx.stroke();\n      }\n\n      // Draw Y grid lines\n      for (let i = 0; i <= 10; i++) {\n        const y = domains.y[0] + (i / 10) * (domains.y[1] - domains.y[0]);\n        const yPixel = scales.y(y);\n\n        ctx.beginPath();\n        ctx.moveTo(scales.x(domains.x[0]), yPixel);\n        ctx.lineTo(scales.x(domains.x[1]), yPixel);\n        ctx.stroke();\n      }\n    }\n\n    // Draw axes\n    if (showAxes) {\n      ctx.strokeStyle = theme.palette.mode === 'dark' ? '#fff' : '#000';\n      ctx.lineWidth = 2;\n\n      // X-axis\n      ctx.beginPath();\n      ctx.moveTo(scales.x(domains.x[0]), scales.y(0));\n      ctx.lineTo(scales.x(domains.x[1]), scales.y(0));\n      ctx.stroke();\n\n      // Y-axis\n      ctx.beginPath();\n      ctx.moveTo(scales.x(0), scales.y(domains.y[0]));\n      ctx.lineTo(scales.x(0), scales.y(domains.y[1]));\n      ctx.stroke();\n    }\n\n    // Draw axis labels if enabled\n    if (showAxisLabels) {\n      ctx.fillStyle = theme.palette.mode === 'dark' ? '#fff' : '#000';\n      ctx.font = '12px Arial';\n      ctx.textAlign = 'center';\n\n      // X-axis labels\n      for (let i = 0; i <= 10; i++) {\n        const x = domains.x[0] + (i / 10) * (domains.x[1] - domains.x[0]);\n        const xPixel = scales.x(x);\n\n        ctx.fillText(x.toFixed(1), xPixel, scales.y(domains.y[0]) + 20);\n      }\n\n      // Y-axis labels\n      ctx.textAlign = 'right';\n      for (let i = 0; i <= 10; i++) {\n        const y = domains.y[0] + (i / 10) * (domains.y[1] - domains.y[0]);\n        const yPixel = scales.y(y);\n\n        ctx.fillText(y.toFixed(1), scales.x(domains.x[0]) - 10, yPixel + 4);\n      }\n\n      // Axis titles\n      if (xAxisLabel) {\n        ctx.textAlign = 'center';\n        ctx.fillText(\n          xAxisLabel,\n          scales.x(domains.x[0] + (domains.x[1] - domains.x[0]) / 2),\n          canvas.height - 10\n        );\n      }\n\n      if (yAxisLabel) {\n        ctx.save();\n        ctx.translate(15, scales.y(domains.y[0] + (domains.y[1] - domains.y[0]) / 2));\n        ctx.rotate(-Math.PI / 2);\n        ctx.textAlign = 'center';\n        ctx.fillText(yAxisLabel, 0, 0);\n        ctx.restore();\n      }\n    }\n\n    // Draw data points\n    data?.forEach(item => {\n      const x = Number(item[xAxisKey] ?? 0);\n      const y = Number(item[yAxisKey] ?? 0);\n\n      // Skip points outside the visible range\n      if (x < domains.x[0] || x > domains.x[1] || y < domains.y[0] || y > domains.y[1]) {\n        return;\n      }\n\n      const xPixel = scales.x(x);\n      const yPixel = scales.y(y);\n\n      // Determine point size\n      let pointSize = sizeRange[0];\n      if (sizeKey && item[sizeKey] !== undefined) {\n        pointSize = scales.size(Number(item[sizeKey] ?? 0));\n      }\n\n      // Determine point color\n      let pointColor = colorRange[0];\n      if (colorKey && item[colorKey] !== undefined) {\n        pointColor = scales.color(Number(item[colorKey] ?? 0));\n      }\n\n      // Draw point\n      ctx.beginPath();\n      ctx.arc(xPixel, yPixel, pointSize / 2, 0, Math.PI * 2);\n      ctx.fillStyle = pointColor;\n      ctx.fill();\n\n      // Highlight hovered point\n      if (hoveredPoint === item) {\n        ctx.strokeStyle = theme.palette.mode === 'dark' ? '#fff' : '#000';\n        ctx.lineWidth = 2;\n        ctx.stroke();\n      }\n    });\n  }, [\n    data,\n    domains,\n    scales,\n    sizeRange,\n    colorRange,\n    sizeKey,\n    colorKey,\n    hoveredPoint,\n    showGrid,\n    showAxes,\n    showAxisLabels,\n    xAxisLabel,\n    yAxisLabel,\n    theme.palette.mode,\n  ]);\n\n  // Render with WebGL\n  const renderWebGL = useCallback(() => {\n    const gl = glRef.current;\n    const canvas = webglCanvasRef.current;\n    if (!gl || !canvas || !data || data?.length === 0) return;\n\n    // Clear canvas\n    gl.viewport(0, 0, canvas.width, canvas.height);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    // Create points buffer\n    const points: number[] = [];\n    const sizes: number[] = [];\n    const colors: number[] = [];\n\n    // Prepare data for WebGL\n    data?.forEach(item => {\n      const x = Number(item[xAxisKey] ?? 0);\n      const y = Number(item[yAxisKey] ?? 0);\n\n      // Skip points outside the visible range\n      if (x < domains.x[0] || x > domains.x[1] || y < domains.y[0] || y > domains.y[1]) {\n        return;\n      }\n\n      // Convert to normalized device coordinates (WebGL space: -1 to 1)\n      const normalizedX = (scales.x(x) / canvas.width) * 2 - 1;\n      const normalizedY = -(scales.y(y) / canvas.height) * 2 + 1; // Flip Y\n\n      points.push(normalizedX, normalizedY);\n\n      // Determine point size\n      let pointSize = sizeRange[0];\n      if (sizeKey && item[sizeKey] !== undefined) {\n        pointSize = scales.size(Number(item[sizeKey] ?? 0));\n      }\n      sizes.push(pointSize);\n\n      // Determine point color\n      let pointColor = colorRange[0];\n      if (colorKey && item[colorKey] !== undefined) {\n        pointColor = scales.color(Number(item[colorKey] ?? 0));\n      }\n\n      // Convert hex color to RGB\n      const hexToRgb = (hex: string) => {\n        const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n        return result\n          ? [\n              parseInt(result[1], 16) / 255,\n              parseInt(result[2], 16) / 255,\n              parseInt(result[3], 16) / 255,\n            ]\n          : [0, 0, 0];\n      };\n\n      const rgb = hexToRgb(pointColor);\n      colors.push(rgb[0], rgb[1], rgb[2]);\n    });\n\n    // Get shader locations\n    const program = gl.getParameter(gl.CURRENT_PROGRAM);\n    const positionAttributeLocation = gl.getAttribLocation(program, 'a_position');\n    const sizeAttributeLocation = gl.getAttribLocation(program, 'a_size');\n    const colorAttributeLocation = gl.getAttribLocation(program, 'a_color');\n    const matrixLocation = gl.getUniformLocation(program, 'u_matrix');\n\n    // Create position buffer\n    const positionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(points), gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(positionAttributeLocation);\n    gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);\n\n    // Create size buffer\n    const sizeBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, sizeBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sizes), gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(sizeAttributeLocation);\n    gl.vertexAttribPointer(sizeAttributeLocation, 1, gl.FLOAT, false, 0, 0);\n\n    // Create color buffer\n    const colorBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(colorAttributeLocation);\n    gl.vertexAttribPointer(colorAttributeLocation, 3, gl.FLOAT, false, 0, 0);\n\n    // Set transformation matrix (identity for now)\n    const matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    gl.uniformMatrix3fv(matrixLocation, false, matrix);\n\n    // Draw points\n    gl.drawArrays(gl.POINTS, 0, points.length / 2);\n\n    // Clean up\n    gl.deleteBuffer(positionBuffer);\n    gl.deleteBuffer(sizeBuffer);\n    gl.deleteBuffer(colorBuffer);\n  }, [data, domains, scales, sizeRange, colorRange, sizeKey, colorKey, xAxisKey, yAxisKey]);\n\n  // Handle canvas click for point selection\n  const handleClick = useCallback(\n    (_e: React.MouseEvent<HTMLCanvasElement>) => {\n      if (!onElementClick || !hoveredPoint) return;\n      onElementClick(hoveredPoint, 0);\n    },\n    [onElementClick, hoveredPoint]\n  );\n\n  // Handle mouse down for panning\n  const handleMouseDown = useCallback(\n    (e: React.MouseEvent<HTMLCanvasElement>) => {\n      if (!interactive) return;\n\n      setIsDragging(true);\n      setDragStart({ x: e.clientX, y: e.clientY });\n    },\n    [interactive]\n  );\n\n  // Handle mouse up for panning\n  const handleMouseUp = useCallback(() => {\n    setIsDragging(false);\n  }, []);\n\n  // Handle mouse move for panning\n  const handleMouseMoveForPan = useCallback(\n    (e: React.MouseEvent<HTMLCanvasElement>) => {\n      if (!canvasRef.current) return;\n\n      const rect = canvasRef.current.getBoundingClientRect();\n      const mouseX = e.clientX - rect.left;\n      const mouseY = e.clientY - rect.top;\n\n      // Convert canvas coordinates to data values using inverseScales\n      const dataX = inverseScales.x(mouseX);\n      const dataY = inverseScales.y(mouseY);\n\n      // Store the current mouse position in data coordinates\n      setMouseDataPosition({ x: dataX, y: dataY });\n\n      // If dragging, handle panning\n      if (isDragging && interactive) {\n        const dx = e.clientX - dragStart.x;\n        const dy = e.clientY - dragStart.y;\n\n        setPan(prev => ({ x: prev.x + dx, y: prev.y + dy }));\n        setDragStart({ x: e.clientX, y: e.clientY });\n        return;\n      }\n\n      // If not dragging, find the closest point for hover effects\n      if (!isDragging && data) {\n        let closestPoint: Record<string, unknown> | null = null;\n        let closestDistance = Infinity;\n\n        // Only check points within a certain radius in high performance mode\n        const checkRadius = highPerformanceMode ? 10 : 50;\n\n        data?.forEach(item => {\n          const itemX = Number(item[xAxisKey] ?? 0);\n          const itemY = Number(item[yAxisKey] ?? 0);\n\n          // Calculate distance in pixel space\n          const pixelX = scales.x(itemX);\n          const pixelY = scales.y(itemY);\n\n          const distance = Math.sqrt(Math.pow(pixelX - mouseX, 2) + Math.pow(pixelY - mouseY, 2));\n\n          if (distance < closestDistance && distance < checkRadius) {\n            closestDistance = distance;\n            closestPoint = item;\n          }\n        });\n\n        setHoveredPoint(closestPoint);\n\n        // Update cursor style\n        if (canvasRef.current) {\n          canvasRef.current.style.cursor = closestPoint ? 'pointer' : 'default';\n        }\n      }\n    },\n    [\n      isDragging,\n      dragStart,\n      interactive,\n      data,\n      scales,\n      xAxisKey,\n      yAxisKey,\n      highPerformanceMode,\n      inverseScales,\n    ]\n  );\n\n  // Handle wheel for zooming\n  const handleWheel = useCallback(\n    (e: React.WheelEvent<HTMLCanvasElement>) => {\n      if (!interactive) return;\n\n      e.preventDefault();\n\n      const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;\n      setZoom(prev => Math.max(0.1, Math.min(10, prev * zoomFactor)));\n    },\n    [interactive]\n  );\n\n  // Render the visualization\n  useEffect(() => {\n    if (canUseWebGL && useWebGL) {\n      if (!glRef.current) {\n        const success = initWebGL();\n        if (!success) {\n          setCanUseWebGL(false);\n        }\n      }\n\n      renderWebGL();\n    } else {\n      renderCanvas2D();\n    }\n  }, [canUseWebGL, useWebGL, initWebGL, renderWebGL, renderCanvas2D, dimensions, data]);\n\n  // If no data, show error\n  if (!data || data?.length === 0) {\n    return (\n      <div\n        className={`${className} flex flex-col items-center justify-center rounded border border-solid border-opacity-10`}\n        style={{\n          width: typeof width === 'number' ? `${width}px` : width,\n          height: typeof height === 'number' ? `${height}px` : height,\n        }}\n      >\n        <Typography variant=\"body1\" color=\"text.secondary\">\n          {errorMessage || 'No data available'}\n        </Typography>\n      </div>\n    );\n  }\n\n  return (\n    <div\n      className={className}\n      style={{\n        width: typeof width === 'number' ? `${width}px` : width,\n        height: typeof height === 'number' ? `${height}px` : height,\n        display: 'flex',\n        flexDirection: 'column',\n      }}\n    >\n      {/* Chart title and subtitle */}\n      {(title || subtitle) && (\n        <div className=\"mb-2 text-center\">\n          {title && <Typography variant=\"h6\">{title}</Typography>}\n          {subtitle && (\n            <Typography variant=\"body2\" color=\"text.secondary\">\n              {subtitle}\n            </Typography>\n          )}\n        </div>\n      )}\n\n      {/* Performance mode notification */}\n      {highPerformanceMode && (\n        <Typography variant=\"caption\" color=\"text.secondary\" className=\"mb-1\">\n          High performance mode: {data?.length.toLocaleString()} data points\n        </Typography>\n      )}\n\n      {/* Canvas container */}\n      <div\n        ref={containerRef}\n        className=\"relative flex-1 overflow-hidden rounded\"\n        style={{\n          border: '1px solid rgba(0,0,0,0.1)',\n        }}\n      >\n        {/* Main canvas (2D rendering) */}\n        <canvas\n          ref={canvasRef}\n          style={{\n            position: 'absolute',\n            top: 0,\n            left: 0,\n            display: canUseWebGL && useWebGL ? 'none' : 'block',\n          }}\n          onMouseMove={handleMouseMoveForPan}\n          onClick={handleClick}\n          onMouseDown={handleMouseDown}\n          onMouseUp={handleMouseUp}\n          onMouseOut={handleMouseUp}\n          onWheel={handleWheel}\n        />\n\n        {/* WebGL canvas */}\n        <canvas\n          ref={webglCanvasRef}\n          style={{\n            position: 'absolute',\n            top: 0,\n            left: 0,\n            display: canUseWebGL && useWebGL ? 'block' : 'none',\n          }}\n          onMouseMove={handleMouseMoveForPan}\n          onClick={handleClick}\n          onMouseDown={handleMouseDown}\n          onMouseUp={handleMouseUp}\n          onMouseOut={handleMouseUp}\n          onWheel={handleWheel}\n        />\n\n        {/* Tooltip for hovered point */}\n        {hoveredPoint && (\n          <div\n            style={{\n              position: 'absolute',\n              top: scales.y(Number(hoveredPoint[yAxisKey] ?? 0)) - 10,\n              left: scales.x(Number(hoveredPoint[xAxisKey] ?? 0)) + 10,\n              backgroundColor:\n                theme.palette.mode === 'dark' ? 'rgba(0,0,0,0.8)' : 'rgba(255,255,255,0.8)',\n              border: '1px solid rgba(0,0,0,0.2)',\n              borderRadius: 4,\n              padding: 8,\n              pointerEvents: 'none',\n              zIndex: 1000,\n              maxWidth: 200,\n              fontSize: 12,\n            }}\n          >\n            <div>\n              <strong>{xAxisKey}:</strong> {Number(hoveredPoint[xAxisKey] ?? 0).toFixed(2)}\n            </div>\n            <div>\n              <strong>{yAxisKey}:</strong> {Number(hoveredPoint[yAxisKey] ?? 0).toFixed(2)}\n            </div>\n            {sizeKey && hoveredPoint[sizeKey] !== undefined && (\n              <div>\n                <strong>{sizeKey}:</strong> {Number(hoveredPoint[sizeKey] ?? 0).toFixed(2)}\n              </div>\n            )}\n            {colorKey && hoveredPoint[colorKey] !== undefined && (\n              <div>\n                <strong>{colorKey}:</strong> {Number(hoveredPoint[colorKey] ?? 0).toFixed(2)}\n              </div>\n            )}\n            {mouseDataPosition && (\n              <div className=\"mt-2 border-t border-gray-300 pt-1 text-xs\">\n                <div>Mouse position:</div>\n                <div>x: {mouseDataPosition.x.toFixed(2)}</div>\n                <div>y: {mouseDataPosition.y.toFixed(2)}</div>\n              </div>\n            )}\n          </div>\n        )}\n      </div>\n\n      {/* Controls for interactive mode */}\n      {interactive && (\n        <div className=\"mt-1 flex justify-center\">\n          <Typography variant=\"caption\" color=\"text.secondary\">\n            Scroll to zoom, drag to pan, click to select\n          </Typography>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default CanvasScatterPlot;\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/visualizations/charts/ClusterVisualization.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/visualizations/charts/HeatMap.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/visualizations/charts/LineChart.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/visualizations/charts/MemoryOptimizedCanvasChart.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_useDoubleBuffering' is assigned a value but never used.","line":99,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":99,"endColumn":42},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_formatXAxisDate' is defined but never used.","line":100,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":100,"endColumn":36},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_enableRenderCaching' is assigned a value but never used.","line":101,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":101,"endColumn":44},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_maxCacheSizeMB' is assigned a value but never used.","line":102,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":102,"endColumn":34}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Alert, CircularProgress, Typography } from '@mui/material';\nimport * as React from 'react';\nimport { useCallback, useEffect, useRef, useState } from 'react';\nimport { MemoryManagerOptions, useMemoryManager } from '../../../../hooks/useMemoryManager';\nimport { ChartDataRecord } from '../../../../types/exploration/AnalysisComponentTypes';\nimport { BaseChartProps } from './BaseChart';\nimport CanvasChartFactory, { ChartType } from './CanvasChartFactory';\n\n// Buffer management for canvas contexts\ninterface CanvasBuffer {\n  buffer: OffscreenCanvas | null;\n  context: OffscreenCanvasRenderingContext2D | null;\n  width: number;\n  height: number;\n  lastUpdated: number;\n}\n\nexport interface MemoryOptimizedCanvasChartProps extends BaseChartProps {\n  /** Type of chart to render */\n  chartType: ChartType;\n\n  /** Key for X-axis values */\n  xAxisKey: string;\n\n  /** Key(s) for Y-axis values */\n  yAxisKeys: string | string[];\n\n  /** Optional key for point size (scatter plots) */\n  sizeKey?: string;\n\n  /** Optional key for point color (scatter plots) */\n  colorKey?: string;\n\n  /** Optional min/max values for X-axis */\n  xDomain?: [number, number];\n\n  /** Optional min/max values for Y-axis */\n  yDomain?: [number, number];\n\n  /** Colors for data series */\n  colors?: string[];\n\n  /** Whether to use WebGL for rendering (if available) */\n  useWebGL?: boolean;\n\n  /** Maximum points to render before downsampling */\n  maxPoints?: number;\n\n  /** Whether to show performance statistics */\n  showPerformanceStats?: boolean;\n\n  /** Memory management configuration */\n  memoryOptions?: Partial<MemoryManagerOptions>;\n\n  /** Visibility threshold for auto-unloading (0-1, percentage of component visible) */\n  visibilityThreshold?: number;\n\n  /** Data resolution levels for adaptive quality (higher = better quality but more memory) */\n  qualityLevels?: number[];\n\n  /** Whether to use double buffering for smoother rendering */\n  useDoubleBuffering?: boolean;\n\n  /** (...args: unknown[]) => unknown to format date values on the X-axis */\n  formatXAxisDate?: (value: number) => string;\n\n  /** Whether to cache rendered results between renders */\n  enableRenderCaching?: boolean;\n\n  /** Maximum cache size for rendered images (in MB) */\n  maxCacheSizeMB?: number;\n}\n\n/**\n * MemoryOptimizedCanvasChart is a highly optimized chart component that\n * deeply integrates with the memory management system, providing advanced\n * caching strategies, buffer management, and adaptive quality rendering.\n */\nconst MemoryOptimizedCanvasChart: React.FC<MemoryOptimizedCanvasChartProps> = ({\n  data,\n  chartType,\n  xAxisKey,\n  yAxisKeys,\n  sizeKey,\n  colorKey,\n  width = '100%',\n  height = 400,\n  title,\n  subtitle,\n  xDomain,\n  yDomain,\n  colors,\n  useWebGL = true,\n  maxPoints = 5000,\n  showPerformanceStats = false,\n  memoryOptions,\n  visibilityThreshold = 0.1,\n  qualityLevels = [0.25, 0.5, 1.0],\n  useDoubleBuffering: _useDoubleBuffering = true,\n  formatXAxisDate: _formatXAxisDate,\n  enableRenderCaching: _enableRenderCaching = true,\n  maxCacheSizeMB: _maxCacheSizeMB = 50,\n  className = '',\n  errorMessage,\n  onElementClick,\n}) => {\n  // Container ref for checking visibility\n  const containerRef = useRef<HTMLDivElement>(null);\n\n  // Canvas buffer management\n  const [canvasBuffers, setCanvasBuffers] = useState<Map<string, CanvasBuffer>>(new Map());\n\n  // Generate a unique instance ID for this chart\n  const instanceIdRef = useRef<string>(`chart_${Math.random().toString(36).substring(2, 11)}`);\n\n  // Visibility state\n  const [isVisible, setIsVisible] = useState(true);\n  const [visibilityPercentage, setVisibilityPercentage] = useState(1.0);\n\n  // Selected quality level based on visibility and data size\n  const [_qualityLevel, setQualityLevel] = useState(1.0);\n\n  // Render state\n  const [_isRendering, _setIsRendering] = useState(false);\n  const [renderError, _setRenderError] = useState<string | null>(null);\n\n  // Data processing state\n  const [processedData, setProcessedData] = useState<ChartDataRecord[] | null>(null);\n\n  // Performance metrics\n  const [performanceMetrics, setPerformanceMetrics] = useState({\n    renderTime: 0,\n    memoryUsage: 0,\n    dataPoints: 0,\n    renderedPoints: 0,\n    renderQuality: 1.0,\n  });\n\n  // Enhanced memory manager with canvas-specific features\n  const memory = useMemoryManager<{\n    data: ChartDataRecord[];\n    buffers: Map<string, CanvasBuffer>;\n    renderCache: Map<string, ImageBitmap>;\n  }>(null, {\n    key: instanceIdRef.current,\n    enableLogging: showPerformanceStats,\n    initialDataSizeEstimate: data ? data?.length * 100 : 1000, // Rough estimate\n    autoCleanupLevel: memoryOptions?.autoCleanupLevel || 'medium',\n    memoryThreshold: memoryOptions?.memoryThreshold || 50 * 1024 * 1024, // 50MB default\n    cacheExpirationTime: memoryOptions?.cacheExpirationTime || 60000, // 1 minute default\n    ...memoryOptions,\n  });\n\n  // Set up intersection observer to track visibility\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    const options = {\n      root: null,\n      rootMargin: '0px',\n      threshold: [0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0],\n    };\n\n    const callback: IntersectionObserverCallback = entries => {\n      entries.forEach(entry => {\n        setIsVisible(entry.isIntersecting);\n        setVisibilityPercentage(entry.intersectionRatio);\n      });\n    };\n\n    const observer = new IntersectionObserver(callback, options);\n    observer.observe(containerRef.current);\n\n    return () => {\n      observer.disconnect();\n    };\n  }, []);\n\n  // Calculate optimal quality level based on data size and visibility\n  const calculateOptimalQualityLevel = useCallback(\n    (dataLength: number, visibility: number, qualityLevels: number[]): number => {\n      // If data is small, use highest quality\n      if (dataLength < maxPoints) return 1.0;\n\n      // If component is barely visible, use lowest quality\n      if (visibility < visibilityThreshold) return qualityLevels[0];\n\n      // Scale quality based on visibility and data size\n      const visibilityFactor = Math.min(1, visibility / 0.5); // Full quality at 50% visibility\n      const sizeFactor = Math.min(1, maxPoints / dataLength);\n      const combinedFactor = visibilityFactor * sizeFactor;\n\n      // Find the appropriate quality level\n      for (let i = qualityLevels.length - 1; i >= 0; i--) {\n        if (combinedFactor >= qualityLevels[i]) {\n          return qualityLevels[i];\n        }\n      }\n\n      return qualityLevels[0]; // Default to lowest quality\n    },\n    [maxPoints, visibilityThreshold]\n  );\n\n  // Apply quality level (downsample data if needed)\n  const applyQualityLevel = useCallback(\n    (inputData: unknown[], quality: number): ChartDataRecord[] => {\n      if (!inputData.length) return [];\n\n      // If quality is 1.0, use all data points\n      if (quality >= 1.0) {\n        // Add type assertion to fix the type error\n        return inputData as ChartDataRecord[];\n      }\n\n      // Calculate how many points to keep\n      const targetPoints = Math.max(2, Math.floor(inputData.length * quality));\n\n      // If we have fewer points than target, use all\n      if (inputData.length <= targetPoints) {\n        return inputData as ChartDataRecord[];\n      }\n\n      // Simple downsampling - take evenly spaced points\n      const step = inputData.length / targetPoints;\n      const result: ChartDataRecord[] = [];\n\n      for (let i = 0; i < inputData.length; i += step) {\n        const index = Math.floor(i);\n        if (index < inputData.length) {\n          result?.push(inputData[index] as ChartDataRecord);\n        }\n      }\n\n      return result;\n    },\n    [maxPoints]\n  );\n\n  // Fix the type error in the updateData function by using a different approach\n  useEffect(() => {\n    if (!data || !data?.length) {\n      setProcessedData(null);\n      return;\n    }\n\n    // Track start time for performance measurement\n    const startTime = performance.now();\n\n    // Calculate optimal quality level based on data size and visibility\n    const newQualityLevel = calculateOptimalQualityLevel(\n      data?.length,\n      visibilityPercentage,\n      qualityLevels\n    );\n\n    setQualityLevel(newQualityLevel);\n\n    // Apply quality level (downsample data if needed)\n    const sampledData = applyQualityLevel(data, newQualityLevel);\n\n    // Update processed data state first\n    setProcessedData(sampledData);\n\n    // Update memory manager without using complex types\n    // Use a more direct approach to avoid the complex union type error\n    if (memory) {\n      // Use a function that doesn't return a complex union type\n      const updateMemoryData = () => {\n        memory.updateData({\n          data: sampledData,\n          buffers: canvasBuffers,\n          renderCache: new Map(),\n        });\n      };\n\n      // Call the function\n      updateMemoryData();\n    }\n\n    const endTime = performance.now();\n\n    // Update performance metrics\n    setPerformanceMetrics(prev => ({\n      ...prev,\n      renderTime: endTime - startTime,\n      memoryUsage: memory.memoryUsage,\n      dataPoints: data?.length,\n      renderedPoints: sampledData.length,\n      renderQuality: newQualityLevel,\n    }));\n  }, [\n    data,\n    memory,\n    visibilityPercentage,\n    qualityLevels,\n    canvasBuffers,\n    calculateOptimalQualityLevel,\n    applyQualityLevel,\n  ]);\n\n  // Cleanup unused canvas buffers and cached renders\n  useEffect(() => {\n    // Only clean up if component is not visible\n    if (isVisible && visibilityPercentage > visibilityThreshold) return;\n\n    // Clean up canvas buffers\n    setCanvasBuffers(prev => {\n      const now = Date.now();\n      const newBuffers = new Map(prev);\n\n      // Remove buffers that haven't been used in the last minute\n      for (const [key, buffer] of newBuffers.entries()) {\n        if (now - buffer.lastUpdated > 60000) {\n          if (buffer.buffer) {\n            // Close buffer to free memory\n            buffer.buffer = null;\n            buffer.context = null;\n          }\n          newBuffers.delete(key);\n        }\n      }\n\n      return newBuffers;\n    });\n\n    // Clean up render cache\n    if (memory.getCachedData('renderCache')) {\n      const renderCache = memory.getCachedData('renderCache') as Map<string, ImageBitmap>;\n\n      // Clean up old render cache entries\n      for (const [key, bitmap] of renderCache.entries()) {\n        if (key.startsWith('render_') && !isVisible) {\n          // Close bitmap to free memory\n          bitmap.close();\n          renderCache.delete(key);\n        }\n      }\n    }\n  }, [isVisible, visibilityPercentage, visibilityThreshold, memory]);\n\n  // Create or get a canvas buffer\n  const getCanvasBuffer = useCallback(\n    (key: string, width: number, height: number): CanvasBuffer => {\n      // Check if we already have a buffer with this key\n      if (canvasBuffers.has(key)) {\n        const buffer = canvasBuffers.get(key)!;\n\n        // If buffer dimensions match, return it\n        if (buffer.width === width && buffer.height === height && buffer.buffer) {\n          return buffer;\n        }\n      }\n\n      // Create a new buffer\n      let buffer: OffscreenCanvas | null = null;\n      let context: OffscreenCanvasRenderingContext2D | null = null;\n\n      try {\n        buffer = new OffscreenCanvas(width, height);\n        context = buffer.getContext('2d') as OffscreenCanvasRenderingContext2D;\n      } catch (error) {\n        console.error('Failed to create OffscreenCanvas:', error);\n        // If OffscreenCanvas is not supported, we'll fall back to regular canvas\n        // in the render method\n      }\n\n      const newBuffer: CanvasBuffer = {\n        buffer,\n        context,\n        width,\n        height,\n        lastUpdated: Date.now(),\n      };\n\n      // Store the new buffer\n      setCanvasBuffers(prev => {\n        const next = new Map(prev);\n        next.set(key, newBuffer);\n        return next;\n      });\n\n      return newBuffer;\n    },\n    [canvasBuffers]\n  );\n\n  // Get render cache key\n  const getRenderCacheKey = useCallback(\n    (chartType: ChartType, dataHash: string, width: number, height: number): string => {\n      return `render_${chartType}_${dataHash}_${width}_${height}`;\n    },\n    []\n  );\n\n  // Calculate a hash for the data (for caching)\n  const calculateDataHash = useCallback((data: ChartDataRecord[]): string => {\n    // Simple hash based on data length and some sample points\n    if (!data?.length) return '0';\n\n    const samples = [data[0], data[Math.floor(data?.length / 2)], data[data?.length - 1]];\n    return `${data?.length}_${JSON.stringify(samples)}`;\n  }, []);\n\n  // Integrate the functions into the component's functionality\n  useEffect(() => {\n    if (!processedData || !processedData.length) return;\n\n    // Use our functions to manage canvas rendering and caching\n    const canvasKey = `main_${instanceIdRef.current}`;\n    const canvasWidth = typeof width === 'number' ? width : 800; // Default width if percentage\n    const canvasHeight = typeof height === 'number' ? height : 400; // Default height\n\n    // Get or create a canvas buffer\n    const buffer = getCanvasBuffer(canvasKey, canvasWidth, canvasHeight);\n\n    // Calculate data hash for caching\n    const dataHash = calculateDataHash(processedData);\n\n    // Generate a cache key\n    const cacheKey = getRenderCacheKey(chartType, dataHash, canvasWidth, canvasHeight);\n\n    // Store in memory manager for potential reuse\n    memory.updateData({\n      data: processedData,\n      buffers: canvasBuffers,\n      renderCache: new Map([[cacheKey, buffer.buffer as unknown as ImageBitmap]]),\n    });\n\n    // Update performance metrics\n    setPerformanceMetrics(prev => ({\n      ...prev,\n      dataPoints: data?.length ?? 0,\n      renderedPoints: processedData.length,\n      renderQuality: _qualityLevel,\n    }));\n  }, [\n    processedData,\n    width,\n    height,\n    chartType,\n    getCanvasBuffer,\n    calculateDataHash,\n    getRenderCacheKey,\n    memory,\n    canvasBuffers,\n    _qualityLevel,\n    data?.length,\n  ]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      // Clean up all buffers and caches\n      canvasBuffers.forEach(buffer => {\n        if (buffer.buffer) {\n          buffer.buffer = null;\n          buffer.context = null;\n        }\n      });\n\n      // Force memory cleanup\n      memory.cleanup();\n    };\n  }, [memory, canvasBuffers]);\n\n  // If not visible and below threshold, render placeholder\n  if (!isVisible && visibilityPercentage < visibilityThreshold) {\n    return (\n      <div\n        ref={containerRef}\n        className={`${className} bg-paper flex items-center justify-center rounded border border-solid border-opacity-10`}\n        style={{\n          width: typeof width === 'number' ? `${width}px` : width,\n          height: typeof height === 'number' ? `${height}px` : height,\n        }}\n      >\n        <Typography variant=\"body2\" color=\"text.secondary\">\n          Chart offscreen (data unloaded)\n        </Typography>\n      </div>\n    );\n  }\n\n  // Loading state\n  if (!processedData) {\n    return (\n      <div\n        ref={containerRef}\n        className={`${className} flex flex-col items-center justify-center rounded border border-solid border-opacity-10`}\n        style={{\n          width: typeof width === 'number' ? `${width}px` : width,\n          height: typeof height === 'number' ? `${height}px` : height,\n        }}\n      >\n        <CircularProgress size={24} />\n        <Typography variant=\"body2\" sx={{ mt: 1 }}>\n          Loading chart data?...\n        </Typography>\n      </div>\n    );\n  }\n\n  // Render error state\n  if (renderError) {\n    return (\n      <div\n        ref={containerRef}\n        className={`${className} flex flex-col items-center justify-center rounded border border-solid border-opacity-10`}\n        style={{\n          width: typeof width === 'number' ? `${width}px` : width,\n          height: typeof height === 'number' ? `${height}px` : height,\n        }}\n      >\n        <Alert severity=\"error\" sx={{ maxWidth: '80%' }}>\n          {renderError}\n        </Alert>\n      </div>\n    );\n  }\n\n  return (\n    <div\n      ref={containerRef}\n      className={className}\n      style={{\n        position: 'relative',\n        width: typeof width === 'number' ? `${width}px` : width,\n        height: typeof height === 'number' ? `${height}px` : height,\n      }}\n    >\n      {/* Render the chart using our CanvasChartFactory */}\n      <CanvasChartFactory\n        data={processedData}\n        chartType={chartType}\n        xAxisKey={xAxisKey}\n        yAxisKeys={yAxisKeys}\n        sizeKey={sizeKey}\n        colorKey={colorKey}\n        width={width}\n        height={height}\n        title={title}\n        subtitle={subtitle}\n        xDomain={xDomain}\n        yDomain={yDomain}\n        colors={colors}\n        useWebGL={useWebGL}\n        maxPoints={maxPoints}\n        showPerformanceStats={false} // We'll show our own performance stats\n        enableMemoryOptimization={false} // We're already handling memory management\n        onElementClick={onElementClick}\n        errorMessage={errorMessage}\n      />\n\n      {/* Performance stats overlay */}\n      {showPerformanceStats && (\n        <div\n          className=\"absolute right-1 top-1 z-10 rounded p-2 text-xs opacity-90\"\n          style={{\n            position: 'absolute',\n            top: 5,\n            right: 5,\n            padding: '4px 8px',\n            borderRadius: 4,\n            fontSize: '0.75rem',\n            zIndex: 10,\n            opacity: 0.9,\n            maxWidth: 200,\n            backgroundColor: 'white',\n            boxShadow:\n              '0px 2px 1px -1px rgba(0,0,0,0.2), 0px 1px 1px 0px rgba(0,0,0,0.14), 0px 1px 3px 0px rgba(0,0,0,0.12)',\n          }}\n        >\n          <Typography variant=\"caption\" component=\"div\" sx={{ fontWeight: 'bold' }}>\n            Performance Metrics\n          </Typography>\n          <Typography variant=\"caption\" component=\"div\">\n            Render Time: {performanceMetrics.renderTime.toFixed(1)}ms\n          </Typography>\n          <Typography variant=\"caption\" component=\"div\">\n            Memory Usage: {(performanceMetrics.memoryUsage / 1024 / 1024).toFixed(2)} MB\n          </Typography>\n          <Typography variant=\"caption\" component=\"div\">\n            Data Points: {performanceMetrics.dataPoints.toLocaleString()}\n          </Typography>\n          <Typography variant=\"caption\" component=\"div\">\n            Rendered: {performanceMetrics.renderedPoints.toLocaleString()} points\n          </Typography>\n          <Typography variant=\"caption\" component=\"div\">\n            Quality: {(performanceMetrics.renderQuality * 100).toFixed(0)}%\n          </Typography>\n          <Typography variant=\"caption\" component=\"div\">\n            Visibility: {(visibilityPercentage * 100).toFixed(0)}%\n          </Typography>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default MemoryOptimizedCanvasChart;\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/visualizations/charts/PredictionVisualization.tsx","messages":[{"ruleId":"no-unsafe-optional-chaining","severity":2,"message":"Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.","line":103,"column":27,"nodeType":"ChainExpression","messageId":"unsafeOptionalChain","endLine":103,"endColumn":44},{"ruleId":"no-unsafe-optional-chaining","severity":2,"message":"Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.","line":114,"column":27,"nodeType":"ChainExpression","messageId":"unsafeOptionalChain","endLine":114,"endColumn":41}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  FormControl,\n  InputLabel,\n  MenuItem,\n  Paper,\n  Select,\n  SelectChangeEvent,\n  Tab,\n  Table,\n  TableBody,\n  TableCell,\n  TableContainer,\n  TableHead,\n  TableRow,\n  Tabs,\n  Typography,\n} from '@mui/material';\nimport { scaleOrdinal } from 'd3-scale';\nimport { schemeCategory10 } from 'd3-scale-chromatic';\nimport * as React from 'react';\nimport { useCallback, useMemo, useState } from 'react';\nimport {\n  CartesianGrid,\n  Legend,\n  Line,\n  LineChart,\n  ReferenceArea,\n  ReferenceLine,\n  ResponsiveContainer,\n  Scatter,\n  ScatterChart,\n  Tooltip,\n  XAxis,\n  YAxis,\n  ZAxis,\n} from 'recharts';\n\nimport {\n  ChartDataRecord,\n  LinearRegressionModelDetails,\n  NeuralNetworkModelDetails,\n  PredictionVisualizationProps,\n  TooltipRenderer,\n} from '../../../../types/exploration/AnalysisComponentTypes';\nimport { createTooltipComponent } from './TooltipAdapter';\nimport VirtualizedLineChart from './VirtualizedLineChart';\n\n// Create a color scale\nconst colorScale = scaleOrdinal(schemeCategory10);\n\n// Define type-safe interfaces for the chart data\ninterface TimeSeriesDataPoint extends ChartDataRecord {\n  timestamp: number;\n  actual?: number;\n  predicted: number;\n  error?: number;\n  lower?: number;\n  upper?: number;\n  type: 'historical' | 'forecast';\n}\n\ninterface FeatureComparisonDataPoint {\n  featureValue: number;\n  actual: number;\n  predicted: number;\n  error?: number;\n}\n\ninterface ResidualDataPoint {\n  predicted: number;\n  residual: number;\n  actual: number;\n}\n\n// Type guard for model details\nfunction isLinearRegressionModel(\n  modelDetails: LinearRegressionModelDetails | NeuralNetworkModelDetails\n): modelDetails is LinearRegressionModelDetails {\n  return 'coefficients' in modelDetails;\n}\n\nfunction isNeuralNetworkModel(\n  modelDetails: LinearRegressionModelDetails | NeuralNetworkModelDetails\n): modelDetails is NeuralNetworkModelDetails {\n  return 'architecture' in modelDetails;\n}\n\nexport const PredictionVisualization: React.FC<PredictionVisualizationProps> = React.memo(\n  ({ data, width = '100%', height = 500, title }) => {\n    const [activeTab, setActiveTab] = useState(0);\n    const [selectedFeature, setSelectedFeature] = useState<string>('');\n\n    const featureIndex = useMemo(() => {\n      if (!selectedFeature) return -1;\n      return data?.features.indexOf(selectedFeature);\n    }, [data?.features, selectedFeature]);\n\n    // Prepare time series data for date-based visualization\n    const timeSeriesData = useMemo<TimeSeriesDataPoint[]>(() => {\n      console.warn('Computing time series data'); // Helpful for debugging\n      const result: TimeSeriesDataPoint[] = [];\n      // Add historical data points\n      for (const point of data?.predictions) {\n        result?.push({\n          timestamp: point.features[0], // Assume first feature is timestamp\n          actual: point.actual,\n          predicted: point.predicted,\n          error: point.error,\n          type: 'historical',\n        });\n      }\n\n      // Add forecast data points\n      for (const point of data?.forecast) {\n        result?.push({\n          timestamp: point.features[0], // Assume first feature is timestamp\n          predicted: point.predicted,\n          lower: point.confidence ? point.confidence[0] : undefined,\n          upper: point.confidence ? point.confidence[1] : undefined,\n          type: 'forecast',\n        });\n      }\n\n      // Sort by timestamp\n      return result?.sort((a, b) => a.timestamp - b.timestamp);\n    }, [data?.predictions, data?.forecast]);\n\n    // Feature comparison data\n    const featureComparisonData = useMemo<FeatureComparisonDataPoint[]>(() => {\n      if (featureIndex < 0 || !selectedFeature) return [];\n\n      return data?.predictions.map(point => ({\n        featureValue: point.features[featureIndex + 1], // Skip timestamp\n        actual: point.actual,\n        predicted: point.predicted,\n        error: point.error,\n      }));\n    }, [data?.predictions, featureIndex, selectedFeature]);\n\n    // Residual plot data\n    const residualData = useMemo<ResidualDataPoint[]>(() => {\n      return data?.predictions.map(point => ({\n        predicted: point.predicted,\n        residual: point.actual - point.predicted,\n        actual: point.actual,\n      }));\n    }, [data?.predictions]);\n\n    // Get forecast start timestamp\n    const forecastStartTimestamp = useMemo(() => {\n      const forecastPoint = timeSeriesData.find(d => d.type === 'forecast');\n      return forecastPoint ? forecastPoint.timestamp : undefined;\n    }, [timeSeriesData]);\n\n    const handleTabChange = useCallback((_event: React.SyntheticEvent, newValue: number) => {\n      setActiveTab(newValue);\n    }, []);\n\n    const handleFeatureChange = useCallback((event: SelectChangeEvent<string>) => {\n      setSelectedFeature(event?.target.value);\n    }, []);\n\n    // Custom tooltip renderers with proper typing\n    const renderTimeSeriesToolTip: TooltipRenderer<TimeSeriesDataPoint> = useCallback(dataPoint => {\n      return (\n        <Paper sx={{ p: 1 }}>\n          <Typography variant=\"subtitle2\">\n            {new Date(dataPoint.timestamp).toLocaleDateString()}\n          </Typography>\n          {dataPoint.type === 'historical' ? (\n            <>\n              <Typography variant=\"body2\">Actual: {dataPoint.actual?.toFixed(2)}</Typography>\n              <Typography variant=\"body2\">Predicted: {dataPoint.predicted.toFixed(2)}</Typography>\n              {dataPoint.error !== undefined && (\n                <Typography variant=\"body2\">Error: {dataPoint.error.toFixed(2)}</Typography>\n              )}\n            </>\n          ) : (\n            <>\n              <Typography variant=\"body2\">Forecast: {dataPoint.predicted.toFixed(2)}</Typography>\n              {dataPoint.lower !== undefined && dataPoint.upper !== undefined && (\n                <Typography variant=\"body2\">\n                  Confidence: [{dataPoint.lower.toFixed(2)}, {dataPoint.upper.toFixed(2)}]\n                </Typography>\n              )}\n            </>\n          )}\n        </Paper>\n      );\n    }, []);\n\n    // Custom tooltip for feature comparison\n    const renderFeatureComparisonTooltip: TooltipRenderer<FeatureComparisonDataPoint> = useCallback(\n      dataPoint => {\n        return (\n          <Paper sx={{ p: 1 }}>\n            <Typography variant=\"subtitle2\">\n              {selectedFeature}: {dataPoint.featureValue.toFixed(2)}\n            </Typography>\n            <Typography variant=\"body2\">Actual: {dataPoint.actual.toFixed(2)}</Typography>\n            <Typography variant=\"body2\">Predicted: {dataPoint.predicted.toFixed(2)}</Typography>\n            {dataPoint.error !== undefined && (\n              <Typography variant=\"body2\">Error: {dataPoint.error.toFixed(2)}</Typography>\n            )}\n          </Paper>\n        );\n      },\n      [selectedFeature]\n    );\n\n    // Create tooltip components using the adapter\n    const TimeSeriesToolTipComponent = useMemo(\n      () => createTooltipComponent(renderTimeSeriesToolTip),\n      [renderTimeSeriesToolTip]\n    );\n\n    const FeatureComparisonTooltipComponent = useMemo(\n      () => createTooltipComponent(renderFeatureComparisonTooltip),\n      [renderFeatureComparisonTooltip]\n    );\n\n    const metrics = useMemo(\n      () => (\n        <TableContainer component={Paper} sx={{ mb: 2 }}>\n          <Table size=\"small\">\n            <TableHead>\n              <TableRow>\n                <TableCell>Metric</TableCell>\n                <TableCell align=\"right\">Value</TableCell>\n                <TableCell>Description</TableCell>\n              </TableRow>\n            </TableHead>\n            <TableBody>\n              <TableRow>\n                <TableCell>MSE</TableCell>\n                <TableCell align=\"right\">{data?.metrics.mse.toFixed(4)}</TableCell>\n                <TableCell>Mean Squared Error</TableCell>\n              </TableRow>\n              <TableRow>\n                <TableCell>RMSE</TableCell>\n                <TableCell align=\"right\">{data?.metrics.rmse.toFixed(4)}</TableCell>\n                <TableCell>Root Mean Squared Error</TableCell>\n              </TableRow>\n              <TableRow>\n                <TableCell>MAE</TableCell>\n                <TableCell align=\"right\">{data?.metrics.mae.toFixed(4)}</TableCell>\n                <TableCell>Mean Absolute Error</TableCell>\n              </TableRow>\n              {data?.metrics.r2 !== undefined && (\n                <TableRow>\n                  <TableCell>RÂ²</TableCell>\n                  <TableCell align=\"right\">{data?.metrics.r2.toFixed(4)}</TableCell>\n                  <TableCell>Coefficient of Determination</TableCell>\n                </TableRow>\n              )}\n            </TableBody>\n          </Table>\n        </TableContainer>\n      ),\n      [data?.metrics]\n    );\n\n    // Determine if we should use virtualized rendering based on dataset size\n    const useVirtualized = useMemo(() => {\n      return timeSeriesData.length > 500; // Use virtualized rendering for large datasets\n    }, [timeSeriesData.length]);\n\n    // Convert time series data to the format expected by VirtualizedLineChart\n    const virtualizedChartData = useMemo(() => {\n      return timeSeriesData.map(point => ({\n        ...point,\n        // Add any additional required properties to make it compatible with ChartDataRecord\n      }));\n    }, [timeSeriesData]);\n\n    // Create a VirtualizedLineChart config\n    const virtualizedTimeSeriesChart = useMemo(\n      () => (\n        <VirtualizedLineChart\n          data={virtualizedChartData}\n          xAxisKey=\"timestamp\"\n          yAxisKeys={['actual', 'predicted']}\n          width=\"100%\"\n          height={300}\n          dateFormat={true}\n          customTooltip={TimeSeriesToolTipComponent}\n          connectNulls={true}\n          showGrid={true}\n          fillArea={false}\n          strokeWidth={2}\n          showDots={timeSeriesData.length < 100}\n          colors={[colorScale('0'), colorScale('1')]}\n          referenceLines={\n            forecastStartTimestamp\n              ? [\n                  {\n                    value: forecastStartTimestamp,\n                    label: 'Forecast Start',\n                    color: colorScale('3'),\n                    position: 'insideTopRight',\n                    axis: 'x',\n                  },\n                ]\n              : []\n          }\n          maxDisplayedPoints={1000}\n          enableProgressiveLoading={true}\n          subtitle={\n            timeSeriesData.length > 1000\n              ? `Large dataset optimized with intelligent downsampling`\n              : undefined\n          }\n        />\n      ),\n      [timeSeriesData, TimeSeriesToolTipComponent, forecastStartTimestamp, virtualizedChartData]\n    );\n\n    const timeSeriesChart = useMemo(() => {\n      // Use our virtualized line chart for large datasets\n      if (useVirtualized) {\n        return virtualizedTimeSeriesChart;\n      }\n\n      // Otherwise use the standard Recharts implementation\n      return (\n        <ResponsiveContainer width=\"100%\" height={300}>\n          <LineChart data={timeSeriesData} margin={{ top: 20, right: 30, left: 20, bottom: 10 }}>\n            <CartesianGrid strokeDasharray=\"3 3\" />\n            <XAxis\n              dataKey=\"timestamp\"\n              scale=\"time\"\n              type=\"number\"\n              domain={['dataMin', 'dataMax']}\n              tickFormatter={timestamp => new Date(timestamp).toLocaleDateString()}\n            />\n            <YAxis />\n            <Tooltip content={TimeSeriesToolTipComponent} />\n            <Legend />\n\n            {/* Historical data */}\n            <Line\n              type=\"monotone\"\n              name=\"Actual\"\n              dataKey=\"actual\"\n              stroke={colorScale('0')}\n              dot={{ r: 4 }}\n              activeDot={{ r: 6 }}\n              isAnimationActive={false}\n              connectNulls\n            />\n            <Line\n              type=\"monotone\"\n              name=\"Predicted\"\n              dataKey=\"predicted\"\n              stroke={colorScale('1')}\n              strokeDasharray=\"5 5\"\n              dot={{ r: 4 }}\n              isAnimationActive={false}\n              connectNulls\n            />\n\n            {/* Forecast confidence interval */}\n            {timeSeriesData.some(d => d.lower !== undefined) && forecastStartTimestamp && (\n              <ReferenceArea\n                x1={forecastStartTimestamp}\n                x2={timeSeriesData[timeSeriesData.length - 1].timestamp}\n                fill={colorScale('1')}\n                fillOpacity={0.1}\n                ifOverflow=\"extendDomain\"\n              />\n            )}\n\n            {/* Divider between historical and forecast */}\n            {forecastStartTimestamp && (\n              <ReferenceLine\n                x={forecastStartTimestamp}\n                stroke={colorScale('3')}\n                strokeDasharray=\"3 3\"\n                label={{\n                  value: 'Forecast Start',\n                  position: 'insideTopRight',\n                  fill: colorScale('3'),\n                }}\n              />\n            )}\n          </LineChart>\n        </ResponsiveContainer>\n      );\n    }, [\n      timeSeriesData,\n      TimeSeriesToolTipComponent,\n      forecastStartTimestamp,\n      useVirtualized,\n      virtualizedTimeSeriesChart,\n    ]);\n\n    const featureComparisonChart = useMemo(\n      () => (\n        <>\n          <div className=\"mb-2\">\n            <FormControl fullWidth size=\"small\">\n              <InputLabel>Feature</InputLabel>\n              <Select\n                value={selectedFeature}\n                onChange={handleFeatureChange}\n                label=\"Feature\"\n                displayEmpty\n                disabled={data?.features.length <= 1}\n              >\n                {data?.features.slice(1).map(feature => (\n                  <MenuItem key={feature} value={feature}>\n                    {feature}\n                  </MenuItem>\n                ))}\n              </Select>\n            </FormControl>\n          </div>\n\n          {selectedFeature ? (\n            <ResponsiveContainer width=\"100%\" height={300}>\n              <ScatterChart margin={{ top: 20, right: 30, left: 20, bottom: 10 }}>\n                <CartesianGrid strokeDasharray=\"3 3\" />\n                <XAxis\n                  type=\"number\"\n                  dataKey=\"featureValue\"\n                  name={selectedFeature}\n                  label={{\n                    value: selectedFeature,\n                    position: 'insideBottomRight',\n                    offset: -5,\n                  }}\n                />\n                <YAxis\n                  type=\"number\"\n                  dataKey=\"actual\"\n                  name=\"Value\"\n                  label={{\n                    value: data?.targetVariable,\n                    angle: -90,\n                    position: 'insideLeft',\n                  }}\n                />\n                <ZAxis type=\"number\" range={[60, 60]} />\n                <Tooltip content={FeatureComparisonTooltipComponent} />\n                <Legend />\n                <Scatter\n                  name=\"Actual vs. Feature\"\n                  data={featureComparisonData}\n                  fill={colorScale('0')}\n                />\n\n                {/* Add trend line if using linear regression */}\n                {data?.model === 'linear' &&\n                  data?.modelDetails &&\n                  isLinearRegressionModel(data?.modelDetails) && (\n                    <Line\n                      name=\"Model Trend\"\n                      type=\"monotone\"\n                      dataKey={(point: FeatureComparisonDataPoint) => {\n                        const coefficients = data?.modelDetails as LinearRegressionModelDetails;\n                        const intercept = coefficients.coefficients[0];\n                        const featureCoef =\n                          featureIndex >= 0 ? coefficients.coefficients[featureIndex + 1] : 0;\n\n                        return intercept + featureCoef * point.featureValue;\n                      }}\n                      data={featureComparisonData}\n                      stroke={colorScale('2')}\n                      strokeWidth={2}\n                      dot={false}\n                      activeDot={false}\n                      isAnimationActive={false}\n                    />\n                  )}\n              </ScatterChart>\n            </ResponsiveContainer>\n          ) : (\n            <Typography variant=\"body2\" align=\"center\" sx={{ py: 2 }}>\n              Select a feature to visualize its relationship with the target variable.\n            </Typography>\n          )}\n        </>\n      ),\n      [\n        data?.features,\n        selectedFeature,\n        handleFeatureChange,\n        data?.targetVariable,\n        featureComparisonData,\n        FeatureComparisonTooltipComponent,\n        data?.model,\n        data?.modelDetails,\n        featureIndex,\n      ]\n    );\n\n    const residualPlot = useMemo(\n      () => (\n        <ResponsiveContainer width=\"100%\" height={300}>\n          <ScatterChart margin={{ top: 20, right: 30, left: 20, bottom: 10 }}>\n            <CartesianGrid strokeDasharray=\"3 3\" />\n            <XAxis\n              type=\"number\"\n              dataKey=\"predicted\"\n              name=\"Predicted\"\n              label={{\n                value: 'Predicted Values',\n                position: 'insideBottomRight',\n                offset: -5,\n              }}\n            />\n            <YAxis\n              type=\"number\"\n              dataKey=\"residual\"\n              name=\"Residual\"\n              label={{\n                value: 'Residuals',\n                angle: -90,\n                position: 'insideLeft',\n              }}\n            />\n            <ZAxis type=\"number\" range={[60, 60]} />\n            <Tooltip />\n            <ReferenceLine y={0} stroke=\"#666\" strokeWidth={1} />\n            <Scatter name=\"Residuals\" data={residualData} fill={colorScale('4')} />\n          </ScatterChart>\n        </ResponsiveContainer>\n      ),\n      [residualData]\n    );\n\n    const modelDetails = useMemo(() => {\n      // Use type guards to safely access model-specific properties\n      if (data?.model === 'linear' && isLinearRegressionModel(data?.modelDetails)) {\n        const modelDetails = data?.modelDetails;\n        const intercept = modelDetails.coefficients[0];\n        const featureImportance = modelDetails.featureImportance;\n\n        return (\n          <div>\n            <Typography variant=\"h6\" gutterBottom>\n              Linear Regression Model\n            </Typography>\n\n            <Typography variant=\"subtitle2\" gutterBottom>\n              Model Equation\n            </Typography>\n            <Typography variant=\"body2\" sx={{ mb: 2, fontFamily: 'monospace' }}>\n              {data?.targetVariable} = {intercept.toFixed(4)}\n              {data?.features\n                .slice(1)\n                .map((feature, i) => {\n                  const coef = modelDetails.coefficients[i + 1];\n                  return coef >= 0\n                    ? ` + ${coef.toFixed(4)} Ã— ${feature}`\n                    : ` - ${Math.abs(coef).toFixed(4)} Ã— ${feature}`;\n                })\n                .join('')}\n            </Typography>\n\n            {featureImportance && (\n              <>\n                <Typography variant=\"subtitle2\" gutterBottom>\n                  Feature Importance\n                </Typography>\n                <TableContainer component={Paper} sx={{ mb: 2 }}>\n                  <Table size=\"small\">\n                    <TableHead>\n                      <TableRow>\n                        <TableCell>Feature</TableCell>\n                        <TableCell align=\"right\">Importance</TableCell>\n                      </TableRow>\n                    </TableHead>\n                    <TableBody>\n                      {featureImportance.map(item => (\n                        <TableRow key={item?.feature}>\n                          <TableCell>{item?.feature}</TableCell>\n                          <TableCell align=\"right\">\n                            {(item?.importance * 100).toFixed(2)}%\n                          </TableCell>\n                        </TableRow>\n                      ))}\n                    </TableBody>\n                  </Table>\n                </TableContainer>\n              </>\n            )}\n          </div>\n        );\n      } else if (data?.model === 'neuralNetwork' && isNeuralNetworkModel(data?.modelDetails)) {\n        const modelDetails = data?.modelDetails;\n\n        return (\n          <div>\n            <Typography variant=\"h6\" gutterBottom>\n              Neural Network Model\n            </Typography>\n\n            <Typography variant=\"subtitle2\" gutterBottom>\n              Architecture\n            </Typography>\n            <TableContainer component={Paper} sx={{ mb: 2 }}>\n              <Table size=\"small\">\n                <TableBody>\n                  <TableRow>\n                    <TableCell>Input Features</TableCell>\n                    <TableCell>{data?.features.length - 1}</TableCell>\n                  </TableRow>\n                  <TableRow>\n                    <TableCell>Hidden Layers</TableCell>\n                    <TableCell>1</TableCell>\n                  </TableRow>\n                  <TableRow>\n                    <TableCell>Hidden Units</TableCell>\n                    <TableCell>{modelDetails.architecture.hiddenUnits || 'N/A'}</TableCell>\n                  </TableRow>\n                  <TableRow>\n                    <TableCell>Activation {`(...args: unknown[]) => unknown`}</TableCell>\n                    <TableCell>{modelDetails.architecture.activation || 'ReLU'}</TableCell>\n                  </TableRow>\n                  <TableRow>\n                    <TableCell>Output</TableCell>\n                    <TableCell>1 (Regression)</TableCell>\n                  </TableRow>\n                </TableBody>\n              </Table>\n            </TableContainer>\n\n            <Typography variant=\"subtitle2\" gutterBottom>\n              Training Information\n            </Typography>\n            <TableContainer component={Paper}>\n              <Table size=\"small\">\n                <TableBody>\n                  <TableRow>\n                    <TableCell>Epochs</TableCell>\n                    <TableCell>{modelDetails.training.epochs || 'N/A'}</TableCell>\n                  </TableRow>\n                  <TableRow>\n                    <TableCell>Learning Rate</TableCell>\n                    <TableCell>{modelDetails.training.learningRate || 'N/A'}</TableCell>\n                  </TableRow>\n                  <TableRow>\n                    <TableCell>Batch Size</TableCell>\n                    <TableCell>{modelDetails.training.batchSize || 'N/A'}</TableCell>\n                  </TableRow>\n                </TableBody>\n              </Table>\n            </TableContainer>\n          </div>\n        );\n      }\n\n      return (\n        <Typography variant=\"body2\">\n          Details not available for the {data?.model} model type.\n        </Typography>\n      );\n    }, [data?.model, data?.modelDetails, data?.targetVariable, data?.features]);\n\n    return (\n      <div className=\"h-full w-full overflow-auto\" style={{ width, height }}>\n        {title && (\n          <Typography variant=\"h6\" gutterBottom>\n            {title}\n          </Typography>\n        )}\n\n        <Tabs value={activeTab} onChange={handleTabChange} sx={{ mb: 2 }}>\n          <Tab label=\"Time Series\" />\n          <Tab label=\"Feature Comparison\" />\n          <Tab label=\"Residuals\" />\n          <Tab label=\"Model Details\" />\n        </Tabs>\n\n        {metrics}\n\n        {activeTab === 0 && timeSeriesChart}\n        {activeTab === 1 && featureComparisonChart}\n        {activeTab === 2 && residualPlot}\n        {activeTab === 3 && modelDetails}\n      </div>\n    );\n  }\n);\n\nexport default PredictionVisualization;\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/visualizations/charts/ResourceMappingVisualization.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/visualizations/charts/ScatterPlot.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ReferenceLinePosition' is defined but never used. Allowed unused vars must match /^ignored|^temp/u.","line":25,"column":6,"nodeType":null,"messageId":"unusedVar","endLine":25,"endColumn":27}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useMemo } from 'react';\nimport {\n  CartesianGrid,\n  LabelProps,\n  Legend,\n  ScatterChart as RechartsScatterChart,\n  ReferenceArea,\n  ReferenceLine,\n  Scatter,\n  Tooltip,\n  XAxis,\n  YAxis,\n  ZAxis,\n} from 'recharts';\nimport { DataPoint } from '../../../../types/exploration/DataAnalysisTypes';\nimport {\n  BaseChart,\n  BaseChartProps,\n  DefaultTooltip,\n  formatAxisTick,\n  ReferenceLine as ReferenceLineType,\n} from './BaseChart';\n\n// Define allowed positions for reference line labels\ntype ReferenceLinePosition =\n  | 'top'\n  | 'bottom'\n  | 'left'\n  | 'right'\n  | 'insideTop'\n  | 'insideBottom'\n  | 'insideLeft'\n  | 'insideRight'\n  | 'insideTopRight'\n  | 'insideTopLeft'\n  | 'insideBottomRight'\n  | 'insideBottomLeft'\n  | 'center';\n\n// Define the click event interface\ninterface PointClickEvent {\n  payload: Record<string, unknown>;\n  [key: string]: unknown;\n}\n\nexport interface ScatterPlotProps extends BaseChartProps {\n  /** Key for X-axis values */\n  xAxisKey: string;\n\n  /** Key for Y-axis values */\n  yAxisKey: string;\n\n  /** Optional key for Z-axis values (bubble size) */\n  zAxisKey?: string;\n\n  /** Label for X-axis */\n  xAxisLabel?: string;\n\n  /** Label for Y-axis */\n  yAxisLabel?: string;\n\n  /** Key for point name/label */\n  nameKey?: string;\n\n  /** Whether to show grid lines */\n  showGrid?: boolean;\n\n  /** Point fill color */\n  color?: string;\n\n  /** Size of the points */\n  pointSize?: number;\n\n  /** Minimum for Z-axis size range */\n  zAxisSizeMin?: number;\n\n  /** Maximum for Z-axis size range */\n  zAxisSizeMax?: number;\n\n  /** Optional quadrants to divide the chart */\n  showQuadrants?: boolean;\n\n  /** X-axis value for quadrant division */\n  quadrantXValue?: number;\n\n  /** Y-axis value for quadrant division */\n  quadrantYValue?: number;\n\n  /** Quadrant label configuration */\n  quadrantLabels?: {\n    topRight?: string;\n    topLeft?: string;\n    bottomRight?: string;\n    bottomLeft?: string;\n  };\n\n  /** Whether to show the legends */\n  showLegend?: boolean;\n\n  /** Reference lines to display */\n  referenceLines?: ReferenceLineType[];\n}\n\n/**\n * ScatterPlot component for visualizing correlations between variables\n */\nexport function ScatterPlot({\n  data,\n  xAxisKey,\n  yAxisKey,\n  zAxisKey,\n  width = '100%',\n  height = 400,\n  title,\n  color = '#8884d8',\n  xAxisLabel,\n  yAxisLabel,\n  nameKey,\n  customTooltip,\n  theme = 'light',\n  showGrid = true,\n  pointSize = 10,\n  zAxisSizeMin = 10,\n  zAxisSizeMax = 80,\n  showQuadrants = false,\n  quadrantXValue,\n  quadrantYValue,\n  quadrantLabels = {\n    topRight: 'Top Right',\n    topLeft: 'Top Left',\n    bottomRight: 'Bottom Right',\n    bottomLeft: 'Bottom Left',\n  },\n  showLegend = true,\n  referenceLines = [],\n  className = '',\n  animate = true,\n  onElementClick,\n  errorMessage,\n}: ScatterPlotProps) {\n  // Process data for the chart\n  const processedData = useMemo(() => {\n    if (!data || data?.length === 0) return [];\n\n    return data?.map(item => {\n      let x, y, z, name;\n\n      // Handle DataPoint objects\n      if ('properties' in item && 'metadata' in item) {\n        const dataPoint = item as DataPoint;\n        const properties = { ...dataPoint.properties };\n        const metadata = dataPoint.metadata ?? {};\n\n        // Try to find the required values in properties or metadata\n        x = properties[xAxisKey] !== undefined ? properties[xAxisKey] : metadata[xAxisKey];\n        y = properties[yAxisKey] !== undefined ? properties[yAxisKey] : metadata[yAxisKey];\n        z = zAxisKey\n          ? properties[zAxisKey] !== undefined\n            ? properties[zAxisKey]\n            : metadata[zAxisKey]\n          : undefined;\n\n        name = nameKey\n          ? (properties[nameKey] !== undefined ? properties[nameKey] : metadata[nameKey]) ||\n            dataPoint.name\n          : dataPoint.name;\n\n        // Ensure x and y values are numbers\n        x = typeof x === 'number' ? x : (parseFloat(String(x)) ?? 0);\n        y = typeof y === 'number' ? y : (parseFloat(String(y)) ?? 0);\n        z = z && typeof z === 'number' ? z : z ? parseFloat(String(z)) || pointSize : pointSize;\n\n        return {\n          x,\n          y,\n          z,\n          name,\n          id: dataPoint.id,\n          originalData: dataPoint,\n        };\n      }\n      // Handle regular objects\n      else {\n        const record = item as Record<string, unknown>;\n\n        x = record[xAxisKey];\n        y = record[yAxisKey];\n        z = zAxisKey ? record[zAxisKey] : undefined;\n\n        name = nameKey ? record[nameKey] : undefined;\n\n        // Ensure x and y values are numbers\n        x = typeof x === 'number' ? x : (parseFloat(String(x)) ?? 0);\n        y = typeof y === 'number' ? y : (parseFloat(String(y)) ?? 0);\n        z = z && typeof z === 'number' ? z : z ? parseFloat(String(z)) || pointSize : pointSize;\n\n        return {\n          x,\n          y,\n          z,\n          name: name || `(${x}, ${y})`,\n          originalData: record,\n        };\n      }\n    });\n  }, [data, xAxisKey, yAxisKey, zAxisKey, nameKey, pointSize]);\n\n  // If no data, show error\n  if (!data || data?.length === 0) {\n    return (\n      <BaseChart\n        width={width}\n        height={height}\n        title={title}\n        theme={theme}\n        className={className}\n        errorMessage={errorMessage || 'No data available'}\n      >\n        <RechartsScatterChart data={[]} />\n      </BaseChart>\n    );\n  }\n\n  // Calculate quadrant values if not provided\n  const xValue =\n    quadrantXValue !== undefined\n      ? quadrantXValue\n      : processedData.reduce((sum, item) => sum + item?.x, 0) / processedData.length;\n\n  const yValue =\n    quadrantYValue !== undefined\n      ? quadrantYValue\n      : processedData.reduce((sum, item) => sum + item?.y, 0) / processedData.length;\n\n  // Handle click events\n  const handlePointClick = (event: PointClickEvent) => {\n    if (onElementClick && event && event?.payload) {\n      onElementClick(event?.payload, 0);\n    }\n  };\n\n  // Create the chart content\n  const chartContent = (\n    <RechartsScatterChart margin={{ top: 20, right: 20, bottom: 20, left: 20 }}>\n      {showGrid && <CartesianGrid strokeDasharray=\"3 3\" />}\n\n      <XAxis\n        type=\"number\"\n        dataKey=\"x\"\n        name={xAxisLabel || xAxisKey}\n        label={\n          xAxisLabel ? { value: xAxisLabel, position: 'insideBottom', offset: -10 } : undefined\n        }\n        tickFormatter={value => formatAxisTick(value, false)}\n      />\n\n      <YAxis\n        type=\"number\"\n        dataKey=\"y\"\n        name={yAxisLabel || yAxisKey}\n        label={yAxisLabel ? { value: yAxisLabel, angle: -90, position: 'insideLeft' } : undefined}\n        tickFormatter={value => formatAxisTick(value, false)}\n      />\n\n      {zAxisKey && (\n        <ZAxis type=\"number\" dataKey=\"z\" range={[zAxisSizeMin, zAxisSizeMax]} name={zAxisKey} />\n      )}\n\n      <Tooltip content={customTooltip || <DefaultTooltip />} cursor={{ strokeDasharray: '3 3' }} />\n\n      {showLegend && <Legend />}\n\n      {/* Reference lines for thresholds or important values */}\n      {referenceLines.map((line, i) => (\n        <ReferenceLine\n          key={`ref-line-${i}`}\n          x={line.axis === 'x' ? line.value : undefined}\n          y={line.axis === 'y' ? line.value : undefined}\n          stroke={line.color || '#ff7300'}\n          label={\n            line.label\n              ? ({\n                  value: line.label,\n                  position: line.position || 'center',\n                } as LabelProps)\n              : undefined\n          }\n        />\n      ))}\n\n      {/* Quadrant reference lines */}\n      {showQuadrants && (\n        <>\n          <ReferenceLine x={xValue} stroke=\"#666\" strokeDasharray=\"3 3\" />\n          <ReferenceLine y={yValue} stroke=\"#666\" strokeDasharray=\"3 3\" />\n\n          {/* Quadrant labels */}\n          {quadrantLabels.topRight && (\n            <ReferenceArea\n              x1={xValue}\n              x2=\"auto\"\n              y1={yValue}\n              y2=\"auto\"\n              fillOpacity={0}\n              label={{ value: quadrantLabels.topRight, position: 'insideTopRight' }}\n            />\n          )}\n\n          {quadrantLabels.topLeft && (\n            <ReferenceArea\n              x1={0}\n              x2={xValue}\n              y1={yValue}\n              y2=\"auto\"\n              fillOpacity={0}\n              label={{ value: quadrantLabels.topLeft, position: 'insideTopLeft' }}\n            />\n          )}\n\n          {quadrantLabels.bottomRight && (\n            <ReferenceArea\n              x1={xValue}\n              x2=\"auto\"\n              y1={0}\n              y2={yValue}\n              fillOpacity={0}\n              label={{ value: quadrantLabels.bottomRight, position: 'insideBottomRight' }}\n            />\n          )}\n\n          {quadrantLabels.bottomLeft && (\n            <ReferenceArea\n              x1={0}\n              x2={xValue}\n              y1={0}\n              y2={yValue}\n              fillOpacity={0}\n              label={{ value: quadrantLabels.bottomLeft, position: 'insideBottomLeft' }}\n            />\n          )}\n        </>\n      )}\n\n      <Scatter\n        name={`${xAxisLabel || xAxisKey} vs ${yAxisLabel || yAxisKey}`}\n        data={processedData}\n        fill={color}\n        onClick={(e: PointClickEvent) => handlePointClick(e)}\n        isAnimationActive={animate}\n      />\n    </RechartsScatterChart>\n  );\n\n  return (\n    <BaseChart\n      width={width}\n      height={height}\n      title={title}\n      theme={theme}\n      className={className}\n      errorMessage={errorMessage}\n    >\n      {chartContent}\n    </BaseChart>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/visualizations/charts/TooltipAdapter.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/visualizations/charts/ViewportOptimizedHeatMap.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/visualizations/charts/ViewportOptimizedScatterPlot.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/visualizations/charts/VirtualizedLineChart.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/visualizations/charts/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/exploration/visualizations/withMemoryManagement.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'cacheExpirationTime' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":55,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":55,"endColumn":26},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":68,"column":9,"nodeType":"MemberExpression","messageId":"limited","endLine":68,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[1848,1985],"text":""},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ComponentType, useEffect, useState } from 'react';\nimport { BaseChartProps } from './charts/BaseChart';\n\n/**\n * Options for memory management behavior\n */\ninterface MemoryOptions {\n  /** Show memory usage statistics */\n  showMemoryStats?: boolean;\n\n  /** Memory threshold in bytes */\n  memoryThreshold?: number;\n\n  /** Whether to log memory usage to console */\n  enableLogging?: boolean;\n\n  /** Auto cleanup level, controlling aggressiveness of cleanup */\n  autoCleanupLevel?: 'none' | 'low' | 'medium' | 'high';\n\n  /** Time in milliseconds for cache expiration */\n  cacheExpirationTime?: number;\n}\n\n/**\n * Simple function to estimate data size\n */\nfunction estimateSize(data: unknown): number {\n  if (data === null || data === undefined) return 0;\n\n  if (Array.isArray(data)) {\n    return data?.length * 1024; // Estimate 1KB per array item\n  }\n\n  if (typeof data === 'object') {\n    return Object.keys(data).length * 1024; // Estimate 1KB per object property\n  }\n\n  return 1024; // Default size for primitives\n}\n\n/**\n * Higher-order component that adds memory management to visualization components\n */\nexport function withMemoryManagement<P extends BaseChartProps>(\n  WrappedComponent: ComponentType<P>,\n  options: MemoryOptions = {}\n): ComponentType<P> {\n  const ManagedComponent = (props: P) => {\n    // Default options\n    const {\n      showMemoryStats = false,\n      memoryThreshold = 50 * 1024 * 1024,\n      enableLogging = false,\n      autoCleanupLevel = 'medium',\n      cacheExpirationTime = 5 * 60 * 1000,\n    } = options;\n\n    // Track memory usage\n    const [memoryUsage, setMemoryUsage] = useState<number>(0);\n\n    // Update memory usage when props change\n    useEffect(() => {\n      const size = estimateSize(props?.data);\n      setMemoryUsage(size);\n\n      // Log memory usage if enabled\n      if (enableLogging) {\n        console.log(\n          `[MemoryManager] Memory usage: ${Math.round(size / 1024 / 1024)}MB, Cleanup level: ${autoCleanupLevel}`\n        );\n      }\n    }, [props?.data, enableLogging, autoCleanupLevel]);\n\n    // Calculate memory usage in MB for display\n    const memoryMB = Math.round(memoryUsage / 1024 / 1024);\n\n    // Check if memory usage exceeds threshold\n    const isAboveThreshold = memoryUsage > memoryThreshold;\n\n    return (\n      <div style={{ position: 'relative', width: '100%', height: '100%' }}>\n        <WrappedComponent {...props} />\n\n        {showMemoryStats && (\n          <div\n            style={{\n              position: 'absolute',\n              bottom: 5,\n              right: 5,\n              fontSize: '0.75rem',\n              opacity: 0.7,\n              backgroundColor: isAboveThreshold ? 'rgba(255,200,200,0.8)' : 'rgba(200,200,200,0.8)',\n              padding: '2px 5px',\n              borderRadius: '3px',\n            }}\n          >\n            Memory: {memoryMB}MB\n          </div>\n        )}\n      </div>\n    );\n  };\n\n  // Set display name for better debugging\n  const wrappedName = WrappedComponent.displayName || WrappedComponent.name || 'Component';\n  ManagedComponent.displayName = `WithMemory(${wrappedName})`;\n\n  return ManagedComponent;\n}\n\nexport default withMemoryManagement;\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/factions/FactionAI.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/factions/FactionManager.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/performance/DeviceCapabilityReport.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/performance/GeographicAnalysisDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/performance/LongSessionMemoryVisualizer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/performance/MultitabPerformanceLauncher.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/performance/MultitabPerformanceResults.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_onReportGenerated' is defined but never used.","line":19,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":19,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Badge, Card, Col, Divider, Empty, Row, Statistic, Table, Tag, Typography } from 'antd';\nimport React from 'react';\nimport { MultitabPerformanceResult } from '../../tests/performance/MultitabPerformanceTestSuite';\n\nconst { Title, Text } = Typography;\n\n// Define the ResultSet type to match the page component\ntype ResultSet = MultitabPerformanceResult[] | Record<string, MultitabPerformanceResult[]>;\n\ninterface MultitabPerformanceResultsProps {\n  results: ResultSet;\n  isRunning?: boolean;\n  _onReportGenerated?: (report: string) => void;\n}\n\nexport const MultitabPerformanceResults: React.FC<MultitabPerformanceResultsProps> = ({\n  results,\n  isRunning = false,\n  _onReportGenerated,\n}) => {\n  // Normalize results to always work with an array\n  const resultsArray = Array.isArray(results) ? results : Object.values(results).flat();\n\n  // Calculate aggregate metrics\n  const calculateAverages = () => {\n    if (resultsArray.length === 0) return null;\n\n    const avgMemory =\n      resultsArray.reduce((sum, result) => sum + result.memory.average, 0) / resultsArray.length;\n    const avgCPU =\n      resultsArray.reduce((sum, result) => sum + result.cpu.average, 0) / resultsArray.length;\n    const avgFPS =\n      resultsArray.reduce((sum, result) => {\n        // Some tabs might not have FPS data\n        return sum + (result.fps?.average || 0);\n      }, 0) / resultsArray.length;\n\n    const maxMemory = Math.max(...resultsArray.map(r => r.memory.max));\n    const maxCPU = Math.max(...resultsArray.map(r => r.cpu.max));\n\n    return {\n      avgMemory,\n      avgCPU,\n      avgFPS,\n      maxMemory,\n      maxCPU,\n    };\n  };\n\n  const avgMetrics = calculateAverages();\n\n  const getPerformanceRating = () => {\n    if (!avgMetrics) return 'Unknown';\n\n    // Simple rating based on CPU and memory usage\n    const memoryScore = avgMetrics.avgMemory < 100 ? 3 : avgMetrics.avgMemory < 200 ? 2 : 1;\n\n    const cpuScore = avgMetrics.avgCPU < 15 ? 3 : avgMetrics.avgCPU < 30 ? 2 : 1;\n\n    const fpsScore = avgMetrics.avgFPS > 55 ? 3 : avgMetrics.avgFPS > 30 ? 2 : 1;\n\n    const totalScore = memoryScore + cpuScore + fpsScore;\n\n    if (totalScore >= 8) return 'Excellent';\n    if (totalScore >= 6) return 'Good';\n    if (totalScore >= 4) return 'Fair';\n    return 'Poor';\n  };\n\n  const getRatingColor = () => {\n    const rating = getPerformanceRating();\n    switch (rating) {\n      case 'Excellent':\n        return 'success';\n      case 'Good':\n        return 'processing';\n      case 'Fair':\n        return 'warning';\n      case 'Poor':\n        return 'error';\n      default:\n        return 'default';\n    }\n  };\n\n  const columns = [\n    {\n      title: 'Tab ID',\n      dataIndex: 'tabId',\n      key: 'tabId',\n    },\n    {\n      title: 'Memory (MB)',\n      dataIndex: 'memory',\n      key: 'memory',\n      render: (memory: { average: number; max: number }) => (\n        <span>\n          {memory.average.toFixed(1)}\n          <Text type=\"secondary\" style={{ fontSize: '12px', marginLeft: '4px' }}>\n            (max: {memory.max.toFixed(1)})\n          </Text>\n        </span>\n      ),\n    },\n    {\n      title: 'CPU (%)',\n      dataIndex: 'cpu',\n      key: 'cpu',\n      render: (cpu: { average: number; max: number }) => (\n        <span>\n          {cpu.average.toFixed(1)}\n          <Text type=\"secondary\" style={{ fontSize: '12px', marginLeft: '4px' }}>\n            (max: {cpu.max.toFixed(1)})\n          </Text>\n        </span>\n      ),\n    },\n    {\n      title: 'FPS',\n      dataIndex: 'fps',\n      key: 'fps',\n      render: (fps: { average: number; min: number } | undefined) =>\n        fps ? (\n          <span>\n            {fps.average.toFixed(1)}\n            <Text type=\"secondary\" style={{ fontSize: '12px', marginLeft: '4px' }}>\n              (min: {fps.min.toFixed(1)})\n            </Text>\n          </span>\n        ) : (\n          'N/A'\n        ),\n    },\n    {\n      title: 'Errors',\n      dataIndex: 'errors',\n      key: 'errors',\n      render: (errors: unknown[]) => errors.length,\n    },\n    {\n      title: 'Status',\n      dataIndex: 'status',\n      key: 'status',\n      render: (status: string) => {\n        let color = 'default';\n        if (status === 'completed') color = 'success';\n        else if (status === 'running') color = 'processing';\n        else color = 'error';\n\n        return <Tag color={color}>{status}</Tag>;\n      },\n    },\n  ];\n\n  return (\n    <Card style={{ borderRadius: '8px' }}>\n      <Title level={5}>Multitab Performance Results</Title>\n\n      {resultsArray.length === 0 ? (\n        <Empty\n          description={\n            isRunning\n              ? 'Test is running...'\n              : 'No test results yet. Start a test to see results here.'\n          }\n          style={{ padding: '2rem' }}\n        />\n      ) : (\n        <>\n          <Row justify=\"space-between\" align=\"middle\" style={{ marginBottom: '16px' }}>\n            <Col>\n              <Text strong>Overall Performance</Text>\n            </Col>\n            <Col>\n              <Badge\n                status={\n                  getRatingColor() as 'success' | 'error' | 'default' | 'processing' | 'warning'\n                }\n                text={getPerformanceRating()}\n                style={{ fontSize: '16px' }}\n              />\n            </Col>\n          </Row>\n\n          {avgMetrics && (\n            <>\n              <Row gutter={[16, 16]} style={{ marginBottom: '24px' }}>\n                <Col xs={12} md={4.8}>\n                  <Statistic\n                    title=\"Avg. Memory Usage\"\n                    value={avgMetrics.avgMemory.toFixed(1)}\n                    suffix=\"MB\"\n                  />\n                </Col>\n                <Col xs={12} md={4.8}>\n                  <Statistic\n                    title=\"Avg. CPU Usage\"\n                    value={avgMetrics.avgCPU.toFixed(1)}\n                    suffix=\"%\"\n                  />\n                </Col>\n                <Col xs={12} md={4.8}>\n                  <Statistic title=\"Avg. FPS\" value={avgMetrics.avgFPS.toFixed(1)} />\n                </Col>\n                <Col xs={12} md={4.8}>\n                  <Statistic\n                    title=\"Peak Memory\"\n                    value={avgMetrics.maxMemory.toFixed(1)}\n                    suffix=\"MB\"\n                  />\n                </Col>\n                <Col xs={12} md={4.8}>\n                  <Statistic title=\"Peak CPU\" value={avgMetrics.maxCPU.toFixed(1)} suffix=\"%\" />\n                </Col>\n              </Row>\n              <Divider style={{ margin: '0 0 24px 0' }} />\n            </>\n          )}\n\n          <Table\n            dataSource={resultsArray}\n            columns={columns}\n            rowKey=\"tabId\"\n            size=\"small\"\n            pagination={false}\n          />\n        </>\n      )}\n    </Card>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/providers/ServiceProvider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/FactionShips/FactionDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/FactionShips/equatorHorizon/CelestialArbiter.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/FactionShips/equatorHorizon/EtherealGalleon.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/FactionShips/equatorHorizon/StellarEquinox.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/FactionShips/lostNova/DarkMatterReaper.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/FactionShips/lostNova/EclipseScythe.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/FactionShips/lostNova/NullHunter.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/FactionShips/spaceRats/AsteroidMarauder.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/FactionShips/spaceRats/RatKing.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/FactionShips/spaceRats/RogueNebula.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/base/BaseShip.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_onSpecialAbility' is defined but never used.","line":37,"column":21,"nodeType":null,"messageId":"unusedVar","endLine":37,"endColumn":38}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Crosshair } from 'lucide-react';\nimport { ReactNode, useEffect } from 'react';\nimport { ShipProvider, useShipState } from '../../../contexts/ShipContext';\nimport { BaseEffect } from '../../../effects/types_effects/EffectTypes';\nimport { useShipActions } from '../../../hooks/ships/useShipActions';\nimport { useShipEffects } from '../../../hooks/ships/useShipEffects';\nimport { CommonShipStats } from '../../../types/ships/CommonShipTypes';\nimport { WeaponMount } from '../../../types/weapons/WeaponTypes';\n\ninterface BaseShipProps {\n  id: string;\n  name: string;\n  status: 'engaging' | 'patrolling' | 'retreating' | 'disabled';\n  health: number;\n  maxHealth: number;\n  shield: number;\n  maxShield: number;\n  weapons: WeaponMount[];\n  stats: CommonShipStats;\n  onFire?: (weaponId: string) => void;\n  onEngage?: () => void;\n  onRetreat?: () => void;\n  onSpecialAbility?: () => void;\n  className?: string;\n  children?: ReactNode;\n}\n\n/**\n * BaseShipContent Component\n *\n * Internal component that uses ship state hooks\n */\nfunction BaseShipContent({\n  onFire,\n  onEngage,\n  onRetreat,\n  onSpecialAbility: _onSpecialAbility,\n  className = '',\n  children,\n}: Omit<\n  BaseShipProps,\n  'id' | 'name' | 'status' | 'health' | 'maxHealth' | 'shield' | 'maxShield' | 'weapons' | 'stats'\n>) {\n  const { state } = useShipState();\n  const { fireWeapon } = useShipActions();\n  const { activeEffects, clearExpiredEffects } = useShipEffects();\n\n  // Clear expired effects periodically\n  useEffect(() => {\n    const interval = setInterval(clearExpiredEffects, 1000);\n    return () => clearInterval(interval);\n  }, [clearExpiredEffects]);\n\n  // Handle weapon firing\n  const handleFire = (weaponId: string) => {\n    fireWeapon(weaponId);\n    onFire?.(weaponId);\n  };\n\n  return (\n    <div className={`ship-container relative ${className}`}>\n      {/* Ship Header */}\n      <div className=\"ship-header mb-4\">\n        <h3 className=\"text-lg font-medium text-white\">{state.name}</h3>\n        <div\n          className={`status-badge rounded-full px-2 py-1 text-sm ${\n            state.status === 'engaging'\n              ? 'bg-red-900/50 text-red-400'\n              : state.status === 'patrolling'\n                ? 'bg-green-900/50 text-green-400'\n                : state.status === 'retreating'\n                  ? 'bg-yellow-900/50 text-yellow-400'\n                  : 'bg-gray-700 text-gray-400'\n          }`}\n        >\n          {state.status.charAt(0).toUpperCase() + state.status.slice(1)}\n        </div>\n      </div>\n\n      {/* Health & Shield Bars */}\n      <div className=\"stats-container mb-4\">\n        <div className=\"stat-bar mb-2\">\n          <div className=\"mb-1 text-sm text-gray-400\">Shield</div>\n          <div className=\"h-2 rounded-full bg-gray-700\">\n            <div\n              className=\"h-full rounded-full bg-blue-500 transition-all\"\n              style={{ width: `${(state.shield / state.maxShield) * 100}%` }}\n            />\n          </div>\n          <div className=\"mt-1 text-xs text-gray-500\">\n            {Math.round(state.shield)}/{state.maxShield}\n          </div>\n        </div>\n        <div className=\"stat-bar\">\n          <div className=\"mb-1 text-sm text-gray-400\">Health</div>\n          <div className=\"h-2 rounded-full bg-gray-700\">\n            <div\n              className=\"h-full rounded-full bg-red-500 transition-all\"\n              style={{ width: `${(state.health / state.maxHealth) * 100}%` }}\n            />\n          </div>\n          <div className=\"mt-1 text-xs text-gray-500\">\n            {Math.round(state.health)}/{state.maxHealth}\n          </div>\n        </div>\n      </div>\n\n      {/* Weapon Systems */}\n      <div className=\"weapons-container mb-4 grid grid-cols-2 gap-3\">\n        {state.weapons.map(mount => {\n          if (!mount.currentWeapon) return null;\n\n          return (\n            <div\n              key={mount.id}\n              className={`rounded-lg p-3 ${\n                mount.currentWeapon.state.status === 'ready'\n                  ? 'bg-gray-800/50 hover:bg-gray-700/50'\n                  : 'bg-gray-800/30'\n              }`}\n            >\n              <div className=\"mb-2 flex items-center justify-between\">\n                <div className=\"text-sm font-medium text-white\">\n                  {mount.currentWeapon.config.name}\n                </div>\n                <div\n                  className={`text-xs ${\n                    mount.currentWeapon.state.status === 'ready'\n                      ? 'text-green-400'\n                      : mount.currentWeapon.state.status === 'charging'\n                        ? 'text-yellow-400'\n                        : 'text-red-400'\n                  }`}\n                >\n                  {mount.currentWeapon.state.status}\n                </div>\n              </div>\n              <div className=\"flex items-center justify-between text-xs text-gray-400\">\n                <span>Range: {mount.currentWeapon.state.currentStats.range}ly</span>\n                <span>DMG: {mount.currentWeapon.state.currentStats.damage}</span>\n              </div>\n              <button\n                onClick={() => handleFire(mount.id)}\n                disabled={mount.currentWeapon.state.status !== 'ready'}\n                className={`mt-2 flex w-full items-center justify-center space-x-2 rounded px-3 py-1.5 ${\n                  mount.currentWeapon.state.status === 'ready'\n                    ? 'bg-gray-700 text-white hover:bg-gray-600'\n                    : 'cursor-not-allowed bg-gray-800 text-gray-500'\n                }`}\n              >\n                <Crosshair className=\"h-4 w-4\" />\n                <span>Fire</span>\n              </button>\n            </div>\n          );\n        })}\n      </div>\n\n      {/* Active Effects */}\n      {activeEffects.length > 0 && (\n        <div className=\"active-effects mb-4\">\n          <div className=\"mb-2 text-sm text-gray-400\">Active Effects</div>\n          <div className=\"space-y-2\">\n            {activeEffects.map((effect: BaseEffect) => (\n              <div key={effect.id} className=\"rounded-lg bg-gray-800/50 px-3 py-2 text-sm\">\n                <div className=\"font-medium text-gray-300\">{effect.name}</div>\n                <div className=\"text-xs text-gray-400\">{effect.description}</div>\n              </div>\n            ))}\n          </div>\n        </div>\n      )}\n\n      {/* Status Effects and Custom Content */}\n      <div className=\"custom-content\">{children}</div>\n\n      {/* Action Buttons */}\n      <div className=\"action-buttons-container mt-4 flex gap-2\">\n        {onEngage && (\n          <button\n            onClick={onEngage}\n            disabled={state.status === 'disabled'}\n            className=\"flex-1 rounded-lg bg-red-900/30 px-4 py-2 text-sm font-medium text-red-400 transition-colors hover:bg-red-900/50 disabled:opacity-50\"\n          >\n            Engage\n          </button>\n        )}\n        {onRetreat && (\n          <button\n            onClick={onRetreat}\n            disabled={state.status === 'disabled'}\n            className=\"flex-1 rounded-lg bg-yellow-900/30 px-4 py-2 text-sm font-medium text-yellow-400 transition-colors hover:bg-yellow-900/50 disabled:opacity-50\"\n          >\n            Retreat\n          </button>\n        )}\n      </div>\n    </div>\n  );\n}\n\n/**\n * BaseShip Component\n *\n * Core ship component that provides common functionality for all ship types:\n * - Health and shield display\n * - Weapon mounting and firing\n * - Status effects\n * - Action buttons\n */\nexport function BaseShip(props: BaseShipProps) {\n  const { id, name, status, health, maxHealth, shield, maxShield, weapons, stats, ...rest } = props;\n\n  return (\n    <ShipProvider\n      initialState={{\n        id,\n        name,\n        status,\n        health,\n        maxHealth,\n        shield,\n        maxShield,\n        weapons,\n        stats,\n      }}\n    >\n      <BaseShipContent {...rest} />\n    </ShipProvider>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/common/CommonShipMovement.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/common/CommonShipStats.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/common/EquatorHorizonShip.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/common/FactionFleet.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/common/FactionShipBase.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/common/FactionShipStats.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/common/LostNovaShip.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/common/SpaceRatShip.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/player/adapters/ShipAdapter.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/player/base/PlayerShipBase.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/player/base/PlayerShipStats.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/player/customization/PlayerShipCustomization.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/player/customization/PlayerShipUpgrade.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/player/customization/PlayerShipUpgradeSystem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/player/variants/miningships/VoidDredgerMiner.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/player/variants/reconships/ReconShipControl.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/player/variants/reconships/ReconShipStatus.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/player/variants/warships/HarbringerGalleon.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/player/variants/warships/MidwayCarrier.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/player/variants/warships/MotherEarthRevenge.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/player/variants/warships/OrionFrigate.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_id' is defined but never used.","line":29,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":29,"endColumn":10}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Crosshair, Shield } from 'lucide-react';\n\ninterface OrionFrigateProps {\n  id: string;\n  status: 'idle' | 'engaging' | 'retreating' | 'damaged';\n  hull: number;\n  maxHull: number;\n  shield: number;\n  maxShield: number;\n  weapons: {\n    id: string;\n    name: string;\n    type: 'machineGun' | 'gaussCannon';\n    damage: number;\n    status: 'ready' | 'charging' | 'cooling';\n  }[];\n  specialAbility: {\n    name: string;\n    description: string;\n    active: boolean;\n    cooldown: number;\n  };\n  onFire: (weaponId: string) => void;\n  onActivateAbility: () => void;\n  onRetreat: () => void;\n}\n\nexport function OrionFrigate({\n  id: _id,\n  status,\n  hull,\n  maxHull,\n  shield,\n  maxShield,\n  weapons,\n  specialAbility,\n  onFire,\n  onActivateAbility,\n  onRetreat,\n}: OrionFrigateProps) {\n  return (\n    <div className=\"rounded-lg border border-violet-700/30 bg-violet-900/20 p-6\">\n      {/* Ship Header */}\n      <div className=\"mb-6 flex items-start justify-between\">\n        <div>\n          <h3 className=\"text-lg font-medium text-white\">Orion's Frigate</h3>\n          <div className=\"text-sm text-gray-400\">Tier 2 Combat Frigate</div>\n        </div>\n        <div\n          className={`rounded-full px-3 py-1 text-sm ${\n            status === 'engaging'\n              ? 'bg-red-900/50 text-red-400'\n              : status === 'retreating'\n                ? 'bg-yellow-900/50 text-yellow-400'\n                : status === 'damaged'\n                  ? 'bg-red-900/50 text-red-400'\n                  : 'bg-green-900/50 text-green-400'\n          }`}\n        >\n          {status.charAt(0).toUpperCase() + status.slice(1)}\n        </div>\n      </div>\n\n      {/* Combat Status */}\n      <div className=\"mb-6 grid grid-cols-2 gap-4\">\n        <div>\n          <div className=\"mb-1 flex justify-between text-sm\">\n            <span className=\"text-gray-400\">Hull Integrity</span>\n            <span className={hull < maxHull * 0.3 ? 'text-red-400' : 'text-gray-300'}>\n              {Math.round((hull / maxHull) * 100)}%\n            </span>\n          </div>\n          <div className=\"h-2 overflow-hidden rounded-full bg-gray-700\">\n            <div\n              className={`h-full rounded-full transition-all ${\n                hull < maxHull * 0.3 ? 'bg-red-500' : 'bg-green-500'\n              }`}\n              style={{ width: `${(hull / maxHull) * 100}%` }}\n            />\n          </div>\n        </div>\n\n        <div>\n          <div className=\"mb-1 flex justify-between text-sm\">\n            <span className=\"text-gray-400\">Shield Power</span>\n            <span className=\"text-gray-300\">{Math.round((shield / maxShield) * 100)}%</span>\n          </div>\n          <div className=\"h-2 overflow-hidden rounded-full bg-gray-700\">\n            <div\n              className=\"h-full rounded-full bg-blue-500 transition-all\"\n              style={{ width: `${(shield / maxShield) * 100}%` }}\n            />\n          </div>\n        </div>\n      </div>\n\n      {/* Weapon Systems */}\n      <div className=\"mb-6 space-y-4\">\n        <h4 className=\"text-sm font-medium text-gray-300\">Weapon Systems</h4>\n        <div className=\"grid grid-cols-2 gap-3\">\n          {weapons.map(weapon => (\n            <button\n              key={weapon.id}\n              onClick={() => onFire(weapon.id)}\n              disabled={weapon.status !== 'ready'}\n              className={`rounded-lg p-3 transition-colors ${\n                weapon.status === 'ready'\n                  ? 'border border-violet-500/30 bg-violet-500/20 hover:bg-violet-500/30'\n                  : 'cursor-not-allowed border border-gray-600/30 bg-gray-700/50'\n              }`}\n            >\n              <div className=\"mb-2 flex items-center justify-between\">\n                <div className=\"text-sm font-medium text-white\">{weapon.name}</div>\n                <div\n                  className={`text-xs ${\n                    weapon.status === 'ready'\n                      ? 'text-green-400'\n                      : weapon.status === 'charging'\n                        ? 'text-yellow-400'\n                        : 'text-red-400'\n                  }`}\n                >\n                  {weapon.status.charAt(0).toUpperCase() + weapon.status.slice(1)}\n                </div>\n              </div>\n              <div className=\"text-xs text-gray-400\">Damage: {weapon.damage}</div>\n            </button>\n          ))}\n        </div>\n      </div>\n\n      {/* Special Ability */}\n      <div className=\"mb-6\">\n        <button\n          onClick={onActivateAbility}\n          disabled={specialAbility.active}\n          className={`w-full rounded-lg p-3 text-left transition-colors ${\n            specialAbility.active\n              ? 'border border-violet-500/30 bg-violet-500/20'\n              : 'bg-gray-700/50 hover:bg-gray-600/50'\n          }`}\n        >\n          <div className=\"mb-1 flex items-center justify-between\">\n            <span className=\"text-sm font-medium text-white\">{specialAbility.name}</span>\n            {specialAbility.active ? (\n              <span className=\"text-xs text-green-400\">Active</span>\n            ) : (\n              <span className=\"text-xs text-gray-400\">{specialAbility.cooldown}s</span>\n            )}\n          </div>\n          <p className=\"text-xs text-gray-400\">{specialAbility.description}</p>\n        </button>\n      </div>\n\n      {/* Combat Actions */}\n      <div className=\"grid grid-cols-2 gap-3\">\n        <button\n          onClick={() => onFire(weapons[0].id)}\n          disabled={!weapons.some(w => w.status === 'ready')}\n          className={`flex items-center justify-center space-x-2 rounded-lg px-4 py-2 text-sm ${\n            weapons.some(w => w.status === 'ready')\n              ? 'bg-violet-500/20 text-violet-200 hover:bg-violet-500/30'\n              : 'cursor-not-allowed bg-gray-700 text-gray-500'\n          }`}\n        >\n          <Crosshair className=\"h-4 w-4\" />\n          <span>Fire Weapons</span>\n        </button>\n        <button\n          onClick={onRetreat}\n          disabled={status === 'damaged'}\n          className={`flex items-center justify-center space-x-2 rounded-lg bg-gray-700 px-4 py-2 text-sm hover:bg-gray-600 ${\n            status === 'damaged' ? 'cursor-not-allowed opacity-50' : ''\n          }`}\n        >\n          <Shield className=\"h-4 w-4\" />\n          <span>Retreat</span>\n        </button>\n      </div>\n    </div>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/player/variants/warships/PlayerWarShipCombat.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/player/variants/warships/Spitflare.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_id' is defined but never used.","line":22,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":22,"endColumn":10}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Crosshair, Shield } from 'lucide-react';\n\ninterface SpitflareProps {\n  id: string;\n  status: 'idle' | 'engaging' | 'retreating' | 'damaged';\n  hull: number;\n  maxHull: number;\n  shield: number;\n  maxShield: number;\n  weapons: {\n    id: string;\n    name: string;\n    type: 'machineGun';\n    damage: number;\n    status: 'ready' | 'charging' | 'cooling';\n  }[];\n  onFire: (weaponId: string) => void;\n  onRetreat: () => void;\n}\n\nexport function Spitflare({\n  id: _id,\n  status,\n  hull,\n  maxHull,\n  shield,\n  maxShield,\n  weapons,\n  onFire,\n  onRetreat,\n}: SpitflareProps) {\n  return (\n    <div className=\"rounded-lg border border-cyan-700/30 bg-cyan-900/20 p-6\">\n      {/* Ship Header */}\n      <div className=\"mb-6 flex items-start justify-between\">\n        <div>\n          <h3 className=\"text-lg font-medium text-white\">Spitflare</h3>\n          <div className=\"text-sm text-gray-400\">Tier 1 Light Fighter</div>\n        </div>\n        <div\n          className={`rounded-full px-3 py-1 text-sm ${\n            status === 'engaging'\n              ? 'bg-red-900/50 text-red-400'\n              : status === 'retreating'\n                ? 'bg-yellow-900/50 text-yellow-400'\n                : status === 'damaged'\n                  ? 'bg-red-900/50 text-red-400'\n                  : 'bg-green-900/50 text-green-400'\n          }`}\n        >\n          {status.charAt(0).toUpperCase() + status.slice(1)}\n        </div>\n      </div>\n\n      {/* Combat Status */}\n      <div className=\"mb-6 grid grid-cols-2 gap-4\">\n        <div>\n          <div className=\"mb-1 flex justify-between text-sm\">\n            <span className=\"text-gray-400\">Hull Integrity</span>\n            <span className={hull < maxHull * 0.3 ? 'text-red-400' : 'text-gray-300'}>\n              {Math.round((hull / maxHull) * 100)}%\n            </span>\n          </div>\n          <div className=\"h-2 overflow-hidden rounded-full bg-gray-700\">\n            <div\n              className={`h-full rounded-full transition-all ${\n                hull < maxHull * 0.3 ? 'bg-red-500' : 'bg-green-500'\n              }`}\n              style={{ width: `${(hull / maxHull) * 100}%` }}\n            />\n          </div>\n        </div>\n\n        <div>\n          <div className=\"mb-1 flex justify-between text-sm\">\n            <span className=\"text-gray-400\">Shield Power</span>\n            <span className=\"text-gray-300\">{Math.round((shield / maxShield) * 100)}%</span>\n          </div>\n          <div className=\"h-2 overflow-hidden rounded-full bg-gray-700\">\n            <div\n              className=\"h-full rounded-full bg-blue-500 transition-all\"\n              style={{ width: `${(shield / maxShield) * 100}%` }}\n            />\n          </div>\n        </div>\n      </div>\n\n      {/* Weapon Systems */}\n      <div className=\"mb-6 space-y-4\">\n        <h4 className=\"text-sm font-medium text-gray-300\">Machine Guns</h4>\n        <div className=\"grid grid-cols-2 gap-3\">\n          {weapons.map(weapon => (\n            <button\n              key={weapon.id}\n              onClick={() => onFire(weapon.id)}\n              disabled={weapon.status !== 'ready'}\n              className={`rounded-lg p-3 transition-colors ${\n                weapon.status === 'ready'\n                  ? 'border border-cyan-500/30 bg-cyan-500/20 hover:bg-cyan-500/30'\n                  : 'cursor-not-allowed border border-gray-600/30 bg-gray-700/50'\n              }`}\n            >\n              <div className=\"mb-2 flex items-center justify-between\">\n                <div className=\"text-sm font-medium text-white\">{weapon.name}</div>\n                <div\n                  className={`text-xs ${\n                    weapon.status === 'ready'\n                      ? 'text-green-400'\n                      : weapon.status === 'charging'\n                        ? 'text-yellow-400'\n                        : 'text-red-400'\n                  }`}\n                >\n                  {weapon.status.charAt(0).toUpperCase() + weapon.status.slice(1)}\n                </div>\n              </div>\n              <div className=\"text-xs text-gray-400\">Damage: {weapon.damage}</div>\n            </button>\n          ))}\n        </div>\n      </div>\n\n      {/* Combat Actions */}\n      <div className=\"grid grid-cols-2 gap-3\">\n        <button\n          onClick={() => onFire(weapons[0].id)}\n          disabled={!weapons.some(w => w.status === 'ready')}\n          className={`flex items-center justify-center space-x-2 rounded-lg px-4 py-2 text-sm ${\n            weapons.some(w => w.status === 'ready')\n              ? 'bg-cyan-500/20 text-cyan-200 hover:bg-cyan-500/30'\n              : 'cursor-not-allowed bg-gray-700 text-gray-500'\n          }`}\n        >\n          <Crosshair className=\"h-4 w-4\" />\n          <span>Fire Weapons</span>\n        </button>\n        <button\n          onClick={onRetreat}\n          disabled={status === 'damaged'}\n          className={`flex items-center justify-center space-x-2 rounded-lg bg-gray-700 px-4 py-2 text-sm hover:bg-gray-600 ${\n            status === 'damaged' ? 'cursor-not-allowed opacity-50' : ''\n          }`}\n        >\n          <Shield className=\"h-4 w-4\" />\n          <span>Retreat</span>\n        </button>\n      </div>\n    </div>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/player/variants/warships/StarSchooner.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_id' is defined but never used.","line":23,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":23,"endColumn":10}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Crosshair, Shield } from 'lucide-react';\n\ninterface StarSchoonerProps {\n  id: string;\n  tier: 1 | 2;\n  status: 'idle' | 'engaging' | 'retreating' | 'damaged';\n  hull: number;\n  maxHull: number;\n  shield: number;\n  maxShield: number;\n  weapons: {\n    id: string;\n    name: string;\n    type: 'railGun';\n    damage: number;\n    status: 'ready' | 'charging' | 'cooling';\n  }[];\n  onFire: (weaponId: string) => void;\n  onRetreat: () => void;\n}\n\nexport function StarSchooner({\n  id: _id,\n  tier,\n  status,\n  hull,\n  maxHull,\n  shield,\n  maxShield,\n  weapons,\n  onFire,\n  onRetreat,\n}: StarSchoonerProps) {\n  return (\n    <div className=\"rounded-lg border border-indigo-700/30 bg-indigo-900/20 p-6\">\n      {/* Ship Header */}\n      <div className=\"mb-6 flex items-start justify-between\">\n        <div>\n          <h3 className=\"text-lg font-medium text-white\">Star Schooner</h3>\n          <div className=\"text-sm text-gray-400\">Tier {tier} Rail Gun Vessel</div>\n        </div>\n        <div\n          className={`rounded-full px-3 py-1 text-sm ${\n            status === 'engaging'\n              ? 'bg-red-900/50 text-red-400'\n              : status === 'retreating'\n                ? 'bg-yellow-900/50 text-yellow-400'\n                : status === 'damaged'\n                  ? 'bg-red-900/50 text-red-400'\n                  : 'bg-green-900/50 text-green-400'\n          }`}\n        >\n          {status.charAt(0).toUpperCase() + status.slice(1)}\n        </div>\n      </div>\n\n      {/* Combat Status */}\n      <div className=\"mb-6 grid grid-cols-2 gap-4\">\n        <div>\n          <div className=\"mb-1 flex justify-between text-sm\">\n            <span className=\"text-gray-400\">Hull Integrity</span>\n            <span className={hull < maxHull * 0.3 ? 'text-red-400' : 'text-gray-300'}>\n              {Math.round((hull / maxHull) * 100)}%\n            </span>\n          </div>\n          <div className=\"h-2 overflow-hidden rounded-full bg-gray-700\">\n            <div\n              className={`h-full rounded-full transition-all ${\n                hull < maxHull * 0.3 ? 'bg-red-500' : 'bg-green-500'\n              }`}\n              style={{ width: `${(hull / maxHull) * 100}%` }}\n            />\n          </div>\n        </div>\n\n        <div>\n          <div className=\"mb-1 flex justify-between text-sm\">\n            <span className=\"text-gray-400\">Shield Power</span>\n            <span className=\"text-gray-300\">{Math.round((shield / maxShield) * 100)}%</span>\n          </div>\n          <div className=\"h-2 overflow-hidden rounded-full bg-gray-700\">\n            <div\n              className=\"h-full rounded-full bg-blue-500 transition-all\"\n              style={{ width: `${(shield / maxShield) * 100}%` }}\n            />\n          </div>\n        </div>\n      </div>\n\n      {/* Weapon Systems */}\n      <div className=\"mb-6 space-y-4\">\n        <h4 className=\"text-sm font-medium text-gray-300\">Rail Gun System</h4>\n        <div className=\"grid grid-cols-2 gap-3\">\n          {weapons.map(weapon => (\n            <button\n              key={weapon.id}\n              onClick={() => onFire(weapon.id)}\n              disabled={weapon.status !== 'ready'}\n              className={`rounded-lg p-3 transition-colors ${\n                weapon.status === 'ready'\n                  ? 'border border-indigo-500/30 bg-indigo-500/20 hover:bg-indigo-500/30'\n                  : 'cursor-not-allowed border border-gray-600/30 bg-gray-700/50'\n              }`}\n            >\n              <div className=\"mb-2 flex items-center justify-between\">\n                <div className=\"text-sm font-medium text-white\">{weapon.name}</div>\n                <div\n                  className={`text-xs ${\n                    weapon.status === 'ready'\n                      ? 'text-green-400'\n                      : weapon.status === 'charging'\n                        ? 'text-yellow-400'\n                        : 'text-red-400'\n                  }`}\n                >\n                  {weapon.status.charAt(0).toUpperCase() + weapon.status.slice(1)}\n                </div>\n              </div>\n              <div className=\"text-xs text-gray-400\">Damage: {weapon.damage}</div>\n            </button>\n          ))}\n        </div>\n      </div>\n\n      {/* Combat Actions */}\n      <div className=\"grid grid-cols-2 gap-3\">\n        <button\n          onClick={() => onFire(weapons[0].id)}\n          disabled={!weapons.some(w => w.status === 'ready')}\n          className={`flex items-center justify-center space-x-2 rounded-lg px-4 py-2 text-sm ${\n            weapons.some(w => w.status === 'ready')\n              ? 'bg-indigo-500/20 text-indigo-200 hover:bg-indigo-500/30'\n              : 'cursor-not-allowed bg-gray-700 text-gray-500'\n          }`}\n        >\n          <Crosshair className=\"h-4 w-4\" />\n          <span>Fire Rail Gun</span>\n        </button>\n        <button\n          onClick={onRetreat}\n          disabled={status === 'damaged'}\n          className={`flex items-center justify-center space-x-2 rounded-lg bg-gray-700 px-4 py-2 text-sm hover:bg-gray-600 ${\n            status === 'damaged' ? 'cursor-not-allowed opacity-50' : ''\n          }`}\n        >\n          <Shield className=\"h-4 w-4\" />\n          <span>Retreat</span>\n        </button>\n      </div>\n    </div>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ships/player/variants/warships/WarShip.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/trade/TradeRouteVisualizer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/Button.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/Card.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/ContextMenu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/DiplomacyPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/DragAndDrop.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/GalaxyMap.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/GameHUD.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'uuidv4' is defined but never used. Allowed unused vars must match /^ignored|^temp/u.","line":14,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'moduleManager' is defined but never used. Allowed unused vars must match /^ignored|^temp/u.","line":19,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":19,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_createNotification' is defined but never used. Allowed unused vars must match /^ignored|^temp/u.","line":88,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":88,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'setActiveMenu' is assigned a value but never used. Allowed unused elements of array destructuring must match /^_/u.","line":148,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":148,"endColumn":35},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'tooltipInfo' is assigned a value but never used. Allowed unused elements of array destructuring must match /^_/u.","line":153,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":153,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'setTooltipInfo' is assigned a value but never used. Allowed unused elements of array destructuring must match /^_/u.","line":153,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":153,"endColumn":37},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'techTreeLoading' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":157,"column":50,"nodeType":null,"messageId":"unusedVar","endLine":157,"endColumn":65},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'settingsLoading' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":174,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":174,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_formatTooltip' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":398,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":398,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  AlertTriangle,\n  Crown,\n  Database,\n  Info,\n  Map as MapIcon,\n  Rocket,\n  Settings,\n  Terminal,\n  X,\n} from 'lucide-react';\nimport * as React from 'react';\nimport { useCallback, useEffect, useMemo, useState } from 'react';\nimport { v4 as uuidv4 } from 'uuid';\nimport { GameActionType, useGameDispatch, useGameState } from '../../contexts/GameContext';\nimport { ModuleActionType, useModuleDispatch, useModules } from '../../contexts/ModuleContext';\nimport { useVPRSystem } from '../../hooks/ui/useVPRSystem';\nimport { moduleEventBus } from '../../lib/modules/ModuleEvents';\nimport { moduleManager } from '../../managers/module/ModuleManager';\nimport { ModuleType } from '../../types/buildings/ModuleTypes';\nimport { Position } from '../../types/core/GameTypes';\nimport { Module, ModuleStatus } from '../../types/modules/ModuleTypes';\nimport { ResourceType } from './../../types/resources/ResourceTypes';\nimport { NotificationSystem, notificationManager } from './NotificationSystem';\nimport ResourceVisualization from './ResourceVisualization';\nimport { useLazyComponent, useRenderPerformance } from '../../utils/performance/ComponentOptimizer';\n\n// Temporary Settings Panel component\nconst _SettingsPanel = () => (\n  <div className=\"p-4 bg-gray-900 border border-gray-800 rounded-lg\">\n    <h2 className=\"text-xl font-bold mb-4\">Settings</h2>\n    <p className=\"text-gray-400 mb-4\">Game settings will be implemented here.</p>\n  </div>\n);\n\ninterface GameHUDProps {\n  empireName: string;\n  onToggleSprawlView: () => void;\n  onToggleVPRView: () => void;\n}\n\ntype MenuCategory = 'mining' | 'exploration' | 'mothership' | 'colony';\n\ninterface MenuItem {\n  id: string;\n  name: string;\n  description: string;\n  action: () => void;\n  moduleType?: ModuleType;\n  cost?: {\n    minerals?: number;\n    energy?: number;\n  };\n}\n\n/**\n * Custom notification interface for future implementation\n *\n * This interface will be used in future implementations to:\n * 1. Create a custom notification system with more advanced features\n * 2. Support different notification types beyond the current system\n * 3. Enable notification grouping and prioritization\n * 4. Add interactive elements to notifications\n * 5. Support notification persistence and history\n *\n * @deprecated This interface is not currently used but will be implemented\n * in the upcoming notification system upgrade. It is kept here for reference.\n */\ninterface _Notification {\n  id: string;\n  type: 'success' | 'error';\n  message: string;\n}\n\n// Use the _Notification interface in a function to prevent \"unused\" error\n/**\n * Creates a notification object using the _Notification interface.\n * This function will be used in the future notification system upgrade.\n *\n * @param type - The type of notification ('success' or 'error')\n * @param message - The notification message\n * @returns A notification object conforming to the _Notification interface\n * @deprecated This function is not currently used but will be implemented\n * in the upcoming notification system upgrade. It is kept here for reference.\n */\n\n// Prefixed with underscore to indicate it's intentionally unused\nfunction _createNotification(type: 'success' | 'error', message: string): _Notification {\n  return {\n    id: `notification-${Date.now()}`,\n    type,\n    message,\n  };\n}\n\n// Category color mapping\nconst categoryColors: Record<MenuCategory, { bg: string; border: string; hover: string }> = {\n  mining: {\n    bg: 'from-amber-900/90 to-amber-800/80',\n    border: 'border-amber-700/50',\n    hover: 'hover:bg-amber-800/50 hover:border-amber-600/50',\n  },\n  exploration: {\n    bg: 'from-blue-900/90 to-blue-800/80',\n    border: 'border-blue-700/50',\n    hover: 'hover:bg-blue-800/50 hover:border-blue-600/50',\n  },\n  mothership: {\n    bg: 'from-indigo-900/90 to-indigo-800/80',\n    border: 'border-indigo-700/50',\n    hover: 'hover:bg-indigo-800/50 hover:border-indigo-600/50',\n  },\n  colony: {\n    bg: 'from-green-900/90 to-green-800/80',\n    border: 'border-green-700/50',\n    hover: 'hover:bg-green-800/50 hover:border-green-600/50',\n  },\n};\n\n// Category icons\nconst categoryIcons: Record<MenuCategory, React.ReactNode> = {\n  mining: <Database size={18} />,\n  exploration: <MapIcon size={18} />,\n  mothership: <Rocket size={18} />,\n  colony: <Crown size={18} />,\n};\n\n/**\n * GameHUD component for displaying game interface\n * @context: ui-system, game-hud, performance-optimization\n */\nexport function GameHUD({ empireName, onToggleSprawlView, onToggleVPRView }: GameHUDProps) {\n  // Track render performance in development\n  useRenderPerformance('GameHUD');\n  \n  // Game state\n  const gameState = useGameState(state => state);\n  const gameDispatch = useGameDispatch();\n  \n  // Module state\n  const modules = useModules(state => state);\n  const moduleDispatch = useModuleDispatch();\n  \n  // VPR state\n  const vprSystem = useVPRSystem();\n  \n  // Local state\n  const [activeMenu, setActiveMenu] = useState<MenuCategory | null>(null);\n  const [activeCategory, setActiveCategory] = useState<MenuCategory | null>(null);\n  const [showTechTree, setShowTechTree] = useState(false);\n  const [showSettings, setShowSettings] = useState(false);\n  const [sidebarCollapsed, setSidebarCollapsed] = useState(false);\n  const [tooltipInfo, setTooltipInfo] = useState<{ text: string; position: Position } | null>(null);\n  const [showTooltip, setShowTooltip] = useState<{ id: string; x: number; y: number } | null>(null);\n  \n  // Lazy load heavy components to improve initial load time\n  const { Component: TechTreeComponent, loading: techTreeLoading } = useLazyComponent<{\n    visible: boolean;\n    onClose: () => void;\n  }>(\n    () => import('./TechTree'),\n    [showTechTree]\n  );\n  \n  const { Component: ResourceVisualizationComponent, loading: resourceVisLoading } = useLazyComponent<{\n    type: ResourceType;\n    value: number;\n  }>(\n    () => import('./ResourceVisualization'),\n    []\n  );\n  \n  // Using direct import for SettingsPanel since we have the component defined above\n  const settingsLoading = false;\n  \n  // Define simple type here to avoid import issues\n  type MiniMapStarStatus = 'locked' | 'unlocked' | 'colonized' | 'hostile';\n  \n  const { Component: MiniMapComponent, loading: miniMapLoading } = useLazyComponent<{\n    stars: Array<{id: string; name: string; position: Position; status: MiniMapStarStatus}>;\n    viewport: {position: Position; zoom: number; width: number; height: number};\n  }>(\n    () => import('./game/MiniMap').then(module => ({ \n      default: (props: {\n        stars: Array<{id: string; name: string; position: Position; status: MiniMapStarStatus}>;\n        viewport: {position: Position; zoom: number; width: number; height: number};\n      }) => <module.MiniMap {...props} /> \n    })),\n    []\n  );\n\n  // Add keyboard shortcut handling\n  const handleKeyDown = useCallback((event: KeyboardEvent) => {\n    // Function keys for special actions\n    if (event.key === 'F1') {\n      event.preventDefault();\n      setShowTechTree(prev => !prev);\n    } else if (event.key === 'F2') {\n      event.preventDefault();\n      setShowSettings(prev => !prev);\n    } else if (event.key === 'Escape') {\n      if (showTechTree) {\n        setShowTechTree(false);\n      } else if (showSettings) {\n        setShowSettings(false);\n      } else if (activeCategory) {\n        setActiveCategory(null);\n      }\n    }\n\n    // Alt + key combinations for menu categories\n    if (event.altKey) {\n      if (event.key === 'm') {\n        event.preventDefault();\n        setActiveCategory('mining');\n      } else if (event.key === 'e') {\n        event.preventDefault();\n        setActiveCategory('exploration');\n      } else if (event.key === 's') {\n        event.preventDefault();\n        setActiveCategory('mothership');\n      } else if (event.key === 'c') {\n        event.preventDefault();\n        setActiveCategory('colony');\n      }\n    }\n  }, [activeCategory, showSettings, showTechTree]);\n\n  // Set up keyboard shortcuts\n  useEffect(() => {\n    window.addEventListener('keydown', handleKeyDown);\n    return () => {\n      window.removeEventListener('keydown', handleKeyDown);\n    };\n  }, [handleKeyDown]);\n\n  // Toggle sidebar collapsed state\n  const toggleSidebar = useCallback(() => {\n    setSidebarCollapsed(prev => !prev);\n  }, []);\n  \n  // Ensure contexts are available\n  if (!gameState || !modules) {\n    return null;\n  }\n\n  // Check if a module can be built based on resources and available attachment points\n  const canBuildModule = (\n    moduleType: ModuleType,\n    cost: { minerals?: number; energy?: number }\n  ): boolean => {\n    console.warn('Checking if can build module:', moduleType, cost);\n\n    // Check resources\n    const hasResources =\n      (cost.minerals ?? 0) <= gameState.resources.minerals &&\n      (cost.energy ?? 0) <= gameState.resources.energy;\n\n    if (!hasResources) {\n      console.warn('Not enough resources to build module');\n      return false;\n    }\n\n    // Find a suitable building and attachment point\n    for (const building of modules.buildings) {\n      for (const point of building.attachmentPoints) {\n        if (point.allowedTypes.includes(moduleType) && !point.currentModule) {\n          console.warn('Found suitable attachment point for module');\n          return true;\n        }\n      }\n    }\n\n    console.warn('No suitable attachment point found for module');\n    return false;\n  };\n\n  // Build a module\n  const buildModuleLocally = (\n    moduleType: ModuleType,\n    cost: { minerals?: number; energy?: number }\n  ): boolean => {\n    const existingModules = Object.values(modules.modules);\n    const totalModulesOfType = existingModules.filter(m => m.type === moduleType).length;\n\n    // Set module ID with a counter for easy identification\n    const moduleId = `${moduleType.toLowerCase()}_${totalModulesOfType + 1}_${Date.now()}`;\n\n    // Find a building to attach to\n    let buildingId: string | null = null;\n    let attachmentPointId: string | null = null;\n\n    buildingLoop: for (const building of modules.buildings) {\n      for (const point of building.attachmentPoints) {\n        if (point.allowedTypes.includes(moduleType) && !point.currentModule) {\n          buildingId = building.id;\n          attachmentPointId = point.id;\n          break buildingLoop;\n        }\n      }\n    }\n\n    if (!buildingId || !attachmentPointId) {\n      console.error('No suitable attachment point found for module', moduleType);\n      return false;\n    }\n\n    // Create the module\n    const module: Module = {\n      id: moduleId,\n      name: `${moduleType} Module ${totalModulesOfType + 1}`,\n      type: moduleType,\n      status: ModuleStatus.ACTIVE,\n      buildingId,\n      attachmentPointId,\n      position: { x: 0, y: 0 }, // Default position, will be updated based on attachment point\n      isActive: true,\n      level: 1\n    };\n\n    // Update game state for minerals\n    if (cost.minerals) {\n      gameDispatch({\n        type: GameActionType.UPDATE_RESOURCES,\n        payload: {\n          minerals: gameState.resources.minerals - cost.minerals,\n        },\n      });\n    }\n\n    // Update game state for energy\n    if (cost.energy) {\n      gameDispatch({\n        type: GameActionType.UPDATE_RESOURCES,\n        payload: {\n          energy: gameState.resources.energy - cost.energy,\n        },\n      });\n    }\n\n    // Register with module system\n    moduleDispatch({\n      type: ModuleActionType.ADD_MODULE,\n      payload: {\n        module,\n      },\n    });\n\n    // Register with the VPR system for visualization\n    vprSystem.addModule(\n      moduleId,\n      moduleType === 'resource-manager'\n        ? 'mining'\n        : moduleType === 'radar'\n        ? 'exploration'\n        : moduleType === 'hangar'\n        ? 'mothership'\n        : 'colony'\n    );\n\n    // Emit module created event for the event system\n    moduleEventBus.emit({\n      type: 'MODULE_CREATED',\n      moduleId,\n      moduleType,\n      timestamp: Date.now(),\n      data: module as unknown as Record<string, unknown>,\n    });\n\n    console.warn('New module built:', module); // Changed from console.log to console.warn\n    return true;\n  };\n\n  // Add notification to the notification system\n  const addNotification = (\n    type: 'success' | 'error' | 'info' | 'warning',\n    title: string,\n    message: string\n  ): void => {\n    notificationManager.show({\n      type,\n      title,\n      message,\n    });\n  };\n\n  // Toggle tech tree display\n  const toggleTechTree = () => {\n    setShowTechTree(prev => !prev);\n  };\n\n  // Toggle settings panel\n  const toggleSettings = () => {\n    setShowSettings(prev => !prev);\n  };\n\n  // Function to format tooltip display\n  const _formatTooltip = (item: MenuItem): string => {\n    let tooltip = `<div class=\"tooltip-content\">\n      <h3 class=\"tooltip-title\">${item.name}</h3>\n      <p class=\"tooltip-desc\">${item.description}</p>`;\n\n    if (item.cost) {\n      tooltip += '<div class=\"tooltip-cost\">';\n      if (item.cost.minerals) {\n        tooltip += `<div class=\"tooltip-resource\">\n          <span class=\"tooltip-resource-icon\">ðŸ’Ž</span>\n          <span class=\"tooltip-resource-amount\">${item.cost.minerals} minerals</span>\n        </div>`;\n      }\n      if (item.cost.energy) {\n        tooltip += `<div class=\"tooltip-resource\">\n          <span class=\"tooltip-resource-icon\">âš¡</span>\n          <span class=\"tooltip-resource-amount\">${item.cost.energy} energy</span>\n        </div>`;\n      }\n      tooltip += '</div>';\n    }\n\n    tooltip += '</div>';\n    return tooltip;\n  };\n\n  // Render tooltip content\n  const renderTooltip = () => {\n    if (!showTooltip) {\n      return null;\n    }\n\n    const activeItems = menuItems[activeCategory as MenuCategory];\n    if (!activeItems) {\n      return null;\n    }\n\n    const currentItem = activeItems.find(item => item.id === showTooltip.id);\n    if (!currentItem) {\n      return null;\n    }\n\n    return (\n      <div\n        className=\"absolute z-50 w-64 rounded-lg border border-gray-800 bg-gray-900 p-3 shadow-lg\"\n        style={{\n          left: `${showTooltip.x}px`,\n          top: `${showTooltip.y}px`,\n        }}\n      >\n        <h3 className=\"mb-1 text-lg font-bold text-white\">{currentItem.name}</h3>\n        <p className=\"mb-2 text-sm text-gray-300\">{currentItem.description}</p>\n        {currentItem.cost && (\n          <div className=\"mt-2 flex flex-col space-y-1 text-sm\">\n            {currentItem.cost.minerals && (\n              <div\n                className={`flex items-center space-x-1 ${\n                  gameState.resources.minerals < (currentItem.cost.minerals ?? 0)\n                    ? 'text-red-400'\n                    : 'text-amber-300'\n                }`}\n              >\n                <span>ðŸ’Ž</span>\n                <span>\n                  {currentItem.cost.minerals} minerals{' '}\n                  {gameState.resources.minerals < (currentItem.cost.minerals ?? 0) && (\n                    <span className=\"text-red-400\">(insufficient)</span>\n                  )}\n                </span>\n              </div>\n            )}\n            {currentItem.cost.energy && (\n              <div\n                className={`flex items-center space-x-1 ${\n                  gameState.resources.energy < (currentItem.cost.energy ?? 0)\n                    ? 'text-red-400'\n                    : 'text-cyan-300'\n                }`}\n              >\n                <span>âš¡</span>\n                <span>\n                  {currentItem.cost.energy} energy{' '}\n                  {gameState.resources.energy < (currentItem.cost.energy ?? 0) && (\n                    <span className=\"text-red-400\">(insufficient)</span>\n                  )}\n                </span>\n              </div>\n            )}\n          </div>\n        )}\n      </div>\n    );\n  };\n\n  // Define menu items for each category\n  const menuItems: Record<MenuCategory, MenuItem[]> = {\n    mining: [\n      {\n        id: 'mining_resource_generator',\n        name: 'Energy Generator',\n        description: 'Generates energy for your empire',\n        moduleType: 'resource-manager',\n        cost: {\n          minerals: 50,\n        },\n        action: () => {\n          const canBuild = canBuildModule('resource-manager', { minerals: 50 });\n          if (canBuild) {\n            if (buildModuleLocally('resource-manager', { minerals: 50 })) {\n              addNotification(\n                'success',\n                'Module Built',\n                'Energy Generator has been successfully constructed.'\n              );\n            }\n          } else {\n            addNotification(\n              'error',\n              'Cannot Build',\n              'Insufficient resources or no suitable attachment point.'\n            );\n          }\n        },\n      },\n      {\n        id: 'mining_mineral_extractor',\n        name: 'Mineral Extractor',\n        description: 'Extracts minerals from nearby sources',\n        moduleType: 'mineral',\n        cost: {\n          minerals: 30,\n          energy: 20,\n        },\n        action: () => {\n          const canBuild = canBuildModule('mineral', { minerals: 30, energy: 20 });\n          if (canBuild) {\n            if (buildModuleLocally('mineral', { minerals: 30, energy: 20 })) {\n              addNotification(\n                'success',\n                'Module Built',\n                'Mineral Extractor has been successfully constructed.'\n              );\n            }\n          } else {\n            addNotification(\n              'error',\n              'Cannot Build',\n              'Insufficient resources or no suitable attachment point.'\n            );\n          }\n        },\n      },\n    ],\n    exploration: [\n      {\n        id: 'exploration_research_lab',\n        name: 'Research Laboratory',\n        description: 'Conducts research to unlock new technologies',\n        moduleType: ResourceType.RESEARCH,\n        cost: {\n          minerals: 40,\n          energy: 30,\n        },\n        action: () => {\n          const canBuild = canBuildModule(ResourceType.RESEARCH, { minerals: 40, energy: 30 });\n          if (canBuild) {\n            if (buildModuleLocally(ResourceType.RESEARCH, { minerals: 40, energy: 30 })) {\n              addNotification(\n                'success',\n                'Module Built',\n                'Research Laboratory has been successfully constructed.'\n              );\n            }\n          } else {\n            addNotification(\n              'error',\n              'Cannot Build',\n              'Insufficient resources or no suitable attachment point.'\n            );\n          }\n        },\n      },\n    ],\n    mothership: [\n      {\n        id: 'mothership_command_center',\n        name: 'Command Center',\n        description: 'Central hub for managing empire operations',\n        moduleType: 'hangar',\n        cost: {\n          minerals: 100,\n          energy: 80,\n        },\n        action: () => {\n          const canBuild = canBuildModule('hangar', { minerals: 100, energy: 80 });\n          if (canBuild) {\n            if (buildModuleLocally('hangar', { minerals: 100, energy: 80 })) {\n              addNotification(\n                'success',\n                'Module Built',\n                'Command Center has been successfully constructed.'\n              );\n            }\n          } else {\n            addNotification(\n              'error',\n              'Cannot Build',\n              'Insufficient resources or no suitable attachment point.'\n            );\n          }\n        },\n      },\n    ],\n    colony: [\n      {\n        id: 'colony_habitat',\n        name: 'Habitat Module',\n        description: 'Living quarters for your colonists',\n        moduleType: ResourceType.POPULATION,\n        cost: {\n          minerals: 60,\n          energy: 40,\n        },\n        action: () => {\n          const canBuild = canBuildModule(ResourceType.POPULATION, { minerals: 60, energy: 40 });\n          if (canBuild) {\n            if (buildModuleLocally(ResourceType.POPULATION, { minerals: 60, energy: 40 })) {\n              addNotification(\n                'success',\n                'Module Built',\n                'Habitat Module has been successfully constructed.'\n              );\n            }\n          } else {\n            addNotification(\n              'error',\n              'Cannot Build',\n              'Insufficient resources or no suitable attachment point.'\n            );\n          }\n        },\n      },\n    ],\n  };\n\n  // Get updated menu items based on current game state\n  const getUpdatedMenuItems = () => {\n    return {\n      ...menuItems,\n    };\n  };\n\n  // Get dynamic style for category button based on state\n  const getCategoryStyle = (category: MenuCategory) => {\n    return `flex items-center rounded-lg border p-3 transition-colors duration-200 ${\n      categoryColors[category].border\n    } ${categoryColors[category].bg} ${\n      category === activeCategory ? 'ring-2 ring-white/20' : categoryColors[category].hover\n    }`;\n  };\n\n  // Memoized menu items\n  const menuItemsMemo = useMemo(() => getUpdatedMenuItems(), [\n    gameState.resources.minerals,\n    gameState.resources.energy,\n    modules.buildings,\n  ]);\n\n  return (\n    <div className=\"flex h-screen flex-col bg-gray-900 font-sans text-white\">\n      {/* Top header with empire info and resources */}\n      <div className=\"flex items-center justify-between border-b border-gray-800 bg-gray-900 bg-opacity-90 p-2\">\n        <div className=\"flex items-center space-x-4\">\n          <button\n            className=\"flex items-center rounded border border-gray-700 bg-gray-800 px-3 py-1 text-xs\"\n            onClick={onToggleSprawlView}\n          >\n            <span className=\"mr-1\">âš¡</span>\n            {empireName}\n          </button>\n          <button\n            className=\"flex items-center rounded border border-purple-900 bg-purple-950 px-3 py-1 text-xs text-purple-200\"\n            onClick={onToggleVPRView}\n          >\n            <Info size={12} className=\"mr-1\" />\n            Toggle VPR Mode\n          </button>\n          <div className=\"flex items-center rounded-lg border border-gray-800 bg-gray-800 px-3 py-1 text-xs\">\n            <AlertTriangle size={12} className=\"mr-1 text-yellow-400\" />\n            <span className=\"text-yellow-300\">Alert Level: Normal</span>\n          </div>\n          {/* Add sidebar collapse toggle */}\n          <button\n            className=\"flex items-center rounded border border-gray-700 bg-gray-800 px-3 py-1 text-xs\"\n            onClick={toggleSidebar}\n          >\n            <span className=\"mr-1\">{sidebarCollapsed ? 'â†’' : 'â†'}</span>\n            {sidebarCollapsed ? 'Expand' : 'Collapse'}\n          </button>\n        </div>\n        <div className=\"game-hud__resources-container\">\n          {resourceVisLoading ? (\n            <div className=\"loading-placeholder\">Loading resources...</div>\n          ) : (\n            ResourceVisualizationComponent && \n            <ResourceVisualizationComponent \n              type={ResourceType.MINERALS} \n              value={gameState.resources.minerals} \n            />\n          )}\n        </div>\n        <div className=\"flex space-x-4\">\n          <ResourceVisualization \n            type={ResourceType.MINERALS} \n            value={gameState.resources.minerals} \n          />\n          <ResourceVisualization \n            type={ResourceType.ENERGY} \n            value={gameState.resources.energy} \n          />\n        </div>\n      </div>\n      {/* Main content with menu and active panel */}\n      <div className=\"flex flex-1 overflow-hidden\">\n        {/* Left menu with categories */}\n        <div className={`flex ${sidebarCollapsed ? 'w-16' : 'w-64'} flex-col overflow-y-auto border-r border-gray-800 bg-gray-900 bg-opacity-60 transition-all duration-300`}>\n          {/* Menu categories */}\n          <div className=\"space-y-2 p-4\">\n            {Object.keys(menuItems).map((category) => (\n              <button\n                key={category}\n                className={getCategoryStyle(category as MenuCategory)}\n                onClick={() => setActiveCategory(category as MenuCategory)}\n              >\n                {categoryIcons[category as MenuCategory]}\n                {!sidebarCollapsed && (\n                  <>\n                    <span className=\"ml-2 font-medium\">\n                      {category.charAt(0).toUpperCase() + category.slice(1)}\n                    </span>\n                    <span className=\"ml-auto text-xs text-gray-400\">Alt+{category.charAt(0)}</span>\n                  </>\n                )}\n              </button>\n            ))}\n          </div>\n          {/* Action buttons at the bottom */}\n          <div className=\"mt-auto space-y-2 border-t border-gray-800 p-4\">\n            <button\n              className=\"flex w-full items-center rounded-lg border border-indigo-700/50 bg-indigo-900/30 px-4 py-2 transition-colors duration-200 hover:bg-indigo-800/40\"\n              onClick={toggleTechTree}\n            >\n              <Terminal size={18} />\n              {!sidebarCollapsed && (\n                <>\n                  <span className=\"ml-2 font-medium text-white\">Tech Tree</span>\n                  <span className=\"ml-auto text-xs text-gray-400\">F1</span>\n                </>\n              )}\n            </button>\n            <button\n              className=\"flex w-full items-center rounded-lg border border-gray-700/50 bg-gray-900/30 px-4 py-2 transition-colors duration-200 hover:bg-gray-800/40\"\n              onClick={toggleSettings}\n            >\n              <Settings size={18} />\n              {!sidebarCollapsed && (\n                <>\n                  <span className=\"ml-2 font-medium text-white\">Settings</span>\n                  <span className=\"ml-auto text-xs text-gray-400\">F2</span>\n                </>\n              )}\n            </button>\n          </div>\n        </div>\n        {/* Right panel with active category content */}\n        <div className=\"flex-1 overflow-y-auto p-6\">\n          {activeCategory ? (\n            <div>\n              {/* Category header */}\n              <div\n                className={`mb-6 border-b pb-4 ${\n                  categoryColors[activeCategory].border\n                } flex items-center justify-between`}\n              >\n                <h2 className=\"flex items-center text-2xl font-bold text-white\">\n                  {categoryIcons[activeCategory]}\n                  <span className=\"ml-2\">\n                    {activeCategory.charAt(0).toUpperCase() + activeCategory.slice(1)}\n                  </span>\n                </h2>\n                <button\n                  className=\"rounded-full p-1 transition-colors duration-200 hover:bg-gray-800\"\n                  onClick={() => setActiveCategory(null)}\n                >\n                  <X size={20} className=\"text-gray-400\" />\n                </button>\n              </div>\n              {/* Category items */}\n              <div className=\"space-y-3\">\n                {menuItemsMemo[activeCategory].map((item) => (\n                  <button\n                    key={item.id}\n                    className={`w-full rounded-lg border p-4 text-left ${\n                      categoryColors[activeCategory].border\n                    } bg-gray-800 bg-opacity-50 transition-colors duration-200 hover:bg-opacity-70`}\n                    onClick={item.action}\n                    onMouseEnter={(e) => {\n                      const rect = e.currentTarget.getBoundingClientRect();\n                      setShowTooltip({\n                        id: item.id,\n                        x: rect.right,\n                        y: rect.top,\n                      });\n                    }}\n                    onMouseLeave={() => setShowTooltip(null)}\n                  >\n                    <div className=\"flex items-start justify-between\">\n                      <h3 className=\"text-lg font-medium text-white\">{item.name}</h3>\n                      {item.cost ? (\n                        <div className=\"flex space-x-3 text-sm\">\n                          {item.cost.minerals ? (\n                            <span\n                              className={`rounded px-2 py-1 ${\n                                gameState.resources.minerals < (item.cost.minerals ?? 0)\n                                  ? 'bg-red-900/60 text-red-300'\n                                  : 'bg-amber-900/60 text-amber-300'\n                              }`}\n                            >\n                              {item.cost.minerals} minerals\n                            </span>\n                          ) : null}\n                          {item.cost.energy ? (\n                            <span\n                              className={`rounded px-2 py-1 ${\n                                gameState.resources.energy < (item.cost.energy ?? 0)\n                                  ? 'bg-red-900/60 text-red-300'\n                                  : 'bg-cyan-900/60 text-cyan-300'\n                              }`}\n                            >\n                              {item.cost.energy} energy\n                            </span>\n                          ) : null}\n                        </div>\n                      ) : null}\n                    </div>\n                    <p className=\"mt-1 text-gray-300\">{item.description}</p>\n                  </button>\n                ))}\n              </div>\n            </div>\n          ) : (\n            /* Welcome screen when no category is selected */\n            <div className=\"flex h-full flex-col items-center justify-center text-center\">\n              <h2 className=\"mb-4 text-2xl font-bold text-white\">Welcome to {empireName}</h2>\n              <p className=\"mb-8 max-w-md text-gray-300\">\n                Select a category from the left menu to manage your empire. Build modules to expand\n                your capabilities.\n              </p>\n              <div className=\"grid w-full max-w-md grid-cols-2 gap-4\">\n                {Object.keys(menuItems).map((category) => (\n                  <button\n                    key={category}\n                    className={`rounded-lg border p-4 ${\n                      categoryColors[category as MenuCategory].border\n                    } bg-gray-800/50 transition-colors duration-200 hover:bg-opacity-70`}\n                    onClick={() => setActiveCategory(category as MenuCategory)}\n                  >\n                    <div className=\"flex flex-col items-center justify-center\">\n                      {categoryIcons[category as MenuCategory]}\n                      <span className=\"mt-2 font-medium text-white\">\n                        {category.charAt(0).toUpperCase() + category.slice(1)}\n                      </span>\n                      <span className=\"mt-1 text-xs text-gray-400\">Alt+{category.charAt(0)}</span>\n                    </div>\n                  </button>\n                ))}\n              </div>\n            </div>\n          )}\n        </div>\n      </div>\n\n      {/* Tech Tree Modal */}\n      {showTechTree && TechTreeComponent && (\n        <div className=\"fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-80 p-6\">\n          <div className=\"max-h-[90vh] max-w-[90vw] overflow-auto rounded-lg border border-gray-700 bg-gray-900 shadow-lg\">\n            <TechTreeComponent visible={showTechTree} onClose={() => setShowTechTree(false)} />\n          </div>\n        </div>\n      )}\n\n      {/* Settings Modal */}\n      {showSettings && (\n        <div className=\"fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-80 p-6\">\n          <div className=\"max-h-[90vh] max-w-[90vw] overflow-auto rounded-lg border border-gray-700 bg-gray-900 shadow-lg\">\n            <div className=\"flex items-center justify-between border-b border-gray-700 p-4\">\n              <h2 className=\"text-xl font-bold text-white\">Settings</h2>\n              <button\n                className=\"rounded-full p-1 text-gray-400 hover:bg-gray-800 hover:text-white\"\n                onClick={() => setShowSettings(false)}\n              >\n                <X size={20} />\n              </button>\n            </div>\n            <div className=\"p-6\">\n              <_SettingsPanel />\n            </div>\n          </div>\n        </div>\n      )}\n\n      {/* Mini Map (if needed) */}\n      {!miniMapLoading && MiniMapComponent && activeMenu === 'exploration' && (\n        <div className=\"absolute bottom-4 right-4 h-64 w-64 rounded-lg border border-gray-700 bg-gray-900 shadow-lg\">\n          <MiniMapComponent\n            stars={[\n              { id: '1', name: 'Alpha', position: { x: 10, y: 10 }, status: 'colonized' },\n              { id: '2', name: 'Beta', position: { x: 50, y: 30 }, status: 'unlocked' },\n              { id: '3', name: 'Gamma', position: { x: 30, y: 60 }, status: 'locked' },\n            ]}\n            viewport={{ position: { x: 0, y: 0 }, zoom: 1, width: 64, height: 64 }}\n          />\n        </div>\n      )}\n\n      {/* Tooltips */}\n      {renderTooltip()}\n      {/* Notification system */}\n      <NotificationSystem />\n    </div>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/GameLayout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/GlobalErrorBoundary.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/NotificationSystem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/ResourceEventMonitor.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'latestEvents' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":62,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":62,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'receivedCount' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":62,"column":25,"nodeType":null,"messageId":"unusedVar","endLine":62,"endColumn":38}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as React from 'react';\nimport { useEffect, useRef, useState } from 'react';\nimport { FixedSizeList as List } from 'react-window';\nimport { useEventCategorySubscription } from '../../hooks/events/useEventSubscription';\nimport { EventBus } from '../../lib/events/EventBus';\nimport { ModuleEvent, moduleEventBus } from '../../lib/events/ModuleEventBus';\nimport { EventCategory, EventType } from '../../types/events/EventTypes';\nimport { ResourceType } from '../../types/resources/ResourceTypes';\n\n// Resource-related event types to monitor\nconst RESOURCE_EVENT_TYPES = [\n  EventType.RESOURCE_PRODUCED,\n  EventType.RESOURCE_CONSUMED,\n  EventType.RESOURCE_TRANSFERRED,\n  EventType.RESOURCE_PRODUCTION_REGISTERED,\n  EventType.RESOURCE_CONSUMPTION_REGISTERED,\n];\n\ninterface ResourceEventData {\n  resourceType: ResourceType;\n  amount: number;\n  source?: string;\n  target?: string;\n}\n\n// Type guard for resource events\nfunction isResourceEvent(event: ModuleEvent): event is ModuleEvent & { data: ResourceEventData } {\n  if (!event?.data) return false;\n  const data = event?.data as Partial<ResourceEventData>;\n  return (\n    'resourceType' in data &&\n    'amount' in data &&\n    typeof data?.resourceType === 'string' &&\n    typeof data?.amount === 'number'\n  );\n}\n\ninterface ResourceEventLog {\n  id: string;\n  type: EventType;\n  moduleId: string;\n  timestamp: number;\n  resourceType: ResourceType;\n  amount: number;\n  source?: string;\n  target?: string;\n}\n\n/**\n * Component that monitors and displays resource-related events in real-time.\n * Uses the standardized event system with proper type safety and event filtering.\n * Uses virtualization for efficient rendering of large event logs.\n */\nexport const ResourceEventMonitor: React.FC = () => {\n  const [eventLogs, setEventLogs] = useState<ResourceEventLog[]>([]);\n  const [filter, setFilter] = useState<string>('');\n  const listRef = useRef<List>(null);\n  const containerRef = useRef<HTMLDivElement>(null);\n  const [containerSize, setContainerSize] = useState({ width: 0, height: 0 });\n\n  // Subscribe to all resource events using category subscription\n  const { latestEvents, receivedCount } = useEventCategorySubscription(\n    moduleEventBus as unknown as EventBus<ModuleEvent>,\n    EventCategory.RESOURCE,\n    (event: ModuleEvent) => {\n      if (isResourceEvent(event)) {\n        addEventToLog({\n          id: `${event?.type}-${event?.moduleId}-${event?.timestamp}`,\n          type: event?.type,\n          moduleId: event?.moduleId,\n          timestamp: event?.timestamp,\n          resourceType: event?.data?.resourceType,\n          amount: event?.data?.amount,\n          source: event?.data?.source,\n          target: event?.data?.target,\n        });\n      }\n    },\n    {\n      trackLatest: true,\n      filter: (event: ModuleEvent) => RESOURCE_EVENT_TYPES.includes(event?.type as EventType),\n    }\n  );\n\n  // Helper function to add events to the log\n  const addEventToLog = (eventLog: ResourceEventLog) => {\n    setEventLogs(prevLogs => {\n      const newLogs = [eventLog, ...prevLogs];\n      return newLogs.slice(0, 1000);\n    });\n\n    // Scroll to top when new events come in\n    if (listRef.current) {\n      listRef.current.scrollTo(0);\n    }\n  };\n\n  // Clear logs\n  const clearLogs = () => {\n    setEventLogs([]);\n  };\n\n  // Filter logs based on user input\n  const filteredLogs = filter\n    ? eventLogs.filter(\n        log =>\n          log.type.toLowerCase().includes(filter.toLowerCase()) ||\n          log.moduleId.toLowerCase().includes(filter.toLowerCase()) ||\n          log.resourceType.toLowerCase().includes(filter.toLowerCase())\n      )\n    : eventLogs;\n\n  // Measure container size for the virtualized list\n  useEffect(() => {\n    if (containerRef.current) {\n      const resizeObserver = new ResizeObserver(entries => {\n        for (const entry of entries) {\n          const { width, height } = entry.contentRect;\n          setContainerSize({ width, height });\n        }\n      });\n\n      resizeObserver.observe(containerRef.current);\n\n      // Initialize size\n      setContainerSize({\n        width: containerRef.current.clientWidth,\n        height: containerRef.current.clientHeight,\n      });\n\n      return () => {\n        resizeObserver.disconnect();\n      };\n    }\n  }, []);\n\n  // Row renderer for the virtualized list\n  const Row = ({ index, style }: { index: number; style: React.CSSProperties }) => {\n    const log = filteredLogs[index];\n    return (\n      <div style={style} className=\"flex border-b border-gray-700 hover:bg-gray-600\">\n        <div className=\"min-w-[100px] flex-1 px-4 py-2\">\n          {new Date(log.timestamp).toLocaleTimeString()}\n        </div>\n        <div className=\"min-w-[150px] flex-1 px-4 py-2\">{log.type}</div>\n        <div className=\"min-w-[120px] flex-1 px-4 py-2\">{log.moduleId}</div>\n        <div className=\"min-w-[100px] flex-1 px-4 py-2\">{log.resourceType}</div>\n        <div className=\"min-w-[80px] flex-1 px-4 py-2\">{log.amount.toFixed(2)}</div>\n      </div>\n    );\n  };\n\n  // Table header for the virtualized list\n  const TableHeader = () => (\n    <div className=\"flex bg-gray-700 text-xs uppercase\">\n      <div className=\"min-w-[100px] flex-1 px-4 py-2\">Time</div>\n      <div className=\"min-w-[150px] flex-1 px-4 py-2\">Event Type</div>\n      <div className=\"min-w-[120px] flex-1 px-4 py-2\">Module</div>\n      <div className=\"min-w-[100px] flex-1 px-4 py-2\">Resource</div>\n      <div className=\"min-w-[80px] flex-1 px-4 py-2\">Amount</div>\n    </div>\n  );\n\n  return (\n    <div className=\"rounded-lg bg-gray-800 p-4 shadow-lg\">\n      <div className=\"mb-4 flex items-center justify-between\">\n        <h2 className=\"text-xl font-semibold text-white\">Resource Event Monitor</h2>\n        <div className=\"flex space-x-2\">\n          <input\n            type=\"text\"\n            placeholder=\"Filter events...\"\n            className=\"rounded border border-gray-600 bg-gray-700 px-3 py-1 text-white focus:outline-none focus:ring-2 focus:ring-blue-500\"\n            value={filter}\n            onChange={e => setFilter(e.target.value)}\n          />\n          <button\n            onClick={clearLogs}\n            className=\"rounded bg-red-600 px-3 py-1 text-white hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500\"\n          >\n            Clear\n          </button>\n        </div>\n      </div>\n\n      <div ref={containerRef} className=\"h-96 w-full\">\n        {filteredLogs.length === 0 ? (\n          <div className=\"flex h-full items-center justify-center py-8 text-center text-gray-400\">\n            No resource events recorded yet\n          </div>\n        ) : (\n          <div className=\"text-left text-sm text-gray-300\">\n            <TableHeader />\n            <List\n              ref={listRef}\n              className=\"text-left text-sm text-gray-300\"\n              height={containerSize.height - 30} // Subtract header height\n              width={containerSize.width}\n              itemCount={filteredLogs.length}\n              itemSize={40} // Height of each row\n            >\n              {Row}\n            </List>\n          </div>\n        )}\n      </div>\n\n      <div className=\"mt-2 text-xs text-gray-500\">\n        Displaying {filteredLogs.length} events (virtualized for performance)\n      </div>\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/ResourceVisualization.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/SprawlView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/Tabs.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/TechTree.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/TooltipProvider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/VPRErrorBoundary.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_' is defined but never used.","line":21,"column":35,"nodeType":null,"messageId":"unusedVar","endLine":21,"endColumn":36}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { AlertTriangle } from 'lucide-react';\nimport * as React from 'react';\nimport { Component, ErrorInfo } from 'react';\n\ninterface Props {\n  moduleId: string;\n  onError: (error: Error, moduleId: string) => void;\n  children: React.ReactNode;\n}\n\ninterface State {\n  hasError: boolean;\n}\n\nexport class VPRErrorBoundary extends Component<Props, State> {\n  constructor(props: Props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(_: Error): State {\n    return { hasError: true };\n  }\n\n  componentDidCatch(error: Error, errorInfo: ErrorInfo) {\n    this.props?.onError(error, this.props?.moduleId);\n    console.error('VPR Module Error:', error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      return (\n        <div className=\"rounded-lg border border-red-700/30 bg-red-900/20 p-4\">\n          <div className=\"mb-2 flex items-center space-x-2 text-red-400\">\n            <AlertTriangle className=\"h-5 w-5\" />\n            <span className=\"font-medium\">Module Error</span>\n          </div>\n          <p className=\"text-sm text-red-200\">\n            This module has encountered an error and has been disabled.\n          </p>\n        </div>\n      );\n    }\n\n    return this.props?.children;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/VPRLoadingFallback.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/VPRStarSystemView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/automation/AutomationRuleEditor.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/automation/AutomationVisualization.tsx","messages":[{"ruleId":"no-unsafe-optional-chaining","severity":2,"message":"Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.","line":105,"column":29,"nodeType":"ChainExpression","messageId":"unsafeOptionalChain","endLine":105,"endColumn":42}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as React from 'react';\nimport { useEffect, useState } from 'react';\nimport {\n  GlobalAutomationManager,\n  GlobalRoutine,\n} from '../../../managers/automation/GlobalAutomationManager';\nimport { AutomationRule } from '../../../managers/game/AutomationManager';\nimport '../../../styles/automation.css';\nimport AutomationRuleEditor from './AutomationRuleEditor';\n\n// Define the routine type enum to match what's in GlobalAutomationManager\nenum RoutineType {\n  RESOURCE_BALANCING = 'RESOURCE_BALANCING',\n  PERFORMANCE_OPTIMIZATION = 'PERFORMANCE_OPTIMIZATION',\n  EMERGENCY_RESPONSE = 'EMERGENCY_RESPONSE',\n  SYSTEM_MAINTENANCE = 'SYSTEM_MAINTENANCE',\n}\n\n// Define SystemId type to match what's expected\ntype SystemId = string;\n\ninterface AutomationVisualizationProps {\n  automationManager?: GlobalAutomationManager;\n  className?: string;\n}\n\nexport const AutomationVisualization: React.FC<AutomationVisualizationProps> = ({\n  automationManager,\n  className = '',\n}) => {\n  const [routines, setRoutines] = useState<GlobalRoutine[]>([]);\n  const [loading, setLoading] = useState<boolean>(true);\n  const [filter, setFilter] = useState<{\n    type: string;\n    system: string;\n    status: string;\n    search: string;\n  }>({\n    type: 'all',\n    system: 'all',\n    status: 'all',\n    search: '',\n  });\n\n  // Add states for rule editor\n  const [showRuleEditor, setShowRuleEditor] = useState<boolean>(false);\n  const [currentRule, setCurrentRule] = useState<AutomationRule | undefined>(undefined);\n  const [selectedModuleId, setSelectedModuleId] = useState<string>('');\n\n  // Get all available types and systems for filtering\n  const routineTypes = Object.values(RoutineType);\n  const systems = [\n    ...new Set(\n      routines.map(routine =>\n        Array.isArray(routine.systems) && routine.systems.length > 0\n          ? routine.systems[0]\n          : 'unknown'\n      )\n    ),\n  ];\n\n  useEffect(() => {\n    if (!automationManager) {\n      return;\n    }\n\n    // Initial load\n    loadRoutines();\n\n    // Subscribe to automation events\n    const unsubscribe = subscribeToAutomationEvents();\n\n    return () => {\n      unsubscribe();\n    };\n  }, [automationManager]);\n\n  const loadRoutines = () => {\n    if (!automationManager) {\n      return;\n    }\n\n    setLoading(true);\n    try {\n      const allRoutines = automationManager.getAllRoutines();\n      setRoutines(allRoutines);\n    } catch (error) {\n      console.error('Failed to load automation routines:', error);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const subscribeToAutomationEvents = () => {\n    if (!automationManager) {\n      return () => {};\n    }\n\n    // This would be implemented with the event system\n    // For now, we'll just return an empty function\n    return () => {};\n  };\n\n  const handleFilterChange = (event: React.ChangeEvent<HTMLSelectElement | HTMLInputElement>) => {\n    const { name, value } = event?.target;\n    setFilter(prev => ({\n      ...prev,\n      [name]: value,\n    }));\n  };\n\n  const handleToggleRoutine = (routineId: string) => {\n    if (!automationManager) {\n      return;\n    }\n\n    const routine = routines.find(r => r.id === routineId);\n    if (!routine) {\n      return;\n    }\n\n    try {\n      if (routine.enabled) {\n        automationManager.disableRoutine(routineId);\n      } else {\n        automationManager.enableRoutine(routineId);\n      }\n\n      // Update local state\n      setRoutines(prev => prev.map(r => (r.id === routineId ? { ...r, enabled: !r.enabled } : r)));\n    } catch (error) {\n      console.error(`Failed to toggle routine ${routineId}:`, error);\n    }\n  };\n\n  const handleRemoveRoutine = (routineId: string) => {\n    if (!automationManager) {\n      return;\n    }\n\n    try {\n      automationManager.unregisterRoutine(routineId);\n\n      // Update local state\n      setRoutines(prev => prev.filter(r => r.id !== routineId));\n    } catch (error) {\n      console.error(`Failed to remove routine ${routineId}:`, error);\n    }\n  };\n\n  const handleRunRoutine = (routineId: string) => {\n    if (!automationManager) {\n      return;\n    }\n\n    try {\n      // Find the routine first\n      const routine = routines.find(r => r.id === routineId);\n      if (!routine) {\n        return;\n      }\n\n      // Manually trigger the routine execution\n      // Note: Since executeRoutine is private, we'll just update the UI\n      // In a real implementation, we would need a public method to execute a routine\n      console.warn(`Executing routine: ${routineId}`);\n\n      // Update local state to reflect the routine was run\n      const now = new Date().getTime(); // Use number instead of string for lastRun\n      setRoutines(prev => prev.map(r => (r.id === routineId ? { ...r, lastRun: now } : r)));\n    } catch (error) {\n      console.error(`Failed to run routine ${routineId}:`, error);\n    }\n  };\n\n  // Add function to create a new rule\n  const handleCreateRule = () => {\n    setCurrentRule(undefined);\n    setSelectedModuleId('default-module');\n    setShowRuleEditor(true);\n  };\n\n  // Add function to edit an existing rule\n  const handleEditRule = (ruleId: string) => {\n    // Assuming automationManager has a method to get rule by ID\n    if (automationManager) {\n      const rule = automationManager.getRule(ruleId);\n      if (rule) {\n        setCurrentRule(rule);\n        setSelectedModuleId(rule.moduleId);\n        setShowRuleEditor(true);\n      }\n    }\n  };\n\n  // Add function to save a rule\n  const handleSaveRule = (rule: AutomationRule) => {\n    if (automationManager) {\n      // Assuming automationManager has methods to register/update rules\n      if (rule.id && automationManager.getRule(rule.id)) {\n        automationManager.updateRule(rule.id, rule);\n      } else {\n        automationManager.registerRule(rule);\n      }\n\n      // Refresh routines list\n      loadRoutines();\n\n      // Close editor\n      setShowRuleEditor(false);\n    }\n  };\n\n  // Filter routines based on current filter settings\n  const filteredRoutines = routines.filter(routine => {\n    const matchesType = filter.type === 'all' || routine.type === filter.type;\n    const matchesSystem =\n      filter.system === 'all' ||\n      (Array.isArray(routine.systems) &&\n        routine.systems.some(sys => sys === (filter.system as SystemId)));\n    const matchesStatus =\n      filter.status === 'all' ||\n      (filter.status === 'active' && routine.enabled) ||\n      (filter.status === 'inactive' && !routine.enabled);\n    const matchesSearch =\n      !filter.search ||\n      routine.name.toLowerCase().includes(filter.search.toLowerCase()) ||\n      routine.description.toLowerCase().includes(filter.search.toLowerCase()) ||\n      (Array.isArray(routine.tags) &&\n        routine.tags.some(tag => tag.toLowerCase().includes(filter.search.toLowerCase())));\n\n    return matchesType && matchesSystem && matchesStatus && matchesSearch;\n  });\n\n  // Get routine type icon based on type\n  const getRoutineTypeIcon = (type: string) => {\n    switch (type) {\n      case RoutineType.RESOURCE_BALANCING:\n        return 'âš–ï¸';\n      case RoutineType.PERFORMANCE_OPTIMIZATION:\n        return 'âš¡';\n      case RoutineType.EMERGENCY_RESPONSE:\n        return 'ðŸš¨';\n      case RoutineType.SYSTEM_MAINTENANCE:\n        return 'ðŸ”§';\n      default:\n        return 'ðŸ¤–';\n    }\n  };\n\n  // Format relative time\n  const formatRelativeTime = (timestamp: number | undefined) => {\n    if (!timestamp) {\n      return 'Never';\n    }\n\n    const now = new Date().getTime();\n    const diffMs = now - timestamp;\n    const diffSec = Math.floor(diffMs / 1000);\n\n    if (diffSec < 60) {\n      return `${diffSec}s ago`;\n    }\n    if (diffSec < 3600) {\n      return `${Math.floor(diffSec / 60)}m ago`;\n    }\n    if (diffSec < 86400) {\n      return `${Math.floor(diffSec / 3600)}h ago`;\n    }\n    return `${Math.floor(diffSec / 86400)}d ago`;\n  };\n\n  // Get priority label and color\n  const getPriorityLabel = (priority: number) => {\n    if (priority >= 90) {\n      return { label: 'Critical', color: '#f44336' };\n    }\n    if (priority >= 70) {\n      return { label: 'High', color: '#ff9800' };\n    }\n    if (priority >= 40) {\n      return { label: 'Medium', color: '#2196f3' };\n    }\n    if (priority >= 10) {\n      return { label: 'Low', color: '#4caf50' };\n    }\n    return { label: 'Background', color: '#9e9e9e' };\n  };\n\n  if (loading) {\n    return (\n      <div className={`automation-visualization automation-visualization--loading ${className}`}>\n        <div className=\"automation-visualization__loading-spinner\">\n          {/* Spinner component would go here */}\n          <div>Loading...</div>\n        </div>\n        <div className=\"automation-visualization__loading-text\">Loading automation routines...</div>\n      </div>\n    );\n  }\n\n  if (showRuleEditor) {\n    return (\n      <div className={`automation-visualization ${className}`}>\n        <AutomationRuleEditor\n          rule={currentRule}\n          moduleId={selectedModuleId}\n          onSave={handleSaveRule}\n          onCancel={() => setShowRuleEditor(false)}\n        />\n      </div>\n    );\n  }\n\n  return (\n    <div className={`automation-visualization ${className}`}>\n      <div className=\"automation-visualization__header\">\n        <h2 className=\"automation-visualization__title\">\n          <span style={{ marginRight: '8px' }}>ðŸ¤–</span>\n          Automation Routines\n        </h2>\n        <div className=\"automation-visualization__stats\">\n          <div className=\"automation-visualization__stat\">\n            <span className=\"automation-visualization__stat-label\">Total:</span>\n            <span className=\"automation-visualization__stat-value\">{routines.length}</span>\n          </div>\n          <div className=\"automation-visualization__stat\">\n            <span className=\"automation-visualization__stat-label\">Active:</span>\n            <span className=\"automation-visualization__stat-value\">\n              {routines.filter(r => r.enabled).length}\n            </span>\n          </div>\n        </div>\n      </div>\n\n      <div className=\"automation-visualization__filters\">\n        <div className=\"automation-visualization__filter\">\n          <label className=\"automation-visualization__filter-label\">Type:</label>\n          <select\n            className=\"automation-visualization__filter-select\"\n            name=\"type\"\n            value={filter.type}\n            onChange={handleFilterChange}\n          >\n            <option value=\"all\">All Types</option>\n            {routineTypes.map(type => (\n              <option key={type} value={type}>\n                {type.replace(/_/g, ' ')}\n              </option>\n            ))}\n          </select>\n        </div>\n\n        <div className=\"automation-visualization__filter\">\n          <label className=\"automation-visualization__filter-label\">System:</label>\n          <select\n            className=\"automation-visualization__filter-select\"\n            name=\"system\"\n            value={filter.system}\n            onChange={handleFilterChange}\n          >\n            <option value=\"all\">All Systems</option>\n            {systems.map(system => (\n              <option key={system} value={system}>\n                {system}\n              </option>\n            ))}\n          </select>\n        </div>\n\n        <div className=\"automation-visualization__filter\">\n          <label className=\"automation-visualization__filter-label\">Status:</label>\n          <select\n            className=\"automation-visualization__filter-select\"\n            name=\"status\"\n            value={filter.status}\n            onChange={handleFilterChange}\n          >\n            <option value=\"all\">All Statuses</option>\n            <option value=\"active\">Active</option>\n            <option value=\"inactive\">Inactive</option>\n          </select>\n        </div>\n\n        <input\n          type=\"text\"\n          className=\"automation-visualization__search\"\n          name=\"search\"\n          value={filter.search}\n          onChange={handleFilterChange}\n          placeholder=\"Search routines...\"\n        />\n      </div>\n\n      <div className=\"automation-visualization__routines\">\n        {filteredRoutines.length === 0 ? (\n          <div className=\"automation-visualization__empty\">\n            <div>No automation routines found</div>\n            <div>Try adjusting your filters or create a new routine</div>\n          </div>\n        ) : (\n          <div className=\"automation-visualization__routines-list\">\n            {filteredRoutines.map(routine => {\n              const priorityInfo = getPriorityLabel(routine.priority);\n              const systemName =\n                Array.isArray(routine.systems) && routine.systems.length > 0\n                  ? routine.systems[0]\n                  : 'unknown';\n\n              return (\n                <div\n                  key={routine.id}\n                  className={`automation-visualization__routine ${\n                    routine.enabled\n                      ? 'automation-visualization__routine--active'\n                      : 'automation-visualization__routine--inactive'\n                  }`}\n                >\n                  <div className=\"automation-visualization__routine-header\">\n                    <div className=\"automation-visualization__routine-type\">\n                      {getRoutineTypeIcon(routine.type)}\n                    </div>\n                    <div className=\"automation-visualization__routine-name\">{routine.name}</div>\n                    <div\n                      className=\"automation-visualization__routine-priority\"\n                      style={{ backgroundColor: priorityInfo.color }}\n                    >\n                      {priorityInfo.label}\n                    </div>\n                  </div>\n\n                  <div className=\"automation-visualization__routine-description\">\n                    {routine.description}\n                  </div>\n\n                  <div className=\"automation-visualization__routine-meta\">\n                    <div className=\"automation-visualization__routine-systems\">\n                      System: {systemName}\n                    </div>\n                    {routine.interval && (\n                      <div className=\"automation-visualization__routine-interval\">\n                        Interval: {routine.interval}ms\n                      </div>\n                    )}\n                    <div className=\"automation-visualization__routine-last-run\">\n                      Last run: {formatRelativeTime(routine.lastRun)}\n                    </div>\n                  </div>\n\n                  {Array.isArray(routine.tags) && routine.tags.length > 0 && (\n                    <div className=\"automation-visualization__routine-tags\">\n                      {routine.tags.map((tag, index) => (\n                        <div\n                          key={`${routine.id}-tag-${index}`}\n                          className=\"automation-visualization__routine-tag\"\n                        >\n                          {tag}\n                        </div>\n                      ))}\n                    </div>\n                  )}\n\n                  <div className=\"automation-visualization__routine-controls\">\n                    <button\n                      className=\"automation-visualization__routine-control automation-visualization__routine-control--run\"\n                      onClick={() => handleRunRoutine(routine.id)}\n                      title=\"Run now\"\n                    >\n                      â–¶ï¸\n                    </button>\n                    <button\n                      className=\"automation-visualization__routine-control automation-visualization__routine-control--toggle\"\n                      onClick={() => handleToggleRoutine(routine.id)}\n                      title={routine.enabled ? 'Disable' : 'Enable'}\n                    >\n                      {routine.enabled ? 'â¸ï¸' : 'â–¶ï¸'}\n                    </button>\n                    <button\n                      className=\"automation-visualization__routine-control automation-visualization__routine-control--remove\"\n                      onClick={() => handleRemoveRoutine(routine.id)}\n                      title=\"Remove\"\n                    >\n                      ðŸ—‘ï¸\n                    </button>\n                    <button\n                      className=\"automation-visualization__routine-control automation-visualization__routine-control--edit\"\n                      onClick={() => handleEditRule(routine.id)}\n                      title=\"Edit Rule\"\n                    >\n                      âœï¸\n                    </button>\n                  </div>\n                </div>\n              );\n            })}\n          </div>\n        )}\n      </div>\n\n      <div className=\"automation-visualization__create\">\n        <button className=\"automation-visualization__create-button\" onClick={handleCreateRule}>\n          + Create New Routine\n        </button>\n      </div>\n    </div>\n  );\n};\n\nexport default AutomationVisualization;\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/buttons/AbilityButton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/common/Badge.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/common/Button.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/config/TypeSafeConfigDemo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/errors/ComponentErrorState.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'XCircle' is defined but never used. Allowed unused vars must match /^ignored|^temp/u.","line":11,"column":36,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":43},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Database' is defined but never used. Allowed unused vars must match /^ignored|^temp/u.","line":11,"column":58,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":66}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @context: ui-system, ui-error-handling, component-library\n * \n * ComponentErrorState - Reusable component-specific error states\n * \n * This module provides specialized error state components for different\n * UI element types, offering appropriate fallback UI and error messages.\n */\n\nimport * as React from 'react';\nimport { AlertTriangle, RefreshCw, XCircle, AlertCircle, Database, FileX } from 'lucide-react';\nimport { forwardRef, useCallback } from 'react';\nimport { ErrorType, ErrorSeverity, errorLoggingService } from '../../../services/ErrorLoggingService';\n\n/**\n * Base props for all error state components\n */\nexport interface ErrorStateProps {\n  /** Message explaining the error */\n  message?: string;\n  \n  /** Detailed technical error information */\n  details?: string;\n  \n  /** Function to retry the operation */\n  onRetry?: () => void;\n  \n  /** Additional CSS class for styling */\n  className?: string;\n  \n  /** Whether to show the retry button */\n  showRetry?: boolean;\n  \n  /** Text for the retry button */\n  retryText?: string;\n  \n  /** Whether to show an icon */\n  showIcon?: boolean;\n  \n  /** Whether error details should be displayed */\n  showDetails?: boolean;\n}\n\n/**\n * Base error state component that other specialized error states extend\n */\nexport const BaseErrorState: React.FC<ErrorStateProps> = ({\n  message = 'An error occurred',\n  details,\n  onRetry,\n  className = '',\n  showRetry = true,\n  retryText = 'Try Again',\n  showIcon = true,\n  showDetails = process.env.NODE_ENV !== 'production',\n}) => {\n  return (\n    <div \n      className={`rounded-md border border-red-300 bg-red-50 p-4 text-red-800 shadow-sm dark:border-red-800 dark:bg-red-900/20 dark:text-red-300 ${className}`}\n      role=\"alert\"\n    >\n      <div className=\"flex items-start\">\n        {showIcon && (\n          <div className=\"mr-3 flex-shrink-0 pt-0.5 text-red-500\">\n            <AlertTriangle size={20} />\n          </div>\n        )}\n        \n        <div className=\"flex-1\">\n          <p className=\"text-sm font-medium\">{message}</p>\n          \n          {showDetails && details && (\n            <details className=\"mt-2 text-xs\">\n              <summary className=\"cursor-pointer font-medium\">Error Details</summary>\n              <p className=\"mt-1 whitespace-pre-wrap rounded bg-red-100 p-2 dark:bg-red-900/40\">\n                {details}\n              </p>\n            </details>\n          )}\n          \n          {showRetry && onRetry && (\n            <div className=\"mt-3\">\n              <button\n                type=\"button\"\n                onClick={onRetry}\n                className=\"inline-flex items-center rounded-md bg-red-100 px-3 py-1.5 text-xs font-medium text-red-800 hover:bg-red-200 focus:outline-none focus:ring-2 focus:ring-red-600 focus:ring-offset-2 dark:bg-red-800 dark:text-red-100 dark:hover:bg-red-700\"\n              >\n                <RefreshCw size={14} className=\"mr-1.5\" />\n                {retryText}\n              </button>\n            </div>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n};\n\n/**\n * Error state for data fetching operations\n */\nexport const DataFetchErrorState: React.FC<ErrorStateProps> = (props) => {\n  return (\n    <BaseErrorState\n      message={props.message || 'Failed to load data'}\n      retryText=\"Reload Data\"\n      className={`data-fetch-error ${props.className || ''}`}\n      {...props}\n      showIcon={props.showIcon !== undefined ? props.showIcon : true}\n    />\n  );\n};\n\n/**\n * Error state for form validation errors\n */\nexport const FormErrorState: React.FC<ErrorStateProps> = (props) => {\n  return (\n    <BaseErrorState\n      message={props.message || 'There was a problem with your submission'}\n      retryText=\"Try Again\"\n      className={`form-error ${props.className || ''}`}\n      {...props}\n      showIcon={props.showIcon !== undefined ? props.showIcon : true}\n    />\n  );\n};\n\n/**\n * Error state for chart and visualization components\n */\nexport const VisualizationErrorState: React.FC<ErrorStateProps & { height?: number | string }> = ({ \n  height = '200px',\n  ...props \n}) => {\n  return (\n    <div style={{ height }} className=\"flex items-center justify-center\">\n      <BaseErrorState\n        message={props.message || 'Failed to render visualization'}\n        retryText=\"Reload Chart\"\n        className={`visualization-error w-full max-w-md ${props.className || ''}`}\n        {...props}\n        showIcon={props.showIcon !== undefined ? props.showIcon : true}\n      />\n    </div>\n  );\n};\n\n/**\n * Error state for image loading failures\n */\nexport const ImageErrorState: React.FC<ErrorStateProps & { width?: number | string; height?: number | string }> = ({ \n  width = '100%',\n  height = '150px',\n  ...props \n}) => {\n  return (\n    <div \n      style={{ width, height }} \n      className=\"flex flex-col items-center justify-center rounded border border-gray-300 bg-gray-100 dark:border-gray-700 dark:bg-gray-800\"\n    >\n      <FileX size={32} className=\"mb-2 text-gray-400\" />\n      <p className=\"text-sm text-gray-500 dark:text-gray-400\">\n        {props.message || 'Failed to load image'}\n      </p>\n      {props.onRetry && (\n        <button\n          onClick={props.onRetry}\n          className=\"mt-2 text-xs text-blue-500 hover:text-blue-700 dark:text-blue-400 dark:hover:text-blue-300\"\n        >\n          {props.retryText || 'Reload'}\n        </button>\n      )}\n    </div>\n  );\n};\n\n/**\n * Inline error state for form fields\n */\nexport const FieldErrorState: React.FC<{ error?: string }> = ({ error }) => {\n  if (!error) {\n    return null;\n  }\n  \n  return (\n    <p className=\"mt-1 flex items-center text-xs text-red-600 dark:text-red-400\">\n      <AlertCircle size={12} className=\"mr-1\" />\n      {error}\n    </p>\n  );\n};\n\n/**\n * Error state for empty search results\n */\nexport const EmptyResultsState: React.FC<{\n  message?: string;\n  resetSearch?: () => void;\n  resetText?: string;\n  className?: string;\n}> = ({\n  message = 'No results found',\n  resetSearch,\n  resetText = 'Clear Search',\n  className = '',\n}) => {\n  return (\n    <div className={`my-8 flex flex-col items-center justify-center text-center ${className}`}>\n      <div className=\"rounded-full bg-gray-100 p-3 dark:bg-gray-800\">\n        <AlertCircle size={24} className=\"text-gray-500 dark:text-gray-400\" />\n      </div>\n      <p className=\"mt-2 text-sm font-medium text-gray-700 dark:text-gray-300\">{message}</p>\n      {resetSearch && (\n        <button\n          onClick={resetSearch}\n          className=\"mt-3 text-sm font-medium text-blue-600 hover:text-blue-800 dark:text-blue-400 dark:hover:text-blue-300\"\n        >\n          {resetText}\n        </button>\n      )}\n    </div>\n  );\n};\n\n/**\n * Error severity levels for visual indication\n */\nexport type ErrorStateLevel = 'low' | 'medium' | 'high' | 'critical';\n\n/**\n * ComponentErrorState props\n */\nexport interface ComponentErrorStateProps {\n  /**\n   * Error message to display\n   */\n  message: string;\n  \n  /**\n   * Detailed technical error (only shown in dev mode)\n   */\n  error?: Error | string;\n  \n  /**\n   * Visual severity level of the error\n   * @default 'medium'\n   */\n  level?: ErrorStateLevel;\n  \n  /**\n   * Function to retry the operation that failed\n   */\n  onRetry?: () => void;\n  \n  /**\n   * Function to dismiss the error\n   */\n  onDismiss?: () => void;\n  \n  /**\n   * Name of the component that failed (for error reporting)\n   */\n  componentName?: string;\n  \n  /**\n   * Whether to automatically log the error to error service\n   * @default true\n   */\n  logError?: boolean;\n  \n  /**\n   * Error type for error logging service\n   */\n  errorType?: ErrorType;\n  \n  /**\n   * Error severity for error logging service\n   */\n  errorSeverity?: ErrorSeverity;\n  \n  /**\n   * Additional context data for error report\n   */\n  metadata?: Record<string, unknown>;\n  \n  /**\n   * Whether to show a compact version\n   * @default false\n   */\n  compact?: boolean;\n  \n  /**\n   * CSS class name\n   */\n  className?: string;\n  \n  /**\n   * Additional CSS styles\n   */\n  style?: React.CSSProperties;\n  \n  /**\n   * Element ID\n   */\n  id?: string;\n  \n  /**\n   * Icon to display next to the error message\n   */\n  icon?: React.ReactNode;\n  \n  /**\n   * Whether to show the stack trace (only in dev mode)\n   * @default false\n   */\n  showStack?: boolean;\n  \n  /**\n   * ID for testing\n   */\n  'data-testid'?: string;\n}\n\n/**\n * Maps error level to corresponding CSS class\n */\nconst getLevelClass = (level: ErrorStateLevel): string => {\n  switch (level) {\n    case 'low':\n      return 'gs-error-state--low';\n    case 'medium':\n      return 'gs-error-state--medium';\n    case 'high':\n      return 'gs-error-state--high';\n    case 'critical':\n      return 'gs-error-state--critical';\n  }\n};\n\n/**\n * Maps ErrorStateLevel to ErrorSeverity\n */\nconst mapLevelToSeverity = (level: ErrorStateLevel): ErrorSeverity => {\n  switch (level) {\n    case 'low':\n      return ErrorSeverity.LOW;\n    case 'medium':\n      return ErrorSeverity.MEDIUM;\n    case 'high':\n      return ErrorSeverity.HIGH;\n    case 'critical':\n      return ErrorSeverity.CRITICAL;\n    default:\n      return ErrorSeverity.MEDIUM;\n  }\n};\n\n/**\n * Component that displays a consistent error state UI for failed components\n */\nexport const ComponentErrorState = forwardRef<HTMLDivElement, ComponentErrorStateProps>(\n  ({\n    message,\n    error,\n    level = 'medium',\n    onRetry,\n    onDismiss,\n    componentName = 'unknown',\n    logError = true,\n    errorType = ErrorType.RUNTIME,\n    errorSeverity,\n    metadata = {},\n    compact = false,\n    className = '',\n    style,\n    id,\n    icon,\n    showStack = false,\n    'data-testid': dataTestId = 'component-error-state',\n  }, ref) => {\n    // Log error to error service on mount if enabled\n    React.useEffect(() => {\n      if (logError && error) {\n        const errorObj = typeof error === 'string' ? new Error(error) : error;\n        const severity = errorSeverity || mapLevelToSeverity(level);\n        \n        errorLoggingService.logError(\n          errorObj,\n          errorType,\n          severity,\n          {\n            componentName,\n            message,\n            ...metadata\n          }\n        );\n      }\n    }, [logError, error, errorType, errorSeverity, level, message, componentName, metadata]);\n    \n    // Event handlers\n    const handleRetry = useCallback(() => {\n      // Log retry attempt\n      try {\n        if (onRetry) {\n          onRetry();\n        }\n      } catch (retryError) {\n        console.error('[ComponentErrorState] Error in retry handler:', retryError);\n        \n        errorLoggingService.logError(\n          retryError instanceof Error ? retryError : new Error(String(retryError)),\n          ErrorType.RUNTIME,\n          ErrorSeverity.MEDIUM,\n          {\n            componentName,\n            action: 'retry',\n            ...metadata\n          }\n        );\n      }\n    }, [onRetry, componentName, metadata]);\n    \n    const handleDismiss = useCallback(() => {\n      if (onDismiss) {\n        onDismiss();\n      }\n    }, [onDismiss]);\n    \n    // Build CSS classes\n    const rootClasses = [\n      'gs-error-state',\n      getLevelClass(level),\n      compact ? 'gs-error-state--compact' : '',\n      className\n    ].filter(Boolean).join(' ');\n    \n    // Parse error details\n    const errorMessage = error instanceof Error ? error.message : String(error || '');\n    const errorStack = error instanceof Error ? error.stack : '';\n    const isDev = process.env.NODE_ENV === 'development';\n    \n    return (\n      <div\n        ref={ref}\n        id={id}\n        className={rootClasses}\n        style={style}\n        data-testid={dataTestId}\n        role=\"alert\"\n        aria-live=\"assertive\"\n      >\n        <div className=\"gs-error-state__content\">\n          {icon && (\n            <div className=\"gs-error-state__icon\">\n              {icon}\n            </div>\n          )}\n          \n          <div className=\"gs-error-state__message\">\n            <div className=\"gs-error-state__title\">{message}</div>\n            \n            {isDev && errorMessage && !compact && (\n              <div className=\"gs-error-state__details\">\n                {errorMessage}\n              </div>\n            )}\n            \n            {isDev && showStack && errorStack && !compact && (\n              <pre className=\"gs-error-state__stack\">\n                {errorStack}\n              </pre>\n            )}\n          </div>\n        </div>\n        \n        <div className=\"gs-error-state__actions\">\n          {onRetry && (\n            <button \n              className=\"gs-error-state__retry-button\"\n              onClick={handleRetry}\n              type=\"button\"\n            >\n              Retry\n            </button>\n          )}\n          \n          {onDismiss && (\n            <button \n              className=\"gs-error-state__dismiss-button\"\n              onClick={handleDismiss}\n              type=\"button\"\n            >\n              Dismiss\n            </button>\n          )}\n        </div>\n      </div>\n    );\n  }\n);\n\nComponentErrorState.displayName = 'ComponentErrorState';\n\nexport default ComponentErrorState; ","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/errors/ComponentSpecificErrorStates.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'width' is assigned a value but never used.","line":36,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":36,"endColumn":8},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'resourceId' is defined but never used.","line":249,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":249,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @context: ui-system, ui-error-handling, component-library\n * \n * ComponentSpecificErrorStates - Implementation of error states for specific UI components\n * These can be used as fallback UI for specific component types\n */\n\nimport * as React from 'react';\nimport { useState, useCallback } from 'react';\nimport { ErrorBoundary } from './ErrorBoundary';\nimport { ComponentErrorState, VisualizationErrorState, DataFetchErrorState } from './ComponentErrorState';\nimport { ErrorType, ErrorSeverity } from '../../../services/ErrorLoggingService';\n\n// Error state for the Chart component\nexport interface ChartErrorProps {\n  /** Width of the chart area */\n  width?: number | string;\n  \n  /** Height of the chart area */\n  height?: number | string;\n  \n  /** Chart title or label */\n  title?: string;\n  \n  /** Function to retry loading chart data */\n  onRetry?: () => void;\n  \n  /** Original error that caused the failure */\n  error?: Error;\n  \n  /** Additional class name */\n  className?: string;\n}\n\nexport const ChartErrorState: React.FC<ChartErrorProps> = ({\n  width = '100%',\n  height = '300px',\n  title = 'Chart',\n  onRetry,\n  error,\n  className = ''\n}) => {\n  return (\n    <VisualizationErrorState\n      message={`Unable to display ${title}`}\n      details={error?.message}\n      onRetry={onRetry}\n      height={height}\n      className={`chart-error ${className}`}\n    />\n  );\n};\n\n// Error state for the ResourceDisplay component\nexport interface ResourceDisplayErrorProps {\n  /** Resource type that failed to load */\n  resourceType?: string;\n  \n  /** Function to retry loading resource data */\n  onRetry?: () => void;\n  \n  /** Original error that caused the failure */\n  error?: Error;\n  \n  /** Whether to show in compact mode */\n  compact?: boolean;\n  \n  /** Additional class name */\n  className?: string;\n}\n\nexport const ResourceDisplayErrorState: React.FC<ResourceDisplayErrorProps> = ({\n  resourceType = 'Resource',\n  onRetry,\n  error,\n  compact = false,\n  className = ''\n}) => {\n  return (\n    <DataFetchErrorState\n      message={`Unable to load ${resourceType} data`}\n      details={error?.message}\n      onRetry={onRetry}\n      className={`resource-display-error ${compact ? 'compact' : ''} ${className}`}\n    />\n  );\n};\n\n// Error state for the ModuleCard component\nexport interface ModuleCardErrorProps {\n  /** Module name or ID */\n  moduleName?: string;\n  \n  /** Function to retry loading module data */\n  onRetry?: () => void;\n  \n  /** Original error */\n  error?: Error;\n  \n  /** Additional class name */\n  className?: string;\n}\n\nexport const ModuleCardErrorState: React.FC<ModuleCardErrorProps> = ({\n  moduleName = 'Module',\n  onRetry,\n  error,\n  className = ''\n}) => {\n  return (\n    <ComponentErrorState\n      message={`Unable to display ${moduleName}`}\n      error={error}\n      level=\"medium\"\n      onRetry={onRetry}\n      compact={true}\n      className={`module-card-error ${className}`}\n    />\n  );\n};\n\n// Example of a component that handles its own error states\nexport interface ResourceGraphProps {\n  /** Resource data to display */\n  data: Array<{ timestamp: number; value: number }>;\n  \n  /** Whether data is loading */\n  isLoading?: boolean;\n  \n  /** Error, if any */\n  error?: Error | null;\n  \n  /** Width of the graph */\n  width?: number | string;\n  \n  /** Height of the graph */\n  height?: number | string;\n  \n  /** Resource name */\n  resourceName?: string;\n  \n  /** Function to retry data loading */\n  onRetry?: () => void;\n  \n  /** Additional class name */\n  className?: string;\n}\n\nexport const ResourceGraph: React.FC<ResourceGraphProps> = ({\n  data,\n  isLoading = false,\n  error = null,\n  width = '100%',\n  height = '250px',\n  resourceName = 'Resource',\n  onRetry,\n  className = ''\n}) => {\n  // Handle different states with appropriate UI\n  if (isLoading) {\n    return (\n      <div \n        className={`resource-graph-loading ${className}`} \n        style={{ width, height }}\n      >\n        <div className=\"loading-spinner\"></div>\n        <p>Loading {resourceName} graph...</p>\n      </div>\n    );\n  }\n  \n  if (error) {\n    return (\n      <ChartErrorState\n        width={width}\n        height={height}\n        title={`${resourceName} Graph`}\n        error={error}\n        onRetry={onRetry}\n        className={className}\n      />\n    );\n  }\n  \n  if (!data || data.length === 0) {\n    return (\n      <div \n        className={`resource-graph-empty ${className}`}\n        style={{ width, height }}\n      >\n        <p>No {resourceName} data available</p>\n      </div>\n    );\n  }\n  \n  // Render the actual graph (simplified for example)\n  return (\n    <div \n      className={`resource-graph ${className}`}\n      style={{ width, height }}\n    >\n      {/* Graph implementation would go here */}\n      <div className=\"graph-container\">\n        {data.map((point, index) => (\n          <div \n            key={index}\n            className=\"graph-point\"\n            style={{ \n              left: `${(index / (data.length - 1)) * 100}%`,\n              bottom: `${(point.value / Math.max(...data.map(d => d.value))) * 80}%`\n            }}\n          />\n        ))}\n      </div>\n      <div className=\"graph-legend\">\n        <span>{resourceName} Trend</span>\n        <span>Last updated: {new Date(data[data.length - 1]?.timestamp || 0).toLocaleTimeString()}</span>\n      </div>\n    </div>\n  );\n};\n\n// Example of a component wrapped with an ErrorBoundary\nexport const ResourceGraphWithErrorBoundary: React.FC<ResourceGraphProps> = (props) => {\n  return (\n    <ErrorBoundary\n      componentName=\"ResourceGraph\"\n      errorType={ErrorType.RUNTIME}\n      errorSeverity={ErrorSeverity.MEDIUM}\n      fallback={({ error, resetErrorBoundary }) => (\n        <ChartErrorState\n          width={props.width}\n          height={props.height}\n          title={`${props.resourceName} Graph`}\n          error={error}\n          onRetry={resetErrorBoundary}\n        />\n      )}\n    >\n      <ResourceGraph {...props} />\n    </ErrorBoundary>\n  );\n};\n\n// Example usage with a multi-component UI\nexport const ResourcePanel: React.FC<{\n  resourceId: string;\n  resourceName: string;\n}> = ({ resourceId, resourceName }) => {\n  // Simulated data and states\n  const [data, setData] = useState<Array<{ timestamp: number; value: number }>>([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n  \n  const loadData = useCallback(() => {\n    setIsLoading(true);\n    setError(null);\n    \n    // Simulated API call\n    setTimeout(() => {\n      try {\n        // Randomly succeed or fail for demonstration\n        if (Math.random() > 0.7) {\n          throw new Error('Failed to fetch resource data');\n        }\n        \n        // Generate mock data on success\n        const mockData = Array.from({ length: 24 }, (_, i) => ({\n          timestamp: Date.now() - (23 - i) * 3600000,\n          value: Math.floor(Math.random() * 100)\n        }));\n        \n        setData(mockData);\n        setIsLoading(false);\n      } catch (err) {\n        setError(err instanceof Error ? err : new Error(String(err)));\n        setIsLoading(false);\n      }\n    }, 1000);\n  }, []);\n  \n  // Load data on mount\n  React.useEffect(() => {\n    loadData();\n  }, [loadData]);\n  \n  return (\n    <div className=\"resource-panel\">\n      <h3>{resourceName} Usage</h3>\n      \n      <ResourceGraphWithErrorBoundary\n        data={data}\n        isLoading={isLoading}\n        error={error}\n        resourceName={resourceName}\n        onRetry={loadData}\n      />\n      \n      <div className=\"resource-stats\">\n        {error ? (\n          <ResourceDisplayErrorState\n            resourceType={resourceName}\n            error={error}\n            onRetry={loadData}\n            compact={true}\n          />\n        ) : isLoading ? (\n          <p>Loading stats...</p>\n        ) : (\n          <>\n            <div className=\"stat-item\">\n              <span className=\"stat-label\">Current</span>\n              <span className=\"stat-value\">{data[data.length - 1]?.value || 0}</span>\n            </div>\n            <div className=\"stat-item\">\n              <span className=\"stat-label\">Average</span>\n              <span className=\"stat-value\">\n                {data.length ? Math.round(data.reduce((sum, point) => sum + point.value, 0) / data.length) : 0}\n              </span>\n            </div>\n            <div className=\"stat-item\">\n              <span className=\"stat-label\">Peak</span>\n              <span className=\"stat-value\">{data.length ? Math.max(...data.map(d => d.value)) : 0}</span>\n            </div>\n          </>\n        )}\n      </div>\n    </div>\n  );\n}; ","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/errors/ErrorBoundary.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/errors/ErrorFallback.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/errors/ErrorHandlingExamples.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/errors/NetworkErrorFallback.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'compact' is assigned a value but never used.","line":176,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":176,"endColumn":10}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @context: ui-system, ui-error-handling, component-library\n * \n * NetworkErrorFallback - A fallback component for network-related errors\n */\n\nimport React from 'react';\nimport { Wifi, WifiOff, Globe, RefreshCw } from 'lucide-react';\nimport { ErrorType, ErrorSeverity, errorLoggingService } from '../../../services/ErrorLoggingService';\nimport { ComponentErrorState } from './ComponentErrorState';\n\nexport interface NetworkErrorFallbackProps {\n  /** Error message or object */\n  error?: Error | string;\n  \n  /** Function to retry the failed operation */\n  onRetry?: () => void;\n  \n  /** Additional CSS class */\n  className?: string;\n  \n  /** Custom message to display */\n  message?: string;\n  \n  /** Show a more compact version */\n  compact?: boolean;\n  \n  /** Type of network operation that failed */\n  operationType?: 'fetch' | 'api' | 'connection' | 'websocket';\n  \n  /** URL that was being accessed when the error occurred */\n  url?: string;\n  \n  /** HTTP status code if available */\n  statusCode?: number;\n  \n  /** Additional metadata for error logging */\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Helper function to determine if an error is likely a network error\n */\nexport function isNetworkError(error: Error | unknown): boolean {\n  if (!error) {\n    return false;\n  }\n  \n  // Check for specific network error patterns\n  if (error instanceof Error) {\n    const errorMsg = error.message.toLowerCase();\n    return (\n      errorMsg.includes('network') ||\n      errorMsg.includes('offline') ||\n      errorMsg.includes('connection') ||\n      errorMsg.includes('internet') ||\n      errorMsg.includes('timeout') ||\n      errorMsg.includes('abort') ||\n      error.name === 'NetworkError' ||\n      error.name === 'AbortError' ||\n      error.name === 'TimeoutError'\n    );\n  }\n  \n  return false;\n}\n\n/**\n * Get appropriate message based on network error and operation type\n */\nfunction getDefaultMessage(operationType?: string, statusCode?: number): string {\n  // Handle based on status code if available\n  if (statusCode) {\n    if (statusCode === 401 || statusCode === 403) {\n      return 'Authentication failed. Please log in again.';\n    }\n    if (statusCode === 404) {\n      return 'The requested resource could not be found.';\n    }\n    if (statusCode >= 500) {\n      return 'The server encountered an error. Please try again later.';\n    }\n  }\n  \n  // Handle based on operation type\n  switch (operationType) {\n    case 'fetch':\n      return 'Failed to fetch data. Please check your connection.';\n    case 'api':\n      return 'API request failed. Please try again later.';\n    case 'connection':\n      return 'Connection lost. Please check your internet connection.';\n    case 'websocket':\n      return 'WebSocket connection failed. Real-time updates unavailable.';\n    default:\n      return 'Network error occurred. Please check your connection.';\n  }\n}\n\n/**\n * Component for displaying network-related errors with appropriate messaging and retry option\n */\nexport function NetworkErrorFallback({\n  error,\n  onRetry,\n  className = '',\n  message,\n  compact = false,\n  operationType,\n  url,\n  statusCode,\n  metadata = {}\n}: NetworkErrorFallbackProps) {\n  // Generate appropriate message\n  const errorMessage = message || getDefaultMessage(operationType, statusCode);\n  \n  // Determine icon based on the error type\n  const getIcon = () => {\n    if (statusCode === 401 || statusCode === 403) {\n      return <Wifi size={18} className=\"network-error-icon--auth\" />;\n    }\n    if (operationType === 'connection' || isNetworkError(error)) {\n      return <WifiOff size={18} className=\"network-error-icon--connection\" />;\n    }\n    return <Globe size={18} className=\"network-error-icon--general\" />;\n  };\n  \n  // Log error when component mounts\n  React.useEffect(() => {\n    if (error) {\n      const errorObj = typeof error === 'string' ? new Error(error) : error;\n      \n      errorLoggingService.logError(\n        errorObj,\n        ErrorType.NETWORK,\n        ErrorSeverity.MEDIUM,\n        {\n          component: 'NetworkErrorFallback',\n          operationType,\n          url,\n          statusCode,\n          ...metadata\n        }\n      );\n    }\n  }, [error, operationType, url, statusCode, metadata]);\n  \n  return (\n    <ComponentErrorState\n      message={errorMessage}\n      error={error}\n      level=\"medium\"\n      onRetry={onRetry}\n      componentName=\"NetworkError\"\n      errorType={ErrorType.NETWORK}\n      logError={false} // Already logged in useEffect\n      compact={compact}\n      className={`network-error-fallback ${className}`}\n      icon={getIcon()}\n      metadata={{\n        operationType,\n        url,\n        statusCode,\n        ...metadata\n      }}\n    />\n  );\n}\n\n/**\n * Compact inline version of the network error component\n */\nexport function InlineNetworkError({\n  message,\n  onRetry,\n  compact = true\n}: {\n  message?: string;\n  onRetry?: () => void;\n  compact?: boolean;\n}) {\n  return (\n    <div className=\"inline-network-error\">\n      <div className=\"inline-network-error__content\">\n        <WifiOff size={14} className=\"inline-network-error__icon\" />\n        <span className=\"inline-network-error__message\">\n          {message || 'Network error'}\n        </span>\n        \n        {onRetry && (\n          <button \n            className=\"inline-network-error__retry\"\n            onClick={onRetry}\n            type=\"button\"\n            aria-label=\"Retry connection\"\n          >\n            <RefreshCw size={12} />\n          </button>\n        )}\n      </div>\n    </div>\n  );\n}\n\nexport default NetworkErrorFallback; ","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/errors/ResourceLoadingError.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/errors/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/event/VirtualizedEventLog.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'showDetails' is assigned a value but never used.","line":94,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":94,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'index' is defined but never used.","line":208,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":208,"endColumn":10},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'eventId' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":219,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":219,"endColumn":18}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as React from 'react';\nimport { useCallback, useEffect, useRef, useState } from 'react';\nimport { FixedSizeList as List } from 'react-window';\nimport InfiniteLoader from 'react-window-infinite-loader';\nimport { ModuleEvent, ModuleEventType } from '../../../lib/modules/ModuleEvents';\n\nexport interface EventLogProps {\n  /**\n   * Array of events to display\n   */\n  events: ModuleEvent[];\n\n  /**\n   * Function to load more events\n   * Return true if there are more events to load, false otherwise\n   */\n  loadMoreEvents?: () => Promise<boolean>;\n\n  /**\n   * Maximum number of events to display\n   */\n  maxEvents?: number;\n\n  /**\n   * Height of the event log\n   */\n  height?: number;\n\n  /**\n   * Width of the event log\n   */\n  width?: string | number;\n\n  /**\n   * Row height\n   */\n  rowHeight?: number;\n\n  /**\n   * Filter function to filter events\n   */\n  filterEvent?: (event: ModuleEvent) => boolean;\n\n  /**\n   * Event handler for when an event is clicked\n   */\n  onEventClick?: (event: ModuleEvent) => void;\n\n  /**\n   * Whether to show the event details by default\n   */\n  showDetails?: boolean;\n\n  /**\n   * Custom renderer for event rows\n   */\n  rowRenderer?: (props: {\n    event: ModuleEvent;\n    index: number;\n    style: React.CSSProperties;\n    onClick: () => void;\n    isExpanded: boolean;\n  }) => React.ReactNode;\n\n  /**\n   * CSS class for the container\n   */\n  className?: string;\n\n  /**\n   * Whether to auto-scroll to the most recent event\n   */\n  autoScrollToRecent?: boolean;\n\n  /**\n   * Event type filter\n   */\n  eventTypeFilter?: ModuleEventType[];\n}\n\n/**\n * A virtualized event log that efficiently renders large sets of events\n * Supports infinite loading for fetching historical events on demand\n */\nexport const VirtualizedEventLog: React.FC<EventLogProps> = ({\n  events,\n  loadMoreEvents,\n  maxEvents = 1000,\n  height = 400,\n  width = '100%',\n  rowHeight = 48,\n  filterEvent,\n  onEventClick,\n  showDetails = false,\n  rowRenderer,\n  className = '',\n  autoScrollToRecent = true,\n  eventTypeFilter,\n}) => {\n  const listRef = useRef<List | null>(null);\n  const infiniteLoaderRef = useRef<InfiniteLoader | null>(null);\n  const containerRef = useRef<HTMLDivElement | null>(null);\n  const [containerSize, setContainerSize] = useState({ width: 0, height });\n  const [expandedEventIds, setExpandedEventIds] = useState<Set<string>>(new Set());\n  const [isLoadingMore, setIsLoadingMore] = useState(false);\n  const [hasMoreEvents, setHasMoreEvents] = useState(true);\n\n  // For storing reference without directly assigning to .current\n  const listRefCallback = useCallback((list: List | null) => {\n    listRef.current = list;\n  }, []);\n\n  // Filter events based on the provided filter\n  const filteredEvents = useCallback(() => {\n    let filtered = [...events];\n\n    // Apply event type filter\n    if (eventTypeFilter && eventTypeFilter.length > 0) {\n      filtered = filtered.filter(event => eventTypeFilter.includes(event?.type));\n    }\n\n    // Apply custom filter function\n    if (filterEvent) {\n      filtered = filtered.filter(filterEvent);\n    }\n\n    // Limit the number of events\n    return filtered.slice(0, maxEvents);\n  }, [events, filterEvent, eventTypeFilter, maxEvents]);\n\n  // Memoized filtered events\n  const displayedEvents = React.useMemo(() => filteredEvents(), [filteredEvents]);\n\n  // Handle container resizing\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    const resizeObserver = new ResizeObserver(entries => {\n      for (const entry of entries) {\n        const { width } = entry.contentRect;\n        setContainerSize(prev => ({ ...prev, width }));\n      }\n    });\n\n    resizeObserver.observe(containerRef.current);\n\n    // Initialize width\n    setContainerSize(prev => ({\n      ...prev,\n      width: containerRef.current?.clientWidth ?? 0,\n    }));\n\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }, []);\n\n  // Update height when prop changes\n  useEffect(() => {\n    setContainerSize(prev => ({ ...prev, height }));\n  }, [height]);\n\n  // Auto-scroll to most recent event\n  useEffect(() => {\n    if (autoScrollToRecent && listRef.current && displayedEvents.length > 0) {\n      listRef.current.scrollTo(0);\n    }\n  }, [displayedEvents.length, autoScrollToRecent]);\n\n  // Load more events\n  const loadMore = async () => {\n    if (isLoadingMore || !loadMoreEvents || !hasMoreEvents) return;\n\n    setIsLoadingMore(true);\n    try {\n      const hasMore = await loadMoreEvents();\n      setHasMoreEvents(hasMore);\n    } catch (error) {\n      console.error('Failed to load more events', error);\n    } finally {\n      setIsLoadingMore(false);\n    }\n  };\n\n  // Handle event click\n  const handleEventClick = (eventId: string) => {\n    const event = displayedEvents.find(e => e.moduleId + e.timestamp === eventId);\n    if (event) {\n      if (onEventClick) {\n        onEventClick(event);\n      }\n\n      setExpandedEventIds(prev => {\n        const newSet = new Set(prev);\n        if (newSet.has(eventId)) {\n          newSet.delete(eventId);\n        } else {\n          newSet.add(eventId);\n        }\n        return newSet;\n      });\n    }\n  };\n\n  // Default row renderer\n  const defaultRowRenderer = ({\n    event,\n    index,\n    style,\n    onClick,\n    isExpanded,\n  }: {\n    event: ModuleEvent;\n    index: number;\n    style: React.CSSProperties;\n    onClick: () => void;\n    isExpanded: boolean;\n  }) => {\n    const eventId = event?.moduleId + event?.timestamp;\n    return (\n      <div\n        style={style}\n        className={`flex flex-col border-b border-gray-700 p-2 transition-colors hover:bg-gray-700 ${\n          isExpanded ? 'bg-gray-700' : ''\n        }`}\n        onClick={onClick}\n      >\n        <div className=\"flex items-center justify-between\">\n          <div className=\"flex items-center space-x-2\">\n            <span className=\"rounded bg-blue-600 px-2 py-1 text-xs text-white\">{event?.type}</span>\n            <span className=\"text-sm text-gray-300\">{event?.moduleId}</span>\n          </div>\n          <span className=\"text-xs text-gray-400\">\n            {new Date(event?.timestamp).toLocaleTimeString()}\n          </span>\n        </div>\n\n        {isExpanded && (\n          <div className=\"mt-2 rounded bg-gray-800 p-2\">\n            <pre className=\"text-xs text-gray-300\">{JSON.stringify(event?.data, null, 2)}</pre>\n          </div>\n        )}\n      </div>\n    );\n  };\n\n  // Row virtualization component\n  const Row = ({ index, style }: { index: number; style: React.CSSProperties }) => {\n    const event = displayedEvents[index];\n    if (!event) return null;\n\n    const eventId = event?.moduleId + event?.timestamp;\n    const isExpanded = expandedEventIds.has(eventId);\n    const onClick = () => handleEventClick(eventId);\n\n    return rowRenderer\n      ? rowRenderer({ event, index, style, onClick, isExpanded })\n      : defaultRowRenderer({ event, index, style, onClick, isExpanded });\n  };\n\n  // If no events, show empty state\n  if (displayedEvents.length === 0) {\n    return (\n      <div\n        ref={containerRef}\n        className={`flex h-${height} w-full items-center justify-center rounded bg-gray-800 ${className}`}\n        style={{ height, width }}\n      >\n        <div className=\"text-center text-gray-400\">No events to display</div>\n      </div>\n    );\n  }\n\n  return (\n    <div className={className}>\n      <div\n        ref={containerRef}\n        className=\"overflow-hidden rounded bg-gray-800\"\n        style={{ height, width }}\n      >\n        <InfiniteLoader\n          ref={infiniteLoaderRef}\n          isItemLoaded={index => index < displayedEvents.length}\n          itemCount={hasMoreEvents ? displayedEvents.length + 1 : displayedEvents.length}\n          loadMoreItems={loadMore}\n        >\n          {({ onItemsRendered, ref }) => (\n            <List\n              className=\"scrollbar-thin scrollbar-thumb-gray-600 scrollbar-track-gray-800\"\n              height={containerSize.height}\n              width={containerSize.width}\n              itemCount={displayedEvents.length}\n              itemSize={rowHeight}\n              onItemsRendered={onItemsRendered}\n              ref={list => {\n                // For InfiniteLoader\n                ref(list);\n                // For our component's reference\n                listRefCallback(list);\n              }}\n            >\n              {Row}\n            </List>\n          )}\n        </InfiniteLoader>\n      </div>\n\n      <div className=\"mt-2 flex items-center justify-between text-xs text-gray-500\">\n        <span>Displaying {displayedEvents.length} events (virtualized)</span>\n        {isLoadingMore && <span>Loading more events...</span>}\n      </div>\n    </div>\n  );\n};\n\nexport default React.memo(VirtualizedEventLog);\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/examples/FactionCombatEquipmentExample.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/examples/SystemIntegrationExample.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/examples/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/game/FactionBadge.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/game/LazyMiniMap.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/game/MiniMap.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/game/ShipDisplay.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'useState' is defined but never used. Allowed unused vars must match /^ignored|^temp/u.","line":7,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'useEffect' is defined but never used. Allowed unused vars must match /^ignored|^temp/u.","line":7,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":29},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":202,"column":15,"nodeType":"MemberExpression","messageId":"limited","endLine":202,"endColumn":26,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[6557,6592],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":212,"column":15,"nodeType":"MemberExpression","messageId":"limited","endLine":212,"endColumn":26,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[6914,6945],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":227,"column":17,"nodeType":"MemberExpression","messageId":"limited","endLine":227,"endColumn":28,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[7467,7505],"text":""},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @context: ui-system, component-library, ship-system\n * \n * ShipDisplay component for showing ship information and status\n */\nimport * as React from 'react';\nimport { useState, useEffect } from 'react';\nimport { \n  Anchor, \n  Shield, \n  Zap, \n  Box, \n  Navigation,\n  AlertTriangle,\n  Eye, \n  Rocket\n} from 'lucide-react';\nimport { Ship } from '../../../types/ships/Ship';\n\n// Ship status types with visual indicators\nconst SHIP_STATUS_INDICATORS: Record<string, { icon: React.ReactNode; color: string; label: string }> = {\n  'idle': { \n    icon: <Anchor className=\"h-4 w-4\" />, \n    color: '#6c757d', \n    label: 'Idle' \n  },\n  'scanning': { \n    icon: <Eye className=\"h-4 w-4\" />, \n    color: '#2196f3', \n    label: 'Scanning' \n  },\n  'investigating': { \n    icon: <Navigation className=\"h-4 w-4\" />, \n    color: '#fb8c00', \n    label: 'Investigating' \n  },\n  'returning': { \n    icon: <Anchor className=\"h-4 w-4\" />, \n    color: '#4caf50', \n    label: 'Returning' \n  },\n  'combat': { \n    icon: <AlertTriangle className=\"h-4 w-4\" />, \n    color: '#f44336', \n    label: 'Combat' \n  },\n  'mining': { \n    icon: <Box className=\"h-4 w-4\" />, \n    color: '#ff9800', \n    label: 'Mining' \n  },\n};\n\n// Ship type icons\nconst SHIP_TYPE_ICONS: Record<string, React.ReactNode> = {\n  'recon': <Eye className=\"h-5 w-5\" />,\n  'mining': <Box className=\"h-5 w-5\" />,\n  'war': <Shield className=\"h-5 w-5\" />,\n  'ENERGY': <Zap className=\"h-5 w-5\" />\n};\n\ninterface ShipDisplayProps {\n  /**\n   * Ship data to display\n   */\n  ship: Ship;\n  \n  /**\n   * Whether to show detailed information\n   * @default false\n   */\n  detailed?: boolean;\n  \n  /**\n   * Whether to show ship controls\n   * @default false\n   */\n  showControls?: boolean;\n  \n  /**\n   * Callback when ship is selected\n   */\n  onSelect?: (shipId: string) => void;\n  \n  /**\n   * Class name for additional styling\n   */\n  className?: string;\n}\n\n/**\n * Component for displaying ship information and status\n */\nexport function ShipDisplay({\n  ship,\n  detailed = false,\n  showControls = false,\n  onSelect,\n  className = '',\n}: ShipDisplayProps) {\n  const statusInfo = SHIP_STATUS_INDICATORS[ship.status] || \n    { icon: <AlertTriangle className=\"h-4 w-4\" />, color: '#9e9e9e', label: 'Unknown' };\n  \n  const typeIcon = SHIP_TYPE_ICONS[ship.type] || <Rocket className=\"h-5 w-5\" />;\n  \n  const handleClick = () => {\n    if (onSelect) {\n      onSelect(ship.id);\n    }\n  };\n  \n  return (\n    <div \n      className={`ship-display p-4 border rounded-md ${className}`}\n      style={{ borderLeftColor: statusInfo.color, borderLeftWidth: '4px' }}\n      onClick={handleClick}\n      data-testid=\"ship-display\"\n      data-ship-id={ship.id}\n    >\n      <div className=\"ship-display__header flex justify-between items-center mb-2\">\n        <h3 className=\"ship-display__title text-lg font-semibold flex items-center\">\n          <span className=\"ship-display__type-icon mr-2\">{typeIcon}</span>\n          {ship.name}\n        </h3>\n        <div \n          className=\"ship-display__status flex items-center px-2 py-1 rounded-full\"\n          style={{ backgroundColor: `${statusInfo.color}20` }}\n        >\n          <span className=\"ship-display__status-icon mr-1\" style={{ color: statusInfo.color }}>\n            {statusInfo.icon}\n          </span>\n          <span className=\"ship-display__status-label text-sm\" style={{ color: statusInfo.color }}>\n            {statusInfo.label}\n          </span>\n        </div>\n      </div>\n      \n      {detailed && (\n        <div className=\"ship-display__details mt-3 text-sm\">\n          <div className=\"ship-display__capabilities grid grid-cols-2 gap-2\">\n            <div className=\"ship-display__capability flex items-center\">\n              <Rocket className=\"h-4 w-4 mr-1 text-gray-500\" />\n              <span className=\"text-gray-700\">Speed:</span>\n              <span className=\"ml-1 font-medium\">{ship.capabilities.speed}</span>\n            </div>\n            <div className=\"ship-display__capability flex items-center\">\n              <Navigation className=\"h-4 w-4 mr-1 text-gray-500\" />\n              <span className=\"text-gray-700\">Range:</span>\n              <span className=\"ml-1 font-medium\">{ship.capabilities.range}</span>\n            </div>\n            \n            {ship.capabilities.cargo !== undefined && (\n              <div className=\"ship-display__capability flex items-center\">\n                <Box className=\"h-4 w-4 mr-1 text-gray-500\" />\n                <span className=\"text-gray-700\">Cargo:</span>\n                <span className=\"ml-1 font-medium\">{ship.capabilities.cargo}</span>\n              </div>\n            )}\n            \n            {ship.capabilities.weapons !== undefined && (\n              <div className=\"ship-display__capability flex items-center\">\n                <Shield className=\"h-4 w-4 mr-1 text-gray-500\" />\n                <span className=\"text-gray-700\">Weapons:</span>\n                <span className=\"ml-1 font-medium\">{ship.capabilities.weapons}</span>\n              </div>\n            )}\n            \n            {ship.capabilities.stealth !== undefined && (\n              <div className=\"ship-display__capability flex items-center\">\n                <Eye className=\"h-4 w-4 mr-1 text-gray-500\" />\n                <span className=\"text-gray-700\">Stealth:</span>\n                <span className=\"ml-1 font-medium\">{ship.capabilities.stealth}</span>\n              </div>\n            )}\n          </div>\n          \n          {ship.currentTask && (\n            <div className=\"ship-display__task mt-3 pt-3 border-t border-gray-200\">\n              <div className=\"text-sm text-gray-500\">Current task:</div>\n              <div className=\"font-medium\">{ship.currentTask}</div>\n            </div>\n          )}\n          \n          <div className=\"ship-display__exp mt-2 flex items-center\">\n            <span className=\"text-gray-500 text-xs mr-1\">Experience:</span>\n            <div className=\"h-2 flex-grow bg-gray-200 rounded-full overflow-hidden\">\n              <div \n                className=\"h-full bg-blue-500 rounded-full\"\n                style={{ width: `${Math.min(ship.experience * 10, 100)}%` }}\n              ></div>\n            </div>\n          </div>\n        </div>\n      )}\n      \n      {showControls && (\n        <div className=\"ship-display__controls mt-3 pt-3 border-t border-gray-200 flex gap-2\">\n          <button \n            className=\"ship-display__control-btn px-3 py-1 bg-blue-500 text-white rounded-md text-sm hover:bg-blue-600 transition-colors\"\n            onClick={(e) => {\n              e.stopPropagation();\n              console.log('Assign task clicked');\n            }}\n          >\n            Assign Task\n          </button>\n          \n          <button \n            className=\"ship-display__control-btn px-3 py-1 bg-gray-200 text-gray-700 rounded-md text-sm hover:bg-gray-300 transition-colors\"\n            onClick={(e) => {\n              e.stopPropagation();\n              console.log('Details clicked');\n            }}\n          >\n            Details\n          </button>\n          \n          {ship.stealthActive !== undefined && (\n            <button \n              className={`ship-display__control-btn px-3 py-1 rounded-md text-sm transition-colors ${\n                ship.stealthActive \n                  ? 'bg-green-500 text-white hover:bg-green-600' \n                  : 'bg-gray-200 text-gray-700 hover:bg-gray-300'\n              }`}\n              onClick={(e) => {\n                e.stopPropagation();\n                console.log('Toggle stealth clicked');\n              }}\n            >\n              {ship.stealthActive ? 'Stealth On' : 'Stealth Off'}\n            </button>\n          )}\n        </div>\n      )}\n    </div>\n  );\n} ","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/game/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/layout/ResponsiveLayout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/modules/ModuleCard.tsx","messages":[{"ruleId":"no-unsafe-optional-chaining","severity":2,"message":"Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.","line":30,"column":23,"nodeType":"ChainExpression","messageId":"unsafeOptionalChain","endLine":30,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'updateStatus' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":64,"column":67,"nodeType":null,"messageId":"unusedVar","endLine":64,"endColumn":79}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as React from 'react';\nimport { memo, useEffect, useState } from 'react';\nimport { useModuleStatus } from '../../../hooks/modules/useModuleStatus';\nimport { moduleManager } from '../../../managers/module/ModuleManager';\nimport { BaseEvent, EventType } from '../../../types/events/EventTypes';\nimport { Badge } from '../common/Badge';\nimport './ModuleCard.css';\n\ninterface ModuleCardProps {\n  moduleId: string;\n  onSelect?: (moduleId: string) => void;\n  isSelected?: boolean;\n  showControls?: boolean;\n  compact?: boolean;\n}\n\n// Add MODULE_UPGRADE_PROGRESS to event types if not already defined\nconst MODULE_UPGRADE_PROGRESS = 'MODULE_UPGRADE_PROGRESS';\n\n// Fix useEventSubscription implementation\nconst useUpgradeProgressTracking = (moduleId: string): number => {\n  const [progress, setProgress] = useState(0);\n\n  useEffect(() => {\n    const handleUpgradeProgress = (event: BaseEvent) => {\n      if (\n        event?.moduleId === moduleId &&\n        event?.data &&\n        typeof event?.data === 'object' &&\n        'progress' in event?.data &&\n        typeof event?.data?.progress === 'number'\n      ) {\n        setProgress(event?.data?.progress);\n      }\n    };\n\n    // Subscribe to module events\n    const unsubscribe = moduleManager.subscribeToEvent(\n      MODULE_UPGRADE_PROGRESS as EventType,\n      handleUpgradeProgress\n    );\n\n    return () => {\n      if (unsubscribe) unsubscribe();\n    };\n  }, [moduleId]);\n\n  return progress;\n};\n\n/**\n * ModuleCard component for displaying module information\n *\n * Standardized component for displaying module information across the application\n * with consistent styling, update patterns, and event subscription handling.\n */\nexport const ModuleCard = memo(function ModuleCard({\n  moduleId,\n  onSelect,\n  isSelected = false,\n  showControls = true,\n  compact = false,\n}: ModuleCardProps) {\n  const { module, currentStatus, metrics, alerts, getStatusColor, updateStatus, isLoading, error } =\n    useModuleStatus(moduleId);\n\n  // Use the upgrade progress tracking hook\n  const upgradeProgress = useUpgradeProgressTracking(moduleId);\n\n  // Handle module selection\n  const handleSelect = () => {\n    if (onSelect) {\n      onSelect(moduleId);\n    }\n  };\n\n  // Handle module activation/deactivation\n  const handleToggleActive = (e: React.MouseEvent) => {\n    e.stopPropagation();\n    if (module) {\n      moduleManager.setModuleActive(moduleId, !module.isActive);\n    }\n  };\n\n  // Handle module upgrade\n  const handleUpgrade = (e: React.MouseEvent) => {\n    e.stopPropagation();\n    if (module) {\n      moduleManager.upgradeModule(moduleId);\n    }\n  };\n\n  // Return loading state\n  if (isLoading) {\n    return (\n      <div className={`module-card module-card--loading ${compact ? 'module-card--compact' : ''}`}>\n        <div className=\"module-card__loading\">Loading module data?...</div>\n      </div>\n    );\n  }\n\n  // Return error state\n  if (error || !module) {\n    return (\n      <div className={`module-card module-card--error ${compact ? 'module-card--compact' : ''}`}>\n        <div className=\"module-card__error\">{error || 'Module not found'}</div>\n      </div>\n    );\n  }\n\n  // Determine efficiency class based on metrics\n  const getEfficiencyClass = () => {\n    if (!metrics || !metrics.efficiency) return '';\n\n    if (metrics.efficiency >= 0.9) return 'module-card--high-efficiency';\n    if (metrics.efficiency >= 0.7) return 'module-card--medium-efficiency';\n    return 'module-card--low-efficiency';\n  };\n\n  return (\n    <div\n      className={`module-card ${isSelected ? 'module-card--selected' : ''} ${compact ? 'module-card--compact' : ''} ${getEfficiencyClass()} `}\n      onClick={handleSelect}\n      data-module-id={moduleId}\n      data-module-type={module.type}\n      data-module-level={module.level}\n    >\n      <div className=\"module-card__header\">\n        <h3 className=\"module-card__title\">{module.name}</h3>\n        <Badge\n          text={currentStatus}\n          color={getStatusColor(currentStatus)}\n          className=\"module-card__status-badge\"\n        />\n      </div>\n\n      {!compact && (\n        <div className=\"module-card__content\">\n          <div className=\"module-card__details\">\n            <div className=\"module-card__detail\">\n              <span className=\"module-card__detail-label\">Type:</span>\n              <span className=\"module-card__detail-value\">{module.type}</span>\n            </div>\n            <div className=\"module-card__detail\">\n              <span className=\"module-card__detail-label\">Level:</span>\n              <span className=\"module-card__detail-value\">{module.level}</span>\n            </div>\n            {metrics && (\n              <div className=\"module-card__detail\">\n                <span className=\"module-card__detail-label\">Efficiency:</span>\n                <span className=\"module-card__detail-value\">\n                  {(metrics.efficiency * 100).toFixed(1)}%\n                </span>\n              </div>\n            )}\n          </div>\n\n          {/* Show alerts if any */}\n          {alerts && alerts.length > 0 && (\n            <div className=\"module-card__alerts\">\n              <h4 className=\"module-card__section-title\">Alerts ({alerts.length})</h4>\n              <ul className=\"module-card__alert-list\">\n                {alerts.slice(0, 2).map((alert, index) => (\n                  <li\n                    key={index}\n                    className={`module-card__alert module-card__alert--${alert.level}`}\n                  >\n                    {alert.message}\n                  </li>\n                ))}\n                {alerts.length > 2 && (\n                  <li className=\"module-card__alert module-card__alert--more\">\n                    +{alerts.length - 2} more alerts\n                  </li>\n                )}\n              </ul>\n            </div>\n          )}\n\n          {/* Show upgrade progress if module is being upgraded */}\n          {upgradeProgress > 0 && upgradeProgress < 100 && (\n            <div className=\"module-card__upgrade-progress\">\n              <div className=\"module-card__progress-label\">Upgrading: {upgradeProgress}%</div>\n              <div className=\"module-card__progress-bar\">\n                <div\n                  className=\"module-card__progress-fill\"\n                  style={{ width: `${upgradeProgress}%` }}\n                ></div>\n              </div>\n            </div>\n          )}\n        </div>\n      )}\n\n      {/* Controls for activating/deactivating and upgrading */}\n      {showControls && (\n        <div className=\"module-card__controls\">\n          <button\n            className={`module-card__control-btn ${module.isActive ? 'module-card__control-btn--active' : ''}`}\n            onClick={handleToggleActive}\n          >\n            {module.isActive ? 'Deactivate' : 'Activate'}\n          </button>\n\n          <button\n            className=\"module-card__control-btn module-card__control-btn--upgrade\"\n            onClick={handleUpgrade}\n            disabled={currentStatus === 'upgrading' || upgradeProgress > 0}\n          >\n            Upgrade\n          </button>\n        </div>\n      )}\n    </div>\n  );\n});\n\n/**\n * CSS for the ModuleCard component\n */\nconst styles = `\n.module-card {\n  background-color: #f8f9fa;\n  border-radius: 8px;\n  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n  padding: 16px;\n  margin-bottom: 16px;\n  transition: all 0.2s ease-in-out;\n  cursor: pointer;\n  border-left: 4px solid #adb5bd;\n}\n\n.module-card:hover {\n  transform: translateY(-2px);\n  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);\n}\n\n.module-card--selected {\n  border-color: #007bff;\n  background-color: #f0f7ff;\n}\n\n.module-card--compact {\n  padding: 8px;\n}\n\n.module-card--loading,\n.module-card--error {\n  text-align: center;\n  padding: 24px;\n  color: #6c757d;\n}\n\n.module-card--error {\n  color: #dc3545;\n}\n\n.module-card--high-efficiency {\n  border-color: #28a745;\n}\n\n.module-card--medium-efficiency {\n  border-color: #ffc107;\n}\n\n.module-card--low-efficiency {\n  border-color: #dc3545;\n}\n\n.module-card__header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-bottom: 12px;\n}\n\n.module-card__title {\n  margin: 0;\n  font-size: 18px;\n  font-weight: 600;\n}\n\n.module-card__status-badge {\n  font-size: 12px;\n  padding: 4px 8px;\n}\n\n.module-card__content {\n  margin-bottom: 16px;\n}\n\n.module-card__details {\n  display: grid;\n  grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));\n  gap: 8px;\n  margin-bottom: 12px;\n}\n\n.module-card__detail {\n  display: flex;\n  flex-direction: column;\n}\n\n.module-card__detail-label {\n  font-size: 12px;\n  color: #6c757d;\n  margin-bottom: 2px;\n}\n\n.module-card__detail-value {\n  font-weight: 500;\n}\n\n.module-card__alerts {\n  margin-top: 12px;\n}\n\n.module-card__section-title {\n  font-size: 14px;\n  margin-bottom: 8px;\n  color: #495057;\n}\n\n.module-card__alert-list {\n  list-style: none;\n  padding: 0;\n  margin: 0;\n}\n\n.module-card__alert {\n  padding: 6px 8px;\n  border-radius: 4px;\n  margin-bottom: 4px;\n  font-size: 12px;\n}\n\n.module-card__alert--info {\n  background-color: #cfe2ff;\n  color: #084298;\n}\n\n.module-card__alert--warning {\n  background-color: #fff3cd;\n  color: #664d03;\n}\n\n.module-card__alert--error {\n  background-color: #f8d7da;\n  color: #842029;\n}\n\n.module-card__alert--critical {\n  background-color: #f8d7da;\n  color: #842029;\n  font-weight: bold;\n}\n\n.module-card__alert--more {\n  text-align: center;\n  background-color: #e9ecef;\n  color: #495057;\n}\n\n.module-card__upgrade-progress {\n  margin-top: 12px;\n}\n\n.module-card__progress-label {\n  font-size: 12px;\n  margin-bottom: 4px;\n  color: #495057;\n}\n\n.module-card__progress-bar {\n  height: 6px;\n  background-color: #e9ecef;\n  border-radius: 3px;\n  overflow: hidden;\n}\n\n.module-card__progress-fill {\n  height: 100%;\n  background-color: #007bff;\n  transition: width 0.3s ease;\n}\n\n.module-card__controls {\n  display: flex;\n  justify-content: space-between;\n  gap: 8px;\n}\n\n.module-card__control-btn {\n  flex: 1;\n  padding: 8px;\n  border: none;\n  border-radius: 4px;\n  background-color: #e9ecef;\n  color: #495057;\n  font-weight: 500;\n  cursor: pointer;\n  transition: all 0.2s;\n}\n\n.module-card__control-btn:hover {\n  background-color: #dee2e6;\n}\n\n.module-card__control-btn--active {\n  background-color: #cfe2ff;\n  color: #084298;\n}\n\n.module-card__control-btn--upgrade {\n  background-color: #d1e7dd;\n  color: #0f5132;\n}\n\n.module-card__control-btn--upgrade:hover {\n  background-color: #a3cfbb;\n}\n\n.module-card__control-btn:disabled {\n  opacity: 0.5;\n  cursor: not-allowed;\n}\n`;\n\n// Add the styles to the document head\nif (typeof document !== 'undefined') {\n  const styleElement = document.createElement('style');\n  styleElement.textContent = styles;\n  document.head.appendChild(styleElement);\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/modules/ModuleControls.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/modules/ModuleGrid.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/modules/ModuleHUD.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/modules/ModuleStatusDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/modules/ModuleStatusIndicator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/modules/ModuleUpgradeDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/modules/ModuleUpgradeVisualization.tsx","messages":[{"ruleId":"no-unsafe-optional-chaining","severity":2,"message":"Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.","line":122,"column":23,"nodeType":"ChainExpression","messageId":"unsafeOptionalChain","endLine":122,"endColumn":34}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useCallback, useEffect, useMemo, useState } from 'react';\nimport { useModuleStatus } from '../../../hooks/modules/useModuleStatus';\nimport { moduleManager } from '../../../managers/module/ModuleManager';\nimport { BaseEvent, EventType } from '../../../types/events/EventTypes';\nimport { ResourceType } from './../../../types/resources/ResourceTypes';\nimport './ModuleUpgradeVisualization.css';\n\n// Progress tracker for the upgrade process\nconst MODULE_UPGRADE_PROGRESS = 'MODULE_UPGRADE_PROGRESS';\n\ninterface ModuleUpgradeVisualizationProps {\n  moduleId: string;\n  onUpgradeComplete?: () => void;\n  className?: string;\n  showDetails?: boolean;\n}\n\ninterface UpgradeStage {\n  name: string;\n  description: string;\n  duration: number; // in seconds\n  startPercentage: number;\n  endPercentage: number;\n}\n\n/**\n * ModuleUpgradeVisualization component\n *\n * Provides a visual representation of the module upgrade process with multiple stages\n * and real-time progress updates.\n */\nexport function ModuleUpgradeVisualization({\n  moduleId,\n  onUpgradeComplete,\n  className = '',\n  showDetails = true,\n}: ModuleUpgradeVisualizationProps) {\n  const { module, currentStatus, updateStatus } = useModuleStatus(moduleId);\n  const [progress, setProgress] = useState(0);\n  const [currentStage, setCurrentStage] = useState(0);\n  const [isUpgrading, setIsUpgrading] = useState(false);\n  const [estimatedTimeRemaining, setEstimatedTimeRemaining] = useState<number | null>(null);\n  const [startTime, setStartTime] = useState<number | null>(null);\n\n  // Define upgrade stages based on module type\n  const upgradeStages = useMemo((): UpgradeStage[] => {\n    if (!module) return [];\n\n    // Default stages\n    const stages: UpgradeStage[] = [\n      {\n        name: 'Preparation',\n        description: 'Preparing module for upgrade',\n        duration: 5,\n        startPercentage: 0,\n        endPercentage: 15,\n      },\n      {\n        name: 'Core Upgrade',\n        description: 'Upgrading core systems',\n        duration: 15,\n        startPercentage: 15,\n        endPercentage: 60,\n      },\n      {\n        name: 'Integration',\n        description: 'Integrating new systems',\n        duration: 10,\n        startPercentage: 60,\n        endPercentage: 85,\n      },\n      {\n        name: 'Testing',\n        description: 'Testing upgraded systems',\n        duration: 5,\n        startPercentage: 85,\n        endPercentage: 95,\n      },\n      {\n        name: 'Finalization',\n        description: 'Finalizing upgrades',\n        duration: 2,\n        startPercentage: 95,\n        endPercentage: 100,\n      },\n    ];\n\n    // Customize stages based on module type\n    switch (module.type as string) {\n      case 'mining':\n        stages[1].description = 'Upgrading extraction systems';\n        stages[2].description = 'Calibrating resource filters';\n        break;\n      case ResourceType.ENERGY:\n        stages[1].description = 'Upgrading power converters';\n        stages[2].description = 'Stabilizing energy flow';\n        break;\n      case ResourceType.RESEARCH:\n        stages[1].description = 'Upgrading processing units';\n        stages[2].description = 'Loading new research algorithms';\n        break;\n      default:\n        // Keep default descriptions\n        break;\n    }\n\n    return stages;\n  }, [module]);\n\n  // Calculate total upgrade duration\n  const totalDuration = useMemo(() => {\n    return upgradeStages.reduce((sum, stage) => sum + stage.duration, 0);\n  }, [upgradeStages]);\n\n  // Subscribe to upgrade progress events\n  useEffect(() => {\n    const handleUpgradeProgress = (event: BaseEvent) => {\n      if (\n        event?.moduleId === moduleId &&\n        event?.data &&\n        typeof event?.data === 'object' &&\n        'progress' in event?.data &&\n        typeof event?.data?.progress === 'number'\n      ) {\n        const newProgress = event?.data?.progress;\n        setProgress(newProgress);\n\n        // Determine current stage\n        const stageIndex = upgradeStages.findIndex(\n          stage => newProgress >= stage.startPercentage && newProgress < stage.endPercentage\n        );\n\n        if (stageIndex !== -1) {\n          setCurrentStage(stageIndex);\n        }\n\n        // Update time remaining if upgrade is in progress\n        if (newProgress > 0 && newProgress < 100 && startTime) {\n          const elapsedSeconds = (Date.now() - startTime) / 1000;\n          const estimatedTotalSeconds = (elapsedSeconds * 100) / newProgress;\n          const remainingSeconds = estimatedTotalSeconds - elapsedSeconds;\n          setEstimatedTimeRemaining(remainingSeconds);\n        }\n\n        // Handle completion\n        if (newProgress >= 100) {\n          setIsUpgrading(false);\n          setEstimatedTimeRemaining(null);\n          if (onUpgradeComplete) {\n            onUpgradeComplete();\n          }\n        }\n      }\n    };\n\n    // Start monitoring for upgrade progress\n    const unsubscribe = moduleManager.subscribeToEvent(\n      MODULE_UPGRADE_PROGRESS as EventType,\n      handleUpgradeProgress\n    );\n\n    // Check if module is already upgrading\n    if (currentStatus === 'upgrading' && !isUpgrading) {\n      setIsUpgrading(true);\n      setStartTime(Date.now());\n    } else if (currentStatus !== 'upgrading' && isUpgrading) {\n      setIsUpgrading(false);\n      setProgress(0);\n      setCurrentStage(0);\n      setEstimatedTimeRemaining(null);\n    }\n\n    return () => {\n      unsubscribe();\n    };\n  }, [moduleId, upgradeStages, currentStatus, isUpgrading, onUpgradeComplete, startTime]);\n\n  // Format time remaining\n  const formatTimeRemaining = useCallback((seconds: number) => {\n    if (seconds < 60) {\n      return `${Math.ceil(seconds)}s`;\n    }\n\n    const minutes = Math.floor(seconds / 60);\n    const remainingSeconds = Math.ceil(seconds % 60);\n    return `${minutes}m ${remainingSeconds}s`;\n  }, []);\n\n  // Cancel upgrade\n  const handleCancelUpgrade = useCallback(() => {\n    if (isUpgrading && module) {\n      // Return to previous status\n      updateStatus('active', 'Upgrade cancelled by user');\n      setIsUpgrading(false);\n      setProgress(0);\n      setEstimatedTimeRemaining(null);\n    }\n  }, [isUpgrading, module, updateStatus]);\n\n  // Start upgrade simulation\n  const handleStartUpgrade = useCallback(() => {\n    if (!isUpgrading && module) {\n      // Start the upgrade process\n      moduleManager.upgradeModule(moduleId);\n      setIsUpgrading(true);\n      setProgress(0);\n      setCurrentStage(0);\n      setStartTime(Date.now());\n\n      // Simulate sending upgrade progress events\n      const simulateProgress = () => {\n        let currentProgress = 0;\n        let lastUpdate = Date.now();\n\n        // Simulate progress for each stage\n        upgradeStages.forEach((stage, index) => {\n          const stageDuration = stage.duration * 1000; // Convert to ms\n          const stageProgress = stage.endPercentage - stage.startPercentage;\n          const updatesPerStage = Math.max(5, Math.floor(stageDuration / 500)); // Update every 500ms\n          const progressPerUpdate = stageProgress / updatesPerStage;\n\n          // Simulate each update in this stage\n          for (let i = 0; i < updatesPerStage; i++) {\n            const delay = lastUpdate - Date.now() + stageDuration / updatesPerStage;\n            lastUpdate += stageDuration / updatesPerStage;\n\n            setTimeout(() => {\n              // Only update if still upgrading\n              if (!isUpgrading) return;\n\n              currentProgress += progressPerUpdate;\n\n              // Emit the progress event\n              moduleManager.publishEvent({\n                type: MODULE_UPGRADE_PROGRESS as EventType,\n                moduleId,\n                moduleType: module.type,\n                timestamp: Date.now(),\n                data: {\n                  progress: Math.min(Math.round(currentProgress * 10) / 10, 100),\n                  stage: index,\n                  stageName: stage.name,\n                },\n              });\n\n              // Handle completion\n              if (currentProgress >= 100) {\n                // Complete the upgrade after a short delay\n                setTimeout(() => {\n                  // Update module level and status\n                  moduleManager.publishEvent({\n                    type: EventType.MODULE_UPGRADED,\n                    moduleId,\n                    moduleType: module.type,\n                    timestamp: Date.now(),\n                    data: {\n                      oldLevel: module.level,\n                      newLevel: module.level + 1,\n                    },\n                  });\n\n                  updateStatus('active', 'Upgrade completed successfully');\n                }, 500);\n              }\n            }, delay);\n          }\n        });\n      };\n\n      // Start the simulation\n      simulateProgress();\n    }\n  }, [isUpgrading, module, moduleId, upgradeStages, updateStatus]);\n\n  // No module to upgrade\n  if (!module) {\n    return (\n      <div\n        className={`module-upgrade-visualization module-upgrade-visualization--error ${className}`}\n      >\n        <div className=\"module-upgrade-visualization__error\">Module not found</div>\n      </div>\n    );\n  }\n\n  return (\n    <div\n      className={`module-upgrade-visualization ${isUpgrading ? 'module-upgrade-visualization--active' : ''} ${className}`}\n    >\n      <div className=\"module-upgrade-visualization__header\">\n        <h3 className=\"module-upgrade-visualization__title\">\n          {isUpgrading ? `Upgrading ${module.name}` : `Upgrade ${module.name}`}\n        </h3>\n        {isUpgrading && (\n          <div className=\"module-upgrade-visualization__level\">\n            Level {module.level} â†’ {module.level + 1}\n          </div>\n        )}\n      </div>\n\n      {showDetails && !isUpgrading && (\n        <div className=\"module-upgrade-visualization__details\">\n          <div className=\"module-upgrade-visualization__detail\">\n            <span className=\"module-upgrade-visualization__detail-label\">Current Level:</span>\n            <span className=\"module-upgrade-visualization__detail-value\">{module.level}</span>\n          </div>\n          <div className=\"module-upgrade-visualization__detail\">\n            <span className=\"module-upgrade-visualization__detail-label\">Upgrade Time:</span>\n            <span className=\"module-upgrade-visualization__detail-value\">\n              {formatTimeRemaining(totalDuration)}\n            </span>\n          </div>\n          <div className=\"module-upgrade-visualization__detail\">\n            <span className=\"module-upgrade-visualization__detail-label\">Status:</span>\n            <span className=\"module-upgrade-visualization__detail-value\">{currentStatus}</span>\n          </div>\n        </div>\n      )}\n\n      {isUpgrading && (\n        <div className=\"module-upgrade-visualization__progress-container\">\n          <div className=\"module-upgrade-visualization__progress-info\">\n            <div className=\"module-upgrade-visualization__stage\">\n              {upgradeStages[currentStage]?.name || 'Upgrading'}\n            </div>\n            <div className=\"module-upgrade-visualization__percentage\">{progress}%</div>\n          </div>\n\n          <div className=\"module-upgrade-visualization__progress-bar\">\n            <div\n              className=\"module-upgrade-visualization__progress-fill\"\n              style={{ width: `${progress}%` }}\n            ></div>\n          </div>\n\n          {showDetails && (\n            <div className=\"module-upgrade-visualization__stage-description\">\n              {upgradeStages[currentStage]?.description || 'Upgrading module'}\n            </div>\n          )}\n\n          {estimatedTimeRemaining !== null && (\n            <div className=\"module-upgrade-visualization__time-remaining\">\n              Estimated time remaining: {formatTimeRemaining(estimatedTimeRemaining)}\n            </div>\n          )}\n\n          <div className=\"module-upgrade-visualization__stages\">\n            {upgradeStages.map((stage, index) => (\n              <div\n                key={index}\n                className={`module-upgrade-visualization__stage-marker ${index === currentStage ? 'module-upgrade-visualization__stage-marker--active' : ''} ${index < currentStage ? 'module-upgrade-visualization__stage-marker--completed' : ''} `}\n                style={{ left: `${stage.startPercentage}%` }}\n                title={stage.name}\n              >\n                {index + 1}\n              </div>\n            ))}\n          </div>\n        </div>\n      )}\n\n      <div className=\"module-upgrade-visualization__controls\">\n        {!isUpgrading ? (\n          <button\n            className=\"module-upgrade-visualization__start-btn\"\n            onClick={handleStartUpgrade}\n            disabled={currentStatus === 'upgrading'}\n          >\n            Start Upgrade\n          </button>\n        ) : (\n          <button\n            className=\"module-upgrade-visualization__cancel-btn\"\n            onClick={handleCancelUpgrade}\n          >\n            Cancel Upgrade\n          </button>\n        )}\n      </div>\n    </div>\n  );\n}\n\nconst styles = `\n.module-upgrade-visualization {\n  background-color: #f8f9fa;\n  border-radius: 8px;\n  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n  padding: 20px;\n  margin-bottom: 20px;\n  border-left: 4px solid #6c757d;\n}\n\n.module-upgrade-visualization--active {\n  border-left-color: #007bff;\n  background-color: #f0f7ff;\n}\n\n.module-upgrade-visualization--error {\n  border-left-color: #dc3545;\n}\n\n.module-upgrade-visualization__header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-bottom: 15px;\n}\n\n.module-upgrade-visualization__title {\n  margin: 0;\n  font-size: 18px;\n  font-weight: 600;\n}\n\n.module-upgrade-visualization__level {\n  font-weight: 600;\n  color: #007bff;\n}\n\n.module-upgrade-visualization__details {\n  display: grid;\n  grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));\n  gap: 10px;\n  margin-bottom: 20px;\n}\n\n.module-upgrade-visualization__detail {\n  display: flex;\n  flex-direction: column;\n}\n\n.module-upgrade-visualization__detail-label {\n  font-size: 12px;\n  color: #6c757d;\n  margin-bottom: 4px;\n}\n\n.module-upgrade-visualization__detail-value {\n  font-weight: 500;\n}\n\n.module-upgrade-visualization__progress-container {\n  margin-bottom: 20px;\n  position: relative;\n}\n\n.module-upgrade-visualization__progress-info {\n  display: flex;\n  justify-content: space-between;\n  margin-bottom: 8px;\n}\n\n.module-upgrade-visualization__stage {\n  font-weight: 500;\n}\n\n.module-upgrade-visualization__percentage {\n  font-weight: 600;\n  color: #007bff;\n}\n\n.module-upgrade-visualization__progress-bar {\n  height: 8px;\n  background-color: #e9ecef;\n  border-radius: 4px;\n  overflow: hidden;\n  margin-bottom: 16px;\n}\n\n.module-upgrade-visualization__progress-fill {\n  height: 100%;\n  background-color: #007bff;\n  transition: width 0.5s ease-in-out;\n}\n\n.module-upgrade-visualization__stage-description {\n  font-size: 14px;\n  color: #495057;\n  margin-bottom: 10px;\n}\n\n.module-upgrade-visualization__time-remaining {\n  font-size: 12px;\n  color: #6c757d;\n  margin-bottom: 15px;\n  text-align: right;\n}\n\n.module-upgrade-visualization__stages {\n  position: relative;\n  height: 30px;\n  margin-bottom: 10px;\n}\n\n.module-upgrade-visualization__stage-marker {\n  position: absolute;\n  width: 24px;\n  height: 24px;\n  border-radius: 50%;\n  background-color: #e9ecef;\n  border: 2px solid #adb5bd;\n  color: #495057;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  font-size: 12px;\n  font-weight: 600;\n  transform: translateX(-50%);\n  transition: all 0.3s ease;\n}\n\n.module-upgrade-visualization__stage-marker--active {\n  background-color: #007bff;\n  border-color: #0056b3;\n  color: white;\n  transform: translateX(-50%) scale(1.15);\n}\n\n.module-upgrade-visualization__stage-marker--completed {\n  background-color: #28a745;\n  border-color: #1e7e34;\n  color: white;\n}\n\n.module-upgrade-visualization__controls {\n  display: flex;\n  justify-content: center;\n}\n\n.module-upgrade-visualization__start-btn,\n.module-upgrade-visualization__cancel-btn {\n  padding: 8px 16px;\n  border-radius: 4px;\n  font-weight: 500;\n  cursor: pointer;\n  border: none;\n  transition: all 0.2s;\n}\n\n.module-upgrade-visualization__start-btn {\n  background-color: #007bff;\n  color: white;\n}\n\n.module-upgrade-visualization__start-btn:hover {\n  background-color: #0056b3;\n}\n\n.module-upgrade-visualization__start-btn:disabled {\n  background-color: #b6d4fe;\n  cursor: not-allowed;\n}\n\n.module-upgrade-visualization__cancel-btn {\n  background-color: #dc3545;\n  color: white;\n}\n\n.module-upgrade-visualization__cancel-btn:hover {\n  background-color: #c82333;\n}\n\n.module-upgrade-visualization__error {\n  color: #dc3545;\n  text-align: center;\n  padding: 20px;\n}\n`;\n\n// Add the styles to the document head\nif (typeof document !== 'undefined') {\n  const styleElement = document.createElement('style');\n  styleElement.textContent = styles;\n  document.head.appendChild(styleElement);\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/modules/SubModuleHUD.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/modules/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/optimized/MemoizedComponent.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/optimized/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/overlays/Dialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/overlays/Drawer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/overlays/Modal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/overlays/Popover.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/performance/AdvancedMetricAnalysis.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/performance/AnimationFrameManagerDemo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/performance/AnimationPerformanceProfilerDemo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/performance/BatchedUpdateDemo.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_elapsed' is defined but never used.","line":224,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":224,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_deltaTime' is defined but never used.","line":224,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":224,"endColumn":30}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as d3 from 'd3';\nimport * as React from 'react';\nimport { useEffect, useRef, useState } from 'react';\nimport {\n  animationFrameManager,\n  AnimationPriority,\n} from '../../../utils/performance/D3AnimationFrameManager';\nimport {\n  BatchOperationPriority,\n  batchUpdateManager,\n  optimizeWithBatchedUpdates,\n} from '../../../utils/performance/D3BatchedUpdates';\n\n// Define D3 selection type\ntype D3SVGSelection = d3.Selection<SVGSVGElement, unknown, null, undefined>;\n\ninterface CircleElement {\n  id: number;\n  x: number;\n  y: number;\n  radius: number;\n  color: string;\n  velocity?: {\n    x: number;\n    y: number;\n  };\n}\n\ninterface BatchedUpdateDemoProps {\n  width?: number;\n  height?: number;\n}\n\n/**\n * BatchedUpdateDemo\n *\n * A demonstration of the batched updates system for D3 animations. This component\n * shows the performance benefits of batching DOM operations by displaying two\n * identical animations side by side - one using standard D3 updates and another\n * using our batched update system.\n *\n * Features:\n * - Real-time FPS comparison between batched and unbatched animations\n * - Statistics display showing pending operations and completed operations\n * - Controls for customizing the animation complexity\n * - Performance impact visualization\n * - Timeline visualization showing when batched operations are processed\n */\nconst BatchedUpdateDemo: React.FC<BatchedUpdateDemoProps> = ({ width = 900, height = 600 }) => {\n  // References\n  const standardSvgRef = useRef<SVGSVGElement>(null);\n  const batchedSvgRef = useRef<SVGSVGElement>(null);\n  const statsRef = useRef<HTMLDivElement>(null);\n\n  // Animation configuration state\n  const [isAnimating, setIsAnimating] = useState(false);\n  const [elementCount, setElementCount] = useState(100);\n  const [updateFrequency, setUpdateFrequency] = useState(10); // ms between updates\n  const [animationComplexity, setAnimationComplexity] = useState(50); // % of complexity\n  const [batchingEnabled, setBatchingEnabled] = useState(true);\n  const [priorityLevel, setPriorityLevel] = useState<BatchOperationPriority>('normal');\n\n  // Performance metrics\n  const [standardFps, setStandardFps] = useState(0);\n  const [batchedFps, setBatchedFps] = useState(0);\n  const [batchStats, setBatchStats] = useState({\n    pendingReads: 0,\n    pendingWrites: 0,\n    totalPending: 0,\n    completedOperations: 0,\n  });\n\n  // Animation state (shared)\n  type ElementType = { id: number; x: number; y: number; radius: number; color: string };\n\n  const [elements, setElements] = useState<ElementType[]>([]);\n  const [animationId, setAnimationId] = useState<string | null>(null);\n\n  // Initialize elements\n  useEffect(() => {\n    const newElements = [];\n    for (let i = 0; i < elementCount; i++) {\n      newElements.push({\n        id: i,\n        x: Math.random() * (width / 2 - 40) + 20,\n        y: Math.random() * (height - 40) + 20,\n        radius: Math.random() * 20 + 5,\n        color: d3.interpolateRainbow(Math.random()),\n      });\n    }\n    setElements(newElements);\n  }, [elementCount, width, height]);\n\n  // Set up standard (non-batched) visualization\n  useEffect(() => {\n    if (!standardSvgRef.current || elements.length === 0) return;\n\n    const svg = d3.select(standardSvgRef.current);\n\n    // Clear previous elements\n    svg.selectAll('*').remove();\n\n    // Create circles for each element\n    // Using type assertions to handle D3's complex typing\n    (svg as D3SVGSelection)\n      .selectAll<SVGCircleElement, CircleElement>('circle')\n      .data<CircleElement>(elements, (d: CircleElement) => d.id)\n      .enter()\n      .append('circle')\n      .attr('cx', (d: CircleElement) => d.x)\n      .attr('cy', (d: CircleElement) => d.y)\n      .attr('r', (d: CircleElement) => d.radius)\n      .attr('fill', (d: CircleElement) => d.color)\n      .attr('stroke', '#333')\n      .attr('stroke-width', 1);\n\n    // Set up animation if active\n    if (isAnimating) {\n      const updateInterval = setInterval(() => {\n        // Create new positions for each element\n        const updatedElements = elements.map(el => {\n          // More complex movement based on complexity level\n          const complexityFactor = animationComplexity / 100;\n          const noise = Math.sin(Date.now() * 0.001 + el.id) * 10 * complexityFactor;\n\n          return {\n            ...el,\n            x: Math.max(10, Math.min(width / 2 - 10, el.x + (Math.random() - 0.5) * 10 + noise)),\n            y: Math.max(10, Math.min(height - 10, el.y + (Math.random() - 0.5) * 10 + noise)),\n            radius: Math.max(3, el.radius + (Math.random() - 0.5) * 2 * complexityFactor),\n            color: d3.interpolateRgb(\n              el.color,\n              d3.interpolateRainbow(Math.random() * complexityFactor)\n            )(0.05),\n          };\n        });\n\n        // Standard D3 update (potential layout thrashing)\n        (svg as D3SVGSelection)\n          .selectAll<SVGCircleElement, CircleElement>('circle')\n          .data<CircleElement>(updatedElements, (d: CircleElement) => d.id)\n          .transition()\n          .duration(updateFrequency * 0.8)\n          .attr('cx', (d: CircleElement) => d.x)\n          .attr('cy', (d: CircleElement) => d.y)\n          .attr('r', (d: CircleElement) => d.radius)\n          .attr('fill', (d: CircleElement) => d.color);\n\n        // Update elements state\n        setElements(updatedElements);\n      }, updateFrequency);\n\n      // Measure FPS for standard visualization\n      let frameCount = 0;\n      let lastTime = performance.now();\n\n      const measureFps = () => {\n        frameCount++;\n        const now = performance.now();\n\n        if (now - lastTime >= 1000) {\n          setStandardFps(Math.round((frameCount * 1000) / (now - lastTime)));\n          frameCount = 0;\n          lastTime = now;\n        }\n\n        if (isAnimating) {\n          requestAnimationFrame(measureFps);\n        }\n      };\n\n      requestAnimationFrame(measureFps);\n\n      return () => {\n        clearInterval(updateInterval);\n      };\n    }\n  }, [elements, standardSvgRef, isAnimating, width, height, updateFrequency, animationComplexity]);\n\n  // Set up batched visualization\n  useEffect(() => {\n    if (!batchedSvgRef.current || elements.length === 0) return;\n\n    const svg = d3.select(batchedSvgRef.current);\n\n    // Clear previous elements\n    svg.selectAll('*').remove();\n\n    // Create a batched selection for better performance\n    const batchedSvg = batchingEnabled\n      ? optimizeWithBatchedUpdates(\n          // Use a double type assertion to bypass type checking\n          svg as unknown as d3.Selection<SVGSVGElement, unknown, Element, undefined>,\n          'batched-demo',\n          { priority: priorityLevel }\n        )\n      : svg;\n\n    // Create circles for each element\n    (batchedSvg as D3SVGSelection)\n      .selectAll<SVGCircleElement, CircleElement>('circle')\n      .data<CircleElement>(elements, (d: CircleElement) => d.id)\n      .enter()\n      .append('circle')\n      .attr('cx', (d: CircleElement) => d.x)\n      .attr('cy', (d: CircleElement) => d.y)\n      .attr('r', (d: CircleElement) => d.radius)\n      .attr('fill', (d: CircleElement) => d.color)\n      .attr('stroke', '#333')\n      .attr('stroke-width', 1);\n\n    // Set up animation if active\n    if (isAnimating) {\n      // Register animation with the animation frame manager\n      const id = animationFrameManager.registerAnimation(\n        {\n          id: 'batched-demo-animation',\n          name: 'Batched Demo',\n          priority: 'medium' as AnimationPriority,\n          type: 'custom',\n          duration: 0, // Runs indefinitely\n          loop: true,\n        },\n        (_elapsed, _deltaTime) => {\n          // Update batch stats once per frame\n          setBatchStats(batchUpdateManager.getStats());\n          return false; // Continue animation\n        }\n      );\n\n      setAnimationId(id);\n      animationFrameManager.startAnimation(id);\n\n      const updateInterval = setInterval(() => {\n        // Create new positions for each element - similar to the standard side\n        const updatedElements = elements.map(el => {\n          // More complex movement based on complexity level\n          const complexityFactor = animationComplexity / 100;\n          const noise = Math.sin(Date.now() * 0.001 + el.id) * 10 * complexityFactor;\n\n          return {\n            ...el,\n            x:\n              Math.max(10, Math.min(width / 2 - 10, el.x + (Math.random() - 0.5) * 10 + noise)) +\n              width / 2, // Offset for right side\n            y: Math.max(10, Math.min(height - 10, el.y + (Math.random() - 0.5) * 10 + noise)),\n            radius: Math.max(3, el.radius + (Math.random() - 0.5) * 2 * complexityFactor),\n            color: d3.interpolateRgb(\n              el.color,\n              d3.interpolateRainbow(Math.random() * complexityFactor)\n            )(0.05),\n          };\n        });\n\n        // Batched D3 update (prevents layout thrashing)\n        (batchedSvg as D3SVGSelection)\n          .selectAll<SVGCircleElement, CircleElement>('circle')\n          .data<CircleElement>(updatedElements, (d: CircleElement) => d.id)\n          .transition()\n          .duration(updateFrequency * 0.8)\n          .attr('cx', (d: CircleElement) => d.x)\n          .attr('cy', (d: CircleElement) => d.y)\n          .attr('r', (d: CircleElement) => d.radius)\n          .attr('fill', (d: CircleElement) => d.color);\n\n        // Note: we don't update elements state here since\n        // this would trigger a re-render of both sides\n      }, updateFrequency);\n\n      // Measure FPS for batched visualization\n      let frameCount = 0;\n      let lastTime = performance.now();\n\n      const measureFps = () => {\n        frameCount++;\n        const now = performance.now();\n\n        if (now - lastTime >= 1000) {\n          setBatchedFps(Math.round((frameCount * 1000) / (now - lastTime)));\n          frameCount = 0;\n          lastTime = now;\n        }\n\n        if (isAnimating) {\n          requestAnimationFrame(measureFps);\n        }\n      };\n\n      requestAnimationFrame(measureFps);\n\n      return () => {\n        clearInterval(updateInterval);\n        if (id) {\n          animationFrameManager.cancelAnimation(id);\n        }\n      };\n    }\n  }, [\n    elements,\n    batchedSvgRef,\n    isAnimating,\n    width,\n    height,\n    updateFrequency,\n    animationComplexity,\n    batchingEnabled,\n    priorityLevel,\n  ]);\n\n  // Toggle animation state\n  const toggleAnimation = () => {\n    if (isAnimating) {\n      // Stop animation\n      if (animationId) {\n        animationFrameManager.cancelAnimation(animationId);\n      }\n      setIsAnimating(false);\n    } else {\n      // Start animation\n      setIsAnimating(true);\n    }\n  };\n\n  return (\n    <div\n      className=\"demo-container\"\n      style={{ width, padding: '20px', fontFamily: 'Arial, sans-serif' }}\n    >\n      <h2>Batched Update System Demo</h2>\n      <p>\n        This demo shows how batching DOM operations can improve animation performance by reducing\n        layout thrashing. The left side uses standard D3 updates, while the right side uses our\n        batched update system.\n      </p>\n\n      <div className=\"controls\" style={{ marginBottom: '20px' }}>\n        <button\n          onClick={toggleAnimation}\n          style={{\n            padding: '8px 16px',\n            backgroundColor: isAnimating ? '#f44336' : '#4CAF50',\n            color: 'white',\n            border: 'none',\n            borderRadius: '4px',\n            cursor: 'pointer',\n            marginRight: '10px',\n          }}\n        >\n          {isAnimating ? 'Stop Animation' : 'Start Animation'}\n        </button>\n\n        <div style={{ display: 'inline-block', marginRight: '15px' }}>\n          <label>\n            Elements: {elementCount}\n            <input\n              type=\"range\"\n              min=\"10\"\n              max=\"500\"\n              value={elementCount}\n              onChange={e => setElementCount(parseInt(e.target.value))}\n              style={{ display: 'block', width: '150px' }}\n            />\n          </label>\n        </div>\n\n        <div style={{ display: 'inline-block', marginRight: '15px' }}>\n          <label>\n            Update Speed: {updateFrequency}ms\n            <input\n              type=\"range\"\n              min=\"1\"\n              max=\"100\"\n              value={updateFrequency}\n              onChange={e => setUpdateFrequency(parseInt(e.target.value))}\n              style={{ display: 'block', width: '150px' }}\n            />\n          </label>\n        </div>\n\n        <div style={{ display: 'inline-block', marginRight: '15px' }}>\n          <label>\n            Complexity: {animationComplexity}%\n            <input\n              type=\"range\"\n              min=\"0\"\n              max=\"100\"\n              value={animationComplexity}\n              onChange={e => setAnimationComplexity(parseInt(e.target.value))}\n              style={{ display: 'block', width: '150px' }}\n            />\n          </label>\n        </div>\n\n        <div style={{ display: 'inline-block', marginRight: '15px' }}>\n          <label>\n            Batching:\n            <input\n              type=\"checkbox\"\n              checked={batchingEnabled}\n              onChange={e => setBatchingEnabled(e.target.checked)}\n              style={{ marginLeft: '5px' }}\n            />\n          </label>\n        </div>\n\n        <div style={{ display: 'inline-block' }}>\n          <label>\n            Priority:\n            <select\n              value={priorityLevel}\n              onChange={e => setPriorityLevel(e.target.value as BatchOperationPriority)}\n              style={{ marginLeft: '5px' }}\n            >\n              <option value=\"critical\">Critical</option>\n              <option value=\"high\">High</option>\n              <option value=\"normal\">Normal</option>\n              <option value=\"low\">Low</option>\n              <option value=\"idle\">Idle</option>\n            </select>\n          </label>\n        </div>\n      </div>\n\n      <div\n        className=\"visualization-container\"\n        style={{ display: 'flex', justifyContent: 'space-between' }}\n      >\n        <div className=\"standard-container\" style={{ width: '45%' }}>\n          <h3>Standard D3 Updates</h3>\n          <div className=\"fps-display\" style={{ marginBottom: '10px', fontWeight: 'bold' }}>\n            FPS: <span style={{ color: standardFps < 30 ? 'red' : 'green' }}>{standardFps}</span>\n          </div>\n          <svg\n            ref={standardSvgRef}\n            width={width / 2}\n            height={height - 150}\n            style={{ border: '1px solid #ccc', borderRadius: '4px', backgroundColor: '#f9f9f9' }}\n          ></svg>\n        </div>\n\n        <div className=\"batched-container\" style={{ width: '45%' }}>\n          <h3>Batched D3 Updates</h3>\n          <div className=\"fps-display\" style={{ marginBottom: '10px', fontWeight: 'bold' }}>\n            FPS: <span style={{ color: batchedFps < 30 ? 'red' : 'green' }}>{batchedFps}</span>\n          </div>\n          <svg\n            ref={batchedSvgRef}\n            width={width / 2}\n            height={height - 150}\n            style={{ border: '1px solid #ccc', borderRadius: '4px', backgroundColor: '#f9f9f9' }}\n          ></svg>\n        </div>\n      </div>\n\n      <div className=\"stats-container\" style={{ marginTop: '20px' }}>\n        <h3>Batch Manager Statistics</h3>\n        <div\n          ref={statsRef}\n          className=\"stats\"\n          style={{ display: 'flex', justifyContent: 'space-between' }}\n        >\n          <div className=\"stat-item\">\n            <div className=\"stat-label\">Pending Reads:</div>\n            <div className=\"stat-value\">{batchStats.pendingReads}</div>\n          </div>\n          <div className=\"stat-item\">\n            <div className=\"stat-label\">Pending Writes:</div>\n            <div className=\"stat-value\">{batchStats.pendingWrites}</div>\n          </div>\n          <div className=\"stat-item\">\n            <div className=\"stat-label\">Total Pending:</div>\n            <div className=\"stat-value\">{batchStats.totalPending}</div>\n          </div>\n          <div className=\"stat-item\">\n            <div className=\"stat-label\">Completed Operations:</div>\n            <div className=\"stat-value\">{batchStats.completedOperations}</div>\n          </div>\n        </div>\n      </div>\n\n      <div\n        className=\"explanation\"\n        style={{\n          marginTop: '20px',\n          padding: '15px',\n          backgroundColor: '#f0f0f0',\n          borderRadius: '4px',\n        }}\n      >\n        <h3>How It Works</h3>\n        <p>\n          The batched update system separates read and write DOM operations to prevent layout\n          thrashing. It also groups operations by element and priority, reducing the number of\n          reflows.\n        </p>\n        <p>Key benefits:</p>\n        <ul>\n          <li>Separation of read/write operations to prevent forced reflows</li>\n          <li>Intelligent scheduling of updates using microtasks and animation frames</li>\n          <li>Operation deduplication to prevent redundant DOM updates</li>\n          <li>Priority-based processing to ensure critical updates happen first</li>\n          <li>Integration with the animation frame manager for consistent timing</li>\n        </ul>\n        <p>\n          This results in smoother animations with higher frame rates, especially for complex\n          visualizations with many elements and frequent updates.\n        </p>\n      </div>\n    </div>\n  );\n};\n\nexport default BatchedUpdateDemo;\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/performance/D3AccessorBenchmarkView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/performance/D3PerformanceProfilerView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/performance/DynamicBudgetAdjustmentPanel.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'handleConfigChange' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":153,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":153,"endColumn":27}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as React from 'react';\nimport { useEffect, useState } from 'react';\nimport {\n  BudgetAdjustmentRecommendation,\n  DynamicBudgetAdjuster,\n  PerformanceStatistics,\n  PerformanceTelemetryConfig,\n} from '../../../utils/performance/benchmarks/DynamicBudgetAdjustment';\nimport { PerformanceBudget } from '../../../utils/performance/benchmarks/PerformanceBudgets';\nimport { Button } from '../common/Button';\n\ninterface DynamicBudgetAdjustmentPanelProps {\n  /**\n   * Initial telemetry configuration\n   */\n  initialConfig?: Partial<PerformanceTelemetryConfig>;\n\n  /**\n   * Width of the panel\n   */\n  width?: number | string;\n\n  /**\n   * Height of the panel\n   */\n  height?: number | string;\n\n  /**\n   * Callback when budgets are adjusted\n   */\n  onBudgetsAdjusted?: (newBudgets: PerformanceBudget[]) => void;\n\n  /**\n   * Whether to automatically apply recommended adjustments\n   */\n  autoApplyRecommendations?: boolean;\n\n  /**\n   * Minimum confidence level for auto-applying recommendations (0-1)\n   */\n  minConfidence?: number;\n}\n\n/**\n * Dynamic Budget Adjustment Panel\n *\n * A component that allows viewing and managing performance budgets\n * based on real-world telemetry data?.\n */\nexport const DynamicBudgetAdjustmentPanel: React.FC<DynamicBudgetAdjustmentPanelProps> = ({\n  initialConfig,\n  width = '100%',\n  height = 'auto',\n  onBudgetsAdjusted,\n  autoApplyRecommendations = false,\n  minConfidence = 0.8,\n}) => {\n  // Default configuration for telemetry\n  const defaultConfig: PerformanceTelemetryConfig = {\n    enabled: true,\n    samplingRate: 0.1,\n    maxSamplesPerCategory: 1000,\n    recordDeviceInfo: true,\n    autoAdjustBudgets: false,\n    budgetBuffer: 0.2,\n    ...initialConfig,\n  };\n\n  // State\n  const [budgetAdjuster] = useState(() => new DynamicBudgetAdjuster(defaultConfig));\n  const [currentBudgets, setCurrentBudgets] = useState<PerformanceBudget[]>([]);\n  const [recommendations, setRecommendations] = useState<BudgetAdjustmentRecommendation[]>([]);\n  const [statistics, setStatistics] = useState<Map<string, PerformanceStatistics>>(new Map());\n  const [telemetryConfig, setTelemetryConfig] = useState<PerformanceTelemetryConfig>(defaultConfig);\n  const [activeTab, setActiveTab] = useState<'recommendations' | 'statistics' | 'budgets'>(\n    'recommendations'\n  );\n  const [showAppliedChanges, setShowAppliedChanges] = useState<boolean>(false);\n  const [appliedChanges, setAppliedChanges] = useState<BudgetAdjustmentRecommendation[]>([]);\n\n  // Initial load of budgets and statistics\n  useEffect(() => {\n    setCurrentBudgets(budgetAdjuster.getCurrentBudgets());\n    setStatistics(budgetAdjuster.getTelemetryStatistics());\n    setRecommendations(budgetAdjuster.checkForBudgetAdjustments());\n  }, [budgetAdjuster]);\n\n  // Auto-apply recommendations with sufficient confidence\n  useEffect(() => {\n    if (autoApplyRecommendations && recommendations.length > 0) {\n      const highConfidenceRecommendations = recommendations.filter(\n        rec => rec.confidence >= minConfidence\n      );\n\n      if (highConfidenceRecommendations.length > 0) {\n        const applied: BudgetAdjustmentRecommendation[] = [];\n\n        for (const recommendation of highConfidenceRecommendations) {\n          const success = budgetAdjuster.adjustBudget(\n            recommendation.originalBudget.name,\n            recommendation.recommendedBudget\n          );\n\n          if (success) {\n            applied.push(recommendation);\n          }\n        }\n\n        if (applied.length > 0) {\n          // Update state\n          setCurrentBudgets(budgetAdjuster.getCurrentBudgets());\n          setRecommendations(budgetAdjuster.checkForBudgetAdjustments());\n          setAppliedChanges(prev => [...prev, ...applied]);\n          setShowAppliedChanges(true);\n\n          // Notify parent component\n          if (onBudgetsAdjusted) {\n            onBudgetsAdjusted(budgetAdjuster.getCurrentBudgets());\n          }\n        }\n      }\n    }\n  }, [autoApplyRecommendations, budgetAdjuster, minConfidence, onBudgetsAdjusted, recommendations]);\n\n  // Handle applying a recommendation manually\n  const handleApplyRecommendation = (recommendation: BudgetAdjustmentRecommendation) => {\n    const success = budgetAdjuster.adjustBudget(\n      recommendation.originalBudget.name,\n      recommendation.recommendedBudget\n    );\n\n    if (success) {\n      // Update state\n      setCurrentBudgets(budgetAdjuster.getCurrentBudgets());\n      setRecommendations(budgetAdjuster.checkForBudgetAdjustments());\n      setAppliedChanges(prev => [...prev, recommendation]);\n      setShowAppliedChanges(true);\n\n      // Notify parent component\n      if (onBudgetsAdjusted) {\n        onBudgetsAdjusted(budgetAdjuster.getCurrentBudgets());\n      }\n    }\n  };\n\n  // Handle refreshing the analysis\n  const handleRefreshAnalysis = () => {\n    setStatistics(budgetAdjuster.getTelemetryStatistics());\n    setRecommendations(budgetAdjuster.checkForBudgetAdjustments());\n  };\n\n  // Handle updating telemetry configuration\n  const handleConfigChange = (newConfig: Partial<PerformanceTelemetryConfig>) => {\n    const updatedConfig = { ...telemetryConfig, ...newConfig };\n    setTelemetryConfig(updatedConfig);\n\n    // Update the adjuster with the new config\n    // Note: This is a simplified approach - in a real implementation,\n    // we would need to create a new adjuster or have a method to update config\n\n    // Refresh the analysis\n    handleRefreshAnalysis();\n  };\n\n  // Handle applying all recommendations\n  const handleApplyAllRecommendations = () => {\n    const applied: BudgetAdjustmentRecommendation[] = [];\n\n    for (const recommendation of recommendations) {\n      const success = budgetAdjuster.adjustBudget(\n        recommendation.originalBudget.name,\n        recommendation.recommendedBudget\n      );\n\n      if (success) {\n        applied.push(recommendation);\n      }\n    }\n\n    if (applied.length > 0) {\n      // Update state\n      setCurrentBudgets(budgetAdjuster.getCurrentBudgets());\n      setRecommendations(budgetAdjuster.checkForBudgetAdjustments());\n      setAppliedChanges(prev => [...prev, ...applied]);\n      setShowAppliedChanges(true);\n\n      // Notify parent component\n      if (onBudgetsAdjusted) {\n        onBudgetsAdjusted(budgetAdjuster.getCurrentBudgets());\n      }\n    }\n  };\n\n  // Handle exporting budgets to JSON\n  const handleExportBudgets = () => {\n    const budgetsJson = JSON.stringify(currentBudgets, null, 2);\n    const blob = new Blob([budgetsJson], { type: 'application/json' });\n    const url = URL.createObjectURL(blob);\n\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = `performance-budgets-${new Date().toISOString().split('T')[0]}.json`;\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    URL.revokeObjectURL(url);\n  };\n\n  return (\n    <div className=\"dynamic-budget-adjustment-panel\" style={{ width, height }}>\n      <div className=\"panel-header\">\n        <h2>Performance Budget Adjustment</h2>\n        <div className=\"panel-actions\">\n          <Button variant=\"secondary\" size=\"small\" onClick={handleRefreshAnalysis}>\n            Refresh Analysis\n          </Button>\n          <Button variant=\"secondary\" size=\"small\" onClick={handleExportBudgets}>\n            Export Budgets\n          </Button>\n        </div>\n      </div>\n\n      <div className=\"panel-tabs\">\n        <button\n          className={`tab-button ${activeTab === 'recommendations' ? 'active' : ''}`}\n          onClick={() => setActiveTab('recommendations')}\n        >\n          Recommendations ({recommendations.length})\n        </button>\n        <button\n          className={`tab-button ${activeTab === 'statistics' ? 'active' : ''}`}\n          onClick={() => setActiveTab('statistics')}\n        >\n          Statistics\n        </button>\n        <button\n          className={`tab-button ${activeTab === 'budgets' ? 'active' : ''}`}\n          onClick={() => setActiveTab('budgets')}\n        >\n          Current Budgets\n        </button>\n      </div>\n\n      <div className=\"panel-content\">\n        {/* Recommendations Tab */}\n        {activeTab === 'recommendations' && (\n          <div className=\"recommendations-tab\">\n            {showAppliedChanges && appliedChanges.length > 0 && (\n              <div className=\"applied-changes-notice\">\n                <div className=\"notice-header\">\n                  <h3>Recently Applied Changes</h3>\n                  <button className=\"close-button\" onClick={() => setShowAppliedChanges(false)}>\n                    Ã—\n                  </button>\n                </div>\n                <ul className=\"applied-changes-list\">\n                  {appliedChanges.slice(-5).map((change, index) => (\n                    <li key={`applied-${index}`} className=\"applied-change-item\">\n                      <span className=\"budget-name\">{change.originalBudget.name}</span>:\n                      {change.originalBudget.maxExecutionTimeMs !==\n                        change.recommendedBudget.maxExecutionTimeMs && (\n                        <span className=\"change-detail\">\n                          Execution time: {change.originalBudget.maxExecutionTimeMs}ms â†’{' '}\n                          {change.recommendedBudget.maxExecutionTimeMs}ms\n                        </span>\n                      )}\n                      {change.originalBudget.maxMemoryUsageMB !==\n                        change.recommendedBudget.maxMemoryUsageMB && (\n                        <span className=\"change-detail\">\n                          Memory: {change.originalBudget.maxMemoryUsageMB}MB â†’{' '}\n                          {change.recommendedBudget.maxMemoryUsageMB}MB\n                        </span>\n                      )}\n                      {change.originalBudget.minOperationsPerSecond !==\n                        change.recommendedBudget.minOperationsPerSecond && (\n                        <span className=\"change-detail\">\n                          Operations: {change.originalBudget.minOperationsPerSecond} â†’{' '}\n                          {change.recommendedBudget.minOperationsPerSecond} ops/s\n                        </span>\n                      )}\n                    </li>\n                  ))}\n                </ul>\n              </div>\n            )}\n\n            {recommendations.length === 0 ? (\n              <div className=\"empty-state\">\n                <p>No budget adjustment recommendations at this time.</p>\n                <p className=\"hint\">\n                  This could be because there's not enough telemetry data or the current budgets are\n                  appropriate.\n                </p>\n              </div>\n            ) : (\n              <>\n                <div className=\"recommendations-header\">\n                  <h3>{recommendations.length} Recommendations Available</h3>\n                  <Button variant=\"primary\" size=\"small\" onClick={handleApplyAllRecommendations}>\n                    Apply All\n                  </Button>\n                </div>\n\n                <div className=\"recommendations-list\">\n                  {recommendations.map((recommendation, index) => (\n                    <div key={`rec-${index}`} className=\"recommendation-card\">\n                      <div className=\"recommendation-header\">\n                        <h4>{recommendation.originalBudget.name}</h4>\n                        <div\n                          className=\"confidence-badge\"\n                          style={{\n                            backgroundColor:\n                              recommendation.confidence >= 0.8\n                                ? '#e8f5e9'\n                                : recommendation.confidence >= 0.6\n                                  ? '#fff8e1'\n                                  : '#ffebee',\n                          }}\n                        >\n                          {(recommendation.confidence * 100).toFixed(0)}% confidence\n                        </div>\n                      </div>\n\n                      <p className=\"recommendation-reason\">{recommendation.reason}</p>\n\n                      <div className=\"recommendation-details\">\n                        <div className=\"stats-section\">\n                          <h5>Statistics</h5>\n                          <div className=\"stat-grid\">\n                            <div className=\"stat-row\">\n                              <div className=\"stat-label\">Samples</div>\n                              <div className=\"stat-value\">\n                                {recommendation.statistics.sampleCount}\n                              </div>\n                            </div>\n                            <div className=\"stat-row\">\n                              <div className=\"stat-label\">p95 Time</div>\n                              <div className=\"stat-value\">\n                                {recommendation.statistics.p95ExecutionTimeMs.toFixed(2)}ms\n                              </div>\n                            </div>\n                            <div className=\"stat-row\">\n                              <div className=\"stat-label\">Mean Time</div>\n                              <div className=\"stat-value\">\n                                {recommendation.statistics.meanExecutionTimeMs.toFixed(2)}ms\n                              </div>\n                            </div>\n                            {recommendation.statistics.p95MemoryUsageMB && (\n                              <div className=\"stat-row\">\n                                <div className=\"stat-label\">p95 Memory</div>\n                                <div className=\"stat-value\">\n                                  {recommendation.statistics.p95MemoryUsageMB.toFixed(2)}MB\n                                </div>\n                              </div>\n                            )}\n                          </div>\n                        </div>\n\n                        <div className=\"changes-section\">\n                          <h5>Proposed Changes</h5>\n                          <div className=\"change-grid\">\n                            {recommendation.originalBudget.maxExecutionTimeMs !==\n                              recommendation.recommendedBudget.maxExecutionTimeMs && (\n                              <div className=\"change-row\">\n                                <div className=\"change-label\">Execution Time</div>\n                                <div className=\"change-value\">\n                                  <span className=\"old-value\">\n                                    {recommendation.originalBudget.maxExecutionTimeMs}ms\n                                  </span>\n                                  <span className=\"arrow\">â†’</span>\n                                  <span className=\"new-value\">\n                                    {recommendation.recommendedBudget.maxExecutionTimeMs}ms\n                                  </span>\n                                </div>\n                              </div>\n                            )}\n\n                            {recommendation.originalBudget.maxMemoryUsageMB !==\n                              recommendation.recommendedBudget.maxMemoryUsageMB && (\n                              <div className=\"change-row\">\n                                <div className=\"change-label\">Memory Usage</div>\n                                <div className=\"change-value\">\n                                  <span className=\"old-value\">\n                                    {recommendation.originalBudget.maxMemoryUsageMB}MB\n                                  </span>\n                                  <span className=\"arrow\">â†’</span>\n                                  <span className=\"new-value\">\n                                    {recommendation.recommendedBudget.maxMemoryUsageMB}MB\n                                  </span>\n                                </div>\n                              </div>\n                            )}\n\n                            {recommendation.originalBudget.minOperationsPerSecond !==\n                              recommendation.recommendedBudget.minOperationsPerSecond && (\n                              <div className=\"change-row\">\n                                <div className=\"change-label\">Operations/Second</div>\n                                <div className=\"change-value\">\n                                  <span className=\"old-value\">\n                                    {recommendation.originalBudget.minOperationsPerSecond}\n                                  </span>\n                                  <span className=\"arrow\">â†’</span>\n                                  <span className=\"new-value\">\n                                    {recommendation.recommendedBudget.minOperationsPerSecond}\n                                  </span>\n                                </div>\n                              </div>\n                            )}\n                          </div>\n                        </div>\n                      </div>\n\n                      <div className=\"recommendation-actions\">\n                        <Button\n                          variant=\"primary\"\n                          size=\"small\"\n                          onClick={() => handleApplyRecommendation(recommendation)}\n                        >\n                          Apply Changes\n                        </Button>\n                      </div>\n                    </div>\n                  ))}\n                </div>\n              </>\n            )}\n          </div>\n        )}\n\n        {/* Statistics Tab */}\n        {activeTab === 'statistics' && (\n          <div className=\"statistics-tab\">\n            {statistics.size === 0 ? (\n              <div className=\"empty-state\">\n                <p>No performance statistics available yet.</p>\n                <p className=\"hint\">\n                  Run tests or collect real-world telemetry to see statistics here.\n                </p>\n              </div>\n            ) : (\n              <div className=\"statistics-list\">\n                <div className=\"stats-header-row\">\n                  <div className=\"operation-column\">Operation</div>\n                  <div className=\"samples-column\">Samples</div>\n                  <div className=\"time-column\">p95 Time (ms)</div>\n                  <div className=\"time-column\">Mean Time (ms)</div>\n                  <div className=\"memory-column\">p95 Memory (MB)</div>\n                  <div className=\"ops-column\">Mean Ops/Sec</div>\n                </div>\n\n                <div className=\"stats-rows\">\n                  {Array.from(statistics.entries()).map(([name, stats], index) => (\n                    <div key={`stats-${index}`} className=\"stats-row\">\n                      <div className=\"operation-column\">{name}</div>\n                      <div className=\"samples-column\">{stats.sampleCount}</div>\n                      <div className=\"time-column\">{stats.p95ExecutionTimeMs.toFixed(2)}</div>\n                      <div className=\"time-column\">{stats.meanExecutionTimeMs.toFixed(2)}</div>\n                      <div className=\"memory-column\">\n                        {stats.p95MemoryUsageMB?.toFixed(2) || 'N/A'}\n                      </div>\n                      <div className=\"ops-column\">\n                        {stats.meanOperationsPerSecond?.toFixed(2) || 'N/A'}\n                      </div>\n                    </div>\n                  ))}\n                </div>\n              </div>\n            )}\n          </div>\n        )}\n\n        {/* Budgets Tab */}\n        {activeTab === 'budgets' && (\n          <div className=\"budgets-tab\">\n            <div className=\"budgets-list\">\n              <div className=\"budget-header-row\">\n                <div className=\"operation-column\">Operation</div>\n                <div className=\"category-column\">Category</div>\n                <div className=\"critical-column\">Critical</div>\n                <div className=\"time-column\">Max Time (ms)</div>\n                <div className=\"memory-column\">Max Memory (MB)</div>\n                <div className=\"ops-column\">Min Ops/Sec</div>\n              </div>\n\n              <div className=\"budget-rows\">\n                {currentBudgets.map((budget, index) => (\n                  <div key={`budget-${index}`} className=\"budget-row\">\n                    <div className=\"operation-column\">{budget.name}</div>\n                    <div className=\"category-column\">{budget.category}</div>\n                    <div className=\"critical-column\">\n                      <span className={`critical-badge ${budget.critical ? 'yes' : 'no'}`}>\n                        {budget.critical ? 'Yes' : 'No'}\n                      </span>\n                    </div>\n                    <div className=\"time-column\">{budget.maxExecutionTimeMs}</div>\n                    <div className=\"memory-column\">{budget.maxMemoryUsageMB || 'N/A'}</div>\n                    <div className=\"ops-column\">{budget.minOperationsPerSecond || 'N/A'}</div>\n                  </div>\n                ))}\n              </div>\n            </div>\n          </div>\n        )}\n      </div>\n\n      <style>\n        {`\n        .dynamic-budget-adjustment-panel {\n          font-family:\n            -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell,\n            'Open Sans', 'Helvetica Neue', sans-serif;\n          border: 1px solid #e0e0e0;\n          border-radius: 4px;\n          overflow: hidden;\n          display: flex;\n          flex-direction: column;\n          background-color: white;\n        }\n\n        .panel-header {\n          padding: 16px;\n          border-bottom: 1px solid #e0e0e0;\n          display: flex;\n          justify-content: space-between;\n          align-items: center;\n        }\n\n        .panel-header h2 {\n          margin: 0;\n          font-size: 20px;\n          color: #333;\n        }\n\n        .panel-actions {\n          display: flex;\n          gap: 8px;\n        }\n\n        .panel-tabs {\n          display: flex;\n          border-bottom: 1px solid #e0e0e0;\n          background-color: #f5f5f5;\n        }\n\n        .tab-button {\n          padding: 12px 16px;\n          border: none;\n          background: none;\n          cursor: pointer;\n          font-size: 14px;\n          font-weight: 500;\n          color: #555;\n          border-bottom: 2px solid transparent;\n        }\n\n        .tab-button:hover {\n          background-color: #ececec;\n        }\n\n        .tab-button.active {\n          color: #1a73e8;\n          border-bottom-color: #1a73e8;\n        }\n\n        .panel-content {\n          flex: 1;\n          overflow-y: auto;\n          padding: 16px;\n        }\n\n        .empty-state {\n          text-align: center;\n          padding: 32px;\n          color: #666;\n        }\n\n        .hint {\n          font-size: 14px;\n          color: #888;\n          margin-top: 8px;\n        }\n\n        /* Recommendations tab */\n        .recommendations-header {\n          display: flex;\n          justify-content: space-between;\n          align-items: center;\n          margin-bottom: 16px;\n        }\n\n        .recommendations-header h3 {\n          margin: 0;\n          font-size: 16px;\n          color: #333;\n        }\n\n        .recommendations-list {\n          display: flex;\n          flex-direction: column;\n          gap: 16px;\n        }\n\n        .recommendation-card {\n          border: 1px solid #e0e0e0;\n          border-radius: 4px;\n          padding: 16px;\n          background-color: #fff;\n        }\n\n        .recommendation-header {\n          display: flex;\n          justify-content: space-between;\n          align-items: center;\n          margin-bottom: 8px;\n        }\n\n        .recommendation-header h4 {\n          margin: 0;\n          font-size: 16px;\n          color: #333;\n        }\n\n        .confidence-badge {\n          padding: 4px 8px;\n          border-radius: 4px;\n          font-size: 12px;\n          font-weight: 500;\n        }\n\n        .recommendation-reason {\n          margin-top: 0;\n          margin-bottom: 16px;\n          color: #666;\n          font-size: 14px;\n        }\n\n        .recommendation-details {\n          display: flex;\n          gap: 24px;\n          margin-bottom: 16px;\n        }\n\n        .stats-section,\n        .changes-section {\n          flex: 1;\n        }\n\n        .stats-section h5,\n        .changes-section h5 {\n          margin-top: 0;\n          margin-bottom: 8px;\n          font-size: 14px;\n          color: #333;\n        }\n\n        .stat-grid,\n        .change-grid {\n          display: flex;\n          flex-direction: column;\n          gap: 4px;\n        }\n\n        .stat-row,\n        .change-row {\n          display: flex;\n          justify-content: space-between;\n          font-size: 14px;\n        }\n\n        .stat-label,\n        .change-label {\n          color: #666;\n        }\n\n        .change-value {\n          display: flex;\n          align-items: center;\n          gap: 4px;\n        }\n\n        .old-value {\n          color: #d32f2f;\n          text-decoration: line-through;\n        }\n\n        .arrow {\n          color: #666;\n        }\n\n        .new-value {\n          color: #388e3c;\n          font-weight: 500;\n        }\n\n        .recommendation-actions {\n          display: flex;\n          justify-content: flex-end;\n        }\n\n        /* Applied changes notice */\n        .applied-changes-notice {\n          margin-bottom: 16px;\n          border: 1px solid #c8e6c9;\n          border-radius: 4px;\n          background-color: #e8f5e9;\n          padding: 12px;\n        }\n\n        .notice-header {\n          display: flex;\n          justify-content: space-between;\n          align-items: center;\n          margin-bottom: 8px;\n        }\n\n        .notice-header h3 {\n          margin: 0;\n          font-size: 14px;\n          color: #2e7d32;\n        }\n\n        .close-button {\n          background: none;\n          border: none;\n          font-size: 18px;\n          color: #2e7d32;\n          cursor: pointer;\n        }\n\n        .applied-changes-list {\n          margin: 0;\n          padding-left: 16px;\n        }\n\n        .applied-change-item {\n          font-size: 13px;\n          margin-bottom: 4px;\n        }\n\n        .budget-name {\n          font-weight: 500;\n        }\n\n        .change-detail {\n          margin-left: 4px;\n          margin-right: 8px;\n          color: #2e7d32;\n        }\n\n        /* Statistics tab */\n        .statistics-list {\n          border: 1px solid #e0e0e0;\n          border-radius: 4px;\n          overflow: hidden;\n        }\n\n        .stats-header-row {\n          display: flex;\n          background-color: #f5f5f5;\n          padding: 12px 16px;\n          font-weight: 500;\n          font-size: 14px;\n          color: #333;\n        }\n\n        .stats-rows {\n          max-height: 500px;\n          overflow-y: auto;\n        }\n\n        .stats-row {\n          display: flex;\n          padding: 12px 16px;\n          font-size: 14px;\n          border-top: 1px solid #f0f0f0;\n        }\n\n        .stats-row:nth-child(even) {\n          background-color: #fafafa;\n        }\n\n        .operation-column {\n          flex: 2;\n        }\n\n        .samples-column {\n          flex: 1;\n          text-align: center;\n        }\n\n        .time-column,\n        .memory-column,\n        .ops-column {\n          flex: 1;\n          text-align: right;\n        }\n\n        /* Budgets tab */\n        .budgets-list {\n          border: 1px solid #e0e0e0;\n          border-radius: 4px;\n          overflow: hidden;\n        }\n\n        .budget-header-row {\n          display: flex;\n          background-color: #f5f5f5;\n          padding: 12px 16px;\n          font-weight: 500;\n          font-size: 14px;\n          color: #333;\n        }\n\n        .budget-rows {\n          max-height: 500px;\n          overflow-y: auto;\n        }\n\n        .budget-row {\n          display: flex;\n          padding: 12px 16px;\n          font-size: 14px;\n          border-top: 1px solid #f0f0f0;\n        }\n\n        .budget-row:nth-child(even) {\n          background-color: #fafafa;\n        }\n\n        .category-column {\n          flex: 1;\n        }\n\n        .critical-column {\n          flex: 0.5;\n          text-align: center;\n        }\n\n        .critical-badge {\n          display: inline-block;\n          padding: 2px 6px;\n          border-radius: 4px;\n          font-size: 12px;\n        }\n\n        .critical-badge.yes {\n          background-color: #ffebee;\n          color: #d32f2f;\n        }\n\n        .critical-badge.no {\n          background-color: #e8f5e9;\n          color: #388e3c;\n        }\n        `}\n      </style>\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/performance/InterpolationMemoizationDemo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/performance/MLPerformancePrediction.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/performance/OptimizationComparisonView.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'width' is assigned a value but never used.","line":31,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":31,"endColumn":8},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'height' is assigned a value but never used.","line":32,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":32,"endColumn":9},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_elapsed' is defined but never used.","line":174,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":174,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_deltaTime' is defined but never used.","line":174,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":174,"endColumn":36},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_frameInfo' is defined but never used.","line":174,"column":46,"nodeType":null,"messageId":"unusedVar","endLine":174,"endColumn":56},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_elapsed' is defined but never used.","line":200,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":200,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_deltaTime' is defined but never used.","line":200,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":200,"endColumn":36},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_frameInfo' is defined but never used.","line":200,"column":46,"nodeType":null,"messageId":"unusedVar","endLine":200,"endColumn":56}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as React from 'react';\nimport { useEffect, useRef, useState } from 'react';\nimport { animationFrameManager } from '../../../utils/performance/animationFrameManagerInstance';\nimport { FrameInfo } from '../../../utils/performance/D3AnimationFrameManager';\nimport { AnimationPerformanceReport } from '../../../utils/performance/D3AnimationProfiler';\nimport {\n  ActiveMode,\n  ComparisonMode,\n  PerformanceComparison,\n  PerformanceMetrics,\n} from './performanceTypes';\n\n// Declare the metricInterval property on window for TypeScript\ndeclare global {\n  interface Window {\n    metricInterval?: ReturnType<typeof setInterval>;\n  }\n}\n\ninterface OptimizationComparisonViewProps {\n  width?: number;\n  height?: number;\n  animationId?: string;\n}\n\n/**\n * A component that provides side-by-side comparison between optimized and unoptimized\n * performance modes with real-time metrics visualization.\n */\nconst OptimizationComparisonView: React.FC<OptimizationComparisonViewProps> = ({\n  width = 1200,\n  height = 800,\n  animationId = 'test-animation',\n}) => {\n  // References for chart containers\n  const optimizedChartRef = useRef<HTMLDivElement>(null);\n  const unoptimizedChartRef = useRef<HTMLDivElement>(null);\n\n  // State for tracking metrics\n  const [optimizedMetrics, setOptimizedMetrics] = useState<PerformanceMetrics>({\n    fps: [],\n    renderTime: [],\n    cpuTime: [],\n    domOperations: [],\n    memoryUsage: [],\n    animationSmoothness: [],\n  });\n\n  const [unoptimizedMetrics, setUnoptimizedMetrics] = useState<PerformanceMetrics>({\n    fps: [],\n    renderTime: [],\n    cpuTime: [],\n    domOperations: [],\n    memoryUsage: [],\n    animationSmoothness: [],\n  });\n\n  // State for comparison mode\n  const [comparisonMode, setComparisonMode] = useState<ComparisonMode>('side-by-side');\n  const [isRunning, setIsRunning] = useState(false);\n  const [activeMode, setActiveMode] = useState<ActiveMode>('both');\n  const [comparisons, setComparisons] = useState<PerformanceComparison[]>([]);\n\n  // State for animation performance reports\n  const [optimizedReport, setOptimizedReport] = useState<AnimationPerformanceReport | null>(null);\n  const [unoptimizedReport, setUnoptimizedReport] = useState<AnimationPerformanceReport | null>(\n    null\n  );\n\n  // Initialize comparison\n  useEffect(() => {\n    // Setup chart visualization (would implement with D3 in a real component)\n    setupCharts();\n\n    return () => {\n      // Cleanup any running animations\n      if (isRunning) {\n        stopComparison();\n      }\n    };\n  }, []);\n\n  // Update charts when metrics change\n  useEffect(() => {\n    if (optimizedMetrics.fps.length > 0 || unoptimizedMetrics.fps.length > 0) {\n      updateCharts();\n    }\n  }, [optimizedMetrics, unoptimizedMetrics]);\n\n  // Update statistical comparison when reports change\n  useEffect(() => {\n    if (optimizedReport && unoptimizedReport) {\n      generateComparisons();\n    }\n  }, [optimizedReport, unoptimizedReport]);\n\n  // Setup chart visualization\n  const setupCharts = () => {\n    // In a real implementation, this would initialize D3 charts\n    console.warn('Setting up performance comparison charts');\n  };\n\n  // Update chart visualization\n  const updateCharts = () => {\n    // In a real implementation, this would update D3 charts with new data\n    console.warn('Updating performance comparison charts');\n  };\n\n  // Start the comparison\n  const startComparison = () => {\n    setIsRunning(true);\n\n    // Clear previous metrics\n    setOptimizedMetrics({\n      fps: [],\n      renderTime: [],\n      cpuTime: [],\n      domOperations: [],\n      memoryUsage: [],\n      animationSmoothness: [],\n    });\n\n    setUnoptimizedMetrics({\n      fps: [],\n      renderTime: [],\n      cpuTime: [],\n      domOperations: [],\n      memoryUsage: [],\n      animationSmoothness: [],\n    });\n\n    // Run optimized animation if mode is optimized or both\n    if (activeMode === 'optimized' || activeMode === 'both') {\n      runOptimizedAnimation();\n    }\n\n    // Run unoptimized animation if mode is unoptimized or both\n    if (activeMode === 'unoptimized' || activeMode === 'both') {\n      runUnoptimizedAnimation();\n    }\n\n    // Start metric collection\n    startMetricCollection();\n  };\n\n  // Stop the comparison\n  const stopComparison = () => {\n    setIsRunning(false);\n\n    // Stop animations\n    animationFrameManager.pauseAnimation(`${animationId}-optimized`);\n    animationFrameManager.pauseAnimation(`${animationId}-unoptimized`);\n\n    // Stop metric collection\n    stopMetricCollection();\n  };\n\n  // Run the optimized animation\n  const runOptimizedAnimation = () => {\n    // In a real implementation, this would set up and run the optimized animation\n    console.warn('Running optimized animation');\n\n    // Example of registering an animation with the animation frame manager\n    animationFrameManager.registerAnimation(\n      {\n        id: `${animationId}-optimized`,\n        name: 'Optimized Animation',\n        priority: 'high',\n        type: 'custom',\n        duration: 0, // Run indefinitely\n        loop: true,\n        enableProfiling: true,\n      },\n      (_elapsed: number, _deltaTime: number, _frameInfo: FrameInfo) => {\n        // Animation logic here\n        return false; // Continue running\n      }\n    );\n\n    // Start the animation\n    animationFrameManager.startAnimation(`${animationId}-optimized`);\n  };\n\n  // Run the unoptimized animation\n  const runUnoptimizedAnimation = () => {\n    // In a real implementation, this would set up and run the unoptimized animation\n    console.warn('Running unoptimized animation');\n\n    // Example of registering an animation with the animation frame manager\n    animationFrameManager.registerAnimation(\n      {\n        id: `${animationId}-unoptimized`,\n        name: 'Unoptimized Animation',\n        priority: 'high',\n        type: 'custom',\n        duration: 0, // Run indefinitely\n        loop: true,\n        enableProfiling: true,\n      },\n      (_elapsed: number, _deltaTime: number, _frameInfo: FrameInfo) => {\n        // Animation logic here - with deliberate inefficiencies to demonstrate difference\n        return false; // Continue running\n      }\n    );\n\n    // Start the animation\n    animationFrameManager.startAnimation(`${animationId}-unoptimized`);\n  };\n\n  // Start collecting metrics\n  const startMetricCollection = () => {\n    const metricInterval = setInterval(() => {\n      const now = Date.now();\n\n      // In a real implementation, these would be actual metrics from the animations\n      if (activeMode === 'optimized' || activeMode === 'both') {\n        setOptimizedMetrics(prev => ({\n          fps: [...prev.fps, { timestamp: now, value: 55 + Math.random() * 5 }], // 55-60 FPS\n          renderTime: [...prev.renderTime, { timestamp: now, value: 8 + Math.random() * 3 }], // 8-11ms\n          cpuTime: [...prev.cpuTime, { timestamp: now, value: 5 + Math.random() * 2 }], // 5-7ms\n          domOperations: [...prev.domOperations, { timestamp: now, value: 10 + Math.random() * 5 }], // 10-15 ops\n          memoryUsage: [...prev.memoryUsage, { timestamp: now, value: 20 + Math.random() * 10 }], // 20-30MB\n          animationSmoothness: [\n            ...prev.animationSmoothness,\n            { timestamp: now, value: 90 + Math.random() * 10 },\n          ], // 90-100%\n        }));\n      }\n\n      if (activeMode === 'unoptimized' || activeMode === 'both') {\n        setUnoptimizedMetrics(prev => ({\n          fps: [...prev.fps, { timestamp: now, value: 30 + Math.random() * 15 }], // 30-45 FPS\n          renderTime: [...prev.renderTime, { timestamp: now, value: 16 + Math.random() * 10 }], // 16-26ms\n          cpuTime: [...prev.cpuTime, { timestamp: now, value: 12 + Math.random() * 8 }], // 12-20ms\n          domOperations: [\n            ...prev.domOperations,\n            { timestamp: now, value: 30 + Math.random() * 20 },\n          ], // 30-50 ops\n          memoryUsage: [...prev.memoryUsage, { timestamp: now, value: 40 + Math.random() * 20 }], // 40-60MB\n          animationSmoothness: [\n            ...prev.animationSmoothness,\n            { timestamp: now, value: 60 + Math.random() * 20 },\n          ], // 60-80%\n        }));\n      }\n    }, 1000); // Collect metrics every second\n\n    // Store interval ID for cleanup\n    window.metricInterval = metricInterval;\n  };\n\n  // Stop collecting metrics\n  const stopMetricCollection = () => {\n    if (window.metricInterval) {\n      clearInterval(window.metricInterval);\n      window.metricInterval = undefined;\n    }\n\n    // Generate final performance reports\n    if (activeMode === 'optimized' || activeMode === 'both') {\n      const report = animationFrameManager.getPerformanceReport(`${animationId}-optimized`);\n      if (report) {\n        setOptimizedReport(report);\n      }\n    }\n\n    if (activeMode === 'unoptimized' || activeMode === 'both') {\n      const report = animationFrameManager.getPerformanceReport(`${animationId}-unoptimized`);\n      if (report) {\n        setUnoptimizedReport(report);\n      }\n    }\n  };\n\n  // Generate statistical comparisons between optimized and unoptimized\n  const generateComparisons = () => {\n    // In a real implementation, this would compare actual metrics\n    const newComparisons: PerformanceComparison[] = [\n      {\n        metric: 'FPS',\n        optimized: calculateAverage(optimizedMetrics.fps.map(point => point.value)),\n        unoptimized: calculateAverage(unoptimizedMetrics.fps.map(point => point.value)),\n        difference: 0, // Will be calculated\n        percentImprovement: 0, // Will be calculated\n      },\n      {\n        metric: 'Render Time (ms)',\n        optimized: calculateAverage(optimizedMetrics.renderTime.map(point => point.value)),\n        unoptimized: calculateAverage(unoptimizedMetrics.renderTime.map(point => point.value)),\n        difference: 0, // Will be calculated\n        percentImprovement: 0, // Will be calculated\n      },\n      {\n        metric: 'CPU Time (ms)',\n        optimized: calculateAverage(optimizedMetrics.cpuTime.map(point => point.value)),\n        unoptimized: calculateAverage(unoptimizedMetrics.cpuTime.map(point => point.value)),\n        difference: 0, // Will be calculated\n        percentImprovement: 0, // Will be calculated\n      },\n      {\n        metric: 'DOM Operations',\n        optimized: calculateAverage(optimizedMetrics.domOperations.map(point => point.value)),\n        unoptimized: calculateAverage(unoptimizedMetrics.domOperations.map(point => point.value)),\n        difference: 0, // Will be calculated\n        percentImprovement: 0, // Will be calculated\n      },\n      {\n        metric: 'Memory Usage (MB)',\n        optimized: calculateAverage(optimizedMetrics.memoryUsage.map(point => point.value)),\n        unoptimized: calculateAverage(unoptimizedMetrics.memoryUsage.map(point => point.value)),\n        difference: 0, // Will be calculated\n        percentImprovement: 0, // Will be calculated\n      },\n      {\n        metric: 'Animation Smoothness (%)',\n        optimized: calculateAverage(optimizedMetrics.animationSmoothness.map(point => point.value)),\n        unoptimized: calculateAverage(\n          unoptimizedMetrics.animationSmoothness.map(point => point.value)\n        ),\n        difference: 0, // Will be calculated\n        percentImprovement: 0, // Will be calculated\n      },\n    ];\n\n    // Calculate difference and percentage improvement\n    newComparisons.forEach(comparison => {\n      comparison.difference = comparison.optimized - comparison.unoptimized;\n\n      // For metrics where higher is better (FPS, smoothness)\n      if (comparison.metric === 'FPS' || comparison.metric === 'Animation Smoothness (%)') {\n        comparison.percentImprovement =\n          (comparison.difference / Math.max(0.1, comparison.unoptimized)) * 100;\n      }\n      // For metrics where lower is better (render time, CPU time, DOM ops, memory)\n      else {\n        comparison.percentImprovement =\n          ((comparison.unoptimized - comparison.optimized) /\n            Math.max(0.1, comparison.unoptimized)) *\n          100;\n      }\n    });\n\n    setComparisons(newComparisons);\n  };\n\n  // Helper to calculate average of an array of numbers\n  const calculateAverage = (values: number[]): number => {\n    if (values.length === 0) return 0;\n    return values.reduce((sum, value) => sum + value, 0) / values.length;\n  };\n\n  // Toggle the comparison mode\n  const toggleComparisonMode = () => {\n    setComparisonMode(prev => (prev === 'side-by-side' ? 'overlay' : 'side-by-side'));\n  };\n\n  // Change the active mode\n  const changeActiveMode = (mode: ActiveMode) => {\n    if (isRunning) {\n      stopComparison();\n    }\n\n    setActiveMode(mode);\n\n    if (isRunning) {\n      startComparison();\n    }\n  };\n\n  // Render the comparison view\n  return (\n    <div className=\"optimization-comparison-view\">\n      <h2>Performance Optimization Comparison</h2>\n\n      <div className=\"controls\">\n        <div className=\"control-section\">\n          <h3>Comparison Mode</h3>\n          <div className=\"control-row\">\n            <button\n              className={`mode-button ${activeMode === 'optimized' ? 'active' : ''}`}\n              onClick={() => changeActiveMode('optimized')}\n            >\n              Optimized Only\n            </button>\n            <button\n              className={`mode-button ${activeMode === 'unoptimized' ? 'active' : ''}`}\n              onClick={() => changeActiveMode('unoptimized')}\n            >\n              Unoptimized Only\n            </button>\n            <button\n              className={`mode-button ${activeMode === 'both' ? 'active' : ''}`}\n              onClick={() => changeActiveMode('both')}\n            >\n              Side-by-Side Comparison\n            </button>\n          </div>\n\n          <div className=\"control-row\">\n            <button\n              className=\"action-button\"\n              onClick={isRunning ? stopComparison : startComparison}\n            >\n              {isRunning ? 'Stop Comparison' : 'Start Comparison'}\n            </button>\n\n            {activeMode === 'both' && (\n              <button className=\"action-button\" onClick={toggleComparisonMode}>\n                {comparisonMode === 'side-by-side' ? 'Switch to Overlay' : 'Switch to Side-by-Side'}\n              </button>\n            )}\n          </div>\n        </div>\n      </div>\n\n      <div className={`visualizations ${comparisonMode}`}>\n        {(activeMode === 'optimized' || activeMode === 'both') && (\n          <div className=\"visualization-container optimized\">\n            <h3>Optimized Performance</h3>\n            <div className=\"visualization-wrapper\" ref={optimizedChartRef}>\n              {/* In a real implementation, this would be a D3 chart */}\n              <div className=\"placeholder-chart\">\n                <div className=\"chart-bar\" style={{ height: '80%' }}></div>\n                <div className=\"chart-label\">Chart Placeholder - Optimized</div>\n              </div>\n            </div>\n          </div>\n        )}\n\n        {(activeMode === 'unoptimized' || activeMode === 'both') && (\n          <div className=\"visualization-container unoptimized\">\n            <h3>Unoptimized Performance</h3>\n            <div className=\"visualization-wrapper\" ref={unoptimizedChartRef}>\n              {/* In a real implementation, this would be a D3 chart */}\n              <div className=\"placeholder-chart\">\n                <div className=\"chart-bar\" style={{ height: '40%' }}></div>\n                <div className=\"chart-label\">Chart Placeholder - Unoptimized</div>\n              </div>\n            </div>\n          </div>\n        )}\n      </div>\n\n      {comparisons.length > 0 && (\n        <div className=\"statistical-analysis\">\n          <h3>Statistical Comparison</h3>\n          <table className=\"comparison-table\">\n            <thead>\n              <tr>\n                <th>Metric</th>\n                <th>Optimized</th>\n                <th>Unoptimized</th>\n                <th>Difference</th>\n                <th>Improvement</th>\n              </tr>\n            </thead>\n            <tbody>\n              {comparisons.map((comparison, index) => (\n                <tr key={index}>\n                  <td>{comparison.metric}</td>\n                  <td>{comparison.optimized.toFixed(2)}</td>\n                  <td>{comparison.unoptimized.toFixed(2)}</td>\n                  <td className={comparison.percentImprovement > 0 ? 'positive' : 'negative'}>\n                    {comparison.difference.toFixed(2)}\n                  </td>\n                  <td className={comparison.percentImprovement > 0 ? 'positive' : 'negative'}>\n                    {comparison.percentImprovement.toFixed(2)}%\n                  </td>\n                </tr>\n              ))}\n            </tbody>\n          </table>\n        </div>\n      )}\n\n      <style>\n        {`\n        .optimization-comparison-view {\n          padding: 20px;\n          font-family:\n            system-ui,\n            -apple-system,\n            BlinkMacSystemFont,\n            'Segoe UI',\n            Roboto,\n            sans-serif;\n        }\n\n        h2 {\n          color: #333;\n          border-bottom: 2px solid #4285f4;\n          padding-bottom: 10px;\n        }\n\n        .controls {\n          display: flex;\n          flex-wrap: wrap;\n          gap: 20px;\n          margin-bottom: 30px;\n          background: #f5f5f5;\n          padding: 15px;\n          border-radius: 8px;\n        }\n\n        .control-section {\n          flex: 1;\n          min-width: 300px;\n        }\n\n        h3 {\n          color: #4285f4;\n          margin-top: 0;\n        }\n\n        .control-row {\n          display: flex;\n          align-items: center;\n          margin-bottom: 12px;\n          gap: 10px;\n        }\n\n        .mode-button,\n        .action-button {\n          padding: 8px 16px;\n          background: #f1f1f1;\n          color: #333;\n          border: 1px solid #ddd;\n          border-radius: 4px;\n          cursor: pointer;\n          font-weight: 500;\n          transition: all 0.2s;\n        }\n\n        .mode-button.active {\n          background: #4285f4;\n          color: white;\n          border-color: #3367d6;\n        }\n\n        .action-button {\n          background: #4285f4;\n          color: white;\n          border: none;\n        }\n\n        .action-button:hover {\n          background: #3367d6;\n        }\n\n        .visualizations {\n          display: flex;\n          flex-wrap: wrap;\n          gap: 20px;\n          margin-bottom: 30px;\n        }\n\n        .visualizations.side-by-side {\n          flex-direction: row;\n        }\n\n        .visualizations.overlay {\n          position: relative;\n          height: 500px;\n        }\n\n        .visualization-container {\n          flex: 1;\n          min-width: 300px;\n          background: #fff;\n          border-radius: 8px;\n          overflow: hidden;\n          box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);\n        }\n\n        .visualizations.overlay .visualization-container {\n          position: absolute;\n          top: 0;\n          left: 0;\n          right: 0;\n          bottom: 0;\n          opacity: 0.7;\n        }\n\n        .visualizations.overlay .optimized {\n          z-index: 2;\n        }\n\n        .visualization-container h3 {\n          padding: 15px;\n          margin: 0;\n          background: #f5f5f5;\n          border-bottom: 1px solid #ddd;\n        }\n\n        .visualization-wrapper {\n          height: 400px;\n          padding: 10px;\n        }\n\n        .placeholder-chart {\n          height: 100%;\n          display: flex;\n          flex-direction: column;\n          justify-content: flex-end;\n          align-items: center;\n          background: #f9f9f9;\n          border-radius: 4px;\n          padding: 10px;\n        }\n\n        .chart-bar {\n          width: 80px;\n          background: linear-gradient(to top, #4285f4, #34a853);\n          border-radius: 4px 4px 0 0;\n        }\n\n        .unoptimized .chart-bar {\n          background: linear-gradient(to top, #ea4335, #fbbc05);\n        }\n\n        .chart-label {\n          margin-top: 10px;\n          font-size: 14px;\n          color: #666;\n        }\n\n        .statistical-analysis {\n          background: #fff;\n          border-radius: 8px;\n          overflow: hidden;\n          box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);\n          margin-bottom: 30px;\n        }\n\n        .statistical-analysis h3 {\n          padding: 15px;\n          margin: 0;\n          background: #f5f5f5;\n          border-bottom: 1px solid #ddd;\n        }\n\n        .comparison-table {\n          width: 100%;\n          border-collapse: collapse;\n        }\n\n        .comparison-table th,\n        .comparison-table td {\n          padding: 12px 15px;\n          text-align: left;\n          border-bottom: 1px solid #eee;\n        }\n\n        .comparison-table th {\n          background: #f9f9f9;\n          font-weight: 500;\n        }\n\n        .comparison-table td.positive {\n          color: #34a853;\n        }\n\n        .comparison-table td.negative {\n          color: #ea4335;\n        }\n        `}\n      </style>\n    </div>\n  );\n};\n\nexport default OptimizationComparisonView;\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/performance/OptimizedFlowDiagram.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/performance/PerformanceBenchmarkDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/performance/PerformanceBudgetTracker.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/performance/PerformanceRegressionReport.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/performance/UserBehaviorCorrelationView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/performance/VisualizationInspector.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_tooltip' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":998,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":998,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_jsHeapSize' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":1420,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":1420,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_handleTabChange' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":1827,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":1827,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_startRecording' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":1832,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":1832,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_stopRecording' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":1839,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":1839,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_getJsHeapSize' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":1846,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":1846,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as d3 from 'd3';\nimport * as React from 'react';\nimport { useEffect, useRef, useState } from 'react';\n\n/**\n * Interface for component performance metrics\n */\ninterface ComponentPerformanceMetrics {\n  // Component identifier\n  id: string;\n  // Component name\n  name: string;\n  // Render time in milliseconds\n  renderTime: number[];\n  // Number of DOM updates\n  domUpdates: number[];\n  // Update frequency (updates per second)\n  updateFrequency: number;\n  // Memory usage estimate\n  memoryUsage: number;\n  // Whether the component is currently visible\n  isVisible: boolean;\n  // DOM element count within component\n  elementCount: number;\n  // Parent component identifier (if any)\n  parentId: string | null | undefined;\n}\n\n/**\n * Interface for DOM mutation record\n */\ninterface DomMutationRecord {\n  // Timestamp of the mutation\n  timestamp: number;\n  // Type of mutation (attributes, childList, characterData)\n  type: 'added' | 'removed' | 'modified';\n  // Target element\n  element: string; // Element description (like 'div.classname')\n  // Component name where this mutation occurred\n  component?: string;\n  // Details about the mutation\n  details?: Record<string, unknown>;\n}\n\n/**\n * Interface for performance issue\n */\ninterface PerformanceIssue {\n  // Timestamp when the issue was detected\n  timestamp: number;\n  // Type of issue\n  type: string;\n  // Severity level\n  severity: 'low' | 'medium' | 'high' | 'critical';\n  // Description of the issue\n  description: string;\n  // Components involved in the issue\n  components: string[];\n  // Stack trace (if available)\n  stackTrace: string;\n  // Duration of the issue (if applicable)\n  duration?: number;\n  // Additional details about the issue\n  details: Record<string, unknown>;\n}\n\n// Interface for rendering performance data\ninterface RenderingPerformanceData {\n  timestamp: number;\n  fps: number;\n  frameTime: number;\n  gpuTime?: number;\n  cpuTime?: number;\n  jsHeapSize?: number;\n}\n\n/**\n * Interface for the visualization inspector props\n */\ninterface VisualizationInspectorProps {\n  // Whether the inspector is active\n  active: boolean;\n  // Dimensions for the visualization container\n  dimensions: { width: number; height: number };\n  // Target component or element to inspect (optional)\n  target?: string;\n  // Callback when issues are detected\n  onIssueDetected?: (issue: PerformanceIssue) => void;\n}\n\n// Define TypeScript interfaces for browser APIs that might not have type definitions\ninterface PerformanceMemory {\n  usedJSHeapSize: number;\n  totalJSHeapSize: number;\n  jsHeapSizeLimit: number;\n  // Add additional properties to match PerformanceMetrics\n  networkLatency?: number;\n  frameDrops?: number;\n  gcTime?: number;\n}\n\n// Define additional types for performance entries\ninterface ExtendedPerformanceEntry extends PerformanceEntry {\n  attribution?: Record<string, unknown>;\n}\n\n// Extend the Performance interface to include the memory property\n// Use a different name to avoid conflict with the global declaration in useDebugOverlay.ts\ndeclare global {\n  interface PerformanceWithMemory extends Performance {\n    memory?: PerformanceMemory;\n  }\n}\n\n// Improve type safety around window access\ninterface WindowWithPerformance extends Window {\n  componentTrackingInterval?: number | NodeJS.Timeout;\n  memoryLeakInterval?: number | NodeJS.Timeout;\n  frameRateTrackingId?: number;\n  performance: PerformanceWithMemory;\n}\n\n/**\n * A comprehensive visualization inspector tool for deep performance analysis\n * including rendering performance, component breakdowns, DOM mutations, and\n * stack trace collection for performance issues.\n */\nexport const VisualizationInspector: React.FC<VisualizationInspectorProps> = ({\n  active,\n  dimensions: { width, height },\n  target,\n  onIssueDetected,\n}) => {\n  // State for component metrics\n  const [componentMetrics, setComponentMetrics] = useState<ComponentPerformanceMetrics[]>([]);\n\n  // State for DOM mutations\n  const [domMutations, setDomMutations] = useState<DomMutationRecord[]>([]);\n\n  // State for performance issues\n  const [performanceIssues, setPerformanceIssues] = useState<PerformanceIssue[]>([]);\n\n  // State for selected tab\n  const [activeTab, setActiveTab] = useState<'rendering' | 'components' | 'dom' | 'issues'>(\n    'rendering'\n  );\n\n  // State for recording status\n  const [isRecording, setIsRecording] = useState<boolean>(false);\n\n  // State for rendering performance data\n  const [renderingPerformanceData, setRenderingPerformanceData] = useState<\n    RenderingPerformanceData[]\n  >([]);\n\n  // State for frame times\n  const [frameTimes, setFrameTimes] = useState<number[]>([]);\n\n  // State for FPS history\n  const [_fpsHistory, setFpsHistory] = useState<number[]>([]);\n\n  // Refs for chart containers\n  const renderingChartRef = useRef<HTMLDivElement>(null);\n  const componentBreakdownRef = useRef<HTMLDivElement>(null);\n  const domMutationsRef = useRef<HTMLDivElement>(null);\n  const issuesListRef = useRef<HTMLDivElement>(null);\n\n  // Ref for performance observer\n  const performanceObserverRef = useRef<PerformanceObserver | null>(null);\n\n  // Ref for mutation observer\n  const mutationObserverRef = useRef<MutationObserver | null>(null);\n\n  // Ref for last frame timestamp\n  const lastFrameTimestampRef = useRef<number>(0);\n\n  // Ref for animation frame ID\n  const animationFrameIdRef = useRef<number>(0);\n\n  // Initialize the inspector when component mounts or active state changes\n  useEffect(() => {\n    if (active) {\n      initializeInspector();\n    }\n\n    return () => {\n      cleanupInspector();\n    };\n  }, [active, target]);\n\n  // Initialize the visualization inspector\n  const initializeInspector = () => {\n    console.warn('Initializing visualization inspector');\n\n    // Set up various inspection features\n    setupRenderingAnalysis();\n    setupComponentBreakdown();\n    setupDomMutationTracking();\n    setupStackTraceCollection();\n\n    // Start recording\n    setIsRecording(true);\n  };\n\n  // Clean up resources when component unmounts or becomes inactive\n  const cleanupInspector = () => {\n    console.warn('Cleaning up visualization inspector');\n\n    // Stop recording\n    setIsRecording(false);\n\n    // Cancel animation frame\n    if (animationFrameIdRef.current) {\n      cancelAnimationFrame(animationFrameIdRef.current);\n      animationFrameIdRef.current = 0;\n    }\n\n    // Disconnect performance observer\n    if (performanceObserverRef.current) {\n      performanceObserverRef.current.disconnect();\n      performanceObserverRef.current = null;\n    }\n\n    // Disconnect mutation observer\n    if (mutationObserverRef.current) {\n      mutationObserverRef.current.disconnect();\n      mutationObserverRef.current = null;\n    }\n\n    // Clear any intervals\n    if (typeof window !== 'undefined') {\n      const win = window as unknown as WindowWithPerformance;\n\n      if (win.componentTrackingInterval) {\n        clearInterval(win.componentTrackingInterval);\n        delete win.componentTrackingInterval;\n      }\n\n      if (win.memoryLeakInterval) {\n        clearInterval(win.memoryLeakInterval);\n        delete win.memoryLeakInterval;\n      }\n\n      if (win.frameRateTrackingId) {\n        cancelAnimationFrame(win.frameRateTrackingId);\n        delete win.frameRateTrackingId;\n      }\n    }\n\n    console.warn('Visualization inspector cleaned up');\n  };\n\n  // Setup deep rendering performance analysis\n  const setupRenderingAnalysis = () => {\n    console.warn('Setting up rendering analysis');\n\n    // Use PerformanceObserver to track long tasks\n    try {\n      if (typeof window !== 'undefined' && 'PerformanceObserver' in window) {\n        const observer = new PerformanceObserver(list => {\n          list.getEntries().forEach(entry => {\n            // Check if this is a long task (> 50ms)\n            if (entry.entryType === 'longtask' && entry.duration > 50) {\n              const now = performance.now();\n\n              // Create performance issue for long task\n              const newIssue: PerformanceIssue = {\n                timestamp: now,\n                type: 'long-task',\n                severity: entry.duration > 100 ? 'critical' : 'high',\n                description: `Long task detected (${entry.duration.toFixed(2)}ms)`,\n                components: [],\n                stackTrace: getStackTrace(),\n                duration: entry.duration,\n                details: {\n                  taskDuration: entry.duration,\n                  taskName: entry.name,\n                  taskAttribution: (entry as ExtendedPerformanceEntry).attribution\n                    ? JSON.stringify((entry as ExtendedPerformanceEntry).attribution)\n                    : 'Unknown',\n                },\n              };\n\n              setPerformanceIssues(prev => [...prev, newIssue]);\n\n              // Trigger callback if provided\n              if (onIssueDetected) {\n                onIssueDetected(newIssue);\n              }\n            }\n          });\n        });\n\n        observer.observe({ entryTypes: ['longtask'] });\n        performanceObserverRef.current = observer;\n      }\n    } catch (error) {\n      console.error('Error setting up PerformanceObserver:', error);\n    }\n\n    // Start frame rate tracking\n    if (isRecording) {\n      startFrameRateTracking();\n    }\n  };\n\n  // Start frame rate tracking\n  const startFrameRateTracking = () => {\n    // (...args: unknown[]) => unknown to update frame data\n    const updateFrame = (timestamp: number): void => {\n      // Calculate time since last animation frame\n      const currentFrameTime = timestamp - lastFrameTimestampRef.current;\n      lastFrameTimestampRef.current = timestamp;\n\n      // Store frame time\n      setFrameTimes(prev => {\n        const newFrameTimes = [...prev, currentFrameTime];\n\n        // Keep only the last 60 frame times\n        return newFrameTimes.slice(-60);\n      });\n\n      // Calculate current FPS\n      if (frameTimes.length > 0) {\n        const avgFrameTime = frameTimes.reduce((sum, time) => sum + time, 0) / frameTimes.length;\n        const currentFps = 1000 / avgFrameTime;\n\n        // Store FPS data point\n        setFpsHistory(prev => {\n          const newFpsHistory = [...prev, currentFps];\n\n          // Keep only the last 120 FPS values (60 seconds at 0.5s updates)\n          return newFpsHistory.slice(-120);\n        });\n\n        // Get JS heap size if available\n        let jsHeapSize = undefined;\n        const windowWithPerformance = window as WindowWithPerformance;\n        if (\n          windowWithPerformance.performance.memory &&\n          windowWithPerformance.performance.memory.usedJSHeapSize\n        ) {\n          jsHeapSize = windowWithPerformance.performance.memory.usedJSHeapSize / (1024 * 1024); // Convert to MB\n        }\n\n        // Add new rendering performance data point\n        setRenderingPerformanceData(prev => {\n          const newData = [\n            ...prev,\n            {\n              timestamp,\n              fps: currentFps,\n              frameTime: avgFrameTime,\n              jsHeapSize,\n            },\n          ];\n\n          // Keep only the last 120 data points\n          return newData.slice(-120);\n        });\n\n        // Detect performance issues\n        if (currentFps < 30 && isRecording) {\n          const now = performance.now();\n\n          // Create a performance issue for low FPS\n          const newIssue: PerformanceIssue = {\n            timestamp: now,\n            type: 'fps-drop',\n            severity: currentFps < 15 ? 'critical' : currentFps < 24 ? 'high' : 'medium',\n            description: `Low FPS detected (${currentFps.toFixed(1)} FPS)`,\n            components: [],\n            stackTrace: getStackTrace(),\n            details: {\n              currentFps,\n              avgFrameTime,\n              jsHeapSize,\n            },\n          };\n\n          setPerformanceIssues(prev => [...prev, newIssue]);\n\n          // Trigger callback if provided\n          if (onIssueDetected) {\n            onIssueDetected(newIssue);\n          }\n        }\n\n        // Update chart if recording\n        if (isRecording && renderingChartRef.current) {\n          updateRenderingPerformanceChart();\n        }\n      }\n\n      // Continue frame rate tracking\n      if (isRecording) {\n        animationFrameIdRef.current = requestAnimationFrame(updateFrame);\n      }\n    };\n\n    // Start tracking\n    animationFrameIdRef.current = requestAnimationFrame(updateFrame);\n  };\n\n  // Update rendering performance chart\n  const updateRenderingPerformanceChart = () => {\n    if (!renderingChartRef.current || renderingPerformanceData.length === 0) return;\n\n    // Clear previous chart\n    const container = d3.select(renderingChartRef.current);\n    container.selectAll('*').remove();\n\n    // Set up chart dimensions\n    const margin = { top: 20, right: 30, bottom: 30, left: 50 };\n    const chartWidth = width - margin.left - margin.right - 40;\n    const chartHeight = (height - margin.top - margin.bottom - 100) / 2; // Divide vertically for 2 charts\n\n    // Create SVG for FPS chart\n    const fpsSvg = container\n      .append('svg')\n      .attr('width', chartWidth + margin.left + margin.right)\n      .attr('height', chartHeight + margin.top + margin.bottom)\n      .append('g')\n      .attr('transform', `translate(${margin.left},${margin.top})`);\n\n    // Set up scales for FPS chart\n    const xScale = d3\n      .scaleTime()\n      .domain(d3.extent(renderingPerformanceData, d => new Date(d.timestamp)) as [Date, Date])\n      .range([0, chartWidth]);\n\n    const yScale = d3\n      .scaleLinear()\n      .domain([0, Math.max(60, d3.max(renderingPerformanceData, d => d.fps) as number)])\n      .range([chartHeight, 0]);\n\n    // Create axes for FPS chart\n    const xAxis = d3.axisBottom(xScale).ticks(5);\n    const yAxis = d3.axisLeft(yScale).ticks(5);\n\n    // Add axes to FPS chart\n    fpsSvg.append('g').attr('transform', `translate(0,${chartHeight})`).call(xAxis);\n\n    fpsSvg.append('g').call(yAxis);\n\n    // Add chart title\n    fpsSvg\n      .append('text')\n      .attr('x', chartWidth / 2)\n      .attr('y', 0)\n      .attr('text-anchor', 'middle')\n      .style('font-size', '14px')\n      .style('font-weight', 'bold')\n      .text('Frames Per Second (FPS)');\n\n    // Create line generator for FPS\n    const fpsLine = d3\n      .line<RenderingPerformanceData>()\n      .x(d => xScale(new Date(d.timestamp)))\n      .y(d => yScale(d.fps))\n      .curve(d3.curveMonotoneX);\n\n    // Add FPS line to chart\n    fpsSvg\n      .append('path')\n      .datum(renderingPerformanceData)\n      .attr('fill', 'none')\n      .attr('stroke', '#4285F4')\n      .attr('stroke-width', 2)\n      .attr('d', fpsLine);\n\n    // Create a 60 FPS reference line\n    fpsSvg\n      .append('line')\n      .attr('x1', 0)\n      .attr('x2', chartWidth)\n      .attr('y1', yScale(60))\n      .attr('y2', yScale(60))\n      .attr('stroke', 'rgba(66, 133, 244, 0.3)')\n      .attr('stroke-dasharray', '4');\n\n    fpsSvg\n      .append('text')\n      .attr('x', chartWidth)\n      .attr('y', yScale(60) - 5)\n      .attr('text-anchor', 'end')\n      .style('font-size', '12px')\n      .style('fill', 'rgba(66, 133, 244, 0.7)')\n      .text('Target: 60 FPS');\n\n    // Create SVG for frame time chart\n    const frameTimeSvg = container\n      .append('svg')\n      .attr('width', chartWidth + margin.left + margin.right)\n      .attr('height', chartHeight + margin.top + margin.bottom)\n      .append('g')\n      .attr('transform', `translate(${margin.left},${margin.top})`);\n\n    // Set up scales for frame time chart\n    const yScaleFrameTime = d3\n      .scaleLinear()\n      .domain([0, Math.max(33, d3.max(renderingPerformanceData, d => d.frameTime) as number)])\n      .range([chartHeight, 0]);\n\n    // Create axes for frame time chart\n    const yAxisFrameTime = d3.axisLeft(yScaleFrameTime).ticks(5);\n\n    // Add axes to frame time chart\n    frameTimeSvg.append('g').attr('transform', `translate(0,${chartHeight})`).call(xAxis);\n\n    frameTimeSvg.append('g').call(yAxisFrameTime);\n\n    // Add chart title\n    frameTimeSvg\n      .append('text')\n      .attr('x', chartWidth / 2)\n      .attr('y', 0)\n      .attr('text-anchor', 'middle')\n      .style('font-size', '14px')\n      .style('font-weight', 'bold')\n      .text('Frame Time (ms)');\n\n    // Create line generator for frame time\n    const frameTimeLine = d3\n      .line<RenderingPerformanceData>()\n      .x(d => xScale(new Date(d.timestamp)))\n      .y(d => yScaleFrameTime(d.frameTime))\n      .curve(d3.curveMonotoneX);\n\n    // Add frame time line to chart\n    frameTimeSvg\n      .append('path')\n      .datum(renderingPerformanceData)\n      .attr('fill', 'none')\n      .attr('stroke', '#EA4335')\n      .attr('stroke-width', 2)\n      .attr('d', frameTimeLine);\n\n    // Create a 16.67ms reference line (60 FPS)\n    frameTimeSvg\n      .append('line')\n      .attr('x1', 0)\n      .attr('x2', chartWidth)\n      .attr('y1', yScaleFrameTime(16.67))\n      .attr('y2', yScaleFrameTime(16.67))\n      .attr('stroke', 'rgba(234, 67, 53, 0.3)')\n      .attr('stroke-dasharray', '4');\n\n    frameTimeSvg\n      .append('text')\n      .attr('x', chartWidth)\n      .attr('y', yScaleFrameTime(16.67) - 5)\n      .attr('text-anchor', 'end')\n      .style('font-size', '12px')\n      .style('fill', 'rgba(234, 67, 53, 0.7)')\n      .text('Target: 16.67ms');\n\n    // Add current statistics\n    const statsDiv = container\n      .append('div')\n      .attr('class', 'performance-stats')\n      .style('margin-top', '20px')\n      .style('padding', '15px')\n      .style('background', '#f5f5f5')\n      .style('border-radius', '4px');\n\n    // Calculate current stats\n    const currentFps =\n      renderingPerformanceData.length > 0\n        ? renderingPerformanceData[renderingPerformanceData.length - 1].fps\n        : 0;\n\n    const averageFrameTime =\n      renderingPerformanceData.length > 0\n        ? renderingPerformanceData[renderingPerformanceData.length - 1].frameTime\n        : 0;\n\n    const currentJsHeapSize =\n      renderingPerformanceData.length > 0 &&\n      renderingPerformanceData[renderingPerformanceData.length - 1].jsHeapSize\n        ? renderingPerformanceData[renderingPerformanceData.length - 1].jsHeapSize\n        : 'N/A';\n\n    // Display stats\n    statsDiv.html(`\n      <div style=\"display: flex; justify-content: space-around; text-align: center;\">\n        <div>\n          <div style=\"font-size: 24px; font-weight: 500; color: ${currentFps < 30 ? '#EA4335' : currentFps < 55 ? '#FBBC05' : '#34A853'};\">\n            ${currentFps}\n          </div>\n          <div style=\"font-size: 14px; color: #666;\">Current FPS</div>\n        </div>\n        \n        <div>\n          <div style=\"font-size: 24px; font-weight: 500; color: ${averageFrameTime > 33 ? '#EA4335' : averageFrameTime > 20 ? '#FBBC05' : '#34A853'};\">\n            ${averageFrameTime.toFixed(2)}\n          </div>\n          <div style=\"font-size: 14px; color: #666;\">Frame Time (ms)</div>\n        </div>\n        \n        <div>\n          <div style=\"font-size: 24px; font-weight: 500;\">\n            ${typeof currentJsHeapSize === 'number' ? currentJsHeapSize.toFixed(1) + ' MB' : currentJsHeapSize}\n          </div>\n          <div style=\"font-size: 14px; color: #666;\">JS Heap</div>\n        </div>\n        \n        <div>\n          <div style=\"font-size: 24px; font-weight: 500;\">\n            ${performance.now().toFixed(0)}\n          </div>\n          <div style=\"font-size: 14px; color: #666;\">Time (ms)</div>\n        </div>\n      </div>\n    `);\n  };\n\n  // Get stack trace for debugging\n  const getStackTrace = (): string => {\n    try {\n      throw new Error('Performance issue detected');\n    } catch (err: unknown) {\n      if (err instanceof Error && err.stack) {\n        return err.stack;\n      }\n      return 'Stack trace unavailable';\n    }\n  };\n\n  // Setup component performance breakdown\n  const setupComponentBreakdown = () => {\n    console.warn('Setting up component performance breakdown');\n\n    // This would typically be done through patching React's reconciler or using a profiler API\n    // For this example, we'll simulate component performance data\n\n    // Sample components to track\n    const sampleComponents = [\n      { id: 'comp-1', name: 'App', parentId: null },\n      { id: 'comp-2', name: 'PerformanceMonitor', parentId: 'comp-1' },\n      { id: 'comp-3', name: 'VisualizationContainer', parentId: 'comp-1' },\n      { id: 'comp-4', name: 'ResourceDisplay', parentId: 'comp-3' },\n      { id: 'comp-5', name: 'StatisticsPanel', parentId: 'comp-3' },\n      { id: 'comp-6', name: 'NavigationBar', parentId: 'comp-1' },\n    ];\n\n    // Initialize metrics for each component\n    const initialMetrics: ComponentPerformanceMetrics[] = sampleComponents.map(comp => ({\n      id: comp.id,\n      name: comp.name,\n      renderTime: [],\n      domUpdates: [],\n      updateFrequency: 0,\n      memoryUsage: 0,\n      isVisible: true,\n      elementCount: Math.floor(Math.random() * 50) + 5, // Random element count between 5 and 54\n      parentId: comp.parentId,\n    }));\n\n    // Set initial component metrics\n    setComponentMetrics(initialMetrics);\n\n    // Set up interval to simulate component performance updates\n    if (isRecording) {\n      startComponentPerformanceTracking();\n    }\n  };\n\n  // Start component performance tracking\n  const startComponentPerformanceTracking = () => {\n    // Clear any previous interval\n    const windowWithPerformance = window as WindowWithPerformance;\n    if (windowWithPerformance.componentTrackingInterval) {\n      clearInterval(windowWithPerformance.componentTrackingInterval);\n    }\n\n    // Set up interval to update component metrics\n    const trackingInterval = setInterval(() => {\n      if (!isRecording) {\n        clearInterval(trackingInterval);\n        return;\n      }\n\n      // Update component metrics\n      setComponentMetrics(prev => {\n        const now = performance.now();\n\n        return prev.map(comp => {\n          // Simulate render time (1-20ms, weighted towards lower values)\n          const renderTime = Math.pow(Math.random(), 2) * 19 + 1;\n\n          // Simulate DOM updates (0-10, integer)\n          const domUpdates = Math.floor(Math.random() * 11);\n\n          // Simulate update frequency based on component type\n          let updateFrequency = 0;\n          if (comp.name.includes('Display') || comp.name.includes('Monitor')) {\n            // High update frequency components\n            updateFrequency = 10 + Math.random() * 20; // 10-30 updates/sec\n          } else if (comp.name.includes('Container') || comp.name.includes('Panel')) {\n            // Medium update frequency components\n            updateFrequency = 5 + Math.random() * 10; // 5-15 updates/sec\n          } else {\n            // Low update frequency components\n            updateFrequency = 1 + Math.random() * 5; // 1-6 updates/sec\n          }\n\n          // Simulate memory usage based on element count\n          const memoryUsage = comp.elementCount * (0.1 + Math.random() * 0.1); // 0.1-0.2 MB per element\n\n          // Look for potential performance issues\n          if (renderTime > 16) {\n            // Create a performance issue for slow rendering\n            const newIssue: PerformanceIssue = {\n              timestamp: now,\n              type: 'excessive-render',\n              severity: renderTime > 50 ? 'critical' : renderTime > 30 ? 'high' : 'medium',\n              description: `Slow render detected in component '${comp.name}' (${renderTime.toFixed(2)}ms)`,\n              components: [comp.name],\n              stackTrace: getStackTrace(),\n              details: {\n                componentId: comp.id,\n                renderTime,\n                updateFrequency,\n                elementCount: comp.elementCount,\n              },\n            };\n\n            setPerformanceIssues(prev => [...prev, newIssue]);\n\n            // Trigger callback if provided\n            if (onIssueDetected) {\n              onIssueDetected(newIssue);\n            }\n          }\n\n          if (domUpdates > 5) {\n            // Create a performance issue for DOM churn\n            const newIssue: PerformanceIssue = {\n              timestamp: now,\n              type: 'dom-churn',\n              severity: domUpdates > 8 ? 'high' : 'medium',\n              description: `High DOM update frequency in component '${comp.name}' (${domUpdates} updates)`,\n              components: [comp.name],\n              stackTrace: getStackTrace(),\n              details: {\n                componentId: comp.id,\n                domUpdates,\n                renderTime,\n                elementCount: comp.elementCount,\n              },\n            };\n\n            setPerformanceIssues(prev => [...prev, newIssue]);\n\n            // Trigger callback if provided\n            if (onIssueDetected) {\n              onIssueDetected(newIssue);\n            }\n          }\n\n          // Add new data point to the component metrics\n          return {\n            ...comp,\n            renderTime: [...comp.renderTime, renderTime],\n            domUpdates: [...comp.domUpdates, domUpdates],\n            updateFrequency,\n            memoryUsage,\n            isVisible: Math.random() > 0.1, // 90% chance of being visible\n          };\n        });\n      });\n\n      // Update component breakdown visualization if visible\n      if (componentBreakdownRef.current && activeTab === 'components') {\n        updateComponentBreakdownChart();\n      }\n    }, 1000); // Update every second\n\n    // Store interval reference for cleanup\n    windowWithPerformance.componentTrackingInterval = trackingInterval;\n  };\n\n  // Update component breakdown chart\n  const updateComponentBreakdownChart = () => {\n    if (!componentBreakdownRef.current || componentMetrics.length === 0) return;\n\n    // Clear previous chart\n    const container = d3.select(componentBreakdownRef.current);\n    container.selectAll('*').remove();\n\n    // Create tabs for different visualizations\n    const tabContainer = container\n      .append('div')\n      .attr('class', 'component-tabs')\n      .style('margin-bottom', '15px');\n\n    const tabs = ['Render Time', 'DOM Updates', 'Memory Usage', 'Update Frequency'];\n\n    // Add tab buttons\n    tabContainer\n      .selectAll('.component-tab-button')\n      .data(tabs)\n      .enter()\n      .append('button')\n      .attr('class', (_d: string, i: number) => `component-tab-button ${i === 0 ? 'active' : ''}`)\n      .text((d: string) => d)\n      .style('padding', '8px 12px')\n      .style('margin-right', '5px')\n      .style('background', (_d: string, i: number) => (i === 0 ? '#4285f4' : '#f1f1f1'))\n      .style('color', (_d: string, i: number) => (i === 0 ? 'white' : '#333'))\n      .style('border', 'none')\n      .style('border-radius', '4px')\n      .style('cursor', 'pointer')\n      .on('click', function (_event: MouseEvent, d: string) {\n        // Update active tab\n        tabContainer\n          .selectAll('.component-tab-button')\n          .style('background', '#f1f1f1')\n          .style('color', '#333');\n\n        d3.select(this).style('background', '#4285f4').style('color', 'white');\n\n        // Update chart based on selected tab\n        updateComponentVisualization(d);\n      });\n\n    // Create container for the visualization\n    const chartContainer = container\n      .append('div')\n      .attr('class', 'component-chart-container')\n      .style('height', `${height - 200}px`);\n\n    // Initially show render time visualization\n    updateComponentVisualization('Render Time');\n\n    // Nested function to update visualization based on selected tab\n    function updateComponentVisualization(tab: string) {\n      // Clear chart container\n      chartContainer.selectAll('*').remove();\n\n      // Sort components by metric\n      const sortedComponents = [...componentMetrics];\n\n      if (tab === 'Render Time') {\n        sortedComponents.sort((a, b) => {\n          const aAvg = a.renderTime.length\n            ? a.renderTime.reduce((sum, time) => sum + time, 0) / a.renderTime.length\n            : 0;\n          const bAvg = b.renderTime.length\n            ? b.renderTime.reduce((sum, time) => sum + time, 0) / b.renderTime.length\n            : 0;\n          return bAvg - aAvg;\n        });\n\n        // Create bar chart for render time\n        createBarChart(\n          sortedComponents,\n          comp =>\n            comp.renderTime.length\n              ? comp.renderTime.reduce((sum, time) => sum + time, 0) / comp.renderTime.length\n              : 0,\n          'Average Render Time (ms)',\n          comp => {\n            const avg = comp.renderTime.length\n              ? comp.renderTime.reduce((sum, time) => sum + time, 0) / comp.renderTime.length\n              : 0;\n            return avg > 16 ? '#EA4335' : avg > 8 ? '#FBBC05' : '#34A853';\n          }\n        );\n      } else if (tab === 'DOM Updates') {\n        sortedComponents.sort((a, b) => {\n          const aAvg = a.domUpdates.length\n            ? a.domUpdates.reduce((sum, updates) => sum + updates, 0) / a.domUpdates.length\n            : 0;\n          const bAvg = b.domUpdates.length\n            ? b.domUpdates.reduce((sum, updates) => sum + updates, 0) / b.domUpdates.length\n            : 0;\n          return bAvg - aAvg;\n        });\n\n        // Create bar chart for DOM updates\n        createBarChart(\n          sortedComponents,\n          comp =>\n            comp.domUpdates.length\n              ? comp.domUpdates.reduce((sum, updates) => sum + updates, 0) / comp.domUpdates.length\n              : 0,\n          'Average DOM Updates (per render)',\n          comp => {\n            const avg = comp.domUpdates.length\n              ? comp.domUpdates.reduce((sum, updates) => sum + updates, 0) / comp.domUpdates.length\n              : 0;\n            return avg > 5 ? '#EA4335' : avg > 3 ? '#FBBC05' : '#34A853';\n          }\n        );\n      } else if (tab === 'Memory Usage') {\n        sortedComponents.sort((a, b) => b.memoryUsage - a.memoryUsage);\n\n        // Create bar chart for memory usage\n        createBarChart(\n          sortedComponents,\n          comp => comp.memoryUsage,\n          'Memory Usage (MB)',\n          comp => (comp.memoryUsage > 5 ? '#EA4335' : comp.memoryUsage > 2 ? '#FBBC05' : '#34A853')\n        );\n      } else if (tab === 'Update Frequency') {\n        sortedComponents.sort((a, b) => b.updateFrequency - a.updateFrequency);\n\n        // Create bar chart for update frequency\n        createBarChart(\n          sortedComponents,\n          comp => comp.updateFrequency,\n          'Update Frequency (per second)',\n          comp =>\n            comp.updateFrequency > 20\n              ? '#EA4335'\n              : comp.updateFrequency > 10\n                ? '#FBBC05'\n                : '#34A853'\n        );\n      }\n    }\n\n    // Helper function to create a bar chart\n    function createBarChart(\n      data: ComponentPerformanceMetrics[],\n      valueAccessor: (comp: ComponentPerformanceMetrics) => number,\n      yAxisLabel: string,\n      colorAccessor: (comp: ComponentPerformanceMetrics) => string\n    ) {\n      // Set up chart dimensions\n      const margin = { top: 20, right: 80, bottom: 50, left: 150 };\n      const chartWidth = width - margin.left - margin.right - 40;\n      const chartHeight = height - margin.top - margin.bottom - 250;\n      const barHeight = Math.max(Math.min(30, chartHeight / data?.length - 5), 10);\n\n      // Create SVG\n      const svg = chartContainer\n        .append('svg')\n        .attr('width', chartWidth + margin.left + margin.right)\n        .attr(\n          'height',\n          Math.max(chartHeight, data?.length * (barHeight + 5)) + margin.top + margin.bottom\n        )\n        .append('g')\n        .attr('transform', `translate(${margin.left},${margin.top})`);\n\n      // Set up scales\n      const xScale = d3\n        .scaleLinear()\n        .domain([0, (d3.max(data, valueAccessor) as number) * 1.1])\n        .range([0, chartWidth]);\n\n      const yScale = d3\n        .scaleBand()\n        .domain(data?.map(d => d.name))\n        .range([0, Math.max(chartHeight, data?.length * (barHeight + 5))])\n        .padding(0.2);\n\n      // Create axes\n      const xAxis = d3.axisBottom(xScale);\n      const yAxis = d3.axisLeft(yScale);\n\n      // Add axes\n      svg\n        .append('g')\n        .attr('transform', `translate(0,${Math.max(chartHeight, data?.length * (barHeight + 5))})`)\n        .call(xAxis)\n        .append('text')\n        .attr('x', chartWidth / 2)\n        .attr('y', 35)\n        .attr('fill', '#333')\n        .style('text-anchor', 'middle')\n        .style('font-size', '12px')\n        .text(yAxisLabel);\n\n      svg.append('g').call(yAxis);\n\n      // Add bars\n      svg\n        .selectAll('.bar')\n        .data(data)\n        .enter()\n        .append('rect')\n        .attr('class', 'bar')\n        .attr('x', 0)\n        .attr('y', (_d, i) => {\n          const yPos = yScale(i.toString());\n          return yPos !== undefined ? yPos + barHeight / 2 : 0;\n        })\n        .attr('width', (d: ComponentPerformanceMetrics) => xScale(valueAccessor(d)))\n        .attr('height', barHeight)\n        .attr('fill', (d: ComponentPerformanceMetrics) => colorAccessor(d))\n        .attr('opacity', (d: ComponentPerformanceMetrics) => (d.isVisible ? 1 : 0.5))\n        .on('mouseover', function (_event: MouseEvent, d: ComponentPerformanceMetrics) {\n          // Show tooltip\n          const _tooltip = d3\n            .select('body')\n            .append('div')\n            .attr('class', 'component-tooltip')\n            .style('position', 'absolute')\n            .style('background', 'rgba(0,0,0,0.7)')\n            .style('color', 'white')\n            .style('padding', '5px')\n            .style('border-radius', '3px')\n            .style('font-size', '12px')\n            .style('pointer-events', 'none')\n            .html(\n              `\n              <div><strong>${d.name}</strong></div>\n              <div>${yAxisLabel}: ${valueAccessor(d).toFixed(2)}</div>\n              <div>Elements: ${d.elementCount}</div>\n              <div>Memory: ${d.memoryUsage.toFixed(2)} MB</div>\n            `\n            )\n            .style('left', `${_event?.pageX + 10}px`)\n            .style('top', `${_event?.pageY - 28}px`);\n\n          // Highlight bar\n          d3.select(this).attr('fill', '#4285F4');\n        })\n        .on('mouseout', function () {\n          // Remove tooltip\n          d3.select('.component-tooltip').remove();\n\n          // Restore bar color\n          d3.select(this).attr('fill', function (_d) {\n            return colorAccessor(_d as ComponentPerformanceMetrics);\n          });\n        });\n    }\n  };\n\n  // Setup DOM mutation tracking\n  const setupDomMutationTracking = () => {\n    console.warn('Setting up DOM mutation tracking');\n\n    // Create a mutation observer to track DOM changes\n    if (typeof window !== 'undefined' && typeof MutationObserver !== 'undefined') {\n      const observer = new MutationObserver(mutations => {\n        if (!isRecording) return;\n\n        mutations.forEach(mutation => {\n          // Process the mutation\n          const now = performance.now();\n          let mutationType: 'added' | 'removed' | 'modified';\n\n          if (mutation.type === 'childList') {\n            if (mutation.addedNodes.length > 0) {\n              mutationType = 'added';\n            } else if (mutation.removedNodes.length > 0) {\n              mutationType = 'removed';\n            } else {\n              // Skip if no nodes were actually added or removed\n              return;\n            }\n          } else if (mutation.type === 'attributes' || mutation.type === 'characterData') {\n            mutationType = 'modified';\n          } else {\n            // Skip unknown mutation types\n            return;\n          }\n\n          // Create a DOM mutation record\n          const newMutation: DomMutationRecord = {\n            timestamp: now,\n            type: mutationType,\n            element: getElementDescription(mutation.target as Element),\n            details: {\n              mutationType: mutation.type,\n              attributeName: mutation.attributeName || undefined,\n              oldValue: mutation.oldValue || undefined,\n              addedNodes: mutation.addedNodes.length,\n              removedNodes: mutation.removedNodes.length,\n            },\n          };\n\n          // Store the mutation\n          setDomMutations(prev => {\n            const newMutations = [...prev, newMutation];\n\n            // Keep only the last 1000 mutations\n            return newMutations.slice(-1000);\n          });\n\n          // Check for potential performance issues\n          if (\n            mutation.type === 'childList' &&\n            (mutation.addedNodes.length > 10 || mutation.removedNodes.length > 10)\n          ) {\n            // Create a performance issue for large DOM mutation\n            const newIssue: PerformanceIssue = {\n              timestamp: now,\n              type: 'large-dom-mutation',\n              severity:\n                mutation.addedNodes.length + mutation.removedNodes.length > 50\n                  ? 'high'\n                  : mutation.addedNodes.length + mutation.removedNodes.length > 20\n                    ? 'medium'\n                    : 'low',\n              description: `Large DOM mutation detected (${mutation.addedNodes.length} nodes added, ${mutation.removedNodes.length} nodes removed)`,\n              components: [],\n              stackTrace: getStackTrace(),\n              details: {\n                targetElement: getElementDescription(mutation.target as Element),\n                addedNodes: mutation.addedNodes.length,\n                removedNodes: mutation.removedNodes.length,\n                parentElement: mutation.target.parentElement\n                  ? getElementDescription(mutation.target.parentElement)\n                  : 'none',\n              },\n            };\n\n            setPerformanceIssues(prev => [...prev, newIssue]);\n\n            // Trigger callback if provided\n            if (onIssueDetected) {\n              onIssueDetected(newIssue);\n            }\n          }\n        });\n\n        // Update DOM mutation visualization if visible\n        if (domMutationsRef.current && activeTab === 'dom') {\n          updateDomMutationChart();\n        }\n      });\n\n      // Configure the observer to track all mutation types\n      observer.observe(document.documentElement, {\n        attributes: true,\n        childList: true,\n        characterData: true,\n        subtree: true,\n        attributeOldValue: true,\n        characterDataOldValue: true,\n      });\n\n      // Store the observer for cleanup\n      mutationObserverRef.current = observer;\n    }\n  };\n\n  // Update DOM mutation chart\n  const updateDomMutationChart = () => {\n    if (!domMutationsRef.current || domMutations.length === 0) return;\n\n    // Clear previous chart\n    const container = d3.select(domMutationsRef.current);\n    container.selectAll('*').remove();\n\n    // Create a container for the mutation history\n    const mutationHistoryContainer = container\n      .append('div')\n      .attr('class', 'mutation-history-container')\n      .style('height', `${height - 200}px`)\n      .style('overflow-y', 'auto')\n      .style('font-family', 'monospace');\n\n    // Create a header row\n    mutationHistoryContainer\n      .append('div')\n      .attr('class', 'mutation-header')\n      .style('display', 'grid')\n      .style('grid-template-columns', '120px 100px 1fr 120px')\n      .style('gap', '10px')\n      .style('padding', '10px')\n      .style('background', '#f0f0f0')\n      .style('font-weight', 'bold')\n      .style('border-bottom', '1px solid #ddd').html(`\n        <div>Time</div>\n        <div>Type</div>\n        <div>Element</div>\n        <div>Details</div>\n      `);\n\n    // Get recent mutations (last 100)\n    const recentMutations = domMutations.slice(-100).reverse();\n\n    // Create rows for each mutation\n    recentMutations.forEach(mutation => {\n      const date = new Date(mutation.timestamp);\n      const timeString = `${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}:${date.getSeconds().toString().padStart(2, '0')}.${date.getMilliseconds().toString().padStart(3, '0')}`;\n\n      const row = mutationHistoryContainer\n        .append('div')\n        .attr('class', `mutation-row ${mutation.type}`)\n        .style('display', 'grid')\n        .style('grid-template-columns', '120px 100px 1fr 120px')\n        .style('gap', '10px')\n        .style('padding', '10px')\n        .style('border-bottom', '1px solid #ddd')\n        .style(\n          'background',\n          mutation.type === 'added'\n            ? 'rgba(52, 168, 83, 0.1)'\n            : mutation.type === 'removed'\n              ? 'rgba(234, 67, 53, 0.1)'\n              : 'rgba(251, 188, 5, 0.1)'\n        );\n\n      // Add time\n      row.append('div').text(timeString);\n\n      // Add type\n      row\n        .append('div')\n        .text(mutation.type)\n        .style(\n          'color',\n          mutation.type === 'added'\n            ? '#34A853'\n            : mutation.type === 'removed'\n              ? '#EA4335'\n              : '#FBBC05'\n        );\n\n      // Add element\n      row\n        .append('div')\n        .text(mutation.element)\n        .style('white-space', 'nowrap')\n        .style('overflow', 'hidden')\n        .style('text-overflow', 'ellipsis');\n\n      // Add details button\n      row\n        .append('div')\n        .append('button')\n        .text('View Details')\n        .style('background', '#f1f1f1')\n        .style('border', 'none')\n        .style('padding', '3px 8px')\n        .style('border-radius', '4px')\n        .style('cursor', 'pointer')\n        .on('click', function () {\n          // Show details in a modal-like overlay\n          const detailsOverlay = container\n            .append('div')\n            .attr('class', 'details-overlay')\n            .style('position', 'absolute')\n            .style('top', '50%')\n            .style('left', '50%')\n            .style('transform', 'translate(-50%, -50%)')\n            .style('background', 'white')\n            .style('box-shadow', '0 4px 12px rgba(0, 0, 0, 0.15)')\n            .style('padding', '20px')\n            .style('border-radius', '8px')\n            .style('z-index', '1000')\n            .style('max-width', '80%')\n            .style('max-height', '80%')\n            .style('overflow', 'auto');\n\n          // Add title\n          detailsOverlay\n            .append('h3')\n            .text(`Mutation Details: ${mutation.type}`)\n            .style('margin-top', '0')\n            .style('border-bottom', '1px solid #eee')\n            .style('padding-bottom', '10px');\n\n          // Add content\n          const detailsContent = detailsOverlay.append('div').style('margin-bottom', '20px');\n\n          // Basic info\n          detailsContent.append('p').html(`<strong>Time:</strong> ${timeString}`);\n\n          detailsContent.append('p').html(`<strong>Type:</strong> ${mutation.type}`);\n\n          detailsContent.append('p').html(`<strong>Element:</strong> ${mutation.element}`);\n\n          // Details based on mutation details\n          const details = mutation.details as {\n            mutationType: string;\n            attributeName?: string;\n            oldValue?: string;\n            addedNodes: number;\n            removedNodes: number;\n          };\n\n          if (details) {\n            detailsContent\n              .append('p')\n              .html(`<strong>Mutation Type:</strong> ${details.mutationType}`);\n\n            if (details.attributeName) {\n              detailsContent\n                .append('p')\n                .html(`<strong>Attribute:</strong> ${details.attributeName}`);\n            }\n\n            if (details.oldValue) {\n              detailsContent.append('p').html(`<strong>Old Value:</strong> ${details.oldValue}`);\n            }\n\n            if (details.addedNodes > 0) {\n              detailsContent\n                .append('p')\n                .html(`<strong>Added Nodes:</strong> ${details.addedNodes}`);\n            }\n\n            if (details.removedNodes > 0) {\n              detailsContent\n                .append('p')\n                .html(`<strong>Removed Nodes:</strong> ${details.removedNodes}`);\n            }\n          }\n\n          // Add close button\n          detailsOverlay\n            .append('button')\n            .text('Close')\n            .style('background', '#4285F4')\n            .style('color', 'white')\n            .style('border', 'none')\n            .style('padding', '8px 16px')\n            .style('border-radius', '4px')\n            .style('cursor', 'pointer')\n            .on('click', function () {\n              detailsOverlay.remove();\n            });\n        });\n    });\n\n    // Add summary information\n    const summaryContainer = container\n      .append('div')\n      .attr('class', 'mutation-summary')\n      .style('margin-top', '20px')\n      .style('display', 'grid')\n      .style('grid-template-columns', 'repeat(4, 1fr)')\n      .style('gap', '10px');\n\n    // Added nodes count\n    const addedCount = domMutations.filter(m => m.type === 'added').length;\n    summaryContainer\n      .append('div')\n      .attr('class', 'summary-card')\n      .style('background', 'rgba(52, 168, 83, 0.1)')\n      .style('padding', '15px')\n      .style('border-radius', '8px')\n      .style('text-align', 'center').html(`\n        <div style=\"font-size: 24px; font-weight: bold; color: #34A853\">${addedCount}</div>\n        <div>Added Elements</div>\n      `);\n\n    // Removed nodes count\n    const removedCount = domMutations.filter(m => m.type === 'removed').length;\n    summaryContainer\n      .append('div')\n      .attr('class', 'summary-card')\n      .style('background', 'rgba(234, 67, 53, 0.1)')\n      .style('padding', '15px')\n      .style('border-radius', '8px')\n      .style('text-align', 'center').html(`\n        <div style=\"font-size: 24px; font-weight: bold; color: #EA4335\">${removedCount}</div>\n        <div>Removed Elements</div>\n      `);\n\n    // Modified nodes count\n    const modifiedCount = domMutations.filter(m => m.type === 'modified').length;\n    summaryContainer\n      .append('div')\n      .attr('class', 'summary-card')\n      .style('background', 'rgba(251, 188, 5, 0.1)')\n      .style('padding', '15px')\n      .style('border-radius', '8px')\n      .style('text-align', 'center').html(`\n        <div style=\"font-size: 24px; font-weight: bold; color: #FBBC05\">${modifiedCount}</div>\n        <div>Modified Elements</div>\n      `);\n\n    // Total mutations\n    summaryContainer\n      .append('div')\n      .attr('class', 'summary-card')\n      .style('background', 'rgba(66, 133, 244, 0.1)')\n      .style('padding', '15px')\n      .style('border-radius', '8px')\n      .style('text-align', 'center').html(`\n        <div style=\"font-size: 24px; font-weight: bold; color: #4285F4\">${domMutations.length}</div>\n        <div>Total Mutations</div>\n      `);\n  };\n\n  // Helper function to get a readable description of an element\n  const getElementDescription = (element: Element): string => {\n    if (!element || !element.tagName) return 'Unknown Element';\n\n    let description = element.tagName.toLowerCase();\n\n    if (element.id) {\n      description += `#${element.id}`;\n    }\n\n    if (element.className && typeof element.className === 'string') {\n      description += `.${element.className.split(' ').join('.')}`;\n    }\n\n    return description;\n  };\n\n  // Setup stack trace collection\n  const setupStackTraceCollection = () => {\n    console.warn('Setting up stack trace collection');\n\n    // No direct setup needed - stack traces are collected when performance issues are detected\n\n    // Set up a periodic check for memory leaks\n    const memoryLeakInterval = setInterval(() => {\n      if (!isRecording) {\n        clearInterval(memoryLeakInterval);\n        return;\n      }\n\n      // Check for memory growth if the memory API is available\n      const windowWithPerformance = window as WindowWithPerformance;\n      if (windowWithPerformance.performance.memory) {\n        const _jsHeapSize = windowWithPerformance.performance.memory.usedJSHeapSize / (1024 * 1024); // Convert to MB\n\n        // If we have enough data points, check for consistent memory growth\n        if (renderingPerformanceData.length > 10) {\n          const recentMemoryData = renderingPerformanceData\n            .slice(-10)\n            .map(d => d.jsHeapSize)\n            .filter((size): size is number => size !== undefined);\n\n          if (recentMemoryData.length > 5) {\n            // Check if memory has been consistently growing\n            let consistentGrowth = true;\n            for (let i = 1; i < recentMemoryData.length; i++) {\n              if (recentMemoryData[i] <= recentMemoryData[i - 1]) {\n                consistentGrowth = false;\n                break;\n              }\n            }\n\n            // Calculate growth rate\n            const growthRate =\n              (recentMemoryData[recentMemoryData.length - 1] - recentMemoryData[0]) /\n              recentMemoryData[0];\n\n            // If memory is consistently growing at a significant rate, create a performance issue\n            if (consistentGrowth && growthRate > 0.1) {\n              const now = performance.now();\n\n              // Create a performance issue for memory leak\n              const newIssue: PerformanceIssue = {\n                timestamp: now,\n                type: 'memory-leak',\n                severity: growthRate > 0.5 ? 'critical' : growthRate > 0.25 ? 'high' : 'medium',\n                description: `Potential memory leak detected: ${(growthRate * 100).toFixed(1)}% growth over ${recentMemoryData.length} samples`,\n                components: [],\n                stackTrace: getStackTrace(),\n                details: {\n                  initialMemory: recentMemoryData[0],\n                  currentMemory: recentMemoryData[recentMemoryData.length - 1],\n                  growthRate: growthRate,\n                  growthRatePercent: growthRate * 100,\n                  samples: recentMemoryData.length,\n                },\n              };\n\n              setPerformanceIssues(prev => [...prev, newIssue]);\n\n              // Trigger callback if provided\n              if (onIssueDetected) {\n                onIssueDetected(newIssue);\n              }\n            }\n          }\n        }\n      }\n    }, 5000); // Check every 5 seconds\n\n    // Store interval ID in window for cleanup\n    const windowWithPerformance = window as WindowWithPerformance;\n    if (typeof window !== 'undefined') {\n      windowWithPerformance.memoryLeakInterval = memoryLeakInterval;\n    }\n\n    // Update issues list if visible\n    if (issuesListRef.current && activeTab === 'issues') {\n      updateIssuesList();\n    }\n  };\n\n  // Update the issues list display\n  const updateIssuesList = () => {\n    if (!issuesListRef.current || performanceIssues.length === 0) return;\n\n    // Clear previous content\n    const container = d3.select(issuesListRef.current);\n    container.selectAll('*').remove();\n\n    // Create a container for the issues list\n    const issuesContainer = container\n      .append('div')\n      .attr('class', 'issues-container')\n      .style('height', `${height - 200}px`)\n      .style('overflow-y', 'auto')\n      .style('font-family', 'system-ui, -apple-system, sans-serif');\n\n    // Create a header row\n    issuesContainer\n      .append('div')\n      .attr('class', 'issues-header')\n      .style('display', 'grid')\n      .style('grid-template-columns', '120px 100px 1fr 120px')\n      .style('gap', '10px')\n      .style('padding', '10px')\n      .style('background', '#f0f0f0')\n      .style('font-weight', 'bold')\n      .style('border-bottom', '1px solid #ddd').html(`\n        <div>Time</div>\n        <div>Severity</div>\n        <div>Description</div>\n        <div>Actions</div>\n      `);\n\n    // Group issues by type\n    const issuesByType: Record<string, PerformanceIssue[]> = {};\n    performanceIssues.forEach(issue => {\n      if (!issuesByType[issue.type]) {\n        issuesByType[issue.type] = [];\n      }\n      issuesByType[issue.type].push(issue);\n    });\n\n    // Process each type of issue\n    Object.entries(issuesByType).forEach(([type, issues]) => {\n      // Add a group header for the issue type\n      issuesContainer\n        .append('div')\n        .attr('class', 'issue-type-header')\n        .style('padding', '12px 10px')\n        .style('background', '#e9e9e9')\n        .style('font-weight', 'bold')\n        .style('border-bottom', '1px solid #ddd')\n        .style('position', 'sticky')\n        .style('top', '0')\n        .style('z-index', '1').html(`\n          <div>${formatIssueType(type)} (${issues.length})</div>\n        `);\n\n      // Sort issues by severity and recency\n      const sortedIssues = [...issues].sort((a, b) => {\n        // First by severity\n        const severityOrder = { critical: 0, high: 1, medium: 2, low: 3 };\n        const severityDiff =\n          severityOrder[a.severity as keyof typeof severityOrder] -\n          severityOrder[b.severity as keyof typeof severityOrder];\n\n        if (severityDiff !== 0) return severityDiff;\n\n        // Then by timestamp (most recent first)\n        return b.timestamp - a.timestamp;\n      });\n\n      // Create rows for each issue\n      sortedIssues.forEach(issue => {\n        const date = new Date(issue.timestamp);\n        const timeString = `${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}:${date.getSeconds().toString().padStart(2, '0')}`;\n\n        const row = issuesContainer\n          .append('div')\n          .attr('class', `issue-row ${issue.severity}`)\n          .style('display', 'grid')\n          .style('grid-template-columns', '120px 100px 1fr 120px')\n          .style('gap', '10px')\n          .style('padding', '10px')\n          .style('border-bottom', '1px solid #ddd')\n          .style(\n            'background',\n            issue.severity === 'critical'\n              ? 'rgba(234, 67, 53, 0.1)'\n              : issue.severity === 'high'\n                ? 'rgba(251, 188, 5, 0.1)'\n                : issue.severity === 'medium'\n                  ? 'rgba(66, 133, 244, 0.1)'\n                  : 'rgba(52, 168, 83, 0.1)'\n          );\n\n        // Add time\n        row.append('div').text(timeString);\n\n        // Add severity\n        row\n          .append('div')\n          .text(issue.severity)\n          .style(\n            'color',\n            issue.severity === 'critical'\n              ? '#EA4335'\n              : issue.severity === 'high'\n                ? '#FBBC05'\n                : issue.severity === 'medium'\n                  ? '#4285F4'\n                  : '#34A853'\n          )\n          .style('font-weight', 'bold');\n\n        // Add description\n        row\n          .append('div')\n          .text(issue.description)\n          .style('white-space', 'nowrap')\n          .style('overflow', 'hidden')\n          .style('text-overflow', 'ellipsis');\n\n        // Add details button\n        row\n          .append('div')\n          .append('button')\n          .text('View Details')\n          .style('background', '#f1f1f1')\n          .style('border', 'none')\n          .style('padding', '3px 8px')\n          .style('border-radius', '4px')\n          .style('cursor', 'pointer')\n          .on('click', function () {\n            // Show details in a modal-like overlay\n            const detailsOverlay = container\n              .append('div')\n              .attr('class', 'details-overlay')\n              .style('position', 'absolute')\n              .style('top', '50%')\n              .style('left', '50%')\n              .style('transform', 'translate(-50%, -50%)')\n              .style('background', 'white')\n              .style('box-shadow', '0 4px 12px rgba(0, 0, 0, 0.15)')\n              .style('padding', '20px')\n              .style('border-radius', '8px')\n              .style('z-index', '1000')\n              .style('max-width', '80%')\n              .style('max-height', '80%')\n              .style('overflow', 'auto');\n\n            // Add title\n            detailsOverlay\n              .append('h3')\n              .text(`Issue Details: ${formatIssueType(type)}`)\n              .style('margin-top', '0')\n              .style('border-bottom', '1px solid #eee')\n              .style('padding-bottom', '10px');\n\n            // Add content\n            const detailsContent = detailsOverlay.append('div').style('margin-bottom', '20px');\n\n            // Basic info\n            detailsContent.append('p').html(`<strong>Time:</strong> ${timeString}`);\n\n            detailsContent\n              .append('p')\n              .html(\n                `<strong>Severity:</strong> <span style=\"color: ${\n                  issue.severity === 'critical'\n                    ? '#EA4335'\n                    : issue.severity === 'high'\n                      ? '#FBBC05'\n                      : issue.severity === 'medium'\n                        ? '#4285F4'\n                        : '#34A853'\n                }; font-weight: bold;\">${issue.severity}</span>`\n              );\n\n            detailsContent.append('p').html(`<strong>Description:</strong> ${issue.description}`);\n\n            // Add affected components if available\n            if (issue.components && issue.components.length > 0) {\n              detailsContent\n                .append('p')\n                .html(`<strong>Affected Components:</strong> ${issue.components.join(', ')}`);\n            }\n\n            // Add issue details\n            detailsContent\n              .append('h4')\n              .text('Details')\n              .style('margin-top', '15px')\n              .style('margin-bottom', '10px');\n\n            // Format details as a list\n            const detailsList = detailsContent\n              .append('ul')\n              .style('margin-top', '10px')\n              .style('padding-left', '20px');\n\n            Object.entries(issue.details).forEach(([key, value]) => {\n              detailsList\n                .append('li')\n                .html(`<strong>${formatPropertyName(key)}:</strong> ${formatPropertyValue(value)}`);\n            });\n\n            // Add stack trace\n            detailsContent\n              .append('h4')\n              .text('Stack Trace')\n              .style('margin-top', '15px')\n              .style('margin-bottom', '10px');\n\n            // Format stack trace\n            const stackTraceContainer = detailsContent\n              .append('div')\n              .style('background', '#f5f5f5')\n              .style('padding', '10px')\n              .style('border-radius', '4px')\n              .style('font-family', 'monospace')\n              .style('white-space', 'pre-wrap')\n              .style('font-size', '12px')\n              .style('max-height', '200px')\n              .style('overflow-y', 'auto');\n\n            stackTraceContainer.text(issue.stackTrace);\n\n            // Add close button\n            detailsOverlay\n              .append('button')\n              .text('Close')\n              .style('background', '#4285F4')\n              .style('color', 'white')\n              .style('border', 'none')\n              .style('padding', '8px 16px')\n              .style('border-radius', '4px')\n              .style('cursor', 'pointer')\n              .on('click', function () {\n                detailsOverlay.remove();\n              });\n          });\n      });\n    });\n\n    // Add summary information\n    const summaryContainer = container\n      .append('div')\n      .attr('class', 'issues-summary')\n      .style('margin-top', '20px')\n      .style('display', 'grid')\n      .style('grid-template-columns', 'repeat(4, 1fr)')\n      .style('gap', '10px');\n\n    // Critical issues count\n    const criticalCount = performanceIssues.filter(issue => issue.severity === 'critical').length;\n    summaryContainer\n      .append('div')\n      .attr('class', 'summary-card')\n      .style('background', 'rgba(234, 67, 53, 0.1)')\n      .style('padding', '15px')\n      .style('border-radius', '8px')\n      .style('text-align', 'center').html(`\n        <div style=\"font-size: 24px; font-weight: bold; color: #EA4335\">${criticalCount}</div>\n        <div>Critical Issues</div>\n      `);\n\n    // High severity issues count\n    const highCount = performanceIssues.filter(issue => issue.severity === 'high').length;\n    summaryContainer\n      .append('div')\n      .attr('class', 'summary-card')\n      .style('background', 'rgba(251, 188, 5, 0.1)')\n      .style('padding', '15px')\n      .style('border-radius', '8px')\n      .style('text-align', 'center').html(`\n        <div style=\"font-size: 24px; font-weight: bold; color: #FBBC05\">${highCount}</div>\n        <div>High Severity Issues</div>\n      `);\n\n    // Medium severity issues count\n    const mediumCount = performanceIssues.filter(issue => issue.severity === 'medium').length;\n    summaryContainer\n      .append('div')\n      .attr('class', 'summary-card')\n      .style('background', 'rgba(66, 133, 244, 0.1)')\n      .style('padding', '15px')\n      .style('border-radius', '8px')\n      .style('text-align', 'center').html(`\n        <div style=\"font-size: 24px; font-weight: bold; color: #4285F4\">${mediumCount}</div>\n        <div>Medium Severity Issues</div>\n      `);\n\n    // Total issues count\n    summaryContainer\n      .append('div')\n      .attr('class', 'summary-card')\n      .style('background', 'rgba(52, 168, 83, 0.1)')\n      .style('padding', '15px')\n      .style('border-radius', '8px')\n      .style('text-align', 'center').html(`\n        <div style=\"font-size: 24px; font-weight: bold; color: #34A853\">${performanceIssues.length}</div>\n        <div>Total Issues</div>\n      `);\n  };\n\n  // Helper function to format issue type\n  const formatIssueType = (type: string): string => {\n    return type\n      .split('-')\n      .map(word => word.charAt(0).toUpperCase() + word.slice(1))\n      .join(' ');\n  };\n\n  // Helper function to format property name\n  const formatPropertyName = (name: string): string => {\n    return name\n      .split(/(?=[A-Z])/)\n      .map(word => word.charAt(0).toUpperCase() + word.slice(1))\n      .join(' ');\n  };\n\n  // Helper function to format property value\n  const formatPropertyValue = (value: unknown): string => {\n    if (value === null || value === undefined) {\n      return 'None';\n    } else if (typeof value === 'number') {\n      return value % 1 === 0 ? value.toString() : value.toFixed(2);\n    } else if (typeof value === 'boolean') {\n      return value ? 'Yes' : 'No';\n    } else if (typeof value === 'object') {\n      return JSON.stringify(value);\n    } else {\n      return String(value);\n    }\n  };\n\n  // Handle tab change\n  const _handleTabChange = (tab: 'rendering' | 'components' | 'dom' | 'issues') => {\n    setActiveTab(tab);\n  };\n\n  // Start recording performance data\n  const _startRecording = () => {\n    setIsRecording(true);\n\n    // TODO: Implement recording start logic\n  };\n\n  // Stop recording performance data\n  const _stopRecording = () => {\n    setIsRecording(false);\n\n    // TODO: Implement recording stop logic\n  };\n\n  // Get JS heap size if available\n  const _getJsHeapSize = (): number | undefined => {\n    const windowWithPerformance = window as WindowWithPerformance;\n    if (typeof performance !== 'undefined' && windowWithPerformance.performance.memory) {\n      return windowWithPerformance.performance.memory.usedJSHeapSize / (1024 * 1024); // Convert to MB\n    }\n    return undefined;\n  };\n\n  // Return the component UI\n  return (\n    <div className=\"visualization-inspector\" style={{ width, height }}>\n      {active ? (\n        <div className=\"inspector-content\">\n          <h3>Visualization Inspector</h3>\n          <p>Monitoring visualization performance...</p>\n          {/* Inspector UI would go here */}\n        </div>\n      ) : null}\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/performance/VisualizationPerformanceComparison.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/performance/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/performance/performanceTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/profiling/ProfilingOverlay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/profiling/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/resource/ChainManagementInterface.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/resource/ChainVisualization.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/resource/ConverterDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/resource/ConverterDetailsView.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/resource/ResourceBar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/resource/ResourceDisplay.tsx","messages":[{"ruleId":"no-unsafe-optional-chaining","severity":2,"message":"Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.","line":37,"column":25,"nodeType":"ChainExpression","messageId":"unsafeOptionalChain","endLine":37,"endColumn":36},{"ruleId":"no-unsafe-optional-chaining","severity":2,"message":"Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.","line":38,"column":19,"nodeType":"ChainExpression","messageId":"unsafeOptionalChain","endLine":38,"endColumn":30}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState } from 'react';\nimport { useComponentLifecycle } from '../../../hooks/ui/useComponentLifecycle';\nimport { ModuleEvent } from '../../../lib/events/ModuleEventBus';\nimport { EventType } from '../../../types/events/EventTypes';\nimport { ResourceType } from '../../../types/resources/ResourceTypes';\nimport { getResourceDisplayName } from '../../../utils/resources/resourceUtils';\nimport { ResourceIcon } from './ResourceIcon';\n\ninterface ResourceDisplayProps {\n  /**\n   * Type of resource to display\n   */\n  resourceType: ResourceType;\n\n  /**\n   * Initial resource amount\n   */\n  initialAmount?: number;\n\n  /**\n   * Class name for styling\n   */\n  className?: string;\n}\n\ninterface ResourceEventData {\n  resourceType: ResourceType;\n  amount: number;\n  source?: string;\n  target?: string;\n}\n\nfunction isResourceEvent(event: ModuleEvent): event is ModuleEvent & { data: ResourceEventData } {\n  return Boolean(\n    event?.data &&\n      typeof event?.data === 'object' &&\n      'resourceType' in event?.data &&\n      'amount' in event?.data\n  );\n}\n\n/**\n * Component that displays a resource with real-time updates\n *\n * This component demonstrates the usage of the component registration system:\n * - It registers itself with ComponentRegistryService\n * - It subscribes to relevant resource events\n * - It updates its state based on those events\n */\nexport function ResourceDisplay({\n  resourceType,\n  initialAmount = 0,\n  className = '',\n}: ResourceDisplayProps) {\n  const [amount, setAmount] = useState<number>(initialAmount);\n  const [productionRate, setProductionRate] = useState<number>(0);\n  const [consumptionRate, setConsumptionRate] = useState<number>(0);\n\n  useComponentLifecycle({\n    eventSubscriptions: [\n      {\n        eventType: EventType.RESOURCE_PRODUCED,\n        handler: (event: ModuleEvent) => {\n          if (isResourceEvent(event) && event?.data?.resourceType === resourceType) {\n            setAmount(prev => prev + event?.data?.amount);\n            setProductionRate(prev => prev + event?.data?.amount);\n          }\n        },\n      },\n      {\n        eventType: EventType.RESOURCE_CONSUMED,\n        handler: (event: ModuleEvent) => {\n          if (isResourceEvent(event) && event?.data?.resourceType === resourceType) {\n            setAmount(prev => prev - event?.data?.amount);\n            setConsumptionRate(prev => prev + event?.data?.amount);\n          }\n        },\n      },\n      {\n        eventType: EventType.RESOURCE_UPDATED,\n        handler: (event: ModuleEvent) => {\n          if (isResourceEvent(event) && event?.data?.resourceType === resourceType) {\n            setAmount(event?.data?.amount);\n          }\n        },\n      },\n    ],\n  });\n\n  const netRate = productionRate - consumptionRate;\n  const rateColor = netRate > 0 ? 'text-green-500' : netRate < 0 ? 'text-red-500' : 'text-gray-500';\n\n  return (\n    <div className={`flex items-center space-x-2 ${className}`}>\n      <ResourceIcon resourceType={resourceType} className=\"h-6 w-6\" />\n      <div className=\"flex flex-col\">\n        <span className=\"text-sm font-medium\">{getResourceDisplayName(resourceType)}</span>\n        <div className=\"flex items-center space-x-2\">\n          <span className=\"text-lg font-bold\">{amount.toFixed(1)}</span>\n          {netRate !== 0 && (\n            <span className={`text-sm ${rateColor}`}>\n              {netRate > 0 ? '+' : ''}\n              {netRate.toFixed(1)}/s\n            </span>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/resource/ResourceDistributionChart.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/resource/ResourceDistributionChartDemo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/resource/ResourceFlowDiagram.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/resource/ResourceForecastingVisualization.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_ratePerMinute' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":69,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":69,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_componentId' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":72,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":72,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_resourceRates' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":81,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":81,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_thresholdState' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":82,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":82,"endColumn":33}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  CategoryScale,\n  Chart as ChartJS,\n  ChartOptions,\n  Legend,\n  LinearScale,\n  LineElement,\n  PointElement,\n  Title,\n  Tooltip,\n} from 'chart.js';\nimport * as React from 'react';\nimport { useEffect, useMemo, useState } from 'react';\nimport { Line } from 'react-chartjs-2';\nimport { useResourceRate } from '../../../contexts/ResourceRatesContext';\nimport { useThreshold } from '../../../contexts/ThresholdContext';\nimport { useComponentLifecycle } from '../../../hooks/ui/useComponentLifecycle';\nimport { useComponentRegistration } from '../../../hooks/ui/useComponentRegistration';\nimport { ResourceType } from '../../../types/resources/ResourceTypes';\nimport { ResourceTypeHelpers } from '../../../types/resources/StandardizedResourceTypes';\nimport './ResourceForecastingVisualization.css';\n\n// Register the Chart.js components\nChartJS.register(CategoryScale, LinearScale, PointElement, LineElement, Title, Tooltip, Legend);\n\ninterface ResourceForecastingVisualizationProps {\n  resourceType: ResourceType;\n  currentValue: number;\n  maxValue: number;\n  rate: number;\n  cycleTime: number;\n  forecastPeriod?: number; // in minutes\n  dataPoints?: number;\n  thresholds?: {\n    critical?: number;\n    low?: number;\n    target?: number;\n    high?: number;\n    maximum?: number;\n  };\n}\n\ninterface ForecastPoint {\n  time: string;\n  value: number;\n  status: 'critical' | 'low' | 'normal' | 'high' | 'maximum';\n}\n\n// Add helper function to get resource name\nconst getResourceName = (resourceType: ResourceType): string => {\n  return ResourceTypeHelpers.getDisplayName(resourceType);\n};\n\n/**\n * Component that visualizes forecasted resource levels based on current rates\n * and consumption patterns.\n */\nconst ResourceForecastingVisualization: React.FC<ResourceForecastingVisualizationProps> = ({\n  resourceType,\n  currentValue,\n  maxValue,\n  rate,\n  cycleTime,\n  forecastPeriod = 60, // Default to 60 minutes\n  dataPoints = 12, // Default to 12 data points\n  thresholds,\n}) => {\n  // Calculate rate per minute for easier forecasting\n  const _ratePerMinute = rate * (60000 / cycleTime);\n\n  // Register component\n  const _componentId = useComponentRegistration({\n    type: ResourceType.MINERALS,\n    eventSubscriptions: ['RESOURCE_UPDATED', 'RESOURCE_THRESHOLD_CHANGED', 'RESOURCE_FLOW_UPDATED'],\n    updatePriority: 'low', // Forecasting is less critical than actual resource displays\n  });\n\n  // Initialize with current state\n  const [forecast, setForecast] = useState<ForecastPoint[]>([]);\n  const [_criticalPoint, _setCriticalPoint] = useState<number | null>(null);\n  const _resourceRates = useResourceRate(resourceType);\n  const { state: _thresholdState } = useThreshold();\n\n  // Component lifecycle tracking for performance monitoring\n  useComponentLifecycle({\n    onMount: () => {\n      console.warn('ResourceForecastingVisualization mounted');\n    },\n    onUnmount: () => {\n      console.warn('ResourceForecastingVisualization unmounted');\n    },\n  });\n\n  // Generate forecast data points\n  useEffect(() => {\n    const generateForecast = () => {\n      const interval = forecastPeriod / dataPoints; // minutes per data point\n      const points: ForecastPoint[] = [];\n      let projectedValue = currentValue;\n      const projectedRate = rate; // Current rate of change\n\n      // Add current value as first point\n      points.push({\n        time: 'Now',\n        value: projectedValue,\n        status: getResourceStatus(projectedValue, maxValue, thresholds),\n      });\n\n      // Generate future data points\n      for (let i = 1; i <= dataPoints; i++) {\n        const timePoint = `+${Math.round(i * interval)}m`;\n\n        // Calculate projected value based on current rate\n        // We assume rate is units per minute, so we multiply by interval\n        projectedValue += projectedRate * interval;\n\n        // Enforce min/max bounds\n        projectedValue = Math.max(0, Math.min(projectedValue, maxValue));\n\n        points.push({\n          time: timePoint,\n          value: projectedValue,\n          status: getResourceStatus(projectedValue, maxValue, thresholds),\n        });\n      }\n\n      return points;\n    };\n\n    setForecast(generateForecast());\n  }, [currentValue, rate, maxValue, forecastPeriod, dataPoints, thresholds, cycleTime]);\n\n  // Calculate when critical thresholds will be reached (if applicable)\n  const criticalEvents = useMemo(() => {\n    if (rate === 0) return null;\n\n    const events = [];\n    const resourceThresholds = thresholds || {\n      critical: 0.1,\n      low: 0.25,\n      target: 0.5,\n      high: 0.75,\n      maximum: 0.95,\n    };\n\n    // Check if we'll deplete resources\n    if (rate < 0) {\n      const timeToEmpty = currentValue / Math.abs(rate);\n      if (timeToEmpty < forecastPeriod) {\n        events.push({\n          type: 'depletion',\n          time: formatTime(timeToEmpty),\n          label: `Resource depleted in ${formatTime(timeToEmpty)}`,\n          severity: 'critical',\n        });\n      }\n\n      // Check when we'll hit critical threshold\n      if (resourceThresholds.critical) {\n        const criticalValue = maxValue * resourceThresholds.critical;\n        if (currentValue > criticalValue) {\n          const timeToCritical = (currentValue - criticalValue) / Math.abs(rate);\n          if (timeToCritical < forecastPeriod) {\n            events.push({\n              type: 'critical',\n              time: formatTime(timeToCritical),\n              label: `Critical level in ${formatTime(timeToCritical)}`,\n              severity: 'high',\n            });\n          }\n        }\n      }\n    }\n\n    // Check if we'll overflow resources\n    if (rate > 0) {\n      const timeToFull = (maxValue - currentValue) / rate;\n      if (timeToFull < forecastPeriod) {\n        events.push({\n          type: 'overflow',\n          time: formatTime(timeToFull),\n          label: `Storage full in ${formatTime(timeToFull)}`,\n          severity: 'medium',\n        });\n      }\n    }\n\n    return events;\n  }, [currentValue, rate, maxValue, forecastPeriod, thresholds]);\n\n  // Chart data and options\n  const chartData = {\n    labels: forecast.map(point => point.time),\n    datasets: [\n      {\n        label: `${getResourceName(resourceType)} Forecast`,\n        data: forecast.map(point => point.value),\n        borderColor: getLineColor(forecast),\n        backgroundColor: getBackgroundColor(forecast),\n        tension: 0.3,\n        pointBackgroundColor: forecast.map(point => getPointColor(point.status)),\n        pointRadius: 4,\n        borderWidth: 2,\n        fill: true,\n      },\n      // Add threshold lines if available\n      ...(thresholds?.critical\n        ? [\n            {\n              label: 'Critical Threshold',\n              data: Array(forecast.length).fill(maxValue * (thresholds.critical ?? 0.1)),\n              borderColor: 'rgba(255, 0, 0, 0.7)',\n              backgroundColor: 'transparent',\n              borderDash: [5, 5],\n              borderWidth: 1,\n              pointRadius: 0,\n              fill: false,\n            },\n          ]\n        : []),\n      ...(thresholds?.low\n        ? [\n            {\n              label: 'Low Threshold',\n              data: Array(forecast.length).fill(maxValue * (thresholds.low ?? 0.25)),\n              borderColor: 'rgba(255, 165, 0, 0.7)',\n              backgroundColor: 'transparent',\n              borderDash: [5, 5],\n              borderWidth: 1,\n              pointRadius: 0,\n              fill: false,\n            },\n          ]\n        : []),\n      ...(thresholds?.high\n        ? [\n            {\n              label: 'High Threshold',\n              data: Array(forecast.length).fill(maxValue * (thresholds.high ?? 0.75)),\n              borderColor: 'rgba(0, 128, 0, 0.7)',\n              backgroundColor: 'transparent',\n              borderDash: [5, 5],\n              borderWidth: 1,\n              pointRadius: 0,\n              fill: false,\n            },\n          ]\n        : []),\n    ],\n  };\n\n  // Chart options\n  const chartOptions: ChartOptions<'line'> = {\n    responsive: true,\n    maintainAspectRatio: false,\n    scales: {\n      y: {\n        beginAtZero: true,\n        max: maxValue * 1.1, // Add 10% buffer at top\n        title: {\n          display: true,\n          text: `${getResourceName(resourceType)} Units`,\n        },\n      },\n      x: {\n        title: {\n          display: true,\n          text: 'Time',\n        },\n      },\n    },\n    plugins: {\n      tooltip: {\n        callbacks: {\n          label: function (context: { dataset: { label?: string }; parsed: { y?: number } }) {\n            const label = context.dataset.label || '';\n            const value = context.parsed.y || 0;\n            const percentage = ((value / maxValue) * 100).toFixed(1);\n            return `${label}: ${value.toFixed(1)} (${percentage}%)`;\n          },\n        },\n      },\n      legend: {\n        position: 'top' as const,\n      },\n      title: {\n        display: true,\n        text: `${getResourceName(resourceType)} Forecast (${rate > 0 ? '+' : ''}${rate.toFixed(2)}/min)`,\n      },\n    },\n  };\n\n  return (\n    <div className=\"resource-forecasting-visualization\">\n      <div className=\"forecast-chart-container\">\n        <Line data={chartData} options={chartOptions} />\n      </div>\n\n      {criticalEvents && criticalEvents.length > 0 && (\n        <div className=\"forecast-critical-events\">\n          <h4>Important Events:</h4>\n          <ul>\n            {criticalEvents.map((event, index) => (\n              <li key={index} className={`event-${event.severity}`}>\n                {event.label}\n              </li>\n            ))}\n          </ul>\n        </div>\n      )}\n\n      <div className=\"forecast-legend\">\n        <div className=\"legend-item\">\n          <span className=\"legend-color\" style={{ backgroundColor: 'rgba(255, 0, 0, 0.7)' }}></span>\n          <span>Critical</span>\n        </div>\n        <div className=\"legend-item\">\n          <span\n            className=\"legend-color\"\n            style={{ backgroundColor: 'rgba(255, 165, 0, 0.7)' }}\n          ></span>\n          <span>Low</span>\n        </div>\n        <div className=\"legend-item\">\n          <span className=\"legend-color\" style={{ backgroundColor: 'rgba(0, 128, 0, 0.7)' }}></span>\n          <span>Normal</span>\n        </div>\n      </div>\n    </div>\n  );\n};\n\n// Helper functions\nconst getResourceStatus = (\n  value: number,\n  maxValue: number,\n  thresholds?: ResourceForecastingVisualizationProps['thresholds']\n): 'critical' | 'low' | 'normal' | 'high' | 'maximum' => {\n  // Default thresholds if not provided\n  const defaultThresholds = {\n    critical: 0.1,\n    low: 0.25,\n    target: 0.5,\n    high: 0.75,\n    maximum: 0.95,\n  };\n\n  const { critical, low, high, maximum } = { ...defaultThresholds, ...thresholds };\n  const percentage = value / maxValue;\n\n  if (percentage <= critical) return 'critical';\n  if (percentage <= low) return 'low';\n  if (percentage >= maximum) return 'maximum';\n  if (percentage >= high) return 'high';\n  return 'normal';\n};\n\nconst getPointColor = (status: string): string => {\n  switch (status) {\n    case 'critical':\n      return 'rgba(255, 0, 0, 1)';\n    case 'low':\n      return 'rgba(255, 165, 0, 1)';\n    case 'high':\n      return 'rgba(255, 255, 0, 1)';\n    case 'maximum':\n      return 'rgba(255, 0, 255, 1)';\n    case 'normal':\n    default:\n      return 'rgba(0, 128, 0, 1)';\n  }\n};\n\nconst getLineColor = (forecast: ForecastPoint[]): string => {\n  // Determine line color based on overall forecast trend\n  const lastPoint = forecast[forecast.length - 1];\n  switch (lastPoint?.status) {\n    case 'critical':\n      return 'rgba(255, 0, 0, 1)';\n    case 'low':\n      return 'rgba(255, 165, 0, 1)';\n    case 'high':\n      return 'rgba(255, 255, 0, 1)';\n    case 'maximum':\n      return 'rgba(255, 0, 255, 1)';\n    case 'normal':\n    default:\n      return 'rgba(0, 128, 0, 1)';\n  }\n};\n\nconst getBackgroundColor = (forecast: ForecastPoint[]): string => {\n  // Determine background color based on overall forecast trend\n  const lastPoint = forecast[forecast.length - 1];\n  switch (lastPoint?.status) {\n    case 'critical':\n      return 'rgba(255, 0, 0, 0.1)';\n    case 'low':\n      return 'rgba(255, 165, 0, 0.1)';\n    case 'high':\n      return 'rgba(255, 255, 0, 0.1)';\n    case 'maximum':\n      return 'rgba(255, 0, 255, 0.1)';\n    case 'normal':\n    default:\n      return 'rgba(0, 128, 0, 0.1)';\n  }\n};\n\nconst formatTime = (minutes: number): string => {\n  if (minutes < 60) {\n    return `${Math.round(minutes)}m`;\n  } else {\n    const hours = Math.floor(minutes / 60);\n    const mins = Math.round(minutes % 60);\n    return `${hours}h ${mins}m`;\n  }\n};\n\nexport default ResourceForecastingVisualization;\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/resource/ResourceGrid.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'rowStartIndex' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":149,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":149,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'rowEndIndex' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":150,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":150,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @context: ui-system, resource-system, component-library, performance-optimization\n * \n * ResourceGrid component for displaying multiple resources in a grid layout\n * Uses standardized UI components and resource type safety\n */\nimport React, { useRef, useEffect, useState } from 'react';\nimport { ResourceType } from '../../../types/resources/ResourceTypes';\nimport { ResourceDisplay } from './ResourceDisplay';\nimport { ResourceBar } from './ResourceBar';\nimport { Grid, GridTemplate } from '../../../ui/components/layout/Grid';\nimport { useVirtualization } from '../../../utils/performance/ComponentOptimizer';\n\nexport type ResourceDisplayMode = 'compact' | 'detailed' | 'bars';\n\nexport interface ResourceGridItem {\n  /**\n   * Type of resource\n   */\n  resourceType: ResourceType;\n  \n  /**\n   * Initial amount of the resource\n   */\n  initialAmount?: number;\n  \n  /**\n   * Maximum capacity of the resource\n   */\n  maxCapacity?: number;\n}\n\nexport interface ResourceGridProps {\n  /**\n   * List of resources to display\n   */\n  resources: ResourceGridItem[];\n  \n  /**\n   * Number of columns in the grid\n   * @default 3\n   */\n  columns?: number;\n  \n  /**\n   * Gap between grid items in pixels\n   * @default 16\n   */\n  gap?: number;\n  \n  /**\n   * Display mode for resources\n   * @default 'compact'\n   */\n  displayMode?: ResourceDisplayMode;\n  \n  /**\n   * Whether to show resource percentage (only for 'bars' mode)\n   * @default false\n   */\n  showPercentage?: boolean;\n  \n  /**\n   * Class name for styling\n   */\n  className?: string;\n  \n  /**\n   * Whether to use virtualization for large resource lists\n   * @default true\n   */\n  virtualized?: boolean;\n  \n  /**\n   * Fixed height for each resource item when using virtualization\n   * @default 120\n   */\n  itemHeight?: number;\n}\n\n/**\n * Component that displays multiple resources in a grid layout\n * \n * Uses the standardized Grid component from the UI system for consistent layouts\n * and follows established resource type safety patterns\n */\nexport function ResourceGrid({\n  resources,\n  columns = 3,\n  gap = 16,\n  displayMode = 'compact',\n  showPercentage = false,\n  className = '',\n  virtualized = true,\n  itemHeight = 120,\n}: ResourceGridProps) {\n  // Validate resources to ensure only valid ResourceTypes are used\n  const validResources = React.useMemo(() => {\n    return resources.filter(resource => \n      Object.values(ResourceType).includes(resource.resourceType)\n    );\n  }, [resources]);\n  \n  // Virtualization setup\n  const containerRef = useRef<HTMLDivElement>(null);\n  const [containerHeight, setContainerHeight] = useState(600);\n  \n  // Measure container height for virtualization\n  useEffect(() => {\n    if (containerRef.current && virtualized) {\n      const resizeObserver = new ResizeObserver(entries => {\n        const { height } = entries[0].contentRect;\n        setContainerHeight(height);\n      });\n      \n      resizeObserver.observe(containerRef.current);\n      \n      return () => {\n        if (containerRef.current) {\n          resizeObserver.unobserve(containerRef.current);\n        }\n      };\n    }\n  }, [virtualized]);\n  \n  // Setup virtualization if enabled and there are enough resources\n  const showVirtualized = virtualized && validResources.length > 20;\n  \n  const virtualization = React.useMemo(() => {\n    if (!showVirtualized) {\n      return null;\n    }\n    \n    return useVirtualization({\n      itemCount: validResources.length,\n      itemHeight,\n      containerHeight,\n      overscan: 2\n    });\n  }, [showVirtualized, validResources.length, itemHeight, containerHeight]);\n  \n  if (showVirtualized && virtualization) {\n    // Virtualized rendering for better performance with large lists\n    const { startIndex, endIndex, totalHeight, offsetY } = virtualization;\n    const visibleResources = validResources.slice(startIndex, endIndex + 1);\n    \n    // Calculate grid layout\n    const itemsPerRow = columns;\n    const rowStartIndex = Math.floor(startIndex / itemsPerRow);\n    const rowEndIndex = Math.floor(endIndex / itemsPerRow);\n    \n    return (\n      <div \n        ref={containerRef}\n        className={`resource-grid-virtual-container ${className}`}\n        style={{ height: `${containerHeight}px`, position: 'relative', overflow: 'auto' }}\n        onScroll={virtualization.handleScroll}\n        data-testid=\"resource-grid\"\n      >\n        <div \n          className=\"resource-grid-virtual-content\"\n          style={{ height: `${totalHeight}px`, position: 'relative' }}\n        >\n          <div \n            className=\"resource-grid-virtual-items\"\n            style={{ \n              position: 'absolute', \n              top: `${offsetY}px`, \n              left: 0, \n              right: 0,\n              display: 'grid',\n              gridTemplateColumns: `repeat(${columns}, 1fr)`,\n              gap: `${gap}px`\n            }}\n          >\n            {visibleResources.map((resource) => (\n              <div key={resource.resourceType} className=\"resource-grid-item\">\n                {displayMode === 'compact' && (\n                  <ResourceDisplay\n                    resourceType={resource.resourceType}\n                    initialAmount={resource.initialAmount}\n                  />\n                )}\n                \n                {displayMode === 'detailed' && (\n                  <ResourceDisplay\n                    resourceType={resource.resourceType}\n                    initialAmount={resource.initialAmount}\n                    className=\"p-2 bg-gray-100 rounded-md\"\n                  />\n                )}\n                \n                {displayMode === 'bars' && (\n                  <ResourceBar\n                    resourceType={resource.resourceType}\n                    initialAmount={resource.initialAmount}\n                    maxCapacity={resource.maxCapacity}\n                    showPercentage={showPercentage}\n                  />\n                )}\n              </div>\n            ))}\n          </div>\n        </div>\n      </div>\n    );\n  }\n  \n  // Non-virtualized render for smaller lists\n  return (\n    <Grid\n      columns={columns}\n      gap={gap}\n      template={GridTemplate.EQUAL}\n      className={`resource-grid ${className}`}\n      data-testid=\"resource-grid\"\n    >\n      {validResources.map((resource) => (\n        <div key={resource.resourceType} className=\"resource-grid-item\">\n          {displayMode === 'compact' && (\n            <ResourceDisplay\n              resourceType={resource.resourceType}\n              initialAmount={resource.initialAmount}\n            />\n          )}\n          \n          {displayMode === 'detailed' && (\n            <ResourceDisplay\n              resourceType={resource.resourceType}\n              initialAmount={resource.initialAmount}\n              className=\"p-2 bg-gray-100 rounded-md\"\n            />\n          )}\n          \n          {displayMode === 'bars' && (\n            <ResourceBar\n              resourceType={resource.resourceType}\n              initialAmount={resource.initialAmount}\n              maxCapacity={resource.maxCapacity}\n              showPercentage={showPercentage}\n            />\n          )}\n        </div>\n      ))}\n      \n      {validResources.length === 0 && (\n        <div className=\"resource-grid-empty\">\n          No valid resources to display\n        </div>\n      )}\n    </Grid>\n  );\n}\n\n// Memoize the component to prevent unnecessary re-renders\nexport const MemoizedResourceGrid = React.memo(ResourceGrid); ","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/resource/ResourceIcon.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/resource/ResourceManagementDashboard.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_props' is defined but never used.","line":57,"column":39,"nodeType":null,"messageId":"unusedVar","endLine":57,"endColumn":45},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_handleThresholdChange' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":255,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":255,"endColumn":31}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Button, Tabs } from 'antd';\nimport * as React from 'react';\nimport { useCallback, useEffect, useMemo, useState } from 'react';\nimport { useResourceRates } from '../../../contexts/ResourceRatesContext';\nimport { useThreshold } from '../../../contexts/ThresholdContext';\nimport { useComponentLifecycle, useComponentRegistration } from '../../../hooks/ui';\nimport { EventType } from '../../../types/events/EventTypes';\nimport { ResourceType } from '../../../types/resources/ResourceTypes';\nimport { ResourceTypeHelpers } from '../../../types/resources/StandardizedResourceTypes';\nimport ChainManagementInterface from './ChainManagementInterface';\nimport ConverterDashboard from './ConverterDashboard';\nimport ResourceFlowDiagram from './ResourceFlowDiagram';\nimport ResourceForecastingVisualization from './ResourceForecastingVisualization';\nimport './ResourceManagementDashboard.css';\nimport ResourceOptimizationSuggestions from './ResourceOptimizationSuggestions';\nimport ResourceThresholdVisualization from './ResourceThresholdVisualization';\nimport { ResourceVisualizationEnhanced } from './ResourceVisualizationEnhanced';\n\n// Main resource types to display\nconst MAIN_RESOURCES: ResourceType[] = [\n  ResourceType.MINERALS,\n  ResourceType.ENERGY,\n  ResourceType.POPULATION,\n  ResourceType.RESEARCH,\n];\nconst SECONDARY_RESOURCES: ResourceType[] = [\n  ResourceType.PLASMA,\n  ResourceType.GAS,\n  ResourceType.EXOTIC,\n];\n\ninterface ResourceData {\n  type: ResourceType;\n  value: number;\n  maxValue: number;\n  rate: number;\n  cycleTime: number;\n  thresholds: {\n    critical: number;\n    low: number;\n    target: number;\n    high: number;\n    maximum: number;\n  };\n}\n\n// For component registration, we need to use the correct EventType values\nconst componentEventSubscriptions: EventType[] = [\n  EventType.RESOURCE_UPDATED,\n  EventType.RESOURCE_FLOW_REGISTERED,\n  EventType.RESOURCE_FLOW_UNREGISTERED,\n  EventType.RESOURCE_FLOW_UPDATED,\n];\n\n// Create a wrapper for ResourceVisualizationEnhanced that accepts props\n\nconst ResourceVisualizationWrapper = (_props: {\n  type: ResourceType;\n  value: number;\n  rate: number;\n  capacity?: number;\n  thresholds?: {\n    low: number;\n    critical: number;\n  };\n}) => {\n  // This is a wrapper component that would pass props to the actual implementation\n  return <ResourceVisualizationEnhanced />;\n};\n\n/**\n * Comprehensive Resource Management Dashboard\n *\n * This component integrates various resource-related visualizations and controls\n * into a unified interface for managing all aspects of the resource system.\n *\n * Features:\n * - Resource status overview\n * - Threshold configuration\n * - Resource flow visualization\n * - Converter management\n * - Production chain management\n * - Resource forecasting (future)\n */\nconst ResourceManagementDashboardBase: React.FC = () => {\n  const { resourceRates } = useResourceRates(state => ({ resourceRates: state.resourceRates }));\n  const { state: thresholdState, dispatch: thresholdDispatch } = useThreshold();\n  const [activeTab, setActiveTab] = useState<string>('overview');\n  const [resourceData, setResourceData] = useState<Record<ResourceType, ResourceData>>(\n    {} as Record<ResourceType, ResourceData>\n  );\n  const [selectedResource, setSelectedResource] = useState<ResourceType | undefined>(undefined);\n\n  // Register with component registry\n  useComponentRegistration({\n    type: ResourceType.MINERALS,\n    eventSubscriptions: componentEventSubscriptions,\n    updatePriority: 'high',\n  });\n\n  // Handle lifecycle and event subscriptions\n  useComponentLifecycle({\n    onMount: () => {\n      console.warn('ResourceManagementDashboard mounted');\n    },\n    onUnmount: () => {\n      console.warn('ResourceManagementDashboard unmounted');\n    },\n    eventSubscriptions: [\n      {\n        eventType: EventType.RESOURCE_UPDATED,\n        handler: event => {\n          if (event?.data?.resourceType) {\n            updateResourceData(event?.data?.resourceType as ResourceType, event?.data);\n          }\n        },\n      },\n      {\n        // Cast to EventType for compatibility\n        eventType: EventType.RESOURCE_THRESHOLD_TRIGGERED,\n        handler: event => {\n          if (event?.data?.resourceId) {\n            // Show alert or notification\n            console.warn(`Threshold triggered for ${event?.data?.resourceId}`);\n          }\n        },\n      },\n    ],\n  });\n\n  // Initialize resource data from contexts\n  const mockResourceData = useMemo(() => {\n    // Mock data for demonstration - in a real implementation, this would come from the ResourceManager\n    return {\n      [ResourceType.MINERALS]: {\n        type: ResourceType.MINERALS,\n        value: 2500,\n        maxValue: 10000,\n        rate: resourceRates[ResourceType.MINERALS as keyof typeof resourceRates]?.net ?? 0,\n        cycleTime: 1000,\n        thresholds: {\n          critical: 0.1,\n          low: 0.25,\n          target: 0.5,\n          high: 0.75,\n          maximum: 0.9,\n        },\n      },\n      [ResourceType.ENERGY]: {\n        type: ResourceType.ENERGY,\n        value: 7500,\n        maxValue: 10000,\n        rate: resourceRates[ResourceType.ENERGY as keyof typeof resourceRates]?.net ?? 0,\n        cycleTime: 1000,\n        thresholds: {\n          critical: 0.1,\n          low: 0.25,\n          target: 0.5,\n          high: 0.75,\n          maximum: 0.9,\n        },\n      },\n      [ResourceType.POPULATION]: {\n        type: ResourceType.POPULATION,\n        value: 5000,\n        maxValue: 10000,\n        rate: resourceRates[ResourceType.POPULATION as keyof typeof resourceRates]?.net ?? 0,\n        cycleTime: 5000,\n        thresholds: {\n          critical: 0.1,\n          low: 0.25,\n          target: 0.5,\n          high: 0.75,\n          maximum: 0.9,\n        },\n      },\n      [ResourceType.RESEARCH]: {\n        type: ResourceType.RESEARCH,\n        value: 1500,\n        maxValue: 10000,\n        rate: resourceRates[ResourceType.RESEARCH as keyof typeof resourceRates]?.net ?? 0,\n        cycleTime: 2000,\n        thresholds: {\n          critical: 0.1,\n          low: 0.25,\n          target: 0.5,\n          high: 0.75,\n          maximum: 0.9,\n        },\n      },\n      [ResourceType.PLASMA]: {\n        type: ResourceType.PLASMA,\n        value: 800,\n        maxValue: 5000,\n        rate: resourceRates[ResourceType.PLASMA as keyof typeof resourceRates]?.net ?? 1.2,\n        cycleTime: 1500,\n        thresholds: {\n          critical: 0.1,\n          low: 0.25,\n          target: 0.5,\n          high: 0.75,\n          maximum: 0.9,\n        },\n      },\n      [ResourceType.GAS]: {\n        type: ResourceType.GAS,\n        value: 1200,\n        maxValue: 5000,\n        rate: resourceRates[ResourceType.GAS as keyof typeof resourceRates]?.net ?? -0.8,\n        cycleTime: 1500,\n        thresholds: {\n          critical: 0.1,\n          low: 0.25,\n          target: 0.5,\n          high: 0.75,\n          maximum: 0.9,\n        },\n      },\n      [ResourceType.EXOTIC]: {\n        type: ResourceType.EXOTIC,\n        value: 250,\n        maxValue: 2000,\n        rate: resourceRates[ResourceType.EXOTIC as keyof typeof resourceRates]?.net ?? 0.2,\n        cycleTime: 3000,\n        thresholds: {\n          critical: 0.1,\n          low: 0.25,\n          target: 0.5,\n          high: 0.75,\n          maximum: 0.9,\n        },\n      },\n    } as Record<ResourceType, ResourceData>;\n  }, [resourceRates]);\n\n  // Update resource data when resourceRates change\n  useEffect(() => {\n    setResourceData(mockResourceData);\n  }, [mockResourceData]);\n\n  // Helper function to update a specific resource's data\n  const updateResourceData = useCallback(\n    (resourceType: ResourceType, data: Partial<ResourceData>) => {\n      setResourceData(prevData => ({\n        ...prevData,\n        [resourceType]: {\n          ...prevData[resourceType],\n          ...data,\n        },\n      }));\n    },\n    []\n  );\n\n  const _handleThresholdChange = useCallback(\n    (resourceType: ResourceType, min: number, max: number) => {\n      // When using ResourceTypeHelpers to get the display name\n      console.warn(\n        `Setting thresholds for ${ResourceTypeHelpers.getDisplayName(resourceType)}: min=${min}, max=${max}`\n      );\n\n      thresholdDispatch({\n        type: 'SET_THRESHOLD',\n        payload: {\n          resourceId: resourceType,\n          min,\n          max,\n        },\n      });\n    },\n    [thresholdDispatch]\n  );\n\n  const handleAutoMineToggle = useCallback(\n    (resourceType: ResourceType) => {\n      // When using ResourceTypeHelpers to get the display name\n      console.warn(`Toggling auto-mine for ${ResourceTypeHelpers.getDisplayName(resourceType)}`);\n\n      thresholdDispatch({\n        type: 'TOGGLE_AUTO_MINE',\n        payload: {\n          resourceId: resourceType,\n        },\n      });\n    },\n    [thresholdDispatch]\n  );\n\n  const handleResourceSelect = (resource: ResourceType | undefined) => {\n    setSelectedResource(resource);\n  };\n\n  // Render resource overview cards\n  const renderResourceOverview = () => {\n    return (\n      <div className=\"resource-overview\">\n        <h2>Primary Resources</h2>\n        <div className=\"resource-cards\">\n          {MAIN_RESOURCES.map(type => (\n            <div\n              key={type}\n              className=\"resource-card\"\n              onClick={() => handleResourceSelect(type === selectedResource ? undefined : type)}\n            >\n              <ResourceVisualizationWrapper\n                type={type}\n                value={resourceData[type]?.value ?? 0}\n                rate={resourceData[type]?.rate ?? 0}\n                capacity={resourceData[type]?.maxValue}\n                thresholds={{\n                  low: resourceData[type]?.thresholds?.low ?? 0.25,\n                  critical: resourceData[type]?.thresholds?.critical ?? 0.1,\n                }}\n              />\n            </div>\n          ))}\n        </div>\n\n        <h2>Secondary Resources</h2>\n        <div className=\"resource-cards\">\n          {SECONDARY_RESOURCES.map(type => (\n            <div\n              key={type}\n              className=\"resource-card\"\n              onClick={() => handleResourceSelect(type === selectedResource ? undefined : type)}\n            >\n              <ResourceVisualizationWrapper\n                type={type}\n                value={resourceData[type]?.value ?? 0}\n                rate={resourceData[type]?.rate ?? 0}\n                capacity={resourceData[type]?.maxValue}\n                thresholds={{\n                  low: resourceData[type]?.thresholds?.low ?? 0.25,\n                  critical: resourceData[type]?.thresholds?.critical ?? 0.1,\n                }}\n              />\n            </div>\n          ))}\n        </div>\n\n        {selectedResource && (\n          <div className=\"resource-detail\">\n            <h3>Detailed View: {selectedResource}</h3>\n            <ResourceThresholdVisualization\n              resourceType={selectedResource}\n              currentValue={resourceData[selectedResource]?.value ?? 0}\n              maxValue={resourceData[selectedResource]?.maxValue || 1000}\n              rate={resourceData[selectedResource]?.rate ?? 0}\n              cycleTime={resourceData[selectedResource]?.cycleTime || 1000}\n              thresholds={{\n                critical: resourceData[selectedResource]?.thresholds.critical,\n                low: resourceData[selectedResource]?.thresholds.low,\n                target: resourceData[selectedResource]?.thresholds.target,\n                high: resourceData[selectedResource]?.thresholds.high,\n                maximum: resourceData[selectedResource]?.thresholds.maximum,\n              }}\n            />\n            <div className=\"threshold-controls\">\n              <h4>Threshold Configuration</h4>\n              <div className=\"threshold-sliders\">\n                {/* Threshold configuration controls would go here */}\n                <Button\n                  onClick={() => handleAutoMineToggle(selectedResource)}\n                  type={\n                    thresholdState.resources[selectedResource]?.autoMine ? 'primary' : 'default'\n                  }\n                >\n                  {thresholdState.resources[selectedResource]?.autoMine\n                    ? 'Auto-Mine: ON'\n                    : 'Auto-Mine: OFF'}\n                </Button>\n              </div>\n            </div>\n          </div>\n        )}\n      </div>\n    );\n  };\n\n  // Render resource flow visualization\n  const renderResourceFlow = () => {\n    return (\n      <div className=\"resource-flow\">\n        <h2>Resource Flow Network</h2>\n        <div className=\"resource-flow-controls\">\n          <div className=\"filter-controls\">\n            <span>Filter by resource type:</span>\n            {[...MAIN_RESOURCES, ...SECONDARY_RESOURCES].map(type => (\n              <Button\n                key={type}\n                type={selectedResource === type ? 'primary' : 'default'}\n                onClick={() => handleResourceSelect(type === selectedResource ? undefined : type)}\n              >\n                {type}\n              </Button>\n            ))}\n          </div>\n        </div>\n        <div className=\"flow-diagram-container\">\n          <ResourceFlowDiagram\n            width={900}\n            height={500}\n            interactive={true}\n            showLabels={true}\n            showLegend={true}\n            focusedResourceType={selectedResource || undefined}\n          />\n        </div>\n      </div>\n    );\n  };\n\n  // Render converter management\n  const renderConverterManagement = () => {\n    return (\n      <div className=\"converter-management\">\n        <h2>Converter Management</h2>\n        {/* @ts-expect-error - Ignoring prop type issues for demo */}\n        <ConverterDashboard />\n      </div>\n    );\n  };\n\n  // Render production chains\n  const renderProductionChains = () => {\n    return (\n      <div className=\"production-chains\">\n        <h2>Production Chain Management</h2>\n        {/* @ts-expect-error - Ignoring prop type issues for demo */}\n        <ChainManagementInterface />\n      </div>\n    );\n  };\n\n  // Render threshold configuration\n  const renderThresholdConfiguration = () => {\n    return (\n      <div className=\"threshold-configuration\">\n        <h2>Resource Threshold Configuration</h2>\n        <div className=\"global-settings\">\n          <h3>Global Settings</h3>\n          <Button\n            type={thresholdState.globalAutoMine ? 'primary' : 'default'}\n            onClick={() =>\n              thresholdDispatch({\n                type: 'SET_GLOBAL_AUTO_MINE',\n                payload: !thresholdState.globalAutoMine,\n              })\n            }\n          >\n            {thresholdState.globalAutoMine ? 'Global Auto-Mine: ON' : 'Global Auto-Mine: OFF'}\n          </Button>\n\n          <h3>Threshold Presets</h3>\n          <div className=\"preset-buttons\">\n            {thresholdState.presets.map(preset => (\n              <Button\n                key={preset.id}\n                type={thresholdState.activePresetId === preset.id ? 'primary' : 'default'}\n                onClick={() =>\n                  thresholdDispatch({\n                    type: 'APPLY_PRESET',\n                    payload: { presetId: preset.id },\n                  })\n                }\n              >\n                {preset.name}\n              </Button>\n            ))}\n          </div>\n        </div>\n\n        <div className=\"resource-thresholds\">\n          <h3>Resource Specific Thresholds</h3>\n          {/* Resource specific threshold configuration would go here */}\n        </div>\n      </div>\n    );\n  };\n\n  // Render alerts and notifications\n  const renderAlerts = () => {\n    return (\n      <div className=\"resource-alerts\">\n        <h2>Resource Alerts</h2>\n        <div className=\"alert-list\">\n          {thresholdState.notifications.map((notification, index) => (\n            <div key={index} className=\"alert-item\">\n              <span>{notification}</span>\n              <Button\n                size=\"small\"\n                onClick={() => thresholdDispatch({ type: 'CLEAR_NOTIFICATION', payload: index })}\n              >\n                Dismiss\n              </Button>\n            </div>\n          ))}\n          {thresholdState.notifications.length === 0 && (\n            <div className=\"no-alerts\">\n              <p>No active alerts. All resource levels are within thresholds.</p>\n            </div>\n          )}\n        </div>\n      </div>\n    );\n  };\n\n  // Render resource forecasting\n  const renderResourceForecasting = () => {\n    return (\n      <div className=\"resource-forecasting\">\n        <h2>Resource Forecasting</h2>\n        <div className=\"forecasting-controls\">\n          <div className=\"filter-controls\">\n            <span>Select resource to forecast:</span>\n            {[...MAIN_RESOURCES, ...SECONDARY_RESOURCES].map(type => (\n              <Button\n                key={type}\n                type={selectedResource === type ? 'primary' : 'default'}\n                onClick={() => handleResourceSelect(type === selectedResource ? undefined : type)}\n              >\n                {type}\n              </Button>\n            ))}\n          </div>\n        </div>\n\n        {selectedResource ? (\n          <div className=\"forecasting-container\">\n            <ResourceForecastingVisualization\n              resourceType={selectedResource}\n              currentValue={resourceData[selectedResource]?.value ?? 0}\n              maxValue={resourceData[selectedResource]?.maxValue || 1000}\n              rate={resourceData[selectedResource]?.rate ?? 0}\n              cycleTime={resourceData[selectedResource]?.cycleTime || 1000}\n              forecastPeriod={120} // 2 hours\n              dataPoints={24}\n              thresholds={{\n                critical: resourceData[selectedResource]?.thresholds.critical,\n                low: resourceData[selectedResource]?.thresholds.low,\n                target: resourceData[selectedResource]?.thresholds.target,\n                high: resourceData[selectedResource]?.thresholds.high,\n                maximum: resourceData[selectedResource]?.thresholds.maximum,\n              }}\n            />\n          </div>\n        ) : (\n          <div className=\"resource-selection-prompt\">\n            <p>Please select a resource to view forecasting data?.</p>\n          </div>\n        )}\n      </div>\n    );\n  };\n\n  // Render optimization suggestions\n  const renderOptimizationSuggestions = () => {\n    return (\n      <div className=\"resource-optimization\">\n        <h2>Resource Optimization Suggestions</h2>\n        <div className=\"optimization-controls\">\n          <div className=\"filter-controls\">\n            <span>Filter suggestions by resource:</span>\n            <Button\n              type={selectedResource === undefined ? 'primary' : 'default'}\n              onClick={() => handleResourceSelect(undefined)}\n            >\n              All Resources\n            </Button>\n            {[...MAIN_RESOURCES, ...SECONDARY_RESOURCES].map(type => (\n              <Button\n                key={type}\n                type={selectedResource === type ? 'primary' : 'default'}\n                onClick={() => handleResourceSelect(type)}\n              >\n                {type}\n              </Button>\n            ))}\n          </div>\n        </div>\n\n        <div className=\"suggestions-container\">\n          <ResourceOptimizationSuggestions\n            focusedResource={selectedResource}\n            showAllSuggestions={false}\n            maxSuggestions={10}\n            onImplementSuggestion={(suggestion: {\n              id: string;\n              title: string;\n              resourceType: ResourceType | 'all';\n              description: string;\n              impact: 'high' | 'medium' | 'low';\n              category: 'efficiency' | 'bottleneck' | 'allocation' | 'prediction';\n              actionable: boolean;\n              implemented: boolean;\n            }) => {\n              // Handle suggestion implementation\n              // This could trigger a resource reallocation, optimization routine, etc.\n              console.warn(`Implementing suggestion: ${suggestion.id}`);\n\n              // Add to notification system\n              thresholdDispatch({\n                type: 'ADD_NOTIFICATION',\n                payload: `Implemented optimization: ${suggestion.title}`,\n              });\n            }}\n          />\n        </div>\n      </div>\n    );\n  };\n\n  return (\n    <div className=\"resource-management-dashboard\">\n      <div className=\"dashboard-header\">\n        <h2>Resource Management</h2>\n      </div>\n\n      <Tabs\n        activeKey={activeTab}\n        onChange={setActiveTab}\n        type=\"card\"\n        className=\"resource-tabs\"\n        items={[\n          {\n            key: 'overview',\n            label: 'Overview',\n            children: renderResourceOverview(),\n          },\n          {\n            key: 'flow',\n            label: 'Resource Flow',\n            children: renderResourceFlow(),\n          },\n          {\n            key: 'converters',\n            label: 'Converters',\n            children: renderConverterManagement(),\n          },\n          {\n            key: 'chains',\n            label: 'Production Chains',\n            children: renderProductionChains(),\n          },\n          {\n            key: 'thresholds',\n            label: 'Thresholds',\n            children: renderThresholdConfiguration(),\n          },\n          {\n            key: 'alerts',\n            label: 'Alerts',\n            children: renderAlerts(),\n          },\n          {\n            key: 'forecasting',\n            label: 'Forecasting',\n            children: renderResourceForecasting(),\n          },\n          {\n            key: 'optimization',\n            label: 'Optimization',\n            children: renderOptimizationSuggestions(),\n          },\n        ]}\n      />\n    </div>\n  );\n};\n\n// Export a memoized version of the component\nexport const ResourceManagementDashboard = React.memo(ResourceManagementDashboardBase);\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/resource/ResourceOptimizationSuggestions.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/resource/ResourceRateFiltering.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/resource/ResourceRatesDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/resource/ResourceRatesTrends.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/resource/ResourceRatesUI.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/resource/ResourceRegistrationDemo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/resource/ResourceThresholdVisualization.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/resource/ResourceVisualizationEnhanced.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'percentFilled' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":89,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":89,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'timeUntilEmpty' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":90,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":90,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'timeUntilFull' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":91,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":91,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'setRate' is assigned a value but never used. Allowed unused elements of array destructuring must match /^_/u.","line":156,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":156,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'fillPercentage' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":203,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":203,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { AlertTriangle, TrendingDown, TrendingUp } from 'lucide-react';\nimport * as React from 'react';\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { useModuleEvents } from '../../../hooks/events/useModuleEvents';\nimport { ModuleEvent } from '../../../lib/events/ModuleEventBus';\nimport { EventType } from '../../../types/events/EventTypes';\nimport { ResourceType } from '../../../types/resources/ResourceTypes';\nimport { isResourceUpdateEvent } from '../../../utils/events/eventTypeGuards';\nimport { resourceColors, resourceIcons, resourceNames } from '../ResourceVisualization';\nimport { useTooltipContext } from '../tooltip-context';\n\n/**\n * Enhanced version of ResourceVisualization that uses the component registration system\n *\n * This component:\n * 1. Registers with the ComponentRegistryService\n * 2. Subscribes to resource-related events\n * 3. Updates in real-time based on resource events\n * 4. Provides performance metrics through the registry\n */\n\ninterface ResourceDisplayProps {\n  type: ResourceType;\n  value: number;\n  rate?: number;\n  capacity?: number;\n  thresholds?: {\n    warning: number;\n    critical: number;\n  };\n}\n\n// Resource descriptions for tooltips\nconst resourceDescriptions: Record<ResourceType, string> = {\n  [ResourceType.MINERALS]: 'Raw materials used for construction and manufacturing.',\n  [ResourceType.ENERGY]: 'Powers all modules, buildings, and operations.',\n  [ResourceType.POPULATION]: 'Citizens of your empire who can be assigned to various tasks.',\n  [ResourceType.RESEARCH]: 'Scientific knowledge used to unlock new technologies.',\n  [ResourceType.PLASMA]: 'High-energy matter used for advanced technology.',\n  [ResourceType.GAS]: 'Various gases used for life support and manufacturing.',\n  [ResourceType.EXOTIC]: 'Rare materials with unique properties for special projects.',\n  [ResourceType.IRON]: 'Basic building material for structures and components.',\n  [ResourceType.COPPER]: 'Conductive material used in electronics and wiring.',\n  [ResourceType.TITANIUM]: 'Strong, lightweight metal used for advanced construction.',\n  [ResourceType.URANIUM]: 'Radioactive material used for nuclear power and weapons.',\n  [ResourceType.WATER]: 'Essential resource for life support and various processes.',\n  [ResourceType.HELIUM]: 'Light gas used for cooling and various industrial processes.',\n  [ResourceType.DEUTERIUM]: 'Hydrogen isotope used for fusion power and advanced propulsion.',\n  [ResourceType.ANTIMATTER]: 'Exotic material with enormous energy potential.',\n  [ResourceType.DARK_MATTER]: 'Mysterious substance with reality-warping properties.',\n  [ResourceType.EXOTIC_MATTER]: 'Extremely rare material with unique physical properties.',\n  [ResourceType.ORGANIC]: 'Biological material used for medicine and biotech.',\n  [ResourceType.FOOD]: 'Essential sustenance to maintain population growth and happiness.',\n};\n\nfunction getResourceStatus(\n  value: number,\n  capacity?: number,\n  thresholds?: { warning: number; critical: number }\n) {\n  if (!capacity || !thresholds) return null;\n\n  const percentage = (value / capacity) * 100;\n\n  if (percentage <= thresholds.critical) {\n    return {\n      icon: AlertTriangle,\n      message: 'Critical',\n      color: 'text-red-500',\n    };\n  }\n\n  if (percentage <= thresholds.warning) {\n    return {\n      icon: AlertTriangle,\n      message: 'Warning',\n      color: 'text-yellow-500',\n    };\n  }\n\n  return null;\n}\n\n// Tooltip content for resources\nconst ResourceTooltip = React.memo(\n  ({ type, value, rate = 0, capacity, thresholds }: ResourceDisplayProps) => {\n    const status = getResourceStatus(value, capacity, thresholds);\n    const colors = resourceColors[type];\n    const percentFilled = capacity ? ((value / capacity) * 100).toFixed(1) : 'N/A';\n    const timeUntilEmpty = rate < 0 ? Math.abs(value / rate).toFixed(1) : 'N/A';\n    const timeUntilFull = rate > 0 && capacity ? ((capacity - value) / rate).toFixed(1) : 'N/A';\n\n    return (\n      <div className={`rounded-md p-2 ${colors.bg} border ${colors.border}`}>\n        <div className=\"flex items-center gap-2\">\n          <span className={colors.base}>{resourceNames[type]}</span>\n          {status && (\n            <span className={status.color}>\n              <status.icon className=\"h-4 w-4\" />\n            </span>\n          )}\n        </div>\n\n        <div className=\"mt-1 space-y-1\">\n          <div className=\"flex items-center justify-between gap-4\">\n            <span className=\"text-gray-400\">Current:</span>\n            <span className={colors.base}>{value.toLocaleString()}</span>\n          </div>\n\n          {rate !== 0 && (\n            <div className=\"flex items-center justify-between gap-4\">\n              <span className=\"text-gray-400\">Rate:</span>\n              <div className=\"flex items-center gap-1\">\n                {rate > 0 ? (\n                  <TrendingUp className=\"h-4 w-4 text-green-500\" />\n                ) : rate < 0 ? (\n                  <TrendingDown className=\"h-4 w-4 text-red-500\" />\n                ) : null}\n                <span\n                  className={rate > 0 ? 'text-green-500' : rate < 0 ? 'text-red-500' : colors.base}\n                >\n                  {rate > 0 ? '+' : ''}\n                  {rate.toLocaleString()}/s\n                </span>\n              </div>\n            </div>\n          )}\n\n          {capacity !== undefined && (\n            <div className=\"flex items-center justify-between gap-4\">\n              <span className=\"text-gray-400\">Capacity:</span>\n              <span className={colors.base}>{capacity.toLocaleString()}</span>\n            </div>\n          )}\n\n          <div className=\"mt-2 text-sm text-gray-400\">{resourceDescriptions[type]}</div>\n        </div>\n      </div>\n    );\n  }\n);\n\nResourceTooltip.displayName = 'ResourceTooltip';\n\n/**\n * Enhanced resource display component that updates in real-time based on resource events\n */\nconst EnhancedResourceDisplay = React.memo(function EnhancedResourceDisplayBase({\n  type,\n  value: initialValue,\n  rate: initialRate,\n  capacity,\n  thresholds,\n}: ResourceDisplayProps) {\n  const [value, setValue] = useState(initialValue);\n  const [rate, setRate] = useState(initialRate);\n  const { showTooltip, hideTooltip } = useTooltipContext();\n  const componentRef = useRef<HTMLDivElement>(null);\n  const { subscribe } = useModuleEvents();\n\n  // Subscribe to resource update events\n  useEffect(() => {\n    const handleResourceUpdate = (event: ModuleEvent) => {\n      if (isResourceUpdateEvent(event)) {\n        const resourceAmounts = event?.data?.resourceAmounts;\n        if (resourceAmounts && type in resourceAmounts) {\n          const newValue = resourceAmounts[type];\n          if (typeof newValue === 'number') {\n            setValue(newValue);\n          }\n        }\n      }\n    };\n\n    const unsubscribe = subscribe(EventType.RESOURCE_UPDATED, handleResourceUpdate);\n    return () => {\n      unsubscribe();\n    };\n  }, [type, subscribe]);\n\n  // Handle mouse events for tooltip\n  const handleMouseEnter = useCallback(() => {\n    if (componentRef.current) {\n      const rect = componentRef.current.getBoundingClientRect();\n      showTooltip(\n        <ResourceTooltip\n          type={type}\n          value={value}\n          rate={rate}\n          capacity={capacity}\n          thresholds={thresholds}\n        />,\n        { x: rect.left + rect.width / 2, y: rect.top }\n      );\n    }\n  }, [type, value, rate, capacity, thresholds, showTooltip]);\n\n  const handleMouseLeave = useCallback(() => {\n    hideTooltip();\n  }, [hideTooltip]);\n\n  // Calculate fill percentage for the progress bar\n  const fillPercentage = useMemo(() => {\n    if (!capacity) return 100;\n    return Math.min(100, (value / capacity) * 100);\n  }, [value, capacity]);\n\n  const colors = resourceColors[type];\n  const Icon = resourceIcons[type];\n  const status = getResourceStatus(value, capacity, thresholds);\n\n  return (\n    <div\n      ref={componentRef}\n      className={`relative flex items-center gap-2 rounded-md p-2 ${colors.bg} border ${colors.border} cursor-pointer`}\n      onMouseEnter={handleMouseEnter}\n      onMouseLeave={handleMouseLeave}\n    >\n      <Icon className={`h-5 w-5 ${colors.base}`} />\n      <span className={colors.base}>{value.toLocaleString()}</span>\n      {status && <status.icon className={`h-4 w-4 ${status.color}`} />}\n    </div>\n  );\n});\n\n/**\n * ResourceVisualizationEnhanced component\n *\n * Enhanced version of ResourceVisualization that uses the new event system\n * and provides real-time updates based on resource events.\n */\nexport const ResourceVisualizationEnhanced = React.memo(\n  function ResourceVisualizationEnhancedBase() {\n    const [resources, setResources] = useState<ResourceDisplayProps[]>([]);\n    const { subscribe } = useModuleEvents();\n\n    // Subscribe to resource events\n    useEffect(() => {\n      const handleResourceUpdate = (event: ModuleEvent) => {\n        if (isResourceUpdateEvent(event)) {\n          const resourceAmounts = event?.data?.resourceAmounts;\n          if (resourceAmounts && typeof resourceAmounts === 'object') {\n            setResources(prev =>\n              prev.map(resource => {\n                const newValue =\n                  resource.type in resourceAmounts ? resourceAmounts[resource.type] : null;\n                return {\n                  ...resource,\n                  value: typeof newValue === 'number' ? newValue : resource.value,\n                };\n              })\n            );\n          }\n        }\n      };\n\n      const unsubscribe = subscribe(EventType.RESOURCE_UPDATED, handleResourceUpdate);\n      return () => {\n        unsubscribe();\n      };\n    }, [subscribe]);\n\n    return (\n      <div className=\"space-y-2\">\n        {resources.map(resource => (\n          <EnhancedResourceDisplay key={resource.type} {...resource} />\n        ))}\n      </div>\n    );\n  }\n);\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/resource/VirtualizedResourceDataset.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/resource/VirtualizedResourceList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/showcase/DataDashboardApp.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_TimeSeriesAnimationConfig' is defined but never used. Allowed unused vars must match /^ignored|^temp/u.","line":111,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":111,"endColumn":37},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'D3Link' is defined but never used. Allowed unused vars must match /^ignored|^temp/u.","line":234,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":234,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'setTimeRange' is assigned a value but never used. Allowed unused elements of array destructuring must match /^_/u.","line":309,"column":21,"nodeType":null,"messageId":"unusedVar","endLine":309,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'worldMapData' is assigned a value but never used. Allowed unused elements of array destructuring must match /^_/u.","line":331,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":331,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_worldMapData' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":338,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":338,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_handleTimeRangeChange' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":380,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":380,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'range' is defined but never used.","line":380,"column":47,"nodeType":null,"messageId":"unusedVar","endLine":380,"endColumn":52},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'labels' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":598,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":598,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'convertTimeSeriesDataToD3Format' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":707,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":707,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'convertGeoDataToD3Format' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":753,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":753,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_filterByCategory' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":930,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":930,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_pointCount' is defined but never used.","line":1437,"column":47,"nodeType":null,"messageId":"unusedVar","endLine":1437,"endColumn":58},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_labels' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":1599,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":1599,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as d3 from 'd3';\nimport { Feature } from 'geojson';\nimport * as React from 'react';\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react';\n\n// Import optimization utilities\nimport {\n  animationQualityManager,\n  QualitySettings,\n} from '../../../utils/performance/D3AnimationQualityManager';\n\n// Import type-safe D3 utilities\nimport { AnimationConfig } from '../../../types/visualizations/D3AnimationTypes';\nimport { createSimulationDragBehavior } from '../../../types/visualizations/D3DragTypes';\nimport {\n  d3Accessors,\n  SimulationLinkDatum,\n  SimulationNodeDatum,\n} from '../../../types/visualizations/D3Types';\nimport {\n  createSvgZoomBehavior,\n  getFitToViewportTransform,\n} from '../../../types/visualizations/D3ZoomTypes';\n\n// Type definitions\ninterface DataDashboardAppProps {\n  width?: number;\n  height?: number;\n}\n\n// Data types\ninterface BaseDataPoint {\n  id: string;\n  value: number;\n  category: string;\n  timestamp: Date;\n}\n\ninterface NetworkNode extends BaseDataPoint {\n  connections: string[];\n  group: string;\n  size: number;\n}\n\ninterface NetworkLink {\n  source: string;\n  target: string;\n  value: number;\n  type: string;\n}\n\ninterface TimeSeriesPoint extends BaseDataPoint {\n  timePeriod: string;\n  change: number;\n}\n\ninterface GeoDataPoint extends BaseDataPoint {\n  region: string;\n  latitude: number;\n  longitude: number;\n  population: number;\n}\n\ninterface HierarchyNode extends BaseDataPoint {\n  parentId: string | null;\n  children?: HierarchyNode[];\n  size: number;\n}\n\n// D3 simulation node interface with proper typing\ninterface D3NetworkNode extends SimulationNodeDatum<NetworkNode> {\n  id: string;\n  value: number;\n  category: string;\n  group: string;\n  size: number;\n  color?: string;\n  radius?: number;\n  // Reference to original data\n  data?: NetworkNode;\n}\n\n// D3 simulation link interface with proper typing\ninterface _D3Link extends SimulationLinkDatum<D3NetworkNode> {\n  source: string | D3NetworkNode;\n  target: string | D3NetworkNode;\n  value: number;\n  type: string;\n  width?: number;\n  color?: string;\n}\n\n// D3 time series chart types with proper type safety\ninterface D3TimeSeriesPoint {\n  id: string;\n  date: Date;\n  value: number;\n  category: string;\n  color?: string;\n  originalData?: TimeSeriesPoint; // Reference to original data\n}\n\n// Interface for grouped time series data\ninterface CategorySeries {\n  category: string;\n  color: string;\n  points: D3TimeSeriesPoint[];\n}\n\n// Animation configuration for time series\ninterface _TimeSeriesAnimationConfig extends AnimationConfig {\n  // Additional animation settings specific to time series\n  staggerDelay?: number; // Delay between animating different series\n  pointDelay?: number; // Delay between animating different points\n  lineAnimationType?: 'grow' | 'fade' | 'draw'; // How the line should animate\n}\n\n// Enums\nenum VisualizationType {\n  NETWORK = 'network',\n  TIMESERIES = 'timeseries',\n  GEOSPATIAL = 'geospatial',\n  HIERARCHY = 'hierarchy',\n}\n\n// Extended quality settings for all visualization types\ninterface ExtendedQualitySettings extends QualitySettings {\n  // Node rendering settings\n  nodeDetailLevel: number;\n  linkDetailLevel: number;\n  showLabels: boolean;\n  textScaleFactor: number;\n\n  // Time series visualization settings\n  lineWidth: number;\n  pointRadius: number;\n  animationsEnabled: boolean;\n  animationDuration: number;\n  showGridLines: boolean;\n  maxDataPointsPerSeries: number;\n  downsampling: boolean;\n\n  // Geographic visualization settings\n  mapProjection: 'mercator' | 'equalEarth' | 'orthographic' | 'naturalEarth';\n  mapDetailLevel: 'low' | 'medium' | 'high';\n  showGraticules: boolean;\n  pointSizeScale: number;\n  showTooltips: boolean;\n\n  // Hierarchical visualization settings\n  hierarchyLayout: 'tree' | 'treemap' | 'cluster' | 'radial';\n  treeOrientation: 'vertical' | 'horizontal' | 'radial';\n  nodeColor: 'byCategory' | 'byValue' | 'byDepth';\n  linkStyle: 'straight' | 'curved' | 'diagonal' | 'step';\n  treemapTiling: 'binary' | 'squarify' | 'slice' | 'dice' | 'sliceDice';\n  includeSizeEncoding: boolean;\n}\n\n// Type for drag behavior with SVG circles\ntype CircleDragBehavior = d3.DragBehavior<SVGCircleElement, D3NetworkNode, unknown>;\n\n// D3 geo data types with proper type safety\ninterface D3GeoPoint {\n  id: string;\n  coordinates: [number, number]; // [longitude, latitude]\n  value: number;\n  category: string;\n  color?: string;\n  radius?: number;\n  region: string;\n  population: number;\n  originalData?: GeoDataPoint; // Reference to original data\n}\n\n// Interface for grouped geographic data\ninterface GeoCategory {\n  category: string;\n  color: string;\n  points: D3GeoPoint[];\n}\n\n// GeoJSON world map type\ninterface WorldMapData {\n  features: Feature[];\n  type: string;\n}\n\n// D3 hierarchical data types with proper type safety\ninterface D3HierarchyNode {\n  id: string;\n  name: string;\n  value: number;\n  size: number;\n  category: string;\n  depth?: number;\n  color?: string;\n  children?: D3HierarchyNode[];\n  originalData?: HierarchyNode; // Reference to original data\n}\n\n// Define a custom type for treemap tiling functions\ntype TreemapTilingFunc = (\n  node: d3.HierarchyRectangularNode<D3HierarchyNode>,\n  x0: number,\n  y0: number,\n  x1: number,\n  y1: number\n) => void;\n\n// Define a custom type for hierarchy point links\ninterface CustomHierarchyPointLink {\n  source: {\n    x: number;\n    y: number;\n    data: D3HierarchyNode;\n  };\n  target: {\n    x: number;\n    y: number;\n    data: D3HierarchyNode;\n  };\n}\n\n// Type for D3's link data structure\ninterface D3LinkDatum {\n  x: number;\n  y: number;\n  data?: D3HierarchyNode;\n  // Other optional properties that might be present\n  [key: string]: number | D3HierarchyNode | undefined;\n}\n\n// Type for D3's link structure\ninterface D3Link {\n  source: D3LinkDatum;\n  target: D3LinkDatum;\n}\n\n// Type definition for d3.hierarchy result with proper typing\n// Using a type that doesn't extend HierarchyNode directly to avoid the 'this' type issue\ninterface HierarchyDatum {\n  x?: number;\n  y?: number;\n  x0?: number;\n  y0?: number;\n  x1?: number;\n  y1?: number;\n  depth: number;\n  height: number;\n  parent: HierarchyDatum | null;\n  children?: HierarchyDatum[];\n  data: D3HierarchyNode;\n  // Add methods from HierarchyNode that we need\n  ancestors(): HierarchyDatum[];\n  descendants(): HierarchyDatum[];\n  leaves(): HierarchyDatum[];\n  find(filter: (node: HierarchyDatum) => boolean): HierarchyDatum | undefined;\n  path(target: HierarchyDatum): HierarchyDatum[];\n  links(): Array<{ source: HierarchyDatum; target: HierarchyDatum }>;\n  sum(value: (d: D3HierarchyNode) => number): HierarchyDatum;\n  sort(compare: (a: HierarchyDatum, b: HierarchyDatum) => number): HierarchyDatum;\n  count(): HierarchyDatum;\n  copy(): HierarchyDatum;\n  each(callback: (node: HierarchyDatum) => void): HierarchyDatum;\n  eachAfter(callback: (node: HierarchyDatum) => void): HierarchyDatum;\n  eachBefore(callback: (node: HierarchyDatum) => void): HierarchyDatum;\n  [Symbol.iterator](): Iterator<HierarchyDatum>;\n}\n\n// Define a proper interface for the link data expected by d3.linkHorizontal\ninterface D3LinkData {\n  source: [number, number];\n  target: [number, number];\n}\n\n/**\n * DataDashboardApp\n *\n * A comprehensive visualization dashboard that demonstrates multiple D3 visualization types\n * optimized with our performance techniques. It shows how various visualizations can coexist\n * and interact while maintaining smooth performance.\n *\n * Features:\n * - Multi-panel visualization layout\n * - Interactive data exploration\n * - Coordinated views and cross-filtering\n * - Integrated performance optimization\n * - Type-safe implementation\n */\nexport const DataDashboardApp: React.FC<DataDashboardAppProps> = ({\n  width = 1200,\n  height = 900,\n}) => {\n  // References\n  const containerRef = useRef<HTMLDivElement>(null);\n  const networkRef = useRef<SVGSVGElement>(null);\n  const timeSeriesRef = useRef<SVGSVGElement>(null);\n  const geoMapRef = useRef<SVGSVGElement>(null);\n  const hierarchyRef = useRef<SVGSVGElement>(null);\n\n  // Simulation state reference for force-directed graph\n  const simulationRef = useRef<d3.Simulation<D3NetworkNode, _D3Link> | null>(null);\n\n  // State\n  const [currentView, setCurrentView] = useState<VisualizationType>(VisualizationType.NETWORK);\n  const [isAnimating, setIsAnimating] = useState(false);\n  const [dataLoaded, setDataLoaded] = useState(false);\n  const [optimizationsEnabled, setOptimizationsEnabled] = useState(true);\n  const [timeRange, setTimeRange] = useState<[Date, Date]>([\n    new Date(2022, 0, 1),\n    new Date(2023, 0, 1),\n  ]);\n  const [selectedEntities, setSelectedEntities] = useState<string[]>([]);\n  const [filterValue, setFilterValue] = useState<number>(0);\n\n  // Data state\n  const [networkData, setNetworkData] = useState<{ nodes: NetworkNode[]; links: NetworkLink[] }>({\n    nodes: [],\n    links: [],\n  });\n  const [timeSeriesData, setTimeSeriesData] = useState<TimeSeriesPoint[]>([]);\n  const [geoData, setGeoData] = useState<GeoDataPoint[]>([]);\n  const [hierarchyData, setHierarchyData] = useState<HierarchyNode[]>([]);\n\n  // Quality settings\n  const [qualitySettings, setQualitySettings] = useState<QualitySettings>(\n    animationQualityManager.getCurrentSettings()\n  );\n\n  // World map GeoJSON data reference\n  const [worldMapData, setWorldMapData] = useState<WorldMapData | null>(null);\n\n  // State for hierarchical visualization layout type\n  const [hierarchyLayoutType, setHierarchyLayoutType] =\n    useState<ExtendedQualitySettings['hierarchyLayout']>('tree');\n\n  // Memoized world map data\n  const _worldMapData = useMemo(() => {\n    return {\n      features: [],\n      type: 'FeatureCollection',\n    };\n  }, []);\n\n  // Define visualization initialization functions early to avoid \"used before declaration\" errors\n  const initializeTimeSeriesVisualization = useCallback(() => {\n    console.warn('Initializing time series visualization');\n    // Implementation would go here\n  }, [timeSeriesData, selectedEntities, timeRange, optimizationsEnabled, qualitySettings]);\n\n  const initializeGeoVisualization = useCallback(() => {\n    console.warn('Initializing geo visualization');\n    // Implementation would go here\n  }, [geoData, selectedEntities, optimizationsEnabled, qualitySettings]);\n\n  // Event handlers\n  const handleViewChange = (view: VisualizationType) => {\n    setCurrentView(view);\n  };\n\n  const toggleAnimation = () => {\n    setIsAnimating(!isAnimating);\n  };\n\n  const toggleOptimizations = () => {\n    setOptimizationsEnabled(!optimizationsEnabled);\n  };\n\n  // Define entity selection handler here before it's used in the visualization functions\n  const handleEntitySelection = (entityId: string) => {\n    setSelectedEntities(prev => {\n      if (prev.includes(entityId)) {\n        return prev.filter(id => id !== entityId);\n      } else {\n        return [...prev, entityId];\n      }\n    });\n  };\n\n  const _handleTimeRangeChange = useCallback((range: [Date, Date]) => {\n    // Implementation\n  }, []);\n\n  const handleFilterChange = (value: number) => {\n    setFilterValue(value);\n  };\n\n  // Load data\n  useEffect(() => {\n    // In a real application, this would be an API call\n    // For now, we'll generate synthetic data\n\n    // Generate network data\n    const networkData = generateNetworkData(50, 100);\n    setNetworkData(networkData);\n\n    // Generate time series data\n    const timeSeriesData = generateTimeSeriesData(100);\n    setTimeSeriesData(timeSeriesData);\n\n    // Generate geo data\n    const geoData = generateGeoData(200);\n    setGeoData(geoData);\n\n    // Generate hierarchy data\n    const hierarchyData = generateHierarchyData(100);\n    setHierarchyData(hierarchyData);\n\n    // Mark data as loaded\n    setDataLoaded(true);\n  }, []);\n\n  // Register with animation quality manager\n  useEffect(() => {\n    if (optimizationsEnabled) {\n      animationQualityManager.registerAnimation('data-dashboard', settings => {\n        setQualitySettings(settings);\n      });\n    }\n\n    return () => {\n      animationQualityManager.unregisterAnimation('data-dashboard');\n    };\n  }, [optimizationsEnabled]);\n\n  /**\n   * Converts network data to D3-compatible format with proper typing\n   * This creates new objects with additional properties needed for D3\n   * while maintaining references to the original data\n   */\n  const convertNetworkDataToD3Format = useCallback(() => {\n    // Create node map for quick lookups\n    const nodeMap = new Map<string, D3NetworkNode>();\n\n    // Convert nodes with proper typing\n    const nodes: D3NetworkNode[] = networkData.nodes.map(node => {\n      // Create a color based on the group\n      let color = '';\n      switch (node.group) {\n        case 'A':\n          color = '#4285F4';\n          break; // Blue\n        case 'B':\n          color = '#EA4335';\n          break; // Red\n        case 'C':\n          color = '#FBBC05';\n          break; // Yellow\n        case 'D':\n          color = '#34A853';\n          break; // Green\n        default:\n          color = '#9AA0A6'; // Grey\n      }\n\n      // Calculate radius based on size and current quality settings\n      const baseRadius = Math.sqrt(node.size) * 3;\n      // Cast to ExtendedQualitySettings to use the additional properties\n      const extendedSettings = qualitySettings as ExtendedQualitySettings;\n      const nodeDetailLevel = extendedSettings.nodeDetailLevel || 1; // Default to 1 if not defined\n      const radius = optimizationsEnabled ? baseRadius * nodeDetailLevel : baseRadius;\n\n      // Create D3 node with proper typing\n      const d3Node: D3NetworkNode = {\n        id: node.id,\n        value: node.value,\n        category: node.category,\n        group: node.group,\n        size: node.size,\n        color,\n        radius,\n        // Store reference to original data\n        data: node,\n      };\n\n      // Add to map for quick lookups when creating links\n      nodeMap.set(node.id, d3Node);\n\n      return d3Node;\n    });\n\n    // Convert links with proper typing\n    const links: _D3Link[] = networkData.links.map(link => {\n      // Calculate link width based on value and quality settings\n      const baseWidth = Math.sqrt(link.value) * 1.5;\n      // Cast to ExtendedQualitySettings to use the additional properties\n      const extendedSettings = qualitySettings as ExtendedQualitySettings;\n      const linkDetailLevel = extendedSettings.linkDetailLevel || 1; // Default to 1 if not defined\n      const width = optimizationsEnabled ? baseWidth * linkDetailLevel : baseWidth;\n\n      // Create color based on link type\n      const color = link.type === 'direct' ? '#4285F4' : '#9AA0A6';\n\n      // Create D3 link with proper typing\n      const d3Link: _D3Link = {\n        source: link.source,\n        target: link.target,\n        value: link.value,\n        type: link.type,\n        width,\n        color,\n      };\n\n      return d3Link;\n    });\n\n    return { nodes, links, nodeMap };\n  }, [networkData, optimizationsEnabled, qualitySettings]);\n\n  /**\n   * Initialize the network visualization with a force-directed graph\n   * This uses D3's force layout with type-safe implementation\n   */\n  const initializeNetworkVisualization = useCallback(() => {\n    if (!networkRef.current || networkData.nodes.length === 0) return;\n\n    console.warn('Initializing network visualization with force-directed graph');\n\n    // Clear previous visualization\n    d3.select(networkRef.current).selectAll('*').remove();\n\n    // Get the container dimensions\n    const svgWidth = width;\n    const svgHeight = height * 0.8; // 80% of total height for the visualization\n\n    // Convert data to D3 format with proper typing\n    const { nodes, links, nodeMap } = convertNetworkDataToD3Format();\n\n    // Create the SVG container\n    const svg = d3\n      .select(networkRef.current)\n      .attr('width', svgWidth)\n      .attr('height', svgHeight)\n      .attr('viewBox', [0, 0, svgWidth, svgHeight])\n      .attr('style', 'max-width: 100%; height: auto; font: 10px sans-serif;');\n\n    // Create a group for zoom/pan transformations\n    const g = svg.append('g').attr('class', 'network-container');\n\n    // Create the zoom behavior with type safety\n    const zoom = createSvgZoomBehavior<SVGSVGElement>({\n      scaleExtentMin: 0.1,\n      scaleExtentMax: 5,\n      targetElement: g,\n      constrainPan: true,\n    });\n\n    // Apply zoom to the SVG\n    svg.call(zoom);\n\n    // Initial transform to fit content\n    const initialTransform = getFitToViewportTransform(\n      svgWidth,\n      svgHeight,\n      svgWidth,\n      svgHeight,\n      50\n    );\n    svg.call(zoom.transform, initialTransform);\n\n    // Create link elements\n    const link = g\n      .append('g')\n      .attr('class', 'links')\n      .selectAll('line')\n      .data(links)\n      .enter()\n      .append('line')\n      .attr('stroke', d => d.color || '#999')\n      .attr('stroke-opacity', 0.6)\n      .attr('stroke-width', d => d.width || 1);\n\n    // Create node elements\n    const node = g\n      .append('g')\n      .attr('class', 'nodes')\n      .selectAll('circle')\n      .data(nodes)\n      .enter()\n      .append('circle')\n      .attr('r', d => d.radius || 5)\n      .attr('fill', d => d.color || '#666')\n      .attr('stroke', '#fff')\n      .attr('stroke-width', 1.5)\n      .classed('selected', d => selectedEntities.includes(d.id));\n\n    // Add titles for tooltips\n    node.append('title').text(d => `${d.id} (${d.group})\\nValue: ${d.value}`);\n\n    // Cast to ExtendedQualitySettings to use the additional properties\n    const extendedSettings = qualitySettings as ExtendedQualitySettings;\n    const showLabels =\n      extendedSettings.showLabels !== undefined ? extendedSettings.showLabels : true; // Default to true\n    const textScaleFactor = extendedSettings.textScaleFactor || 1; // Default to 1\n\n    // Create text labels based on quality settings\n    if (showLabels) {\n      const labels = g\n        .append('g')\n        .attr('class', 'labels')\n        .selectAll('text')\n        .data(nodes.filter(n => n.value > filterValue)) // Only label significant nodes\n        .enter()\n        .append('text')\n        .attr('dx', 12)\n        .attr('dy', '.35em')\n        .text(d => d.id)\n        .style('font-size', `${10 * textScaleFactor}px`)\n        .style('fill', '#333');\n    }\n\n    // Create the force simulation with proper typing\n    const simulation = d3\n      .forceSimulation<D3NetworkNode>(nodes)\n      .force(\n        'link',\n        d3\n          .forceLink<D3NetworkNode, _D3Link>(links)\n          .id(d => d.id)\n          .distance(d => 30 + d.value)\n      )\n      .force(\n        'charge',\n        d3.forceManyBody().strength(d => {\n          // Safely access the size property by casting to D3NetworkNode\n          const node = d as D3NetworkNode;\n          return -30 * (node.size || 1);\n        })\n      )\n      .force('center', d3.forceCenter(svgWidth / 2, svgHeight / 2))\n      .force(\n        'collision',\n        d3.forceCollide<D3NetworkNode>().radius(d => (d.radius || 5) + 2)\n      );\n\n    // Create drag behavior with type safety\n    const drag = createSimulationDragBehavior<D3NetworkNode, SVGCircleElement>(simulation);\n\n    // Apply the drag behavior with proper type casting\n    node.call(drag as CircleDragBehavior);\n\n    // Node click handler\n    node.on('click', (event, d) => {\n      event?.stopPropagation(); // Prevent triggering container click\n      handleEntitySelection(d.id);\n    });\n\n    // Update function for the simulation\n    simulation.on('tick', () => {\n      // Use safe accessors to prevent type errors\n      link\n        .attr('x1', d =>\n          d3Accessors.getX(typeof d.source === 'string' ? nodeMap.get(d.source) : d.source)\n        )\n        .attr('y1', d =>\n          d3Accessors.getY(typeof d.source === 'string' ? nodeMap.get(d.source) : d.source)\n        )\n        .attr('x2', d =>\n          d3Accessors.getX(typeof d.target === 'string' ? nodeMap.get(d.target) : d.target)\n        )\n        .attr('y2', d =>\n          d3Accessors.getY(typeof d.target === 'string' ? nodeMap.get(d.target) : d.target)\n        );\n\n      node.attr('cx', d => d3Accessors.getX(d)).attr('cy', d => d3Accessors.getY(d));\n\n      // Update labels position if they exist\n      if (showLabels) {\n        g.selectAll('.labels text')\n          .attr('x', d => d3Accessors.getX(d))\n          .attr('y', d => d3Accessors.getY(d));\n      }\n    });\n\n    // Store simulation reference for cleanup\n    simulationRef.current = simulation;\n\n    // Animation toggle\n    if (!isAnimating) {\n      simulation.alpha(0).stop();\n    }\n\n    // Cleanup function for when component unmounts or view changes\n    return () => {\n      if (simulationRef.current) {\n        simulationRef.current.stop();\n        simulationRef.current = null;\n      }\n    };\n  }, [\n    networkData,\n    width,\n    height,\n    selectedEntities,\n    filterValue,\n    isAnimating,\n    optimizationsEnabled,\n    qualitySettings,\n    convertNetworkDataToD3Format,\n    handleEntitySelection,\n  ]);\n\n  /**\n   * Converts time series data to D3-compatible format with proper typing\n   * Creates points and series objects needed for D3 visualization\n   */\n  const convertTimeSeriesDataToD3Format = useCallback(() => {\n    // Create color mapping for consistent colors per category\n    const categoryColors: Record<string, string> = {\n      revenue: '#4285F4', // Blue\n      expenses: '#EA4335', // Red\n      profit: '#34A853', // Green\n      users: '#FBBC05', // Yellow\n    };\n\n    // Convert points with proper typing\n    const points: D3TimeSeriesPoint[] = timeSeriesData.map(point => {\n      // Get color based on category\n      const color = categoryColors[point.category] || '#9AA0A6';\n\n      // Create D3 point with proper typing\n      const d3Point: D3TimeSeriesPoint = {\n        id: point.id,\n        date: point.timestamp,\n        value: point.value,\n        category: point.category,\n        color,\n        originalData: point,\n      };\n\n      return d3Point;\n    });\n\n    // Group points by category for line generation\n    const categories = Array.from(new Set(points.map(p => p.category)));\n    const series: CategorySeries[] = categories.map(category => {\n      return {\n        category,\n        color: categoryColors[category] || '#9AA0A6',\n        points: points\n          .filter(p => p.category === category)\n          .sort((a, b) => a.date.getTime() - b.date.getTime()),\n      };\n    });\n\n    return { points, series };\n  }, [timeSeriesData]);\n\n  /**\n   * Converts geographic data to D3-compatible format with proper typing\n   * This creates points objects needed for D3 geo visualization\n   */\n  const convertGeoDataToD3Format = useCallback(() => {\n    // Create color mapping for consistent colors per category\n    const categoryColors: Record<string, string> = {\n      customers: '#4285F4', // Blue\n      sales: '#EA4335', // Red\n      partners: '#34A853', // Green\n    };\n\n    // Convert points with proper typing\n    const points: D3GeoPoint[] = geoData.map(point => {\n      // Get color based on category\n      const color = categoryColors[point.category] || '#9AA0A6';\n\n      // Create D3 geo point with proper typing\n      const d3Point: D3GeoPoint = {\n        id: point.id,\n        coordinates: [point.longitude, point.latitude], // GeoJSON uses [longitude, latitude]\n        value: point.value,\n        category: point.category,\n        color,\n        region: point.region,\n        population: point.population,\n        originalData: point,\n      };\n\n      return d3Point;\n    });\n\n    // Group points by category for styling and filtering\n    const categories = Array.from(new Set(points.map(p => p.category)));\n    const geoCategories: GeoCategory[] = categories.map(category => {\n      return {\n        category,\n        color: categoryColors[category] || '#9AA0A6',\n        points: points.filter(p => p.category === category),\n      };\n    });\n\n    return { points, geoCategories };\n  }, [geoData]);\n\n  /**\n   * Converts flat hierarchy data to a proper hierarchical structure with proper typing\n   * This creates a tree structure suitable for D3 hierarchical layouts\n   */\n  const convertHierarchyDataToD3Format = useCallback(() => {\n    // Create a map to store nodes by ID for quick lookup\n    const nodeMap = new Map<string, D3HierarchyNode>();\n\n    // Define category colors\n    const categoryColors: Record<string, string> = {\n      'category-A': '#4285F4', // Blue\n      'category-B': '#EA4335', // Red\n      'category-C': '#34A853', // Green\n      'subcategory-1': '#9AA0A6', // Gray\n      'subcategory-2': '#FBBC05', // Yellow\n      'subcategory-3': '#DADCE0', // Light gray\n      root: '#5F6368', // Dark gray\n    };\n\n    // First pass: create D3HierarchyNode objects for all nodes\n    hierarchyData.forEach(node => {\n      const color = categoryColors[node.category] || '#9AA0A6';\n\n      const d3Node: D3HierarchyNode = {\n        id: node.id,\n        name: node.id, // Use ID as name\n        value: node.value,\n        size: node.size,\n        category: node.category,\n        color,\n        children: [],\n        originalData: node,\n      };\n\n      nodeMap.set(node.id, d3Node);\n    });\n\n    // Second pass: build the tree structure\n    const rootNodes: D3HierarchyNode[] = [];\n\n    hierarchyData.forEach(node => {\n      const d3Node = nodeMap.get(node.id);\n\n      if (node.parentId === null) {\n        // This is a root node\n        rootNodes.push(d3Node!);\n      } else {\n        // This node has a parent, add it to the parent's children\n        const parentNode = nodeMap.get(node.parentId);\n        if (parentNode) {\n          if (!parentNode.children) {\n            parentNode.children = [];\n          }\n          parentNode.children.push(d3Node!);\n        }\n      }\n    });\n\n    // Return the root of the hierarchy (should be only one)\n    return rootNodes[0];\n  }, [hierarchyData]);\n\n  /**\n   * Creates a hierarchical visualization with tree or treemap layout\n   * Uses D3's hierarchical layouts with proper type safety\n   */\n  const initializeHierarchyVisualization = useCallback(() => {\n    if (!hierarchyRef.current || hierarchyData.length === 0) return;\n\n    console.warn(`Initializing hierarchical visualization with ${hierarchyLayoutType} layout`);\n\n    // Clear previous visualization\n    d3.select(hierarchyRef.current).selectAll('*').remove();\n\n    // Get the container dimensions\n    const svgWidth = width;\n    const svgHeight = height * 0.8; // 80% of total height for the visualization\n\n    // Cast quality settings\n    const extendedSettings = qualitySettings as ExtendedQualitySettings;\n\n    // Default settings with fallbacks\n    const animationsEnabled =\n      extendedSettings.animationsEnabled !== undefined ? extendedSettings.animationsEnabled : true;\n    const animationDuration = extendedSettings.animationDuration || 1000;\n    const showLabels =\n      extendedSettings.showLabels !== undefined ? extendedSettings.showLabels : true;\n    const textScaleFactor = extendedSettings.textScaleFactor || 1;\n    const nodeColor = extendedSettings.nodeColor || 'byCategory';\n    const linkStyle = extendedSettings.linkStyle || 'diagonal';\n    const treemapTiling = extendedSettings.treemapTiling || 'squarify';\n    const includeSizeEncoding =\n      extendedSettings.includeSizeEncoding !== undefined\n        ? extendedSettings.includeSizeEncoding\n        : true;\n    const treeOrientation = extendedSettings.treeOrientation || 'vertical';\n\n    // Convert hierarchy data to D3 format (proper tree structure)\n    const rootNode = convertHierarchyDataToD3Format();\n\n    // Create the SVG container\n    const svg = d3\n      .select(hierarchyRef.current)\n      .attr('width', svgWidth)\n      .attr('height', svgHeight)\n      .attr('viewBox', [0, 0, svgWidth, svgHeight])\n      .attr('style', 'max-width: 100%; height: auto; font: 10px sans-serif;');\n\n    // Set up margins and visualization dimensions\n    const margin = { top: 40, right: 40, bottom: 40, left: 120 };\n    const visWidth = svgWidth - margin.left - margin.right;\n    const visHeight = svgHeight - margin.top - margin.bottom;\n\n    // Create visualization area with margin\n    const g = svg\n      .append('g')\n      .attr('transform', `translate(${margin.left},${margin.top})`)\n      .attr('class', 'hierarchy-container');\n\n    // Main visualization title\n    svg\n      .append('text')\n      .attr('class', 'hierarchy-title')\n      .attr('text-anchor', 'middle')\n      .attr('x', svgWidth / 2)\n      .attr('y', 20)\n      .attr('font-size', '16px')\n      .attr('font-weight', 'bold')\n      .text(\n        `Hierarchical Data Visualization (${hierarchyLayoutType.charAt(0).toUpperCase() + hierarchyLayoutType.slice(1)})`\n      );\n\n    // Create a group for zoom/pan transformations\n    const zoomG = g.append('g');\n\n    // Apply category filter if selected entities exist\n    const _filterByCategory = (node: D3HierarchyNode): boolean => {\n      if (selectedEntities.length === 0) return true;\n      if (selectedEntities.includes(node.category)) return true;\n      if (node.children) {\n        // Include if any children match the filter\n        return node.children.some(_filterByCategory);\n      }\n      return false;\n    };\n\n    // Create a value scale for node size\n    const valueExtent = d3.extent(hierarchyData, d => d.value) as [number, number];\n    const sizeScale = d3.scaleSqrt().domain(valueExtent).range([5, 20]);\n\n    // Create color scales\n    const categoryScale = (category: string): string => {\n      const colorMap: Record<string, string> = {\n        'category-A': '#4285F4',\n        'category-B': '#EA4335',\n        'category-C': '#34A853',\n        'subcategory-1': '#9AA0A6',\n        'subcategory-2': '#FBBC05',\n        'subcategory-3': '#DADCE0',\n        root: '#5F6368',\n      };\n      return colorMap[category] || '#9AA0A6';\n    };\n\n    const valueColorScale = d3.scaleSequential(d3.interpolateViridis).domain(valueExtent);\n\n    const depthColorScale = d3.scaleOrdinal(d3.schemeCategory10);\n\n    // (...args: unknown[]) => unknown to determine node color based on settings\n    const getNodeColor = (d: HierarchyDatum): string => {\n      switch (nodeColor) {\n        case 'byValue':\n          return valueColorScale(d.data?.value);\n        case 'byDepth':\n          return depthColorScale(d.depth.toString());\n        case 'byCategory':\n        default:\n          return d.data?.color || categoryScale(d.data?.category);\n      }\n    };\n\n    // Create hierarchy from the rootNode using d3.hierarchy\n    const root = d3.hierarchy<D3HierarchyNode>(rootNode) as unknown as HierarchyDatum;\n\n    // Apply filtering if needed\n    // Apply filter to only include nodes that match selectedEntities\n    if (selectedEntities.length > 0) {\n      root.descendants().forEach(node => {\n        if (node.children) {\n          node.children = node.children.filter(\n            child =>\n              selectedEntities.length === 0 ||\n              selectedEntities.includes(child.data?.category) ||\n              (child.children &&\n                child.children.some(grandchild =>\n                  selectedEntities.includes(grandchild.data?.category)\n                ))\n          );\n        }\n      });\n    }\n\n    // Size the hierarchy based on values\n    root.sum(d => (includeSizeEncoding ? d.value : 1));\n\n    // Implement different layouts based on the selected type\n    if (hierarchyLayoutType === 'treemap') {\n      // TREEMAP LAYOUT\n\n      // Create the treemap layout\n      let tilingMethod: TreemapTilingFunc;\n      switch (treemapTiling) {\n        case 'binary':\n          tilingMethod = d3.treemapBinary;\n          break;\n        case 'slice':\n          tilingMethod = d3.treemapSlice;\n          break;\n        case 'dice':\n          tilingMethod = d3.treemapDice;\n          break;\n        case 'sliceDice':\n          tilingMethod = d3.treemapSliceDice;\n          break;\n        case 'squarify':\n        default:\n          tilingMethod = d3.treemapSquarify;\n          break;\n      }\n\n      const treemap = d3\n        .treemap<D3HierarchyNode>()\n        .size([visWidth, visHeight])\n        .padding(3)\n        .round(true)\n        .tile(tilingMethod);\n\n      // Compute the treemap layout\n      treemap(root as unknown as d3.HierarchyNode<D3HierarchyNode>);\n\n      // Create the treemap cells\n      const nodes = zoomG\n        .selectAll('g')\n        .data(root.descendants())\n        .enter()\n        .append('g')\n        .attr('transform', d => {\n          // Use non-null assertions since we know these values exist after treemap layout\n          return `translate(${d.x0!},${d.y0!})`;\n        })\n        .attr('class', 'node')\n        .classed('selected', d => selectedEntities.includes(d.data?.id));\n\n      // Add rectangles for each node\n      nodes\n        .append('rect')\n        .attr('width', d => Math.max(0, d.x1! - d.x0!))\n        .attr('height', d => Math.max(0, d.y1! - d.y0!))\n        .attr('fill', getNodeColor)\n        .attr('stroke', '#fff')\n        .attr('stroke-width', 1)\n        .on('click', (event, d) => {\n          event?.stopPropagation();\n          handleEntitySelection(d.data?.id);\n        });\n\n      // Add text labels to cells\n      nodes\n        .append('text')\n        .attr('x', d => (d.x1! - d.x0!) / 2)\n        .attr('y', d => (d.y1! - d.y0!) / 2)\n        .attr('text-anchor', 'middle')\n        .attr('dominant-baseline', 'middle')\n        .style('font-size', d => {\n          const width = d.x1! - d.x0!;\n          const height = d.y1! - d.y0!;\n          return Math.min(width, height) / 8 + 'px';\n        })\n        .style('fill', '#fff')\n        .text(d => d.data?.name)\n        .style('pointer-events', 'none');\n\n      // Add tooltips\n      nodes\n        .append('title')\n        .text(\n          d =>\n            `${d.data?.name}\\nCategory: ${d.data?.category}\\nValue: ${d.data?.value.toFixed(2)}\\nSize: ${d.data?.size}`\n        );\n\n      // Add click handlers for selection\n      nodes.on('click', (event, d) => {\n        event?.stopPropagation();\n        handleEntitySelection(d.data?.id);\n      });\n\n      // Add zoom behavior\n      const zoom = createSvgZoomBehavior<SVGSVGElement>({\n        scaleExtentMin: 0.5,\n        scaleExtentMax: 8,\n        targetElement: zoomG,\n        constrainPan: true,\n      });\n\n      // Apply zoom to the SVG\n      svg.call(zoom);\n\n      // Add animations if enabled\n      if (animationsEnabled && isAnimating) {\n        // Animate the nodes appearing\n        nodes\n          .attr('opacity', 0)\n          .transition()\n          .duration(animationDuration)\n          .attr('opacity', 0.8)\n          .ease(d3.easeBackOut);\n      }\n    } else {\n      // TREE LAYOUT\n\n      // Determine tree orientation\n      let treeLayout: d3.TreeLayout<D3HierarchyNode>;\n\n      if (treeOrientation === 'horizontal') {\n        // Horizontal tree (left to right)\n        treeLayout = d3.tree<D3HierarchyNode>().size([visHeight, visWidth]);\n\n        // Swap x and y in the resulting layout\n        root.descendants().forEach(d => {\n          const temp = d.x;\n          d.x = d.y;\n          d.y = temp;\n        });\n      } else if (treeOrientation === 'radial') {\n        // Radial tree\n        treeLayout = d3\n          .tree<D3HierarchyNode>()\n          .size([2 * Math.PI, Math.min(visWidth, visHeight) / 2 - 40]);\n\n        // Apply layout without transforming yet\n        treeLayout(root as unknown as d3.HierarchyNode<D3HierarchyNode>);\n\n        // Convert from polar to Cartesian coordinates\n        root.descendants().forEach(d => {\n          const radius = d.y!; // Add non-null assertion\n          const angle = d.x!; // Add non-null assertion\n          d.x = radius * Math.cos(angle - Math.PI / 2) + visWidth / 2;\n          d.y = radius * Math.sin(angle - Math.PI / 2) + visHeight / 2;\n        });\n      } else {\n        // Default: Vertical tree (top to bottom)\n        treeLayout = d3.tree<D3HierarchyNode>().size([visWidth, visHeight]);\n      }\n\n      // Apply the tree layout if not already applied\n      if (treeOrientation !== 'radial') {\n        treeLayout(root as unknown as d3.HierarchyNode<D3HierarchyNode>);\n      }\n\n      // Create the link generator based on the selected style\n      const linkGenerator = (d: CustomHierarchyPointLink) => {\n        const source = { x: d.source.x ?? 0, y: d.source.y ?? 0, data: d.source.data };\n        const target = { x: d.target.x ?? 0, y: d.target.y ?? 0, data: d.target.data };\n\n        // Create properly formatted link data for d3.linkHorizontal\n        const linkData: D3LinkData = {\n          source: [source.y, source.x],\n          target: [target.y, target.x],\n        };\n\n        switch (linkStyle) {\n          case 'straight':\n            return d3.linkHorizontal()(linkData);\n          case 'step':\n            return `M${source.y},${source.x} V${target.x} H${target.y}`;\n          case 'diagonal':\n          default:\n            return d3.linkHorizontal()(linkData);\n        }\n      };\n\n      // Draw links\n      const links = zoomG\n        .append('g')\n        .attr('class', 'links')\n        .selectAll('path')\n        .data(root.links())\n        .enter()\n        .append('path')\n        .attr('d', d => {\n          // Cast the HierarchyDatum link to CustomHierarchyPointLink\n          const link = {\n            source: {\n              x: d.source.x ?? 0,\n              y: d.source.y ?? 0,\n              data: d.source.data,\n            },\n            target: {\n              x: d.target.x ?? 0,\n              y: d.target.y ?? 0,\n              data: d.target.data,\n            },\n          } as CustomHierarchyPointLink;\n\n          return linkGenerator(link);\n        })\n        .attr('fill', 'none')\n        .attr('stroke', '#ccc')\n        .attr('stroke-width', 1.5)\n        .attr('opacity', 0.5);\n\n      // Draw nodes\n      const nodes = zoomG\n        .append('g')\n        .attr('class', 'nodes')\n        .selectAll('g')\n        .data(root.descendants())\n        .enter()\n        .append('g')\n        .attr('class', 'node')\n        .attr('transform', d => `translate(${d.x},${d.y})`)\n        .classed('selected', d => selectedEntities.includes(d.data?.category));\n\n      // Add circles for each node\n      const circles = nodes\n        .append('circle')\n        .attr('r', d => (includeSizeEncoding ? sizeScale(d.data?.value) : 6))\n        .attr('fill', getNodeColor)\n        .attr('stroke', '#fff')\n        .attr('stroke-width', 1.5)\n        .attr('cursor', 'pointer');\n\n      // Add labels if enabled\n      if (showLabels) {\n        nodes\n          .append('text')\n          .attr('dy', '.31em')\n          .attr('x', d => (d.children ? -8 : 8))\n          .style('text-anchor', d => (d.children ? 'end' : 'start'))\n          .text(d => d.data?.name)\n          .attr('font-size', `${10 * textScaleFactor}px`)\n          .attr('pointer-events', 'none'); // Don't interfere with click events\n      }\n\n      // Add tooltips\n      nodes\n        .append('title')\n        .text(\n          d =>\n            `${d.data?.name}\\nCategory: ${d.data?.category}\\nValue: ${d.data?.value.toFixed(2)}\\nSize: ${d.data?.size}`\n        );\n\n      // Add click handlers for selection\n      nodes.on('click', (event, d) => {\n        event?.stopPropagation();\n        handleEntitySelection(d.data?.category);\n      });\n\n      // Add zoom behavior\n      const zoom = createSvgZoomBehavior<SVGSVGElement>({\n        scaleExtentMin: 0.5,\n        scaleExtentMax: 8,\n        targetElement: zoomG,\n        constrainPan: true,\n      });\n\n      // Apply zoom to the SVG\n      svg.call(zoom);\n\n      // Add initial transform to center the root node\n      if (treeOrientation === 'horizontal') {\n        const initialTransform = d3.zoomIdentity.translate(margin.left, visHeight / 2);\n        svg.call(zoom.transform, initialTransform);\n      }\n\n      // Add animations if enabled\n      if (animationsEnabled && isAnimating) {\n        // Animate the links\n        links\n          .attr('stroke-dasharray', function () {\n            const length = this.getTotalLength();\n            return `${length} ${length}`;\n          })\n          .attr('stroke-dashoffset', function () {\n            return this.getTotalLength();\n          })\n          .transition()\n          .duration(animationDuration)\n          .attr('stroke-dashoffset', 0)\n          .ease(d3.easeLinear);\n\n        // Animate the nodes appearing\n        circles\n          .attr('r', 0)\n          .transition()\n          .duration(animationDuration)\n          .delay((d, i) => d.depth * 300 + i * 10)\n          .attr('r', d => (includeSizeEncoding ? sizeScale(d.data?.value) : 6))\n          .ease(d3.easeElastic);\n      }\n    }\n\n    // Add layout toggle buttons\n    const buttonGroup = svg\n      .append('g')\n      .attr('class', 'layout-buttons')\n      .attr('transform', `translate(${svgWidth - 180}, ${margin.top - 20})`);\n\n    const layouts = ['tree', 'treemap', 'cluster', 'radial'];\n\n    layouts.forEach((layout, i) => {\n      const button = buttonGroup\n        .append('g')\n        .attr('class', 'layout-button')\n        .attr('transform', `translate(${i * 45}, 0)`)\n        .style('cursor', 'pointer')\n        .on('click', () => {\n          setHierarchyLayoutType(layout as ExtendedQualitySettings['hierarchyLayout']);\n        });\n\n      button\n        .append('rect')\n        .attr('width', 40)\n        .attr('height', 20)\n        .attr('rx', 5)\n        .attr('ry', 5)\n        .attr('fill', layout === hierarchyLayoutType ? '#4285F4' : '#e0e0e0');\n\n      button\n        .append('text')\n        .attr('x', 20)\n        .attr('y', 14)\n        .attr('text-anchor', 'middle')\n        .attr('fill', layout === hierarchyLayoutType ? '#fff' : '#333')\n        .attr('font-size', '10px')\n        .text(layout.charAt(0).toUpperCase() + layout.slice(1));\n    });\n\n    // Reset selection when clicking on the background\n    svg.on('click', event => {\n      // Prevent triggering if clicking on nodes\n      if (event?.target === svg.node()) {\n        setSelectedEntities([]);\n      }\n    });\n  }, [\n    hierarchyData,\n    hierarchyRef.current,\n    width,\n    height,\n    hierarchyLayoutType,\n    isAnimating,\n    optimizationsEnabled,\n    qualitySettings,\n    selectedEntities,\n    convertHierarchyDataToD3Format,\n    handleEntitySelection,\n  ]);\n\n  // Initialize visualizations once data is loaded\n  useEffect(() => {\n    if (!dataLoaded) return;\n\n    // Initialize visualizations based on current view\n    switch (currentView) {\n      case VisualizationType.NETWORK:\n        initializeNetworkVisualization();\n        break;\n      case VisualizationType.TIMESERIES:\n        initializeTimeSeriesVisualization();\n        break;\n      case VisualizationType.GEOSPATIAL:\n        initializeGeoVisualization();\n        break;\n      case VisualizationType.HIERARCHY:\n        initializeHierarchyVisualization();\n        break;\n    }\n  }, [\n    dataLoaded,\n    currentView,\n    networkData,\n    timeSeriesData,\n    geoData,\n    hierarchyData,\n    selectedEntities,\n    timeRange,\n    optimizationsEnabled,\n    qualitySettings,\n    initializeNetworkVisualization,\n    initializeTimeSeriesVisualization,\n    initializeGeoVisualization,\n    initializeHierarchyVisualization,\n    hierarchyLayoutType,\n  ]);\n\n  // Generate mock network data\n  const generateNetworkData = (nodeCount: number, linkCount: number) => {\n    const nodes: NetworkNode[] = [];\n    const links: NetworkLink[] = [];\n\n    // Generate nodes\n    const groups = ['A', 'B', 'C', 'D'];\n    for (let i = 0; i < nodeCount; i++) {\n      nodes.push({\n        id: `node-${i}`,\n        value: Math.random() * 100,\n        category: ['primary', 'secondary', 'tertiary'][Math.floor(Math.random() * 3)],\n        timestamp: new Date(2022, Math.floor(Math.random() * 12), Math.floor(Math.random() * 28)),\n        connections: [],\n        group: groups[Math.floor(Math.random() * groups.length)],\n        size: Math.random() * 10 + 5,\n      });\n    }\n\n    // Generate links\n    for (let i = 0; i < linkCount; i++) {\n      const source = Math.floor(Math.random() * nodeCount);\n      let target = Math.floor(Math.random() * nodeCount);\n\n      // Avoid self-links\n      while (target === source) {\n        target = Math.floor(Math.random() * nodeCount);\n      }\n\n      const link = {\n        source: `node-${source}`,\n        target: `node-${target}`,\n        value: Math.random() * 10,\n        type: ['direct', 'indirect'][Math.floor(Math.random() * 2)],\n      };\n\n      links.push(link);\n\n      // Update node connections\n      nodes[source].connections.push(`node-${target}`);\n      nodes[target].connections.push(`node-${source}`);\n    }\n\n    return { nodes, links };\n  };\n\n  // Generate mock time series data\n  const generateTimeSeriesData = useCallback((_pointCount: number) => {\n    const data: TimeSeriesPoint[] = [];\n    const categories = ['revenue', 'expenses', 'profit', 'users'];\n    const timePeriods = ['Q1', 'Q2', 'Q3', 'Q4'];\n\n    // Generate time series points\n    for (let year = 2020; year <= 2023; year++) {\n      for (let periodIdx = 0; periodIdx < timePeriods.length; periodIdx++) {\n        for (let catIdx = 0; catIdx < categories.length; catIdx++) {\n          const prevValue =\n            catIdx === 0\n              ? 0\n              : (data?.find(\n                  d =>\n                    d.category === categories[catIdx] &&\n                    d.timePeriod === timePeriods[periodIdx === 0 ? 3 : periodIdx - 1]\n                )?.value ?? 0);\n\n          const randomChange = Math.random() * 20 - 10; // -10 to +10\n          const value = Math.max(0, prevValue + randomChange + Math.random() * 5 + 50);\n\n          data?.push({\n            id: `ts-${year}-${timePeriods[periodIdx]}-${categories[catIdx]}`,\n            value,\n            category: categories[catIdx],\n            timestamp: new Date(year, periodIdx * 3, 15), // Quarterly data\n            timePeriod: `${year}-${timePeriods[periodIdx]}`,\n            change: value - prevValue,\n          });\n        }\n      }\n    }\n\n    return data;\n  }, []);\n\n  // Generate mock geo data\n  const generateGeoData = (pointCount: number) => {\n    const data: GeoDataPoint[] = [];\n    const regions = ['North America', 'Europe', 'Asia', 'South America', 'Africa', 'Oceania'];\n\n    // Generate geo points\n    for (let i = 0; i < pointCount; i++) {\n      const region = regions[Math.floor(Math.random() * regions.length)];\n\n      // Generate latitude/longitude based on rough region bounds\n      let latitude, longitude;\n      switch (region) {\n        case 'North America':\n          latitude = 30 + Math.random() * 20;\n          longitude = -130 + Math.random() * 60;\n          break;\n        case 'Europe':\n          latitude = 40 + Math.random() * 15;\n          longitude = -10 + Math.random() * 50;\n          break;\n        case 'Asia':\n          latitude = 10 + Math.random() * 40;\n          longitude = 60 + Math.random() * 80;\n          break;\n        case 'South America':\n          latitude = -40 + Math.random() * 40;\n          longitude = -80 + Math.random() * 30;\n          break;\n        case 'Africa':\n          latitude = -30 + Math.random() * 50;\n          longitude = -20 + Math.random() * 60;\n          break;\n        case 'Oceania':\n          latitude = -40 + Math.random() * 30;\n          longitude = 110 + Math.random() * 50;\n          break;\n        default:\n          latitude = Math.random() * 180 - 90;\n          longitude = Math.random() * 360 - 180;\n      }\n\n      data?.push({\n        id: `geo-${i}`,\n        value: Math.random() * 100,\n        category: ['customers', 'sales', 'partners'][Math.floor(Math.random() * 3)],\n        timestamp: new Date(2022, Math.floor(Math.random() * 12), Math.floor(Math.random() * 28)),\n        region,\n        latitude,\n        longitude,\n        population: Math.floor(Math.random() * 1000000),\n      });\n    }\n\n    return data;\n  };\n\n  // Generate mock hierarchy data\n  const generateHierarchyData = (nodeCount: number) => {\n    const data: HierarchyNode[] = [];\n\n    // Create root node\n    data?.push({\n      id: 'root',\n      value: 1000,\n      category: 'root',\n      timestamp: new Date(),\n      parentId: null,\n      size: 100,\n    });\n\n    // Create first level children\n    const firstLevelCount = 5;\n    for (let i = 0; i < firstLevelCount; i++) {\n      data?.push({\n        id: `level1-${i}`,\n        value: 200 + Math.random() * 200,\n        category: ['category-A', 'category-B', 'category-C'][Math.floor(Math.random() * 3)],\n        timestamp: new Date(),\n        parentId: 'root',\n        size: 50 + Math.random() * 20,\n      });\n    }\n\n    // Create second level children\n    const remainingNodes = nodeCount - 1 - firstLevelCount;\n    const nodesPerFirstLevel = Math.floor(remainingNodes / firstLevelCount);\n\n    for (let i = 0; i < firstLevelCount; i++) {\n      for (let j = 0; j < nodesPerFirstLevel; j++) {\n        data?.push({\n          id: `level2-${i}-${j}`,\n          value: 50 + Math.random() * 100,\n          category: ['subcategory-1', 'subcategory-2', 'subcategory-3'][\n            Math.floor(Math.random() * 3)\n          ],\n          timestamp: new Date(),\n          parentId: `level1-${i}`,\n          size: 20 + Math.random() * 10,\n        });\n      }\n    }\n\n    return data;\n  };\n\n  // Load world map data once\n  useEffect(() => {\n    // In a real application, this would load from an API or local file\n    // For this demo, we'll use a simplified world map in GeoJSON format\n    const fetchWorldMap = async () => {\n      try {\n        // Simplified world map in GeoJSON format (low resolution for performance)\n        const response = await fetch('https://unpkg.com/world-atlas@2.0.2/countries-110m.json');\n        const data = await response?.json();\n        setWorldMapData(data);\n      } catch (error) {\n        console.error('Error loading world map data:', error);\n        // Fallback to null if fetch fails\n        setWorldMapData(null);\n      }\n    };\n\n    fetchWorldMap();\n  }, []);\n\n  // Memoized labels\n  const _labels = useMemo(() => {\n    return {\n      network: {\n        title: 'Network Visualization',\n        subtitle: 'Interactive force-directed graph',\n      },\n      timeseries: {\n        title: 'Time Series Analysis',\n        subtitle: 'Multi-category temporal data',\n      },\n      geospatial: {\n        title: 'Geographic Distribution',\n        subtitle: 'Global data visualization',\n      },\n      hierarchy: {\n        title: 'Hierarchical Structure',\n        subtitle: 'Tree-based organization',\n      },\n    };\n  }, []);\n\n  // Rendering\n  return (\n    <div\n      className=\"data-dashboard-app\"\n      ref={containerRef}\n      style={{\n        width,\n        height,\n        fontFamily: 'Arial, sans-serif',\n        display: 'flex',\n        flexDirection: 'column',\n      }}\n    >\n      <div\n        className=\"dashboard-header\"\n        style={{\n          padding: '1rem',\n          backgroundColor: '#f5f5f5',\n          borderBottom: '1px solid #ddd',\n        }}\n      >\n        <h1 style={{ margin: 0, fontSize: '1.5rem' }}>Data Visualization Dashboard</h1>\n        <p>A comprehensive showcase of optimized D3 visualizations</p>\n\n        <div\n          className=\"dashboard-controls\"\n          style={{\n            display: 'flex',\n            gap: '1rem',\n            marginTop: '0.5rem',\n          }}\n        >\n          <div className=\"view-selector\" style={{ display: 'flex', gap: '0.5rem' }}>\n            {Object.values(VisualizationType).map(type => (\n              <button\n                key={type}\n                onClick={() => handleViewChange(type)}\n                style={{\n                  padding: '0.5rem 1rem',\n                  backgroundColor: currentView === type ? '#2196F3' : '#e0e0e0',\n                  color: currentView === type ? 'white' : 'black',\n                  border: 'none',\n                  borderRadius: '4px',\n                  cursor: 'pointer',\n                }}\n              >\n                {type.charAt(0).toUpperCase() + type.slice(1)}\n              </button>\n            ))}\n          </div>\n\n          <button\n            onClick={toggleAnimation}\n            style={{\n              padding: '0.5rem 1rem',\n              backgroundColor: isAnimating ? '#f44336' : '#4CAF50',\n              color: 'white',\n              border: 'none',\n              borderRadius: '4px',\n              cursor: 'pointer',\n            }}\n          >\n            {isAnimating ? 'Stop Animation' : 'Start Animation'}\n          </button>\n\n          <button\n            onClick={toggleOptimizations}\n            style={{\n              padding: '0.5rem 1rem',\n              backgroundColor: optimizationsEnabled ? '#9C27B0' : '#FF9800',\n              color: 'white',\n              border: 'none',\n              borderRadius: '4px',\n              cursor: 'pointer',\n            }}\n          >\n            {optimizationsEnabled ? 'Optimizations On' : 'Optimizations Off'}\n          </button>\n        </div>\n      </div>\n\n      <div\n        className=\"dashboard-main\"\n        style={{\n          flex: 1,\n          display: 'grid',\n          gridTemplateColumns: '70% 30%',\n          gridTemplateRows: '60% 40%',\n          gap: '1rem',\n          padding: '1rem',\n          overflow: 'hidden',\n        }}\n      >\n        <div\n          className=\"main-visualization\"\n          style={{\n            gridColumn: '1',\n            gridRow: '1 / span 2',\n            backgroundColor: 'white',\n            boxShadow: '0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24)',\n            borderRadius: '4px',\n            overflow: 'hidden',\n            position: 'relative',\n          }}\n        >\n          {currentView === VisualizationType.NETWORK && (\n            <svg ref={networkRef} width=\"100%\" height=\"100%\"></svg>\n          )}\n\n          {currentView === VisualizationType.TIMESERIES && (\n            <svg ref={timeSeriesRef} width=\"100%\" height=\"100%\"></svg>\n          )}\n\n          {currentView === VisualizationType.GEOSPATIAL && (\n            <svg ref={geoMapRef} width=\"100%\" height=\"100%\"></svg>\n          )}\n\n          {currentView === VisualizationType.HIERARCHY && (\n            <svg ref={hierarchyRef} width=\"100%\" height=\"100%\"></svg>\n          )}\n\n          {!dataLoaded && (\n            <div\n              className=\"loading-overlay\"\n              style={{\n                position: 'absolute',\n                top: 0,\n                left: 0,\n                right: 0,\n                bottom: 0,\n                display: 'flex',\n                justifyContent: 'center',\n                alignItems: 'center',\n                backgroundColor: 'rgba(255, 255, 255, 0.7)',\n              }}\n            >\n              <div>Loading visualization data?...</div>\n            </div>\n          )}\n        </div>\n\n        <div\n          className=\"detail-panel\"\n          style={{\n            gridColumn: '2',\n            gridRow: '1',\n            backgroundColor: 'white',\n            boxShadow: '0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24)',\n            borderRadius: '4px',\n            padding: '1rem',\n            overflow: 'auto',\n          }}\n        >\n          <h2 style={{ margin: '0 0 1rem 0', fontSize: '1.2rem' }}>Details</h2>\n\n          {selectedEntities.length > 0 ? (\n            <div className=\"selected-entities\">\n              <h3>Selected Items</h3>\n              <ul>\n                {selectedEntities.map(id => (\n                  <li key={id}>{id}</li>\n                ))}\n              </ul>\n            </div>\n          ) : (\n            <div className=\"no-selection\">\n              <p>No items selected. Click on elements in the visualization to see details.</p>\n            </div>\n          )}\n        </div>\n\n        <div\n          className=\"controls-panel\"\n          style={{\n            gridColumn: '2',\n            gridRow: '2',\n            backgroundColor: 'white',\n            boxShadow: '0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24)',\n            borderRadius: '4px',\n            padding: '1rem',\n            overflow: 'auto',\n          }}\n        >\n          <h2 style={{ margin: '0 0 1rem 0', fontSize: '1.2rem' }}>Controls</h2>\n\n          <div className=\"filter-controls\" style={{ marginBottom: '1rem' }}>\n            <label style={{ display: 'block', marginBottom: '0.5rem' }}>\n              Filter by value: {filterValue}\n            </label>\n            <input\n              type=\"range\"\n              min=\"0\"\n              max=\"100\"\n              value={filterValue}\n              onChange={e => handleFilterChange(parseInt(e.target.value))}\n              style={{ width: '100%' }}\n            />\n          </div>\n\n          <div className=\"time-range-controls\">\n            <h3 style={{ fontSize: '1rem', marginBottom: '0.5rem' }}>Time Range</h3>\n            <div\n              style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '0.5rem' }}\n            >\n              <span>{timeRange[0].toLocaleDateString()}</span>\n              <span>{timeRange[1].toLocaleDateString()}</span>\n            </div>\n            {/* This is a simplified time range selector - would be replaced with a proper date range picker */}\n            <input\n              type=\"range\"\n              min=\"0\"\n              max=\"100\"\n              value={50}\n              onChange={() => {}}\n              style={{ width: '100%' }}\n            />\n          </div>\n        </div>\n      </div>\n\n      <div\n        className=\"dashboard-footer\"\n        style={{\n          padding: '0.5rem 1rem',\n          backgroundColor: '#f5f5f5',\n          borderTop: '1px solid #ddd',\n          fontSize: '0.8rem',\n          color: '#666',\n        }}\n      >\n        <div>\n          Quality Tier:{' '}\n          {qualitySettings.visualComplexity >= 0.8\n            ? 'High'\n            : qualitySettings.visualComplexity >= 0.5\n              ? 'Medium'\n              : 'Low'}\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default DataDashboardApp;\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/showcase/PerformanceMonitoringDashboard.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'setFrameBudget' is assigned a value but never used. Allowed unused elements of array destructuring must match /^_/u.","line":85,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":85,"endColumn":37},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'colorScale' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":898,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":898,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as d3 from 'd3';\nimport * as React from 'react';\nimport { useEffect, useRef, useState } from 'react';\n\n// Import optimization utilities\nimport {\n  animationFrameManager,\n  FrameInfo,\n} from '../../../utils/performance/D3AnimationFrameManager';\n\n// Type definitions\ninterface PerformanceMonitoringDashboardProps {\n  width?: number;\n  height?: number;\n}\n\ninterface MetricPoint {\n  timestamp: number;\n  value: number;\n}\n\ninterface PerformanceMetrics {\n  fps: MetricPoint[];\n  cpuTime: MetricPoint[];\n  memoryUsage: MetricPoint[];\n  domOperations: MetricPoint[];\n  renderTime: MetricPoint[];\n  layoutThrashing: MetricPoint[];\n  cacheHitRate: MetricPoint[];\n  animationSmoothness: MetricPoint[];\n}\n\ninterface PerformanceIssue {\n  id: string;\n  timestamp: number;\n  type: 'frame_drop' | 'layout_thrashing' | 'high_cpu' | 'memory_leak' | 'jank';\n  severity: 'low' | 'medium' | 'high' | 'critical';\n  description: string;\n  recommendation: string;\n  relatedMetrics: string[];\n}\n\n/**\n * PerformanceMonitoringDashboard\n *\n * A comprehensive dashboard for monitoring and visualizing performance metrics\n * of D3 visualizations. It provides real-time insights into performance characteristics\n * and helps identify optimization opportunities.\n *\n * Features:\n * - Real-time performance metrics\n * - Historical data visualization\n * - Issue detection and recommendations\n * - Comparative performance analysis\n * - Integration with all optimization systems\n */\nconst PerformanceMonitoringDashboard: React.FC<PerformanceMonitoringDashboardProps> = ({\n  width = 1200,\n  height = 900,\n}) => {\n  // References\n  const containerRef = useRef<HTMLDivElement>(null);\n  const fpsChartRef = useRef<SVGSVGElement>(null);\n  const cpuChartRef = useRef<SVGSVGElement>(null);\n  const memoryChartRef = useRef<SVGSVGElement>(null);\n  const timelineChartRef = useRef<SVGSVGElement>(null);\n\n  // State\n  const [isMonitoring, setIsMonitoring] = useState(false);\n  const [monitoredAnimation, setMonitoredAnimation] = useState<string>('');\n  const [timeWindow, setTimeWindow] = useState<number>(60000); // 1 minute in ms\n  const [performanceMetrics, setPerformanceMetrics] = useState<PerformanceMetrics>({\n    fps: [],\n    cpuTime: [],\n    memoryUsage: [],\n    domOperations: [],\n    renderTime: [],\n    layoutThrashing: [],\n    cacheHitRate: [],\n    animationSmoothness: [],\n  });\n  const [detectedIssues, setDetectedIssues] = useState<PerformanceIssue[]>([]);\n  const [selectedMetric, setSelectedMetric] = useState<keyof PerformanceMetrics>('fps');\n  const [activeAnimations, setActiveAnimations] = useState<string[]>([]);\n  const [frameBudget, setFrameBudget] = useState<number>(16.67); // 60fps by default\n\n  // Initialize monitoring\n  useEffect(() => {\n    // Get the list of active animations from the animation frame manager\n    updateActiveAnimations();\n\n    // Set up periodic polling for active animations\n    const animationPoller = setInterval(() => {\n      updateActiveAnimations();\n    }, 5000);\n\n    return () => {\n      clearInterval(animationPoller);\n      stopMonitoring();\n    };\n  }, []);\n\n  // Set up performance monitoring when an animation is selected\n  useEffect(() => {\n    if (isMonitoring && monitoredAnimation) {\n      startMonitoring(monitoredAnimation);\n    } else {\n      stopMonitoring();\n    }\n  }, [isMonitoring, monitoredAnimation]);\n\n  // Update charts when metrics or selected metric changes\n  useEffect(() => {\n    if (performanceMetrics[selectedMetric].length > 0) {\n      updateCharts();\n    }\n  }, [performanceMetrics, selectedMetric]);\n\n  // Get the list of active animations\n  const updateActiveAnimations = () => {\n    // In a real implementation, we would get this from the animation frame manager\n    // For now, we'll create a mock list\n    setActiveAnimations([\n      'network-visualization',\n      'time-series-chart',\n      'hierarchy-visualization',\n      'geo-visualization',\n      'unified-demo',\n      'batch-update-demo',\n    ]);\n  };\n\n  // Start monitoring a specific animation\n  const startMonitoring = (animationId: string) => {\n    if (!animationId) return;\n\n    console.warn(`Starting monitoring for animation: ${animationId}`);\n\n    // Reset metrics\n    setPerformanceMetrics({\n      fps: [],\n      cpuTime: [],\n      memoryUsage: [],\n      domOperations: [],\n      renderTime: [],\n      layoutThrashing: [],\n      cacheHitRate: [],\n      animationSmoothness: [],\n    });\n\n    setDetectedIssues([]);\n\n    // Register a special monitor animation that will collect performance data\n    animationFrameManager.registerAnimation(\n      {\n        id: 'performance-monitor',\n        name: 'Performance Monitor',\n        priority: 'low', // Low priority to avoid affecting the monitored animation\n        type: 'custom',\n        duration: 0, // Run indefinitely\n        loop: true,\n      },\n      (_elapsed, deltaTime, frameInfo) => {\n        collectPerformanceMetrics(deltaTime, frameInfo);\n        return false; // Never complete\n      }\n    );\n\n    // Start the monitoring animation\n    animationFrameManager.startAnimation('performance-monitor');\n  };\n\n  // Stop monitoring\n  const stopMonitoring = () => {\n    // Stop the monitoring animation\n    try {\n      animationFrameManager.pauseAnimation('performance-monitor');\n    } catch (e) {\n      // Animation might not exist yet\n    }\n  };\n\n  // Collect performance metrics on each frame\n  const collectPerformanceMetrics = (deltaTime: number, frameInfo: FrameInfo) => {\n    const now = Date.now();\n\n    // Update FPS metric\n    setPerformanceMetrics(prev => {\n      const newFps = [...prev.fps, { timestamp: now, value: frameInfo.currentFps }];\n\n      // Simulate other metrics for now\n      // In a real implementation, we would get these from the various systems\n      const newCpuTime = [\n        ...prev.cpuTime,\n        {\n          timestamp: now,\n          value: 10 + Math.random() * 10, // Random value between 10-20ms\n        },\n      ];\n\n      const newMemoryUsage = [\n        ...prev.memoryUsage,\n        {\n          timestamp: now,\n          value: 50 + Math.sin(now * 0.001) * 10, // Oscillating value to simulate GC\n        },\n      ];\n\n      const newDomOperations = [\n        ...prev.domOperations,\n        {\n          timestamp: now,\n          value: Math.floor(Math.random() * 50), // Random number of DOM operations\n        },\n      ];\n\n      const newRenderTime = [\n        ...prev.renderTime,\n        {\n          timestamp: now,\n          value: 5 + Math.random() * 10, // Random render time between 5-15ms\n        },\n      ];\n\n      const newLayoutThrashing = [\n        ...prev.layoutThrashing,\n        {\n          timestamp: now,\n          value: Math.random() > 0.9 ? Math.floor(Math.random() * 5) : 0, // Occasional layout thrashing\n        },\n      ];\n\n      const newCacheHitRate = [\n        ...prev.cacheHitRate,\n        {\n          timestamp: now,\n          value: 70 + Math.random() * 30, // Cache hit rate between 70-100%\n        },\n      ];\n\n      const newAnimationSmoothness = [\n        ...prev.animationSmoothness,\n        {\n          timestamp: now,\n          value: frameInfo.currentFps > 30 ? 100 : (frameInfo.currentFps / 30) * 100, // Smoothness score\n        },\n      ];\n\n      // Limit the number of data points based on time window\n      const cutoff = now - timeWindow;\n      const trimMetrics = (metrics: MetricPoint[]) =>\n        metrics.filter(point => point.timestamp >= cutoff);\n\n      // Detect potential performance issues\n      detectPerformanceIssues(\n        newFps[newFps.length - 1],\n        newCpuTime[newCpuTime.length - 1],\n        newLayoutThrashing[newLayoutThrashing.length - 1]\n      );\n\n      return {\n        fps: trimMetrics(newFps),\n        cpuTime: trimMetrics(newCpuTime),\n        memoryUsage: trimMetrics(newMemoryUsage),\n        domOperations: trimMetrics(newDomOperations),\n        renderTime: trimMetrics(newRenderTime),\n        layoutThrashing: trimMetrics(newLayoutThrashing),\n        cacheHitRate: trimMetrics(newCacheHitRate),\n        animationSmoothness: trimMetrics(newAnimationSmoothness),\n      };\n    });\n  };\n\n  // Detect performance issues based on metrics\n  const detectPerformanceIssues = (\n    fpsPoint: MetricPoint,\n    cpuPoint: MetricPoint,\n    layoutPoint: MetricPoint\n  ) => {\n    const now = Date.now();\n\n    // Check for frame drop\n    if (fpsPoint.value < 30) {\n      const severity =\n        fpsPoint.value < 10\n          ? 'critical'\n          : fpsPoint.value < 20\n            ? 'high'\n            : fpsPoint.value < 25\n              ? 'medium'\n              : 'low';\n\n      const newIssue: PerformanceIssue = {\n        id: `frame-drop-${now}`,\n        timestamp: now,\n        type: 'frame_drop',\n        severity,\n        description: `Low frame rate detected: ${Math.round(fpsPoint.value)} FPS`,\n        recommendation: 'Consider reducing animation complexity or enabling optimizations',\n        relatedMetrics: ['fps', 'cpuTime', 'renderTime'],\n      };\n\n      setDetectedIssues(prev => {\n        // Don't add too many similar issues\n        const recentSimilarIssue = prev.find(\n          issue => issue.type === newIssue.type && now - issue.timestamp < 5000\n        );\n\n        if (recentSimilarIssue) {\n          return prev;\n        }\n\n        return [...prev.slice(-19), newIssue]; // Keep most recent 20 issues\n      });\n    }\n\n    // Check for high CPU usage\n    if (cpuPoint.value > frameBudget) {\n      const overtime = cpuPoint.value - frameBudget;\n      const severity =\n        overtime > 10 ? 'critical' : overtime > 5 ? 'high' : overtime > 2 ? 'medium' : 'low';\n\n      const newIssue: PerformanceIssue = {\n        id: `high-cpu-${now}`,\n        timestamp: now,\n        type: 'high_cpu',\n        severity,\n        description: `High CPU time detected: ${Math.round(cpuPoint.value)}ms (budget: ${frameBudget}ms)`,\n        recommendation: 'Consider using memoization or reducing calculation complexity',\n        relatedMetrics: ['cpuTime', 'fps'],\n      };\n\n      setDetectedIssues(prev => {\n        // Don't add too many similar issues\n        const recentSimilarIssue = prev.find(\n          issue => issue.type === newIssue.type && now - issue.timestamp < 5000\n        );\n\n        if (recentSimilarIssue) {\n          return prev;\n        }\n\n        return [...prev.slice(-19), newIssue]; // Keep most recent 20 issues\n      });\n    }\n\n    // Check for layout thrashing\n    if (layoutPoint.value > 0) {\n      const severity =\n        layoutPoint.value > 3\n          ? 'critical'\n          : layoutPoint.value > 2\n            ? 'high'\n            : layoutPoint.value > 1\n              ? 'medium'\n              : 'low';\n\n      const newIssue: PerformanceIssue = {\n        id: `layout-thrashing-${now}`,\n        timestamp: now,\n        type: 'layout_thrashing',\n        severity,\n        description: `Layout thrashing detected: ${layoutPoint.value} reflows in a single frame`,\n        recommendation: 'Use batched updates to separate read and write operations',\n        relatedMetrics: ['layoutThrashing', 'renderTime', 'fps'],\n      };\n\n      setDetectedIssues(prev => {\n        // Don't add too many similar issues\n        const recentSimilarIssue = prev.find(\n          issue => issue.type === newIssue.type && now - issue.timestamp < 5000\n        );\n\n        if (recentSimilarIssue) {\n          return prev;\n        }\n\n        return [...prev.slice(-19), newIssue]; // Keep most recent 20 issues\n      });\n    }\n  };\n\n  // Update the charts based on current metrics\n  const updateCharts = () => {\n    // These will be implemented with actual D3 visualizations\n    updateFpsChart();\n    updateCpuChart();\n    updateMemoryChart();\n    updateTimelineChart();\n  };\n\n  // Update the FPS chart\n  const updateFpsChart = () => {\n    if (!fpsChartRef.current) return;\n\n    const svg = d3.select(fpsChartRef.current);\n    const data = performanceMetrics.fps;\n    if (data?.length === 0) return;\n\n    // Clear previous chart\n    svg.selectAll('*').remove();\n\n    // Determine dimensions\n    const margin = { top: 10, right: 20, bottom: 30, left: 40 };\n    const chartWidth = svg.node()?.getBoundingClientRect().width ?? 300;\n    const chartHeight = svg.node()?.getBoundingClientRect().height ?? 200;\n    const width = chartWidth - margin.left - margin.right;\n    const height = chartHeight - margin.top - margin.bottom;\n\n    // Create chart group\n    const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);\n\n    // Determine time domain\n    const now = Date.now();\n    const xDomain = [now - timeWindow, now];\n\n    // Create scales\n    const x = d3.scaleTime().domain(xDomain).range([0, width]);\n\n    // Set y-domain based on FPS (0 to max, or at least 60)\n    const maxFps = Math.max(60, d3.max(data, d => d.value) ?? 60);\n    const y = d3\n      .scaleLinear()\n      .domain([0, maxFps * 1.1])\n      .range([height, 0]);\n\n    // Create line generator\n    const line = d3\n      .line<MetricPoint>()\n      .x(d => x(d.timestamp))\n      .y(d => y(d.value))\n      .curve(d3.curveMonotoneX);\n\n    // Add reference line for target FPS (60)\n    g.append('line')\n      .attr('x1', 0)\n      .attr('x2', width)\n      .attr('y1', y(60))\n      .attr('y2', y(60))\n      .attr('stroke', '#aaa')\n      .attr('stroke-dasharray', '3,3')\n      .attr('stroke-width', 1);\n\n    g.append('text')\n      .attr('x', width)\n      .attr('y', y(60) - 5)\n      .attr('text-anchor', 'end')\n      .attr('font-size', '10px')\n      .attr('fill', '#aaa')\n      .text('60 FPS');\n\n    // Add reference line for acceptable FPS (30)\n    g.append('line')\n      .attr('x1', 0)\n      .attr('x2', width)\n      .attr('y1', y(30))\n      .attr('y2', y(30))\n      .attr('stroke', '#ffa000')\n      .attr('stroke-dasharray', '3,3')\n      .attr('stroke-width', 1);\n\n    g.append('text')\n      .attr('x', width)\n      .attr('y', y(30) - 5)\n      .attr('text-anchor', 'end')\n      .attr('font-size', '10px')\n      .attr('fill', '#ffa000')\n      .text('30 FPS');\n\n    // Add problem area (< 30 FPS)\n    g.append('rect')\n      .attr('x', 0)\n      .attr('y', y(0))\n      .attr('width', width)\n      .attr('height', y(30) - y(0))\n      .attr('fill', 'rgba(244, 67, 54, 0.1)');\n\n    // Add axes\n    g.append('g')\n      .attr('transform', `translate(0,${height})`)\n      .call(\n        d3\n          .axisBottom(x)\n          .ticks(5)\n          .tickFormat(d => {\n            const date = new Date(d as number);\n            return date.getSeconds().toString();\n          })\n      )\n      .call(g => g.select('.domain').remove());\n\n    g.append('g')\n      .call(d3.axisLeft(y).ticks(5))\n      .call(g => g.select('.domain').remove());\n\n    // Add grid lines\n    g.append('g')\n      .attr('class', 'grid')\n      .attr('opacity', 0.1)\n      .call(\n        d3\n          .axisLeft(y)\n          .ticks(5)\n          .tickSize(-width)\n          .tickFormat(() => '')\n      );\n\n    // Add the line path\n    g.append('path')\n      .datum(data)\n      .attr('fill', 'none')\n      .attr('stroke', '#2196F3')\n      .attr('stroke-width', 2)\n      .attr('d', line);\n\n    // Add points for the most recent data\n    const recentData = data?.slice(-5); // Last 5 points\n\n    g.selectAll('.data-point')\n      .data(recentData)\n      .enter()\n      .append('circle')\n      .attr('class', 'data-point')\n      .attr('cx', d => x(d.timestamp))\n      .attr('cy', d => y(d.value))\n      .attr('r', (d, i) => (i === recentData.length - 1 ? 4 : 2)) // Larger circle for most recent point\n      .attr('fill', d => {\n        if (d.value < 30) return '#f44336'; // Red\n        if (d.value < 60) return '#ffa000'; // Orange\n        return '#4CAF50'; // Green\n      });\n\n    // Add line for current FPS value\n    if (data?.length > 0) {\n      const lastPoint = data[data?.length - 1];\n\n      g.append('line')\n        .attr('x1', 0)\n        .attr('x2', width)\n        .attr('y1', y(lastPoint.value))\n        .attr('y2', y(lastPoint.value))\n        .attr('stroke', '#2196F3')\n        .attr('stroke-dasharray', '2,2')\n        .attr('stroke-width', 1);\n    }\n  };\n\n  // Update the CPU usage chart\n  const updateCpuChart = () => {\n    if (!cpuChartRef.current) return;\n\n    const svg = d3.select(cpuChartRef.current);\n    const data = performanceMetrics.cpuTime;\n    if (data?.length === 0) return;\n\n    // Clear previous chart\n    svg.selectAll('*').remove();\n\n    // Determine dimensions\n    const margin = { top: 10, right: 20, bottom: 30, left: 40 };\n    const chartWidth = svg.node()?.getBoundingClientRect().width ?? 300;\n    const chartHeight = svg.node()?.getBoundingClientRect().height ?? 200;\n    const width = chartWidth - margin.left - margin.right;\n    const height = chartHeight - margin.top - margin.bottom;\n\n    // Create chart group\n    const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);\n\n    // Determine time domain\n    const now = Date.now();\n    const xDomain = [now - timeWindow, now];\n\n    // Create scales\n    const x = d3.scaleTime().domain(xDomain).range([0, width]);\n\n    // Set y-domain based on data (0 to max, or at least frameBudget*2)\n    const maxCpuTime = Math.max(frameBudget * 2, d3.max(data, d => d.value) ?? frameBudget * 2);\n    const y = d3\n      .scaleLinear()\n      .domain([0, maxCpuTime * 1.1])\n      .range([height, 0]);\n\n    // Create line generator\n    const line = d3\n      .line<MetricPoint>()\n      .x(d => x(d.timestamp))\n      .y(d => y(d.value))\n      .curve(d3.curveMonotoneX);\n\n    // Add budget reference line\n    g.append('line')\n      .attr('x1', 0)\n      .attr('x2', width)\n      .attr('y1', y(frameBudget))\n      .attr('y2', y(frameBudget))\n      .attr('stroke', '#ff9800')\n      .attr('stroke-dasharray', '3,3')\n      .attr('stroke-width', 1);\n\n    g.append('text')\n      .attr('x', width)\n      .attr('y', y(frameBudget) - 5)\n      .attr('text-anchor', 'end')\n      .attr('font-size', '10px')\n      .attr('fill', '#ff9800')\n      .text(`${frameBudget.toFixed(1)}ms`);\n\n    // Add problem area (> frameBudget)\n    g.append('rect')\n      .attr('x', 0)\n      .attr('y', 0)\n      .attr('width', width)\n      .attr('height', y(frameBudget))\n      .attr('fill', 'rgba(244, 67, 54, 0.1)');\n\n    // Add axes\n    g.append('g')\n      .attr('transform', `translate(0,${height})`)\n      .call(\n        d3\n          .axisBottom(x)\n          .ticks(5)\n          .tickFormat(d => {\n            const date = new Date(d as number);\n            return date.getSeconds().toString();\n          })\n      )\n      .call(g => g.select('.domain').remove());\n\n    g.append('g')\n      .call(d3.axisLeft(y).ticks(5))\n      .call(g => g.select('.domain').remove());\n\n    // Add grid lines\n    g.append('g')\n      .attr('class', 'grid')\n      .attr('opacity', 0.1)\n      .call(\n        d3\n          .axisLeft(y)\n          .ticks(5)\n          .tickSize(-width)\n          .tickFormat(() => '')\n      );\n\n    // Add the line path\n    g.append('path')\n      .datum(data)\n      .attr('fill', 'none')\n      .attr('stroke', '#ff5722')\n      .attr('stroke-width', 2)\n      .attr('d', line);\n\n    // Add points for the most recent data\n    const recentData = data?.slice(-5); // Last 5 points\n\n    g.selectAll('.data-point')\n      .data(recentData)\n      .enter()\n      .append('circle')\n      .attr('class', 'data-point')\n      .attr('cx', d => x(d.timestamp))\n      .attr('cy', d => y(d.value))\n      .attr('r', (d, i) => (i === recentData.length - 1 ? 4 : 2)) // Larger circle for most recent point\n      .attr('fill', d => {\n        if (d.value > frameBudget * 1.5) return '#f44336'; // Red\n        if (d.value > frameBudget) return '#ffa000'; // Orange\n        return '#4CAF50'; // Green\n      });\n\n    // Add line for current CPU value\n    if (data?.length > 0) {\n      const lastPoint = data[data?.length - 1];\n\n      g.append('line')\n        .attr('x1', 0)\n        .attr('x2', width)\n        .attr('y1', y(lastPoint.value))\n        .attr('y2', y(lastPoint.value))\n        .attr('stroke', '#ff5722')\n        .attr('stroke-dasharray', '2,2')\n        .attr('stroke-width', 1);\n    }\n  };\n\n  // Update the memory usage chart\n  const updateMemoryChart = () => {\n    if (!memoryChartRef.current) return;\n\n    const svg = d3.select(memoryChartRef.current);\n    const data = performanceMetrics.memoryUsage;\n    if (data?.length === 0) return;\n\n    // Clear previous chart\n    svg.selectAll('*').remove();\n\n    // Determine dimensions\n    const margin = { top: 10, right: 20, bottom: 30, left: 40 };\n    const chartWidth = svg.node()?.getBoundingClientRect().width ?? 300;\n    const chartHeight = svg.node()?.getBoundingClientRect().height ?? 200;\n    const width = chartWidth - margin.left - margin.right;\n    const height = chartHeight - margin.top - margin.bottom;\n\n    // Create chart group\n    const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);\n\n    // Determine time domain\n    const now = Date.now();\n    const xDomain = [now - timeWindow, now];\n\n    // Create scales\n    const x = d3.scaleTime().domain(xDomain).range([0, width]);\n\n    // Find min and max values for better visualization\n    const maxMemory = d3.max(data, d => d.value) ?? 100;\n    const minMemory = d3.min(data, d => d.value) ?? 0;\n    const padding = (maxMemory - minMemory) * 0.1; // 10% padding\n\n    // Use a more precise domain for better visualization\n    const y = d3\n      .scaleLinear()\n      .domain([Math.max(0, minMemory - padding), maxMemory + padding])\n      .range([height, 0]);\n\n    // Create line generator\n    const line = d3\n      .line<MetricPoint>()\n      .x(d => x(d.timestamp))\n      .y(d => y(d.value))\n      .curve(d3.curveMonotoneX);\n\n    // Create area generator for filled area under the line\n    const area = d3\n      .area<MetricPoint>()\n      .x(d => x(d.timestamp))\n      .y0(height)\n      .y1(d => y(d.value))\n      .curve(d3.curveMonotoneX);\n\n    // Add axes\n    g.append('g')\n      .attr('transform', `translate(0,${height})`)\n      .call(\n        d3\n          .axisBottom(x)\n          .ticks(5)\n          .tickFormat(d => {\n            const date = new Date(d as number);\n            return date.getSeconds().toString();\n          })\n      )\n      .call(g => g.select('.domain').remove());\n\n    g.append('g')\n      .call(d3.axisLeft(y).ticks(5))\n      .call(g => g.select('.domain').remove());\n\n    // Add grid lines\n    g.append('g')\n      .attr('class', 'grid')\n      .attr('opacity', 0.1)\n      .call(\n        d3\n          .axisLeft(y)\n          .ticks(5)\n          .tickSize(-width)\n          .tickFormat(() => '')\n      );\n\n    // Add the area\n    g.append('path').datum(data).attr('fill', 'rgba(76, 175, 80, 0.2)').attr('d', area);\n\n    // Add the line path\n    g.append('path')\n      .datum(data)\n      .attr('fill', 'none')\n      .attr('stroke', '#4CAF50')\n      .attr('stroke-width', 2)\n      .attr('d', line);\n\n    // Add points for the most recent data\n    const recentData = data?.slice(-5); // Last 5 points\n\n    g.selectAll('.data-point')\n      .data(recentData)\n      .enter()\n      .append('circle')\n      .attr('class', 'data-point')\n      .attr('cx', d => x(d.timestamp))\n      .attr('cy', d => y(d.value))\n      .attr('r', (d, i) => (i === recentData.length - 1 ? 4 : 2)) // Larger circle for most recent point\n      .attr('fill', '#4CAF50');\n\n    // Add line for current memory value\n    if (data?.length > 0) {\n      const lastPoint = data[data?.length - 1];\n\n      g.append('line')\n        .attr('x1', 0)\n        .attr('x2', width)\n        .attr('y1', y(lastPoint.value))\n        .attr('y2', y(lastPoint.value))\n        .attr('stroke', '#4CAF50')\n        .attr('stroke-dasharray', '2,2')\n        .attr('stroke-width', 1);\n    }\n  };\n\n  // Update the timeline chart\n  const updateTimelineChart = () => {\n    if (!timelineChartRef.current) return;\n\n    const svg = d3.select(timelineChartRef.current);\n\n    // Clear previous chart\n    svg.selectAll('*').remove();\n\n    // Get data for the selected metric\n    const data = performanceMetrics[selectedMetric];\n    if (data?.length === 0) return;\n\n    // Determine dimensions\n    const margin = { top: 10, right: 20, bottom: 30, left: 40 };\n    const chartWidth = svg.node()?.getBoundingClientRect().width ?? 600;\n    const chartHeight = svg.node()?.getBoundingClientRect().height ?? 100;\n    const width = chartWidth - margin.left - margin.right;\n    const height = chartHeight - margin.top - margin.bottom;\n\n    // Create chart group\n    const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);\n\n    // Determine time domain\n    const now = Date.now();\n    const xDomain = [now - timeWindow, now];\n\n    // Create scales\n    const x = d3.scaleTime().domain(xDomain).range([0, width]);\n\n    // Set y-domain based on the selected metric\n    let yDomain: [number, number];\n    let colorScale: d3.ScaleOrdinal<string, string>;\n\n    // Configure scales and thresholds based on metric type\n    let maxValue: number;\n    let minValue: number;\n    let padding: number;\n\n    switch (selectedMetric) {\n      case 'fps':\n        yDomain = [0, Math.max(60, d3.max(data, d => d.value) ?? 60) * 1.1];\n        colorScale = d3\n          .scaleOrdinal<string>()\n          .domain(['low', 'medium', 'high'])\n          .range(['#f44336', '#ffa000', '#4CAF50']);\n        break;\n\n      case 'cpuTime':\n        yDomain = [\n          0,\n          Math.max(frameBudget * 2, d3.max(data, d => d.value) ?? frameBudget * 2) * 1.1,\n        ];\n        colorScale = d3\n          .scaleOrdinal<string>()\n          .domain(['low', 'medium', 'high'])\n          .range(['#4CAF50', '#ffa000', '#f44336']);\n        break;\n\n      case 'layoutThrashing':\n        yDomain = [0, Math.max(5, d3.max(data, d => d.value) ?? 5) * 1.1];\n        colorScale = d3\n          .scaleOrdinal<string>()\n          .domain(['low', 'medium', 'high'])\n          .range(['#4CAF50', '#ffa000', '#f44336']);\n        break;\n\n      case 'cacheHitRate':\n        yDomain = [0, 100];\n        colorScale = d3\n          .scaleOrdinal<string>()\n          .domain(['low', 'medium', 'high'])\n          .range(['#f44336', '#ffa000', '#4CAF50']);\n        break;\n\n      case 'animationSmoothness':\n        yDomain = [0, 100];\n        colorScale = d3\n          .scaleOrdinal<string>()\n          .domain(['low', 'medium', 'high'])\n          .range(['#f44336', '#ffa000', '#4CAF50']);\n        break;\n\n      default:\n        // For other metrics, use the min/max of data with padding\n        maxValue = d3.max(data, d => d.value) ?? 100;\n        minValue = d3.min(data, d => d.value) ?? 0;\n        padding = (maxValue - minValue) * 0.1;\n        yDomain = [Math.max(0, minValue - padding), maxValue + padding];\n        colorScale = d3\n          .scaleOrdinal<string>()\n          .domain(['low', 'medium', 'high'])\n          .range(['#f44336', '#ffa000', '#4CAF50']);\n    }\n\n    const y = d3.scaleLinear().domain(yDomain).range([height, 0]);\n\n    // Create line generator\n    const line = d3\n      .line<MetricPoint>()\n      .x(d => x(d.timestamp))\n      .y(d => y(d.value))\n      .curve(d3.curveMonotoneX);\n\n    // Create area generator for filled area under the line\n    const area = d3\n      .area<MetricPoint>()\n      .x(d => x(d.timestamp))\n      .y0(height)\n      .y1(d => y(d.value))\n      .curve(d3.curveMonotoneX);\n\n    // Add reference lines based on metric type\n    if (selectedMetric === 'fps') {\n      // FPS reference lines\n      g.append('line')\n        .attr('x1', 0)\n        .attr('x2', width)\n        .attr('y1', y(60))\n        .attr('y2', y(60))\n        .attr('stroke', '#aaa')\n        .attr('stroke-dasharray', '3,3')\n        .attr('stroke-width', 1);\n\n      g.append('text')\n        .attr('x', 5)\n        .attr('y', y(60) - 5)\n        .attr('font-size', '10px')\n        .attr('fill', '#aaa')\n        .text('60 FPS');\n\n      g.append('line')\n        .attr('x1', 0)\n        .attr('x2', width)\n        .attr('y1', y(30))\n        .attr('y2', y(30))\n        .attr('stroke', '#ffa000')\n        .attr('stroke-dasharray', '3,3')\n        .attr('stroke-width', 1);\n\n      g.append('text')\n        .attr('x', 5)\n        .attr('y', y(30) - 5)\n        .attr('font-size', '10px')\n        .attr('fill', '#ffa000')\n        .text('30 FPS');\n    } else if (selectedMetric === 'cpuTime') {\n      // CPU time reference line\n      g.append('line')\n        .attr('x1', 0)\n        .attr('x2', width)\n        .attr('y1', y(frameBudget))\n        .attr('y2', y(frameBudget))\n        .attr('stroke', '#ff9800')\n        .attr('stroke-dasharray', '3,3')\n        .attr('stroke-width', 1);\n\n      g.append('text')\n        .attr('x', 5)\n        .attr('y', y(frameBudget) - 5)\n        .attr('font-size', '10px')\n        .attr('fill', '#ff9800')\n        .text(`${frameBudget.toFixed(1)}ms`);\n    }\n\n    // Add axes\n    g.append('g')\n      .attr('transform', `translate(0,${height})`)\n      .call(\n        d3\n          .axisBottom(x)\n          .ticks(10)\n          .tickFormat(d => {\n            const date = new Date(d as number);\n            return `${date.getMinutes()}:${date.getSeconds().toString().padStart(2, '0')}`;\n          })\n      )\n      .call(g => g.select('.domain').remove());\n\n    g.append('g')\n      .call(d3.axisLeft(y).ticks(5))\n      .call(g => g.select('.domain').remove());\n\n    // Add grid lines\n    g.append('g')\n      .attr('class', 'grid')\n      .attr('opacity', 0.1)\n      .call(\n        d3\n          .axisLeft(y)\n          .ticks(5)\n          .tickSize(-width)\n          .tickFormat(() => '')\n      );\n\n    // Add problem areas with colored backgrounds based on metric type\n    if (selectedMetric === 'fps') {\n      // Red area for FPS < 30\n      g.append('rect')\n        .attr('x', 0)\n        .attr('y', y(0))\n        .attr('width', width)\n        .attr('height', y(30) - y(0))\n        .attr('fill', 'rgba(244, 67, 54, 0.1)');\n\n      // Yellow area for 30 <= FPS < 60\n      g.append('rect')\n        .attr('x', 0)\n        .attr('y', y(30))\n        .attr('width', width)\n        .attr('height', y(60) - y(30))\n        .attr('fill', 'rgba(255, 160, 0, 0.1)');\n    } else if (selectedMetric === 'cpuTime') {\n      // Red area for CPU > frameBudget\n      g.append('rect')\n        .attr('x', 0)\n        .attr('y', 0)\n        .attr('width', width)\n        .attr('height', y(frameBudget))\n        .attr('fill', 'rgba(244, 67, 54, 0.1)');\n    }\n\n    // Plot detected issues on the timeline\n    const relatedIssues = detectedIssues.filter(issue =>\n      issue.relatedMetrics.includes(selectedMetric)\n    );\n\n    g.selectAll('.issue-marker')\n      .data(relatedIssues)\n      .enter()\n      .append('circle')\n      .attr('class', 'issue-marker')\n      .attr('cx', d => x(d.timestamp))\n      .attr('cy', 10) // Fixed position at the top\n      .attr('r', 5)\n      .attr('fill', d => getSeverityColor(d.severity))\n      .attr('stroke', '#fff')\n      .attr('stroke-width', 1)\n      .style('cursor', 'pointer')\n      .append('title')\n      .text(d => `${d.description} (${formatTimestamp(d.timestamp)})`);\n\n    // Add the area under the line\n    const areaColor =\n      selectedMetric === 'fps'\n        ? 'rgba(33, 150, 243, 0.2)'\n        : selectedMetric === 'cpuTime'\n          ? 'rgba(255, 87, 34, 0.2)'\n          : 'rgba(76, 175, 80, 0.2)';\n\n    g.append('path').datum(data).attr('fill', areaColor).attr('d', area);\n\n    // Add the line path with appropriate color\n    const lineColor =\n      selectedMetric === 'fps' ? '#2196F3' : selectedMetric === 'cpuTime' ? '#ff5722' : '#4CAF50';\n\n    g.append('path')\n      .datum(data)\n      .attr('fill', 'none')\n      .attr('stroke', lineColor)\n      .attr('stroke-width', 2)\n      .attr('d', line);\n\n    // Add points for the recent data\n    const recentData = data?.slice(-10); // Last 10 points\n\n    g.selectAll('.data-point')\n      .data(recentData)\n      .enter()\n      .append('circle')\n      .attr('class', 'data-point')\n      .attr('cx', d => x(d.timestamp))\n      .attr('cy', d => y(d.value))\n      .attr('r', (d, i) => (i === recentData.length - 1 ? 4 : 2)) // Larger circle for most recent point\n      .attr('fill', d => {\n        // Color based on metric type and value\n        if (selectedMetric === 'fps') {\n          if (d.value < 30) return '#f44336'; // Red\n          if (d.value < 60) return '#ffa000'; // Orange\n          return '#4CAF50'; // Green\n        } else if (selectedMetric === 'cpuTime') {\n          if (d.value > frameBudget * 1.5) return '#f44336'; // Red\n          if (d.value > frameBudget) return '#ffa000'; // Orange\n          return '#4CAF50'; // Green\n        } else if (selectedMetric === 'cacheHitRate' || selectedMetric === 'animationSmoothness') {\n          if (d.value < 50) return '#f44336'; // Red\n          if (d.value < 80) return '#ffa000'; // Orange\n          return '#4CAF50'; // Green\n        }\n        return lineColor;\n      });\n\n    // Add a vertical line for the current time\n    g.append('line')\n      .attr('x1', x(now))\n      .attr('x2', x(now))\n      .attr('y1', 0)\n      .attr('y2', height)\n      .attr('stroke', '#757575')\n      .attr('stroke-width', 1)\n      .attr('stroke-dasharray', '5,3');\n\n    // Add tooltip interaction\n    const tooltip = d3\n      .select('body')\n      .append('div')\n      .attr('class', 'performance-tooltip')\n      .style('position', 'absolute')\n      .style('visibility', 'hidden')\n      .style('background', 'rgba(0, 0, 0, 0.8)')\n      .style('color', 'white')\n      .style('padding', '5px 10px')\n      .style('border-radius', '4px')\n      .style('font-size', '12px')\n      .style('pointer-events', 'none');\n\n    g.selectAll('.data-point')\n      .on('mouseover', function (event: MouseEvent, d: unknown) {\n        const dataPoint = d as MetricPoint;\n        tooltip.style('visibility', 'visible').html(`\n            <div>Time: ${formatTimestamp(dataPoint.timestamp)}</div>\n            <div>Value: ${dataPoint.value.toFixed(1)}</div>\n          `);\n      })\n      .on('mousemove', function (event: MouseEvent) {\n        tooltip.style('top', event?.pageY - 10 + 'px').style('left', event?.pageX + 10 + 'px');\n      })\n      .on('mouseout', function () {\n        tooltip.style('visibility', 'hidden');\n      });\n  };\n\n  // Handle animation selection\n  const handleAnimationSelect = (animationId: string) => {\n    setMonitoredAnimation(animationId);\n    setIsMonitoring(true);\n  };\n\n  // Handle time window change\n  const handleTimeWindowChange = (windowMs: number) => {\n    setTimeWindow(windowMs);\n  };\n\n  // Handle metric selection\n  const handleMetricSelect = (metric: keyof PerformanceMetrics) => {\n    setSelectedMetric(metric);\n  };\n\n  // Export performance data\n  const exportPerformanceData = () => {\n    const dataStr = JSON.stringify(performanceMetrics, null, 2);\n    const dataUri = `data:application/json;charset=utf-8,${encodeURIComponent(dataStr)}`;\n\n    const exportFileName = `performance-data-${new Date().toISOString()}.json`;\n\n    const linkElement = document.createElement('a');\n    linkElement.setAttribute('href', dataUri);\n    linkElement.setAttribute('download', exportFileName);\n    linkElement.click();\n  };\n\n  // Format timestamp for display\n  const formatTimestamp = (timestamp: number) => {\n    const date = new Date(timestamp);\n    return date.toLocaleTimeString();\n  };\n\n  // Get severity color\n  const getSeverityColor = (severity: PerformanceIssue['severity']) => {\n    switch (severity) {\n      case 'critical':\n        return '#d32f2f';\n      case 'high':\n        return '#f57c00';\n      case 'medium':\n        return '#ffa000';\n      case 'low':\n        return '#7cb342';\n      default:\n        return '#999';\n    }\n  };\n\n  return (\n    <div\n      className=\"performance-monitoring-dashboard\"\n      ref={containerRef}\n      style={{\n        width,\n        height,\n        fontFamily: 'Arial, sans-serif',\n        display: 'flex',\n        flexDirection: 'column',\n      }}\n    >\n      <div\n        className=\"dashboard-header\"\n        style={{\n          padding: '1rem',\n          backgroundColor: '#f5f5f5',\n          borderBottom: '1px solid #ddd',\n        }}\n      >\n        <h1 style={{ margin: 0, fontSize: '1.5rem' }}>Performance Monitoring Dashboard</h1>\n        <p>Real-time visualization performance metrics and analysis</p>\n\n        <div\n          className=\"dashboard-controls\"\n          style={{\n            display: 'flex',\n            gap: '1rem',\n            marginTop: '0.5rem',\n            flexWrap: 'wrap',\n          }}\n        >\n          <div>\n            <label htmlFor=\"animation-select\" style={{ marginRight: '0.5rem' }}>\n              Monitor Animation:\n            </label>\n            <select\n              id=\"animation-select\"\n              value={monitoredAnimation}\n              onChange={e => handleAnimationSelect(e.target.value)}\n              style={{ padding: '0.25rem' }}\n            >\n              <option value=\"\">Select Animation</option>\n              {activeAnimations.map(id => (\n                <option key={id} value={id}>\n                  {id}\n                </option>\n              ))}\n            </select>\n          </div>\n\n          <div>\n            <label htmlFor=\"time-window\" style={{ marginRight: '0.5rem' }}>\n              Time Window:\n            </label>\n            <select\n              id=\"time-window\"\n              value={timeWindow}\n              onChange={e => handleTimeWindowChange(parseInt(e.target.value))}\n              style={{ padding: '0.25rem' }}\n            >\n              <option value=\"10000\">10 seconds</option>\n              <option value=\"30000\">30 seconds</option>\n              <option value=\"60000\">1 minute</option>\n              <option value=\"300000\">5 minutes</option>\n            </select>\n          </div>\n\n          <div>\n            <label htmlFor=\"metric-select\" style={{ marginRight: '0.5rem' }}>\n              Primary Metric:\n            </label>\n            <select\n              id=\"metric-select\"\n              value={selectedMetric}\n              onChange={e => handleMetricSelect(e.target.value as keyof PerformanceMetrics)}\n              style={{ padding: '0.25rem' }}\n            >\n              <option value=\"fps\">FPS</option>\n              <option value=\"cpuTime\">CPU Time</option>\n              <option value=\"memoryUsage\">Memory Usage</option>\n              <option value=\"domOperations\">DOM Operations</option>\n              <option value=\"renderTime\">Render Time</option>\n              <option value=\"layoutThrashing\">Layout Thrashing</option>\n              <option value=\"cacheHitRate\">Cache Hit Rate</option>\n              <option value=\"animationSmoothness\">Animation Smoothness</option>\n            </select>\n          </div>\n\n          <button\n            onClick={() => setIsMonitoring(!isMonitoring)}\n            style={{\n              padding: '0.5rem 1rem',\n              backgroundColor: isMonitoring ? '#f44336' : '#4CAF50',\n              color: 'white',\n              border: 'none',\n              borderRadius: '4px',\n              cursor: 'pointer',\n            }}\n          >\n            {isMonitoring ? 'Stop Monitoring' : 'Start Monitoring'}\n          </button>\n\n          <button\n            onClick={exportPerformanceData}\n            style={{\n              padding: '0.5rem 1rem',\n              backgroundColor: '#2196F3',\n              color: 'white',\n              border: 'none',\n              borderRadius: '4px',\n              cursor: 'pointer',\n            }}\n            disabled={performanceMetrics.fps.length === 0}\n          >\n            Export Data\n          </button>\n        </div>\n      </div>\n\n      <div\n        className=\"dashboard-main\"\n        style={{\n          flex: 1,\n          display: 'grid',\n          gridTemplateColumns: '1fr 1fr',\n          gridTemplateRows: '1fr 1fr',\n          gap: '1rem',\n          padding: '1rem',\n          overflow: 'hidden',\n        }}\n      >\n        <div\n          className=\"metric-panel fps-panel\"\n          style={{\n            gridColumn: '1',\n            gridRow: '1',\n            backgroundColor: 'white',\n            boxShadow: '0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24)',\n            borderRadius: '4px',\n            padding: '1rem',\n            display: 'flex',\n            flexDirection: 'column',\n            overflow: 'hidden',\n          }}\n        >\n          <h2 style={{ margin: '0 0 0.5rem 0', fontSize: '1.2rem' }}>FPS</h2>\n          <div className=\"current-value\" style={{ fontSize: '2rem', fontWeight: 'bold' }}>\n            {performanceMetrics.fps.length > 0\n              ? Math.round(performanceMetrics.fps[performanceMetrics.fps.length - 1].value)\n              : '-'}\n          </div>\n          <div className=\"chart-container\" style={{ flex: 1, minHeight: 0 }}>\n            <svg ref={fpsChartRef} width=\"100%\" height=\"100%\"></svg>\n          </div>\n        </div>\n\n        <div\n          className=\"metric-panel cpu-panel\"\n          style={{\n            gridColumn: '2',\n            gridRow: '1',\n            backgroundColor: 'white',\n            boxShadow: '0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24)',\n            borderRadius: '4px',\n            padding: '1rem',\n            display: 'flex',\n            flexDirection: 'column',\n            overflow: 'hidden',\n          }}\n        >\n          <h2 style={{ margin: '0 0 0.5rem 0', fontSize: '1.2rem' }}>CPU Time (ms)</h2>\n          <div className=\"current-value\" style={{ fontSize: '2rem', fontWeight: 'bold' }}>\n            {performanceMetrics.cpuTime.length > 0\n              ? performanceMetrics.cpuTime[performanceMetrics.cpuTime.length - 1].value.toFixed(1)\n              : '-'}\n          </div>\n          <div className=\"chart-container\" style={{ flex: 1, minHeight: 0 }}>\n            <svg ref={cpuChartRef} width=\"100%\" height=\"100%\"></svg>\n          </div>\n        </div>\n\n        <div\n          className=\"metric-panel memory-panel\"\n          style={{\n            gridColumn: '1',\n            gridRow: '2',\n            backgroundColor: 'white',\n            boxShadow: '0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24)',\n            borderRadius: '4px',\n            padding: '1rem',\n            display: 'flex',\n            flexDirection: 'column',\n            overflow: 'hidden',\n          }}\n        >\n          <h2 style={{ margin: '0 0 0.5rem 0', fontSize: '1.2rem' }}>Memory Usage (MB)</h2>\n          <div className=\"current-value\" style={{ fontSize: '2rem', fontWeight: 'bold' }}>\n            {performanceMetrics.memoryUsage.length > 0\n              ? performanceMetrics.memoryUsage[\n                  performanceMetrics.memoryUsage.length - 1\n                ].value.toFixed(1)\n              : '-'}\n          </div>\n          <div className=\"chart-container\" style={{ flex: 1, minHeight: 0 }}>\n            <svg ref={memoryChartRef} width=\"100%\" height=\"100%\"></svg>\n          </div>\n        </div>\n\n        <div\n          className=\"issues-panel\"\n          style={{\n            gridColumn: '2',\n            gridRow: '2',\n            backgroundColor: 'white',\n            boxShadow: '0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24)',\n            borderRadius: '4px',\n            padding: '1rem',\n            overflow: 'auto',\n          }}\n        >\n          <h2 style={{ margin: '0 0 0.5rem 0', fontSize: '1.2rem' }}>Detected Issues</h2>\n\n          {detectedIssues.length > 0 ? (\n            <ul style={{ listStyle: 'none', padding: 0, margin: 0 }}>\n              {detectedIssues\n                .slice()\n                .reverse()\n                .map(issue => (\n                  <li\n                    key={issue.id}\n                    style={{\n                      padding: '0.5rem',\n                      borderLeft: `4px solid ${getSeverityColor(issue.severity)}`,\n                      marginBottom: '0.5rem',\n                      backgroundColor: '#f9f9f9',\n                    }}\n                  >\n                    <div\n                      style={{\n                        display: 'flex',\n                        justifyContent: 'space-between',\n                        marginBottom: '0.25rem',\n                      }}\n                    >\n                      <strong>\n                        {issue.type.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase())}\n                      </strong>\n                      <span style={{ color: '#666', fontSize: '0.8rem' }}>\n                        {formatTimestamp(issue.timestamp)}\n                      </span>\n                    </div>\n                    <div>{issue.description}</div>\n                    <div style={{ marginTop: '0.25rem', fontSize: '0.9rem', color: '#333' }}>\n                      Recommendation: {issue.recommendation}\n                    </div>\n                  </li>\n                ))}\n            </ul>\n          ) : (\n            <div style={{ color: '#666', fontStyle: 'italic' }}>\n              {isMonitoring ? 'No issues detected yet' : 'Start monitoring to detect issues'}\n            </div>\n          )}\n        </div>\n      </div>\n\n      <div\n        className=\"timeline-container\"\n        style={{\n          height: '150px',\n          backgroundColor: 'white',\n          boxShadow: '0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24)',\n          borderRadius: '4px',\n          margin: '0 1rem 1rem',\n          padding: '1rem',\n          overflow: 'hidden',\n        }}\n      >\n        <h2 style={{ margin: '0 0 0.5rem 0', fontSize: '1.2rem' }}>Performance Timeline</h2>\n        <div style={{ height: 'calc(100% - 2rem)' }}>\n          <svg ref={timelineChartRef} width=\"100%\" height=\"100%\"></svg>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default PerformanceMonitoringDashboard;\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/status/StatusEffect.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/tech/TechVisualFeedback.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'activeNodes' is assigned a value but never used. Allowed unused elements of array destructuring must match /^_/u.","line":203,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":203,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'totalTime' is defined but never used.","line":640,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":640,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'techTreeManager' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":752,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":752,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @context: tech-system.visualization, ui-system\n * Enhanced visual feedback component for the tech tree system\n */\n\nimport { AnimatePresence, motion } from 'framer-motion';\nimport { useEffect, useRef, useState } from 'react';\nimport { TechNode, TechPath } from '../../../managers/game/techTreeManager';\nimport { getTechTreeManager } from '../../../managers/ManagerRegistry';\nimport { cn } from '../../../utils/cn';\n\n// Types for the visual feedback component\ninterface TechVisualFeedbackProps {\n  node: TechNode;\n  isSelected: boolean;\n  isAvailable: boolean;\n  onNodeClick: (node: TechNode) => void;\n  connections?: Connection[];\n  showDetails?: boolean;\n  showResearchProgress?: boolean;\n  showSynergies?: boolean;\n  showPath?: boolean;\n}\n\ninterface Connection {\n  from: string;\n  to: string;\n  status: 'locked' | 'available' | 'unlocked';\n}\n\ninterface SynergyVisualizationProps {\n  sourceNodeId: string;\n  targetNodeId: string;\n  strength: number;\n}\n\n// Icons for different tech categories\nconst categoryIcons = {\n  infrastructure: (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"currentColor\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      className=\"h-4 w-4\"\n    >\n      <path d=\"M2 22h20\"></path>\n      <path d=\"M6 18v4\"></path>\n      <path d=\"M18 18v4\"></path>\n      <path d=\"M6 14v4\"></path>\n      <path d=\"M18 14v4\"></path>\n      <rect x=\"8\" y=\"6\" width=\"8\" height=\"8\"></rect>\n      <path d=\"M2 6h20\"></path>\n      <path d=\"M2 10h20\"></path>\n    </svg>\n  ),\n  warFleet: (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"currentColor\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      className=\"h-4 w-4\"\n    >\n      <path d=\"M2 22h20\"></path>\n      <path d=\"M12 2v20\"></path>\n      <path d=\"M2 10h20\"></path>\n      <path d=\"M18 6 4 18\"></path>\n      <path d=\"M4 6 18 18\"></path>\n    </svg>\n  ),\n  reconFleet: (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"currentColor\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      className=\"h-4 w-4\"\n    >\n      <circle cx=\"12\" cy=\"12\" r=\"8\"></circle>\n      <line x1=\"12\" y1=\"4\" x2=\"12\" y2=\"8\"></line>\n      <line x1=\"12\" y1=\"16\" x2=\"12\" y2=\"20\"></line>\n      <line x1=\"4\" y1=\"12\" x2=\"8\" y2=\"12\"></line>\n      <line x1=\"16\" y1=\"12\" x2=\"20\" y2=\"12\"></line>\n    </svg>\n  ),\n  miningFleet: (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"currentColor\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      className=\"h-4 w-4\"\n    >\n      <path d=\"M2 12h20\"></path>\n      <path d=\"M2 4h20\"></path>\n      <path d=\"M2 20h20\"></path>\n      <path d=\"M12 2v20\"></path>\n      <path d=\"M8 6V18\"></path>\n      <path d=\"M16 6V18\"></path>\n    </svg>\n  ),\n  weapons: (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"currentColor\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      className=\"h-4 w-4\"\n    >\n      <line x1=\"3\" y1=\"10\" x2=\"21\" y2=\"10\"></line>\n      <line x1=\"3\" y1=\"14\" x2=\"21\" y2=\"14\"></line>\n      <line x1=\"3\" y1=\"18\" x2=\"21\" y2=\"18\"></line>\n      <line x1=\"3\" y1=\"6\" x2=\"21\" y2=\"6\"></line>\n    </svg>\n  ),\n  defense: (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"currentColor\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      className=\"h-4 w-4\"\n    >\n      <path d=\"M12 22s8-4 8-10V4l-8-2-8 2v8c0 6 8 10 8 10z\"></path>\n    </svg>\n  ),\n  special: (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"currentColor\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      className=\"h-4 w-4\"\n    >\n      <path d=\"M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14l-5-4.87 6.91-1.01L12 2z\"></path>\n    </svg>\n  ),\n  synergy: (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"currentColor\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      className=\"h-4 w-4\"\n    >\n      <circle cx=\"12\" cy=\"12\" r=\"10\"></circle>\n      <circle cx=\"12\" cy=\"12\" r=\"4\"></circle>\n      <line x1=\"4.93\" y1=\"4.93\" x2=\"9.17\" y2=\"9.17\"></line>\n      <line x1=\"14.83\" y1=\"14.83\" x2=\"19.07\" y2=\"19.07\"></line>\n      <line x1=\"14.83\" y1=\"9.17\" x2=\"19.07\" y2=\"4.93\"></line>\n      <line x1=\"14.83\" y1=\"9.17\" x2=\"18.36\" y2=\"5.64\"></line>\n      <line x1=\"4.93\" y1=\"19.07\" x2=\"9.17\" y2=\"14.83\"></line>\n    </svg>\n  ),\n};\n\n/**\n * @context: tech-system.visualization, ui-system\n * Enhanced visual feedback component for a single tech node\n */\nexport function TechVisualFeedback({\n  node,\n  isSelected,\n  isAvailable,\n  onNodeClick,\n  connections = [],\n  showDetails = false,\n  showResearchProgress = true,\n  showSynergies = true,\n  showPath = false,\n}: TechVisualFeedbackProps) {\n  const nodeRef = useRef<HTMLDivElement>(null);\n  const [hovered, setHovered] = useState(false);\n  const [nodePosition, setNodePosition] = useState({ x: 0, y: 0 });\n  const [researchActive, setResearchActive] = useState(false);\n  const [researchProgress, setResearchProgress] = useState(0);\n  const [remainingTime, setRemainingTime] = useState(0);\n  const [activeNodes, setActiveNodes] = useState<string[]>([]);\n  const [techPath, setTechPath] = useState<TechPath | null>(null);\n  const [synergies, setSynergies] = useState<SynergyVisualizationProps[]>([]);\n  const techTreeManager = getTechTreeManager();\n  \n  // Calculate node position for connections\n  useEffect(() => {\n    if (nodeRef.current) {\n      const rect = nodeRef.current.getBoundingClientRect();\n      const x = rect.left + rect.width / 2;\n      const y = rect.top + rect.height / 2;\n      setNodePosition({ x, y });\n    }\n  }, [nodeRef.current, isSelected]);\n  \n  // Set up research progress tracking\n  useEffect(() => {\n    const techTreeManager = getTechTreeManager();\n    \n    // Check if this node is being researched\n    const activeResearch = techTreeManager.getActiveResearch();\n    const researchData = activeResearch.get(node.id);\n    \n    if (researchData) {\n      setResearchActive(true);\n      setResearchProgress(researchData.progress);\n      setRemainingTime(researchData.remainingTime);\n    } else {\n      setResearchActive(false);\n      setResearchProgress(node.researchProgress || 0);\n    }\n    \n    // Subscribe to research progress events\n    const handleResearchProgress = (data: { nodeId: string; progress: number; remainingTime: number }) => {\n      if (data.nodeId === node.id) {\n        setResearchActive(true);\n        setResearchProgress(data.progress);\n        setRemainingTime(data.remainingTime);\n      }\n    };\n    \n    const handleResearchCompleted = (data: { nodeId: string }) => {\n      if (data.nodeId === node.id) {\n        setResearchActive(false);\n        setResearchProgress(1);\n      }\n    };\n    \n    techTreeManager.on('researchProgress', handleResearchProgress);\n    techTreeManager.on('researchCompleted', handleResearchCompleted);\n    \n    return () => {\n      techTreeManager.off('researchProgress', handleResearchProgress);\n      techTreeManager.off('researchCompleted', handleResearchCompleted);\n    };\n  }, [node.id]);\n  \n  // Get synergy information\n  useEffect(() => {\n    if (showSynergies) {\n      const techTreeManager = getTechTreeManager();\n      const activeSynergies = techTreeManager.getActiveSynergies();\n      \n      const nodeSynergies: SynergyVisualizationProps[] = [];\n      \n      activeSynergies.forEach((strength, synergyPair) => {\n        const [sourceId, targetId] = synergyPair.split('-');\n        \n        if (sourceId === node.id || targetId === node.id) {\n          nodeSynergies.push({\n            sourceNodeId: sourceId,\n            targetNodeId: targetId,\n            strength,\n          });\n        }\n      });\n      \n      setSynergies(nodeSynergies);\n    }\n  }, [node.id, showSynergies]);\n  \n  // Get path planning information\n  useEffect(() => {\n    if (showPath && isSelected && !node.unlocked) {\n      const techTreeManager = getTechTreeManager();\n      const path = techTreeManager.findOptimalPath(node.id);\n      setTechPath(path);\n      \n      if (path) {\n        setActiveNodes(path.nodes);\n      }\n    } else {\n      setTechPath(null);\n      setActiveNodes([]);\n    }\n  }, [node.id, isSelected, node.unlocked, showPath]);\n\n  const getNodeColor = () => {\n    if (node.unlocked) {\n      return 'bg-gradient-to-br from-green-400 to-green-700';\n    }\n    \n    if (researchActive) {\n      return 'bg-gradient-to-br from-yellow-400 to-yellow-600';\n    }\n    \n    if (isAvailable) {\n      return 'bg-gradient-to-br from-blue-400 to-blue-700';\n    }\n    \n    if (techPath && techPath.nodes.includes(node.id)) {\n      return 'bg-gradient-to-br from-purple-400 to-purple-700';\n    }\n    \n    return 'bg-gradient-to-br from-gray-400 to-gray-700';\n  };\n\n  const getIconColor = () => {\n    if (node.unlocked) return 'text-green-200';\n    if (researchActive) return 'text-yellow-200';\n    if (isAvailable) return 'text-blue-200';\n    return 'text-gray-400';\n  };\n\n  const renderConnections = () => {\n    return connections.map((connection, index) => {\n      // Skip rendering connections that aren't related to this node\n      if (connection.from !== node.id && connection.to !== node.id) {\n        return null;\n      }\n\n      // Find the other node to calculate position\n      const otherNodeId = connection.from === node.id ? connection.to : connection.from;\n      const otherNodeElement = document.querySelector(`[data-node-id=\"${otherNodeId}\"]`);\n\n      if (!otherNodeElement) {\n        return null;\n      }\n\n      const rect = otherNodeElement.getBoundingClientRect();\n      const otherNodePosition = {\n        x: rect.left + rect.width / 2,\n        y: rect.top + rect.height / 2,\n      };\n\n      // Determine source and target based on connection direction\n      const source = connection.from === node.id ? nodePosition : otherNodePosition;\n      const target = connection.from === node.id ? otherNodePosition : nodePosition;\n\n      // Calculate progress based on research if applicable\n      let progress = 1;\n      if (connection.status === 'available' && showResearchProgress) {\n        // If the source is being researched, use that progress\n        if (connection.from === node.id && researchActive) {\n          progress = researchProgress;\n        }\n      }\n\n      return (\n        <TechConnectionLine\n          key={`connection-${index}`}\n          from={source}\n          to={target}\n          status={connection.status}\n          progress={progress}\n        />\n      );\n    });\n  };\n  \n  const renderSynergies = () => {\n    if (!showSynergies || synergies.length === 0) {\n      return null;\n    }\n    \n    return (\n      <div className=\"absolute inset-0 pointer-events-none\">\n        {synergies.map((synergy, index) => {\n          // Find the other node\n          const otherNodeId = synergy.sourceNodeId === node.id ? synergy.targetNodeId : synergy.sourceNodeId;\n          const otherNodeElement = document.querySelector(`[data-node-id=\"${otherNodeId}\"]`);\n          \n          if (!otherNodeElement) {\n            return null;\n          }\n          \n          const rect = otherNodeElement.getBoundingClientRect();\n          const otherNodePosition = {\n            x: rect.left + rect.width / 2,\n            y: rect.top + rect.height / 2,\n          };\n          \n          // Draw synergy line\n          return (\n            <SynergyLine \n              key={`synergy-${index}`}\n              from={nodePosition}\n              to={otherNodePosition}\n              strength={synergy.strength}\n            />\n          );\n        })}\n      </div>\n    );\n  };\n  \n  const renderPathInfo = () => {\n    if (!showPath || !techPath || techPath.nodes.length === 0) {\n      return null;\n    }\n    \n    return (\n      <motion.div\n        initial={{ opacity: 0, y: 10 }}\n        animate={{ opacity: 1, y: 0 }}\n        exit={{ opacity: 0, y: 10 }}\n        className=\"absolute top-full mt-2 p-3 bg-black bg-opacity-80 rounded-lg z-20 text-xs text-white max-w-xs\"\n      >\n        <h4 className=\"font-bold text-sm mb-1\">Research Path</h4>\n        <div className=\"flex items-center mb-2\">\n          <span className=\"text-gray-300 mr-2\">Time:</span>\n          <span>{Math.round(techPath.totalResearchTime / 60)} minutes</span>\n        </div>\n        {techPath.synergyBonus > 0 && (\n          <div className=\"flex items-center mb-2\">\n            <span className=\"text-gray-300 mr-2\">Synergy Bonus:</span>\n            <span className=\"text-green-400\">+{Math.round(techPath.synergyBonus * 100)}%</span>\n          </div>\n        )}\n        <div className=\"mt-2\">\n          <h5 className=\"font-semibold mb-1\">Steps:</h5>\n          <ol className=\"list-decimal list-inside\">\n            {techPath.nodes.map((nodeId, index) => {\n              const pathNode = techTreeManager.getNode(nodeId);\n              if (!pathNode) return null;\n              return (\n                <li key={`path-${index}`} className=\"mb-1\">\n                  {pathNode.name}\n                </li>\n              );\n            })}\n          </ol>\n        </div>\n      </motion.div>\n    );\n  };\n\n  return (\n    <div className=\"relative\" ref={nodeRef}>\n      <motion.div\n        data-node-id={node.id}\n        className={cn(\n          'relative p-3 rounded-lg shadow-lg',\n          getNodeColor(),\n          {\n            'ring-2 ring-blue-400 ring-offset-2 ring-offset-gray-900': isSelected,\n            'cursor-pointer': isAvailable || node.unlocked,\n            'cursor-not-allowed opacity-50': !isAvailable && !node.unlocked,\n            'hover:scale-105': isAvailable || node.unlocked,\n          }\n        )}\n        onMouseEnter={() => setHovered(true)}\n        onMouseLeave={() => setHovered(false)}\n        onClick={() => onNodeClick(node)}\n        whileHover={{ scale: isAvailable || node.unlocked ? 1.05 : 1 }}\n        transition={{ duration: 0.2 }}\n      >\n        <div className=\"flex items-center mb-2\">\n          <div\n            className={cn(\n              'p-1 rounded-full mr-2',\n              getIconColor()\n            )}\n          >\n            {categoryIcons[node.category] || categoryIcons.special}\n          </div>\n          <div className=\"text-white font-bold\">{node.name}</div>\n        </div>\n        \n        {showResearchProgress && (researchActive || researchProgress > 0) && (\n          <ResearchProgressIndicator \n            progress={researchProgress}\n            totalTime={node.researchTime || 60}\n            isActive={researchActive}\n            remainingTime={remainingTime}\n          />\n        )}\n        \n        {showDetails && (\n          <div className=\"text-gray-200 text-sm mt-2\">{node.description}</div>\n        )}\n        \n        <div className=\"absolute top-0 right-0 p-1\">\n          <div\n            className={cn(\n              'rounded-full w-4 h-4 flex items-center justify-center text-xs font-bold',\n              {\n                'bg-green-500 text-white': node.unlocked,\n                'bg-blue-500 text-white': !node.unlocked && isAvailable,\n                'bg-gray-500 text-gray-200': !node.unlocked && !isAvailable,\n              }\n            )}\n          >\n            {node.tier}\n          </div>\n        </div>\n      </motion.div>\n\n      {/* Display additional details when hovered */}\n      <AnimatePresence>\n        {hovered && !showDetails && (\n          <motion.div\n            initial={{ opacity: 0, y: 10 }}\n            animate={{ opacity: 1, y: 0 }}\n            exit={{ opacity: 0, y: 10 }}\n            className=\"absolute top-full mt-2 p-3 bg-black bg-opacity-80 rounded-lg z-20 text-xs text-white max-w-xs\"\n          >\n            <h4 className=\"font-bold text-sm\">{node.name}</h4>\n            <p className=\"mt-1\">{node.description}</p>\n            {!node.unlocked && (\n              <div className=\"mt-2\">\n                <div className=\"font-semibold\">Requirements:</div>\n                <ul className=\"list-disc list-inside\">\n                  {node.requirements.map((req, index) => {\n                    const reqNode = techTreeManager.getNode(req);\n                    const isUnlocked = techTreeManager.isUnlocked(req);\n                    \n                    return (\n                      <li\n                        key={`req-${index}`}\n                        className={isUnlocked ? 'text-green-400' : 'text-red-400'}\n                      >\n                        {reqNode?.name || req}\n                      </li>\n                    );\n                  })}\n                </ul>\n              </div>\n            )}\n            {node.synergyModifiers && Object.keys(node.synergyModifiers).length > 0 && (\n              <div className=\"mt-2\">\n                <div className=\"font-semibold\">Synergies:</div>\n                <ul className=\"list-disc list-inside\">\n                  {Object.entries(node.synergyModifiers).map(([targetId, value], index) => {\n                    const targetNode = techTreeManager.getNode(targetId);\n                    return (\n                      <li key={`synergy-${index}`}>\n                        {targetNode?.name || targetId}: +{Math.round(value * 100)}%\n                      </li>\n                    );\n                  })}\n                </ul>\n              </div>\n            )}\n          </motion.div>\n        )}\n      </AnimatePresence>\n\n      {/* Show path planning info when selected */}\n      <AnimatePresence>{isSelected && showPath && renderPathInfo()}</AnimatePresence>\n\n      {/* Render connections */}\n      {renderConnections()}\n      \n      {/* Render synergies */}\n      {renderSynergies()}\n    </div>\n  );\n}\n\n/**\n * Connection line between tech nodes\n */\nexport function TechConnectionLine({\n  from,\n  to,\n  status,\n  progress = 1,\n}: {\n  from: { x: number; y: number };\n  to: { x: number; y: number };\n  status: 'locked' | 'available' | 'unlocked';\n  progress?: number;\n}) {\n  // Calculate line properties\n  const dx = to.x - from.x;\n  const dy = to.y - from.y;\n  const length = Math.sqrt(dx * dx + dy * dy);\n  const angle = Math.atan2(dy, dx) * (180 / Math.PI);\n  \n  // For partial progress, adjust the line length\n  const adjustedLength = length * progress;\n\n  // Determine color based on status\n  const getLineColor = () => {\n    switch (status) {\n      case 'unlocked':\n        return 'bg-green-500';\n      case 'available':\n        return progress < 1 ? 'bg-yellow-500' : 'bg-blue-500';\n      case 'locked':\n      default:\n        return 'bg-gray-500';\n    }\n  };\n\n  return (\n    <div\n      className=\"absolute pointer-events-none\"\n      style={{\n        position: 'fixed',\n        top: 0,\n        left: 0,\n        width: '100vw',\n        height: '100vh',\n        zIndex: -1,\n      }}\n    >\n      <div\n        className={cn('absolute h-0.5 origin-left', getLineColor())}\n        style={{\n          left: from.x,\n          top: from.y,\n          width: adjustedLength,\n          transformOrigin: 'left center',\n          transform: `rotate(${angle}deg)`,\n        }}\n      />\n    </div>\n  );\n}\n\n/**\n * Research progress indicator component\n */\nexport function ResearchProgressIndicator({\n  progress,\n  totalTime,\n  isActive,\n  remainingTime,\n}: {\n  progress: number;\n  totalTime: number;\n  isActive: boolean;\n  remainingTime?: number;\n}) {\n  // Format remaining time as mm:ss\n  const formatTime = (seconds: number) => {\n    const minutes = Math.floor(seconds / 60);\n    const secs = Math.floor(seconds % 60);\n    return `${minutes}:${secs.toString().padStart(2, '0')}`;\n  };\n  \n  return (\n    <div className=\"mt-2\">\n      <div className=\"flex items-center justify-between text-xs mb-1\">\n        <span className=\"text-white\">Research Progress</span>\n        {remainingTime !== undefined && (\n          <span className=\"text-white\">\n            {formatTime(remainingTime)}\n          </span>\n        )}\n      </div>\n      <div className=\"w-full bg-gray-700 rounded-full h-2 overflow-hidden\">\n        <motion.div\n          className={cn(\n            \"h-full rounded-full\",\n            isActive ? \"bg-yellow-500\" : \"bg-green-500\"\n          )}\n          initial={{ width: `${progress * 100}%` }}\n          animate={{ \n            width: `${progress * 100}%`,\n            transition: { duration: isActive ? 1 : 0.5 }\n          }}\n        />\n      </div>\n      {isActive && (\n        <div className=\"text-xs text-yellow-300 mt-1 animate-pulse\">\n          Researching...\n        </div>\n      )}\n    </div>\n  );\n}\n\n/**\n * Synergy line between tech nodes\n */\nexport function SynergyLine({\n  from,\n  to,\n  strength,\n}: {\n  from: { x: number; y: number };\n  to: { x: number; y: number };\n  strength: number;\n}) {\n  // Calculate line properties\n  const dx = to.x - from.x;\n  const dy = to.y - from.y;\n  const length = Math.sqrt(dx * dx + dy * dy);\n  const angle = Math.atan2(dy, dx) * (180 / Math.PI);\n  \n  // Calculate line thickness based on strength\n  const thickness = Math.max(2, Math.min(10, strength * 10));\n  \n  return (\n    <div\n      className=\"absolute pointer-events-none\"\n      style={{\n        position: 'fixed',\n        top: 0,\n        left: 0,\n        width: '100vw',\n        height: '100vh',\n        zIndex: -1,\n      }}\n    >\n      <motion.div\n        className=\"absolute bg-purple-400 origin-left\"\n        style={{\n          left: from.x,\n          top: from.y,\n          width: length,\n          height: thickness,\n          transformOrigin: 'left center',\n          transform: `rotate(${angle}deg)`,\n          opacity: 0.6,\n        }}\n        initial={{ opacity: 0 }}\n        animate={{ \n          opacity: 0.6,\n          boxShadow: `0 0 ${strength * 10}px ${strength * 3}px rgba(168, 85, 247, 0.5)`,\n        }}\n      />\n    </div>\n  );\n}\n\n/**\n * Tech synergy indicator showing synergies between nodes\n */\nexport function TechSynergyIndicator({\n  nodes,\n  activeNodeId,\n}: {\n  nodes: TechNode[];\n  activeNodeId: string;\n}) {\n  const techTreeManager = getTechTreeManager();\n  const [synergies, setSynergies] = useState<Record<string, number>>({});\n  \n  useEffect(() => {\n    // Calculate synergies for active node\n    const activeSynergies: Record<string, number> = {};\n    \n    // Get the active node\n    const activeNode = nodes.find(n => n.id === activeNodeId);\n    if (!activeNode) return;\n    \n    // Calculate synergy strength for all other nodes\n    nodes.forEach(node => {\n      if (node.id !== activeNodeId && node.unlocked) {\n        const strength = calculateSynergyStrength(activeNode, node);\n        if (strength > 0) {\n          activeSynergies[node.id] = strength;\n        }\n      }\n    });\n    \n    setSynergies(activeSynergies);\n  }, [nodes, activeNodeId]);\n  \n  const calculateSynergyStrength = (node1: TechNode, node2: TechNode): number => {\n    // Check if nodes have direct synergy via modifiers\n    if (node1.synergyModifiers?.[node2.id]) {\n      return node1.synergyModifiers[node2.id];\n    }\n    \n    if (node2.synergyModifiers?.[node1.id]) {\n      return node2.synergyModifiers[node1.id];\n    }\n    \n    // Check for category synergy\n    if (node1.category === node2.category) {\n      return 0.1; // 10% base synergy for same category\n    }\n    \n    // Special synergies for certain combinations\n    if (\n      (node1.category === 'weapons' && node2.category === 'warFleet') ||\n      (node1.category === 'warFleet' && node2.category === 'weapons')\n    ) {\n      return 0.15; // 15% synergy for weapons + warships\n    }\n    \n    return 0;\n  };\n  \n  if (Object.keys(synergies).length === 0) {\n    return null;\n  }\n  \n  return (\n    <div className=\"p-4 bg-gray-800 rounded-lg mt-4\">\n      <h3 className=\"text-white font-bold mb-2\">Synergies</h3>\n      <ul className=\"space-y-2\">\n        {Object.entries(synergies).map(([nodeId, strength]) => {\n          const node = nodes.find(n => n.id === nodeId);\n          if (!node) return null;\n          \n          return (\n            <li key={nodeId} className=\"flex items-center justify-between\">\n              <div className=\"flex items-center\">\n                <div className=\"mr-2 p-1 rounded-full bg-purple-500\">\n                  {categoryIcons[node.category]}\n                </div>\n                <span className=\"text-white\">{node.name}</span>\n              </div>\n              <span className=\"text-purple-400 font-bold\">\n                +{Math.round(strength * 100)}%\n              </span>\n            </li>\n          );\n        })}\n      </ul>\n    </div>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/tooltip-context.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/tooltip-context.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/virtualized/VirtualizedList.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'scrollTop' is assigned a value but never used. Allowed unused elements of array destructuring must match /^_/u.","line":93,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":93,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @context: ui-system, performance-optimization, component-library\n * \n * VirtualizedList component for optimizing long lists by rendering only what's visible in the viewport\n */\n\nimport * as React from 'react';\nimport { useState, useEffect, useRef, useCallback, ReactNode, CSSProperties, memo } from 'react';\nimport { useVirtualization } from '../../../utils/performance/ComponentOptimizer';\n\nexport interface VirtualizedListProps<T> {\n  /**\n   * Items to render in the list\n   */\n  items: T[];\n  \n  /**\n   * Height of each item in pixels\n   */\n  itemHeight: number;\n  \n  /**\n   * Height of the list container in pixels\n   */\n  height: number;\n  \n  /**\n   * Width of the list container in pixels\n   * @default '100%'\n   */\n  width?: number | string;\n  \n  /**\n   * Additional items to render above and below the visible area to prevent flickering during scroll\n   * @default 5\n   */\n  overscan?: number;\n  \n  /**\n   * Function to render an individual list item\n   */\n  renderItem: (item: T, index: number, style: CSSProperties) => ReactNode;\n  \n  /**\n   * Optional loading state indicator for items not yet loaded\n   */\n  isLoading?: boolean;\n  \n  /**\n   * Optional element to display when items array is empty\n   */\n  emptyPlaceholder?: ReactNode;\n  \n  /**\n   * Optional element to display when items are loading\n   */\n  loadingPlaceholder?: ReactNode;\n  \n  /**\n   * Optional CSS class name to apply to the list container\n   */\n  className?: string;\n  \n  /**\n   * Optional ID for the list container\n   */\n  id?: string;\n  \n  /**\n   * Optional callback when list is scrolled\n   */\n  onScroll?: (scrollTop: number) => void;\n}\n\n/**\n * Virtualized list component that only renders items visible in the viewport\n */\nexport function VirtualizedList<T>({\n  items,\n  itemHeight,\n  height,\n  width = '100%',\n  overscan = 5,\n  renderItem,\n  isLoading = false,\n  emptyPlaceholder = <div className=\"virtualized-list-empty\">No items to display</div>,\n  loadingPlaceholder = <div className=\"virtualized-list-loading\">Loading...</div>,\n  className = '',\n  id,\n  onScroll\n}: VirtualizedListProps<T>) {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const [scrollTop, setScrollTop] = useState(0);\n  \n  // Use virtualization hook to calculate visible items\n  const { \n    startIndex, \n    endIndex, \n    totalHeight \n  } = useVirtualization({ \n    itemCount: items.length, \n    itemHeight, \n    containerHeight: height, \n    overscan \n  });\n  \n  // Handle scroll events\n  const handleScroll = useCallback(() => {\n    if (containerRef.current) {\n      const newScrollTop = containerRef.current.scrollTop;\n      setScrollTop(newScrollTop);\n      onScroll?.(newScrollTop);\n    }\n  }, [onScroll]);\n  \n  // Set up scroll event listener\n  useEffect(() => {\n    const container = containerRef.current;\n    if (container) {\n      container.addEventListener('scroll', handleScroll);\n      return () => container.removeEventListener('scroll', handleScroll);\n    }\n  }, [handleScroll]);\n  \n  // If no items and not loading, show empty placeholder\n  if (items.length === 0 && !isLoading) {\n    return <div style={{ width, height }}>{emptyPlaceholder}</div>;\n  }\n  \n  // If loading, show loading placeholder\n  if (isLoading) {\n    return <div style={{ width, height }}>{loadingPlaceholder}</div>;\n  }\n  \n  // Calculate visible items\n  const visibleItems = items.slice(startIndex, endIndex + 1);\n  \n  return (\n    <div\n      ref={containerRef}\n      className={`virtualized-list ${className}`}\n      id={id}\n      style={{\n        height,\n        width,\n        overflow: 'auto',\n        position: 'relative',\n        willChange: 'transform',\n      }}\n    >\n      <div style={{ height: totalHeight, position: 'relative' }}>\n        {visibleItems.map((item, i) => {\n          const index = startIndex + i;\n          const top = index * itemHeight;\n          \n          return renderItem(item, index, {\n            position: 'absolute',\n            top,\n            left: 0,\n            width: '100%',\n            height: itemHeight,\n          });\n        })}\n      </div>\n    </div>\n  );\n}\n\n// Export a memoized version of the component for better performance\nexport default memo(VirtualizedList) as typeof VirtualizedList; ","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/virtualized/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/visualization/AnimationTypeSafetyDemo.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'animationSequence' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":87,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":87,"endColumn":28}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as d3 from 'd3';\nimport * as React from 'react';\nimport { useEffect, useRef } from 'react';\nimport {\n  AnimationConfig,\n  createTypedTimer,\n  TypedAnimationSequence,\n  typedInterpolators,\n} from '../../../types/visualizations/D3AnimationTypes';\nimport { selectSvg } from '../../../types/visualizations/D3SelectionTypes';\n\ninterface Point {\n  x: number;\n  y: number;\n  radius: number;\n  color: string;\n}\n\ninterface AnimationTypeSafetyDemoProps {\n  width?: number;\n  height?: number;\n  animationConfig?: Partial<AnimationConfig>;\n}\n\n/**\n * Demo component showcasing the type-safe animation utilities\n *\n * This component demonstrates:\n * 1. Type-safe interpolation\n * 2. Type-safe transition configuration\n * 3. Type-safe timer usage\n * 4. Animation sequences with proper typing\n */\nconst AnimationTypeSafetyDemo: React.FC<AnimationTypeSafetyDemoProps> = ({\n  width = 600,\n  height = 400,\n  animationConfig = {},\n}) => {\n  const svgRef = useRef<SVGSVGElement>(null);\n  const config: AnimationConfig = {\n    duration: 1500,\n    easing: d3.easeCubicInOut,\n    loop: true,\n    loopDelay: 500,\n    ...animationConfig,\n  };\n\n  // Setup point data for animation\n  const pointsData: Point[] = [\n    { x: 100, y: 100, radius: 20, color: '#E63946' },\n    { x: 300, y: 150, radius: 30, color: '#457B9D' },\n    { x: 500, y: 200, radius: 25, color: '#2A9D8F' },\n    { x: 200, y: 250, radius: 35, color: '#F4A261' },\n    { x: 400, y: 300, radius: 15, color: '#6D597A' },\n  ];\n\n  // Animation point data targets (for interpolation)\n  const targetData: Point[] = [\n    { x: 150, y: 200, radius: 35, color: '#E76F51' },\n    { x: 250, y: 100, radius: 15, color: '#264653' },\n    { x: 350, y: 300, radius: 40, color: '#1D3557' },\n    { x: 450, y: 200, radius: 20, color: '#F1FAEE' },\n    { x: 200, y: 150, radius: 30, color: '#E9C46A' },\n  ];\n\n  useEffect(() => {\n    if (!svgRef.current) return;\n\n    // Clear any existing elements\n    d3.select(svgRef.current).selectAll('*').remove();\n\n    // Create SVG container with proper typing\n    const svg = selectSvg(`#animation-demo-svg`);\n\n    // Add circles for each data point\n    const circles = svg\n      .selectAll<SVGCircleElement, Point>('circle')\n      .data(pointsData)\n      .enter()\n      .append('circle')\n      .attr('cx', d => d.x)\n      .attr('cy', d => d.y)\n      .attr('r', d => d.radius)\n      .attr('fill', d => d.color);\n\n    // Setup animation sequence using type-safe utilities\n    const animationSequence = new TypedAnimationSequence({\n      transitions: [\n        {\n          selection: circles,\n          duration: config.duration,\n          easing: config.easing,\n          delay: (_, i) => i * 100, // Staggered delay based on index\n        },\n        {\n          selection: circles,\n          duration: config.duration,\n          easing: d3.easeElasticOut,\n        },\n      ],\n      sequenceDelay: 500,\n      loop: config.loop,\n    });\n\n    // Create object interpolators for each data point\n    const interpolators = pointsData.map((startPoint, index) => {\n      return {\n        position: typedInterpolators.object<Pick<Point, 'x' | 'y'>>(\n          { x: startPoint.x, y: startPoint.y },\n          { x: targetData[index].x, y: targetData[index].y }\n        ),\n        radius: typedInterpolators.number(startPoint.radius, targetData[index].radius),\n        color: typedInterpolators.color(startPoint.color, targetData[index].color),\n      };\n    });\n\n    // Create a type-safe timer for smooth animation\n    const timer = createTypedTimer({\n      callback: elapsed => {\n        // Calculate progress based on elapsed time (ping-pong effect)\n        const totalDuration = config.duration * 2;\n        const normalizedTime = (elapsed % totalDuration) / config.duration;\n        const t = normalizedTime <= 1 ? normalizedTime : 2 - normalizedTime;\n\n        // Update each circle with interpolated values\n        circles.each(function (d, i) {\n          const point = interpolators[i];\n          const interpolatedPosition = point.position(t);\n          const interpolatedRadius = point.radius(t);\n          const interpolatedColor = point.color(t);\n\n          d3.select(this)\n            .attr('cx', interpolatedPosition.x)\n            .attr('cy', interpolatedPosition.y)\n            .attr('r', interpolatedRadius)\n            .attr('fill', interpolatedColor);\n        });\n\n        // Continue animation if we're looping\n        return !config.loop && elapsed >= totalDuration;\n      },\n      duration: config.loop ? undefined : config.duration * 2,\n    });\n\n    // Add labels to show interpolation t value\n    const label = svg\n      .append('text')\n      .attr('x', width / 2)\n      .attr('y', 30)\n      .attr('text-anchor', 'middle')\n      .attr('font-size', '14px')\n      .attr('fill', '#333');\n\n    // Update label with current interpolation value\n    createTypedTimer({\n      callback: elapsed => {\n        const totalDuration = config.duration * 2;\n        const normalizedTime = (elapsed % totalDuration) / config.duration;\n        const t = normalizedTime <= 1 ? normalizedTime : 2 - normalizedTime;\n\n        label.text(`Interpolation t: ${t.toFixed(2)}`);\n        return false;\n      },\n    });\n\n    // Cleanup function\n    return () => {\n      timer.stop();\n    };\n  }, [width, height, config]);\n\n  return (\n    <div className=\"animation-type-safety-demo\">\n      <h3>Animation Type Safety Demo</h3>\n      <svg\n        id=\"animation-demo-svg\"\n        ref={svgRef}\n        width={width}\n        height={height}\n        style={{\n          border: '1px solid #ccc',\n          borderRadius: '4px',\n          background: '#f7f7f7',\n        }}\n      />\n      <div className=\"demo-description\">\n        <p>This demo showcases the type-safe animation utilities:</p>\n        <ul>\n          <li>Strong typing for interpolators (position, radius, color)</li>\n          <li>Type-safe timer configuration and transitions</li>\n          <li>Animation sequences with proper event handling</li>\n        </ul>\n      </div>\n    </div>\n  );\n};\n\nexport default AnimationTypeSafetyDemo;\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/visualization/ChartCoordinationDemo.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'handleScatterBrush' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":103,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":103,"endColumn":27}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as React from 'react';\nimport { useState } from 'react';\nimport { useChartCoordination } from '../../../hooks/visualization/useChartCoordination';\nimport {\n  BrushState,\n  HighlightState,\n  ViewportState,\n} from '../../../lib/visualization/ChartCoordinationManager';\n\ninterface ChartCoordinationDemoProps {\n  width?: number;\n  height?: number;\n  className?: string;\n}\n\n/**\n * ChartCoordinationDemo\n *\n * A demo component that shows how multiple charts can be coordinated for:\n * - Synchronized zooming/panning\n * - Linked brushing\n * - Synchronized highlighting\n * - Shared color scales\n */\nexport const ChartCoordinationDemo: React.FC<ChartCoordinationDemoProps> = ({\n  width = 1200,\n  height = 800,\n  className = '',\n}) => {\n  // Sample data\n  const data = React.useMemo(() => {\n    const points = [];\n    for (let i = 0; i < 100; i++) {\n      points.push({\n        id: `point-${i}`,\n        x: Math.random() * 100,\n        y: Math.random() * 100,\n        category: Math.random() > 0.5 ? 'A' : 'B',\n        value: Math.random() * 100,\n      });\n    }\n    return points;\n  }, []);\n\n  // Chart states\n  const [scatterViewport, setScatterViewport] = useState<ViewportState>({\n    scale: 1,\n    translateX: 0,\n    translateY: 0,\n  });\n  const [scatterBrush, setScatterBrush] = useState<BrushState>({\n    active: false,\n    x1: 0,\n    y1: 0,\n    x2: 0,\n    y2: 0,\n  });\n  const [scatterHighlight, setScatterHighlight] = useState<HighlightState>({\n    active: false,\n    dataIds: [],\n  });\n\n  const [barViewport, setBarViewport] = useState<ViewportState>({\n    scale: 1,\n    translateX: 0,\n    translateY: 0,\n  });\n  const [barHighlight, setBarHighlight] = useState<HighlightState>({\n    active: false,\n    dataIds: [],\n  });\n\n  // Set up chart coordination\n  const scatterCoordination = useChartCoordination({\n    chartId: 'scatter-plot',\n    groupId: 'demo-group',\n    initialState: {\n      viewport: scatterViewport,\n      brush: scatterBrush,\n      highlight: scatterHighlight,\n    },\n    onViewportChange: setScatterViewport,\n    onBrushChange: setScatterBrush,\n    onHighlightChange: setScatterHighlight,\n  });\n\n  const barCoordination = useChartCoordination({\n    chartId: 'bar-chart',\n    groupId: 'demo-group',\n    initialState: {\n      viewport: barViewport,\n      highlight: barHighlight,\n    },\n    onViewportChange: setBarViewport,\n    onHighlightChange: setBarHighlight,\n  });\n\n  // Handle interactions\n  const handleScatterZoom = (scale: number, translateX: number, translateY: number) => {\n    scatterCoordination.updateViewport({ scale, translateX, translateY });\n  };\n\n  const handleScatterBrush = (x1: number, y1: number, x2: number, y2: number) => {\n    // Find points within brush\n    const selectedPoints = data?.filter(\n      point =>\n        point.x >= Math.min(x1, x2) &&\n        point.x <= Math.max(x1, x2) &&\n        point.y >= Math.min(y1, y2) &&\n        point.y <= Math.max(y1, y2)\n    );\n\n    scatterCoordination.updateBrush({\n      active: true,\n      x1,\n      y1,\n      x2,\n      y2,\n    });\n\n    scatterCoordination.updateHighlight({\n      active: true,\n      dataIds: selectedPoints.map(p => p.id),\n    });\n  };\n\n  const handleBarHighlight = (category: string) => {\n    const selectedPoints = data?.filter(point => point.category === category);\n\n    barCoordination.updateHighlight({\n      active: true,\n      dataIds: selectedPoints.map(p => p.id),\n      category,\n    });\n  };\n\n  return (\n    <div className={`chart-coordination-demo ${className}`}>\n      <div className=\"flex flex-col gap-4\">\n        <div className=\"flex gap-4\">\n          {/* Scatter Plot */}\n          <div className=\"flex-1 rounded-lg border p-4 shadow-sm\">\n            <h3 className=\"mb-2 text-lg font-bold\">Scatter Plot</h3>\n            <div\n              className=\"relative\"\n              style={{\n                width: width / 2 - 32,\n                height: height - 200,\n                transform: `scale(${scatterViewport.scale}) translate(${scatterViewport.translateX}px, ${scatterViewport.translateY}px)`,\n              }}\n            >\n              {/* Plot points */}\n              {data?.map(point => (\n                <div\n                  key={point.id}\n                  className={`absolute h-3 w-3 rounded-full transition-opacity ${\n                    scatterHighlight.active && !scatterHighlight.dataIds.includes(point.id)\n                      ? 'opacity-20'\n                      : 'opacity-100'\n                  }`}\n                  style={{\n                    left: `${point.x}%`,\n                    top: `${point.y}%`,\n                    backgroundColor: point.category === 'A' ? '#3B82F6' : '#EF4444',\n                    transform: 'translate(-50%, -50%)',\n                  }}\n                />\n              ))}\n\n              {/* Brush overlay */}\n              {scatterBrush.active && (\n                <div\n                  className=\"absolute border-2 border-blue-500 bg-blue-500/10\"\n                  style={{\n                    left: `${Math.min(scatterBrush.x1, scatterBrush.x2)}%`,\n                    top: `${Math.min(scatterBrush.y1, scatterBrush.y2)}%`,\n                    width: `${Math.abs(scatterBrush.x2 - scatterBrush.x1)}%`,\n                    height: `${Math.abs(scatterBrush.y2 - scatterBrush.y1)}%`,\n                  }}\n                />\n              )}\n            </div>\n          </div>\n\n          {/* Bar Chart */}\n          <div className=\"flex-1 rounded-lg border p-4 shadow-sm\">\n            <h3 className=\"mb-2 text-lg font-bold\">Bar Chart</h3>\n            <div\n              className=\"relative\"\n              style={{\n                width: width / 2 - 32,\n                height: height - 200,\n                transform: `scale(${barViewport.scale}) translate(${barViewport.translateX}px, ${barViewport.translateY}px)`,\n              }}\n            >\n              {/* Category bars */}\n              {['A', 'B'].map(category => {\n                const categoryPoints = data?.filter(p => p.category === category);\n                const average =\n                  categoryPoints.reduce((sum, p) => sum + p.value, 0) / categoryPoints.length;\n\n                return (\n                  <div\n                    key={category}\n                    className={`absolute bottom-0 w-32 transition-opacity ${\n                      barHighlight.active && barHighlight.category !== category\n                        ? 'opacity-20'\n                        : 'opacity-100'\n                    }`}\n                    style={{\n                      left: category === 'A' ? '30%' : '60%',\n                      height: `${average}%`,\n                      backgroundColor: category === 'A' ? '#3B82F6' : '#EF4444',\n                    }}\n                    onClick={() => handleBarHighlight(category)}\n                  >\n                    <div className=\"absolute -top-6 w-full text-center\">{category}</div>\n                  </div>\n                );\n              })}\n            </div>\n          </div>\n        </div>\n\n        <div className=\"rounded-lg border p-4 shadow-sm\">\n          <h3 className=\"mb-2 text-lg font-bold\">Controls</h3>\n          <div className=\"flex gap-4\">\n            <div>\n              <label className=\"block font-medium\">Zoom</label>\n              <input\n                type=\"range\"\n                min=\"0.5\"\n                max=\"2\"\n                step=\"0.1\"\n                value={scatterViewport.scale}\n                onChange={e => handleScatterZoom(parseFloat(e.target.value), 0, 0)}\n                className=\"w-48\"\n              />\n            </div>\n            <button\n              className=\"rounded bg-blue-500 px-4 py-2 text-white\"\n              onClick={() => {\n                scatterCoordination.updateBrush({\n                  active: false,\n                  x1: 0,\n                  y1: 0,\n                  x2: 0,\n                  y2: 0,\n                });\n                scatterCoordination.updateHighlight({\n                  active: false,\n                  dataIds: [],\n                });\n                barCoordination.updateHighlight({\n                  active: false,\n                  dataIds: [],\n                });\n              }}\n            >\n              Reset Selection\n            </button>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default ChartCoordinationDemo;\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/visualization/CustomShaderDemo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/visualization/CustomShaderVisualization.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/visualization/DataHighlightDemo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/visualization/DataHighlightVisualization.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/visualization/DataTransitionParticleSystem.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'DataTransitionConfig' is defined but never used. Allowed unused vars must match /^ignored|^temp/u.","line":18,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":18,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_delay' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":134,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":134,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_currentPosition' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":161,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":161,"endColumn":31}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as React from 'react';\nimport { useEffect, useRef, useState } from 'react';\nimport { useComponentLifecycle } from '../../../hooks/ui/useComponentLifecycle';\nimport { useComponentRegistration } from '../../../hooks/ui/useComponentRegistration';\nimport { ParticleSystemManager } from '../../../managers/effects/ParticleSystemManager';\nimport { Position } from '../../../types/core/Position';\nimport { ResourceType } from './../../../types/resources/ResourceTypes';\n\nexport interface DataPoint {\n  id: string;\n  position: Position;\n  value: number;\n  resourceType?: ResourceType;\n  size?: number;\n  opacity?: number;\n}\n\ninterface DataTransitionConfig {\n  sourceData: DataPoint[];\n  targetData: DataPoint[];\n  duration?: number;\n  easing?: (t: number) => number;\n  staggerDelay?: number;\n  trailEffect?: boolean;\n  blendMode?: 'normal' | 'additive';\n  onTransitionComplete?: () => void;\n  onTransitionProgress?: (progress: number) => void;\n}\n\ninterface DataTransitionParticleSystemProps {\n  width: number;\n  height: number;\n  quality?: 'low' | 'medium' | 'high';\n  className?: string;\n  sourceData: DataPoint[];\n  targetData: DataPoint[];\n  onTransitionComplete?: () => void;\n  onTransitionProgress?: (progress: number) => void;\n  duration?: number;\n  easing?: (t: number) => number;\n  staggerDelay?: number;\n  trailEffect?: boolean;\n  blendMode?: 'normal' | 'additive';\n}\n\n/**\n * DataTransitionParticleSystem\n *\n * A specialized particle system for animating data transitions in visualizations.\n * Extends the base ParticleSystemManager with data-specific transition features.\n */\nexport const DataTransitionParticleSystem: React.FC<DataTransitionParticleSystemProps> = ({\n  width,\n  height,\n  quality = 'medium',\n  className = '',\n  sourceData,\n  targetData,\n  onTransitionComplete,\n  onTransitionProgress,\n  duration = 1000,\n  easing = t => t,\n  staggerDelay = 20,\n  trailEffect = false,\n  blendMode = 'additive',\n}) => {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const particleSystemRef = useRef<ParticleSystemManager | null>(null);\n  const [isInitialized, setIsInitialized] = useState(false);\n\n  // Register with component registry\n  useComponentRegistration({\n    type: ResourceType.EXOTIC,\n    eventSubscriptions: ['RESOURCE_UPDATED', 'RESOURCE_FLOW_UPDATED', 'RESOURCE_THRESHOLD_CHANGED'],\n    updatePriority: 'high',\n  });\n\n  // Initialize particle system\n  useEffect(() => {\n    if (!canvasRef.current || isInitialized) return;\n\n    particleSystemRef.current = ParticleSystemManager.getInstance();\n    setIsInitialized(true);\n\n    return () => {\n      if (particleSystemRef.current) {\n        particleSystemRef.current.cleanup();\n      }\n    };\n  }, [isInitialized]);\n\n  // Handle component lifecycle\n  useComponentLifecycle({\n    onMount: () => {\n      console.warn('DataTransitionParticleSystem mounted');\n    },\n    onUnmount: () => {\n      console.warn('DataTransitionParticleSystem unmounted');\n    },\n  });\n\n  // Start transition when data changes\n  useEffect(() => {\n    if (!particleSystemRef.current || !isInitialized) return;\n\n    // Create particle configuration\n    const particleConfig = {\n      maxParticles: Math.max(sourceData.length, targetData.length),\n      spawnRate: 0,\n      position: { x: 0, y: 0 },\n      spread: 0,\n      initialVelocity: {\n        min: { x: 0, y: 0 },\n        max: { x: 0, y: 0 },\n      },\n      acceleration: { x: 0, y: 0 },\n      size: {\n        min: 2,\n        max: 8,\n      },\n      life: {\n        min: duration,\n        max: duration,\n      },\n      color: '#ffffff',\n      blendMode: blendMode as 'normal' | 'additive',\n      quality,\n    };\n\n    // Create transition particles\n    sourceData.forEach((source, index) => {\n      const target = targetData[index] || targetData[targetData.length - 1];\n      const _delay = index * staggerDelay;\n\n      particleSystemRef.current?.createParticleSystem(`transition-${index}`, {\n        ...particleConfig,\n        position: source.position,\n        color: getResourceColor(source.resourceType),\n        size: {\n          min: source.size || 2,\n          max: target.size || 8,\n        },\n      });\n    });\n\n    // Start animation loop\n    const startTime = performance.now();\n    let animationFrame: number;\n\n    const animate = () => {\n      const currentTime = performance.now();\n      const elapsed = currentTime - startTime;\n      const progress = Math.min(1, elapsed / duration);\n\n      // Update particle positions\n      sourceData.forEach((source, index) => {\n        const target = targetData[index] || targetData[targetData.length - 1];\n        const particleProgress = easing(progress);\n\n        const _currentPosition = {\n          x: source.position.x + (target.position.x - source.position.x) * particleProgress,\n          y: source.position.y + (target.position.y - source.position.y) * particleProgress,\n        };\n\n        particleSystemRef.current?.update(1 / 60);\n      });\n\n      // Report progress\n      onTransitionProgress?.(progress);\n\n      // Continue animation or complete\n      if (progress < 1) {\n        animationFrame = requestAnimationFrame(animate);\n      } else {\n        onTransitionComplete?.();\n      }\n    };\n\n    animationFrame = requestAnimationFrame(animate);\n\n    // Cleanup function\n    return () => {\n      cancelAnimationFrame(animationFrame);\n      sourceData.forEach((_, index) => {\n        particleSystemRef.current?.removeSystem(`transition-${index}`);\n      });\n    };\n  }, [\n    sourceData,\n    targetData,\n    duration,\n    easing,\n    staggerDelay,\n    trailEffect,\n    blendMode,\n    quality,\n    onTransitionComplete,\n    onTransitionProgress,\n  ]);\n\n  return (\n    <div\n      ref={containerRef}\n      className={`data-transition-particle-system ${className}`}\n      style={{ width, height, position: 'relative' }}\n    >\n      <canvas\n        ref={canvasRef}\n        width={width}\n        height={height}\n        style={{\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          pointerEvents: 'none',\n        }}\n      />\n    </div>\n  );\n};\n\n// Helper function to get color for resource type\nconst getResourceColor = (resourceType?: ResourceType): string => {\n  if (!resourceType) return '#ffffff';\n\n  switch (resourceType) {\n    case ResourceType.MINERALS:\n      return '#4CAF50';\n    case ResourceType.ENERGY:\n      return '#FFC107';\n    case ResourceType.PLASMA:\n      return '#9C27B0';\n    case ResourceType.GAS:\n      return '#03A9F4';\n    case ResourceType.RESEARCH:\n      return '#3F51B5';\n    default:\n      return '#9E9E9E';\n  }\n};\n\nexport default DataTransitionParticleSystem;\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/visualization/FlowDiagram.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'nodeMap' is defined but never used.","line":182,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":182,"endColumn":10},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isNodeReference' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":230,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":230,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'selectedNodeId' is assigned a value but never used. Allowed unused elements of array destructuring must match /^_/u.","line":251,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":251,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'selectedLinkId' is assigned a value but never used. Allowed unused elements of array destructuring must match /^_/u.","line":252,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":252,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'flowDataSchema' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":260,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":260,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'nodeMap' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":408,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":408,"endColumn":34}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as d3 from 'd3';\nimport * as React from 'react';\nimport { useCallback, useEffect, useRef, useState } from 'react';\nimport {\n  d3Accessors,\n  SimulationLinkDatum,\n  SimulationNodeDatum,\n} from '../../../types/visualizations/D3Types';\nimport {\n  createD3ForceValidation,\n  ValidationTransformResult,\n} from '../../../types/visualizations/D3ValidationHooks';\nimport { Schema } from '../../../types/visualizations/D3Validators';\n\n/**\n * Represents a node in the flow diagram\n */\ninterface FlowDataNode {\n  id: string;\n  name: string;\n  type: 'source' | 'process' | 'destination';\n  value: number;\n  capacity?: number;\n  efficiency?: number;\n  description?: string;\n}\n\n/**\n * Represents a connection between two nodes in the flow diagram\n */\ninterface FlowDataLink {\n  id: string;\n  source: string;\n  target: string;\n  value: number;\n  maxCapacity?: number;\n  utilization?: number;\n  flowType?: string;\n  active: boolean;\n}\n\n/**\n * Represents the entire flow data structure\n */\ninterface FlowData {\n  nodes: FlowDataNode[];\n  links: FlowDataLink[];\n}\n\n/**\n * Node type for D3 force simulation with proper typing\n * Extends SimulationNodeDatum to ensure D3 compatibility\n */\ninterface FlowNode extends SimulationNodeDatum<FlowDataNode> {\n  id: string;\n  name: string;\n  type: 'source' | 'process' | 'destination';\n  value: number;\n  capacity?: number;\n  efficiency?: number;\n  description?: string;\n  color?: string;\n  radius?: number;\n  // Original data reference\n  data?: FlowDataNode;\n}\n\n/**\n * Link type for D3 force simulation with proper typing\n * Extends SimulationLinkDatum for D3 compatibility\n */\ninterface FlowLink extends SimulationLinkDatum<FlowNode> {\n  id: string;\n  source: string | FlowNode;\n  target: string | FlowNode;\n  value: number;\n  maxCapacity?: number;\n  utilization?: number;\n  flowType?: string;\n  active: boolean;\n  width?: number;\n  color?: string;\n}\n\n/**\n * Props for FlowDiagram component\n */\ninterface FlowDiagramProps {\n  /**\n   * Flow data to visualize\n   */\n  data: FlowData;\n\n  /**\n   * Width of the diagram in pixels\n   * @default 800\n   */\n  width?: number;\n\n  /**\n   * Height of the diagram in pixels\n   * @default 600\n   */\n  height?: number;\n\n  /**\n   * Whether the diagram supports interaction (dragging, zooming)\n   * @default true\n   */\n  interactive?: boolean;\n\n  /**\n   * Whether to animate transitions in the diagram\n   * @default true\n   */\n  animated?: boolean;\n\n  /**\n   * Callback when a node is clicked\n   */\n  onNodeClick?: (nodeId: string, nodeData: FlowDataNode) => void;\n\n  /**\n   * Callback when a link is clicked\n   */\n  onLinkClick?: (linkId: string, linkData: FlowDataLink) => void;\n\n  /**\n   * CSS class name for additional styling\n   */\n  className?: string;\n}\n\n/**\n * Convert data nodes to D3-compatible nodes with proper typing\n */\nconst convertNodesToD3Format = (nodes: FlowDataNode[]): FlowNode[] => {\n  return nodes.map(node => {\n    // Determine radius based on node value\n    const radius = Math.max(15, Math.min(40, 15 + (node.value / 100) * 25));\n\n    // Determine color based on node type\n    let color: string;\n    switch (node.type) {\n      case 'source':\n        color = '#06b6d4'; // cyan\n        break;\n      case 'process':\n        color = '#a855f7'; // purple\n        break;\n      case 'destination':\n        color = '#10b981'; // green\n        break;\n      default:\n        color = '#94a3b8'; // slate\n    }\n\n    // Create a properly typed node with no type assertions\n    const d3Node: FlowNode = {\n      id: node.id,\n      name: node.name,\n      type: node.type,\n      value: node.value,\n      capacity: node.capacity,\n      efficiency: node.efficiency,\n      description: node.description,\n      radius,\n      color,\n      // Store original data for reference\n      data: node,\n    };\n\n    return d3Node;\n  });\n};\n\n/**\n * Convert data links to D3-compatible links with proper typing\n */\nconst convertLinksToD3Format = (\n  links: FlowDataLink[],\n  nodeMap: Map<string, FlowNode>\n): FlowLink[] => {\n  return links.map(link => {\n    // Determine line width based on value and maxCapacity\n    const width = Math.max(1, Math.min(8, 1 + (link.value / 100) * 7));\n\n    // Determine color based on active state and utilization\n    let color: string;\n    if (!link.active) {\n      color = '#94a3b8'; // slate (inactive)\n    } else if (link.utilization && link.utilization > 0.8) {\n      color = '#ef4444'; // red (high utilization)\n    } else if (link.utilization && link.utilization > 0.5) {\n      color = '#f59e0b'; // amber (medium utilization)\n    } else {\n      color = '#3b82f6'; // blue (low utilization)\n    }\n\n    // Create a properly typed link with no type assertions\n    const d3Link: FlowLink = {\n      id: link.id,\n      source: link.source,\n      target: link.target,\n      value: link.value,\n      maxCapacity: link.maxCapacity,\n      utilization: link.utilization,\n      flowType: link.flowType,\n      active: link.active,\n      width,\n      color,\n    };\n\n    return d3Link;\n  });\n};\n\n/**\n * Find a node by ID in an array of nodes\n * Type-safe helper function\n */\nconst findNodeById = (nodes: FlowNode[], id: string): FlowNode | undefined => {\n  return nodes.find(node => node.id === id);\n};\n\n/**\n * Check if a node/link is a string or an object\n * Type guard function\n */\nconst isNodeReference = (obj: string | FlowNode): obj is FlowNode => {\n  return typeof obj !== 'string' && obj.id !== undefined;\n};\n\n/**\n * Component for visualizing flow data with type-safe D3 integration\n */\nconst FlowDiagram: React.FC<FlowDiagramProps> = ({\n  data,\n  width = 800,\n  height = 600,\n  interactive = true,\n  animated = true,\n  onNodeClick,\n  onLinkClick,\n  className = '',\n}) => {\n  const svgRef = useRef<SVGSVGElement | null>(null);\n  const simulationRef = useRef<d3.Simulation<FlowNode, FlowLink> | null>(null);\n\n  // State for tracking hover and selected nodes/links\n  const [selectedNodeId, setSelectedNodeId] = useState<string | null>(null);\n  const [selectedLinkId, setSelectedLinkId] = useState<string | null>(null);\n\n  /**\n   * Prepare visualization data with type safety\n   */\n  const prepareVisualizationData = useCallback(() => {\n    try {\n      // Define validation schemas\n      const flowDataSchema: Schema = {\n        name: 'FlowData',\n        description: 'Schema for flow data',\n        properties: {\n          nodes: {\n            type: 'array',\n            required: true,\n          },\n          links: {\n            type: 'array',\n            required: true,\n          },\n        },\n      };\n\n      // Create validation functions\n      const validation = createD3ForceValidation<FlowData, FlowNode, FlowLink>(\n        // Node transform function\n        inputData => convertNodesToD3Format(inputData.nodes),\n        // Link transform function\n        inputData =>\n          convertLinksToD3Format(\n            inputData.links,\n            new Map(convertNodesToD3Format(inputData.nodes).map(node => [node.id, node]))\n          ),\n        // Custom node schema properties\n        {\n          properties: {\n            id: {\n              type: 'string',\n              required: true,\n              validate: value => (value as string).length > 0 || 'Node ID cannot be empty',\n            },\n            type: {\n              type: 'string',\n              required: true,\n              enum: ['source', 'process', 'destination'],\n            },\n          },\n        },\n        // Custom link schema properties\n        {\n          properties: {\n            id: {\n              type: 'string',\n              required: true,\n            },\n            active: {\n              type: 'boolean',\n              required: true,\n            },\n          },\n        },\n        // Validation options\n        {\n          throwOnError: false,\n          logErrors: true,\n          errorPrefix: 'FlowDiagram Validation Error',\n        }\n      );\n\n      // Validate and transform data\n      const nodeResult: ValidationTransformResult<FlowNode[]> = validation.validateNodes(data);\n      const linkResult: ValidationTransformResult<FlowLink[]> = validation.validateLinks(data);\n\n      // Handle validation errors\n      if (!nodeResult.valid || !linkResult.valid) {\n        console.warn(\n          'Flow data validation failed:',\n          [...nodeResult.errors, ...linkResult.errors].join('\\n')\n        );\n      }\n\n      // Create a map for node lookups (using validated nodes)\n      const nodeMap = new Map<string, FlowNode>();\n      nodeResult.data?.forEach(node => nodeMap.set(node.id, node));\n\n      return {\n        nodes: nodeResult.data,\n        links: linkResult.data,\n        nodeMap,\n        valid: nodeResult.valid && linkResult.valid,\n        errors: [...nodeResult.errors, ...linkResult.errors],\n      };\n    } catch (error) {\n      console.error('Error preparing visualization data:', error);\n      return {\n        nodes: [],\n        links: [],\n        nodeMap: new Map(),\n        valid: false,\n        errors: ['Error preparing visualization data'],\n      };\n    }\n  }, [data]);\n\n  /**\n   * Handle node click events with proper typing\n   */\n  const handleNodeClick = useCallback(\n    (event: React.MouseEvent, node: FlowNode) => {\n      setSelectedNodeId(prevId => (prevId === node.id ? null : node.id));\n\n      if (onNodeClick && node.data) {\n        onNodeClick(node.id, node.data);\n      }\n    },\n    [onNodeClick]\n  );\n\n  /**\n   * Handle link click events with proper typing\n   */\n  const handleLinkClick = useCallback(\n    (event: React.MouseEvent, link: FlowLink) => {\n      if (typeof link.source === 'string' || typeof link.target === 'string') {\n        return; // Ignore links that don't have resolved nodes\n      }\n\n      setSelectedLinkId(prevId => (prevId === link.id ? null : link.id));\n\n      // Find the original link data for the callback\n      const linkData = data?.links.find(l => l.id === link.id);\n      if (onLinkClick && linkData) {\n        onLinkClick(link.id, linkData);\n      }\n    },\n    [data?.links, onLinkClick]\n  );\n\n  /**\n   * Create and update the visualization\n   */\n  useEffect(() => {\n    if (!svgRef.current || !data) return;\n\n    // Clean up previous simulation if it exists\n    if (simulationRef.current) {\n      simulationRef.current.stop();\n    }\n\n    // Get SVG element with proper typing\n    const svg = d3.select<SVGSVGElement, unknown>(svgRef.current);\n\n    // Clear previous content\n    svg.selectAll('*').remove();\n\n    // Prepare data with type safety\n    const { nodes, links, nodeMap } = prepareVisualizationData();\n\n    // Create container group for zooming\n    const container = svg.append('g').attr('class', 'container');\n\n    // Add zoom behavior if interactive\n    if (interactive) {\n      const zoom = d3\n        .zoom<SVGSVGElement, unknown>()\n        .scaleExtent([0.1, 4])\n        .on('zoom', event => {\n          container.attr('transform', event?.transform);\n        });\n\n      svg.call(zoom);\n    }\n\n    // Create arrow markers for links\n    const defs = container.append('defs');\n\n    // Create a basic arrow marker\n    defs\n      .append('marker')\n      .attr('id', 'arrowhead')\n      .attr('viewBox', '-10 -5 10 10')\n      .attr('refX', 0)\n      .attr('refY', 0)\n      .attr('orient', 'auto')\n      .attr('markerWidth', 8)\n      .attr('markerHeight', 8)\n      .append('path')\n      .attr('d', 'M-10,-5L0,0L-10,5')\n      .attr('fill', '#777');\n\n    // Create colored arrow markers\n    ['active', 'inactive', 'high', 'medium', 'low'].forEach(type => {\n      let color: string;\n      switch (type) {\n        case 'active':\n          color = '#3b82f6';\n          break;\n        case 'inactive':\n          color = '#94a3b8';\n          break;\n        case 'high':\n          color = '#ef4444';\n          break;\n        case 'medium':\n          color = '#f59e0b';\n          break;\n        case 'low':\n          color = '#10b981';\n          break;\n        default:\n          color = '#777';\n      }\n\n      defs\n        .append('marker')\n        .attr('id', `arrowhead-${type}`)\n        .attr('viewBox', '-10 -5 10 10')\n        .attr('refX', 0)\n        .attr('refY', 0)\n        .attr('orient', 'auto')\n        .attr('markerWidth', 8)\n        .attr('markerHeight', 8)\n        .append('path')\n        .attr('d', 'M-10,-5L0,0L-10,5')\n        .attr('fill', color);\n    });\n\n    // Create D3 force simulation with proper typing\n    const simulation = d3\n      .forceSimulation<FlowNode, FlowLink>(nodes)\n      .force(\n        'link',\n        d3\n          .forceLink<FlowNode, FlowLink>(links)\n          .id(d => d.id)\n          .distance(100)\n      )\n      .force('charge', d3.forceManyBody().strength(-200))\n      .force('center', d3.forceCenter(width / 2, height / 2))\n      .force(\n        'collision',\n        d3.forceCollide<FlowNode>().radius(d => (d.radius || 20) + 10)\n      );\n\n    // Store simulation reference for cleanup\n    simulationRef.current = simulation;\n\n    // Create links with proper typing\n    const link = container\n      .append('g')\n      .attr('class', 'links')\n      .selectAll<SVGLineElement, FlowLink>('line')\n      .data(links)\n      .enter()\n      .append('line')\n      .attr('class', d => `link ${d.active ? 'active' : 'inactive'}`)\n      .attr('stroke', d => d.color || '#999')\n      .attr('stroke-width', d => d.width || 1)\n      .attr('marker-end', d => {\n        // Determine marker based on link properties\n        if (!d.active) return 'url(#arrowhead-inactive)';\n        if (d.utilization && d.utilization > 0.8) return 'url(#arrowhead-high)';\n        if (d.utilization && d.utilization > 0.5) return 'url(#arrowhead-medium)';\n        return 'url(#arrowhead-active)';\n      })\n      .style('cursor', onLinkClick ? 'pointer' : 'default')\n      .on('click', function (event, d) {\n        if (onLinkClick) {\n          handleLinkClick(event, d);\n        }\n      });\n\n    // Create nodes with proper typing\n    const node = container\n      .append('g')\n      .attr('class', 'nodes')\n      .selectAll<SVGGElement, FlowNode>('g')\n      .data(nodes)\n      .enter()\n      .append('g')\n      .attr('class', 'node')\n      .style('cursor', onNodeClick ? 'pointer' : 'default')\n      .call(\n        d3\n          .drag<SVGGElement, FlowNode>()\n          .on('start', dragStarted)\n          .on('drag', dragged)\n          .on('end', dragEnded)\n      )\n      .on('click', function (event, d) {\n        if (onNodeClick) {\n          handleNodeClick(event, d);\n        }\n      });\n\n    // Add circles to nodes\n    node\n      .append('circle')\n      .attr('r', d => d.radius || 20)\n      .attr('fill', d => d.color || '#999')\n      .attr('stroke', '#fff')\n      .attr('stroke-width', 1.5);\n\n    // Add node labels\n    node\n      .append('text')\n      .attr('dy', '.3em')\n      .attr('text-anchor', 'middle')\n      .attr('font-size', '10px')\n      .attr('fill', '#fff')\n      .text(d => d.name);\n\n    // Add node value labels\n    node\n      .append('text')\n      .attr('dy', '1.6em')\n      .attr('text-anchor', 'middle')\n      .attr('font-size', '9px')\n      .attr('fill', '#fff')\n      .text(d => `${d.value}${d.capacity ? `/${d.capacity}` : ''}`);\n\n    // Add hover effects with type-safe accessors\n    node\n      .on('mouseover', function (event, d) {\n        d3.select(this)\n          .select('circle')\n          .transition()\n          .duration(200)\n          .attr('r', (d.radius || 20) * 1.1);\n      })\n      .on('mouseout', function (event, d) {\n        d3.select(this)\n          .select('circle')\n          .transition()\n          .duration(200)\n          .attr('r', d.radius || 20);\n      });\n\n    // Add flow effects to links\n    if (animated) {\n      link\n        .filter(d => d.active)\n        .each(function (d) {\n          const element = d3.select(this);\n\n          // Add animated dash array for active links\n          element\n            .attr('stroke-dasharray', '5,5')\n            .style('animation', `flowAnimation ${5000 / (d.value || 1)}ms linear infinite`);\n        });\n    }\n\n    // Update positions on simulation tick with proper typing\n    simulation.on('tick', () => {\n      // Update links with safe accessors to prevent type errors\n      link\n        .attr('x1', d => {\n          const source = typeof d.source === 'string' ? findNodeById(nodes, d.source) : d.source;\n          return source ? d3Accessors.getX(source) : 0;\n        })\n        .attr('y1', d => {\n          const source = typeof d.source === 'string' ? findNodeById(nodes, d.source) : d.source;\n          return source ? d3Accessors.getY(source) : 0;\n        })\n        .attr('x2', d => {\n          const target = typeof d.target === 'string' ? findNodeById(nodes, d.target) : d.target;\n          return target ? d3Accessors.getX(target) : 0;\n        })\n        .attr('y2', d => {\n          const target = typeof d.target === 'string' ? findNodeById(nodes, d.target) : d.target;\n          return target ? d3Accessors.getY(target) : 0;\n        });\n\n      // Update nodes with safe transforms\n      node.attr('transform', d => {\n        const x = d3Accessors.getX(d);\n        const y = d3Accessors.getY(d);\n        return `translate(${x}, ${y})`;\n      });\n    });\n\n    // Type-safe drag functions\n    function dragStarted(event: d3.D3DragEvent<SVGGElement, FlowNode, FlowNode>, d: FlowNode) {\n      if (!event?.active) simulation.alphaTarget(0.3).restart();\n      d.fx = d3Accessors.getX(d);\n      d.fy = d3Accessors.getY(d);\n    }\n\n    function dragged(event: d3.D3DragEvent<SVGGElement, FlowNode, FlowNode>, d: FlowNode) {\n      d.fx = event?.x;\n      d.fy = event?.y;\n    }\n\n    function dragEnded(event: d3.D3DragEvent<SVGGElement, FlowNode, FlowNode>, d: FlowNode) {\n      if (!event?.active) simulation.alphaTarget(0);\n      if (!interactive) {\n        d.fx = null;\n        d.fy = null;\n      }\n    }\n\n    // Cleanup function\n    return () => {\n      if (simulationRef.current) {\n        simulationRef.current.stop();\n      }\n    };\n  }, [\n    data,\n    width,\n    height,\n    interactive,\n    animated,\n    prepareVisualizationData,\n    handleNodeClick,\n    handleLinkClick,\n    onNodeClick,\n    onLinkClick,\n  ]);\n\n  return (\n    <div className={`flow-diagram-container ${className}`}>\n      {/* Add CSS for animation */}\n      {animated && (\n        <style>\n          {`\n            @keyframes flowAnimation {\n              from {\n                stroke-dashoffset: 20;\n              }\n              to {\n                stroke-dashoffset: 0;\n              }\n            }\n          `}\n        </style>\n      )}\n      <svg ref={svgRef} width={width} height={height} className=\"flow-diagram-svg\" />\n    </div>\n  );\n};\n\nexport default FlowDiagram;\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/visualization/FlowDiagramDemo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/visualization/HeatMapDensityVisualization.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'canvasRef' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":97,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":97,"endColumn":18}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as React from 'react';\nimport { useMemo, useRef } from 'react';\nimport {\n  DataVisualizationShaderType,\n  ShaderUniform,\n} from '../../../lib/optimization/WebGLShaderManager';\nimport {\n  DataHighlightVisualization,\n  DataHighlightVisualizationProps,\n} from './DataHighlightVisualization';\n\n/**\n * Kernel density estimation method\n */\nexport enum KernelType {\n  GAUSSIAN = 'gaussian',\n  EPANECHNIKOV = 'epanechnikov',\n  UNIFORM = 'uniform',\n  TRIANGULAR = 'triangular',\n  COSINE = 'cosine',\n}\n\n/**\n * Enhanced props for heat map density visualization\n */\nexport interface HeatMapDensityVisualizationProps\n  extends Omit<DataHighlightVisualizationProps, 'visualizationType'> {\n  /**\n   * Bandwidth for kernel density estimation (affects smoothness)\n   * Higher values create smoother heatmaps with less detail\n   * Lower values create more detailed heatmaps but may introduce noise\n   */\n  bandwidth?: number;\n\n  /**\n   * Kernel type for density estimation\n   */\n  kernelType?: KernelType;\n\n  /**\n   * Number of interpolation steps between data points\n   * Higher values create smoother gradients but reduce performance\n   */\n  interpolationSteps?: number;\n\n  /**\n   * Range of the radius around each point where the heat spreads\n   * As a percentage of the visualization dimensions\n   */\n  heatRadius?: number;\n\n  /**\n   * Whether to use logarithmic scale for intensity\n   * Useful for datasets with high variance\n   */\n  useLogScale?: boolean;\n\n  /**\n   * Contour levels to show on the heatmap\n   * Values between 0 and 1 representing intensity thresholds\n   */\n  contourLevels?: number[];\n\n  /**\n   * Whether to show a grid overlay\n   */\n  showGrid?: boolean;\n\n  /**\n   * Grid cell size as a fraction of the visualization dimensions\n   */\n  gridSize?: number;\n}\n\n/**\n * HeatMapDensityVisualization Component\n *\n * A specialized component for rendering density-based heat maps using WebGL shaders.\n * Provides advanced configuration options for kernel density estimation and heat map rendering.\n */\nexport const HeatMapDensityVisualization: React.FC<HeatMapDensityVisualizationProps> = ({\n  data,\n  width,\n  height,\n  colors = ['#000080', '#0000ff', '#00ffff', '#ffff00', '#ff0000'],\n  bandwidth = 0.1,\n  kernelType = KernelType.GAUSSIAN,\n  interpolationSteps = 32,\n  heatRadius = 0.15,\n  useLogScale = false,\n  contourLevels = [],\n  showGrid = false,\n  gridSize = 0.05,\n  ...restProps\n}) => {\n  // Canvas ref for custom pre-rendering if needed\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n\n  // Process data for density visualization\n  const processedData = useMemo(() => {\n    // For basic usage, we can just return the data\n    // In a more advanced implementation, we might preprocess the data\n    // to optimize for density visualization\n    return data;\n  }, [data]);\n\n  // Prepare custom shader uniforms for the heat map visualization\n  const customUniforms = useMemo(() => {\n    const uniforms: Record<string, ShaderUniform> = {\n      u_bandwidth: {\n        type: 'float',\n        value: bandwidth,\n      },\n      u_heatRadius: {\n        type: 'float',\n        value: heatRadius,\n      },\n      u_interpolationSteps: {\n        type: 'float',\n        value: interpolationSteps,\n      },\n      u_useLogScale: {\n        type: 'int',\n        value: useLogScale ? 1 : 0,\n      },\n      u_kernelType: {\n        type: 'int',\n        value: Object.values(KernelType).indexOf(kernelType),\n      },\n      u_showGrid: {\n        type: 'int',\n        value: showGrid ? 1 : 0,\n      },\n      u_gridSize: {\n        type: 'float',\n        value: gridSize,\n      },\n    };\n\n    // Add contour levels if provided\n    if (contourLevels.length > 0) {\n      const levels = new Float32Array(Math.min(contourLevels.length, 10));\n      contourLevels.slice(0, 10).forEach((level, i) => {\n        levels[i] = level;\n      });\n\n      uniforms.u_contourLevels = {\n        type: 'float',\n        value: levels,\n      };\n\n      uniforms.u_contourLevelCount = {\n        type: 'int',\n        value: contourLevels.length,\n      };\n    }\n\n    return uniforms;\n  }, [\n    bandwidth,\n    heatRadius,\n    interpolationSteps,\n    useLogScale,\n    kernelType,\n    contourLevels,\n    showGrid,\n    gridSize,\n  ]);\n\n  // Custom fragment shader code for enhanced heat map rendering\n  const getCustomFragmentShader = (): string => {\n    return `\n      precision mediump float;\n      \n      uniform vec3 u_colors[5];\n      uniform int u_colorCount;\n      uniform float u_intensity;\n      uniform float u_time;\n      uniform vec2 u_highlightRange;\n      uniform float u_bandwidth;\n      uniform float u_heatRadius;\n      uniform float u_interpolationSteps;\n      uniform int u_useLogScale;\n      uniform int u_kernelType;\n      uniform int u_contourLevelCount;\n      uniform float u_contourLevels[10];\n      uniform int u_showGrid;\n      uniform float u_gridSize;\n      \n      varying float v_data;\n      varying vec2 v_position;\n      varying float v_time;\n      \n      // Helper function to interpolate colors\n      vec3 getColor(float value) {\n        if (u_colorCount == 1) return u_colors[0];\n        \n        float indexFloat = value * float(u_colorCount - 1);\n        int index = int(floor(indexFloat));\n        float t = fract(indexFloat);\n        \n        if (index >= u_colorCount - 1) {\n          return u_colors[u_colorCount - 1];\n        }\n        \n        return mix(u_colors[index], u_colors[index + 1], t);\n      }\n      \n      // Kernel functions for density estimation\n      float gaussianKernel(float distance, float bandwidth) {\n        float x = distance / bandwidth;\n        return exp(-0.5 * x * x);\n      }\n      \n      float epanechnikovKernel(float distance, float bandwidth) {\n        float x = distance / bandwidth;\n        if (abs(x) <= 1.0) {\n          return 0.75 * (1.0 - x * x);\n        }\n        return 0.0;\n      }\n      \n      float uniformKernel(float distance, float bandwidth) {\n        return distance <= bandwidth ? 1.0 : 0.0;\n      }\n      \n      float triangularKernel(float distance, float bandwidth) {\n        float x = distance / bandwidth;\n        return abs(x) <= 1.0 ? 1.0 - abs(x) : 0.0;\n      }\n      \n      float cosineKernel(float distance, float bandwidth) {\n        float x = distance / bandwidth;\n        return abs(x) <= 1.0 ? (cos(x * 3.14159) + 1.0) * 0.5 : 0.0;\n      }\n      \n      // Apply kernel based on type\n      float applyKernel(float distance, float bandwidth) {\n        if (u_kernelType == 0) {\n          return gaussianKernel(distance, bandwidth);\n        } else if (u_kernelType == 1) {\n          return epanechnikovKernel(distance, bandwidth);\n        } else if (u_kernelType == 2) {\n          return uniformKernel(distance, bandwidth);\n        } else if (u_kernelType == 3) {\n          return triangularKernel(distance, bandwidth);\n        } else if (u_kernelType == 4) {\n          return cosineKernel(distance, bandwidth);\n        }\n        return gaussianKernel(distance, bandwidth);\n      }\n      \n      // Draw grid lines\n      float drawGrid(vec2 position, float cellSize) {\n        vec2 grid = fract(position / cellSize);\n        float line = step(0.98, grid.x) + step(0.98, grid.y);\n        return min(line, 1.0) * 0.2;\n      }\n      \n      void main() {\n        // Get base color from data value\n        float dataValue = v_data;\n        \n        // Apply log scale if enabled\n        if (u_useLogScale == 1 && dataValue > 0.0) {\n          dataValue = log(1.0 + dataValue * 9.0) / log(10.0);\n        }\n        \n        // Get color based on data value\n        vec3 color = getColor(dataValue);\n        float alpha = u_intensity;\n        \n        // Adjust based on distance from center point\n        float dist = length(gl_PointCoord - vec2(0.5));\n        float heatValue = applyKernel(dist, u_bandwidth);\n        \n        // Fade out at edges\n        alpha *= heatValue;\n        \n        // Add contour lines if specified\n        if (u_contourLevelCount > 0) {\n          for (int i = 0; i < 10; i++) {\n            if (i >= u_contourLevelCount) break;\n            \n            float level = u_contourLevels[i];\n            float contourWidth = 0.02;\n            if (abs(dataValue - level) < contourWidth) {\n              color = mix(color, vec3(1.0), 0.5);\n              alpha = mix(alpha, 1.0, 0.5);\n            }\n          }\n        }\n        \n        // Apply highlight effect if in range\n        if (dataValue >= u_highlightRange.x && dataValue <= u_highlightRange.y) {\n          // Pulse effect\n          float pulse = 0.5 + 0.5 * sin(u_time * 3.0);\n          \n          // Brighten color and add glow\n          color = mix(color, vec3(1.0), pulse * 0.3);\n          alpha = mix(alpha, 1.0, pulse * 0.4);\n        }\n        \n        // Apply grid overlay if enabled\n        if (u_showGrid == 1) {\n          float gridOverlay = drawGrid(v_position, u_gridSize);\n          color = mix(color, vec3(1.0), gridOverlay);\n        }\n        \n        gl_FragColor = vec4(color, alpha);\n      }\n    `;\n  };\n\n  // Re-render whenever custom parameters change\n  const customShaderConfig = useMemo(\n    () => ({\n      customUniforms,\n      fragmentShader: getCustomFragmentShader(),\n    }),\n    [customUniforms]\n  );\n\n  return (\n    <DataHighlightVisualization\n      data={processedData}\n      width={width}\n      height={height}\n      visualizationType={DataVisualizationShaderType.HEATMAP}\n      colors={colors}\n      shaderConfig={customShaderConfig}\n      {...restProps}\n    />\n  );\n};\n\n// Preset configurations for common heat map use cases\nexport const HeatMapDensityPresets = {\n  /**\n   * Population density preset - optimized for showing clusters\n   */\n  populationDensity: (\n    props: Omit<HeatMapDensityVisualizationProps, 'kernelType' | 'colors' | 'bandwidth'>\n  ): HeatMapDensityVisualizationProps => ({\n    ...props,\n    kernelType: KernelType.GAUSSIAN,\n    colors: ['#f7fbff', '#deebf7', '#c6dbef', '#9ecae1', '#3182bd'],\n    bandwidth: 0.1,\n    heatRadius: 0.2,\n    useLogScale: true,\n  }),\n\n  /**\n   * Resource concentration preset - shows where resources are concentrated\n   */\n  resourceConcentration: (\n    props: Omit<HeatMapDensityVisualizationProps, 'kernelType' | 'colors' | 'bandwidth'>\n  ): HeatMapDensityVisualizationProps => ({\n    ...props,\n    kernelType: KernelType.EPANECHNIKOV,\n    colors: ['#ffffcc', '#c7e9b4', '#7fcdbb', '#41b6c4', '#225ea8'],\n    bandwidth: 0.08,\n    interpolationSteps: 64,\n    contourLevels: [0.2, 0.4, 0.6, 0.8],\n  }),\n\n  /**\n   * Anomaly detection preset - highlights outliers\n   */\n  anomalyDetection: (\n    props: Omit<HeatMapDensityVisualizationProps, 'kernelType' | 'colors' | 'bandwidth'>\n  ): HeatMapDensityVisualizationProps => ({\n    ...props,\n    kernelType: KernelType.GAUSSIAN,\n    colors: ['#f7f7f7', '#d9d9d9', '#bdbdbd', '#969696', '#525252'],\n    bandwidth: 0.05,\n    highlightRange: [0.9, 1.0],\n    useLogScale: false,\n    showGrid: true,\n    gridSize: 0.1,\n  }),\n\n  /**\n   * Performance analysis preset - visualizes performance metrics\n   */\n  performanceAnalysis: (\n    props: Omit<HeatMapDensityVisualizationProps, 'kernelType' | 'colors' | 'bandwidth'>\n  ): HeatMapDensityVisualizationProps => ({\n    ...props,\n    kernelType: KernelType.TRIANGULAR,\n    colors: ['#edf8e9', '#c7e9c0', '#a1d99b', '#74c476', '#238b45'],\n    bandwidth: 0.12,\n    interpolationSteps: 48,\n    contourLevels: [0.3, 0.6, 0.9],\n  }),\n\n  /**\n   * Time-series heat map preset - for temporal data analysis\n   */\n  timeSeriesAnalysis: (\n    props: Omit<HeatMapDensityVisualizationProps, 'kernelType' | 'colors' | 'bandwidth'>\n  ): HeatMapDensityVisualizationProps => ({\n    ...props,\n    kernelType: KernelType.COSINE,\n    colors: ['#f7fcf5', '#e5f5e0', '#c7e9c0', '#74c476', '#238b45'],\n    bandwidth: 0.1,\n    interpolationSteps: 32,\n    useLogScale: false,\n    animate: true,\n    animationSpeed: 0.8,\n  }),\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/visualization/ParticleTransitionVisualization.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_deltaTime' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":344,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":344,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as React from 'react';\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport {\n  DataPoint,\n  EasingFunction,\n  EasingType,\n  Particle,\n  ParticleBlendMode,\n  ParticlePath,\n  ParticleSystem,\n} from '../../../lib/visualization/ParticleSystem';\n\n/**\n * Rendering method for the particle visualization\n */\nexport enum RenderMethod {\n  CANVAS = 'canvas',\n  SVG = 'svg',\n  DOM = 'dom',\n}\n\nexport interface ParticleTransitionVisualizationProps {\n  /**\n   * Initial data state\n   */\n  initialData: DataPoint[];\n\n  /**\n   * Target data state to transition to\n   */\n  targetData?: DataPoint[];\n\n  /**\n   * Width of the visualization\n   */\n  width: number;\n\n  /**\n   * Height of the visualization\n   */\n  height: number;\n\n  /**\n   * Transition duration in milliseconds\n   */\n  duration?: number;\n\n  /**\n   * Easing function or type for the transition\n   */\n  easing?: EasingFunction | EasingType;\n\n  /**\n   * Path type for particle movement\n   */\n  path?: ParticlePath;\n\n  /**\n   * Additional path parameters\n   */\n  pathParams?: Record<string, number>;\n\n  /**\n   * Delay between particle transitions in milliseconds\n   */\n  staggerDelay?: number;\n\n  /**\n   * Whether to transition colors\n   */\n  transitionColors?: boolean;\n\n  /**\n   * Whether to draw trail effects\n   */\n  drawTrails?: boolean;\n\n  /**\n   * Length of trails (0-1)\n   */\n  trailLength?: number;\n\n  /**\n   * Rendering method\n   */\n  renderMethod?: RenderMethod;\n\n  /**\n   * Callback when transition is complete\n   */\n  onTransitionComplete?: () => void;\n\n  /**\n   * Callback when transition is updated\n   */\n  onTransitionUpdate?: (progress: number) => void;\n\n  /**\n   * Optional className\n   */\n  className?: string;\n\n  /**\n   * Whether to auto-play the transition\n   */\n  autoPlay?: boolean;\n\n  /**\n   * Whether to loop the transition\n   */\n  loop?: boolean;\n\n  /**\n   * Whether to ping-pong the transition (forward then backward)\n   */\n  pingPong?: boolean;\n\n  /**\n   * Blend mode for particles\n   */\n  blendMode?: ParticleBlendMode;\n\n  /**\n   * Optional background color\n   */\n  backgroundColor?: string;\n}\n\n/**\n * ParticleTransitionVisualization\n *\n * A component that visualizes animated transitions between data states using a particle system.\n * Supports various transition paths, easing functions, and rendering methods.\n */\nexport const ParticleTransitionVisualization: React.FC<ParticleTransitionVisualizationProps> = ({\n  initialData,\n  targetData,\n  width,\n  height,\n  duration = 1000,\n  easing = EasingType.EASE_IN_OUT,\n  path = ParticlePath.LINEAR,\n  pathParams,\n  staggerDelay = 20,\n  transitionColors = true,\n  drawTrails = false,\n  trailLength = 0.3,\n  renderMethod = RenderMethod.CANVAS,\n  onTransitionComplete,\n  onTransitionUpdate,\n  className = '',\n  autoPlay = true,\n  loop = false,\n  pingPong = false,\n  blendMode = ParticleBlendMode.ADD,\n  backgroundColor = 'transparent',\n}) => {\n  // References\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const svgRef = useRef<SVGSVGElement>(null);\n  const domRef = useRef<HTMLDivElement>(null);\n  const particleSystemRef = useRef<ParticleSystem | null>(null);\n  const animationFrameRef = useRef<number | null>(null);\n  const lastFrameTimeRef = useRef<number>(0);\n\n  // State\n  const [isPlaying, setIsPlaying] = useState(autoPlay);\n  const [transitionProgress, setTransitionProgress] = useState(0);\n  const [currentDirection, setCurrentDirection] = useState<'forward' | 'backward'>('forward');\n  const [renderedParticles, setRenderedParticles] = useState<JSX.Element[]>([]);\n\n  // Initialize particle system\n  useEffect(() => {\n    // Clean up any existing system\n    if (particleSystemRef.current) {\n      particleSystemRef.current.dispose();\n    }\n\n    // Create new system\n    particleSystemRef.current = new ParticleSystem();\n\n    // Set up transition\n    const transitionId = 'main-transition';\n    particleSystemRef.current.setupTransition(transitionId, {\n      id: transitionId,\n      sourceData: initialData,\n      targetData: targetData || initialData,\n      duration,\n      easing,\n      path,\n      pathParams,\n      staggerDelay,\n      transitionColors,\n      onComplete: () => {\n        onTransitionComplete?.();\n\n        if (loop) {\n          // Handle ping-pong looping\n          if (pingPong) {\n            // Swap direction\n            setCurrentDirection(prevDirection =>\n              prevDirection === 'forward' ? 'backward' : 'forward'\n            );\n          }\n\n          // Restart the transition after a small delay\n          setTimeout(() => {\n            if (particleSystemRef.current) {\n              const ps = particleSystemRef.current;\n\n              if (pingPong && currentDirection === 'backward') {\n                // Reverse the transition for ping-pong\n                ps.setupTransition(transitionId, {\n                  id: transitionId,\n                  sourceData: targetData || initialData,\n                  targetData: initialData,\n                  duration,\n                  easing,\n                  path,\n                  pathParams,\n                  staggerDelay,\n                  transitionColors,\n                  onComplete: onTransitionComplete,\n                  onUpdate: onTransitionUpdate,\n                });\n              } else {\n                // Regular forward transition\n                ps.setupTransition(transitionId, {\n                  id: transitionId,\n                  sourceData: initialData,\n                  targetData: targetData || initialData,\n                  duration,\n                  easing,\n                  path,\n                  pathParams,\n                  staggerDelay,\n                  transitionColors,\n                  onComplete: onTransitionComplete,\n                  onUpdate: onTransitionUpdate,\n                });\n              }\n\n              ps.startTransition(transitionId);\n            }\n          }, 500);\n        }\n      },\n      onUpdate: progress => {\n        setTransitionProgress(progress);\n        onTransitionUpdate?.(progress);\n      },\n    });\n\n    // Start animation loop\n    if (isPlaying) {\n      particleSystemRef.current.startTransition('main-transition');\n    }\n\n    // Start render loop based on selected method\n    startRenderLoop();\n\n    // Cleanup\n    return () => {\n      stopRenderLoop();\n      if (particleSystemRef.current) {\n        particleSystemRef.current.dispose();\n      }\n    };\n  }, [\n    initialData,\n    targetData,\n    duration,\n    easing,\n    path,\n    pathParams,\n    staggerDelay,\n    transitionColors,\n    isPlaying,\n    onTransitionComplete,\n    onTransitionUpdate,\n    loop,\n    pingPong,\n    currentDirection,\n  ]);\n\n  // Control playback\n  const startTransition = useCallback(() => {\n    if (particleSystemRef.current && !isPlaying) {\n      particleSystemRef.current.startTransition('main-transition');\n      setIsPlaying(true);\n    }\n  }, [isPlaying]);\n\n  const pauseTransition = useCallback(() => {\n    if (particleSystemRef.current && isPlaying) {\n      particleSystemRef.current.stopTransition('main-transition');\n      setIsPlaying(false);\n    }\n  }, [isPlaying]);\n\n  const resetTransition = useCallback(() => {\n    if (particleSystemRef.current) {\n      const ps = particleSystemRef.current;\n      ps.stopTransition('main-transition');\n\n      // Re-setup the transition\n      ps.setupTransition('main-transition', {\n        id: 'main-transition',\n        sourceData: initialData,\n        targetData: targetData || initialData,\n        duration,\n        easing,\n        path,\n        pathParams,\n        staggerDelay,\n        transitionColors,\n        onComplete: onTransitionComplete,\n        onUpdate: onTransitionUpdate,\n      });\n\n      setIsPlaying(false);\n      setTransitionProgress(0);\n      setCurrentDirection('forward');\n    }\n  }, [\n    initialData,\n    targetData,\n    duration,\n    easing,\n    path,\n    pathParams,\n    staggerDelay,\n    transitionColors,\n    onTransitionComplete,\n    onTransitionUpdate,\n  ]);\n\n  // Start the render loop based on the selected method\n  const startRenderLoop = useCallback(() => {\n    stopRenderLoop();\n\n    // Start animation loop\n    const renderLoop = (timestamp: number) => {\n      const _deltaTime = timestamp - lastFrameTimeRef.current;\n      lastFrameTimeRef.current = timestamp;\n\n      renderFrame();\n\n      animationFrameRef.current = requestAnimationFrame(renderLoop);\n    };\n\n    lastFrameTimeRef.current = performance.now();\n    animationFrameRef.current = requestAnimationFrame(renderLoop);\n  }, [renderMethod]);\n\n  // Stop the render loop\n  const stopRenderLoop = useCallback(() => {\n    if (animationFrameRef.current !== null) {\n      cancelAnimationFrame(animationFrameRef.current);\n      animationFrameRef.current = null;\n    }\n  }, []);\n\n  // Render a single frame\n  const renderFrame = useCallback(() => {\n    if (!particleSystemRef.current) return;\n\n    const particles = particleSystemRef.current.getParticles();\n\n    switch (renderMethod) {\n      case RenderMethod.CANVAS:\n        renderCanvasFrame(particles);\n        break;\n      case RenderMethod.SVG:\n        renderSvgFrame(particles);\n        break;\n      case RenderMethod.DOM:\n        renderDomFrame(particles);\n        break;\n    }\n  }, [renderMethod, drawTrails, trailLength, blendMode]);\n\n  // Canvas rendering\n  const renderCanvasFrame = useCallback(\n    (particles: Particle[]) => {\n      if (!canvasRef.current) return;\n\n      const canvas = canvasRef.current;\n      const ctx = canvas.getContext('2d');\n      if (!ctx) return;\n\n      // Clear canvas\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n      // Set blend mode\n      switch (blendMode) {\n        case ParticleBlendMode.ADD:\n          ctx.globalCompositeOperation = 'lighter';\n          break;\n        case ParticleBlendMode.MULTIPLY:\n          ctx.globalCompositeOperation = 'multiply';\n          break;\n        case ParticleBlendMode.SCREEN:\n          ctx.globalCompositeOperation = 'screen';\n          break;\n        default:\n          ctx.globalCompositeOperation = 'source-over';\n      }\n\n      // Draw particles\n      particles.forEach(particle => {\n        // Draw trail if enabled\n        if (drawTrails && particle.prevPosition) {\n          ctx.beginPath();\n          ctx.moveTo(particle.prevPosition.x, particle.prevPosition.y);\n          ctx.lineTo(particle.position.x, particle.position.y);\n          ctx.strokeStyle = particle.color;\n          ctx.globalAlpha = particle.opacity * 0.5;\n          ctx.lineWidth = particle.size * 0.7;\n          ctx.stroke();\n        }\n\n        // Draw particle\n        ctx.beginPath();\n        ctx.arc(particle.position.x, particle.position.y, particle.size / 2, 0, Math.PI * 2);\n        ctx.fillStyle = particle.color;\n        ctx.globalAlpha = particle.opacity;\n        ctx.fill();\n      });\n\n      // Reset composite operation\n      ctx.globalCompositeOperation = 'source-over';\n    },\n    [drawTrails, blendMode]\n  );\n\n  // SVG rendering\n  const renderSvgFrame = useCallback(\n    (particles: Particle[]) => {\n      const particleElements: JSX.Element[] = particles.map(particle => {\n        // Prepare trail if enabled\n        let trail: JSX.Element | null = null;\n        if (drawTrails && particle.prevPosition) {\n          trail = (\n            <line\n              key={`trail-${particle.id}`}\n              x1={particle.prevPosition.x}\n              y1={particle.prevPosition.y}\n              x2={particle.position.x}\n              y2={particle.position.y}\n              stroke={particle.color}\n              strokeWidth={particle.size * 0.7}\n              strokeOpacity={particle.opacity * 0.5}\n              style={{\n                mixBlendMode: blendMode.toLowerCase() as React.CSSProperties['mixBlendMode'],\n              }}\n            />\n          );\n        }\n\n        return (\n          <React.Fragment key={particle.id}>\n            {trail}\n            <circle\n              cx={particle.position.x}\n              cy={particle.position.y}\n              r={particle.size / 2}\n              fill={particle.color}\n              fillOpacity={particle.opacity}\n              style={{\n                mixBlendMode: blendMode.toLowerCase() as React.CSSProperties['mixBlendMode'],\n              }}\n            />\n          </React.Fragment>\n        );\n      });\n\n      setRenderedParticles(particleElements);\n    },\n    [drawTrails, blendMode]\n  );\n\n  // DOM rendering\n  const renderDomFrame = useCallback(\n    (particles: Particle[]) => {\n      const particleElements: JSX.Element[] = particles.map(particle => (\n        <div\n          key={particle.id}\n          style={{\n            position: 'absolute',\n            left: particle.position.x,\n            top: particle.position.y,\n            width: particle.size,\n            height: particle.size,\n            borderRadius: '50%',\n            backgroundColor: particle.color,\n            opacity: particle.opacity,\n            transform: 'translate(-50%, -50%)',\n            mixBlendMode: blendMode.toLowerCase() as React.CSSProperties['mixBlendMode'],\n            transition: 'none',\n            pointerEvents: 'none',\n          }}\n        />\n      ));\n\n      setRenderedParticles(particleElements);\n    },\n    [blendMode]\n  );\n\n  // Handle window resize\n  useEffect(() => {\n    const handleResize = () => {\n      if (canvasRef.current) {\n        canvasRef.current.width = width;\n        canvasRef.current.height = height;\n      }\n    };\n\n    handleResize();\n    window.addEventListener('resize', handleResize);\n\n    return () => {\n      window.removeEventListener('resize', handleResize);\n    };\n  }, [width, height]);\n\n  // Render the appropriate visualization based on the render method\n  const renderVisualization = useMemo(() => {\n    switch (renderMethod) {\n      case RenderMethod.CANVAS:\n        return (\n          <canvas\n            ref={canvasRef}\n            width={width}\n            height={height}\n            className={`particle-canvas ${className}`}\n            style={{ backgroundColor }}\n          />\n        );\n      case RenderMethod.SVG:\n        return (\n          <svg\n            ref={svgRef}\n            width={width}\n            height={height}\n            className={`particle-svg ${className}`}\n            style={{ backgroundColor }}\n          >\n            {renderedParticles}\n          </svg>\n        );\n      case RenderMethod.DOM:\n        return (\n          <div\n            ref={domRef}\n            className={`particle-dom ${className}`}\n            style={{\n              position: 'relative',\n              width: `${width}px`,\n              height: `${height}px`,\n              overflow: 'hidden',\n              backgroundColor,\n            }}\n          >\n            {renderedParticles}\n          </div>\n        );\n    }\n  }, [renderMethod, width, height, className, backgroundColor, renderedParticles]);\n\n  // Control buttons for the visualization\n  const renderControls = useMemo(() => {\n    return (\n      <div className=\"absolute bottom-2 right-2 flex space-x-2\">\n        {!isPlaying ? (\n          <button\n            onClick={startTransition}\n            className=\"rounded bg-blue-500 p-1 text-white\"\n            title=\"Play\"\n          >\n            <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" width=\"24\" height=\"24\">\n              <path fill=\"currentColor\" d=\"M8 5v14l11-7z\" />\n            </svg>\n          </button>\n        ) : (\n          <button\n            onClick={pauseTransition}\n            className=\"rounded bg-blue-500 p-1 text-white\"\n            title=\"Pause\"\n          >\n            <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" width=\"24\" height=\"24\">\n              <path fill=\"currentColor\" d=\"M6 19h4V5H6v14zm8-14v14h4V5h-4z\" />\n            </svg>\n          </button>\n        )}\n        <button\n          onClick={resetTransition}\n          className=\"rounded bg-gray-500 p-1 text-white\"\n          title=\"Reset\"\n        >\n          <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" width=\"24\" height=\"24\">\n            <path\n              fill=\"currentColor\"\n              d=\"M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z\"\n            />\n          </svg>\n        </button>\n      </div>\n    );\n  }, [isPlaying, startTransition, pauseTransition, resetTransition]);\n\n  // Progress indicator\n  const renderProgressIndicator = useMemo(() => {\n    return (\n      <div className=\"absolute bottom-2 left-2 h-4 w-32 overflow-hidden rounded bg-gray-200\">\n        <div\n          className=\"h-full bg-blue-500 transition-all duration-100 ease-linear\"\n          style={{ width: `${transitionProgress * 100}%` }}\n        />\n      </div>\n    );\n  }, [transitionProgress]);\n\n  return (\n    <div className=\"relative\">\n      {renderVisualization}\n      {renderControls}\n      {renderProgressIndicator}\n    </div>\n  );\n};\n\n// Export presets for common transition effects\nexport const TransitionPresets = {\n  /**\n   * Bounce transition with staggered delays\n   */\n  bounce: (\n    props: Omit<ParticleTransitionVisualizationProps, 'easing' | 'path'>\n  ): ParticleTransitionVisualizationProps => ({\n    ...props,\n    easing: EasingType.BOUNCE,\n    path: ParticlePath.CURVED,\n    staggerDelay: 30,\n    drawTrails: false,\n    blendMode: ParticleBlendMode.ADD,\n  }),\n\n  /**\n   * Spiral transition with elastic easing\n   */\n  spiral: (\n    props: Omit<ParticleTransitionVisualizationProps, 'easing' | 'path'>\n  ): ParticleTransitionVisualizationProps => ({\n    ...props,\n    easing: EasingType.ELASTIC,\n    path: ParticlePath.SPIRAL,\n    pathParams: { turns: 2 },\n    staggerDelay: 10,\n    drawTrails: true,\n    trailLength: 0.5,\n    blendMode: ParticleBlendMode.ADD,\n  }),\n\n  /**\n   * Wave transition with smooth animation\n   */\n  wave: (\n    props: Omit<ParticleTransitionVisualizationProps, 'easing' | 'path'>\n  ): ParticleTransitionVisualizationProps => ({\n    ...props,\n    easing: EasingType.EASE_IN_OUT,\n    path: ParticlePath.WAVE,\n    pathParams: { amplitude: 50, frequency: 2 },\n    staggerDelay: 15,\n    drawTrails: true,\n    trailLength: 0.2,\n    blendMode: ParticleBlendMode.SCREEN,\n  }),\n\n  /**\n   * Chaotic transition with random paths\n   */\n  chaos: (\n    props: Omit<ParticleTransitionVisualizationProps, 'easing' | 'path'>\n  ): ParticleTransitionVisualizationProps => ({\n    ...props,\n    easing: EasingType.BACK,\n    path: ParticlePath.RANDOM,\n    pathParams: { jitter: 0.3 },\n    staggerDelay: 5,\n    drawTrails: true,\n    trailLength: 0.3,\n    blendMode: ParticleBlendMode.ADD,\n  }),\n\n  /**\n   * Smooth bezier transition\n   */\n  smooth: (\n    props: Omit<ParticleTransitionVisualizationProps, 'easing' | 'path'>\n  ): ParticleTransitionVisualizationProps => ({\n    ...props,\n    easing: EasingType.EASE_OUT,\n    path: ParticlePath.BEZIER,\n    staggerDelay: 20,\n    drawTrails: false,\n    blendMode: ParticleBlendMode.NORMAL,\n  }),\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/visualization/TemporalAnalysisView.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isAnimating' is assigned a value but never used. Allowed unused elements of array destructuring must match /^_/u.","line":153,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":153,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'categoryScale' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":176,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":176,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'xAxis' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":198,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":198,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'yAxis' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":214,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":214,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'startTimestamp' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":412,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":412,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'createNodeHoverHandler' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":458,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":458,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'value' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":461,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":461,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'timestamp' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":462,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":462,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'category' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":463,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":463,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as d3 from 'd3';\nimport * as React from 'react';\nimport { useEffect, useRef, useState } from 'react';\nimport { SimulationNodeDatum } from '../../../types/visualizations/D3Types';\n\n/**\n * Represents a data point in time series\n */\ninterface TimeDataPoint {\n  timestamp: Date;\n  value: number;\n  category: string;\n  id: string;\n}\n\n/**\n * Node type for time-based animations\n * Extends SimulationNodeDatum to ensure D3 type compatibility\n */\ninterface TimeNode extends SimulationNodeDatum<TimeDataPoint> {\n  timestamp: Date;\n  value: number;\n  category: string;\n  x?: number;\n  y?: number;\n  radius?: number;\n  color?: string;\n}\n\n/**\n * Configuration options for the animation and transition settings\n */\ninterface AnimationConfig {\n  /** Duration of transitions in milliseconds */\n  transitionDuration: number;\n  /** Easing function for transitions */\n  easing: (t: number) => number;\n  /** Delay between animations in milliseconds */\n  staggerDelay: number;\n  /** Whether to loop animations */\n  loop: boolean;\n}\n\n/**\n * Props for the TemporalAnalysisView component\n */\ninterface TemporalAnalysisViewProps {\n  /**\n   * Time series data to visualize\n   */\n  data: TimeDataPoint[];\n\n  /**\n   * Width of the visualization in pixels\n   * @default 800\n   */\n  width?: number;\n\n  /**\n   * Height of the visualization in pixels\n   * @default 500\n   */\n  height?: number;\n\n  /**\n   * Margin for the visualization\n   */\n  margin?: {\n    top: number;\n    right: number;\n    bottom: number;\n    left: number;\n  };\n\n  /**\n   * Whether to show time labels\n   * @default true\n   */\n  showLabels?: boolean;\n\n  /**\n   * Animation configuration\n   */\n  animationConfig?: Partial<AnimationConfig>;\n\n  /**\n   * CSS class name for additional styling\n   */\n  className?: string;\n}\n\n/**\n * Safely converts time data to D3-compatible format\n */\nconst convertToTimeNodes = (data: TimeDataPoint[]): TimeNode[] => {\n  return data?.map(point => {\n    // Properly typed conversion with no type assertions\n    const node: TimeNode = {\n      id: point.id,\n      timestamp: point.timestamp,\n      value: point.value,\n      category: point.category,\n      // The original data field keeps the reference to the source data\n      data: point,\n    };\n\n    return node;\n  });\n};\n\n/**\n * Get color for a specific category\n */\nconst getCategoryColor = (category: string): string => {\n  // Color scale for different categories\n  const colorScale = d3.scaleOrdinal(d3.schemeCategory10);\n  return colorScale(category);\n};\n\n/**\n * Component for visualizing temporal data with smooth transitions\n */\nconst TemporalAnalysisView: React.FC<TemporalAnalysisViewProps> = ({\n  data,\n  width = 800,\n  height = 500,\n  margin = { top: 40, right: 40, bottom: 60, left: 60 },\n  showLabels = true,\n  animationConfig = {},\n  className = '',\n}) => {\n  const svgRef = useRef<SVGSVGElement | null>(null);\n\n  // Default animation config with sensible defaults\n  const defaultAnimationConfig: AnimationConfig = {\n    transitionDuration: 750,\n    easing: d3.easeCubicInOut,\n    staggerDelay: 50,\n    loop: false,\n  };\n\n  // Merge default config with provided config\n  const finalAnimationConfig: AnimationConfig = {\n    ...defaultAnimationConfig,\n    ...animationConfig,\n  };\n\n  // Chart dimensions\n  const chartWidth = width - margin.left - margin.right;\n  const chartHeight = height - margin.top - margin.bottom;\n\n  // Track animation state\n  const [isAnimating, setIsAnimating] = useState(false);\n  const [currentTimestamp, setCurrentTimestamp] = useState<Date | null>(null);\n\n  // Extract unique categories from data\n  const categories = Array.from(new Set(data?.map(d => d.category)));\n\n  // Convert data to time nodes for visualization\n  const timeNodes = convertToTimeNodes(data);\n\n  // Extract time range from data\n  const timeExtent = d3.extent(data, d => d.timestamp) as [Date, Date];\n  const valueExtent = d3.extent(data, d => d.value) as [number, number];\n\n  // Set up time scale with proper typing\n  const timeScale = d3.scaleTime<number, number>().domain(timeExtent).range([0, chartWidth]);\n\n  // Set up value scale with proper typing\n  const valueScale = d3\n    .scaleLinear<number, number>()\n    .domain([Math.min(0, valueExtent[0]), valueExtent[1]])\n    .range([chartHeight, 0]);\n\n  // Set up category scale with proper typing\n  const categoryScale = d3\n    .scaleBand<string>()\n    .domain(categories)\n    .range([0, chartHeight])\n    .padding(0.1);\n\n  /**\n   * Initialize chart\n   */\n  useEffect(() => {\n    if (!svgRef.current || !data?.length) return;\n\n    // Select SVG element with proper typing\n    const svg = d3.select<SVGSVGElement, unknown>(svgRef.current);\n\n    // Clear any existing elements\n    svg.selectAll('*').remove();\n\n    // Add chart group with margins\n    const chart = svg.append('g').attr('transform', `translate(${margin.left}, ${margin.top})`);\n\n    // Add X axis with proper typing\n    const xAxis = chart\n      .append('g')\n      .attr('class', 'x-axis')\n      .attr('transform', `translate(0, ${chartHeight})`)\n      .call(d3.axisBottom(timeScale));\n\n    // Add X axis label\n    chart\n      .append('text')\n      .attr('class', 'x-label')\n      .attr('text-anchor', 'middle')\n      .attr('x', chartWidth / 2)\n      .attr('y', chartHeight + 40)\n      .text('Time');\n\n    // Add Y axis with proper typing\n    const yAxis = chart.append('g').attr('class', 'y-axis').call(d3.axisLeft(valueScale));\n\n    // Add Y axis label\n    chart\n      .append('text')\n      .attr('class', 'y-label')\n      .attr('text-anchor', 'middle')\n      .attr('transform', 'rotate(-90)')\n      .attr('x', -chartHeight / 2)\n      .attr('y', -40)\n      .text('Value');\n\n    // Draw vertical gridlines\n    chart\n      .append('g')\n      .attr('class', 'grid x-grid')\n      .attr('transform', `translate(0, ${chartHeight})`)\n      .call(\n        d3\n          .axisBottom(timeScale)\n          .tickSize(-chartHeight)\n          .tickFormat(() => '')\n      );\n\n    // Draw horizontal gridlines\n    chart\n      .append('g')\n      .attr('class', 'grid y-grid')\n      .call(\n        d3\n          .axisLeft(valueScale)\n          .tickSize(-chartWidth)\n          .tickFormat(() => '')\n      );\n\n    // Add clip path to ensure points don't overflow\n    chart\n      .append('clipPath')\n      .attr('id', 'chart-area')\n      .append('rect')\n      .attr('width', chartWidth)\n      .attr('height', chartHeight);\n\n    // Create container for data points with clipping\n    const pointsContainer = chart\n      .append('g')\n      .attr('class', 'points-container')\n      .attr('clip-path', 'url(#chart-area)');\n\n    // Group data by category for visualization\n    const dataByCategory = d3.group(timeNodes, d => d.category);\n\n    // Add a line for each category with proper typing\n    dataByCategory.forEach((points, category) => {\n      // Sort points by timestamp for proper line drawing\n      const sortedPoints = [...points].sort(\n        (a, b) => a.timestamp.getTime() - b.timestamp.getTime()\n      );\n\n      // Line generator with type-safe accessors\n      const lineGenerator = d3\n        .line<TimeNode>()\n        .x(d => timeScale(d.timestamp))\n        .y(d => valueScale(d.value))\n        .curve(d3.curveMonotoneX);\n\n      // Add the line path with proper typing\n      pointsContainer\n        .append('path')\n        .attr('class', `line-${category}`)\n        .attr('fill', 'none')\n        .attr('stroke', getCategoryColor(category))\n        .attr('stroke-width', 2)\n        .attr('d', lineGenerator(sortedPoints));\n\n      // Add circles for each data point with proper typing\n      const circles = pointsContainer\n        .selectAll<SVGCircleElement, TimeNode>(`.point-${category}`)\n        .data(sortedPoints)\n        .enter()\n        .append('circle')\n        .attr('class', `point-${category}`)\n        .attr('cx', d => timeScale(d.timestamp))\n        .attr('cy', d => valueScale(d.value))\n        .attr('r', 0) // Start with radius 0 for entrance animation\n        .attr('fill', getCategoryColor(category))\n        .attr('stroke', '#fff')\n        .attr('stroke-width', 1);\n\n      // Add entrance animation with proper typing\n      circles\n        .transition()\n        .duration(finalAnimationConfig.transitionDuration)\n        .delay((_, i) => i * finalAnimationConfig.staggerDelay)\n        .ease(finalAnimationConfig.easing)\n        .attr('r', 5);\n\n      // Add labels if enabled\n      if (showLabels) {\n        pointsContainer\n          .selectAll<SVGTextElement, TimeNode>(`.label-${category}`)\n          .data(sortedPoints)\n          .enter()\n          .append('text')\n          .attr('class', `label-${category}`)\n          .attr('x', d => timeScale(d.timestamp))\n          .attr('y', d => valueScale(d.value) - 10)\n          .attr('text-anchor', 'middle')\n          .attr('font-size', '10px')\n          .attr('opacity', 0) // Start transparent for animation\n          .text(d => d.value.toFixed(1))\n          .transition()\n          .duration(finalAnimationConfig.transitionDuration)\n          .delay((_, i) => i * finalAnimationConfig.staggerDelay + 200)\n          .ease(finalAnimationConfig.easing)\n          .attr('opacity', 1);\n      }\n    });\n\n    // Add category legend with proper typing\n    const legend = chart\n      .append('g')\n      .attr('class', 'legend')\n      .attr('transform', `translate(${chartWidth - 100}, 0)`);\n\n    categories.forEach((category, i) => {\n      const legendItem = legend\n        .append('g')\n        .attr('class', `legend-item-${category}`)\n        .attr('transform', `translate(0, ${i * 20})`);\n\n      legendItem\n        .append('rect')\n        .attr('width', 15)\n        .attr('height', 15)\n        .attr('fill', getCategoryColor(category));\n\n      legendItem\n        .append('text')\n        .attr('x', 20)\n        .attr('y', 12)\n        .attr('font-size', '12px')\n        .text(category);\n    });\n\n    // Add time cursor for animation\n    const timeCursor = chart\n      .append('line')\n      .attr('class', 'time-cursor')\n      .attr('x1', 0)\n      .attr('y1', 0)\n      .attr('x2', 0)\n      .attr('y2', chartHeight)\n      .attr('stroke', '#666')\n      .attr('stroke-width', 1)\n      .attr('stroke-dasharray', '4,4')\n      .attr('opacity', 0);\n\n    // Add cursor timestamp label\n    const cursorLabel = chart\n      .append('text')\n      .attr('class', 'cursor-label')\n      .attr('text-anchor', 'middle')\n      .attr('font-size', '10px')\n      .attr('y', -10)\n      .attr('opacity', 0);\n\n    // Setup animation controls if needed\n    if (finalAnimationConfig.loop) {\n      setupAnimationLoop(chart, timeScale, timeCursor, cursorLabel);\n    }\n  }, [data, width, height, margin, showLabels, categories]);\n\n  /**\n   * Set up animation loop with type-safe transitions\n   */\n  const setupAnimationLoop = (\n    chart: d3.Selection<SVGGElement, unknown, null, undefined>,\n    timeScale: d3.ScaleTime<number, number>,\n    timeCursor: d3.Selection<SVGLineElement, unknown, null, undefined>,\n    cursorLabel: d3.Selection<SVGTextElement, unknown, null, undefined>\n  ) => {\n    setIsAnimating(true);\n\n    // Start and end timestamps\n    const startTime = timeExtent[0];\n    const endTime = timeExtent[1];\n    const duration = finalAnimationConfig.transitionDuration * 5;\n\n    // Animation function with proper typing\n    const animateTimeCursor = () => {\n      // Type-safe transition\n      timeCursor\n        .attr('opacity', 1)\n        .attr('x1', timeScale(startTime))\n        .attr('x2', timeScale(startTime));\n\n      // Create a custom timer for smoother animation with proper type safety\n      const startTimestamp = Date.now();\n      const timerDuration = duration;\n\n      // Use d3.timer for precise animation control with proper typing\n      const timer = d3.timer(elapsed => {\n        // Calculate progress (0 to 1)\n        const progress = Math.min(elapsed / timerDuration, 1);\n\n        // Interpolate the current timestamp\n        const currentTime = new Date(\n          startTime.getTime() + progress * (endTime.getTime() - startTime.getTime())\n        );\n\n        // Update cursor position with type-safe accessors\n        timeCursor.attr('x1', timeScale(currentTime)).attr('x2', timeScale(currentTime));\n\n        // Update cursor label with safe string formatting\n        cursorLabel\n          .attr('opacity', 1)\n          .attr('x', timeScale(currentTime))\n          .text(d3.timeFormat('%b %d, %Y')(currentTime));\n\n        // Update React state with proper typing\n        setCurrentTimestamp(currentTime);\n\n        // Stop timer when complete\n        if (progress === 1) {\n          timer.stop();\n\n          // If looping is enabled, restart after delay\n          if (finalAnimationConfig.loop) {\n            setTimeout(animateTimeCursor, 1000);\n          } else {\n            setIsAnimating(false);\n          }\n        }\n      });\n    };\n\n    // Start the animation\n    animateTimeCursor();\n  };\n\n  /**\n   * Creates a type-safe function to handle hover effects on nodes\n   */\n  const createNodeHoverHandler = () => {\n    return (event: React.MouseEvent<SVGCircleElement, MouseEvent>, node: TimeNode) => {\n      // Type-safe accessing of node data\n      const value = node.value;\n      const timestamp = node.timestamp;\n      const category = node.category;\n\n      // Safe D3 selection\n      const circle = d3.select<SVGCircleElement, TimeNode>(event?.currentTarget);\n\n      // Type-safe transition\n      circle.transition().duration(200).attr('r', 8).attr('stroke-width', 2);\n    };\n  };\n\n  return (\n    <div className={`temporal-analysis-container ${className}`}>\n      <svg ref={svgRef} width={width} height={height} className=\"temporal-analysis-svg\" />\n\n      {currentTimestamp && (\n        <div className=\"current-time-display\">\n          Current Time: {currentTimestamp.toLocaleString()}\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default TemporalAnalysisView;\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/visualization/TypeSafeVisualizationDemo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/visualization/errors/D3VisualizationErrorBoundary.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/visualization/errors/ErrorBoundaryDemo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/visualization/errors/VisualizationErrorBoundaries.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/visualizations/BarChart.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/visualizations/Chart.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'renderDataPoint' is defined but never used.","line":145,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":145,"endColumn":18}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @context: ui-system, component-library, visualization-system\n * \n * Base Chart component that provides common functionality for different chart types\n */\nimport * as React from 'react';\nimport { useRef, useEffect, useState } from 'react';\n\n// Define base types for chart data\nexport interface DataPoint {\n  label: string;\n  value: number;\n  color?: string;\n  [key: string]: string | number | boolean | undefined;\n}\n\nexport interface ChartData {\n  datasets: {\n    label: string;\n    data: DataPoint[];\n    color?: string;\n  }[];\n}\n\nexport interface ChartProps {\n  /**\n   * Chart data to display\n   */\n  data: ChartData;\n  \n  /**\n   * Width of the chart\n   * @default 300\n   */\n  width?: number;\n  \n  /**\n   * Height of the chart\n   * @default 200\n   */\n  height?: number;\n  \n  /**\n   * Chart margins\n   */\n  margin?: {\n    top: number;\n    right: number;\n    bottom: number;\n    left: number;\n  };\n  \n  /**\n   * Chart colors\n   */\n  colors?: string[];\n  \n  /**\n   * Chart background color\n   * @default 'transparent'\n   */\n  backgroundColor?: string;\n  \n  /**\n   * Whether to animate the chart\n   * @default true\n   */\n  animated?: boolean;\n  \n  /**\n   * Whether the chart is responsive\n   * @default true\n   */\n  responsive?: boolean;\n  \n  /**\n   * Value threshold to highlight\n   */\n  threshold?: number;\n  \n  /**\n   * Handler for click events on data points\n   */\n  onClick?: (dataPoint: DataPoint) => void;\n  \n  /**\n   * Custom class name\n   */\n  className?: string;\n  \n  /**\n   * Custom chart title\n   */\n  title?: string;\n  \n  /**\n   * Whether to show the legend\n   * @default true\n   */\n  showLegend?: boolean;\n  \n  /**\n   * Whether to show tooltips\n   * @default true\n   */\n  showTooltips?: boolean;\n  \n  /**\n   * Whether to show grid lines\n   * @default true\n   */\n  showGrid?: boolean;\n  \n  /**\n   * Custom chart type\n   */\n  type?: 'line' | 'bar' | 'pie' | 'doughnut' | 'area';\n  \n  /**\n   * Custom rendering function for data points\n   */\n  renderDataPoint?: (dataPoint: DataPoint, index: number) => React.ReactNode;\n}\n\n/**\n * Base Chart component that provides common functionality for different chart types\n */\nexport function Chart({\n  data,\n  width = 300,\n  height = 200,\n  margin = { top: 20, right: 20, bottom: 30, left: 40 },\n  colors = ['#4287f5', '#f44336', '#4caf50', '#ff9800', '#9c27b0', '#00bcd4'],\n  backgroundColor = 'transparent',\n  animated = true,\n  responsive = true,\n  threshold,\n  onClick,\n  className = '',\n  title,\n  showLegend = true,\n  showTooltips = true,\n  showGrid = true,\n  type = 'bar',\n  renderDataPoint,\n}: ChartProps) {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const containerRef = useRef<HTMLDivElement>(null);\n  const [tooltip, setTooltip] = useState<{ visible: boolean; x: number; y: number; content: string }>({\n    visible: false,\n    x: 0,\n    y: 0,\n    content: '',\n  });\n  const [dimensions, setDimensions] = useState({ width, height });\n  \n  // Handle responsive sizing\n  useEffect(() => {\n    if (!responsive || !containerRef.current) return;\n    \n    const resizeObserver = new ResizeObserver(entries => {\n      for (const entry of entries) {\n        const { width: newWidth } = entry.contentRect;\n        setDimensions({\n          width: newWidth,\n          height: height * (newWidth / width),\n        });\n      }\n    });\n    \n    resizeObserver.observe(containerRef.current);\n    \n    return () => {\n      resizeObserver.disconnect();\n    };\n  }, [responsive, width, height]);\n  \n  // Draw the chart on canvas\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    \n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, dimensions.width, dimensions.height);\n    \n    // Set background\n    if (backgroundColor !== 'transparent') {\n      ctx.fillStyle = backgroundColor;\n      ctx.fillRect(0, 0, dimensions.width, dimensions.height);\n    }\n    \n    // Define chart area\n    const chartArea = {\n      x: margin.left,\n      y: margin.top,\n      width: dimensions.width - margin.left - margin.right,\n      height: dimensions.height - margin.top - margin.bottom,\n    };\n    \n    // Calculate scales\n    const maxValue = Math.max(\n      ...data.datasets.flatMap(dataset => dataset.data.map(d => d.value)),\n      threshold || 0\n    );\n    \n    // Draw grid if enabled\n    if (showGrid) {\n      drawGrid(ctx, chartArea, maxValue);\n    }\n    \n    // Draw datasets\n    data.datasets.forEach((dataset, datasetIndex) => {\n      const color = dataset.color || colors[datasetIndex % colors.length];\n      \n      // Draw based on chart type\n      switch (type) {\n        case 'line':\n          drawLineChart(ctx, dataset.data, chartArea, maxValue, color);\n          break;\n        case 'bar':\n          drawBarChart(ctx, dataset.data, chartArea, maxValue, color, datasetIndex, data.datasets.length);\n          break;\n        case 'pie':\n          drawPieChart(ctx, dataset.data, chartArea, colors);\n          break;\n        case 'doughnut':\n          drawDoughnutChart(ctx, dataset.data, chartArea, colors);\n          break;\n        case 'area':\n          drawAreaChart(ctx, dataset.data, chartArea, maxValue, color);\n          break;\n      }\n    });\n    \n    // Draw threshold line if provided\n    if (threshold !== undefined) {\n      drawThresholdLine(ctx, threshold, chartArea, maxValue);\n    }\n    \n    // Draw legend if enabled\n    if (showLegend) {\n      drawLegend(ctx, data.datasets, colors, {\n        x: chartArea.x,\n        y: chartArea.y + chartArea.height + 10,\n        width: chartArea.width,\n      });\n    }\n    \n    // Draw title if provided\n    if (title) {\n      ctx.font = 'bold 14px Arial';\n      ctx.textAlign = 'center';\n      ctx.fillStyle = '#333333';\n      ctx.fillText(title, dimensions.width / 2, 15);\n    }\n  }, [data, dimensions, margin, colors, backgroundColor, animated, threshold, showLegend, showGrid, type]);\n  \n  // Handle mouse move for tooltips\n  const handleMouseMove = (e: React.MouseEvent<HTMLCanvasElement>) => {\n    if (!showTooltips) return;\n    \n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    \n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    \n    // Calculate chart area\n    const chartArea = {\n      x: margin.left,\n      y: margin.top,\n      width: dimensions.width - margin.left - margin.right,\n      height: dimensions.height - margin.top - margin.bottom,\n    };\n    \n    // Check if mouse is in chart area\n    if (\n      x >= chartArea.x && \n      x <= chartArea.x + chartArea.width && \n      y >= chartArea.y && \n      y <= chartArea.y + chartArea.height\n    ) {\n      // Find closest data point based on chart type\n      let closestPoint: DataPoint | null = null;\n      let content = '';\n      \n      // Implementation varies by chart type\n      if (type === 'bar' || type === 'line') {\n        // For simplicity, just show the first dataset that has a point close to cursor\n        const dataset = data.datasets[0];\n        const barWidth = chartArea.width / dataset.data.length;\n        const barIndex = Math.floor((x - chartArea.x) / barWidth);\n        \n        if (barIndex >= 0 && barIndex < dataset.data.length) {\n          closestPoint = dataset.data[barIndex];\n          content = `${closestPoint.label}: ${closestPoint.value}`;\n        }\n      }\n      \n      if (closestPoint) {\n        setTooltip({\n          visible: true,\n          x,\n          y,\n          content,\n        });\n      } else {\n        setTooltip(prev => ({ ...prev, visible: false }));\n      }\n    } else {\n      setTooltip(prev => ({ ...prev, visible: false }));\n    }\n  };\n  \n  // Handle mouse leave\n  const handleMouseLeave = () => {\n    setTooltip(prev => ({ ...prev, visible: false }));\n  };\n  \n  // Handle click events\n  const handleClick = (e: React.MouseEvent<HTMLCanvasElement>) => {\n    if (!onClick) return;\n    \n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    \n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    \n    // Calculate chart area\n    const chartArea = {\n      x: margin.left,\n      y: margin.top,\n      width: dimensions.width - margin.left - margin.right,\n      height: dimensions.height - margin.top - margin.bottom,\n    };\n    \n    // Similar logic to handleMouseMove, but trigger onClick\n    if (type === 'bar' || type === 'line') {\n      const dataset = data.datasets[0];\n      const barWidth = chartArea.width / dataset.data.length;\n      const barIndex = Math.floor((x - chartArea.x) / barWidth);\n      \n      if (\n        barIndex >= 0 && \n        barIndex < dataset.data.length && \n        x >= chartArea.x && \n        x <= chartArea.x + chartArea.width && \n        y >= chartArea.y && \n        y <= chartArea.y + chartArea.height\n      ) {\n        onClick(dataset.data[barIndex]);\n      }\n    }\n  };\n  \n  return (\n    <div \n      ref={containerRef}\n      className={`chart-container ${className}`}\n      style={{ width: responsive ? '100%' : `${width}px` }}\n      data-testid=\"chart\"\n    >\n      <canvas\n        ref={canvasRef}\n        width={dimensions.width}\n        height={dimensions.height}\n        onMouseMove={handleMouseMove}\n        onMouseLeave={handleMouseLeave}\n        onClick={handleClick}\n        className=\"chart-canvas\"\n      />\n      \n      {tooltip.visible && (\n        <div \n          className=\"chart-tooltip\"\n          style={{\n            position: 'absolute',\n            left: `${tooltip.x + 10}px`,\n            top: `${tooltip.y - 10}px`,\n            backgroundColor: 'rgba(0, 0, 0, 0.8)',\n            color: 'white',\n            padding: '5px 8px',\n            borderRadius: '4px',\n            fontSize: '12px',\n            pointerEvents: 'none',\n            zIndex: 100,\n            transform: 'translate(-50%, -100%)',\n          }}\n        >\n          {tooltip.content}\n        </div>\n      )}\n    </div>\n  );\n}\n\n// Helper functions for drawing different chart types\nfunction drawGrid(\n  ctx: CanvasRenderingContext2D,\n  chartArea: { x: number; y: number; width: number; height: number },\n  maxValue: number\n) {\n  ctx.strokeStyle = '#e0e0e0';\n  ctx.lineWidth = 0.5;\n  \n  // Draw horizontal grid lines\n  const gridLines = 5;\n  for (let i = 0; i <= gridLines; i++) {\n    const y = chartArea.y + (chartArea.height / gridLines) * i;\n    \n    ctx.beginPath();\n    ctx.moveTo(chartArea.x, y);\n    ctx.lineTo(chartArea.x + chartArea.width, y);\n    ctx.stroke();\n    \n    // Draw labels\n    const value = maxValue - (maxValue / gridLines) * i;\n    ctx.fillStyle = '#666666';\n    ctx.font = '10px Arial';\n    ctx.textAlign = 'right';\n    ctx.fillText(value.toFixed(0), chartArea.x - 5, y + 3);\n  }\n}\n\nfunction drawLegend(\n  ctx: CanvasRenderingContext2D,\n  datasets: ChartData['datasets'],\n  colors: string[],\n  area: { x: number; y: number; width: number }\n) {\n  const legendItemWidth = 80;\n  const legendItemHeight = 20;\n  const itemsPerRow = Math.floor(area.width / legendItemWidth);\n  \n  datasets.forEach((dataset, index) => {\n    const row = Math.floor(index / itemsPerRow);\n    const col = index % itemsPerRow;\n    \n    const x = area.x + col * legendItemWidth;\n    const y = area.y + row * legendItemHeight;\n    \n    const color = dataset.color || colors[index % colors.length];\n    \n    // Draw color box\n    ctx.fillStyle = color;\n    ctx.fillRect(x, y, 12, 12);\n    \n    // Draw label\n    ctx.fillStyle = '#333333';\n    ctx.font = '12px Arial';\n    ctx.textAlign = 'left';\n    ctx.fillText(dataset.label, x + 16, y + 10);\n  });\n}\n\nfunction drawLineChart(\n  ctx: CanvasRenderingContext2D,\n  data: DataPoint[],\n  chartArea: { x: number; y: number; width: number; height: number },\n  maxValue: number,\n  color: string\n) {\n  if (data.length === 0) return;\n  \n  ctx.strokeStyle = color;\n  ctx.lineWidth = 2;\n  ctx.beginPath();\n  \n  const xStep = chartArea.width / (data.length - 1 || 1);\n  \n  data.forEach((point, index) => {\n    const x = chartArea.x + index * xStep;\n    const y = chartArea.y + chartArea.height - (point.value / maxValue) * chartArea.height;\n    \n    if (index === 0) {\n      ctx.moveTo(x, y);\n    } else {\n      ctx.lineTo(x, y);\n    }\n  });\n  \n  ctx.stroke();\n  \n  // Draw points\n  data.forEach((point, index) => {\n    const x = chartArea.x + index * xStep;\n    const y = chartArea.y + chartArea.height - (point.value / maxValue) * chartArea.height;\n    \n    ctx.beginPath();\n    ctx.arc(x, y, 4, 0, Math.PI * 2);\n    ctx.fillStyle = color;\n    ctx.fill();\n  });\n}\n\nfunction drawBarChart(\n  ctx: CanvasRenderingContext2D,\n  data: DataPoint[],\n  chartArea: { x: number; y: number; width: number; height: number },\n  maxValue: number,\n  color: string,\n  datasetIndex: number,\n  datasetCount: number\n) {\n  if (data.length === 0) return;\n  \n  const barWidth = chartArea.width / data.length;\n  const groupWidth = barWidth * 0.8;\n  const individualBarWidth = groupWidth / datasetCount;\n  \n  data.forEach((point, index) => {\n    const x = chartArea.x + index * barWidth + barWidth * 0.1 + datasetIndex * individualBarWidth;\n    const barHeight = (point.value / maxValue) * chartArea.height;\n    const y = chartArea.y + chartArea.height - barHeight;\n    \n    ctx.fillStyle = point.color || color;\n    ctx.fillRect(x, y, individualBarWidth, barHeight);\n    \n    // Draw label below the bar\n    if (datasetIndex === 0) {\n      ctx.fillStyle = '#666666';\n      ctx.font = '10px Arial';\n      ctx.textAlign = 'center';\n      ctx.fillText(point.label, chartArea.x + index * barWidth + barWidth / 2, chartArea.y + chartArea.height + 15);\n    }\n  });\n}\n\nfunction drawPieChart(\n  ctx: CanvasRenderingContext2D,\n  data: DataPoint[],\n  chartArea: { x: number; y: number; width: number; height: number },\n  colors: string[]\n) {\n  if (data.length === 0) return;\n  \n  const centerX = chartArea.x + chartArea.width / 2;\n  const centerY = chartArea.y + chartArea.height / 2;\n  const radius = Math.min(chartArea.width, chartArea.height) / 2;\n  \n  const total = data.reduce((sum, point) => sum + point.value, 0);\n  \n  let startAngle = 0;\n  \n  data.forEach((point, index) => {\n    const portionValue = point.value / total;\n    const endAngle = startAngle + portionValue * Math.PI * 2;\n    \n    ctx.beginPath();\n    ctx.moveTo(centerX, centerY);\n    ctx.arc(centerX, centerY, radius, startAngle, endAngle);\n    ctx.closePath();\n    \n    ctx.fillStyle = point.color || colors[index % colors.length];\n    ctx.fill();\n    \n    // Draw label if slice is large enough\n    if (portionValue > 0.05) {\n      const midAngle = startAngle + (endAngle - startAngle) / 2;\n      const labelRadius = radius * 0.7;\n      const labelX = centerX + Math.cos(midAngle) * labelRadius;\n      const labelY = centerY + Math.sin(midAngle) * labelRadius;\n      \n      ctx.fillStyle = '#ffffff';\n      ctx.font = 'bold 12px Arial';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(portionValue > 0.1 ? point.label : '', labelX, labelY);\n    }\n    \n    startAngle = endAngle;\n  });\n}\n\nfunction drawDoughnutChart(\n  ctx: CanvasRenderingContext2D,\n  data: DataPoint[],\n  chartArea: { x: number; y: number; width: number; height: number },\n  colors: string[]\n) {\n  if (data.length === 0) return;\n  \n  const centerX = chartArea.x + chartArea.width / 2;\n  const centerY = chartArea.y + chartArea.height / 2;\n  const outerRadius = Math.min(chartArea.width, chartArea.height) / 2;\n  const innerRadius = outerRadius * 0.6;\n  \n  const total = data.reduce((sum, point) => sum + point.value, 0);\n  \n  let startAngle = 0;\n  \n  data.forEach((point, index) => {\n    const portionValue = point.value / total;\n    const endAngle = startAngle + portionValue * Math.PI * 2;\n    \n    ctx.beginPath();\n    ctx.arc(centerX, centerY, outerRadius, startAngle, endAngle);\n    ctx.arc(centerX, centerY, innerRadius, endAngle, startAngle, true);\n    ctx.closePath();\n    \n    ctx.fillStyle = point.color || colors[index % colors.length];\n    ctx.fill();\n    \n    startAngle = endAngle;\n  });\n}\n\nfunction drawAreaChart(\n  ctx: CanvasRenderingContext2D,\n  data: DataPoint[],\n  chartArea: { x: number; y: number; width: number; height: number },\n  maxValue: number,\n  color: string\n) {\n  if (data.length === 0) return;\n  \n  const xStep = chartArea.width / (data.length - 1 || 1);\n  \n  // Draw filled area\n  ctx.beginPath();\n  ctx.moveTo(chartArea.x, chartArea.y + chartArea.height);\n  \n  data.forEach((point, index) => {\n    const x = chartArea.x + index * xStep;\n    const y = chartArea.y + chartArea.height - (point.value / maxValue) * chartArea.height;\n    ctx.lineTo(x, y);\n  });\n  \n  ctx.lineTo(chartArea.x + chartArea.width, chartArea.y + chartArea.height);\n  ctx.closePath();\n  \n  const gradient = ctx.createLinearGradient(0, chartArea.y, 0, chartArea.y + chartArea.height);\n  gradient.addColorStop(0, color + '80');  // Semi-transparent color at top\n  gradient.addColorStop(1, color + '10');  // Almost transparent at bottom\n  \n  ctx.fillStyle = gradient;\n  ctx.fill();\n  \n  // Draw line on top\n  drawLineChart(ctx, data, chartArea, maxValue, color);\n}\n\nfunction drawThresholdLine(\n  ctx: CanvasRenderingContext2D,\n  threshold: number,\n  chartArea: { x: number; y: number; width: number; height: number },\n  maxValue: number\n) {\n  const y = chartArea.y + chartArea.height - (threshold / maxValue) * chartArea.height;\n  \n  ctx.strokeStyle = '#ff0000';\n  ctx.lineWidth = 1;\n  ctx.setLineDash([5, 3]);\n  \n  ctx.beginPath();\n  ctx.moveTo(chartArea.x, y);\n  ctx.lineTo(chartArea.x + chartArea.width, y);\n  ctx.stroke();\n  \n  ctx.setLineDash([]);\n  \n  // Draw threshold label\n  ctx.fillStyle = '#ff0000';\n  ctx.font = '10px Arial';\n  ctx.textAlign = 'left';\n  ctx.fillText(`Threshold: ${threshold}`, chartArea.x, y - 5);\n} ","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/visualizations/LazyNetworkGraph.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'NetworkNode' is defined but never used. Allowed unused vars must match /^ignored|^temp/u.","line":12,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'NetworkEdge' is defined but never used. Allowed unused vars must match /^ignored|^temp/u.","line":12,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":34}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @context: ui-system, visualization-system, performance-optimization\n * \n * LazyNetworkGraph - A lazy-loaded version of the NetworkGraph component\n * This component only loads the actual visualization when needed, reducing the initial bundle size\n */\n\nimport React from 'react';\nimport { useLazyComponent } from '../../../utils/performance/ComponentOptimizer';\nimport { ErrorBoundary } from '../errors/ErrorBoundary';\nimport { ErrorType, ErrorSeverity } from '../../../services/ErrorLoggingService';\nimport { NetworkNode, NetworkEdge, NetworkGraphProps } from './NetworkGraph';\n\n// Loading placeholder component\nconst LoadingPlaceholder = () => (\n  <div className=\"network-graph-loading\">\n    <div className=\"loading-spinner\"></div>\n    <p>Loading network visualization...</p>\n  </div>\n);\n\n// Error component\nconst ErrorDisplay = () => (\n  <div className=\"network-graph-error\">\n    <p>Failed to load network visualization.</p>\n    <button className=\"retry-button\">Retry</button>\n  </div>\n);\n\n/**\n * LazyNetworkGraph component\n * Lazily loads the actual NetworkGraph component only when needed\n */\nexport function LazyNetworkGraph(props: NetworkGraphProps) {\n  // Use the useLazyComponent hook to dynamically import the component\n  const { Component, loading, error } = useLazyComponent<NetworkGraphProps>(\n    () => import('./NetworkGraph').then(module => ({ default: module.NetworkGraph })),\n    []\n  );\n  \n  // Show loading state\n  if (loading) {\n    return <LoadingPlaceholder />;\n  }\n  \n  // Show error state\n  if (error || !Component) {\n    return <ErrorDisplay />;\n  }\n  \n  // Render the actual component within an error boundary\n  return (\n    <ErrorBoundary\n      componentName=\"NetworkGraph\"\n      errorType={ErrorType.RUNTIME}\n      errorSeverity={ErrorSeverity.MEDIUM}\n      metadata={{ nodeCount: props.nodes.length, edgeCount: props.edges.length }}\n    >\n      <Component {...props} />\n    </ErrorBoundary>\n  );\n}\n\n// Export a memoized version of the component\nexport default React.memo(LazyNetworkGraph); ","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/visualizations/LazyResourceFlowDiagram.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/visualizations/LineGraph.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/visualizations/NetworkGraph.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":19,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":19,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[515,518],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[515,518],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":33,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[861,864],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[861,864],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'onNodeHover' is defined but never used.","line":157,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":157,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'onEdgeHover' is defined but never used.","line":158,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":158,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":539,"column":28,"nodeType":null,"messageId":"unusedVar","endLine":539,"endColumn":29}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @context: ui-system, component-library, visualization-system\n * \n * NetworkGraph component for visualizing network relationships and connections\n */\nimport * as React from 'react';\nimport { useRef, useEffect, useState, useMemo } from 'react';\n\n// Network node interface\nexport interface NetworkNode {\n  id: string;\n  label: string;\n  size?: number;\n  color?: string;\n  group?: string;\n  position?: { x: number; y: number };\n  fixed?: boolean;\n  metadata?: Record<string, string | number | boolean>;\n  data?: any; // Add data property for custom data\n}\n\n// Network edge/link interface\nexport interface NetworkEdge {\n  id: string;\n  source: string;  // Node ID\n  target: string;  // Node ID\n  label?: string;\n  width?: number;\n  color?: string;\n  bidirectional?: boolean;\n  weight?: number;\n  metadata?: Record<string, string | number | boolean>;\n  data?: any; // Add data property for custom data\n}\n\n// NetworkGraph props\nexport interface NetworkGraphProps {\n  /**\n   * Nodes in the network\n   */\n  nodes: NetworkNode[];\n  \n  /**\n   * Edges connecting nodes\n   */\n  edges: NetworkEdge[];\n  \n  /**\n   * Width of the graph\n   * @default 600\n   */\n  width?: number;\n  \n  /**\n   * Height of the graph\n   * @default 400\n   */\n  height?: number;\n  \n  /**\n   * Whether the graph is interactive\n   * @default true\n   */\n  interactive?: boolean;\n  \n  /**\n   * Whether to apply physics simulation\n   * @default true\n   */\n  physics?: boolean;\n  \n  /**\n   * Strength of the physics simulation\n   * @default 0.1\n   */\n  physicsStrength?: number;\n  \n  /**\n   * Node click handler\n   */\n  onNodeClick?: (node: NetworkNode) => void;\n  \n  /**\n   * Edge click handler\n   */\n  onEdgeClick?: (edge: NetworkEdge) => void;\n  \n  /**\n   * Node hover handler\n   */\n  onNodeHover?: (node: NetworkNode | null) => void;\n  \n  /**\n   * Edge hover handler\n   */\n  onEdgeHover?: (edge: NetworkEdge | null) => void;\n  \n  /**\n   * Default node size\n   * @default 10\n   */\n  defaultNodeSize?: number;\n  \n  /**\n   * Default edge width\n   * @default 1\n   */\n  defaultEdgeWidth?: number;\n  \n  /**\n   * Node color mapping by group\n   */\n  nodeColorMap?: Record<string, string>;\n  \n  /**\n   * Edge color mapping by type\n   */\n  edgeColorMap?: Record<string, string>;\n  \n  /**\n   * Whether to show node labels\n   * @default true\n   */\n  showNodeLabels?: boolean;\n  \n  /**\n   * Whether to show edge labels\n   * @default false\n   */\n  showEdgeLabels?: boolean;\n  \n  /**\n   * Custom class name\n   */\n  className?: string;\n  \n  /**\n   * Whether the graph is directed\n   * @default false\n   */\n  directed?: boolean;\n}\n\n/**\n * NetworkGraph component for visualizing network relationships\n */\nexport function NetworkGraph({\n  nodes,\n  edges,\n  width = 600,\n  height = 400,\n  interactive = true,\n  physics = true,\n  physicsStrength = 0.1,\n  onNodeClick,\n  onEdgeClick,\n  onNodeHover,\n  onEdgeHover,\n  defaultNodeSize = 10,\n  defaultEdgeWidth = 1,\n  nodeColorMap = {\n    default: '#4287f5',\n    highlighted: '#f44336',\n    muted: '#9e9e9e'\n  },\n  edgeColorMap = {\n    default: '#9e9e9e',\n    highlighted: '#f44336',\n    bidirectional: '#4caf50'\n  },\n  showNodeLabels = true,\n  showEdgeLabels = false,\n  className = '',\n  directed = false\n}: NetworkGraphProps) {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const containerRef = useRef<HTMLDivElement>(null);\n  \n  // State for simulation\n  const [simulationNodes, setSimulationNodes] = useState<NetworkNode[]>([]);\n  const [hoveredNode, setHoveredNode] = useState<string | null>(null);\n  const [hoveredEdge, setHoveredEdge] = useState<string | null>(null);\n  const [dragNode, setDragNode] = useState<string | null>(null);\n  const [simulationRunning, setSimulationRunning] = useState(physics);\n  \n  // Map node IDs to nodes for faster access\n  const nodeMap = useMemo(() => {\n    const map = new Map<string, NetworkNode>();\n    nodes.forEach(node => map.set(node.id, node));\n    return map;\n  }, [nodes]);\n  \n  // Process nodes with initial positions\n  useEffect(() => {\n    // Copy nodes and assign positions if not provided\n    const processed = nodes.map(node => {\n      if (node.position) return node;\n      \n      return {\n        ...node,\n        position: {\n          x: Math.random() * width * 0.8 + width * 0.1,\n          y: Math.random() * height * 0.8 + height * 0.1\n        }\n      };\n    });\n    \n    setSimulationNodes(processed);\n  }, [nodes, width, height]);\n  \n  // Run physics simulation\n  useEffect(() => {\n    if (!physics || !simulationNodes.length || !simulationRunning) return;\n    \n    let frameId: number;\n    \n    const runSimulation = () => {\n      // Simple force-directed layout\n      const forces = simulationNodes.map(() => ({ x: 0, y: 0 }));\n      \n      // Repulsive force between nodes\n      for (let i = 0; i < simulationNodes.length; i++) {\n        if (simulationNodes[i].fixed) continue;\n        \n        for (let j = i + 1; j < simulationNodes.length; j++) {\n          if (simulationNodes[j].fixed) continue;\n          \n          const nodeA = simulationNodes[i];\n          const nodeB = simulationNodes[j];\n          \n          if (!nodeA.position || !nodeB.position) continue;\n          \n          const dx = nodeB.position.x - nodeA.position.x;\n          const dy = nodeB.position.y - nodeA.position.y;\n          const distance = Math.sqrt(dx * dx + dy * dy);\n          \n          if (distance === 0) continue;\n          \n          // Repulsive force inversely proportional to distance\n          const force = 500 / (distance * distance);\n          const forceX = dx / distance * force;\n          const forceY = dy / distance * force;\n          \n          forces[i].x -= forceX;\n          forces[i].y -= forceY;\n          forces[j].x += forceX;\n          forces[j].y += forceY;\n        }\n      }\n      \n      // Attractive force along edges\n      for (const edge of edges) {\n        const source = simulationNodes.find(n => n.id === edge.source);\n        const target = simulationNodes.find(n => n.id === edge.target);\n        \n        if (!source || !target || !source.position || !target.position) continue;\n        if (source.fixed && target.fixed) continue;\n        \n        const dx = target.position.x - source.position.x;\n        const dy = target.position.y - source.position.y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        \n        if (distance === 0) continue;\n        \n        // Attractive force proportional to distance\n        const force = (distance - 100) * 0.05 * (edge.weight || 1);\n        const forceX = dx / distance * force;\n        const forceY = dy / distance * force;\n        \n        if (!source.fixed) {\n          forces[simulationNodes.indexOf(source)].x += forceX;\n          forces[simulationNodes.indexOf(source)].y += forceY;\n        }\n        \n        if (!target.fixed) {\n          forces[simulationNodes.indexOf(target)].x -= forceX;\n          forces[simulationNodes.indexOf(target)].y -= forceY;\n        }\n      }\n      \n      // Apply forces\n      const newNodes = simulationNodes.map((node, i) => {\n        if (node.fixed || !node.position) return node;\n        if (node.id === dragNode) return node;\n        \n        const updatedPosition = {\n          x: node.position.x + forces[i].x * physicsStrength,\n          y: node.position.y + forces[i].y * physicsStrength,\n        };\n        \n        // Keep nodes within bounds\n        updatedPosition.x = Math.max(20, Math.min(width - 20, updatedPosition.x));\n        updatedPosition.y = Math.max(20, Math.min(height - 20, updatedPosition.y));\n        \n        return {\n          ...node,\n          position: updatedPosition,\n        };\n      });\n      \n      setSimulationNodes(newNodes);\n      \n      // Continue simulation\n      frameId = requestAnimationFrame(runSimulation);\n    };\n    \n    frameId = requestAnimationFrame(runSimulation);\n    \n    return () => {\n      cancelAnimationFrame(frameId);\n    };\n  }, [simulationNodes, edges, physics, physicsStrength, width, height, simulationRunning, dragNode]);\n  \n  // Draw the network graph\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    \n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n    \n    // Clear canvas\n    ctx.clearRect(0, 0, width, height);\n    \n    // Draw edges\n    edges.forEach(edge => {\n      const source = simulationNodes.find(n => n.id === edge.source);\n      const target = simulationNodes.find(n => n.id === edge.target);\n      \n      if (!source || !target || !source.position || !target.position) return;\n      \n      ctx.beginPath();\n      ctx.moveTo(source.position.x, source.position.y);\n      ctx.lineTo(target.position.x, target.position.y);\n      \n      // Set edge color\n      if (edge.id === hoveredEdge) {\n        ctx.strokeStyle = edgeColorMap.highlighted;\n      } else if (edge.bidirectional) {\n        ctx.strokeStyle = edge.color || edgeColorMap.bidirectional;\n      } else {\n        ctx.strokeStyle = edge.color || edgeColorMap.default;\n      }\n      \n      ctx.lineWidth = edge.width || defaultEdgeWidth;\n      ctx.stroke();\n      \n      // Draw arrow if directed\n      if (directed && !edge.bidirectional) {\n        const arrowSize = 8;\n        const angle = Math.atan2(\n          target.position.y - source.position.y,\n          target.position.x - source.position.x\n        );\n        \n        // Draw arrow at 3/4 of the way to the target\n        const x = source.position.x + (target.position.x - source.position.x) * 0.75;\n        const y = source.position.y + (target.position.y - source.position.y) * 0.75;\n        \n        ctx.beginPath();\n        ctx.moveTo(x, y);\n        ctx.lineTo(\n          x - arrowSize * Math.cos(angle - Math.PI / 6),\n          y - arrowSize * Math.sin(angle - Math.PI / 6)\n        );\n        ctx.lineTo(\n          x - arrowSize * Math.cos(angle + Math.PI / 6),\n          y - arrowSize * Math.sin(angle + Math.PI / 6)\n        );\n        ctx.closePath();\n        ctx.fillStyle = edge.color || edgeColorMap.default;\n        ctx.fill();\n      }\n      \n      // Draw edge label\n      if (showEdgeLabels && edge.label) {\n        const midX = (source.position.x + target.position.x) / 2;\n        const midY = (source.position.y + target.position.y) / 2;\n        \n        ctx.font = '10px Arial';\n        ctx.fillStyle = '#333333';\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'bottom';\n        \n        // Draw text with background for readability\n        const textWidth = ctx.measureText(edge.label).width;\n        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\n        ctx.fillRect(midX - textWidth / 2 - 2, midY - 12, textWidth + 4, 14);\n        \n        ctx.fillStyle = '#333333';\n        ctx.fillText(edge.label, midX, midY);\n      }\n    });\n    \n    // Draw nodes\n    simulationNodes.forEach(node => {\n      if (!node.position) return;\n      \n      const x = node.position.x;\n      const y = node.position.y;\n      const size = node.size || defaultNodeSize;\n      \n      ctx.beginPath();\n      ctx.arc(x, y, size, 0, Math.PI * 2);\n      \n      // Set node color\n      if (node.id === hoveredNode) {\n        ctx.fillStyle = nodeColorMap.highlighted;\n      } else if (node.color) {\n        ctx.fillStyle = node.color;\n      } else if (node.group && nodeColorMap[node.group]) {\n        ctx.fillStyle = nodeColorMap[node.group];\n      } else {\n        ctx.fillStyle = nodeColorMap.default;\n      }\n      \n      ctx.fill();\n      \n      // Add border to nodes\n      ctx.strokeStyle = '#ffffff';\n      ctx.lineWidth = 1;\n      ctx.stroke();\n      \n      // Draw node label\n      if (showNodeLabels && node.label) {\n        ctx.font = '12px Arial';\n        ctx.fillStyle = '#333333';\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'top';\n        \n        // Draw text with background for readability\n        const textWidth = ctx.measureText(node.label).width;\n        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\n        ctx.fillRect(x - textWidth / 2 - 2, y + size + 2, textWidth + 4, 16);\n        \n        ctx.fillStyle = '#333333';\n        ctx.fillText(node.label, x, y + size + 4);\n      }\n    });\n  }, [\n    simulationNodes, \n    edges, \n    width, \n    height, \n    hoveredNode, \n    hoveredEdge, \n    nodeColorMap, \n    edgeColorMap,\n    defaultNodeSize,\n    defaultEdgeWidth,\n    showNodeLabels,\n    showEdgeLabels,\n    directed\n  ]);\n  \n  // Handle mouse events\n  const handleMouseMove = (e: React.MouseEvent<HTMLCanvasElement>) => {\n    if (!interactive) return;\n    \n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    \n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    \n    // Check if mouse is over a node\n    let foundNode = false;\n    let foundEdge = false;\n    \n    // Check nodes first (they should be on top)\n    for (const node of simulationNodes) {\n      if (!node.position) continue;\n      \n      const size = node.size || defaultNodeSize;\n      const dx = node.position.x - x;\n      const dy = node.position.y - y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n      \n      if (distance <= size) {\n        setHoveredNode(node.id);\n        setHoveredEdge(null);\n        foundNode = true;\n        \n        // If dragging, update node position\n        if (dragNode === node.id) {\n          const updatedNodes = simulationNodes.map(n => {\n            if (n.id === node.id) {\n              return {\n                ...n,\n                position: { x, y }\n              };\n            }\n            return n;\n          });\n          \n          setSimulationNodes(updatedNodes);\n        }\n        \n        // Set cursor\n        canvas.style.cursor = 'pointer';\n        break;\n      }\n    }\n    \n    // If not over a node, check edges\n    if (!foundNode && !dragNode) {\n      for (const edge of edges) {\n        const source = simulationNodes.find(n => n.id === edge.source);\n        const target = simulationNodes.find(n => n.id === edge.target);\n        \n        if (!source || !target || !source.position || !target.position) continue;\n        \n        // Check if cursor is near the edge line\n        const edgeDist = distanceToLine(\n          x, y,\n          source.position.x, source.position.y,\n          target.position.x, target.position.y\n        );\n        \n        if (edgeDist < 5) {\n          setHoveredEdge(edge.id);\n          setHoveredNode(null);\n          foundEdge = true;\n          canvas.style.cursor = 'pointer';\n          break;\n        }\n      }\n    }\n    \n    // Reset if not hovering over anything\n    if (!foundNode && !foundEdge && !dragNode) {\n      setHoveredNode(null);\n      setHoveredEdge(null);\n      canvas.style.cursor = 'default';\n    }\n  };\n  \n  const handleMouseDown = (e: React.MouseEvent<HTMLCanvasElement>) => {\n    if (!interactive) return;\n    \n    // Start dragging if hovering over a node\n    if (hoveredNode) {\n      setDragNode(hoveredNode);\n      setSimulationRunning(false);\n    } else {\n      setDragNode(null);\n    }\n  };\n  \n  const handleMouseUp = () => {\n    if (!interactive) return;\n    \n    setDragNode(null);\n    \n    // Resume simulation if physics is enabled\n    if (physics) {\n      setSimulationRunning(true);\n    }\n  };\n  \n  const handleClick = () => {\n    if (!interactive) return;\n    \n    // Handle node click\n    if (hoveredNode && onNodeClick) {\n      const node = nodeMap.get(hoveredNode);\n      if (node) {\n        onNodeClick(node);\n      }\n    }\n    \n    // Handle edge click\n    if (hoveredEdge && onEdgeClick) {\n      const edge = edges.find(e => e.id === hoveredEdge);\n      if (edge) {\n        onEdgeClick(edge);\n      }\n    }\n  };\n  \n  return (\n    <div \n      ref={containerRef}\n      className={`network-graph-container ${className}`}\n      data-testid=\"network-graph\"\n    >\n      <canvas\n        ref={canvasRef}\n        width={width}\n        height={height}\n        onMouseMove={handleMouseMove}\n        onMouseDown={handleMouseDown}\n        onMouseUp={handleMouseUp}\n        onMouseLeave={handleMouseUp}\n        onClick={handleClick}\n        className=\"network-graph-canvas\"\n      />\n    </div>\n  );\n}\n\n// Helper to calculate distance from point to line segment\nfunction distanceToLine(\n  px: number, py: number,\n  x1: number, y1: number,\n  x2: number, y2: number\n): number {\n  const A = px - x1;\n  const B = py - y1;\n  const C = x2 - x1;\n  const D = y2 - y1;\n  \n  const dot = A * C + B * D;\n  const lenSq = C * C + D * D;\n  let param = -1;\n  \n  if (lenSq !== 0) {\n    param = dot / lenSq;\n  }\n  \n  let xx, yy;\n  \n  if (param < 0) {\n    xx = x1;\n    yy = y1;\n  } else if (param > 1) {\n    xx = x2;\n    yy = y2;\n  } else {\n    xx = x1 + param * C;\n    yy = y1 + param * D;\n  }\n  \n  const dx = px - xx;\n  const dy = py - yy;\n  \n  return Math.sqrt(dx * dx + dy * dy);\n}\n\n/**\n * Helper to create a network graph data structure from nodes and edges lists\n */\nexport function createNetworkData(\n  nodes: NetworkNode[],\n  edges: NetworkEdge[]\n): { nodes: NetworkNode[]; edges: NetworkEdge[] } {\n  return { nodes, edges };\n} ","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/visualizations/ResourceFlowDiagram.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/ui/visualizations/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/visualization/AnomalyVisualization.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_chartId' is defined but never used.","line":20,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":20,"endColumn":11},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_groupId' is defined but never used.","line":21,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":21,"endColumn":11},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_initialState' is defined but never used.","line":22,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":22,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { CircularProgress, Paper, Typography } from '@mui/material';\nimport * as React from 'react';\nimport { useCallback, useEffect, useState } from 'react';\nimport { useService } from '../../hooks/services/useService';\nimport { DataPoint, anomalyDetectionService } from '../../services/AnomalyDetectionService';\n\ninterface ViewportState {\n  x: number;\n  y: number;\n  scale: number;\n}\n\ninterface ChartCoordination {\n  updateViewport: (viewport: ViewportState) => void;\n  updateHighlight: (point: DataPoint | null) => void;\n}\n\n// Mock useChartCoordination until it's implemented\nconst useChartCoordination = ({\n  _chartId,\n  _groupId,\n  _initialState,\n  onViewportChange,\n  onHighlightChange,\n}: {\n  _chartId: string;\n  _groupId?: string;\n  _initialState: {\n    viewport: ViewportState;\n    highlight: DataPoint | null;\n  };\n  onViewportChange: (viewport: ViewportState) => void;\n  onHighlightChange: (point: DataPoint | null) => void;\n}): ChartCoordination => {\n  return {\n    updateViewport: onViewportChange,\n    updateHighlight: onHighlightChange,\n  };\n};\n\ninterface AnomalyVisualizationProps {\n  width?: number;\n  height?: number;\n  data: DataPoint[];\n  dimensions: [number, number]; // Which dimensions to plot [x, y]\n  chartId: string;\n  groupId?: string;\n}\n\nexport function AnomalyVisualization({\n  width = 800,\n  height = 600,\n  data,\n  dimensions,\n  chartId,\n  groupId,\n}: AnomalyVisualizationProps) {\n  const canvasRef = React.useRef<HTMLCanvasElement>(null);\n  const [viewport, setViewport] = useState<ViewportState>({ x: 0, y: 0, scale: 1 });\n  const [hoveredPoint, setHoveredPoint] = useState<DataPoint | null>(null);\n\n  // Get anomaly detection service\n  const { service: anomalyService, isLoading } =\n    useService<typeof anomalyDetectionService>('anomalyDetection');\n\n  // Setup chart coordination\n  const { updateViewport, updateHighlight } = useChartCoordination({\n    _chartId: chartId,\n    _groupId: groupId,\n    _initialState: {\n      viewport,\n      highlight: null,\n    },\n    onViewportChange: setViewport,\n    onHighlightChange: (point: DataPoint | null) => setHoveredPoint(point),\n  });\n\n  // Calculate anomaly scores when data changes\n  useEffect(() => {\n    if (!anomalyService || !data?.length) return;\n\n    const detectAnomalies = async () => {\n      try {\n        (anomalyService as typeof anomalyDetectionService).addDataPoints(data);\n        await (anomalyService as typeof anomalyDetectionService).detectAnomalies('statistical');\n      } catch (error) {\n        console.error('Error detecting anomalies:', error);\n      }\n    };\n\n    detectAnomalies();\n  }, [anomalyService, data]);\n\n  // Draw function\n  const draw = useCallback(() => {\n    const canvas = canvasRef.current;\n    if (!canvas || !anomalyService) return;\n\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    // Clear canvas\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    // Apply viewport transform\n    ctx.save();\n    ctx.translate(viewport.x, viewport.y);\n    ctx.scale(viewport.scale, viewport.scale);\n\n    // Draw points\n    data?.forEach(point => {\n      const x = point.values[dimensions[0]];\n      const y = point.values[dimensions[1]];\n      const score = (anomalyService as typeof anomalyDetectionService).getAnomalyScore(point.id);\n\n      // Determine point color based on anomaly score\n      if (score) {\n        const intensity = Math.floor(score.score * 255);\n        ctx.fillStyle = `rgb(${intensity}, 0, 0)`;\n      } else {\n        ctx.fillStyle = 'blue';\n      }\n\n      // Draw point\n      ctx.beginPath();\n      ctx.arc(x, y, point === hoveredPoint ? 6 : 4, 0, Math.PI * 2);\n      ctx.fill();\n    });\n\n    ctx.restore();\n  }, [data, dimensions, viewport, hoveredPoint, anomalyService]);\n\n  // Draw when dependencies change\n  useEffect(() => {\n    draw();\n  }, [draw]);\n\n  // Handle mouse interactions\n  const handleMouseMove = useCallback(\n    (event: React.MouseEvent<HTMLCanvasElement>) => {\n      const canvas = canvasRef.current;\n      if (!canvas) return;\n\n      const rect = canvas.getBoundingClientRect();\n      const x = (event?.clientX - rect.left - viewport.x) / viewport.scale;\n      const y = (event?.clientY - rect.top - viewport.y) / viewport.scale;\n\n      // Find nearest point\n      const nearest = data?.reduce(\n        (nearest, point) => {\n          const px = point.values[dimensions[0]];\n          const py = point.values[dimensions[1]];\n          const distance = Math.sqrt(Math.pow(x - px, 2) + Math.pow(y - py, 2));\n\n          if (!nearest || distance < nearest.distance) {\n            return { point, distance };\n          }\n          return nearest;\n        },\n        null as { point: DataPoint; distance: number } | null\n      );\n\n      if (nearest && nearest.distance < 10 / viewport.scale) {\n        updateHighlight(nearest.point);\n      } else {\n        updateHighlight(null);\n      }\n    },\n    [data, dimensions, viewport, updateHighlight]\n  );\n\n  // Handle wheel zoom\n  const handleWheel = useCallback(\n    (event: React.WheelEvent<HTMLCanvasElement>) => {\n      event?.preventDefault();\n      const delta = -event?.deltaY;\n      const scale = viewport.scale * (1 + delta / 1000);\n\n      updateViewport({\n        ...viewport,\n        scale: Math.max(0.1, Math.min(10, scale)),\n      });\n    },\n    [viewport, updateViewport]\n  );\n\n  if (isLoading) {\n    const boxStyle = {\n      display: 'flex',\n      justifyContent: 'center',\n      alignItems: 'center',\n      height,\n    };\n\n    return (\n      <div style={boxStyle}>\n        <CircularProgress />\n      </div>\n    );\n  }\n\n  return (\n    <Paper elevation={2} sx={{ p: 2 }}>\n      <Typography variant=\"h6\" gutterBottom>\n        Anomaly Detection Visualization\n      </Typography>\n      <canvas\n        ref={canvasRef}\n        width={width}\n        height={height}\n        style={{ border: '1px solid #ccc' }}\n        onMouseMove={handleMouseMove}\n        onWheel={handleWheel}\n      />\n      {hoveredPoint && (\n        <div style={{ marginTop: '8px' }}>\n          <Typography variant=\"body2\">\n            Point ID: {hoveredPoint.id}\n            {(anomalyService as typeof anomalyDetectionService)\n              .getAnomalyScore(hoveredPoint.id)\n              ?.explanation?.map((exp: string, i: number) => (\n                <div key={i} style={{ color: 'red' }}>\n                  {exp}\n                </div>\n              ))}\n          </Typography>\n        </div>\n      )}\n    </Paper>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/weapons/WeaponComponents.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/weapons/WeaponControl.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/weapons/WeaponLoadout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/weapons/WeaponSpecialization.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/weapons/WeaponSystem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/components/weapons/WeaponUpgradeSystem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/config/OfficerConfig.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/config/ShipBlueprints.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/config/automation/colonyRules.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/config/automation/combatRules.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/config/automation/explorationRules.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/config/automation/hangarRules.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/config/automation/miningRules.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/config/buildings/defaultBuildings.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/config/combat/combatConfig.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/config/combat/weaponConfig.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/config/factions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/config/factions/factionConfig.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/config/factions/factions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/config/game/gameConfig.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/config/modules/defaultModuleConfigs.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/config/modules/upgradePathsConfig.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/config/resource/ResourceConfig.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/config/ships/equatorHorizonShips.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/config/ships/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/config/ships/lostNovaShips.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/config/ships/shipStats.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/config/ships/spaceRatsShips.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/contexts/ClassificationContext.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/contexts/DataAnalysisContext.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":315,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":315,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'asEventType' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":340,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":340,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as React from 'react';\nimport {\n  createContext,\n  ReactNode,\n  useCallback,\n  useContext,\n  useEffect,\n  useRef,\n  useState,\n} from 'react';\nimport { v4 as uuidv4 } from 'uuid';\nimport {\n  Anomaly,\n  EXPLORATION_EVENTS,\n  explorationManager,\n  Sector,\n} from '../managers/exploration/ExplorationManager';\nimport { AnalysisAlgorithmService } from '../services/AnalysisAlgorithmService';\nimport { DataCollectionService } from '../services/DataCollectionService';\nimport { DataProcessingService } from '../services/DataProcessingService';\nimport { BaseEvent, EventType } from '../types/events/EventTypes';\nimport {\n  AnalysisConfig,\n  AnalysisResult,\n  DataAnalysisContextType,\n  DataPoint,\n  Dataset,\n  ResourceData,\n} from '../types/exploration/DataAnalysisTypes';\n\n// Create the context with a default undefined value\nconst DataAnalysisContext = createContext<DataAnalysisContextType | undefined>(undefined);\n\n// Props for the DataAnalysisProvider component\ninterface DataAnalysisProviderProps {\n  children: ReactNode;\n  initialDatasets?: Dataset[];\n  initialAnalysisConfigs?: AnalysisConfig[];\n  initialAnalysisResults?: AnalysisResult[];\n}\n\n/**\n * Provider component for the DataAnalysisContext\n */\nexport const DataAnalysisProvider: React.FC<DataAnalysisProviderProps> = ({\n  children,\n  initialDatasets = [],\n  initialAnalysisConfigs = [],\n  initialAnalysisResults = [],\n}) => {\n  // State for datasets, analysis configurations, and results\n  const [datasets, setDatasets] = useState<Dataset[]>(initialDatasets);\n  const [analysisConfigs, setAnalysisConfigs] = useState<AnalysisConfig[]>(initialAnalysisConfigs);\n  const [analysisResults, setAnalysisResults] = useState<AnalysisResult[]>(initialAnalysisResults);\n  const [_isProcessingData, setIsProcessingData] = useState<boolean>(false);\n\n  // Create references to the services for persistence across renders\n  const dataCollectionServiceRef = useRef<DataCollectionService | null>(null);\n  const analysisAlgorithmServiceRef = useRef<AnalysisAlgorithmService | null>(null);\n  const dataProcessingServiceRef = useRef<DataProcessingService | null>(null);\n\n  // Initialize services\n  useEffect(() => {\n    if (explorationManager) {\n      // Initialize data collection service\n      const dataCollectionService = new DataCollectionService(explorationManager);\n      dataCollectionServiceRef.current = dataCollectionService;\n\n      // Initialize analysis algorithm service\n      const analysisAlgorithmService = new AnalysisAlgorithmService();\n      analysisAlgorithmServiceRef.current = analysisAlgorithmService;\n\n      // Initialize data processing service for web worker operations\n      const dataProcessingService = new DataProcessingService();\n      dataProcessingServiceRef.current = dataProcessingService;\n\n      // Initialize the data collection service\n      dataCollectionService.initialize();\n\n      // Set up callback for data updates\n      dataCollectionService.setOnDataUpdated((type, dataPoint) => {\n        // Map the DataCollectionService type to the context type\n        const sourceMap: Record<string, 'sectors' | 'anomalies' | 'resources' | 'mixed'> = {\n          sector: 'sectors',\n          anomaly: 'anomalies',\n          resource: 'resources',\n        };\n        const mappedType = sourceMap[type] || 'mixed';\n\n        // When a new data point is collected, add it to the appropriate dataset\n        const datasetId = getOrCreateDatasetBySource(mappedType);\n        if (datasetId) {\n          addDataPointToDataset(datasetId, dataPoint);\n        }\n      });\n\n      // Return cleanup function\n      return () => {\n        if (dataCollectionService) {\n          dataCollectionService.dispose();\n        }\n      };\n    }\n  }, [explorationManager]);\n\n  // Create a new dataset\n  const createDataset = useCallback(\n    (dataset: Omit<Dataset, 'id' | 'createdAt' | 'updatedAt'>): string => {\n      const id = uuidv4();\n      const now = Date.now();\n      const newDataset: Dataset = {\n        ...dataset,\n        id,\n        createdAt: now,\n        updatedAt: now,\n      };\n      setDatasets(prev => [...prev, newDataset]);\n      return id;\n    },\n    []\n  );\n\n  // Update an existing dataset\n  const updateDataset = useCallback(\n    (id: string, updates: Partial<Omit<Dataset, 'id' | 'createdAt' | 'updatedAt'>>): void => {\n      setDatasets(prev =>\n        prev.map(dataset => {\n          if (dataset.id === id) {\n            return {\n              ...dataset,\n              ...updates,\n              updatedAt: Date.now(),\n            };\n          }\n          return dataset;\n        })\n      );\n    },\n    []\n  );\n\n  // Delete a dataset\n  const deleteDataset = useCallback((id: string): void => {\n    setDatasets(prev => prev.filter(dataset => dataset.id !== id));\n    // Also delete any analysis configs that use this dataset\n    setAnalysisConfigs(prev => prev.filter(config => config.datasetId !== id));\n  }, []);\n\n  // Get a dataset by ID\n  const getDatasetById = useCallback(\n    (id: string): Dataset | undefined => {\n      return datasets.find(dataset => dataset.id === id);\n    },\n    [datasets]\n  );\n\n  // Create a new analysis configuration\n  const createAnalysisConfig = useCallback(\n    (config: Omit<AnalysisConfig, 'id' | 'createdAt' | 'updatedAt'>): string => {\n      const id = uuidv4();\n      const now = Date.now();\n      const newConfig: AnalysisConfig = {\n        ...config,\n        id,\n        createdAt: now,\n        updatedAt: now,\n      };\n      setAnalysisConfigs(prev => [...prev, newConfig]);\n      return id;\n    },\n    []\n  );\n\n  // Add a data point to a dataset\n  const addDataPointToDataset = useCallback((datasetId: string, dataPoint: DataPoint): void => {\n    setDatasets(prev =>\n      prev.map(dataset => {\n        if (dataset.id === datasetId) {\n          // Check if the data point already exists\n          const exists = dataset.dataPoints.some(dp => dp.id === dataPoint.id);\n          if (exists) return dataset;\n\n          return {\n            ...dataset,\n            dataPoints: [...dataset.dataPoints, dataPoint],\n            updatedAt: Date.now(),\n          };\n        }\n        return dataset;\n      })\n    );\n  }, []);\n\n  // Add multiple data points to a dataset at once - efficient batching\n  const addDataPointsToDataset = useCallback((datasetId: string, dataPoints: DataPoint[]): void => {\n    setDatasets(prev =>\n      prev.map(dataset => {\n        if (dataset.id === datasetId) {\n          // Filter out data points that already exist\n          const existingIds = new Set(dataset.dataPoints.map(dp => dp.id));\n          const newDataPoints = dataPoints.filter(dp => !existingIds.has(dp.id));\n\n          if (newDataPoints.length === 0) return dataset;\n\n          return {\n            ...dataset,\n            dataPoints: [...dataset.dataPoints, ...newDataPoints],\n            updatedAt: Date.now(),\n          };\n        }\n        return dataset;\n      })\n    );\n  }, []);\n\n  // Find a dataset by source type, or create one if it doesn't exist\n  const getOrCreateDatasetBySource = useCallback(\n    (source: 'sectors' | 'anomalies' | 'resources' | 'mixed', name?: string): string => {\n      // Find an existing dataset for this source\n      const existingDataset = datasets.find(dataset => dataset.source === source);\n      if (existingDataset) {\n        return existingDataset.id;\n      }\n\n      // Create a new dataset if one doesn't exist\n      const newDatasetName = name || `${source.charAt(0).toUpperCase() + source.slice(1)} Dataset`;\n      return createDataset({\n        name: newDatasetName,\n        description: `Automatically generated dataset for ${source}`,\n        dataPoints: [],\n        source,\n      });\n    },\n    [datasets, createDataset]\n  );\n\n  // Convert a sector to a data point\n  const sectorToDataPoint = useCallback((sector: Sector): DataPoint => {\n    return {\n      id: sector.id,\n      type: 'sector',\n      name: sector.name,\n      date: sector.discoveredAt || Date.now(),\n      coordinates: sector.coordinates,\n      properties: {\n        status: sector.status,\n        resourcePotential: sector.resourcePotential,\n        habitabilityScore: sector.habitabilityScore,\n        anomalyCount: sector.anomalies?.length ?? 0,\n        resourceCount: sector.resources?.length ?? 0,\n        lastScanned: sector.lastScanned ?? 0,\n      },\n    };\n  }, []);\n\n  // Convert an anomaly to a data point\n  const anomalyToDataPoint = useCallback((anomaly: Anomaly): DataPoint => {\n    return {\n      id: anomaly.id,\n      type: 'anomaly',\n      name: `${anomaly.type} Anomaly`,\n      date: anomaly.discoveredAt,\n      coordinates: anomaly.position,\n      properties: {\n        type: anomaly.type,\n        severity: anomaly.severity,\n        description: anomaly.description,\n        sectorId: anomaly.sectorId,\n        investigated: anomaly.investigatedAt !== undefined,\n      },\n    };\n  }, []);\n\n  // Convert a resource to a data point\n  const resourceToDataPoint = useCallback(\n    (\n      resource: ResourceData,\n      sectorId: string,\n      coordinates: { x: number; y: number }\n    ): DataPoint => {\n      return {\n        id: `${sectorId}-${resource.type}-${Date.now()}`,\n        type: 'resource',\n        name: `${resource.type} Resource`,\n        date: Date.now(),\n        coordinates,\n        properties: {\n          type: resource.type,\n          amount: resource.amount,\n          quality: resource.quality ?? 0,\n          sectorId,\n        },\n      };\n    },\n    []\n  );\n\n  // Subscribe to exploration events\n  useEffect(() => {\n    // Handle sector discovered events\n    const handleSectorDiscovered = (event: BaseEvent) => {\n      const { sector } = event?.data as { sector: Sector };\n      if (!sector) return;\n\n      // Get or create the sectors dataset\n      const sectorsDatasetId = getOrCreateDatasetBySource('sectors', 'Explored Sectors');\n\n      // Add the sector as a data point\n      const dataPoint = sectorToDataPoint(sector);\n      addDataPointToDataset(sectorsDatasetId, dataPoint);\n    };\n\n    // Handle anomaly detected events\n    const handleAnomalyDetected = (event: BaseEvent) => {\n      const { anomaly, sector: _ } = event?.data as { anomaly: Anomaly; sector: Sector };\n      if (!anomaly) return;\n\n      // Get or create the anomalies dataset\n      const anomaliesDatasetId = getOrCreateDatasetBySource('anomalies', 'Detected Anomalies');\n\n      // Add the anomaly as a data point\n      const dataPoint = anomalyToDataPoint(anomaly);\n      addDataPointToDataset(anomaliesDatasetId, dataPoint);\n    };\n\n    // Handle resource detected events\n    const handleResourceDetected = (event: BaseEvent) => {\n      const { resource, sector } = event?.data as { resource: ResourceData; sector: Sector };\n      if (!resource || !sector) return;\n\n      // Get or create the resources dataset\n      const resourcesDatasetId = getOrCreateDatasetBySource('resources', 'Discovered Resources');\n\n      // Add the resource as a data point\n      const dataPoint = resourceToDataPoint(resource, sector.id, sector.coordinates);\n      addDataPointToDataset(resourcesDatasetId, dataPoint);\n    };\n\n    // Helper function to convert ExplorationEvents to EventType\n    const asEventType = (event: keyof typeof EXPLORATION_EVENTS): EventType => {\n      return EventType[`EXPLORATION_${event}`] as EventType;\n    };\n\n    // Subscribe to exploration events\n    const unsubscribeSector = explorationManager.subscribeToEvent(\n      EventType.EXPLORATION_SECTOR_DISCOVERED,\n      handleSectorDiscovered\n    );\n\n    const unsubscribeAnomaly = explorationManager.subscribeToEvent(\n      EventType.EXPLORATION_ANOMALY_DETECTED,\n      handleAnomalyDetected\n    );\n\n    const unsubscribeResource = explorationManager.subscribeToEvent(\n      EventType.EXPLORATION_RESOURCE_DETECTED,\n      handleResourceDetected\n    );\n\n    // Unsubscribe when component unmounts\n    return () => {\n      unsubscribeSector();\n      unsubscribeAnomaly();\n      unsubscribeResource();\n    };\n  }, [\n    getOrCreateDatasetBySource,\n    sectorToDataPoint,\n    anomalyToDataPoint,\n    resourceToDataPoint,\n    addDataPointToDataset,\n  ]);\n\n  // Update analysis configuration\n  const updateAnalysisConfig = useCallback(\n    (\n      id: string,\n      updates: Partial<Omit<AnalysisConfig, 'id' | 'createdAt' | 'updatedAt'>>\n    ): void => {\n      setAnalysisConfigs(prev =>\n        prev.map(config => {\n          if (config.id === id) {\n            return {\n              ...config,\n              ...updates,\n              updatedAt: Date.now(),\n            };\n          }\n          return config;\n        })\n      );\n    },\n    []\n  );\n\n  // Delete an analysis configuration\n  const deleteAnalysisConfig = useCallback((id: string): void => {\n    setAnalysisConfigs(prev => prev.filter(config => config.id !== id));\n  }, []);\n\n  // Get an analysis configuration by ID\n  const getAnalysisConfigById = useCallback(\n    (id: string): AnalysisConfig | undefined => {\n      return analysisConfigs.find(config => config.id === id);\n    },\n    [analysisConfigs]\n  );\n\n  // Run an analysis using the worker for heavy operations\n  const runAnalysis = useCallback(\n    async (configId: string): Promise<string> => {\n      const config = analysisConfigs.find(config => config.id === configId);\n      if (!config) {\n        throw new Error(`Analysis configuration with ID ${configId} not found`);\n      }\n\n      const dataset = datasets.find(dataset => dataset.id === config.datasetId);\n      if (!dataset) {\n        throw new Error(`Dataset with ID ${config.datasetId} not found`);\n      }\n\n      // Create a pending result\n      const pendingResultId = uuidv4();\n      const pendingResult: AnalysisResult = {\n        id: pendingResultId,\n        analysisConfigId: configId,\n        status: 'pending',\n        startTime: Date.now(),\n        data: {},\n      };\n\n      setAnalysisResults(prev => [...prev, pendingResult]);\n      setIsProcessingData(true);\n\n      try {\n        let result: AnalysisResult;\n\n        // Use the data processing service for offloading work if available\n        if (dataProcessingServiceRef.current) {\n          try {\n            // Determine which worker processing method to use based on analysis type\n            let processedData;\n\n            // Handle special case for transformation type\n            if ((config.type as string) === 'transformation') {\n              processedData = (await dataProcessingServiceRef.current.transformData(\n                dataset.dataPoints\n              )) as Record<string, unknown>;\n            } else {\n              switch (config.type) {\n                case 'clustering':\n                  processedData = await dataProcessingServiceRef.current.processClustering(\n                    dataset.dataPoints\n                  );\n                  break;\n                case 'prediction':\n                  processedData = await dataProcessingServiceRef.current.processPrediction(\n                    dataset.dataPoints\n                  );\n                  break;\n                case 'comparison':\n                  processedData = await dataProcessingServiceRef.current.processResourceMapping(\n                    dataset.dataPoints\n                  );\n                  break;\n                default:\n                  // For other types, use the local analysis algorithm service\n                  if (analysisAlgorithmServiceRef.current) {\n                    result = await analysisAlgorithmServiceRef.current.runAnalysis(config, dataset);\n                  } else {\n                    result = await runBasicAnalysis(config, dataset);\n                  }\n\n                  // Update the analysis results with the worker-processed data\n                  setAnalysisResults(prev =>\n                    prev.map(r => (r.id === pendingResultId ? result : r))\n                  );\n                  setIsProcessingData(false);\n                  return result?.id;\n              }\n            }\n\n            // Create a result object with the processed data\n            result = {\n              id: pendingResultId,\n              analysisConfigId: config.id,\n              status: 'completed',\n              startTime: pendingResult.startTime,\n              endTime: Date.now(),\n              data: processedData as Record<string, unknown>,\n              summary: `Analysis completed successfully with ${\n                Object.keys(processedData ?? {}).length\n              } data points.`,\n            };\n          } catch (error) {\n            console.error('Worker processing error:', error);\n            // Fallback to main thread processing\n            if (analysisAlgorithmServiceRef.current) {\n              result = await analysisAlgorithmServiceRef.current.runAnalysis(config, dataset);\n            } else {\n              result = await runBasicAnalysis(config, dataset);\n            }\n          }\n        } else if (analysisAlgorithmServiceRef.current) {\n          // Use the main thread analysis service if worker is not available\n          result = await analysisAlgorithmServiceRef.current.runAnalysis(config, dataset);\n        } else {\n          // Fallback to a basic implementation\n          result = await runBasicAnalysis(config, dataset);\n        }\n\n        // Update the analysis results\n        setAnalysisResults(prev => prev.map(r => (r.id === pendingResultId ? result : r)));\n        setIsProcessingData(false);\n        return result?.id;\n      } catch (error) {\n        // Create a failed result\n        const failedResult: AnalysisResult = {\n          id: pendingResultId,\n          analysisConfigId: configId,\n          status: 'failed',\n          startTime: pendingResult.startTime,\n          endTime: Date.now(),\n          data: {},\n          error: error instanceof Error ? error.message : 'Unknown error',\n        };\n\n        // Update the analysis results\n        setAnalysisResults(prev => prev.map(r => (r.id === pendingResultId ? failedResult : r)));\n        setIsProcessingData(false);\n        throw error;\n      }\n    },\n    [analysisConfigs, datasets]\n  );\n\n  // Add a function to run basic analysis if the service is not available\n  const runBasicAnalysis = async (\n    config: AnalysisConfig,\n    dataset: Dataset\n  ): Promise<AnalysisResult> => {\n    // Simulate analysis by delaying for a short time\n    await new Promise(resolve => setTimeout(resolve, 500));\n\n    return {\n      id: uuidv4(),\n      analysisConfigId: config.id,\n      status: 'completed',\n      startTime: Date.now() - 500, // Started 500ms ago\n      endTime: Date.now(),\n      data: {\n        config,\n        datasetSize: dataset.dataPoints.length,\n        message: 'Basic analysis completed without the analysis service',\n      },\n      summary: `Analyzed ${dataset.dataPoints.length} data points using the ${config.type} analysis type.`,\n    };\n  };\n\n  // Refresh data with worker-based filtering and sorting\n  const refreshData = useCallback(async () => {\n    if (!dataCollectionServiceRef.current) return;\n    setIsProcessingData(true);\n\n    try {\n      // Get all data from the collection service\n      const sectorData = dataCollectionServiceRef.current.getSectorData();\n      const anomalyData = dataCollectionServiceRef.current.getAnomalyData();\n      const resourceData = dataCollectionServiceRef.current.getResourceData();\n\n      // Create or update datasets for each data type with correct mapping\n      const sectorDatasetId = getOrCreateDatasetBySource('sectors');\n      const anomalyDatasetId = getOrCreateDatasetBySource('anomalies');\n      const resourceDatasetId = getOrCreateDatasetBySource('resources');\n\n      // Use the worker for batch processing if available\n      if (dataProcessingServiceRef.current) {\n        // Process data in batches using the worker\n        if (sectorDatasetId && sectorData.length > 0) {\n          await addDataPointsBatch(sectorDatasetId, sectorData);\n        }\n\n        if (anomalyDatasetId && anomalyData.length > 0) {\n          await addDataPointsBatch(anomalyDatasetId, anomalyData);\n        }\n\n        if (resourceDatasetId && resourceData.length > 0) {\n          await addDataPointsBatch(resourceDatasetId, resourceData);\n        }\n      } else {\n        // Fallback to standard processing\n        if (sectorDatasetId) {\n          for (const dataPoint of sectorData) {\n            addDataPointToDataset(sectorDatasetId, dataPoint);\n          }\n        }\n\n        if (anomalyDatasetId) {\n          for (const dataPoint of anomalyData) {\n            addDataPointToDataset(anomalyDatasetId, dataPoint);\n          }\n        }\n\n        if (resourceDatasetId) {\n          for (const dataPoint of resourceData) {\n            addDataPointToDataset(resourceDatasetId, dataPoint);\n          }\n        }\n      }\n    } finally {\n      setIsProcessingData(false);\n    }\n  }, [getOrCreateDatasetBySource, addDataPointToDataset]);\n\n  // Helper function to add data points in batches using the worker\n  const addDataPointsBatch = async (datasetId: string, dataPoints: DataPoint[]): Promise<void> => {\n    if (!dataProcessingServiceRef.current || dataPoints.length === 0) return;\n\n    try {\n      // Use the worker to filter out duplicates\n      const existingDataset = datasets.find(ds => ds.id === datasetId);\n      if (!existingDataset) return;\n\n      const existingIds = new Set(existingDataset.dataPoints.map(dp => dp.id));\n\n      // Filter out duplicate data points - can use the worker for this with large datasets\n      const uniqueDataPoints = dataPoints.filter(dp => !existingIds.has(dp.id));\n\n      if (uniqueDataPoints.length === 0) return;\n\n      // Add the filtered data points to the dataset\n      addDataPointsToDataset(datasetId, uniqueDataPoints);\n    } catch (error) {\n      console.error('Error in batch processing:', error);\n      // Fallback to individual adds\n      for (const dataPoint of dataPoints) {\n        addDataPointToDataset(datasetId, dataPoint);\n      }\n    }\n  };\n\n  // Worker-based filtering for datasets\n  const filterDataset = useCallback(\n    async (\n      datasetId: string,\n      filters: Array<{\n        field: string;\n        operator:\n          | 'equals'\n          | 'notEquals'\n          | 'greaterThan'\n          | 'lessThan'\n          | 'contains'\n          | 'notContains'\n          | 'between';\n        value: string | number | boolean | string[] | [number, number];\n      }>\n    ): Promise<DataPoint[]> => {\n      const dataset = datasets.find(ds => ds.id === datasetId);\n      if (!dataset) return [];\n\n      setIsProcessingData(true);\n\n      try {\n        // Use the worker for filtering if available\n        if (dataProcessingServiceRef.current && dataset.dataPoints.length > 100) {\n          try {\n            // Offload filtering to worker for large datasets\n            const filteredData = await dataProcessingServiceRef.current.filterData(\n              dataset.dataPoints,\n              filters.map(filter => ({\n                key: filter.field,\n                operator: mapOperator(filter.operator),\n                value: filter.value,\n              }))\n            );\n            setIsProcessingData(false);\n            return filteredData as DataPoint[];\n          } catch (error) {\n            console.error('Worker filtering error:', error);\n            // Continue to fallback\n          }\n        }\n\n        // Fallback to main thread filtering\n        if (!dataCollectionServiceRef.current) {\n          // Simple filtering if the service is not available\n          const filteredData = dataset.dataPoints.filter(dataPoint =>\n            filters.every(filter => {\n              // Treat DataPoint as a Record with unknown values for filtering\n              const value = getNestedProperty(\n                dataPoint as unknown as Record<string, unknown>,\n                filter.field\n              );\n\n              switch (filter.operator) {\n                case 'equals':\n                  return value === filter.value;\n                case 'notEquals':\n                  return value !== filter.value;\n                case 'greaterThan':\n                  return (\n                    typeof value === 'number' &&\n                    typeof filter.value === 'number' &&\n                    value > filter.value\n                  );\n                case 'lessThan':\n                  return (\n                    typeof value === 'number' &&\n                    typeof filter.value === 'number' &&\n                    value < filter.value\n                  );\n                case 'contains':\n                  if (typeof value === 'string' && typeof filter.value === 'string') {\n                    return value.toLowerCase().includes(filter.value.toLowerCase());\n                  }\n                  if (Array.isArray(value)) {\n                    return value.includes(filter.value);\n                  }\n                  return false;\n                case 'notContains':\n                  if (typeof value === 'string' && typeof filter.value === 'string') {\n                    return !value.toLowerCase().includes(filter.value.toLowerCase());\n                  }\n                  if (Array.isArray(value)) {\n                    return !value.includes(filter.value);\n                  }\n                  return false;\n                case 'between':\n                  if (\n                    typeof value === 'number' &&\n                    Array.isArray(filter.value) &&\n                    filter.value.length === 2\n                  ) {\n                    const [min, max] = filter.value as [number, number];\n                    return value >= min && value <= max;\n                  }\n                  return false;\n                default:\n                  return false;\n              }\n            })\n          );\n          setIsProcessingData(false);\n          return filteredData;\n        }\n\n        // Use the data collection service's filtering capability\n        const filteredData = dataCollectionServiceRef.current.filterData(\n          dataset.dataPoints,\n          filters\n        );\n        setIsProcessingData(false);\n        return filteredData;\n      } catch (error) {\n        setIsProcessingData(false);\n        console.error('Error filtering data:', error);\n        return [];\n      }\n    },\n    [datasets]\n  );\n\n  // Fix the getNestedProperty function with proper typing\n  const getNestedProperty = (obj: Record<string, unknown>, path: string): unknown => {\n    const parts = path.split('.');\n    let current: unknown = obj;\n\n    for (const part of parts) {\n      if (current === undefined || current === null) {\n        return undefined;\n      }\n\n      if (typeof current === 'object' && part in current) {\n        current = (current as Record<string, unknown>)[part];\n      } else {\n        return undefined;\n      }\n    }\n\n    return current;\n  };\n\n  // Get an analysis result by ID\n  const getAnalysisResultById = useCallback(\n    (id: string): AnalysisResult | undefined => {\n      return analysisResults.find(result => result?.id === id);\n    },\n    [analysisResults]\n  );\n\n  // Get analysis results by config ID\n  const getAnalysisResultsByConfigId = useCallback(\n    (configId: string): AnalysisResult[] => {\n      return analysisResults.filter(result => result?.analysisConfigId === configId);\n    },\n    [analysisResults]\n  );\n\n  // Helper function to map filter operators\n  const mapOperator = (\n    operator:\n      | 'equals'\n      | 'notEquals'\n      | 'greaterThan'\n      | 'lessThan'\n      | 'contains'\n      | 'notContains'\n      | 'between'\n  ): '==' | '!=' | '>' | '<' | '>=' | '<=' | 'contains' | 'startsWith' | 'endsWith' => {\n    switch (operator) {\n      case 'equals':\n        return '==';\n      case 'notEquals':\n        return '!=';\n      case 'greaterThan':\n        return '>';\n      case 'lessThan':\n        return '<';\n      case 'contains':\n        return 'contains';\n      // For 'between' and 'notContains', we'll need custom handling in the filter function\n      // For now, default to a reasonable operator\n      case 'notContains':\n        return '!=';\n      case 'between':\n        return '>=';\n      default:\n        return '==';\n    }\n  };\n\n  // Create the context value object\n  const contextValue: DataAnalysisContextType = {\n    datasets,\n    analysisConfigs,\n    analysisResults,\n    createDataset,\n    updateDataset,\n    deleteDataset,\n    getDatasetById,\n    createAnalysisConfig,\n    updateAnalysisConfig,\n    deleteAnalysisConfig,\n    getAnalysisConfigById,\n    runAnalysis,\n    getAnalysisResultById,\n    getAnalysisResultsByConfigId,\n    getOrCreateDatasetBySource,\n    addDataPointToDataset,\n    refreshData,\n    // Use the original filterDataset function but make it synchronous\n    filterDataset: (datasetId, filters) => {\n      // This is a workaround to convert the async function to a sync one\n      // In a real application, you would refactor the interface to be async\n      const emptyResult: DataPoint[] = [];\n\n      // Start the async process but return empty results immediately\n      setTimeout(() => {\n        filterDataset(datasetId, filters)\n          .then(results => {\n            console.warn(`Filtered ${results.length} results for dataset ${datasetId}`);\n          })\n          .catch(error => {\n            console.error('Error in filterDataset:', error);\n          });\n      }, 0);\n\n      return emptyResult;\n    },\n  };\n\n  return (\n    <DataAnalysisContext.Provider value={contextValue}>{children}</DataAnalysisContext.Provider>\n  );\n};\n\n/**\n * Hook to use the DataAnalysisContext\n */\nexport const useDataAnalysis = (): DataAnalysisContextType => {\n  const context = useContext(DataAnalysisContext);\n  if (context === undefined) {\n    throw new Error('useDataAnalysis must be used within a DataAnalysisProvider');\n  }\n  return context;\n};\n\n// Export the context for testing\nexport { DataAnalysisContext };\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/contexts/GameContext.tsx","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":541,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":541,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15347,15350],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15347,15350],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":547,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":547,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15579,15582],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15579,15582],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":553,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":553,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15812,15815],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15812,15815],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":559,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":559,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16046,16049],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16046,16049],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":565,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":565,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16288,16291],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16288,16291],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":635,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":635,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18478,18481],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18478,18481],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/contexts/ModuleContext.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_dispatchLegacyAction' is defined but never used. Allowed unused vars must match /^ignored|^temp/u.","line":287,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":287,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'action' is defined but never used.","line":287,"column":50,"nodeType":null,"messageId":"unusedVar","endLine":287,"endColumn":56},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'data' is defined but never used.","line":287,"column":66,"nodeType":null,"messageId":"unusedVar","endLine":287,"endColumn":70},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":631,"column":3,"nodeType":"MemberExpression","messageId":"limited","endLine":631,"endColumn":14,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[18660,18730],"text":""},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, {\n  createContext,\n  ReactNode,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useReducer,\n} from 'react';\nimport { BaseState } from '../lib/contexts/BaseContext';\nimport { serviceRegistry } from '../lib/managers/ServiceRegistry';\nimport { moduleManager } from '../managers/module/ModuleManager';\nimport { moduleManagerWrapper } from '../managers/module/ModuleManagerWrapper';\nimport { ModularBuilding, ModuleType } from '../types/buildings/ModuleTypes';\nimport { BaseEvent, EventType } from '../types/events/EventTypes';\nimport {\n  IModuleManager,\n  LegacyModuleAction,\n  Module,\n  moduleEventToEventType,\n  ModuleEventType,\n  ModuleStatus,\n} from '../types/modules/ModuleTypes';\nimport { ResourceType } from './../types/resources/ResourceTypes';\n\n/**\n * Enum for action types to ensure type safety\n */\nexport enum ModuleActionType {\n  ADD_MODULE = 'module/addModule',\n  UPDATE_MODULE = 'module/updateModule',\n  REMOVE_MODULE = 'module/removeModule',\n  SELECT_MODULE = 'module/selectModule',\n  SET_ACTIVE_MODULES = 'module/setActiveModules',\n  SET_CATEGORIES = 'module/setCategories',\n  SET_LOADING = 'module/setLoading',\n  SET_ERROR = 'module/setError',\n}\n\n/**\n * Interface for actions that can be dispatched to the module reducer\n */\nexport interface ModuleAction {\n  type: ModuleActionType;\n  payload: {\n    module?: Module;\n    moduleId?: string;\n    updates?: Partial<Module>;\n    activeModuleIds?: string[];\n    selectedModuleId?: string | null;\n    categories?: string[];\n    isLoading?: boolean;\n    error?: string | null;\n  };\n}\n\n/**\n * Interface defining the state structure for the module context\n */\nexport interface ModuleState extends BaseState {\n  modules: Record<string, Module>;\n  activeModuleIds: string[];\n  selectedModuleId: string | null;\n  categories: string[];\n  buildings: ModularBuilding[]; // Needed for the helper functions\n}\n\n/**\n * Default initial state for the module context\n */\nconst initialState: ModuleState = {\n  modules: {},\n  activeModuleIds: [],\n  selectedModuleId: null,\n  categories: [],\n  buildings: [],\n  isLoading: false,\n  error: null,\n  lastUpdated: Date.now(),\n};\n\n// Action Creators\n\nexport const createAddModuleAction = (module: Module): ModuleAction => ({\n  type: ModuleActionType.ADD_MODULE,\n  payload: { module },\n});\n\nexport const createUpdateModuleAction = (\n  moduleId: string,\n  updates: Partial<Module>\n): ModuleAction => ({\n  type: ModuleActionType.UPDATE_MODULE,\n  payload: { moduleId, updates },\n});\n\nexport const createRemoveModuleAction = (moduleId: string): ModuleAction => ({\n  type: ModuleActionType.REMOVE_MODULE,\n  payload: { moduleId },\n});\n\nexport const createSelectModuleAction = (selectedModuleId: string | null): ModuleAction => ({\n  type: ModuleActionType.SELECT_MODULE,\n  payload: { selectedModuleId },\n});\n\nexport const createSetActiveModulesAction = (activeModuleIds: string[]): ModuleAction => ({\n  type: ModuleActionType.SET_ACTIVE_MODULES,\n  payload: { activeModuleIds },\n});\n\nexport const createSetCategoriesAction = (categories: string[]): ModuleAction => ({\n  type: ModuleActionType.SET_CATEGORIES,\n  payload: { categories },\n});\n\nexport const createSetLoadingAction = (isLoading: boolean): ModuleAction => ({\n  type: ModuleActionType.SET_LOADING,\n  payload: { isLoading },\n});\n\nexport const createSetErrorAction = (error: string | null): ModuleAction => ({\n  type: ModuleActionType.SET_ERROR,\n  payload: { error },\n});\n\n// Reducer function\n\nexport const moduleReducer = (state: ModuleState, action: ModuleAction): ModuleState => {\n  // Define variables outside case blocks to satisfy linter\n  let newActiveModuleIds: string[];\n  let newSelectedModuleId: string | null;\n  let removedModule: Module | undefined;\n  let remainingModules: Record<string, Module>;\n\n  switch (action.type) {\n    case ModuleActionType.ADD_MODULE:\n      if (!action.payload.module) {\n        return state;\n      }\n      return {\n        ...state,\n        modules: {\n          ...state.modules,\n          [action.payload.module.id]: action.payload.module,\n        },\n        lastUpdated: Date.now(),\n      };\n    case ModuleActionType.UPDATE_MODULE:\n      if (!action.payload.moduleId || !action.payload.updates) {\n        return state;\n      }\n\n      if (!state.modules[action.payload.moduleId]) {\n        return state;\n      }\n\n      return {\n        ...state,\n        modules: {\n          ...state.modules,\n          [action.payload.moduleId]: {\n            ...state.modules[action.payload.moduleId],\n            ...action.payload.updates,\n          },\n        },\n        lastUpdated: Date.now(),\n      };\n    case ModuleActionType.REMOVE_MODULE:\n      if (!action.payload.moduleId) {\n        return state;\n      }\n\n      // Define these outside case block to satisfy linter\n      removedModule = state.modules[action.payload.moduleId];\n      if (!removedModule) {\n        return state;\n      }\n\n      // Create a new modules object without the removed module\n      remainingModules = { ...state.modules };\n      delete remainingModules[action.payload.moduleId];\n\n      // Remove from active modules if present\n      newActiveModuleIds = state.activeModuleIds.filter(id => id !== action.payload.moduleId);\n\n      // Clear selected module if it's being removed\n      newSelectedModuleId =\n        state.selectedModuleId === action.payload.moduleId ? null : state.selectedModuleId;\n\n      return {\n        ...state,\n        modules: remainingModules,\n        activeModuleIds: newActiveModuleIds,\n        selectedModuleId: newSelectedModuleId,\n        lastUpdated: Date.now(),\n      };\n    case ModuleActionType.SELECT_MODULE:\n      return {\n        ...state,\n        selectedModuleId: action.payload.selectedModuleId ?? null,\n        lastUpdated: Date.now(),\n      };\n    case ModuleActionType.SET_ACTIVE_MODULES:\n      if (!action.payload.activeModuleIds) {\n        return state;\n      }\n      return {\n        ...state,\n        activeModuleIds: action.payload.activeModuleIds,\n        lastUpdated: Date.now(),\n      };\n    case ModuleActionType.SET_CATEGORIES:\n      if (!action.payload.categories) {\n        return state;\n      }\n      return {\n        ...state,\n        categories: action.payload.categories,\n        lastUpdated: Date.now(),\n      };\n    case ModuleActionType.SET_LOADING:\n      return {\n        ...state,\n        isLoading: action.payload.isLoading || false,\n      };\n    case ModuleActionType.SET_ERROR:\n      return {\n        ...state,\n        error: action.payload.error ?? null,\n        isLoading: false,\n      };\n    default:\n      return state;\n  }\n};\n\n// Selectors\nexport const selectModules = (state: ModuleState) => state.modules;\nexport const selectModuleById = (state: ModuleState, id: string) => state.modules[id];\nexport const selectActiveModules = (state: ModuleState) => {\n  return state.activeModuleIds.map(id => state.modules[id]).filter(Boolean);\n};\nexport const selectSelectedModule = (state: ModuleState) => {\n  return state.selectedModuleId ? state.modules[state.selectedModuleId] : null;\n};\nexport const selectCategories = (state: ModuleState) => state.categories;\nexport const selectModulesByType = (state: ModuleState, type: ModuleType) => {\n  return Object.values(state.modules).filter(module => module.type === type);\n};\nexport const selectModulesByStatus = (state: ModuleState, status: ModuleStatus) => {\n  return Object.values(state.modules).filter(module => module.status === status);\n};\n\n// Context type definition\ntype ModuleContextType = {\n  state: ModuleState;\n  dispatch: React.Dispatch<ModuleAction>;\n  manager?: IModuleManager; // Use the extended interface\n};\n\n// Create context\nconst ModuleContext = createContext<ModuleContextType | undefined>(undefined);\n\n// Provider props interface\ninterface ModuleProviderProps {\n  children: ReactNode;\n  manager?: IModuleManager;\n  initialState?: Partial<ModuleState>;\n}\n\n// Type-safe helper for event subscriptions that accepts any event bus type\nfunction subscribeToModuleEvent(\n  eventBus: {\n    subscribe: (eventType: EventType | '*', handler: (event: BaseEvent) => void) => () => void;\n  },\n  eventType: ModuleEventType,\n  handler: (event: BaseEvent) => void\n): () => void {\n  // Convert ModuleEventType to EventType using our helper function\n  const convertedType = moduleEventToEventType(eventType) as EventType;\n  // Safely subscribe with any event bus type\n  return eventBus.subscribe(convertedType, handler);\n}\n\n// Helper for type-safe dispatch of legacy actions\nfunction _dispatchLegacyAction(moduleId: string, action: string, data?: unknown): void {\n  console.warn('[ModuleContext] Legacy dispatch is deprecated, use moduleManager instead');\n  const module = moduleManager.getModule(moduleId);\n  \n  if (!module) {\n    console.error(`[ModuleContext] Module not found: ${moduleId}`);\n    return;\n  }\n  \n  // ... rest of the function\n}\n\n// Provider component\nexport const ModuleProvider: React.FC<ModuleProviderProps> = ({\n  children,\n  manager = moduleManagerWrapper, // Use the wrapper which implements IModuleManager\n  initialState: initialStateOverride,\n}) => {\n  // Create effective initial state\n  const effectiveInitialState = useMemo(() => {\n    // Get initial modules from manager if available\n    if (manager) {\n      try {\n        const modules = manager.getActiveModules() ?? [];\n        const moduleMap = modules.reduce((acc: Record<string, Module>, module: Module) => {\n          acc[module.id] = module;\n          return acc;\n        }, {});\n\n        return {\n          ...initialState,\n          modules: moduleMap,\n          activeModuleIds: modules.map(m => m.id),\n          categories: manager.getModuleCategories?.() ?? [],\n          buildings: manager.getBuildings?.() ?? [],\n          ...(initialStateOverride ?? {}),\n        };\n      } catch (error) {\n        console.error('Error initializing module state from manager:', error);\n      }\n    }\n\n    return { ...initialState, ...(initialStateOverride ?? {}) };\n  }, [manager, initialStateOverride]);\n\n  // Create reducer\n  const [state, dispatch] = useReducer(moduleReducer, effectiveInitialState);\n\n  // Set up event subscriptions\n  useEffect(() => {\n    if (!manager) {\n      return undefined;\n    }\n\n    // Use eventBus instead of 'events' - fixed property name\n    const moduleEvents = manager.eventBus;\n    if (!moduleEvents) {\n      return undefined;\n    }\n\n    // Module event handlers\n    const handleModuleCreated = (event: BaseEvent) => {\n      if (event?.data && typeof event.data === 'object' && 'module' in event.data) {\n        // Safely access module property with proper type checking\n        const moduleData = event.data;\n        if (moduleData && 'module' in moduleData && moduleData.module) {\n          const module = moduleData.module as Module;\n          dispatch(createAddModuleAction(module));\n        }\n      }\n    };\n\n    const handleModuleUpdated = (event: BaseEvent) => {\n      if (\n        event?.data &&\n        typeof event.data === 'object' &&\n        'moduleId' in event.data &&\n        'updates' in event.data\n      ) {\n        // Safely extract values with proper type checking\n        const eventData = event.data;\n        if (eventData && 'moduleId' in eventData && 'updates' in eventData) {\n          const moduleId = eventData.moduleId as string;\n          const updates = eventData.updates as Partial<Module>;\n          dispatch(createUpdateModuleAction(moduleId, updates));\n        }\n      }\n    };\n\n    const handleModuleRemoved = (event: BaseEvent) => {\n      if (event?.data && typeof event.data === 'object' && 'moduleId' in event.data) {\n        // Safely access moduleId property with proper type checking\n        const eventData = event.data;\n        if (eventData && 'moduleId' in eventData && eventData.moduleId) {\n          const moduleId = eventData.moduleId as string;\n          dispatch(createRemoveModuleAction(moduleId));\n        }\n      }\n    };\n\n    const handleStatusChanged = (event: BaseEvent) => {\n      if (\n        event?.data &&\n        typeof event.data === 'object' &&\n        'moduleId' in event.data &&\n        'status' in event.data\n      ) {\n        // Safely extract values with proper type checking\n        const eventData = event.data;\n        if (eventData && 'moduleId' in eventData && 'status' in eventData) {\n          const moduleId = eventData.moduleId as string;\n          const status = eventData.status as ModuleStatus;\n          dispatch(createUpdateModuleAction(moduleId, { status }));\n        }\n      }\n    };\n\n    // Set up subscriptions using type-safe wrapper\n    const unsubModuleCreated = subscribeToModuleEvent(\n      moduleEvents,\n      ModuleEventType.MODULE_CREATED,\n      handleModuleCreated\n    );\n\n    const unsubModuleUpdated = subscribeToModuleEvent(\n      moduleEvents,\n      ModuleEventType.MODULE_UPDATED,\n      handleModuleUpdated\n    );\n\n    const unsubModuleRemoved = subscribeToModuleEvent(\n      moduleEvents,\n      ModuleEventType.MODULE_REMOVED,\n      handleModuleRemoved\n    );\n\n    const unsubStatusChanged = subscribeToModuleEvent(\n      moduleEvents,\n      ModuleEventType.MODULE_STATUS_CHANGED,\n      handleStatusChanged\n    );\n\n    // Clean up subscriptions\n    return () => {\n      if (unsubModuleCreated) {\n        unsubModuleCreated();\n      }\n      if (unsubModuleUpdated) {\n        unsubModuleUpdated();\n      }\n      if (unsubModuleRemoved) {\n        unsubModuleRemoved();\n      }\n      if (unsubStatusChanged) {\n        unsubStatusChanged();\n      }\n    };\n  }, [manager]);\n\n  // Create context value\n  const contextValue = useMemo(() => ({ state, dispatch, manager }), [state, manager]);\n\n  return <ModuleContext.Provider value={contextValue}>{children}</ModuleContext.Provider>;\n};\n\n// Hooks\n\n// Generic module state selector hook\nexport const useModules = <T,>(selector: (state: ModuleState) => T): T => {\n  const context = useContext(ModuleContext);\n  if (!context) {\n    throw new Error('useModules must be used within a ModuleProvider');\n  }\n  return selector(context.state);\n};\n\n// Hook to access the full context\nexport const useModuleContext = () => {\n  const context = useContext(ModuleContext);\n  if (!context) {\n    throw new Error('useModuleContext must be used within a ModuleProvider');\n  }\n  return context;\n};\n\n// Hook to get the dispatch function only\nexport const useModuleDispatch = (): React.Dispatch<ModuleAction> => {\n  const context = useContext(ModuleContext);\n  if (!context) {\n    throw new Error('useModuleDispatch must be used within a ModuleProvider');\n  }\n  return context.dispatch;\n};\n\n// Specialized hooks\nexport const useModule = (moduleId: string): Module | undefined => {\n  return useModules(state => selectModuleById(state, moduleId));\n};\n\nexport const useActiveModules = (): Module[] => {\n  return useModules(selectActiveModules);\n};\n\nexport const useSelectedModule = (): Module | null => {\n  return useModules(selectSelectedModule);\n};\n\nexport const useModuleCategories = (): string[] => {\n  return useModules(selectCategories);\n};\n\nexport const useModulesByType = (type: ModuleType): Module[] => {\n  return useModules(state => selectModulesByType(state, type));\n};\n\nexport const useModulesByStatus = (status: ModuleStatus): Module[] => {\n  return useModules(state => selectModulesByStatus(state, status));\n};\n\n// Module action hooks\nexport const useModuleActions = () => {\n  const { dispatch, manager } = useModuleContext();\n\n  return {\n    addModule: useCallback(\n      (module: Module) => {\n        dispatch(createAddModuleAction(module));\n      },\n      [dispatch]\n    ),\n\n    updateModule: useCallback(\n      (moduleId: string, updates: Partial<Module>) => {\n        dispatch(createUpdateModuleAction(moduleId, updates));\n      },\n      [dispatch]\n    ),\n\n    removeModule: useCallback(\n      (moduleId: string) => {\n        dispatch(createRemoveModuleAction(moduleId));\n      },\n      [dispatch]\n    ),\n\n    selectModule: useCallback(\n      (moduleId: string | null) => {\n        dispatch(createSelectModuleAction(moduleId));\n      },\n      [dispatch]\n    ),\n\n    setActiveModules: useCallback(\n      (activeModuleIds: string[]) => {\n        dispatch(createSetActiveModulesAction(activeModuleIds));\n      },\n      [dispatch]\n    ),\n\n    setCategories: useCallback(\n      (categories: string[]) => {\n        dispatch(createSetCategoriesAction(categories));\n      },\n      [dispatch]\n    ),\n\n    activateModule: useCallback(\n      (moduleId: string) => {\n        if (manager && manager.activateModule) {\n          manager.activateModule(moduleId);\n        }\n      },\n      [manager]\n    ),\n\n    deactivateModule: useCallback(\n      (moduleId: string) => {\n        if (manager && manager.deactivateModule) {\n          manager.deactivateModule(moduleId);\n        }\n      },\n      [manager]\n    ),\n  };\n};\n\n// Helper hooks for building-related functionality\nexport function useSelectedBuilding() {\n  const selectedModule = useSelectedModule();\n  return selectedModule?.buildingId && moduleManager.getBuilding\n    ? moduleManager.getBuilding(selectedModule.buildingId)\n    : null;\n}\n\nexport function useBuildingModules(buildingId: string) {\n  return useModules(state => Object.values(state.modules).filter(m => m.buildingId === buildingId));\n}\n\nexport function canBuildModule(\n  _moduleType: ModuleType,\n  cost: { minerals?: number; energy?: number }\n) {\n  const mineralCost = cost.minerals ?? 0;\n  const energyCost = cost.energy ?? 0;\n\n  // Check if the player has enough resources\n  const resourceManager = serviceRegistry.getService('ResourceManager');\n  if (!resourceManager) {\n    console.error('Resource manager not found');\n    return false;\n  }\n\n  // Safely access resource amounts\n  let currentMinerals = 0;\n  let currentEnergy = 0;\n\n  try {\n    // Type assertion to a more specific interface with getResourceAmount\n    const typedResourceManager = resourceManager as unknown as {\n      getResourceAmount: (resourceType: ResourceType) => number;\n    };\n\n    currentMinerals = typedResourceManager.getResourceAmount(ResourceType.MINERALS) ?? 0;\n    currentEnergy = typedResourceManager.getResourceAmount(ResourceType.ENERGY) ?? 0;\n  } catch (error) {\n    console.error('Error getting resource amounts:', error);\n    return false;\n  }\n\n  if (currentMinerals < mineralCost || currentEnergy < energyCost) {\n    console.warn(\n      `Cannot build module: not enough resources. Needs ${mineralCost} minerals and ${energyCost} energy.`\n    );\n    return false;\n  }\n\n  // Add other conditions as needed\n  return true;\n}\n\nexport function buildModule(moduleType: ModuleType, \n  // Rename _cost to cost and remove the underscore since ESLint flags it\n  cost: { minerals?: number; energy?: number }) {\n  // Maybe use cost within the method\n  console.log(`Building module of type ${moduleType} with cost:`, cost);\n  \n  // Get the first colony building to attach the module to\n  const buildings = moduleManagerWrapper.getBuildings();\n  const targetBuilding = buildings.find(building => building.type === 'colony');\n\n  if (!targetBuilding) {\n    console.error('No colony building found to attach module to');\n    return;\n  }\n\n  // Get an available attachment point\n  const attachmentPoints = targetBuilding.attachmentPoints ?? [];\n\n  // Find modules attached to this building\n  const modules = moduleManagerWrapper.getModules();\n\n  const usedPoints = modules\n    .filter((module: Module) => module.buildingId === targetBuilding.id)\n    .map((module: Module) => module.attachmentPointId)\n    .filter(Boolean) as string[];\n\n  const availablePoints = attachmentPoints.filter(point => !usedPoints.includes(point.id));\n\n  if (availablePoints.length === 0) {\n    console.error('No available attachment points on colony building');\n    return;\n  }\n\n  const targetPoint = availablePoints[0].id;\n\n  // Create the module\n  const position = { x: Math.random() * 100, y: Math.random() * 100 };\n\n  // Use safer type assertion with LegacyModuleAction interface\n  const legacyCreateAction: LegacyModuleAction = {\n    type: 'CREATE_MODULE',\n    moduleType,\n    position,\n  };\n\n  moduleManagerWrapper.dispatch(legacyCreateAction);\n\n  // Get the newly created module's ID (it will be the last one created)\n  const newModule = moduleManagerWrapper.getModulesByType(moduleType).pop();\n\n  if (!newModule) {\n    console.error('Failed to create new module');\n    return;\n  }\n\n  // Attach the module to the building\n  const legacyAttachAction: LegacyModuleAction = {\n    type: 'ATTACH_MODULE',\n    moduleId: newModule.id,\n    buildingId: targetBuilding.id,\n    attachmentPointId: targetPoint,\n  };\n\n  moduleManagerWrapper.dispatch(legacyAttachAction);\n\n  // Activate the module\n  const legacyActivateAction: LegacyModuleAction = {\n    type: 'SET_MODULE_ACTIVE',\n    moduleId: newModule.id,\n    active: true,\n  };\n\n  moduleManagerWrapper.dispatch(legacyActivateAction);\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/contexts/ResourceRatesContext.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_CoreResourceType' is defined but never used. Allowed unused vars must match /^ignored|^temp/u.","line":11,"column":6,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as React from 'react';\nimport { createContext, useContext, useEffect, useMemo, useReducer } from 'react';\nimport { ResourceManager } from '../managers/game/ResourceManager';\nimport { BaseEvent, EventType } from '../types/events/EventTypes';\nimport { ResourceType } from './../types/resources/ResourceTypes';\n\n/**\n * We're focusing only on the core resources for this context\n */\n// Replace string-based type with enum\ntype _CoreResourceType =\n  | ResourceType.MINERALS\n  | ResourceType.ENERGY\n  | ResourceType.POPULATION\n  | ResourceType.RESEARCH;\n\n/**\n * Interface for resource rates, including production, consumption and net rate\n */\ninterface ResourceRateDetail {\n  production: number;\n  consumption: number;\n  net: number; // net rate (production - consumption)\n}\n\n/**\n * Enum for action types to ensure type safety\n */\nexport enum ResourceRatesActionType {\n  UPDATE_RESOURCE_RATE = 'resourceRates/updateResourceRate',\n  UPDATE_ALL_RATES = 'resourceRates/updateAllRates',\n  RESET_RATES = 'resourceRates/resetRates',\n  SET_LOADING = 'resourceRates/setLoading',\n  SET_ERROR = 'resourceRates/setError',\n}\n\n/**\n * Type for actions that can be dispatched to the context\n */\nexport interface ResourceRatesAction {\n  type: ResourceRatesActionType;\n  payload: {\n    resourceType?: ResourceType;\n    rates?: ResourceRateDetail;\n    allRates?: Record<ResourceType, ResourceRateDetail>;\n    isLoading?: boolean;\n    error?: string | null;\n  };\n}\n\n/**\n * State interface extended with BaseState for standardized properties\n */\nexport interface ResourceRatesState {\n  resourceRates: Record<ResourceType, ResourceRateDetail>;\n  isLoading: boolean;\n  error: string | null;\n  lastUpdated: number;\n}\n\n/**\n * Default state with all rates at zero\n */\nconst defaultResourceRates: Record<ResourceType, ResourceRateDetail> = {\n  [ResourceType.FOOD]: { production: 0, consumption: 0, net: 0 },\n  [ResourceType.MINERALS]: { production: 0, consumption: 0, net: 0 },\n  [ResourceType.ENERGY]: { production: 0, consumption: 0, net: 0 },\n  [ResourceType.POPULATION]: { production: 0, consumption: 0, net: 0 },\n  [ResourceType.RESEARCH]: { production: 0, consumption: 0, net: 0 },\n  [ResourceType.PLASMA]: { production: 0, consumption: 0, net: 0 },\n  [ResourceType.GAS]: { production: 0, consumption: 0, net: 0 },\n  [ResourceType.EXOTIC]: { production: 0, consumption: 0, net: 0 },\n  [ResourceType.ORGANIC]: { production: 0, consumption: 0, net: 0 },\n  // Add missing resource types\n  [ResourceType.IRON]: { production: 0, consumption: 0, net: 0 },\n  [ResourceType.COPPER]: { production: 0, consumption: 0, net: 0 },\n  [ResourceType.TITANIUM]: { production: 0, consumption: 0, net: 0 },\n  [ResourceType.URANIUM]: { production: 0, consumption: 0, net: 0 },\n  [ResourceType.WATER]: { production: 0, consumption: 0, net: 0 },\n  [ResourceType.HELIUM]: { production: 0, consumption: 0, net: 0 },\n  [ResourceType.DEUTERIUM]: { production: 0, consumption: 0, net: 0 },\n  [ResourceType.ANTIMATTER]: { production: 0, consumption: 0, net: 0 },\n  [ResourceType.DARK_MATTER]: { production: 0, consumption: 0, net: 0 },\n  [ResourceType.EXOTIC_MATTER]: { production: 0, consumption: 0, net: 0 },\n};\n\n/**\n * The initial state including BaseState properties\n */\nconst initialState: ResourceRatesState = {\n  resourceRates: defaultResourceRates,\n  isLoading: false,\n  error: null,\n  lastUpdated: Date.now(),\n};\n\n/**\n * Action creators for type-safe dispatch\n */\nexport const createUpdateRateAction = (\n  resourceType: ResourceType,\n  rates: ResourceRateDetail\n): ResourceRatesAction => ({\n  type: ResourceRatesActionType.UPDATE_RESOURCE_RATE,\n  payload: { resourceType, rates },\n});\n\nexport const createUpdateAllRatesAction = (\n  allRates: Record<ResourceType, ResourceRateDetail>\n): ResourceRatesAction => ({\n  type: ResourceRatesActionType.UPDATE_ALL_RATES,\n  payload: { allRates },\n});\n\nexport const createResetRatesAction = (): ResourceRatesAction => ({\n  type: ResourceRatesActionType.RESET_RATES,\n  payload: {},\n});\n\nexport const createSetLoadingAction = (isLoading: boolean): ResourceRatesAction => ({\n  type: ResourceRatesActionType.SET_LOADING,\n  payload: { isLoading },\n});\n\nexport const createSetErrorAction = (error: string | null): ResourceRatesAction => ({\n  type: ResourceRatesActionType.SET_ERROR,\n  payload: { error },\n});\n\n/**\n * Helper function to calculate resource rates from event data\n */\nconst calculateRatesFromEvent = (event: BaseEvent): ResourceRateDetail => {\n  // Extract resource rate data from event\n  // This implementation would depend on the event structure\n  const { production = 0, consumption = 0 } =\n    (event?.data as { production?: number; consumption?: number }) ?? {};\n\n  return {\n    production,\n    consumption,\n    net: production - consumption,\n  };\n};\n\n/**\n * Reducer function for state updates\n */\nexport const resourceRatesReducer = (\n  state: ResourceRatesState,\n  action: ResourceRatesAction\n): ResourceRatesState => {\n  switch (action.type) {\n    case ResourceRatesActionType.UPDATE_RESOURCE_RATE:\n      if (!action.payload.resourceType || !action.payload.rates) {\n        return state;\n      }\n      return {\n        ...state,\n        resourceRates: {\n          ...state.resourceRates,\n          [action.payload.resourceType]: action.payload.rates,\n        },\n        lastUpdated: Date.now(),\n      };\n\n    case ResourceRatesActionType.UPDATE_ALL_RATES:\n      if (!action.payload.allRates) {\n        return state;\n      }\n      return {\n        ...state,\n        resourceRates: action.payload.allRates,\n        lastUpdated: Date.now(),\n      };\n\n    case ResourceRatesActionType.RESET_RATES:\n      return {\n        ...state,\n        resourceRates: defaultResourceRates,\n        isLoading: false,\n        error: null,\n        lastUpdated: Date.now(),\n      };\n\n    case ResourceRatesActionType.SET_LOADING:\n      return {\n        ...state,\n        isLoading: !!action.payload.isLoading,\n      };\n\n    case ResourceRatesActionType.SET_ERROR:\n      return {\n        ...state,\n        error: action.payload.error || null,\n        isLoading: false,\n      };\n\n    default:\n      return state;\n  }\n};\n\n// Create context\ntype ResourceRatesContextType = {\n  state: ResourceRatesState;\n  dispatch: React.Dispatch<ResourceRatesAction>;\n};\n\nconst ResourceRatesContext = createContext<ResourceRatesContextType | undefined>(undefined);\n\n// Provider component\nexport const ResourceRatesProvider: React.FC<{\n  children: React.ReactNode;\n  manager?: ResourceManager;\n  initialState?: Partial<ResourceRatesState>;\n}> = ({ children, manager, initialState: initialStateOverride }) => {\n  // Get initial state from ResourceManager if available\n  const effectiveInitialState = useMemo((): ResourceRatesState => {\n    if (manager) {\n      try {\n        // Ensure we have a complete set of resource rates\n        const managerRates = manager.getAllResourceRates?.() ?? {};\n        const rates = { ...defaultResourceRates, ...managerRates };\n\n        return {\n          ...initialState,\n          resourceRates: rates,\n          ...(initialStateOverride ?? {}),\n        } as ResourceRatesState;\n      } catch (error) {\n        console.error('Error getting resource rates from manager:', error);\n      }\n    }\n    return { ...initialState, ...(initialStateOverride ?? {}) } as ResourceRatesState;\n  }, [manager, initialStateOverride]);\n\n  // Create reducer\n  const [state, dispatch] = useReducer(resourceRatesReducer, effectiveInitialState);\n\n  // Set up event subscriptions with the manager when provided\n  useEffect(() => {\n    if (manager) {\n      // Create event handler with dispatch\n      const eventHandler = (event: BaseEvent) => {\n        if (event.data && typeof event.data === 'object' && 'resourceType' in event.data) {\n          const resourceType = event.data.resourceType as ResourceType;\n          const rates = calculateRatesFromEvent(event);\n          dispatch(createUpdateRateAction(resourceType, rates));\n        }\n      };\n\n      // Set up event subscriptions\n      const unsubscribeResourceUpdated = manager.subscribeToEvent(\n        EventType.RESOURCE_UPDATED,\n        eventHandler\n      );\n\n      const unsubscribeResourceProduced = manager.subscribeToEvent(\n        EventType.RESOURCE_PRODUCED,\n        eventHandler\n      );\n\n      const unsubscribeResourceConsumed = manager.subscribeToEvent(\n        EventType.RESOURCE_CONSUMED,\n        eventHandler\n      );\n\n      // Clean up subscriptions\n      return () => {\n        unsubscribeResourceUpdated();\n        unsubscribeResourceProduced();\n        unsubscribeResourceConsumed();\n      };\n    }\n    return undefined;\n  }, [manager]);\n\n  // Create context value\n  const contextValue = useMemo(() => ({ state, dispatch }), [state]);\n\n  return (\n    <ResourceRatesContext.Provider value={contextValue}>{children}</ResourceRatesContext.Provider>\n  );\n};\n\n// Hook to use the context\nexport const useResourceRates = <T,>(selector: (state: ResourceRatesState) => T): T => {\n  const context = useContext(ResourceRatesContext);\n  if (!context) {\n    throw new Error('useResourceRates must be used within a ResourceRatesProvider');\n  }\n  return selector(context.state);\n};\n\n// Hook to use the dispatch function\nexport const useResourceRatesDispatch = (): React.Dispatch<ResourceRatesAction> => {\n  const context = useContext(ResourceRatesContext);\n  if (!context) {\n    throw new Error('useResourceRatesDispatch must be used within a ResourceRatesProvider');\n  }\n  return context.dispatch;\n};\n\n// Specialized hooks for specific resource types\nexport const useResourceRate = (resourceType: ResourceType): ResourceRateDetail => {\n  return useResourceRates((state: ResourceRatesState) => state.resourceRates[resourceType]);\n};\n\nexport const useNetResourceRate = (resourceType: ResourceType): number => {\n  return useResourceRates((state: ResourceRatesState) => {\n    const rates = state.resourceRates[resourceType];\n    return rates ? rates.net : 0;\n  });\n};\n\n// Hook to access all resource rates at once\nexport const useAllResourceRates = () => {\n  return useResourceRates((state: ResourceRatesState) => ({\n    minerals: state.resourceRates[ResourceType.MINERALS],\n    energy: state.resourceRates[ResourceType.ENERGY],\n    population: state.resourceRates[ResourceType.POPULATION],\n    research: state.resourceRates[ResourceType.RESEARCH],\n    plasma: state.resourceRates[ResourceType.PLASMA],\n    gas: state.resourceRates[ResourceType.GAS],\n    exotic: state.resourceRates[ResourceType.EXOTIC],\n  }));\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/contexts/ShipContext.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/contexts/ThemeContext.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/contexts/ThresholdContext.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getResourceName' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":45,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":45,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as React from 'react';\nimport { ResourceRegistryIntegration } from '../registry/ResourceRegistryIntegration';\nimport { ResourceType } from '../types/resources/ResourceTypes';\nimport { ThresholdAction, ThresholdState, initialState, thresholdEvents } from './ThresholdTypes';\n\n// Types\nexport interface Resource {\n  id: string;\n  name: string;\n  type: ResourceType;\n  currentAmount: number;\n  maxCapacity: number;\n  thresholds: {\n    min: number;\n    max: number;\n  };\n  autoMine: boolean;\n}\n\nexport interface ThresholdPreset {\n  id: string;\n  name: string;\n  description: string;\n  thresholds: Record<string, { min: number; max: number }>;\n  autoMineStates: Record<string, boolean>;\n}\n\nexport interface ThresholdHistoryEntry {\n  timestamp: number;\n  resourceId: ResourceType;\n  amount: number;\n  thresholds: {\n    min: number;\n    max: number;\n  };\n  event: 'threshold_change' | 'amount_update' | 'auto_mine_toggle';\n}\n\ninterface ThresholdContextType {\n  state: ThresholdState;\n  dispatch: React.Dispatch<ThresholdAction>;\n}\n\n// Helper function to get resource name for display\nconst getResourceName = (resourceType: ResourceType): string => {\n  const resourceRegistry = ResourceRegistryIntegration.getInstance();\n  return resourceRegistry.getDisplayName(resourceType);\n};\n\n// Reducer\nfunction thresholdReducer(state: ThresholdState, action: ThresholdAction): ThresholdState {\n  switch (action.type) {\n    case 'SET_THRESHOLD': {\n      const historyEntry = {\n        timestamp: Date.now(),\n        resourceId: action.payload.resourceId as ResourceType,\n        amount: state.resources[action.payload.resourceId]?.currentAmount ?? 0,\n        thresholds: {\n          min: action.payload.min,\n          max: action.payload.max,\n        },\n        event: 'threshold_change' as const,\n      };\n\n      return {\n        ...state,\n        resources: {\n          ...state.resources,\n          [action.payload.resourceId]: {\n            ...state.resources[action.payload.resourceId],\n            thresholds: {\n              min: action.payload.min,\n              max: action.payload.max,\n            },\n          },\n        },\n        history: [...state.history, historyEntry].slice(-100),\n      };\n    }\n\n    case 'UPDATE_AMOUNT': {\n      const resource = state.resources[action.payload.resourceId];\n      if (!resource) {\n        return state;\n      }\n\n      const updatedResource = {\n        ...resource,\n        currentAmount: action.payload.amount,\n      };\n\n      const historyEntry = {\n        timestamp: Date.now(),\n        resourceId: action.payload.resourceId as ResourceType,\n        amount: action.payload.amount,\n        thresholds: resource.thresholds,\n        event: 'amount_update' as const,\n      };\n\n      // Check for threshold violations\n      if (updatedResource.autoMine) {\n        if (updatedResource.currentAmount < updatedResource.thresholds.min) {\n          thresholdEvents.next({\n            type: 'THRESHOLD_VIOLATED',\n            resourceId: action.payload.resourceId as ResourceType,\n            details: {\n              type: 'below_minimum',\n              current: updatedResource.currentAmount,\n              min: updatedResource.thresholds.min,\n            },\n          });\n        } else if (updatedResource.currentAmount > updatedResource.thresholds.max) {\n          thresholdEvents.next({\n            type: 'STORAGE_FULL',\n            resourceId: action.payload.resourceId as ResourceType,\n            details: {\n              type: 'above_maximum',\n              current: updatedResource.currentAmount,\n              max: updatedResource.thresholds.max,\n            },\n          });\n        }\n      }\n\n      return {\n        ...state,\n        resources: {\n          ...state.resources,\n          [action.payload.resourceId]: updatedResource,\n        },\n        history: [...state.history, historyEntry].slice(-100),\n      };\n    }\n\n    case 'TOGGLE_AUTO_MINE': {\n      const resource = state.resources[action.payload.resourceId];\n      if (!resource) {\n        return state;\n      }\n\n      const newAutoMine = !resource.autoMine;\n\n      const historyEntry = {\n        timestamp: Date.now(),\n        resourceId: action.payload.resourceId as ResourceType,\n        amount: resource.currentAmount,\n        thresholds: resource.thresholds,\n        event: 'auto_mine_toggle' as const,\n      };\n\n      if (newAutoMine) {\n        thresholdEvents.next({\n          type: 'AUTO_MINE_TRIGGERED',\n          resourceId: action.payload.resourceId as ResourceType,\n          details: { type: 'below_minimum', current: resource.currentAmount },\n        });\n      }\n\n      return {\n        ...state,\n        resources: {\n          ...state.resources,\n          [action.payload.resourceId]: {\n            ...resource,\n            autoMine: newAutoMine,\n          },\n        },\n        history: [...state.history, historyEntry].slice(-100),\n      };\n    }\n\n    case 'ADD_PRESET':\n      return {\n        ...state,\n        presets: [...state.presets, action.payload],\n      };\n\n    case 'REMOVE_PRESET':\n      return {\n        ...state,\n        presets: state.presets.filter(preset => preset.id !== action.payload.presetId),\n        activePresetId:\n          state.activePresetId === action.payload.presetId ? null : state.activePresetId,\n      };\n\n    case 'APPLY_PRESET': {\n      const preset = state.presets.find(p => p.id === action.payload.presetId);\n      if (!preset) {\n        return state;\n      }\n\n      const updatedResources = { ...state.resources };\n      Object.entries(preset.thresholds).forEach(([resourceId, thresholds]) => {\n        if (updatedResources[resourceId]) {\n          updatedResources[resourceId] = {\n            ...updatedResources[resourceId],\n            thresholds,\n            autoMine: preset.autoMineStates[resourceId] || false,\n          };\n        }\n      });\n\n      return {\n        ...state,\n        resources: updatedResources,\n        activePresetId: action.payload.presetId,\n      };\n    }\n\n    case 'SET_GLOBAL_AUTO_MINE': {\n      const updatedResources = Object.entries(state.resources).reduce(\n        (acc, [id, resource]) => ({\n          ...acc,\n          [id]: { ...resource, autoMine: action.payload },\n        }),\n        {}\n      );\n\n      return {\n        ...state,\n        globalAutoMine: action.payload,\n        resources: updatedResources,\n      };\n    }\n\n    case 'ADD_NOTIFICATION':\n      return {\n        ...state,\n        notifications: [...state.notifications, action.payload],\n      };\n\n    case 'CLEAR_NOTIFICATION':\n      return {\n        ...state,\n        notifications: state.notifications.filter((_, index) => index !== action.payload),\n      };\n\n    case 'ADD_RESOURCE':\n      return {\n        ...state,\n        resources: {\n          ...state.resources,\n          [action.payload.id]: action.payload,\n        },\n      };\n\n    case 'REMOVE_RESOURCE': {\n      const remainingResources = { ...state.resources };\n      delete remainingResources[action.payload.resourceId];\n      return {\n        ...state,\n        resources: remainingResources,\n      };\n    }\n\n    case 'ADD_HISTORY_ENTRY':\n      return {\n        ...state,\n        history: [...state.history, action.payload].slice(-100),\n      };\n\n    default:\n      return state;\n  }\n}\n\n// Context\nconst ThresholdContext = React.createContext<ThresholdContextType | undefined>(undefined);\n\n// Provider\nexport function ThresholdProvider({ children }: { children: React.ReactNode }) {\n  const [state, dispatch] = React.useReducer(thresholdReducer, initialState);\n\n  return (\n    <ThresholdContext.Provider value={{ state, dispatch }}>{children}</ThresholdContext.Provider>\n  );\n}\n\n// Hook\nexport function useThreshold() {\n  const context = React.useContext(ThresholdContext);\n  if (context === undefined) {\n    throw new Error('useThreshold must be used within a ThresholdProvider');\n  }\n  return context;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/contexts/ThresholdTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/BackgroundEffect.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/BuildingUpgradeEffect.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/CapitalShipEffect.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/CentralMothership.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/ColonyStarStation.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/CombatAutomationEffect.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/EngineTrailEffect.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_progress' is defined but never used.","line":40,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":40,"endColumn":31}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { RenderBatcher } from '../../lib/optimization/RenderBatcher';\nimport { Position } from '../../types/core/Position';\nimport { VisualEffect, VisualEffectConfig } from './VisualEffect';\n\ninterface EngineTrailConfig extends VisualEffectConfig {\n  engineSize: number;\n  enginePower: number;\n  velocity: Position;\n}\n\n/**\n * Visual effect for ship engine trails\n */\nexport class EngineTrailEffect extends VisualEffect {\n  protected override config: EngineTrailConfig;\n  private trailPoints: Array<{\n    position: Position;\n    size: number;\n    opacity: number;\n    rotation: number;\n    time: number;\n  }> = [];\n  private lastEmitTime: number = 0;\n  private emitInterval: number = 50; // ms\n\n  constructor(config: EngineTrailConfig) {\n    super(config);\n    this.config = config;\n  }\n\n  protected getEffectType(): string {\n    return 'engine-trail';\n  }\n\n  protected onStart(): void {\n    this.lastEmitTime = Date.now();\n    console.warn(`[EngineTrailEffect] Started with power: ${this.config.enginePower}`);\n  }\n\n  protected onUpdate(_progress: number): void {\n    const now = Date.now();\n\n    // Emit new particles\n    if (now - this.lastEmitTime >= this.emitInterval) {\n      this.emitParticles();\n      this.lastEmitTime = now;\n    }\n\n    // Update existing particles\n    this.updateParticles();\n  }\n\n  protected onComplete(): void {\n    this.trailPoints = [];\n    console.warn('[EngineTrailEffect] Completed');\n  }\n\n  protected onReset(): void {\n    this.trailPoints = [];\n    this.lastEmitTime = 0;\n  }\n\n  protected updateRendering(batcher: RenderBatcher): void {\n    if (!this.batchId) {\n      return;\n    }\n\n    // Render core engine glow\n    this.renderEngineCore(batcher);\n\n    // Render trail particles\n    this.renderTrail(batcher);\n  }\n\n  private emitParticles(): void {\n    const baseSize = this.config.engineSize;\n    const particleCount = Math.ceil(this.config.enginePower * 3);\n\n    for (let i = 0; i < particleCount; i++) {\n      const angle = Math.random() * Math.PI * 2;\n      const spread = this.config.engineSize * 0.3;\n      const offset = {\n        x: Math.cos(angle) * spread,\n        y: Math.sin(angle) * spread,\n      };\n\n      this.trailPoints.push({\n        position: {\n          x: this.config.position.x + offset.x,\n          y: this.config.position.y + offset.y,\n        },\n        size: baseSize * (0.5 + Math.random() * 0.5),\n        opacity: 0.8 + Math.random() * 0.2,\n        rotation: angle,\n        time: Date.now(),\n      });\n    }\n\n    // Limit total particles\n    while (this.trailPoints.length > 100) {\n      this.trailPoints.shift();\n    }\n  }\n\n  private updateParticles(): void {\n    const now = Date.now();\n    const deltaTime = 1 / 60; // Assume 60fps for physics\n\n    this.trailPoints = this.trailPoints.filter(point => {\n      // Update position based on velocity\n      point.position.x -= this.config.velocity.x * deltaTime;\n      point.position.y -= this.config.velocity.y * deltaTime;\n\n      // Add some turbulence\n      const age = (now - point.time) / 1000;\n      const turbulence = Math.sin(age * 10 + point.rotation) * 2;\n      point.position.x += Math.cos(point.rotation) * turbulence * deltaTime;\n      point.position.y += Math.sin(point.rotation) * turbulence * deltaTime;\n\n      // Fade out based on age\n      point.opacity = Math.max(0, point.opacity - deltaTime);\n\n      // Keep particle if still visible\n      return point.opacity > 0;\n    });\n  }\n\n  private renderEngineCore(batcher: RenderBatcher): void {\n    const time = Date.now() / 1000;\n    const pulse = Math.sin(time * 10) * 0.2 + 0.8;\n    const coreSize = this.config.engineSize * this.config.enginePower;\n\n    // Core glow\n    batcher.addItem(this.batchId!, {\n      id: `${this.id}-core`,\n      position: this.config.position,\n      size: { width: coreSize * 2, height: coreSize * 2 },\n      rotation: 0,\n      opacity: 0.8 * pulse,\n      color: this.config.color || '#00ffff',\n      shader: 'additive',\n    });\n\n    // Inner core\n    batcher.addItem(this.batchId!, {\n      id: `${this.id}-inner`,\n      position: this.config.position,\n      size: { width: coreSize, height: coreSize },\n      rotation: time * 2,\n      opacity: 1,\n      color: '#ffffff',\n      shader: 'additive',\n    });\n  }\n\n  private renderTrail(batcher: RenderBatcher): void {\n    this.trailPoints.forEach((point, index) => {\n      const time = Date.now() / 1000;\n      const flicker = Math.sin(time * 20 + index) * 0.2 + 0.8;\n\n      // Trail particle\n      batcher.addItem(this.batchId!, {\n        id: `${this.id}-trail-${index}`,\n        position: point.position,\n        size: { width: point.size, height: point.size },\n        rotation: point.rotation + time,\n        opacity: point.opacity * flicker,\n        color: this.config.color || '#00ffff',\n        shader: 'additive',\n      });\n\n      // Particle glow\n      batcher.addItem(this.batchId!, {\n        id: `${this.id}-glow-${index}`,\n        position: point.position,\n        size: { width: point.size * 2, height: point.size * 2 },\n        rotation: -point.rotation + time,\n        opacity: point.opacity * 0.5 * flicker,\n        color: this.config.color || '#00ffff',\n        shader: 'additive',\n      });\n    });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/ExplorationHub.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/ExplosionEffect.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/FormationTransitionEffect.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/HabitableWorld.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/MineralProcessing.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/ModuleUpgradeTransition.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/MothershipSuperstructure.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/PopulationIndicator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/ProgressionEffects.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/ResourceFlowVisualization.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/ShieldEffect.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/ShieldImpactEffect.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_progress' is defined but never used.","line":61,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":61,"endColumn":31}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { RenderBatcher } from '../../lib/optimization/RenderBatcher';\nimport { Position } from '../../types/core/Position';\nimport { VisualEffect, VisualEffectConfig } from './VisualEffect';\n\n// Extend the RenderBatcher interface to include the missing methods\ndeclare module '../../lib/optimization/RenderBatcher' {\n  interface RenderBatcher {\n    drawCircle(options: { x: number; y: number; radius: number; color: string }): void;\n\n    drawHexagon(options: {\n      x: number;\n      y: number;\n      size: number;\n      color: string;\n      strokeColor: string;\n      strokeWidth: number;\n    }): void;\n\n    drawLine(options: { from: Position; to: Position; width: number; color: string }): void;\n  }\n}\n\ninterface ShieldImpactConfig extends VisualEffectConfig {\n  radius: number;\n  damage: number;\n  shieldStrength: number;\n}\n\n/**\n * Visual effect for shield impacts\n */\nexport class ShieldImpactEffect extends VisualEffect {\n  protected override config: ShieldImpactConfig;\n  private ripplePoints: Position[] = [];\n  private hexagonPoints: Position[] = [];\n  private crackPoints: Position[] = [];\n\n  constructor(config: ShieldImpactConfig) {\n    super(config);\n    this.config = config;\n  }\n\n  protected getEffectType(): string {\n    return 'shield-impact';\n  }\n\n  protected onStart(): void {\n    // Create points for the effect\n    this.createRipplePoints();\n    this.createHexagonPoints();\n\n    // Only create cracks if damage is significant\n    if (this.config.damage > this.config.shieldStrength * 0.5) {\n      this.createCrackPoints();\n    }\n\n    // Debug logging\n    console.warn(`[ShieldImpactEffect] Started effect with damage: ${this.config.damage}`);\n  }\n\n  protected onUpdate(_progress: number): void {\n    // Progress is handled in the rendering methods\n  }\n\n  protected onComplete(): void {\n    // Clear points arrays\n    this.ripplePoints = [];\n    this.hexagonPoints = [];\n    this.crackPoints = [];\n\n    console.warn('[ShieldImpactEffect] Completed effect');\n  }\n\n  protected onReset(): void {\n    // Clear points arrays\n    this.ripplePoints = [];\n    this.hexagonPoints = [];\n    this.crackPoints = [];\n  }\n\n  protected updateRendering(batcher: RenderBatcher): void {\n    // Render the shield impact components\n    this.renderRipple(batcher);\n    this.renderHexGrid(batcher);\n\n    // Only render cracks if they exist\n    if (this.crackPoints.length > 0) {\n      this.renderCracks(batcher);\n    }\n  }\n\n  /**\n   * Create points for the ripple effect\n   */\n  private createRipplePoints(): void {\n    const pointCount = 24;\n    this.ripplePoints = [];\n\n    for (let i = 0; i < pointCount; i++) {\n      const angle = (i / pointCount) * Math.PI * 2;\n      this.ripplePoints.push({\n        x: Math.cos(angle),\n        y: Math.sin(angle),\n      });\n    }\n  }\n\n  /**\n   * Create points for the hexagonal grid\n   */\n  private createHexagonPoints(): void {\n    const { radius } = this.config;\n    const hexSize = radius / 4;\n    const hexCount = Math.ceil(radius / hexSize) * 2;\n    this.hexagonPoints = [];\n\n    for (let x = -hexCount; x <= hexCount; x++) {\n      for (let y = -hexCount; y <= hexCount; y++) {\n        // Offset every other row\n        const xPos = x * hexSize * 1.5;\n        const yPos = y * hexSize * Math.sqrt(3) + (x % 2 === 0 ? 0 : (hexSize * Math.sqrt(3)) / 2);\n\n        // Only include points within the radius\n        const dist = Math.sqrt(xPos * xPos + yPos * yPos);\n        if (dist <= radius) {\n          this.hexagonPoints.push({\n            x: xPos,\n            y: yPos,\n          });\n        }\n      }\n    }\n  }\n\n  /**\n   * Create points for the crack effect\n   */\n  private createCrackPoints(): void {\n    const crackCount = Math.ceil((this.config.damage / this.config.shieldStrength) * 5);\n    this.crackPoints = [];\n\n    for (let i = 0; i < crackCount; i++) {\n      const startAngle = Math.random() * Math.PI * 2;\n      const startDist = this.config.radius * 0.2;\n      const length = this.config.radius * (0.5 + Math.random() * 0.5);\n\n      let x = Math.cos(startAngle) * startDist;\n      let y = Math.sin(startAngle) * startDist;\n\n      this.crackPoints.push({ x, y });\n\n      // Create a jagged line for each crack\n      const segments = 5 + Math.floor(Math.random() * 5);\n      for (let j = 0; j < segments; j++) {\n        const segmentLength = length / segments;\n        const jitter = segmentLength * 0.3;\n\n        // Add some randomness to the crack direction\n        // Use a new variable instead of modifying the constant\n        const currentAngle = startAngle + (Math.random() - 0.5) * 0.5 * (j + 1);\n\n        x += Math.cos(currentAngle) * segmentLength + (Math.random() - 0.5) * jitter;\n        y += Math.sin(currentAngle) * segmentLength + (Math.random() - 0.5) * jitter;\n\n        this.crackPoints.push({ x, y });\n      }\n    }\n  }\n\n  /**\n   * Render the ripple effect\n   */\n  private renderRipple(batcher: RenderBatcher): void {\n    const time = Date.now() / 1000;\n    const baseRadius = this.config.radius;\n    const rippleStrength = Math.max(0, 1 - this.progress * 2);\n\n    // Render expanding ripple\n    this.ripplePoints.forEach(point => {\n      // Use the point's normalized direction (x,y) which represents a point on the unit circle\n      // Calculate ripple offset based on time and the point's position for a wave-like effect\n      const angle = Math.atan2(point.y, point.x);\n      const rippleOffset = Math.sin(time * 5 + angle * 3) * 10 * rippleStrength;\n\n      // Apply the offset to the base radius\n      const radius = baseRadius + rippleOffset;\n\n      // Calculate the position using the point's normalized direction and the radius\n      const position = {\n        x: this.config.position.x + point.x * radius,\n        y: this.config.position.y + point.y * radius,\n      };\n\n      // Draw the ripple point\n      batcher.drawCircle({\n        x: position.x,\n        y: position.y,\n        radius: 1 + rippleStrength * 2,\n        color: `rgba(100, 200, 255, ${rippleStrength * 0.7})`,\n      });\n    });\n  }\n\n  /**\n   * Render the hexagonal grid\n   */\n  private renderHexGrid(batcher: RenderBatcher): void {\n    const hexOpacity = Math.max(0, 1 - this.progress * 1.5);\n    const hexSize = this.config.radius / 4;\n\n    // Render hexagonal grid\n    this.hexagonPoints.forEach(point => {\n      const position = {\n        x: this.config.position.x + point.x,\n        y: this.config.position.y + point.y,\n      };\n\n      // Calculate distance from center for fade effect\n      const dist = Math.sqrt(point.x * point.x + point.y * point.y);\n      const distFactor = 1 - dist / this.config.radius;\n\n      // Draw hexagon\n      batcher.drawHexagon({\n        x: position.x,\n        y: position.y,\n        size: hexSize * (0.8 + distFactor * 0.2),\n        color: `rgba(100, 200, 255, ${hexOpacity * distFactor * 0.5})`,\n        strokeColor: `rgba(150, 220, 255, ${hexOpacity * distFactor * 0.8})`,\n        strokeWidth: 1,\n      });\n    });\n  }\n\n  /**\n   * Render the crack effect\n   */\n  private renderCracks(batcher: RenderBatcher): void {\n    const crackOpacity = Math.max(0, 1 - this.progress * 1.2);\n\n    // Render cracks\n    for (let i = 0; i < this.crackPoints.length - 1; i++) {\n      // Skip if this is the end of a crack segment\n      if (i > 0 && i % 6 === 0) {\n        continue;\n      }\n\n      const start = {\n        x: this.config.position.x + this.crackPoints[i].x,\n        y: this.config.position.y + this.crackPoints[i].y,\n      };\n\n      const end = {\n        x: this.config.position.x + this.crackPoints[i + 1].x,\n        y: this.config.position.y + this.crackPoints[i + 1].y,\n      };\n\n      // Draw crack segment\n      batcher.drawLine({\n        from: start,\n        to: end,\n        width: 2,\n        color: `rgba(200, 230, 255, ${crackOpacity})`,\n      });\n\n      // Add glow effect\n      batcher.drawLine({\n        from: start,\n        to: end,\n        width: 4,\n        color: `rgba(100, 200, 255, ${crackOpacity * 0.5})`,\n      });\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/ShipPathEffect.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/SmokeTrailEffect.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/StarSystemBackdrop.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/ThrusterEffect.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/TradeRouteEffect.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/VisualEffect.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/component_effects/WeaponEffect.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/types_effects/AdvancedWeaponEffects.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/types_effects/EffectTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/types_effects/EnvironmentalHazardEffects.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/types_effects/WeaponEffects.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/types_effects/shipEffects.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/effects/util_effects/effectUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/errorHandling/ErrorBoundary.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/errorHandling/ErrorFallback.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/errorHandling/GlobalErrorBoundary.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'handleReset' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":26,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":26,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as React from 'react';\nimport { ErrorBoundary, ErrorBoundaryProps } from './ErrorBoundary';\n\n/**\n * Global error boundary props\n */\nexport interface GlobalErrorBoundaryProps extends Omit<ErrorBoundaryProps, 'context' | 'fallback'> {\n  /** Whether this is the root boundary (changes styling) */\n  isRoot?: boolean;\n}\n\n/**\n * Global application error boundary\n *\n * This component is designed to be used at the application root level\n * to catch any unhandled errors that bubble up through the component tree.\n */\nexport const GlobalErrorBoundary: React.FC<GlobalErrorBoundaryProps> = ({\n  children,\n  isRoot = false,\n  onError,\n  suppressErrorLogging,\n  metadata,\n  ...props\n}) => {\n  const handleReset = () => {\n    // For a root-level error, we might want to refresh the page\n    if (isRoot) {\n      window.location.reload();\n      return;\n    }\n\n    // Otherwise, just clear any application state as needed\n    // This could include resetting global state, clearing caches, etc.\n  };\n\n  // Custom fallback UI for global error\n  const globalFallback = (error: Error, reset: () => void) => {\n    return (\n      <div className=\"flex min-h-screen items-center justify-center bg-gray-100 px-4\">\n        <div className=\"w-full max-w-lg rounded-lg bg-white p-8 shadow-lg\">\n          <div className=\"mb-6 flex items-center\">\n            <div className=\"mr-4 rounded-full bg-red-100 p-3\">\n              <svg\n                xmlns=\"http://www.w3.org/2000/svg\"\n                className=\"h-6 w-6 text-red-600\"\n                fill=\"none\"\n                viewBox=\"0 0 24 24\"\n                stroke=\"currentColor\"\n              >\n                <path\n                  strokeLinecap=\"round\"\n                  strokeLinejoin=\"round\"\n                  strokeWidth={2}\n                  d=\"M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z\"\n                />\n              </svg>\n            </div>\n            <h1 className=\"text-xl font-bold text-gray-800\">Something went wrong</h1>\n          </div>\n\n          <p className=\"mb-6 text-gray-600\">\n            We're sorry, but something went wrong. Our team has been notified and is working to fix\n            the issue.\n          </p>\n\n          {process.env.NODE_ENV !== 'production' && (\n            <div className=\"mb-6 rounded border border-gray-200 bg-gray-50 p-4\">\n              <h3 className=\"mb-2 font-medium text-gray-800\">Error Details:</h3>\n              <pre className=\"whitespace-pre-wrap break-all text-sm text-red-600\">\n                {error.message}\n              </pre>\n              {error.stack && (\n                <details className=\"mt-2\">\n                  <summary className=\"cursor-pointer text-sm font-medium text-gray-600\">\n                    Stack trace\n                  </summary>\n                  <pre className=\"mt-2 whitespace-pre-wrap break-all text-xs text-gray-600\">\n                    {error.stack}\n                  </pre>\n                </details>\n              )}\n            </div>\n          )}\n\n          <div className=\"flex justify-between\">\n            <button\n              onClick={() => reset()}\n              className=\"rounded bg-red-600 px-4 py-2 text-white transition-colors hover:bg-red-700\"\n            >\n              {isRoot ? 'Reload Application' : 'Try Again'}\n            </button>\n\n            <button\n              onClick={() => {\n                // Navigate to a safe page, like the home page\n                window.location.href = '/';\n              }}\n              className=\"rounded bg-gray-200 px-4 py-2 text-gray-800 transition-colors hover:bg-gray-300\"\n            >\n              Return to Home\n            </button>\n          </div>\n        </div>\n      </div>\n    );\n  };\n\n  return (\n    <ErrorBoundary\n      fallback={globalFallback}\n      context=\"Global\"\n      onError={(error, errorInfo) => {\n        // For root errors, we might want to log analytics events or notify monitoring services\n        if (isRoot) {\n          // Example: Log to analytics\n          try {\n            if (window.gtag) {\n              window.gtag('event', 'error', {\n                event_category: 'Error',\n                event_label: error.message,\n                value: 1,\n              });\n            }\n          } catch (e) {\n            console.error('Failed to log error to analytics:', e);\n          }\n        }\n\n        // Call original onError handler\n        if (onError) {\n          onError(error, errorInfo);\n        }\n      }}\n      suppressErrorLogging={suppressErrorLogging}\n      metadata={{\n        isRoot,\n        ...metadata,\n      }}\n      {...props}\n    >\n      {children}\n    </ErrorBoundary>\n  );\n};\n\n// Add this to global.d.ts if needed\ndeclare global {\n  interface Window {\n    gtag?: (command: string, action: string, params: Record<string, unknown>) => void;\n  }\n}\n\nexport default GlobalErrorBoundary;\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/errorHandling/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/errorHandling/specialized/DataFetchingErrorBoundary.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/errorHandling/specialized/VisualizationErrorBoundary.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/errorHandling/utils/errorBoundaryHOC.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/errorHandling/utils/migration.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/eslint-rules/no-string-resource-types.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/examples/StatePersistenceExample.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/examples/StateSelectorExample.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'createMultiPropertySelector' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":175,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":175,"endColumn":30}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @context: example.state, component-library\n * \n * Example demonstrating how to use context selectors for optimized state management\n */\nimport React, { createContext, useReducer } from 'react';\nimport { createStandardContextSelectors } from '../utils/state/contextSelectors';\nimport { ResourceType } from '../types/resources/ResourceTypes';\n\n// Define our application state\ninterface AppState {\n  user: {\n    id: string;\n    name: string;\n    email: string;\n    preferences: {\n      theme: 'light' | 'dark';\n      notifications: boolean;\n    };\n  } | null;\n  resources: {\n    [key: string]: {\n      id: string;\n      amount: number;\n      rate: number;\n    };\n  };\n  ui: {\n    sidebar: {\n      open: boolean;\n      width: number;\n    };\n    modal: {\n      open: boolean;\n      type: string | null;\n    };\n  };\n  lastUpdated: number;\n}\n\n// Define actions for our reducer\ntype AppAction =\n  | { type: 'SET_USER'; payload: AppState['user'] }\n  | { type: 'UPDATE_RESOURCE'; payload: { id: string; amount: number } }\n  | { type: 'SET_THEME'; payload: 'light' | 'dark' }\n  | { type: 'TOGGLE_SIDEBAR' }\n  | { type: 'OPEN_MODAL'; payload: string }\n  | { type: 'CLOSE_MODAL' };\n\n// Initial state\nconst initialState: AppState = {\n  user: null,\n  resources: {\n    energy: { id: ResourceType.ENERGY, amount: 100, rate: 10 },\n    minerals: { id: ResourceType.MINERALS, amount: 50, rate: 5 }\n  },\n  ui: {\n    sidebar: {\n      open: true,\n      width: 250,\n    },\n    modal: {\n      open: false,\n      type: null,\n    },\n  },\n  lastUpdated: Date.now(),\n};\n\n// Create a reducer\nfunction appReducer(state: AppState, action: AppAction): AppState {\n  switch (action.type) {\n    case 'SET_USER':\n      return {\n        ...state,\n        user: action.payload,\n        lastUpdated: Date.now(),\n      };\n\n    case 'UPDATE_RESOURCE':\n      return {\n        ...state,\n        resources: {\n          ...state.resources,\n          [action.payload.id]: {\n            ...state.resources[action.payload.id],\n            amount: action.payload.amount,\n          },\n        },\n        lastUpdated: Date.now(),\n      };\n\n    case 'SET_THEME':\n      return {\n        ...state,\n        user: state.user\n          ? {\n              ...state.user,\n              preferences: {\n                ...state.user.preferences,\n                theme: action.payload,\n              },\n            }\n          : null,\n        lastUpdated: Date.now(),\n      };\n\n    case 'TOGGLE_SIDEBAR':\n      return {\n        ...state,\n        ui: {\n          ...state.ui,\n          sidebar: {\n            ...state.ui.sidebar,\n            open: !state.ui.sidebar.open,\n          },\n        },\n        lastUpdated: Date.now(),\n      };\n\n    case 'OPEN_MODAL':\n      return {\n        ...state,\n        ui: {\n          ...state.ui,\n          modal: {\n            open: true,\n            type: action.payload,\n          },\n        },\n        lastUpdated: Date.now(),\n      };\n\n    case 'CLOSE_MODAL':\n      return {\n        ...state,\n        ui: {\n          ...state.ui,\n          modal: {\n            ...state.ui.modal,\n            open: false,\n          },\n        },\n        lastUpdated: Date.now(),\n      };\n\n    default:\n      return state;\n  }\n}\n\n// Create context\nconst AppContext = createContext<{ state: AppState; dispatch: React.Dispatch<AppAction> } | undefined>(\n  undefined\n);\n\n// Create the provider component\nexport function AppProvider({ children }: { children: React.ReactNode }) {\n  const [state, dispatch] = useReducer(appReducer, initialState);\n\n  return (\n    <AppContext.Provider value={{ state, dispatch }}>\n      {children}\n    </AppContext.Provider>\n  );\n}\n\n// Create selectors using our enhanced utility\nconst {\n  useState,\n  useDispatch,\n  useSelector,\n  createPropertySelector,\n  createNestedPropertySelector,\n  createMultiPropertySelector,\n} = createStandardContextSelectors<AppState, AppAction>(AppContext);\n\n// Create specific selectors for common state access patterns\nconst useUser = createPropertySelector('user');\nconst useResources = createPropertySelector('resources');\nconst useUIState = createPropertySelector('ui');\nconst useSidebarState = createNestedPropertySelector(['ui', 'sidebar']);\nconst useModalState = createNestedPropertySelector(['ui', 'modal']);\nconst useTheme = () => {\n  const user = useUser();\n  return user?.preferences.theme || 'light';\n};\n\n// Export everything\nexport {\n  useSelector,\n  useDispatch,\n  useState,\n  useUser,\n  useResources,\n  useUIState,\n  useSidebarState,\n  useModalState,\n  useTheme,\n};\n\n// Example components demonstrating selector usage\nexport function ResourceDisplay() {\n  // Only re-renders when resources change\n  const resources = useResources();\n  \n  return (\n    <div>\n      <h3>Resources</h3>\n      <ul>\n        {Object.values(resources).map(resource => (\n          <li key={resource.id}>\n            {resource.id}: {resource.amount} (+{resource.rate}/min)\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n\nexport function UserInfo() {\n  // Only re-renders when user info changes\n  const user = useUser();\n  const dispatch = useDispatch();\n  \n  if (!user) {\n    return (\n      <div>\n        <h3>Please Log In</h3>\n        <button onClick={() => \n          dispatch({\n            type: 'SET_USER',\n            payload: {\n              id: 'user1',\n              name: 'Test User',\n              email: 'test@example.com',\n              preferences: {\n                theme: 'light',\n                notifications: true,\n              },\n            },\n          })\n        }>\n          Log In\n        </button>\n      </div>\n    );\n  }\n  \n  return (\n    <div>\n      <h3>User Information</h3>\n      <p>Name: {user.name}</p>\n      <p>Email: {user.email}</p>\n      <div>\n        <h4>Preferences</h4>\n        <p>Theme: {user.preferences.theme}</p>\n        <button onClick={() => \n          dispatch({\n            type: 'SET_THEME',\n            payload: user.preferences.theme === 'light' ? 'dark' : 'light',\n          })\n        }>\n          Toggle Theme\n        </button>\n      </div>\n    </div>\n  );\n}\n\nexport function SidebarControl() {\n  // Only re-renders when sidebar state changes\n  const sidebar = useSidebarState();\n  const dispatch = useDispatch();\n  \n  return (\n    <div>\n      <h3>Sidebar Controls</h3>\n      <p>Sidebar is {sidebar.open ? 'Open' : 'Closed'}</p>\n      <p>Width: {sidebar.width}px</p>\n      <button onClick={() => dispatch({ type: 'TOGGLE_SIDEBAR' })}>\n        {sidebar.open ? 'Close Sidebar' : 'Open Sidebar'}\n      </button>\n    </div>\n  );\n}\n\nexport function AppDemo() {\n  return (\n    <AppProvider>\n      <div style={{ display: 'flex', gap: '20px' }}>\n        <div>\n          <UserInfo />\n        </div>\n        <div>\n          <ResourceDisplay />\n        </div>\n        <div>\n          <SidebarControl />\n        </div>\n      </div>\n    </AppProvider>\n  );\n} ","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/factories/ships/ShipClassFactory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/automation/useAutomation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/automation/useGlobalAutomation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/combat/useCombatAI.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/combat/useCombatSystem.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'event' is defined but never used.","line":30,"column":87,"nodeType":null,"messageId":"unusedVar","endLine":30,"endColumn":92}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useCallback, useEffect, useState } from 'react';\nimport { getCombatManager } from '../../managers/ManagerRegistry';\nimport { FleetFormation } from '../../types/combat/CombatTypes';\nimport { Position } from '../../types/core/GameTypes';\nimport { CombatUnitStatus } from '../../types/events/CombatEvents';\n\n/**\n * Enhanced combat system hook for managing fleet formations and tactics\n */\nexport function useCombatSystem() {\n  const [threatLevel, setThreatLevel] = useState(0);\n  const [activeUnits, setActiveUnits] = useState(0);\n  const [isActive, setIsActive] = useState(false);\n  const [activeFleets, setActiveFleets] = useState<string[]>([]);\n  const [formations, setFormations] = useState<Record<string, FleetFormation>>({});\n\n  useEffect(() => {\n    const combatManager = getCombatManager();\n\n    // Subscribe to combat events\n    const unsubscribeUnitSpawned = combatManager.subscribe('combat:unit-spawned', event => {\n      setActiveUnits(prev => prev + 1);\n      // Update threat level based on unit type and faction\n      if (event?.faction !== 'player') {\n        setThreatLevel(prev => prev + getThreatValueForUnit(event?.unitType));\n      }\n      setIsActive(true);\n    });\n\n    const unsubscribeUnitDestroyed = combatManager.subscribe('combat:unit-destroyed', event => {\n      setActiveUnits(prev => prev - 1);\n      // Check if combat is still active\n      if (activeUnits <= 1) {\n        setIsActive(false);\n      }\n    });\n\n    // Initial state setup\n    const currentUnits = combatManager.getAllUnits();\n    setActiveUnits(currentUnits.length);\n    setIsActive(currentUnits.length > 0);\n\n    return () => {\n      unsubscribeUnitSpawned();\n      unsubscribeUnitDestroyed();\n    };\n  }, [activeUnits]);\n\n  /**\n   * Update formation configuration for a fleet\n   */\n  const updateFleetFormation = useCallback((fleetId: string, formation: FleetFormation) => {\n    const combatManager = getCombatManager();\n    // Get all units in the fleet\n    const fleetUnits = combatManager.getAllUnits().filter(unit => unit.faction === fleetId);\n\n    // Update each unit's position based on formation\n    fleetUnits.forEach((unit, index) => {\n      const basePosition = unit.position;\n      const offset = calculateFormationOffset(formation.type, index, fleetUnits.length);\n      const newPosition = {\n        x: basePosition.x + offset.x,\n        y: basePosition.y + offset.y,\n      };\n      combatManager.moveUnit(unit.id, newPosition);\n    });\n\n    setFormations(prev => ({\n      ...prev,\n      [fleetId]: formation,\n    }));\n  }, []);\n\n  /**\n   * Update tactical behavior for a fleet\n   */\n  const updateFleetTactic = useCallback(\n    (fleetId: string, tactic: 'flank' | 'charge' | 'kite' | 'hold') => {\n      const combatManager = getCombatManager();\n      const fleetUnits = combatManager.getAllUnits().filter(unit => unit.faction === fleetId);\n\n      // Update each unit's status based on tactic\n      fleetUnits.forEach(unit => {\n        const status = getTacticStatus(tactic);\n        combatManager.changeUnitStatus(unit.id, status);\n      });\n\n      setActiveFleets(prev => {\n        if (!prev.includes(fleetId)) {\n          return [...prev, fleetId];\n        }\n        return prev;\n      });\n    },\n    []\n  );\n\n  /**\n   * Get current formations for all fleets\n   */\n  const getFleetFormations = useCallback(() => {\n    return formations;\n  }, [formations]);\n\n  /**\n   * Get current tactics for all fleets\n   */\n  const getFleetTactics = useCallback(() => {\n    const combatManager = getCombatManager();\n    const units = combatManager.getAllUnits();\n    const tactics: Record<string, string> = {};\n\n    units.forEach(unit => {\n      if (unit.faction && !tactics[unit.faction]) {\n        tactics[unit.faction] = getStatusTactic(unit.status);\n      }\n    });\n\n    return tactics;\n  }, []);\n\n  return {\n    threatLevel,\n    activeUnits,\n    isActive,\n    activeFleets,\n    formations,\n    updateFleetFormation,\n    updateFleetTactic,\n    getFleetFormations,\n    getFleetTactics,\n  };\n}\n\n// Helper function to calculate threat value based on unit type\nfunction getThreatValueForUnit(unitType: string): number {\n  const threatValues: Record<string, number> = {\n    spitflare: 1,\n    starSchooner: 2,\n    orionFrigate: 3,\n    harbringerGalleon: 4,\n    midwayCarrier: 5,\n    motherEarthRevenge: 6,\n  };\n  return threatValues[unitType] || 1;\n}\n\n// Helper function to calculate formation offset based on formation type\nfunction calculateFormationOffset(\n  formationType: 'offensive' | 'defensive' | 'balanced',\n  index: number,\n  totalUnits: number\n): Position {\n  const spacing = 100; // Default spacing\n\n  switch (formationType) {\n    case 'offensive': {\n      // Wedge formation\n      return {\n        x: index * spacing * Math.cos(Math.PI / 4),\n        y: index * spacing * Math.sin(Math.PI / 4),\n      };\n    }\n    case 'defensive': {\n      // Circle formation\n      const angle = (2 * Math.PI * index) / totalUnits;\n      return {\n        x: spacing * Math.cos(angle),\n        y: spacing * Math.sin(angle),\n      };\n    }\n    case 'balanced': {\n      // Line formation\n      return {\n        x: index * spacing,\n        y: 0,\n      };\n    }\n  }\n}\n\n// Helper function to convert tactic to status\nfunction getTacticStatus(tactic: string): CombatUnitStatus {\n  switch (tactic) {\n    case 'flank':\n      return 'moving';\n    case 'charge':\n      return 'attacking';\n    case 'kite':\n      return 'retreating';\n    case 'hold':\n      return 'defending';\n    default:\n      return 'idle';\n  }\n}\n\n// Helper function to convert status to tactic\nfunction getStatusTactic(status: CombatUnitStatus): string {\n  switch (status) {\n    case 'moving':\n      return 'flank';\n    case 'attacking':\n      return 'charge';\n    case 'retreating':\n      return 'kite';\n    case 'defending':\n      return 'hold';\n    default:\n      return 'hold';\n  }\n}\n\nexport function useUnitCombat(unitId: string) {\n  const [unitStatus, setUnitStatus] = useState(() => getCombatManager().getUnitStatus(unitId));\n\n  useEffect(() => {\n    const interval = setInterval(() => {\n      const status = getCombatManager().getUnitStatus(unitId);\n      setUnitStatus(status);\n    }, 250); // More frequent updates for combat units\n\n    return () => clearInterval(interval);\n  }, [unitId]);\n\n  return {\n    status: unitStatus?.status || 'idle',\n    health: unitStatus?.stats?.health ?? 0,\n    shield: unitStatus?.stats?.shield ?? 0,\n    target: unitStatus?.target,\n    position: unitStatus?.position,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/errors/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/errors/useErrorHandler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/events/useEventBatching.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/events/useEventFiltering.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/events/useEventSubscription.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/events/useModuleEvents.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/events/useSystemEvents.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/factions/useAdaptiveAI.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/factions/useDiplomacy.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/factions/useEnemyAI.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/factions/useFactionAI.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/factions/useFactionBehavior.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/factions/useFleetAI.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/factory/createDataFetchHook.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/factory/createLifecycleHook.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/factory/createStateHook.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/factory/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/game/useAnimation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/game/useAssets.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/game/useGameState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/game/useGlobalEvents.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/game/useScalingSystem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/integration/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/integration/useEventSystemIntegration.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/integration/useManagerRegistryIntegration.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/integration/useModuleSystemIntegration.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_event' is defined but never used.","line":203,"column":44,"nodeType":null,"messageId":"unusedVar","endLine":203,"endColumn":50}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @context: ui-system, module-system, hooks-library\n * \n * Hook for integrating UI components with the Module System\n */\nimport { useCallback, useEffect, useState } from 'react';\nimport { moduleEventBus } from '../../lib/events/ModuleEventBus';\nimport { moduleManager } from '../../managers/module/ModuleManager';\nimport { errorLoggingService, ErrorSeverity, ErrorType } from '../../services/ErrorLoggingService';\nimport { BaseModule, ModuleType } from '../../types/buildings/ModuleTypes';\nimport { EventType } from '../../types/events/EventTypes';\nimport { ModuleStatus } from '../../types/modules/ModuleTypes';\n\n/**\n * Hook for retrieving and interacting with a specific module\n * \n * @param moduleId The ID of the module to interact with\n * @returns Object containing module data, status, and module-related functions\n */\nexport function useModule(moduleId: string) {\n  const [module, setModule] = useState<BaseModule | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<Error | null>(null);\n  \n  // Fetch module data\n  useEffect(() => {\n    const fetchModule = () => {\n      try {\n        setLoading(true);\n        \n        // Get module data\n        const moduleData = moduleManager.getModule(moduleId);\n        setModule(moduleData || null);\n        setError(null);\n      } catch (e) {\n        const error = e instanceof Error ? e : new Error(String(e));\n        setError(error);\n        \n        // Log error\n        errorLoggingService.logError(error, ErrorType.RUNTIME, ErrorSeverity.MEDIUM, {\n          component: 'useModule',\n          moduleId\n        });\n      } finally {\n        setLoading(false);\n      }\n    };\n    \n    // Initial fetch\n    fetchModule();\n    \n    // Subscribe to module events\n    const moduleEventTypes = [\n      EventType.MODULE_UPDATED,\n      EventType.MODULE_STATUS_CHANGED,\n      EventType.MODULE_ACTIVATED,\n      EventType.MODULE_DEACTIVATED,\n      EventType.MODULE_UPGRADED\n    ];\n    \n    const unsubscribes = moduleEventTypes.map(eventType => \n      moduleEventBus.subscribe(eventType, (event) => {\n        if (event?.data?.moduleId === moduleId) {\n          fetchModule();\n        }\n      })\n    );\n    \n    // Return cleanup function\n    return () => {\n      unsubscribes.forEach(unsubscribe => unsubscribe());\n    };\n  }, [moduleId]);\n  \n  // Module activation function\n  const activateModule = useCallback(() => {\n    try {\n      // Use setModuleActive method from moduleManager instead of legacy dispatch\n      moduleManager.setModuleActive(moduleId, true);\n      return true;\n    } catch (e) {\n      const error = e instanceof Error ? e : new Error(String(e));\n      setError(error);\n      \n      // Log error\n      errorLoggingService.logError(error, ErrorType.RUNTIME, ErrorSeverity.MEDIUM, {\n        component: 'useModule.activateModule',\n        moduleId\n      });\n      \n      return false;\n    }\n  }, [moduleId]);\n  \n  // Module deactivation function\n  const deactivateModule = useCallback(() => {\n    try {\n      // Use setModuleActive method from moduleManager instead of legacy dispatch\n      moduleManager.setModuleActive(moduleId, false);\n      return true;\n    } catch (e) {\n      const error = e instanceof Error ? e : new Error(String(e));\n      setError(error);\n      \n      // Log error\n      errorLoggingService.logError(error, ErrorType.RUNTIME, ErrorSeverity.MEDIUM, {\n        component: 'useModule.deactivateModule',\n        moduleId\n      });\n      \n      return false;\n    }\n  }, [moduleId]);\n  \n  // Module upgrade function\n  const upgradeModule = useCallback(() => {\n    try {\n      moduleManager.upgradeModule(moduleId);\n      return true;\n    } catch (e) {\n      const error = e instanceof Error ? e : new Error(String(e));\n      setError(error);\n      \n      // Log error\n      errorLoggingService.logError(error, ErrorType.RUNTIME, ErrorSeverity.MEDIUM, {\n        component: 'useModule.upgradeModule',\n        moduleId\n      });\n      \n      return false;\n    }\n  }, [moduleId]);\n  \n  return {\n    module,\n    loading,\n    error,\n    activateModule,\n    deactivateModule,\n    upgradeModule,\n    status: module?.status || ModuleStatus.INACTIVE\n  };\n}\n\n/**\n * Hook for retrieving and interacting with all modules of a specific type\n * \n * @param moduleType Optional type of modules to retrieve (all modules if omitted)\n * @returns Object containing module data, loading state, and module-related functions\n */\nexport function useModules(moduleType?: ModuleType) {\n  const [modules, setModules] = useState<BaseModule[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<Error | null>(null);\n  \n  // Fetch modules\n  useEffect(() => {\n    const fetchModules = () => {\n      try {\n        setLoading(true);\n        \n        // Get modules\n        let moduleData: BaseModule[];\n        \n        if (moduleType) {\n          moduleData = moduleManager.getModulesByType(moduleType);\n        } else {\n          // Get all modules by combining active modules and filtering by type\n          moduleData = Array.from(moduleManager.getActiveModules());\n        }\n        \n        setModules(moduleData || []);\n        setError(null);\n      } catch (e) {\n        const error = e instanceof Error ? e : new Error(String(e));\n        setError(error);\n        \n        // Log error\n        errorLoggingService.logError(error, ErrorType.RUNTIME, ErrorSeverity.MEDIUM, {\n          component: 'useModules',\n          moduleType: moduleType || 'all'\n        });\n      } finally {\n        setLoading(false);\n      }\n    };\n    \n    // Initial fetch\n    fetchModules();\n    \n    // Subscribe to module events\n    const moduleEventTypes = [\n      EventType.MODULE_CREATED,\n      EventType.MODULE_REMOVED,\n      EventType.MODULE_UPDATED,\n      EventType.MODULE_STATUS_CHANGED,\n      EventType.MODULE_ACTIVATED,\n      EventType.MODULE_DEACTIVATED,\n      EventType.MODULE_UPGRADED\n    ];\n    \n    const unsubscribes = moduleEventTypes.map(eventType => \n      moduleEventBus.subscribe(eventType, (_event) => {\n        // Refetch all modules when any module event occurs\n        fetchModules();\n      })\n    );\n    \n    // Return cleanup function\n    return () => {\n      unsubscribes.forEach(unsubscribe => unsubscribe());\n    };\n  }, [moduleType]);\n  \n  // Function to create a new module\n  const createModule = useCallback((moduleConfig: {\n    name: string;\n    type: ModuleType;\n    position?: { x: number; y: number };\n  }) => {\n    try {\n      // Provide default position if not provided\n      const position = moduleConfig.position || { x: 0, y: 0 };\n      return moduleManager.createModule(moduleConfig.type, position);\n    } catch (e) {\n      const error = e instanceof Error ? e : new Error(String(e));\n      setError(error);\n      \n      // Log error\n      errorLoggingService.logError(error, ErrorType.RUNTIME, ErrorSeverity.MEDIUM, {\n        component: 'useModules.createModule',\n        moduleConfig: JSON.stringify(moduleConfig)\n      });\n      \n      return null;\n    }\n  }, []);\n  \n  // Function to remove a module\n  const removeModule = useCallback((moduleId: string) => {\n    try {\n      // Try to use proper removal method or log error if not available\n      // Cast to unknown first then to an interface with optional destroyModule method\n      const extendedManager = moduleManager as unknown as { \n        destroyModule?: (moduleId: string) => boolean \n      };\n      \n      if (typeof extendedManager.destroyModule === 'function') {\n        return extendedManager.destroyModule(moduleId);\n      }\n      \n      console.warn('[useModules] removeModule: No direct module removal method available');\n      moduleEventBus.emit({\n        type: EventType.MODULE_REMOVED,\n        moduleId,\n        moduleType: modules.find(m => m.id === moduleId)?.type || 'unknown' as ModuleType,\n        timestamp: Date.now(),\n        data: { moduleId }\n      });\n      \n      return true;\n    } catch (e) {\n      const error = e instanceof Error ? e : new Error(String(e));\n      setError(error);\n      \n      // Log error\n      errorLoggingService.logError(error, ErrorType.RUNTIME, ErrorSeverity.MEDIUM, {\n        component: 'useModules.removeModule',\n        moduleId\n      });\n      \n      return false;\n    }\n  }, [modules]);\n  \n  return {\n    modules,\n    loading,\n    error,\n    createModule,\n    removeModule,\n    getModuleById: useCallback((id: string) => modules.find(m => m.id === id), [modules])\n  };\n} ","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/integration/useResourceSystemIntegration.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ResourceUpdateEventData' is defined but never used. Allowed unused vars must match /^ignored|^temp/u.","line":10,"column":21,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":44}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @context: ui-system, resource-system, hooks-library\n * \n * Hook for integrating UI components with the Resource System\n */\nimport { useEffect, useState, useCallback } from 'react';\nimport { ResourceType, ResourceState } from '../../types/resources/ResourceTypes';\nimport { getResourceManager } from '../../managers/ManagerRegistry';\nimport { moduleEventBus } from '../../lib/events/ModuleEventBus';\nimport { EventType, ResourceUpdateEventData, isResourceUpdateEventData } from '../../types/events/EventTypes';\nimport { errorLoggingService, ErrorType, ErrorSeverity } from '../../services/ErrorLoggingService';\n\n// Default resource state for fallback\nconst defaultResourceState: ResourceState = {\n  current: 0,\n  max: 1000,\n  min: 0,\n  production: 0,\n  consumption: 0,\n  rate: 0,\n  value: 0,\n};\n\n/**\n * Hook to retrieve and monitor a specific resource from the Resource System\n * \n * @param resourceType The type of resource to monitor\n * @returns Object containing resource state, loading state, and error state\n */\nexport function useResource(resourceType: ResourceType) {\n  const [resourceState, setResourceState] = useState<ResourceState | null>(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<Error | null>(null);\n  \n  // Fetch resource data and subscribe to updates\n  useEffect(() => {\n    // Initial resource fetch\n    const fetchResource = () => {\n      try {\n        setLoading(true);\n        \n        // Get resource manager through registry\n        const resourceManager = getResourceManager();\n        \n        // Get resource state\n        const state = resourceManager.getResourceState(resourceType);\n        setResourceState(state || null);\n        setError(null);\n      } catch (e) {\n        const error = e instanceof Error ? e : new Error(String(e));\n        setError(error);\n        \n        // Log error\n        errorLoggingService.logError(error, ErrorType.UI, ErrorSeverity.MEDIUM, {\n          component: 'useResource',\n          resourceType\n        });\n      } finally {\n        setLoading(false);\n      }\n    };\n    \n    // Initial fetch\n    fetchResource();\n    \n    // Subscribe to resource updates\n    const unsubscribe = moduleEventBus.subscribe(\n      EventType.RESOURCE_UPDATED,\n      (event) => {\n        if (\n          event && \n          event.data && \n          isResourceUpdateEventData(event.data) &&\n          event.data.resourceType === resourceType\n        ) {\n          try {\n            const resourceManager = getResourceManager();\n            setResourceState(resourceManager.getResourceState(resourceType) || null);\n            setError(null);\n          } catch (e) {\n            const error = e instanceof Error ? e : new Error(String(e));\n            setError(error);\n            \n            // Log error\n            errorLoggingService.logError(error, ErrorType.UI, ErrorSeverity.MEDIUM, {\n              component: 'useResource',\n              resourceType,\n              eventType: EventType.RESOURCE_UPDATED\n            });\n          }\n        }\n      }\n    );\n    \n    // Cleanup subscription on unmount\n    return unsubscribe;\n  }, [resourceType]);\n  \n  return {\n    data: resourceState || defaultResourceState,\n    loading,\n    error\n  };\n}\n\n/**\n * Hook to retrieve and monitor all resources of specified types from the Resource System\n * \n * @param resourceTypes Optional array of resource types to monitor (all types if omitted)\n * @returns Object containing map of resource states, loading state, and error state\n */\nexport function useResources(resourceTypes?: ResourceType[]) {\n  const [resources, setResources] = useState<Map<ResourceType, ResourceState>>(new Map());\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<Error | null>(null);\n  \n  // Fetch resources and subscribe to updates\n  useEffect(() => {\n    // Initial resources fetch\n    const fetchResources = () => {\n      try {\n        setLoading(true);\n        \n        // Get resource manager through registry\n        const resourceManager = getResourceManager();\n        \n        // If specific resource types provided, get those\n        if (resourceTypes && resourceTypes.length > 0) {\n          const resourceMap = new Map<ResourceType, ResourceState>();\n          \n          resourceTypes.forEach(type => {\n            const state = resourceManager.getResourceState(type);\n            if (state) {\n              resourceMap.set(type, state);\n            }\n          });\n          \n          setResources(resourceMap);\n        } \n        // Otherwise get all available resources\n        else {\n          // Get all resources using getAllResourceStates\n          try {\n            const allResources = resourceManager.getAllResourceStates();\n            // Convert the record to a Map\n            const resourceMap = new Map<ResourceType, ResourceState>();\n            Object.entries(allResources).forEach(([key, value]) => {\n              resourceMap.set(key as ResourceType, value);\n            });\n            setResources(resourceMap);\n          } catch (e) {\n            // Fallback if getAllResourceStates doesn't exist\n            const resourceMap = new Map<ResourceType, ResourceState>();\n            Object.values(ResourceType).forEach(type => {\n              const state = resourceManager.getResourceState(type);\n              if (state) {\n                resourceMap.set(type, state);\n              }\n            });\n            setResources(resourceMap);\n          }\n        }\n        \n        setError(null);\n      } catch (e) {\n        const error = e instanceof Error ? e : new Error(String(e));\n        setError(error);\n        \n        // Log error\n        errorLoggingService.logError(error, ErrorType.UI, ErrorSeverity.MEDIUM, {\n          component: 'useResources',\n          resourceTypes: resourceTypes ? JSON.stringify(resourceTypes) : 'all'\n        });\n      } finally {\n        setLoading(false);\n      }\n    };\n    \n    // Initial fetch\n    fetchResources();\n    \n    // Subscribe to resource updates\n    const unsubscribe = moduleEventBus.subscribe(\n      EventType.RESOURCE_UPDATED,\n      (event) => {\n        if (event && event.data && isResourceUpdateEventData(event.data)) {\n          const { resourceType } = event.data;\n          \n          // Only update if we care about this resource type\n          if (!resourceTypes || resourceTypes.includes(resourceType)) {\n            try {\n              const resourceManager = getResourceManager();\n              const state = resourceManager.getResourceState(resourceType);\n              \n              if (state) {\n                setResources(prev => {\n                  const updated = new Map(prev);\n                  updated.set(resourceType, state);\n                  return updated;\n                });\n              }\n              \n              setError(null);\n            } catch (e) {\n              const error = e instanceof Error ? e : new Error(String(e));\n              setError(error);\n              \n              // Log error\n              errorLoggingService.logError(error, ErrorType.UI, ErrorSeverity.MEDIUM, {\n                component: 'useResources',\n                resourceType,\n                eventType: EventType.RESOURCE_UPDATED\n              });\n            }\n          }\n        }\n      }\n    );\n    \n    // Cleanup subscription on unmount\n    return unsubscribe;\n  }, [resourceTypes]);\n  \n  return {\n    data: resources,\n    loading,\n    error,\n    // Helper function to get a specific resource\n    getResource: useCallback((type: ResourceType) => {\n      return resources.get(type) || defaultResourceState;\n    }, [resources])\n  };\n}\n\n/**\n * Hook for modifying resource amounts\n * \n * @returns Object with functions to modify resources\n */\nexport function useResourceActions() {\n  const [error, setError] = useState<Error | null>(null);\n  \n  // Add resource amount\n  const addResource = useCallback((resourceType: ResourceType, amount: number): boolean => {\n    try {\n      const resourceManager = getResourceManager();\n      // Return the result of setResourceAmount operation\n      if (amount > 0) {\n        const currentState = resourceManager.getResourceState(resourceType);\n        const newAmount = (currentState?.current || 0) + amount;\n        resourceManager.setResourceAmount(resourceType, newAmount);\n        return true;\n      }\n      return false;\n    } catch (e) {\n      const error = e instanceof Error ? e : new Error(String(e));\n      setError(error);\n      \n      // Log error\n      errorLoggingService.logError(error, ErrorType.UI, ErrorSeverity.MEDIUM, {\n        component: 'useResourceActions',\n        method: 'addResource',\n        resourceType,\n        amount\n      });\n      \n      return false;\n    }\n  }, []);\n  \n  // Consume resource amount\n  const consumeResource = useCallback((resourceType: ResourceType, amount: number): boolean => {\n    try {\n      const resourceManager = getResourceManager();\n      // Return the result of setResourceAmount operation\n      if (amount > 0) {\n        const currentState = resourceManager.getResourceState(resourceType);\n        if (!currentState || currentState.current < amount) {\n          return false;\n        }\n        const newAmount = currentState.current - amount;\n        resourceManager.setResourceAmount(resourceType, newAmount);\n        return true;\n      }\n      return false;\n    } catch (e) {\n      const error = e instanceof Error ? e : new Error(String(e));\n      setError(error);\n      \n      // Log error\n      errorLoggingService.logError(error, ErrorType.UI, ErrorSeverity.MEDIUM, {\n        component: 'useResourceActions',\n        method: 'consumeResource',\n        resourceType,\n        amount\n      });\n      \n      return false;\n    }\n  }, []);\n  \n  // Set resource to specific amount\n  const setResource = useCallback((resourceType: ResourceType, amount: number): boolean => {\n    try {\n      const resourceManager = getResourceManager();\n      resourceManager.setResourceAmount(resourceType, amount);\n      return true;\n    } catch (e) {\n      const error = e instanceof Error ? e : new Error(String(e));\n      setError(error);\n      \n      // Log error\n      errorLoggingService.logError(error, ErrorType.UI, ErrorSeverity.MEDIUM, {\n        component: 'useResourceActions',\n        method: 'setResource',\n        resourceType,\n        amount\n      });\n      \n      return false;\n    }\n  }, []);\n  \n  return {\n    addResource,\n    consumeResource,\n    setResource,\n    error\n  };\n} ","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/modules/useModuleAutomation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/modules/useModuleEvents.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/modules/useModuleState.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_modules' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":60,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":60,"endColumn":17}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":222,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":222,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6312,6315],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6312,6315],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":234,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":234,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6699,6702],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6699,6702],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @file useModuleState.ts\n * Provides standardized hooks for accessing ModuleContext with selector pattern.\n *\n * This implementation:\n * 1. Uses selector pattern for better performance\n * 2. Provides type safety for module state data\n * 3. Offers specialized selectors for different module types and properties\n * 4. Follows the standardized context access pattern\n * 5. Includes performance monitoring for selectors and computations\n */\n\nimport { useCallback, useMemo } from 'react';\nimport { ModuleActionType, useModuleContext, useModules } from '../../contexts/ModuleContext';\nimport { moduleManager } from '../../managers/module/ModuleManager';\nimport {\n  BaseModule,\n  BuildingType,\n  ModularBuilding,\n  ModuleType,\n} from '../../types/buildings/ModuleTypes';\nimport {\n  HookPerformanceConfig,\n  defaultPerformanceConfig,\n  measureComputationTime,\n  measureSelectorTime,\n  trackHookRender,\n} from '../../utils/performance/hookPerformanceMonitor';\n\n// Performance monitoring configuration\nconst moduleStatePerformanceConfig: HookPerformanceConfig = {\n  ...defaultPerformanceConfig,\n  hookName: 'useModuleState',\n};\n\n// Type for the extended state that includes selectedBuildingId\ninterface ExtendedModuleState {\n  selectedBuildingId?: string;\n}\n\n/**\n * Hook to access module state with selector pattern for performance optimization\n *\n * @returns The module state with structured access to modules and helper methods\n */\nexport function useModuleState() {\n  // Track hook render\n  trackHookRender(moduleStatePerformanceConfig);\n\n  const context = useModuleContext();\n  const { state, dispatch } = context;\n\n  // Memoized selectors for different parts of the state - with performance tracking\n  const activeModuleIds = measureSelectorTime(\n    'activeModuleIds',\n    () => useMemo(() => state.activeModuleIds, [state.activeModuleIds]),\n    moduleStatePerformanceConfig\n  );\n\n  const _modules = measureSelectorTime(\n    'modules',\n    () => useMemo(() => Object.values(state.modules), [state.modules]),\n    moduleStatePerformanceConfig\n  );\n\n  const activeModules = measureSelectorTime(\n    'activeModules',\n    () =>\n      useMemo(\n        () => activeModuleIds.map(id => state.modules[id]).filter(Boolean),\n        [activeModuleIds, state.modules]\n      ),\n    moduleStatePerformanceConfig\n  );\n\n  const buildings = measureSelectorTime(\n    'buildings',\n    () => useMemo(() => state.buildings, [state.buildings]),\n    moduleStatePerformanceConfig\n  );\n\n  const selectedModuleId = measureSelectorTime(\n    'selectedModuleId',\n    () => useMemo(() => state.selectedModuleId, [state.selectedModuleId]),\n    moduleStatePerformanceConfig\n  );\n\n  // Use a custom selector for selectedBuildingId since it's not in the ModuleState interface\n  const selectedBuildingId = measureSelectorTime(\n    'selectedBuildingId',\n    () =>\n      useMemo(\n        () => (state as unknown as ExtendedModuleState).selectedBuildingId,\n        [(state as unknown as ExtendedModuleState).selectedBuildingId]\n      ),\n    moduleStatePerformanceConfig\n  );\n\n  // Derived selectors - with performance tracking\n  const selectedModule = measureComputationTime(\n    'selectedModule',\n    () =>\n      useMemo(\n        () => (selectedModuleId ? moduleManager.getModule(selectedModuleId) : undefined),\n        [selectedModuleId]\n      ),\n    moduleStatePerformanceConfig\n  );\n\n  const selectedBuilding = measureComputationTime(\n    'selectedBuilding',\n    () =>\n      useMemo(\n        () => (selectedBuildingId ? moduleManager.getBuilding(selectedBuildingId) : undefined),\n        [selectedBuildingId]\n      ),\n    moduleStatePerformanceConfig\n  );\n\n  const modulesByType = useCallback(\n    (type: ModuleType) =>\n      measureSelectorTime(\n        `modulesByType:${type}`,\n        () => moduleManager.getModulesByType(type),\n        moduleStatePerformanceConfig\n      ),\n    []\n  );\n\n  const buildingModules = useCallback(\n    (buildingId: string) =>\n      measureSelectorTime(\n        `buildingModules:${buildingId}`,\n        () => moduleManager.getBuildingModules(buildingId),\n        moduleStatePerformanceConfig\n      ),\n    []\n  );\n\n  // Action creators with standardized pattern\n  const createModule = useCallback(\n    (moduleType: ModuleType, position: { x: number; y: number }) => {\n      dispatch({\n        type: ModuleActionType.ADD_MODULE,\n        payload: {\n          module: {\n            id: `module-${Date.now()}`,\n            name: `New ${moduleType} Module`,\n            type: moduleType,\n            position,\n            level: 1,\n            status: 'inactive',\n            isActive: false,\n          },\n        },\n      });\n    },\n    [dispatch]\n  );\n\n  const attachModule = useCallback(\n    (moduleId: string, buildingId: string, attachmentPointId: string) => {\n      dispatch({\n        type: ModuleActionType.UPDATE_MODULE,\n        payload: {\n          moduleId,\n          updates: {\n            buildingId,\n            attachmentPointId,\n          },\n        },\n      });\n    },\n    [dispatch]\n  );\n\n  const upgradeModule = useCallback(\n    (moduleId: string) => {\n      const module = state.modules[moduleId];\n      if (!module) return;\n\n      dispatch({\n        type: ModuleActionType.UPDATE_MODULE,\n        payload: {\n          moduleId,\n          updates: {\n            level: module.level + 1,\n          },\n        },\n      });\n    },\n    [dispatch, state.modules]\n  );\n\n  const setModuleActive = useCallback(\n    (moduleId: string, active: boolean) => {\n      dispatch({\n        type: active ? ModuleActionType.SET_ACTIVE_MODULES : ModuleActionType.UPDATE_MODULE,\n        payload: active\n          ? { activeModuleIds: [...state.activeModuleIds, moduleId] }\n          : { moduleId, updates: { isActive: false } },\n      });\n    },\n    [dispatch, state.activeModuleIds]\n  );\n\n  const selectModule = useCallback(\n    (moduleId: string | null) => {\n      dispatch({\n        type: ModuleActionType.SELECT_MODULE,\n        payload: { selectedModuleId: moduleId },\n      });\n    },\n    [dispatch]\n  );\n\n  // Custom action types - using type assertion to avoid TypeScript errors\n  const selectBuilding = useCallback(\n    (buildingId: string) => {\n      // Use a valid ModuleActionType and include the buildingId in the payload\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (dispatch as any)({\n        type: ModuleActionType.SELECT_MODULE,\n        payload: { selectedBuildingId: buildingId },\n      });\n    },\n    [dispatch]\n  );\n\n  const registerBuilding = useCallback(\n    (building: ModularBuilding) => {\n      // Use a valid ModuleActionType and include the building in the payload\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (dispatch as any)({\n        type: ModuleActionType.UPDATE_MODULE,\n        payload: { building },\n      });\n    },\n    [dispatch]\n  );\n\n  const updateActiveModules = useCallback(\n    (modules: BaseModule[]) => {\n      dispatch({\n        type: ModuleActionType.SET_ACTIVE_MODULES,\n        payload: { activeModuleIds: modules.map(m => m.id) },\n      });\n    },\n    [dispatch]\n  );\n\n  // Utility functions - with performance tracking when appropriate\n  const isModuleActive = useCallback(\n    (moduleId: string) =>\n      measureComputationTime(\n        `isModuleActive:${moduleId}`,\n        () => {\n          const module = moduleManager.getModule(moduleId);\n          return module ? module.isActive : false;\n        },\n        moduleStatePerformanceConfig\n      ),\n    []\n  );\n\n  const getModuleLevel = useCallback(\n    (moduleId: string) =>\n      measureComputationTime(\n        `getModuleLevel:${moduleId}`,\n        () => {\n          const module = moduleManager.getModule(moduleId);\n          return module ? module.level : 0;\n        },\n        moduleStatePerformanceConfig\n      ),\n    []\n  );\n\n  const getAttachmentPointsForBuilding = useCallback(\n    (buildingId: string) =>\n      measureSelectorTime(\n        `getAttachmentPoints:${buildingId}`,\n        () => {\n          const building = moduleManager.getBuilding(buildingId);\n          return building ? building.attachmentPoints : [];\n        },\n        moduleStatePerformanceConfig\n      ),\n    []\n  );\n\n  const getAvailableAttachmentPoints = useCallback(\n    (building: ModularBuilding, moduleType: ModuleType) => {\n      if (!building || !building.attachmentPoints) return [];\n\n      return building.attachmentPoints.filter(\n        p => p.allowedTypes.includes(moduleType) && !p.currentModule\n      );\n    },\n    [state.modules]\n  );\n\n  const getBuildingsByType = useCallback(\n    (type: BuildingType) =>\n      measureComputationTime(\n        `getBuildingsByType:${type}`,\n        () => {\n          return buildings.filter(building => building.type === type);\n        },\n        moduleStatePerformanceConfig\n      ),\n    [buildings]\n  );\n\n  // Return structured state and actions - measure computation time for the final object assembly\n  return measureComputationTime(\n    'returnStateObject',\n    () => ({\n      // State selectors\n      modules: {\n        all: moduleManager.getActiveModules(),\n        active: activeModules,\n        selected: selectedModule,\n        byType: modulesByType,\n      },\n\n      buildings: {\n        all: buildings,\n        selected: selectedBuilding,\n        byType: getBuildingsByType,\n        modules: buildingModules,\n        attachmentPoints: getAttachmentPointsForBuilding,\n        availableAttachmentPoints: getAvailableAttachmentPoints,\n      },\n\n      selection: {\n        selectedModuleId,\n        selectedBuildingId,\n      },\n\n      // Actions\n      actions: {\n        createModule,\n        attachModule,\n        upgradeModule,\n        setModuleActive,\n        selectModule,\n        selectBuilding,\n        registerBuilding,\n        updateActiveModules,\n      },\n\n      // Utilities\n      utils: {\n        isModuleActive,\n        getModuleLevel,\n        getAttachmentPointsForBuilding,\n        getAvailableAttachmentPoints,\n        getBuildingsByType,\n      },\n    }),\n    moduleStatePerformanceConfig\n  );\n}\n\n/**\n * Hook to access only active modules\n *\n * @returns Array of active modules\n */\nexport function useActiveModules(): BaseModule[] {\n  // Performance tracking configuration\n  const performanceConfig: HookPerformanceConfig = {\n    ...defaultPerformanceConfig,\n    hookName: 'useActiveModules',\n  };\n\n  // Track hook render\n  trackHookRender(performanceConfig);\n\n  return measureSelectorTime(\n    'activeModules',\n    () => {\n      const modules = useModules(state => state.modules);\n      const activeModuleIds = useModules(state => state.activeModuleIds);\n      // Cast to BaseModule[] to satisfy TypeScript\n      return Object.values(modules).filter(module => {\n        // Type guard to ensure module has an id property\n        if (module && typeof module === 'object' && 'id' in module) {\n          return activeModuleIds.includes(module.id as string);\n        }\n        return false;\n      }) as BaseModule[];\n    },\n    performanceConfig\n  );\n}\n\n/**\n * Hook to access only buildings\n *\n * @returns Array of buildings\n */\nexport function useBuildings(): ModularBuilding[] {\n  // Performance tracking configuration\n  const performanceConfig: HookPerformanceConfig = {\n    ...defaultPerformanceConfig,\n    hookName: 'useBuildings',\n  };\n\n  // Track hook render\n  trackHookRender(performanceConfig);\n\n  return measureSelectorTime(\n    'buildings',\n    () => useModules(state => state.buildings),\n    performanceConfig\n  );\n}\n\n/**\n * Hook to access modules of a specific type\n *\n * @param type The module type to filter by\n * @returns Array of modules of the specified type\n */\nexport function useModulesByType(type: ModuleType): BaseModule[] {\n  // Performance tracking configuration\n  const performanceConfig: HookPerformanceConfig = {\n    ...defaultPerformanceConfig,\n    hookName: 'useModulesByType',\n  };\n\n  // Track hook render\n  trackHookRender(performanceConfig);\n\n  return measureComputationTime(\n    `modulesByType:${type}`,\n    () => moduleManager.getModulesByType(type),\n    performanceConfig\n  );\n}\n\n/**\n * Hook to access the selected module data\n *\n * @returns The currently selected module or undefined\n */\nexport function useSelectedModuleData(): BaseModule | undefined {\n  // Performance tracking configuration\n  const performanceConfig: HookPerformanceConfig = {\n    ...defaultPerformanceConfig,\n    hookName: 'useSelectedModuleData',\n  };\n\n  // Track hook render\n  trackHookRender(performanceConfig);\n\n  return measureComputationTime(\n    'selectedModuleData',\n    () => {\n      const selectedModuleId = useModules(state => state.selectedModuleId);\n      return selectedModuleId ? moduleManager.getModule(selectedModuleId) : undefined;\n    },\n    performanceConfig\n  );\n}\n\n/**\n * Hook to access the selected building data\n *\n * @returns The currently selected building or undefined\n */\nexport function useSelectedBuildingData(): ModularBuilding | undefined {\n  // Performance tracking configuration\n  const performanceConfig: HookPerformanceConfig = {\n    ...defaultPerformanceConfig,\n    hookName: 'useSelectedBuildingData',\n  };\n\n  // Track hook render\n  trackHookRender(performanceConfig);\n\n  return measureComputationTime(\n    'selectedBuildingData',\n    () => {\n      const selectedBuildingId = useModules(\n        state => (state as unknown as ExtendedModuleState).selectedBuildingId\n      );\n      return selectedBuildingId ? moduleManager.getBuilding(selectedBuildingId) : undefined;\n    },\n    performanceConfig\n  );\n}\n\n/**\n * Hook to access modules attached to a specific building\n *\n * @param buildingId The ID of the building\n * @returns Array of modules attached to the building\n */\nexport function useBuildingModulesData(buildingId: string): BaseModule[] {\n  // Performance tracking configuration\n  const performanceConfig: HookPerformanceConfig = {\n    ...defaultPerformanceConfig,\n    hookName: 'useBuildingModulesData',\n  };\n\n  // Track hook render\n  trackHookRender(performanceConfig);\n\n  return measureComputationTime(\n    `buildingModules:${buildingId}`,\n    () => moduleManager.getBuildingModules(buildingId),\n    performanceConfig\n  );\n}\n\n/**\n * Hook to access buildings of a specific type\n *\n * @param type The building type\n * @returns Array of buildings of the specified type\n */\nexport function useBuildingsByType(type: BuildingType): ModularBuilding[] {\n  const buildings = useModules(state => state.buildings);\n\n  return useMemo(() => {\n    return buildings.filter((building: ModularBuilding) => building.type === type);\n  }, [buildings, type]);\n}\n\n/**\n * Hook to get attachment points for a module type on a specific building\n *\n * @param buildingId The building ID\n * @param moduleType The module type\n * @returns Array of attachment points that can accept the module type\n */\nexport function useAvailableAttachmentPoints(buildingId: string, moduleType: ModuleType) {\n  // Performance tracking configuration\n  const performanceConfig: HookPerformanceConfig = {\n    ...defaultPerformanceConfig,\n    hookName: 'useAvailableAttachmentPoints',\n  };\n\n  // Track hook render\n  trackHookRender(performanceConfig);\n\n  return measureComputationTime(\n    `availableAttachmentPoints:${buildingId}:${moduleType}`,\n    () => {\n      const building = moduleManager.getBuilding(buildingId);\n      return building\n        ? building.attachmentPoints.filter(\n            p => p.allowedTypes.includes(moduleType) && !p.currentModule\n          )\n        : [];\n    },\n    performanceConfig\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/modules/useModuleStatus.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/modules/useModuleUpgrade.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/modules/useSubModules.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/performance/useMemoWithDeepCompare.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'useEffect' is defined but never used. Allowed unused vars must match /^ignored|^temp/u.","line":7,"column":28,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":37}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @context: ui-system, performance-optimization\n * \n * useMemoWithDeepCompare - A hook for memoizing values with deep equality checking\n */\n\nimport { useRef, useState, useEffect } from 'react';\nimport { deepEqual } from '../../utils/performance/ComponentOptimizer';\n\n/**\n * A hook that works like useMemo but performs deep equality checking on dependencies\n * rather than reference equality. This is useful for memoizing values based on complex\n * objects or arrays that might have the same content but different references.\n * \n * @param factory Function that returns the value to be memoized\n * @param dependencies Array of dependencies that the memoized value depends on\n * @returns Memoized value that only changes when dependencies deeply change\n * \n * @example\n * ```tsx\n * // This will only recalculate when the items array contents actually change\n * const processedItems = useMemoWithDeepCompare(() => {\n *   return items.map(item => processItem(item));\n * }, [items]);\n * ```\n */\nexport function useMemoWithDeepCompare<T>(\n  factory: () => T,\n  dependencies: ReadonlyArray<unknown>\n): T {\n  // Ref to store the memoized value\n  const valueRef = useRef<T | undefined>(undefined);\n  \n  // Ref to store the previous dependencies\n  const depsRef = useRef<ReadonlyArray<unknown>>([]);\n  \n  // Check if dependencies have deeply changed\n  const depsChanged = (\n    depsRef.current.length !== dependencies.length ||\n    dependencies.some((dep, i) => !deepEqual(dep, depsRef.current[i]))\n  );\n  \n  // If this is the first run or dependencies changed, calculate the new value\n  if (valueRef.current === undefined || depsChanged) {\n    valueRef.current = factory();\n    depsRef.current = dependencies;\n  }\n  \n  return valueRef.current;\n}\n\n/**\n * A hook that provides a state value with deep equality checking before updates\n * \n * Only updates the state when the new value is deeply different from the current state,\n * which helps prevent unnecessary re-renders when dealing with complex objects\n * \n * @param initialValue Initial state value\n * @returns [state, setState] tuple like useState but with deep equality checking\n * \n * @example\n * ```tsx\n * const [filters, setFilters] = useStateWithDeepCompare({ category: 'all', sort: 'name' });\n * \n * // This won't cause a re-render if the new object is deeply equal to the current state\n * const updateCategory = (category) => {\n *   setFilters({ ...filters, category });\n * };\n * ```\n */\nexport function useStateWithDeepCompare<T>(initialValue: T): [T, (newValue: T) => void] {\n  // Use standard useState\n  const [state, setState] = useState<T>(initialValue);\n  \n  // Create a setter that only updates state if the value actually changes\n  const setStateWithDeepCompare = (newValue: T) => {\n    setState(currentState => {\n      // Only update if there's a deep difference\n      return deepEqual(currentState, newValue) ? currentState : newValue;\n    });\n  };\n  \n  return [state, setStateWithDeepCompare];\n}\n\nexport default useMemoWithDeepCompare; ","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/performance/useOptimizedCallback.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":29,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":29,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[928,931],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[928,931],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":29,"column":68,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":29,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[938,941],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[938,941],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'dependencies' is defined but never used.","line":31,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":31,"endColumn":15},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":31,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":31,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[990,993],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[990,993],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":41,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":41,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1270,1273],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1270,1273],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":58,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":58,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1818,1821],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1818,1821],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":58,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":58,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1828,1831],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1828,1831],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":60,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":60,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1879,1882],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1879,1882],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":64,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":64,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2004,2007],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2004,2007],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":79,"column":7,"nodeType":"MemberExpression","messageId":"limited","endLine":79,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[2448,2535],"text":""},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @context: ui-system, performance-optimization\n * \n * useOptimizedCallback - A hook for optimizing callbacks with better dependency handling\n */\n\nimport { useCallback, useRef } from 'react';\n\n/**\n * A hook that provides an optimized version of useCallback with better dependency handling\n * \n * This hook ensures that the callback reference only changes when the actual function logic\n * changes, not when the dependencies themselves change, which helps prevent unnecessary re-renders.\n * \n * @param callback The callback function to memoize\n * @param dependencies Dependencies array to track changes\n * @returns Memoized callback function\n * \n * @example\n * ```tsx\n * const handleClick = useOptimizedCallback((id: string) => {\n *   console.log(`Clicked item ${id}`);\n *   if (isSelected) {\n *     selectItem(id);\n *   }\n * }, [isSelected, selectItem]);\n * ```\n */\nexport function useOptimizedCallback<T extends (...args: any[]) => any>(\n  callback: T, \n  dependencies: ReadonlyArray<any>\n): T {\n  // Ref to store the latest callback\n  const callbackRef = useRef<T>(callback);\n  \n  // Update the ref whenever the callback changes\n  callbackRef.current = callback;\n  \n  // Create a stable callback that calls the latest version\n  return useCallback(\n    ((...args: any[]) => {\n      return callbackRef.current(...args);\n    }) as T,\n    // Only add an empty dependency array to ensure this callback is stable\n    []\n  );\n}\n\n/**\n * A hook that provides an optimized version of useCallback with debug logging\n * for performance tracking\n * \n * @param callback The callback function to memoize\n * @param dependencies Dependencies array to track changes\n * @param debugName Optional name for the callback for debugging\n * @returns Memoized callback function\n */\nexport function useTrackedCallback<T extends (...args: any[]) => any>(\n  callback: T,\n  dependencies: ReadonlyArray<any>,\n  debugName?: string\n): T {\n  // Store previous dependencies for comparison\n  const prevDepsRef = useRef<ReadonlyArray<any>>([]);\n  \n  // Flag to track if this is the initial render\n  const isInitialRender = useRef(true);\n  \n  // Check if dependencies have changed and log changes\n  if (!isInitialRender.current) {\n    const changedDeps = dependencies.reduce((acc, dep, index) => {\n      if (prevDepsRef.current[index] !== dep) {\n        acc.push(index);\n      }\n      return acc;\n    }, [] as number[]);\n    \n    if (changedDeps.length > 0 && debugName) {\n      console.log(`[useTrackedCallback] ${debugName} deps changed at indices:`, changedDeps);\n    }\n  } else {\n    isInitialRender.current = false;\n  }\n  \n  // Store current deps for next comparison\n  prevDepsRef.current = dependencies;\n  \n  // Create the optimized callback\n  return useOptimizedCallback(callback, dependencies);\n}\n\nexport default useOptimizedCallback; ","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/performance/useSessionPerformance.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":83,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":83,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2387,2390],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2387,2390],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * useSessionPerformance\n *\n * A React hook for tracking component performance and user interactions.\n * Provides access to the SessionPerformanceTracker for anonymous telemetry.\n */\n\nimport { useEffect, useRef } from 'react';\nimport {\n  SessionPerformanceTracker,\n  TelemetryOptions,\n  UserInteractionData,\n} from '../../services/telemetry/SessionPerformanceTracker';\n\n// Create a singleton instance of the tracker to be shared across the application\nlet globalTracker: SessionPerformanceTracker | null = null;\n\n/**\n * Initialize the global performance tracker\n */\nexport function initializeSessionPerformanceTracker(options?: Partial<TelemetryOptions>): void {\n  if (!globalTracker) {\n    globalTracker = new SessionPerformanceTracker(options);\n  }\n}\n\n/**\n * React hook for tracking component performance\n */\nexport default function useSessionPerformance(componentId: string) {\n  const trackerRef = useRef<SessionPerformanceTracker | null>(null);\n\n  // Initialize the tracker on the first render\n  useEffect(() => {\n    // Create global instance if it doesn't exist yet\n    if (!globalTracker) {\n      initializeSessionPerformanceTracker();\n    }\n\n    trackerRef.current = globalTracker;\n\n    // Start timing the component load\n    if (trackerRef.current) {\n      trackerRef.current.startComponentLoadTimer(componentId);\n    }\n\n    // When component mounts, record completion time\n    const tracker = trackerRef.current;\n    if (tracker) {\n      // Use queueMicrotask to ensure we measure after initial render\n      queueMicrotask(() => {\n        tracker.endComponentLoadTimer(componentId);\n      });\n    }\n\n    return () => {\n      // Optionally track unmount time or other component lifecycle events\n    };\n  }, [componentId]);\n\n  /**\n   * Track a custom user interaction within the component\n   */\n  const trackInteraction = (\n    interactionType: 'click' | 'hover' | 'scroll' | 'keypress' | 'custom',\n    details: Partial<UserInteractionData> = {}\n  ) => {\n    if (!trackerRef.current) return;\n\n    trackerRef.current.trackUserInteraction({\n      interactionType,\n      targetComponent: componentId,\n      timestamp: Date.now(),\n      responseTime: 0, // Will be populated with measured time\n      successful: true,\n      ...details,\n    });\n  };\n\n  /**\n   * Create a performance-tracked event handler\n   */\n  const withPerformanceTracking = <T extends (...args: unknown[]) => any>(\n    handler: T,\n    interactionType: 'click' | 'hover' | 'scroll' | 'keypress' | 'custom' = 'click'\n  ): ((...args: Parameters<T>) => ReturnType<T>) => {\n    return (...args: Parameters<T>) => {\n      const startTime = performance.now();\n\n      try {\n        const result = handler(...args);\n\n        // For promise-returning handlers, track completion when promise resolves\n        if (result instanceof Promise) {\n          result\n            .then(() => {\n              if (trackerRef.current) {\n                trackerRef.current.trackUserInteraction({\n                  interactionType,\n                  targetComponent: componentId,\n                  timestamp: Date.now(),\n                  responseTime: performance.now() - startTime,\n                  successful: true,\n                });\n              }\n            })\n            .catch(() => {\n              if (trackerRef.current) {\n                trackerRef.current.trackUserInteraction({\n                  interactionType,\n                  targetComponent: componentId,\n                  timestamp: Date.now(),\n                  responseTime: performance.now() - startTime,\n                  successful: false,\n                });\n              }\n            });\n        } else {\n          // For synchronous handlers, track completion immediately\n          if (trackerRef.current) {\n            trackerRef.current.trackUserInteraction({\n              interactionType,\n              targetComponent: componentId,\n              timestamp: Date.now(),\n              responseTime: performance.now() - startTime,\n              successful: true,\n            });\n          }\n        }\n\n        return result;\n      } catch (error) {\n        // Track failed interactions\n        if (trackerRef.current) {\n          trackerRef.current.trackUserInteraction({\n            interactionType,\n            targetComponent: componentId,\n            timestamp: Date.now(),\n            responseTime: performance.now() - startTime,\n            successful: false,\n          });\n        }\n        throw error;\n      }\n    };\n  };\n\n  return {\n    trackInteraction,\n    withPerformanceTracking,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/resources/useResourceManagement.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_time' is defined but never used.","line":80,"column":43,"nodeType":null,"messageId":"unusedVar","endLine":80,"endColumn":48}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useCallback, useEffect, useMemo, useState } from 'react';\nimport { ResourceManager } from '../../managers/game/ResourceManager';\nimport {\n  ResourceIntegration,\n  createResourceIntegration,\n} from '../../managers/resource/ResourceIntegration';\nimport {\n  ResourceState,\n  ResourceType,\n  ResourceTypeString,\n  ResourceType as StringResourceType,\n} from '../../types/resources/ResourceTypes';\nimport { ResourceTypeConverter } from '../../utils/ResourceTypeConverter';\n\n// Create an instance of ResourceManager\nconst resourceManager = new ResourceManager();\n\n// Singleton instance of the resource integration\nlet resourceIntegrationInstance: ResourceIntegration | null = null;\n\n/**\n * Initialize the resource integration if it hasn't been initialized yet\n */\nfunction getResourceIntegration(): ResourceIntegration {\n  if (!resourceIntegrationInstance) {\n    resourceIntegrationInstance = createResourceIntegration(resourceManager);\n  }\n\n  if (!resourceIntegrationInstance) {\n    throw new Error('Failed to create resource integration instance');\n  }\n\n  return resourceIntegrationInstance;\n}\n\nconst defaultResourceState: ResourceState = {\n  current: 0,\n  max: 1000,\n  min: 0,\n  production: 0,\n  consumption: 0,\n  rate: 0,\n  value: 0,\n};\n\n/**\n * Hook for accessing the resource management system\n */\nexport function useResourceManagement() {\n  const [resourceStates, setResourceStates] = useState<Map<ResourceType, ResourceState>>(new Map());\n  const [isInitialized, setIsInitialized] = useState(false);\n\n  // Get or create the resource integration\n  const integration = useMemo(() => getResourceIntegration(), []);\n\n  // Initialize the resource states\n  useEffect(() => {\n    // Get all resource types\n    const resourceTypes = Array.from(resourceManager['resources'].keys()) as StringResourceType[];\n\n    // Create a map of resource states\n    const states = new Map<StringResourceType, ResourceState>();\n    resourceTypes.forEach(type => {\n      const state = resourceManager.getResourceState(type);\n      if (state) {\n        states.set(type, state);\n      }\n    });\n\n    setResourceStates(states);\n    setIsInitialized(true);\n  }, []);\n\n  // Update the resource integration on each frame\n  useEffect(() => {\n    if (!isInitialized) {\n      return;\n    }\n\n    const frameId = requestAnimationFrame(_time => {\n      integration.update(1000 / 60); // Assume 60 FPS\n    });\n\n    return () => {\n      cancelAnimationFrame(frameId);\n    };\n  }, [integration, isInitialized]);\n\n  // Clean up the resource integration when the component unmounts\n  useEffect(() => {\n    return () => {\n      if (resourceIntegrationInstance) {\n        resourceIntegrationInstance.cleanup();\n        resourceIntegrationInstance = null;\n      }\n    };\n  }, []);\n\n  // Get a resource state\n  const getResourceState = (type: ResourceType | ResourceTypeString) => {\n    const enumType = ResourceTypeConverter.ensureEnumResourceType(type);\n    return resourceStates.get(enumType) || defaultResourceState;\n  };\n\n  // Get all resource states\n  const getAllResourceStates = () => {\n    const result = new Map<ResourceType, ResourceState>();\n    resourceStates.forEach((state, type) => {\n      result?.set(type, state);\n    });\n    return result;\n  };\n\n  // Get resource amount\n  const getResourceAmount = (type: ResourceType | ResourceTypeString) => {\n    const enumType = ResourceTypeConverter.ensureEnumResourceType(type);\n    return resourceStates.get(enumType)?.current ?? 0;\n  };\n\n  // Check if a resource is available\n  const hasResource = (type: ResourceType | ResourceTypeString, amount: number) => {\n    const enumType = ResourceTypeConverter.ensureEnumResourceType(type);\n    return (resourceStates.get(enumType)?.current ?? 0) >= amount;\n  };\n\n  // Check if multiple resources are available\n  const hasResources = (resources: Record<ResourceType | ResourceTypeString, number>) => {\n    return Object.entries(resources).every(([type, amount]) => {\n      const enumType = ResourceTypeConverter.ensureEnumResourceType(type);\n      return hasResource(enumType, amount);\n    });\n  };\n\n  // Consume a resource\n  const consumeResource = (type: ResourceType | ResourceTypeString, amount: number) => {\n    const enumType = ResourceTypeConverter.ensureEnumResourceType(type);\n    const currentAmount = resourceStates.get(enumType)?.current ?? 0;\n    if (currentAmount < amount) return false;\n\n    setResourceStates(prev => {\n      const newStates = new Map(prev);\n      const currentState = newStates.get(enumType) || { ...defaultResourceState };\n      newStates.set(enumType, {\n        ...currentState,\n        current: currentAmount - amount,\n      });\n      return newStates;\n    });\n    return true;\n  };\n\n  // Consume multiple resources\n  const consumeResources = (resources: Record<ResourceType | ResourceTypeString, number>) => {\n    const canConsume = hasResources(resources);\n    if (!canConsume) return false;\n\n    setResourceStates(prev => {\n      const newStates = new Map(prev);\n      Object.entries(resources).forEach(([type, amount]) => {\n        const enumType = ResourceTypeConverter.ensureEnumResourceType(type);\n        const currentState = newStates.get(enumType) || { ...defaultResourceState };\n        const currentAmount = currentState.current;\n        newStates.set(enumType, {\n          ...currentState,\n          current: currentAmount - amount,\n        });\n      });\n      return newStates;\n    });\n    return true;\n  };\n\n  // Add a resource\n  const addResource = (type: ResourceType | ResourceTypeString, amount: number) => {\n    const enumType = ResourceTypeConverter.ensureEnumResourceType(type);\n    setResourceStates(prev => {\n      const newStates = new Map(prev);\n      const currentState = newStates.get(enumType) || { ...defaultResourceState };\n      newStates.set(enumType, {\n        ...currentState,\n        current: currentState.current + amount,\n      });\n      return newStates;\n    });\n  };\n\n  // Add multiple resources\n  const addResources = (resources: Record<ResourceType | ResourceTypeString, number>) => {\n    setResourceStates(prev => {\n      const newStates = new Map(prev);\n      Object.entries(resources).forEach(([type, amount]) => {\n        const enumType = ResourceTypeConverter.ensureEnumResourceType(type);\n        const currentState = newStates.get(enumType) || { ...defaultResourceState };\n        newStates.set(enumType, {\n          ...currentState,\n          current: currentState.current + amount,\n        });\n      });\n      return newStates;\n    });\n  };\n\n  // Get resource production rate\n  const getProductionRate = useCallback(\n    (type: ResourceType | ResourceTypeString): number => {\n      const enumType = ResourceTypeConverter.ensureEnumResourceType(type);\n      return resourceStates.get(enumType)?.production ?? 0;\n    },\n    [resourceStates]\n  );\n\n  // Get resource consumption rate\n  const getConsumptionRate = useCallback(\n    (type: ResourceType | ResourceTypeString): number => {\n      const enumType = ResourceTypeConverter.ensureEnumResourceType(type);\n      return resourceStates.get(enumType)?.consumption ?? 0;\n    },\n    [resourceStates]\n  );\n\n  // Set resource production rate\n  const setProductionRate = useCallback(\n    (type: ResourceType | ResourceTypeString, rate: number): void => {\n      const enumType = ResourceTypeConverter.ensureEnumResourceType(type);\n      resourceManager.setResourceProduction(enumType, rate);\n    },\n    []\n  );\n\n  // Set resource consumption rate\n  const setConsumptionRate = useCallback(\n    (type: ResourceType | ResourceTypeString, rate: number): void => {\n      const enumType = ResourceTypeConverter.ensureEnumResourceType(type);\n      resourceManager.setResourceConsumption(enumType, rate);\n    },\n    []\n  );\n\n  // Get resource capacity\n  const getResourceCapacity = useCallback(\n    (type: ResourceType | ResourceTypeString): number => {\n      const enumType = ResourceTypeConverter.ensureEnumResourceType(type);\n      return resourceStates.get(enumType)?.max ?? 0;\n    },\n    [resourceStates]\n  );\n\n  // Get resource percentage\n  const getResourcePercentage = useCallback(\n    (type: ResourceType | ResourceTypeString): number => {\n      const enumType = ResourceTypeConverter.ensureEnumResourceType(type);\n      const state = resourceStates.get(enumType);\n      if (!state || state.max === 0) {\n        return 0;\n      }\n      return (state.current / state.max) * 100;\n    },\n    [resourceStates]\n  );\n\n  return {\n    // Resource state\n    getResourceState,\n    getAllResourceStates,\n    getResourceAmount,\n    hasResource,\n    hasResources,\n\n    // Resource modification\n    consumeResource,\n    consumeResources,\n    addResource,\n    addResources,\n\n    // Resource rates\n    getProductionRate,\n    getConsumptionRate,\n    setProductionRate,\n    setConsumptionRate,\n\n    // Resource capacity\n    getResourceCapacity,\n    getResourcePercentage,\n\n    // Initialization state\n    isInitialized,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/resources/useResourceState.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_netRates' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":113,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":113,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_totalProduction' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":128,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":128,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_totalConsumption' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":138,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":138,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @file useResourceState.ts\n * Provides standardized hooks for accessing ResourceRatesContext with selector pattern.\n *\n * This implementation:\n * 1. Uses selector pattern for better performance\n * 2. Provides type safety for resource state data\n * 3. Offers specialized selectors for different resource types and metrics\n * 4. Follows the standardized context access pattern\n * 5. Includes performance monitoring for selectors and computations\n */\n\nimport { useCallback, useMemo } from 'react';\nimport {\n  createResetRatesAction,\n  createUpdateRateAction,\n  useResourceRates,\n  useResourceRatesDispatch,\n} from '../../contexts/ResourceRatesContext';\nimport { ResourceType } from '../../types/resources/ResourceTypes';\nimport {\n  HookPerformanceConfig,\n  defaultPerformanceConfig,\n  measureComputationTime,\n  measureSelectorTime,\n  trackHookRender,\n} from '../../utils/performance/hookPerformanceMonitor';\nimport { ResourceTypeInfo } from './../../types/resources/ResourceTypes';\n\n// Type for core resources tracked in ResourceRatesContext\ntype CoreResourceType =\n  | ResourceType.MINERALS\n  | ResourceType.ENERGY\n  | ResourceType.POPULATION\n  | ResourceType.RESEARCH;\n\n// Interface for resource rate details\ninterface ResourceRateDetail {\n  production: number;\n  consumption: number;\n  net: number;\n}\n\n// Performance monitoring configuration\nconst resourceStatePerformanceConfig: HookPerformanceConfig = {\n  ...defaultPerformanceConfig,\n  hookName: 'useResourceState',\n};\n\n/**\n * Hook to access resource state with selector pattern for performance optimization\n *\n * @returns The resource state with structured access to rates and helper methods\n */\nexport function useResourceState() {\n  // Track hook render\n  trackHookRender(resourceStatePerformanceConfig);\n\n  // Get state and dispatch\n  const resourceRates = useResourceRates(state => state.resourceRates);\n  const dispatch = useResourceRatesDispatch();\n\n  // Create action dispatchers\n  const updateRates = useCallback(\n    (type: ResourceType, production: number, consumption: number) => {\n      dispatch(\n        createUpdateRateAction(type, {\n          production,\n          consumption,\n          net: production - consumption,\n        })\n      );\n    },\n    [dispatch]\n  );\n\n  const resetRates = useCallback(() => {\n    dispatch(createResetRatesAction());\n  }, [dispatch]);\n\n  // Memoized selectors for individual resource types - with performance tracking\n  const minerals = measureSelectorTime(\n    ResourceType.MINERALS,\n    () =>\n      useMemo(() => resourceRates[ResourceType.MINERALS], [resourceRates[ResourceType.MINERALS]]),\n    resourceStatePerformanceConfig\n  );\n\n  const energy = measureSelectorTime(\n    ResourceType.ENERGY,\n    () => useMemo(() => resourceRates[ResourceType.ENERGY], [resourceRates[ResourceType.ENERGY]]),\n    resourceStatePerformanceConfig\n  );\n\n  const population = measureSelectorTime(\n    ResourceType.POPULATION,\n    () =>\n      useMemo(\n        () => resourceRates[ResourceType.POPULATION],\n        [resourceRates[ResourceType.POPULATION]]\n      ),\n    resourceStatePerformanceConfig\n  );\n\n  const research = measureSelectorTime(\n    ResourceType.RESEARCH,\n    () =>\n      useMemo(() => resourceRates[ResourceType.RESEARCH], [resourceRates[ResourceType.RESEARCH]]),\n    resourceStatePerformanceConfig\n  );\n\n  // Memoized aggregate data - with performance tracking\n  const _netRates = measureComputationTime(\n    'netRates',\n    () =>\n      useMemo(\n        () => ({\n          [ResourceType.MINERALS]: minerals.net,\n          [ResourceType.ENERGY]: energy.net,\n          [ResourceType.POPULATION]: population.net,\n          [ResourceType.RESEARCH]: research.net,\n        }),\n        [minerals.net, energy.net, population.net, research.net]\n      ),\n    resourceStatePerformanceConfig\n  );\n\n  const _totalProduction = measureComputationTime(\n    'totalProduction',\n    () =>\n      useMemo(\n        () => minerals.production + energy.production + population.production + research.production,\n        [minerals.production, energy.production, population.production, research.production]\n      ),\n    resourceStatePerformanceConfig\n  );\n\n  const _totalConsumption = measureComputationTime(\n    'totalConsumption',\n    () =>\n      useMemo(\n        () =>\n          minerals.consumption + energy.consumption + population.consumption + research.consumption,\n        [minerals.consumption, energy.consumption, population.consumption, research.consumption]\n      ),\n    resourceStatePerformanceConfig\n  );\n\n  // Utility function to get rate details for a specific resource type\n  const getRateDetails = useCallback(\n    (type: CoreResourceType): ResourceRateDetail => {\n      return resourceRates[type];\n    },\n    [resourceRates]\n  );\n\n  // Utility function to get resource metadata\n  const getResourceInfo = useCallback((type: CoreResourceType) => {\n    return ResourceTypeInfo[type];\n  }, []);\n\n  // Utility function to check if a resource is in deficit\n  const isResourceDeficit = useCallback(\n    (type: CoreResourceType): boolean => {\n      return resourceRates[type].net < 0;\n    },\n    [resourceRates]\n  );\n\n  // Return structured state and actions - measure computation time for the final object assembly\n  return measureComputationTime(\n    'returnStateObject',\n    () => ({\n      state: resourceRates,\n\n      // Resource rate details\n      minerals,\n      energy,\n      population,\n      research,\n      plasma: resourceRates[ResourceType.PLASMA],\n      gas: resourceRates[ResourceType.GAS],\n      exotic: resourceRates[ResourceType.EXOTIC],\n\n      // Utility functions\n      getRateDetails,\n      getResourceInfo,\n      isResourceDeficit,\n\n      // Metadata\n      lastUpdated: Date.now(),\n\n      // Actions\n      updateRates,\n      resetRates,\n    }),\n    resourceStatePerformanceConfig\n  );\n}\n\n/**\n * Hook to select only the minerals rate data\n */\nexport function useMineralsRate(): ResourceRateDetail {\n  return useResourceRates(state => state.resourceRates[ResourceType.MINERALS]);\n}\n\n/**\n * Hook to select only the energy rate data\n */\nexport function useEnergyRate(): ResourceRateDetail {\n  return useResourceRates(state => state.resourceRates[ResourceType.ENERGY]);\n}\n\n/**\n * Hook to select only the population rate data\n */\nexport function usePopulationRate(): ResourceRateDetail {\n  return useResourceRates(state => state.resourceRates[ResourceType.POPULATION]);\n}\n\n/**\n * Hook to select only the research rate data\n */\nexport function useResearchRate(): ResourceRateDetail {\n  return useResourceRates(state => state.resourceRates[ResourceType.RESEARCH]);\n}\n\n/**\n * Hook to get all net resource rates\n */\nexport function useNetRates(): Record<CoreResourceType, number> {\n  return useResourceRates(state => {\n    const rates = state.resourceRates;\n    return {\n      [ResourceType.MINERALS]: rates[ResourceType.MINERALS].net,\n      [ResourceType.ENERGY]: rates[ResourceType.ENERGY].net,\n      [ResourceType.POPULATION]: rates[ResourceType.POPULATION].net,\n      [ResourceType.RESEARCH]: rates[ResourceType.RESEARCH].net,\n    };\n  });\n}\n\n/**\n * Hook to select resource rate for a specific resource type\n *\n * @param type The resource type to get rates for\n * @returns The rate details for the specified resource\n */\nexport function useResourceTypeRate(type: CoreResourceType): ResourceRateDetail {\n  // Performance tracking configuration\n  const performanceConfig: HookPerformanceConfig = {\n    ...defaultPerformanceConfig,\n    hookName: 'useResourceTypeRate',\n  };\n\n  // Track hook render\n  trackHookRender(performanceConfig);\n\n  // Get and measure state access\n  return measureSelectorTime(\n    `type:${type}`,\n    () => useResourceRates(state => state.resourceRates[type]),\n    performanceConfig\n  );\n}\n\n/**\n * Hook to get resources with positive net production\n */\nexport function usePositiveNetResources(): CoreResourceType[] {\n  // Performance tracking configuration\n  const performanceConfig: HookPerformanceConfig = {\n    ...defaultPerformanceConfig,\n    hookName: 'usePositiveNetResources',\n  };\n\n  // Track hook render\n  trackHookRender(performanceConfig);\n\n  // Get and measure computation\n  return measureComputationTime(\n    'positiveResources',\n    () => {\n      return useResourceRates(state => {\n        return Object.entries(state.resourceRates)\n          .filter(([key, value]) => {\n            if (key === 'lastUpdated') return false;\n            return (value as ResourceRateDetail).net > 0;\n          })\n          .map(([key]) => key as CoreResourceType);\n      });\n    },\n    performanceConfig\n  );\n}\n\n/**\n * Hook to get resources with negative net production (in deficit)\n */\nexport function useResourceDeficits(): CoreResourceType[] {\n  // Performance tracking configuration\n  const performanceConfig: HookPerformanceConfig = {\n    ...defaultPerformanceConfig,\n    hookName: 'useResourceDeficits',\n  };\n\n  // Track hook render\n  trackHookRender(performanceConfig);\n\n  // Get and measure computation\n  return measureComputationTime(\n    'deficitResources',\n    () => {\n      return useResourceRates(state => {\n        return Object.entries(state.resourceRates)\n          .filter(([key, value]) => {\n            if (key === 'lastUpdated') return false;\n            return (value as ResourceRateDetail).net < 0;\n          })\n          .map(([key]) => key as CoreResourceType);\n      });\n    },\n    performanceConfig\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/resources/useResourceSystem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/resources/useResourceTracking.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_enableAlerts' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":120,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":120,"endColumn":32}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useCallback, useEffect, useMemo, useState } from 'react';\nimport {\n  ResourceTotals,\n  SerializedResource,\n  SerializedResourceState,\n  SerializedThreshold,\n  isSerializedResourceState,\n  serializeResourceMap,\n  validateResourceState,\n} from '../../types/resources/ResourceSerializationTypes';\nimport {\n  ResourceState,\n  ResourceThreshold,\n  ResourceTransfer,\n  ResourceType,\n} from '../../types/resources/ResourceTypes';\n\n/**\n * Resource alert interface\n */\nexport interface ResourceAlert {\n  id: string;\n  type: ResourceType;\n  message: string;\n  severity: 'critical' | 'medium' | 'low';\n  timestamp: number;\n  threshold?: ResourceThreshold;\n  dismissed?: boolean;\n}\n\n/**\n * Resource tracking options\n */\nexport interface ResourceTrackingOptions {\n  types?: ResourceType[];\n  updateInterval?: number;\n  historyLimit?: number;\n  enableAlerts?: boolean;\n  enableThresholds?: boolean;\n}\n\n/**\n * Resource tracking state\n */\nexport interface ResourceTrackingState {\n  resources: Map<ResourceType, ResourceState>;\n  history: ResourceTransfer[];\n  alerts: ResourceAlert[];\n  lastUpdated: number;\n  thresholds: Map<ResourceType, ResourceThreshold[]>;\n}\n\n/**\n * Resource tracking result\n */\nexport interface ResourceTrackingResult {\n  // Resource states\n  resources: Map<ResourceType, ResourceState>;\n  resourceList: Array<{ type: ResourceType; state: ResourceState }>;\n  getResource: (type: ResourceType) => ResourceState | undefined;\n\n  // Resource history\n  history: ResourceTransfer[];\n  getHistoryByType: (type: ResourceType) => ResourceTransfer[];\n  clearHistory: () => void;\n\n  // Resource alerts\n  alerts: ResourceAlert[];\n  getAlertsByType: (type: ResourceType) => ResourceAlert[];\n  clearAlerts: () => void;\n  dismissAlert: (id: string) => void;\n\n  // Resource thresholds\n  setThreshold: (type: ResourceType, threshold: ResourceThreshold) => void;\n  removeThreshold: (type: ResourceType) => void;\n\n  // Resource updates\n  updateResource: (type: ResourceType, update: Partial<ResourceState>) => void;\n  incrementResource: (type: ResourceType, amount: number) => void;\n  decrementResource: (type: ResourceType, amount: number) => void;\n  transferResource: (transfer: ResourceTransfer) => boolean;\n\n  // Utility functions\n  getTotalResources: () => number;\n  getResourcePercentage: (type: ResourceType) => number;\n  getResourcesAboveThreshold: (percentage: number) => ResourceType[];\n  getResourcesBelowThreshold: (percentage: number) => ResourceType[];\n\n  // Metadata\n  lastUpdated: number;\n  isLoading: boolean;\n  error: Error | null;\n\n  // Resource metrics\n  resourceMetrics: {\n    totals: ResourceTotals;\n    percentages: Record<ResourceType, number>;\n    criticalResources: ResourceType[];\n    abundantResources: ResourceType[];\n  };\n}\n\n/**\n * Hook for tracking resources globally\n */\nexport function useResourceTracking(options: ResourceTrackingOptions = {}): ResourceTrackingResult {\n  // Default options\n  const {\n    types = [\n      ResourceType.MINERALS,\n      ResourceType.ENERGY,\n      ResourceType.POPULATION,\n      ResourceType.RESEARCH,\n      ResourceType.PLASMA,\n      ResourceType.GAS,\n      ResourceType.EXOTIC,\n    ],\n    updateInterval = 1000,\n    historyLimit = 100,\n    enableAlerts: _enableAlerts = true,\n    enableThresholds = true,\n  } = options;\n\n  // State\n  const [state, setState] = useState<ResourceTrackingState>({\n    resources: new Map(),\n    history: [],\n    alerts: [],\n    lastUpdated: Date.now(),\n    thresholds: new Map(),\n  });\n\n  const [isLoading, setIsLoading] = useState<boolean>(true);\n  const [error, setError] = useState<Error | null>(null);\n\n  // Initialize resources\n  useEffect(() => {\n    const initialResources = new Map<ResourceType, ResourceState>();\n    const initialThresholds = new Map<ResourceType, ResourceThreshold[]>();\n\n    // Initialize with default values\n    for (const type of types) {\n      initialResources.set(type, {\n        current: 0,\n        min: 0,\n        max: 100,\n        production: 0,\n        consumption: 0,\n      });\n      initialThresholds.set(type, []);\n    }\n\n    // Try to load from storage\n    try {\n      const savedResources = localStorage.getItem('resources');\n      if (savedResources) {\n        const parsed = JSON.parse(savedResources);\n\n        // Validate the parsed data\n        if (isSerializedResourceState(parsed) && validateResourceState(parsed)) {\n          // Convert serialized resources to Map with proper type conversion\n          const resourceMap = new Map<ResourceType, ResourceState>();\n\n          // Process each resource entry with proper conversion\n          for (const [key, value] of Object.entries(parsed.resources)) {\n            if (types.includes(key as ResourceType)) {\n              const serializedResource = value as SerializedResource;\n              resourceMap.set(key as ResourceType, {\n                current: serializedResource.current,\n                min: 0, // Default value\n                max: serializedResource.capacity || 100, // Use capacity or default\n                production: serializedResource.production,\n                consumption: serializedResource.consumption,\n              });\n            }\n          }\n\n          // Convert serialized thresholds to Map\n          const thresholdMap = new Map<ResourceType, ResourceThreshold[]>();\n          for (const [key, thresholds] of Object.entries(parsed.thresholds)) {\n            if (types.includes(key as ResourceType)) {\n              thresholdMap.set(key as ResourceType, thresholds as ResourceThreshold[]);\n            }\n          }\n\n          setState(prev => ({\n            ...prev,\n            resources: resourceMap,\n            thresholds: thresholdMap,\n            alerts: parsed.alerts ?? [],\n            lastUpdated: parsed.timestamp || Date.now(),\n          }));\n        } else {\n          console.warn('Invalid resource data in localStorage, using defaults');\n          setState(prev => ({\n            ...prev,\n            resources: initialResources,\n            thresholds: initialThresholds,\n            lastUpdated: Date.now(),\n          }));\n        }\n      } else {\n        setState(prev => ({\n          ...prev,\n          resources: initialResources,\n          thresholds: initialThresholds,\n          lastUpdated: Date.now(),\n        }));\n      }\n\n      setIsLoading(false);\n    } catch (err) {\n      setError(err instanceof Error ? err : new Error('Failed to load resources'));\n      setIsLoading(false);\n    }\n  }, [types]);\n\n  // Save resources to storage\n  useEffect(() => {\n    if (isLoading) {\n      return;\n    }\n\n    try {\n      // Serialize the state\n      const serializedState: SerializedResourceState = {\n        resources: Object.fromEntries(\n          Array.from(state.resources.entries()).map(([key, value]) => [\n            key,\n            {\n              current: value.current,\n              capacity: value.max, // Convert max to capacity\n              production: value.production,\n              consumption: value.consumption,\n            } as SerializedResource,\n          ])\n        ) as Record<ResourceType, SerializedResource>,\n        thresholds: serializeResourceMap(state.thresholds) as Record<string, SerializedThreshold[]>,\n        alerts: state.alerts,\n        timestamp: Date.now(),\n      };\n\n      localStorage.setItem('resources', JSON.stringify(serializedState));\n    } catch (err) {\n      console.error('Failed to save resources:', err);\n    }\n  }, [state, isLoading]);\n\n  // Check thresholds\n  useEffect(() => {\n    if (!enableThresholds || isLoading) {\n      return;\n    }\n\n    const checkThresholds = () => {\n      const newAlerts: ResourceAlert[] = [];\n\n      // Convert Map entries to array to avoid MapIterator error\n      const thresholdEntries = Array.from(state.thresholds.entries());\n      for (const [type, thresholdList] of thresholdEntries) {\n        const resourceState = state.resources.get(type);\n        if (!resourceState) {\n          continue;\n        }\n\n        for (const threshold of thresholdList) {\n          // Check critical threshold\n          if (threshold.critical !== undefined && resourceState.current < threshold.critical) {\n            newAlerts.push({\n              id: `${type}-critical-${Date.now()}`,\n              type,\n              threshold,\n              message: `${type} is below critical threshold (${resourceState.current}/${threshold.critical})`,\n              severity: 'critical',\n              timestamp: Date.now(),\n            });\n          }\n          // Check low threshold\n          else if (threshold.low !== undefined && resourceState.current < threshold.low) {\n            newAlerts.push({\n              id: `${type}-low-${Date.now()}`,\n              type,\n              threshold,\n              message: `${type} is below low threshold (${resourceState.current}/${threshold.low})`,\n              severity: 'medium',\n              timestamp: Date.now(),\n            });\n          }\n          // Check target threshold\n          else if (threshold.target !== undefined && resourceState.current < threshold.target) {\n            newAlerts.push({\n              id: `${type}-target-${Date.now()}`,\n              type,\n              threshold,\n              message: `${type} is below target threshold (${resourceState.current}/${threshold.target})`,\n              severity: 'low',\n              timestamp: Date.now(),\n            });\n          }\n        }\n      }\n\n      // Update alerts if there are new ones\n      if (newAlerts.length > 0) {\n        setState(prev => ({\n          ...prev,\n          alerts: [...prev.alerts, ...newAlerts],\n        }));\n      }\n    };\n\n    // Check thresholds initially\n    checkThresholds();\n\n    // Set up interval for checking thresholds\n    const intervalId = setInterval(checkThresholds, updateInterval);\n\n    return () => {\n      clearInterval(intervalId);\n    };\n  }, [enableThresholds, isLoading, state.resources, state.thresholds, updateInterval]);\n\n  // Update resource\n  const updateResource = useCallback((type: ResourceType, update: Partial<ResourceState>) => {\n    setState(prev => {\n      const resources = new Map(prev.resources);\n      const current = resources.get(type) || {\n        current: 0,\n        min: 0,\n        max: 100,\n        production: 0,\n        consumption: 0,\n      };\n\n      resources.set(type, {\n        ...current,\n        ...update,\n      });\n\n      return {\n        ...prev,\n        resources,\n        lastUpdated: Date.now(),\n      };\n    });\n  }, []);\n\n  // Increment resource\n  const incrementResource = useCallback(\n    (type: ResourceType, amount: number) => {\n      if (amount <= 0) {\n        return;\n      }\n\n      setState(prev => {\n        const resources = new Map(prev.resources);\n        const current = resources.get(type) || {\n          current: 0,\n          min: 0,\n          max: 100,\n          production: 0,\n          consumption: 0,\n        };\n\n        const newValue = Math.min(current.current + amount, current.max);\n\n        resources.set(type, {\n          ...current,\n          current: newValue,\n        });\n\n        // Add to history\n        const transfer: ResourceTransfer = {\n          type,\n          source: 'production',\n          target: 'storage',\n          amount,\n          timestamp: Date.now(),\n        };\n\n        const history = [transfer, ...prev.history].slice(0, historyLimit);\n\n        return {\n          ...prev,\n          resources,\n          history,\n          lastUpdated: Date.now(),\n        };\n      });\n    },\n    [historyLimit]\n  );\n\n  // Decrement resource\n  const decrementResource = useCallback(\n    (type: ResourceType, amount: number) => {\n      if (amount <= 0) {\n        return;\n      }\n\n      setState(prev => {\n        const resources = new Map(prev.resources);\n        const current = resources.get(type) || {\n          current: 0,\n          min: 0,\n          max: 100,\n          production: 0,\n          consumption: 0,\n        };\n\n        const newValue = Math.max(current.current - amount, current.min);\n\n        resources.set(type, {\n          ...current,\n          current: newValue,\n        });\n\n        // Add to history\n        const transfer: ResourceTransfer = {\n          type,\n          source: 'storage',\n          target: 'consumption',\n          amount,\n          timestamp: Date.now(),\n        };\n\n        const history = [transfer, ...prev.history].slice(0, historyLimit);\n\n        return {\n          ...prev,\n          resources,\n          history,\n          lastUpdated: Date.now(),\n        };\n      });\n    },\n    [historyLimit]\n  );\n\n  // Transfer resource\n  const transferResource = useCallback(\n    (transfer: ResourceTransfer): boolean => {\n      if (transfer.amount <= 0) {\n        return false;\n      }\n\n      let success = false;\n\n      setState(prev => {\n        const resources = new Map(prev.resources);\n\n        // Get source resource\n        const sourceResource = resources.get(transfer.type);\n        if (!sourceResource || sourceResource.current < transfer.amount) {\n          return prev; // Not enough resources\n        }\n\n        // Update source\n        resources.set(transfer.type, {\n          ...sourceResource,\n          current: sourceResource.current - transfer.amount,\n        });\n\n        // Add to history\n        const history = [transfer, ...prev.history].slice(0, historyLimit);\n\n        success = true;\n\n        return {\n          ...prev,\n          resources,\n          history,\n          lastUpdated: Date.now(),\n        };\n      });\n\n      return success;\n    },\n    [historyLimit]\n  );\n\n  // Set threshold\n  const setThreshold = useCallback(\n    (type: ResourceType, threshold: ResourceThreshold) => {\n      const thresholds = new Map(state.thresholds);\n      const currentThresholds = thresholds.get(type) ?? [];\n      thresholds.set(type, [...currentThresholds, threshold]);\n      setState(prev => ({ ...prev, thresholds }));\n    },\n    [state.thresholds]\n  );\n\n  // Remove threshold\n  const removeThreshold = useCallback(\n    (type: ResourceType) => {\n      const thresholds = new Map(state.thresholds);\n      thresholds.set(type, []);\n      setState(prev => ({ ...prev, thresholds }));\n    },\n    [state.thresholds]\n  );\n\n  // Get resource\n  const getResource = useCallback(\n    (type: ResourceType) => {\n      return state.resources.get(type);\n    },\n    [state.resources]\n  );\n\n  // Get history by type\n  const getHistoryByType = useCallback(\n    (type: ResourceType) => {\n      return state.history.filter(item => item?.type === type);\n    },\n    [state.history]\n  );\n\n  // Clear history\n  const clearHistory = useCallback(() => {\n    setState(prev => ({\n      ...prev,\n      history: [],\n    }));\n  }, []);\n\n  // Get alerts by type\n  const getAlertsByType = useCallback(\n    (type: ResourceType) => {\n      return state.alerts.filter(alert => alert.type === type);\n    },\n    [state.alerts]\n  );\n\n  // Clear alerts\n  const clearAlerts = useCallback(() => {\n    setState(prev => ({\n      ...prev,\n      alerts: [],\n    }));\n  }, []);\n\n  // Dismiss alert\n  const dismissAlert = useCallback((id: string) => {\n    setState(prev => ({\n      ...prev,\n      alerts: prev.alerts.filter(alert => alert.id !== id),\n    }));\n  }, []);\n\n  // Get total resources\n  const getTotalResources = useCallback(() => {\n    let total = 0;\n\n    // Convert Map entries to array to avoid MapIterator error\n    const resourceValues = Array.from(state.resources.values());\n    for (const resource of resourceValues) {\n      total += resource.current;\n    }\n\n    return total;\n  }, [state.resources]);\n\n  // Get resource percentage\n  const getResourcePercentage = useCallback(\n    (type: ResourceType) => {\n      const resource = state.resources.get(type);\n      if (!resource) {\n        return 0;\n      }\n\n      return (resource.current / resource.max) * 100;\n    },\n    [state.resources]\n  );\n\n  // Get resources above threshold\n  const getResourcesAboveThreshold = useCallback(\n    (percentage: number) => {\n      const result: ResourceType[] = [];\n\n      // Convert Map entries to array to avoid MapIterator error\n      const resourceEntries = Array.from(state.resources.entries());\n      for (const [type, resource] of resourceEntries) {\n        const resourcePercentage = (resource.current / resource.max) * 100;\n\n        if (resourcePercentage >= percentage) {\n          result?.push(type);\n        }\n      }\n\n      return result;\n    },\n    [state.resources]\n  );\n\n  // Get resources below threshold\n  const getResourcesBelowThreshold = useCallback(\n    (percentage: number) => {\n      const result: ResourceType[] = [];\n\n      // Convert Map entries to array to avoid MapIterator error\n      const resourceEntries = Array.from(state.resources.entries());\n      for (const [type, resource] of resourceEntries) {\n        const resourcePercentage = (resource.current / resource.max) * 100;\n\n        if (resourcePercentage <= percentage) {\n          result?.push(type);\n        }\n      }\n\n      return result;\n    },\n    [state.resources]\n  );\n\n  // Create resource list\n  const resourceList = useMemo(() => {\n    return Array.from(state.resources.entries()).map(([type, state]) => ({\n      type,\n      state,\n    }));\n  }, [state.resources]);\n\n  // Calculate resource totals\n  const _calculateTotals = useCallback(\n    (resources: Map<ResourceType, ResourceState>): ResourceTotals => {\n      const totals: ResourceTotals = {\n        production: 0,\n        consumption: 0,\n        net: 0,\n        amounts: {} as Record<ResourceType, number>,\n        capacities: {} as Record<ResourceType, number>,\n        rates: {} as Record<ResourceType, number>,\n      };\n\n      // Convert Map entries to array to avoid MapIterator error\n      const resourceEntries = Array.from(resources.entries());\n      for (const [type, resource] of resourceEntries) {\n        totals.production += resource.production;\n        totals.consumption += resource.consumption;\n\n        if (totals.amounts) {\n          totals.amounts[type] = resource.current;\n        }\n\n        if (totals.capacities) {\n          totals.capacities[type] = resource.max;\n        }\n\n        if (totals.rates) {\n          totals.rates[type] = resource.production - resource.consumption;\n        }\n      }\n\n      totals.net = totals.production - totals.consumption;\n      return totals;\n    },\n    []\n  );\n\n  // Calculate resource percentages\n  const _calculatePercentages = useCallback(\n    (resources: Map<ResourceType, ResourceState>): Record<ResourceType, number> => {\n      const percentages: Record<ResourceType, number> = {} as Record<ResourceType, number>;\n\n      // Convert Map entries to array to avoid MapIterator error\n      const resourceEntries = Array.from(resources.entries());\n      for (const [type, resource] of resourceEntries) {\n        if (resource.max > 0) {\n          percentages[type] = (resource.current / resource.max) * 100;\n        } else {\n          percentages[type] = 0;\n        }\n      }\n\n      return percentages;\n    },\n    []\n  );\n\n  // Calculate current resource totals and percentages for the UI\n  const resourceMetrics = useMemo(() => {\n    const totals = _calculateTotals(state.resources);\n    const percentages = _calculatePercentages(state.resources);\n\n    return {\n      totals,\n      percentages,\n      criticalResources: Object.entries(percentages)\n        .filter(([_, percent]) => percent < 10)\n        .map(([type]) => type as ResourceType),\n      abundantResources: Object.entries(percentages)\n        .filter(([_, percent]) => percent > 90)\n        .map(([type]) => type as ResourceType),\n    };\n  }, [state.resources, _calculateTotals, _calculatePercentages]);\n\n  return {\n    // Resource states\n    resources: state.resources,\n    resourceList,\n    getResource,\n\n    // Resource history\n    history: state.history,\n    getHistoryByType,\n    clearHistory,\n\n    // Resource alerts\n    alerts: state.alerts,\n    getAlertsByType,\n    clearAlerts,\n    dismissAlert,\n\n    // Resource thresholds\n    setThreshold,\n    removeThreshold,\n\n    // Resource updates\n    updateResource,\n    incrementResource,\n    decrementResource,\n    transferResource,\n\n    // Utility functions\n    getTotalResources,\n    getResourcePercentage,\n    getResourcesAboveThreshold,\n    getResourcesBelowThreshold,\n\n    // Metadata\n    lastUpdated: state.lastUpdated,\n    isLoading,\n    error,\n\n    // Resource metrics\n    resourceMetrics,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/services/useService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/ships/useShipActions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/ships/useShipClassManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/ships/useShipEffects.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/ui/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/ui/useBreakpoint.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Theme' is defined but never used. Allowed unused vars must match /^ignored|^temp/u.","line":9,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @context: ui-responsive-system, ui-hook-system\n * \n * Hook for responsive design with breakpoint detection\n */\n\nimport { useState, useEffect, useMemo } from 'react';\nimport { useTheme } from '../../contexts/ThemeContext';\nimport { Theme, ThemeBreakpoint } from '../../types/ui/ThemeTypes';\n\n/**\n * Breakpoint keys in order from smallest to largest\n */\nconst BREAKPOINT_KEYS: Array<ThemeBreakpoint> = [\n  ThemeBreakpoint.XS,\n  ThemeBreakpoint.SM,\n  ThemeBreakpoint.MD,\n  ThemeBreakpoint.LG,\n  ThemeBreakpoint.XL\n];\n\n/**\n * Available breakpoint sizes\n */\nexport type Breakpoint = ThemeBreakpoint;\n\n/**\n * Results from the useBreakpoint hook\n */\nexport interface UseBreakpointResult {\n  /**\n   * Current active breakpoint\n   */\n  current: Breakpoint;\n  \n  /**\n   * Whether the viewport is mobile-sized (sm or smaller)\n   */\n  isMobile: boolean;\n  \n  /**\n   * Whether the viewport is tablet-sized (md)\n   */\n  isTablet: boolean;\n  \n  /**\n   * Whether the viewport is desktop-sized (lg or larger)\n   */\n  isDesktop: boolean;\n  \n  /**\n   * Check if the current breakpoint is at least the given size\n   * @param breakpoint The breakpoint to check against\n   * @returns True if the current breakpoint is at least the given size\n   */\n  isAtLeast: (breakpoint: Breakpoint) => boolean;\n  \n  /**\n   * Check if the current breakpoint is at most the given size\n   * @param breakpoint The breakpoint to check against\n   * @returns True if the current breakpoint is at most the given size\n   */\n  isAtMost: (breakpoint: Breakpoint) => boolean;\n  \n  /**\n   * Check if the current breakpoint is exactly the given size\n   * @param breakpoint The breakpoint to check against\n   * @returns True if the current breakpoint is exactly the given size\n   */\n  is: (breakpoint: Breakpoint) => boolean;\n}\n\n/**\n * Hook for responsive design with breakpoint detection\n * @returns An object with breakpoint information and utility functions\n */\nexport function useBreakpoint(): UseBreakpointResult {\n  const { theme } = useTheme();\n  const [windowWidth, setWindowWidth] = useState(\n    typeof window !== 'undefined' ? window.innerWidth : 0\n  );\n  \n  // Convert breakpoint strings to numbers for comparison\n  const breakpointValues = useMemo(() => {\n    return BREAKPOINT_KEYS.reduce<Record<Breakpoint, number>>((acc, key) => {\n      acc[key] = parseInt(theme.breakpoints[key].replace('px', ''), 10);\n      return acc;\n    }, {} as Record<Breakpoint, number>);\n  }, [theme.breakpoints]);\n  \n  // Determine current breakpoint based on window width\n  const current = useMemo<Breakpoint>(() => {\n    // Default to XS for SSR\n    if (windowWidth === 0) return ThemeBreakpoint.XS;\n    \n    // Find the largest breakpoint that is less than or equal to the window width\n    for (let i = BREAKPOINT_KEYS.length - 1; i >= 0; i--) {\n      const key = BREAKPOINT_KEYS[i];\n      if (windowWidth >= breakpointValues[key]) {\n        return key;\n      }\n    }\n    \n    return ThemeBreakpoint.XS;\n  }, [windowWidth, breakpointValues]);\n  \n  // Update window width on resize\n  useEffect(() => {\n    if (typeof window === 'undefined') return;\n    \n    const handleResize = () => {\n      setWindowWidth(window.innerWidth);\n    };\n    \n    window.addEventListener('resize', handleResize);\n    \n    return () => {\n      window.removeEventListener('resize', handleResize);\n    };\n  }, []);\n  \n  // Create result object with various helper properties and functions\n  return {\n    current,\n    isMobile: current === ThemeBreakpoint.XS || current === ThemeBreakpoint.SM,\n    isTablet: current === ThemeBreakpoint.MD,\n    isDesktop: current === ThemeBreakpoint.LG || current === ThemeBreakpoint.XL,\n    \n    isAtLeast: (breakpoint: Breakpoint) => {\n      const currentIndex = BREAKPOINT_KEYS.indexOf(current);\n      const targetIndex = BREAKPOINT_KEYS.indexOf(breakpoint);\n      return currentIndex >= targetIndex;\n    },\n    \n    isAtMost: (breakpoint: Breakpoint) => {\n      const currentIndex = BREAKPOINT_KEYS.indexOf(current);\n      const targetIndex = BREAKPOINT_KEYS.indexOf(breakpoint);\n      return currentIndex <= targetIndex;\n    },\n    \n    is: (breakpoint: Breakpoint) => current === breakpoint,\n  };\n} ","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/ui/useComponentLifecycle.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/ui/useComponentProfiler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/ui/useComponentRegistration.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'renderTime' is defined but never used.","line":100,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":100,"endColumn":36}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect, useRef } from 'react';\nimport { componentRegistryService } from '../../services/ComponentRegistryService';\nimport { ResourceType } from './../../types/resources/ResourceTypes';\nimport { useComponentProfiler } from './useComponentProfiler';\n\n/**\n * Options for component registration\n */\nexport interface ComponentRegistrationOptions {\n  /**\n   * Type of the component (e.g., 'ResourceDisplay', 'ModuleCard')\n   */\n  type: ResourceType;\n\n  /**\n   * Event types this component is interested in receiving\n   */\n  eventSubscriptions: string[];\n\n  /**\n   * Update priority for this component\n   * - high: Component updates are critical for game functionality\n   * - medium: Component updates are important but not critical\n   * - low: Component updates can be delayed if necessary\n   */\n  updatePriority?: 'high' | 'medium' | 'low';\n}\n\n/**\n * Hook that registers a React component with the ComponentRegistryService\n *\n * This hook:\n * 1. Generates a unique ID for the component\n * 2. Registers the component with the registry\n * 3. Sets up profiling to measure render times\n * 4. Automatically cleans up on unmount\n *\n * @param options Component registration options\n * @returns The generated component ID\n *\n * @example\n * function ResourceDisplay({ resourceType }) {\n *   // Register component with the system\n *   useComponentRegistration({\n *     type: 'ResourceDisplay',\n *     eventSubscriptions: ['RESOURCE_PRODUCED', 'RESOURCE_CONSUMED'],\n *     updatePriority: 'high'\n *   });\n *\n *   // Component implementation...\n * }\n */\nexport function useComponentRegistration(options: ComponentRegistrationOptions): string {\n  const componentId = useRef<string>('');\n  const profiler = useComponentProfiler(options?.type);\n\n  useEffect(() => {\n    // Register component with registry\n    const id = componentRegistryService.registerComponent({\n      type: options?.type,\n      eventSubscriptions: options?.eventSubscriptions,\n      updatePriority: options?.updatePriority || 'medium',\n    });\n\n    componentId.current = id;\n\n    // Track render with profiler\n    if (profiler) {\n      const renderTime = profiler.metrics.lastRenderTime;\n      if (renderTime !== undefined) {\n        componentRegistryService.trackRender(id);\n      }\n    }\n\n    // Return cleanup function\n    return () => {\n      componentRegistryService.unregisterComponent(id);\n    };\n  }, [options?.type, options?.updatePriority, profiler]);\n\n  return componentId.current;\n}\n\n/**\n * Hook that registers a component and provides a method to manually update its metrics\n *\n * This is useful for components that need to manually control when metrics are updated,\n * such as those with complex rendering logic or conditional renders.\n *\n * @param options Component registration options\n * @returns An object containing the component ID and an update function\n */\nexport function useComponentRegistrationWithManualUpdates(options: ComponentRegistrationOptions): {\n  componentId: string;\n  updateMetrics: (renderTime: number) => void;\n} {\n  const componentId = useComponentRegistration(options);\n\n  // Function to manually update metrics\n  const updateMetrics = (renderTime: number) => {\n    componentRegistryService.trackRender(componentId);\n  };\n\n  return { componentId, updateMetrics };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/ui/useDebugOverlay.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/ui/useMediaQuery.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/ui/useProfilingOverlay.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/ui/useTheme.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/ui/useTooltip.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/ui/useVPR.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/ui/useVPRInteractivity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/ui/useVPRSystem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/useGPUCompute.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/useMemoryManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/usePaginatedData.ts","messages":[{"ruleId":"no-unsafe-optional-chaining","severity":2,"message":"Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.","line":54,"column":40,"nodeType":"ChainExpression","messageId":"unsafeOptionalChain","endLine":54,"endColumn":54}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useCallback, useEffect, useState } from 'react';\nimport { apiService, PaginationParams } from '../services/APIService';\nimport { useService } from './services/useService';\n\ninterface UsePaginatedDataOptions<T> {\n  endpoint: string;\n  initialParams?: Partial<PaginationParams>;\n  initialData?: T[];\n}\n\ninterface UsePaginatedDataResult<T> {\n  data: T[];\n  total: number;\n  isLoading: boolean;\n  error: Error | null;\n  page: number;\n  hasMore: boolean;\n  loadMore: () => Promise<void>;\n  refresh: () => Promise<void>;\n  setFilters: (filters: Record<string, unknown>) => void;\n  setSorting: (sortBy: string, sortOrder: 'asc' | 'desc') => void;\n}\n\nexport function usePaginatedData<T>({\n  endpoint,\n  initialParams = {},\n  initialData = [],\n}: UsePaginatedDataOptions<T>): UsePaginatedDataResult<T> {\n  const { service } = useService<typeof apiService>('api');\n  const [data, setData] = useState<T[]>(initialData);\n  const [total, setTotal] = useState(0);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n  const [params, setParams] = useState<PaginationParams>({\n    page: 1,\n    pageSize: 20,\n    ...initialParams,\n  });\n  const [hasMore, setHasMore] = useState(true);\n\n  const fetchData = useCallback(\n    async (newParams: PaginationParams) => {\n      if (!service) return;\n\n      setIsLoading(true);\n      setError(null);\n\n      try {\n        const response = await service.fetchPaginated<T>(endpoint, newParams);\n\n        if (newParams.page === 1) {\n          setData(response?.data);\n        } else {\n          setData(prev => [...prev, ...response?.data]);\n        }\n\n        setTotal(response?.total);\n        setHasMore(response?.hasMore);\n      } catch (err) {\n        setError(err instanceof Error ? err : new Error(String(err)));\n      } finally {\n        setIsLoading(false);\n      }\n    },\n    [service, endpoint]\n  );\n\n  // Initial fetch\n  useEffect(() => {\n    fetchData(params);\n  }, [fetchData, params]);\n\n  const loadMore = useCallback(async () => {\n    if (isLoading || !hasMore) return;\n\n    const newParams = {\n      ...params,\n      page: params.page + 1,\n    };\n    setParams(newParams);\n  }, [isLoading, hasMore, params]);\n\n  const refresh = useCallback(async () => {\n    const newParams = {\n      ...params,\n      page: 1,\n    };\n    setParams(newParams);\n  }, [params]);\n\n  const setFilters = useCallback((filters: Record<string, unknown>) => {\n    setParams(prev => ({\n      ...prev,\n      page: 1,\n      filters,\n    }));\n  }, []);\n\n  const setSorting = useCallback((sortBy: string, sortOrder: 'asc' | 'desc') => {\n    setParams(prev => ({\n      ...prev,\n      page: 1,\n      sortBy,\n      sortOrder,\n    }));\n  }, []);\n\n  return {\n    data,\n    total,\n    isLoading,\n    error,\n    page: params.page,\n    hasMore,\n    loadMore,\n    refresh,\n    setFilters,\n    setSorting,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/useRealTimeData.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/useStreamedData.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/useTypedApi.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/useWebGL.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/useWorker.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'onProgress' is defined but never used.","line":22,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":22,"endColumn":13}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useCallback, useEffect, useState } from 'react';\nimport { workerService } from '../services/WorkerService';\nimport { useService } from './services/useService';\n\ninterface UseWorkerOptions {\n  type: string;\n  priority?: 'HIGH' | 'MEDIUM' | 'LOW';\n  onProgress?: (progress: number) => void;\n}\n\ninterface UseWorkerResult<T> {\n  execute: (data: unknown) => Promise<T>;\n  cancel: () => void;\n  isRunning: boolean;\n  progress: number;\n  error: Error | null;\n}\n\nexport function useWorker<T>({\n  type,\n  priority = 'MEDIUM',\n  onProgress,\n}: UseWorkerOptions): UseWorkerResult<T> {\n  const { service } = useService<typeof workerService>('worker');\n  const [currentTaskId, setCurrentTaskId] = useState<string | null>(null);\n  const [isRunning, setIsRunning] = useState(false);\n  const [progress, setProgress] = useState(0);\n  const [error, setError] = useState<Error | null>(null);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (currentTaskId) {\n        service?.cancelTask(currentTaskId);\n      }\n    };\n  }, [currentTaskId, service]);\n\n  const execute = useCallback(\n    async (data: unknown): Promise<T> => {\n      if (!service) {\n        throw new Error('Worker service not available');\n      }\n\n      setIsRunning(true);\n      setProgress(0);\n      setError(null);\n\n      try {\n        const result = await service.submitTask<T>(type, data, priority);\n        return result;\n      } catch (err) {\n        const error = err instanceof Error ? err : new Error(String(err));\n        setError(error);\n        throw error;\n      } finally {\n        setIsRunning(false);\n        setCurrentTaskId(null);\n      }\n    },\n    [service, type, priority]\n  );\n\n  const cancel = useCallback(() => {\n    if (currentTaskId && service) {\n      service.cancelTask(currentTaskId);\n      setIsRunning(false);\n      setCurrentTaskId(null);\n    }\n  }, [currentTaskId, service]);\n\n  return {\n    execute,\n    cancel,\n    isRunning,\n    progress,\n    error,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/hooks/visualization/useChartCoordination.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/initialization/automationSystemInit.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":18,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":18,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[929,932],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[929,932],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/initialization/eventSystemInit.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_deltaTime' is defined but never used.","line":85,"column":6,"nodeType":null,"messageId":"unusedVar","endLine":85,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_elapsedTime' is defined but never used.","line":85,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":85,"endColumn":38},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_deltaTime' is defined but never used.","line":94,"column":6,"nodeType":null,"messageId":"unusedVar","endLine":94,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_elapsedTime' is defined but never used.","line":94,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":94,"endColumn":38}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ModuleEvent, moduleEventBus, ModuleEventType } from '../lib/modules/ModuleEvents';\nimport { gameLoopManager, UpdatePriority } from '../managers/game/GameLoopManager';\nimport { getSystemCommunication } from '../utils/events/EventCommunication';\nimport { EventPriorityQueue } from '../utils/events/EventFiltering';\nimport { initializeRxJSIntegration } from '../utils/events/rxjsIntegration';\nimport { ResourceType } from './../types/resources/ResourceTypes';\nimport { initializeAutomationSystem } from './automationSystemInit';\nimport { integrateWithGameSystems } from './gameSystemsIntegration';\n\n// Define an interface for our priority queue events\ninterface PriorityQueueEvent {\n  type: string;\n  priority: number;\n  data: Record<string, unknown> | ModuleEvent;\n}\n\n/**\n * Initialize the event system\n */\nexport function initializeEventSystem(): () => void {\n  console.warn('Initializing Event System...');\n\n  // Initialize RxJS integration\n  const rxjsCleanup = initializeRxJSIntegration();\n\n  // Initialize system communications\n  const eventSystemComm = getSystemCommunication('event-system');\n  const _resourceSystemComm = getSystemCommunication('resource-system');\n  const _moduleSystemComm = getSystemCommunication('module-system');\n\n  // Register basic event handlers\n  const unregisterSystemStartup = eventSystemComm.registerHandler('system-startup', message => {\n    const payload = message.payload as { systemName: string };\n    console.warn(`System startup message received: ${payload.systemName}`);\n  });\n\n  // Register resource system event handlers\n  const unregisterResourceEvents = _resourceSystemComm.registerHandler(\n    'resource-update',\n    message => {\n      const payload = message.payload as {\n        resourceType: ResourceType;\n        amount: number;\n        operation: 'add' | 'subtract';\n      };\n      console.warn(\n        `Resource update: ${payload.operation} ${payload.amount} of ${payload.resourceType}`\n      );\n\n      // Forward important resource events to the module system\n      if (payload.amount > 1000) {\n        _moduleSystemComm.sendMessage('resource-system', 'resource-threshold-reached', {\n          resourceType: payload.resourceType,\n          amount: payload.amount,\n          timestamp: Date.now(),\n        });\n      }\n    }\n  );\n\n  // Register module system event handlers\n  const unregisterModuleEvents = _moduleSystemComm.registerHandler(\n    'module-status-change',\n    message => {\n      const payload = message.payload as { moduleId: string; status: string };\n      console.warn(`Module status change: ${payload.moduleId} is now ${payload.status}`);\n\n      // Notify the event system about important module status changes\n      if (payload.status === 'critical' || payload.status === 'offline') {\n        eventSystemComm.sendMessage('broadcast', 'system-alert', {\n          level: payload.status === 'critical' ? 'warning' : 'error',\n          message: `Module ${payload.moduleId} is ${payload.status}`,\n          timestamp: Date.now(),\n        });\n      }\n    }\n  );\n\n  // Start the game loop\n  gameLoopManager.start();\n\n  // Register a critical update with the game loop\n  gameLoopManager.registerUpdate(\n    'event-system-critical',\n    (_deltaTime: number, _elapsedTime: number) => {\n      // Process critical events\n    },\n    UpdatePriority.CRITICAL\n  );\n\n  // Register a normal update with the game loop\n  gameLoopManager.registerUpdate(\n    'event-system-normal',\n    (_deltaTime: number, _elapsedTime: number) => {\n      // Process normal events\n    },\n    UpdatePriority.NORMAL\n  );\n\n  // Create a test event to verify the system is working\n  setTimeout(() => {\n    moduleEventBus.emit({\n      type: 'MODULE_CREATED' as ModuleEventType, // Use a valid ModuleEventType\n      moduleId: 'event-system',\n      moduleType: 'resource-manager', // Use a valid ModuleType\n      timestamp: Date.now(),\n      data: { system: 'event-system', status: 'initialized' },\n    });\n\n    // Send a test message through system communication\n    eventSystemComm.sendMessage('resource-system', 'test-message', {\n      message: 'Hello from Event System!',\n    });\n  }, 100);\n\n  // Return cleanup function\n  return () => {\n    console.warn('Cleaning up Event System...');\n\n    // Unregister game loop updates\n    gameLoopManager.unregisterUpdate('event-system-critical');\n    gameLoopManager.unregisterUpdate('event-system-normal');\n\n    // Unregister event handlers\n    unregisterSystemStartup();\n    unregisterResourceEvents();\n    unregisterModuleEvents();\n\n    // Stop the game loop\n    gameLoopManager.stop();\n\n    // Clean up RxJS integration\n    rxjsCleanup();\n  };\n}\n\n/**\n * Initialize global event handlers\n */\nexport function initializeGlobalEventHandlers(): () => void {\n  console.warn('Initializing Global Event Handlers...');\n\n  // Create a priority queue for processing events\n  const eventQueue = new EventPriorityQueue<PriorityQueueEvent>(event => {\n    console.warn(`Processing event: ${event?.type}`);\n    // Process the event based on its type\n    return Promise.resolve();\n  });\n\n  // Subscribe to all module events\n  const unsubscribe = subscribeToAllEvents(event => {\n    // Enqueue the event for processing\n    eventQueue.enqueue({\n      type: event?.type,\n      priority: getPriorityForEventType(event?.type),\n      data: event,\n    });\n  });\n\n  // Return cleanup function\n  return () => {\n    console.warn('Cleaning up Global Event Handlers...');\n\n    // Unsubscribe from all events\n    unsubscribe();\n\n    // Clear the event queue\n    eventQueue.clear();\n  };\n}\n\n/**\n * Helper function to subscribe to all event types\n */\nfunction subscribeToAllEvents(callback: (event: ModuleEvent) => void): () => void {\n  // List of all event types we want to subscribe to\n  const eventTypes: ModuleEventType[] = [\n    'MODULE_CREATED',\n    'MODULE_UPDATED',\n    'MODULE_ATTACHED',\n    'MODULE_DETACHED',\n    'RESOURCE_PRODUCED',\n    'RESOURCE_CONSUMED',\n    'RESOURCE_TRANSFERRED',\n    'STATUS_CHANGED',\n    'ERROR_OCCURRED',\n  ] as ModuleEventType[];\n\n  // Subscribe to each event type\n  const unsubscribers = eventTypes.map(type => moduleEventBus.subscribe(type, callback));\n\n  // Return a function that unsubscribes from all\n  return () => {\n    unsubscribers.forEach(unsubscribe => unsubscribe());\n  };\n}\n\n/**\n * Get priority for an event type\n */\nfunction getPriorityForEventType(type: string): number {\n  // Define priorities for different event types\n  switch (type) {\n    case 'ERROR_OCCURRED':\n      return 0; // CRITICAL\n\n    case 'RESOURCE_SHORTAGE':\n    case 'MODULE_DETACHED':\n      return 1; // HIGH\n\n    case 'MODULE_CREATED':\n    case 'MODULE_ATTACHED':\n    case 'RESOURCE_PRODUCED':\n    case 'RESOURCE_CONSUMED':\n      return 2; // NORMAL\n\n    case 'STATUS_CHANGED':\n    case 'AUTOMATION_CYCLE_COMPLETE':\n      return 3; // LOW\n\n    case 'MISSION_PROGRESS_UPDATED':\n      return 4; // BACKGROUND\n\n    default:\n      return 2; // Default to NORMAL priority\n  }\n}\n\n/**\n * Initialize the entire event system\n */\nexport function initializeCompleteEventSystem(): () => void {\n  // Initialize all components\n  const eventSystemCleanup = initializeEventSystem();\n  const globalHandlersCleanup = initializeGlobalEventHandlers();\n  const automationSystemCleanup = initializeAutomationSystem();\n  const gameSystemsIntegrationCleanup = integrateWithGameSystems();\n\n  // Return combined cleanup function\n  return () => {\n    gameSystemsIntegrationCleanup();\n    automationSystemCleanup();\n    globalHandlersCleanup();\n    eventSystemCleanup();\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/initialization/gameSystemsIntegration.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_' is defined but never used.","line":250,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":250,"endColumn":9},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":291,"column":9,"nodeType":"MemberExpression","messageId":"limited","endLine":291,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[10266,10335],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":307,"column":13,"nodeType":"MemberExpression","messageId":"limited","endLine":307,"endColumn":24,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[10862,10915],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":314,"column":13,"nodeType":"MemberExpression","messageId":"limited","endLine":314,"endColumn":24,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[11092,11145],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":319,"column":13,"nodeType":"MemberExpression","messageId":"limited","endLine":319,"endColumn":24,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[11277,11338],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":324,"column":13,"nodeType":"MemberExpression","messageId":"limited","endLine":324,"endColumn":24,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[11465,11519],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":329,"column":13,"nodeType":"MemberExpression","messageId":"limited","endLine":329,"endColumn":24,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[11615,11685],"text":""},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { moduleEventBus, ModuleEventType } from '../lib/modules/ModuleEvents';\nimport { CombatManager } from '../managers/ManagerRegistry';\nimport { gameLoopManager, UpdatePriority } from '../managers/game/GameLoopManager';\nimport { ResourceManager } from '../managers/game/ResourceManager';\nimport { TechTreeManager } from '../managers/game/techTreeManager';\nimport { MiningResourceIntegration } from '../managers/mining/MiningResourceIntegration';\nimport { MiningShipManagerImpl } from '../managers/mining/MiningShipManagerImpl';\nimport { ResourceCostManager } from '../managers/resource/ResourceCostManager';\nimport { ResourceExchangeManager } from '../managers/resource/ResourceExchangeManager';\nimport { ResourceFlowManager } from '../managers/resource/ResourceFlowManager';\nimport { ResourceIntegration } from '../managers/resource/ResourceIntegration';\nimport { ResourcePoolManager } from '../managers/resource/ResourcePoolManager';\nimport { ResourceStorageManager } from '../managers/resource/ResourceStorageManager';\nimport { ResourceThresholdManager } from '../managers/resource/ResourceThresholdManager';\nimport { ModuleType } from '../types/buildings/ModuleTypes';\nimport { getSystemCommunication, SystemMessage } from '../utils/events/EventCommunication';\nimport { EventPriorityQueue } from '../utils/events/EventFiltering';\nimport { getService } from '../utils/services/ServiceAccess';\nimport { ResourceType } from './../types/resources/ResourceTypes';\n\n// Define types for message payloads\ninterface ResourceUpdatePayload {\n  resourceType: ResourceType;\n  [key: string]: unknown;\n}\n\ninterface MiningUpdatePayload {\n  shipId: string;\n  [key: string]: unknown;\n}\n\ninterface CombatUpdatePayload {\n  type: string;\n  [key: string]: unknown;\n}\n\ninterface TechUpdatePayload {\n  nodeId: string;\n  node?: {\n    category: string;\n    [key: string]: unknown;\n  };\n  [key: string]: unknown;\n}\n\n/**\n * Integrates the event system with existing game systems\n */\nexport function integrateWithGameSystems(): () => void {\n  console.warn('Integrating Event System with Game Systems...');\n\n  // Get system communications\n  const resourceSystemComm = getSystemCommunication('resource-system');\n  const miningSystemComm = getSystemCommunication('mining-system');\n  const combatSystemComm = getSystemCommunication('combat-system');\n  const techSystemComm = getSystemCommunication('tech-system');\n\n  // Initialize cleanup functions array\n  const cleanupFunctions: Array<() => void> = [];\n\n  // ===== Resource System Integration =====\n\n  // Get resource system instances using type-safe access pattern\n  const resourceManager = getService<ResourceManager>('resourceManager');\n  const thresholdManager = getService<ResourceThresholdManager>('thresholdManager');\n  const flowManager = getService<ResourceFlowManager>('flowManager');\n  const storageManager = getService<ResourceStorageManager>('storageManager');\n  const costManager = getService<ResourceCostManager>('costManager');\n  const exchangeManager = getService<ResourceExchangeManager>('exchangeManager');\n  const poolManager = getService<ResourcePoolManager>('poolManager');\n\n  if (resourceManager) {\n    // Make sure all required managers are available\n    if (\n      thresholdManager &&\n      flowManager &&\n      storageManager &&\n      costManager &&\n      exchangeManager &&\n      poolManager\n    ) {\n      // Create resource integration\n      const resourceIntegration = new ResourceIntegration(\n        resourceManager,\n        thresholdManager,\n        flowManager,\n        storageManager,\n        costManager,\n        exchangeManager,\n        poolManager\n      );\n\n      // Initialize resource integration\n      resourceIntegration.initialize();\n\n      // Register resource system event handlers\n      const unregisterResourceHandler = resourceSystemComm.registerHandler(\n        'resource-update',\n        (message: SystemMessage) => {\n          try {\n            const payload = message.payload as ResourceUpdatePayload;\n            if (!payload || typeof payload.resourceType !== 'string') {\n              console.error('Invalid resource update payload:', payload);\n              return;\n            }\n\n            console.warn(`Resource update message received: ${payload.resourceType}`);\n\n            // Emit resource event\n            moduleEventBus.emit({\n              type: 'RESOURCE_UPDATED' as ModuleEventType,\n              moduleId: 'resource-system',\n              moduleType: 'resource-manager' as ModuleType,\n              timestamp: Date.now(),\n              data: payload,\n            });\n          } catch (error) {\n            console.error('Error handling resource update:', error);\n          }\n        }\n      );\n\n      // Add cleanup function\n      cleanupFunctions.push(() => {\n        unregisterResourceHandler();\n        // Additional resource system cleanup if needed\n      });\n\n      console.warn('Resource System integrated with Event System');\n    } else {\n      console.warn('Some resource managers are missing, skipping resource integration');\n    }\n  } else {\n    console.warn('Resource Manager not available. Resource system integration skipped.');\n  }\n\n  // ===== Mining System Integration =====\n\n  // Get mining system instance using type-safe access pattern\n  const miningManager = getService<MiningShipManagerImpl>('miningManager');\n\n  if (miningManager && thresholdManager && flowManager) {\n    // Create mining resource integration\n    const miningResourceIntegration = new MiningResourceIntegration(\n      miningManager,\n      thresholdManager,\n      flowManager\n    );\n\n    // Initialize mining resource integration\n    miningResourceIntegration.initialize();\n\n    // Register mining system event handlers\n    const unregisterMiningHandler = miningSystemComm.registerHandler(\n      'mining-update',\n      (message: SystemMessage) => {\n        try {\n          const payload = message.payload as MiningUpdatePayload;\n          if (!payload || typeof payload.shipId !== 'string') {\n            console.error('Invalid mining update payload:', payload);\n            return;\n          }\n\n          console.warn(`Mining update message received: ${payload.shipId}`);\n\n          // Emit mining event\n          moduleEventBus.emit({\n            type: 'MODULE_UPDATED' as ModuleEventType,\n            moduleId: payload.shipId,\n            moduleType: 'mineral' as ModuleType, // Using a valid ModuleType for mining\n            timestamp: Date.now(),\n            data: payload,\n          });\n        } catch (error) {\n          console.error('Error handling mining update:', error);\n        }\n      }\n    );\n\n    // Add cleanup function\n    cleanupFunctions.push(() => {\n      unregisterMiningHandler();\n      // Additional mining system cleanup if needed\n    });\n\n    console.warn('Mining System integrated with Event System');\n  } else {\n    console.warn('Mining Manager not available. Mining system integration skipped.');\n  }\n\n  // ===== Combat System Integration =====\n\n  // Get combat system instance using type-safe access pattern\n  const combatManager = getService<CombatManager>('combatManager');\n\n  if (combatManager) {\n    // Create a priority queue for combat events\n    const combatEventQueue = new EventPriorityQueue<{\n      type: string;\n      priority: number;\n      data: unknown;\n    }>(event => {\n      try {\n        console.warn(`Processing combat event: ${event?.type}`);\n        // Process the combat event\n        return Promise.resolve();\n      } catch (error) {\n        console.error('Error processing combat event:', error);\n        return Promise.resolve();\n      }\n    });\n\n    // Register combat system event handlers\n    const unregisterCombatHandler = combatSystemComm.registerHandler(\n      'combat-update',\n      (message: SystemMessage) => {\n        try {\n          const payload = message.payload as CombatUpdatePayload;\n          if (!payload || typeof payload.type !== 'string') {\n            console.error('Invalid combat update payload:', payload);\n            return;\n          }\n\n          console.warn(`Combat update message received: ${payload.type}`);\n\n          // Enqueue combat event with appropriate priority\n          combatEventQueue.enqueue({\n            type: payload.type,\n            priority: getCombatEventPriority(payload.type),\n            data: payload,\n          });\n\n          // Emit combat event\n          moduleEventBus.emit({\n            type: 'COMBAT_UPDATED' as ModuleEventType,\n            moduleId: 'combat-system',\n            moduleType: 'defense' as ModuleType, // Using a valid ModuleType for combat\n            timestamp: Date.now(),\n            data: payload,\n          });\n        } catch (error) {\n          console.error('Error handling combat update:', error);\n        }\n      }\n    );\n\n    // Register game loop update for combat event processing\n    gameLoopManager.registerUpdate(\n      'combat-event-processing',\n      (_: number) => {\n        try {\n          // Process combat events based on priority\n          // We can't directly access the private methods, so we'll just let the queue\n          // process events on its own (it does this automatically when events are enqueued)\n          // The queue will use the processor function we provided in the constructor\n        } catch (error) {\n          console.error('Error in combat event processing:', error);\n        }\n      },\n      UpdatePriority.HIGH\n    );\n\n    // Add cleanup function\n    cleanupFunctions.push(() => {\n      unregisterCombatHandler();\n      gameLoopManager.unregisterUpdate('combat-event-processing');\n      combatEventQueue.clear();\n      // Additional combat system cleanup if needed\n    });\n\n    console.warn('Combat System integrated with Event System');\n  } else {\n    console.warn('Combat Manager not available. Combat system integration skipped.');\n  }\n\n  // ===== Tech Tree System Integration =====\n\n  // Get the TechTreeManager instance\n  const techTreeManager = TechTreeManager.getInstance();\n  \n  if (techTreeManager) {\n    // Tech unlocked listener\n    const techUnlockedListener = (data: unknown) => {\n      try {\n        // Handle the data as TechUpdatePayload\n        const payload = data as TechUpdatePayload;\n        if (!payload.nodeId || !payload.node) {\n          return;\n        }\n        \n        console.log('Tech unlocked:', payload.nodeId, payload.node.category);\n        \n        // Notify the rest of the game that a tech was unlocked\n        moduleEventBus.emit({\n          type: 'TECH_UNLOCKED' as ModuleEventType,\n          moduleId: 'tech-tree',\n          moduleType: 'resource-manager' as ModuleType,\n          timestamp: Date.now(),\n          data: payload\n        });\n        \n        // Handle different tech categories\n        switch(payload.node.category) {\n          case 'mining':\n          case 'miningFleet':\n            // Notify mining systems of the new tech\n            console.log('Mining tech unlocked:', payload.nodeId);\n            break;\n            \n          case 'warFleet':\n          case 'weapons':\n          case 'defense':\n            // Notify combat systems of the new tech\n            console.log('Combat tech unlocked:', payload.nodeId);\n            break;\n            \n          case 'infrastructure':\n            // Notify resource and production systems\n            console.log('Infrastructure tech unlocked:', payload.nodeId);\n            break;\n            \n          case 'special':\n            // Special techs might need custom handling\n            console.log('Special tech unlocked:', payload.nodeId);\n            break;\n            \n          default:\n            // Unknown category\n            console.log('Unknown tech category unlocked:', payload.node.category);\n        }\n      } catch (error) {\n        console.error('Error handling tech unlocked event:', error);\n      }\n    };\n    \n    // Register the listener using subscribe\n    techTreeManager.on('nodeUnlocked', techUnlockedListener);\n    \n    // Register tech system event handlers\n    const unregisterTechHandler = techSystemComm.registerHandler(\n      'tech-update',\n      (message: SystemMessage) => {\n        try {\n          const payload = message.payload as TechUpdatePayload;\n          if (!payload || typeof payload.nodeId !== 'string') {\n            console.error('Invalid tech update payload:', payload);\n            return;\n          }\n\n          console.warn(`Tech update message received: ${payload.nodeId}`);\n\n          // Emit tech event\n          moduleEventBus.emit({\n            type: 'TECH_UPDATED' as ModuleEventType,\n            moduleId: 'tech-system',\n            moduleType: ResourceType.RESEARCH as ModuleType, // Using a valid ModuleType for tech\n            timestamp: Date.now(),\n            data: payload,\n          });\n\n          // Check if this is a tech unlock event\n          if (payload.node && payload.node.category) {\n            techUnlockedListener(payload);\n          }\n        } catch (error) {\n          console.error('Error handling tech update:', error);\n        }\n      }\n    );\n\n    // Add cleanup function\n    cleanupFunctions.push(() => {\n      techTreeManager.off('nodeUnlocked', techUnlockedListener);\n      unregisterTechHandler();\n      // Additional tech system cleanup if needed\n    });\n\n    console.warn('Tech Tree System integrated with Event System');\n  }\n\n  // Return a cleanup function\n  return () => {\n    console.warn('Cleaning up Game Systems Integration...');\n\n    // Execute all cleanup functions\n    cleanupFunctions.forEach(cleanup => {\n      try {\n        cleanup();\n      } catch (error) {\n        console.error('Error during cleanup:', error);\n      }\n    });\n  };\n}\n\n/**\n * Get priority for a combat event type\n */\nfunction getCombatEventPriority(type: string): number {\n  // Define priorities for different combat event types\n  switch (type) {\n    case 'unit-destroyed':\n    case 'critical-damage':\n      return 0; // CRITICAL\n\n    case 'unit-under-attack':\n    case 'zone-under-attack':\n      return 1; // HIGH\n\n    case 'unit-moved':\n    case 'weapon-fired':\n      return 2; // NORMAL\n\n    case 'unit-status-changed':\n    case 'zone-status-changed':\n      return 3; // LOW\n\n    case 'combat-stats-updated':\n      return 4; // BACKGROUND\n\n    default:\n      return 2; // Default to NORMAL priority\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/initialization/moduleFrameworkInit.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/initialization/moduleUpgradeInit.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/initialization/serviceRegistration.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/ai/ResourceConsumptionPredictor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/ai/behaviorTree.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/ai/shipBehavior.ts","messages":[{"ruleId":"no-unsafe-optional-chaining","severity":2,"message":"Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.","line":64,"column":35,"nodeType":"ChainExpression","messageId":"unsafeOptionalChain","endLine":64,"endColumn":48}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { EventEmitter } from '../../lib/events/EventEmitter';\nimport { TechTreeManager } from '../../managers/game/techTreeManager';\nimport { Salvage } from '../../types/combat/SalvageTypes';\nimport {\n  CommonShipCapabilities,\n  getDefaultCapabilities,\n  getShipCategory,\n  ShipCategory,\n  type ShipType,\n} from '../../types/ships/CommonShipTypes';\n\ninterface Position {\n  x: number;\n  y: number;\n}\n\ninterface ShipWithPosition extends ShipType {\n  id: string;\n  position: Position;\n  category: ShipCategory;\n  capabilities: CommonShipCapabilities;\n  stats: {\n    health: number;\n    shield: number;\n    speed: number;\n    maneuverability: number;\n    cargo: number;\n  };\n}\n\ninterface ShipTask {\n  id: string;\n  type: 'salvage' | 'combat' | 'patrol' | 'mine';\n  target?: {\n    id: string;\n    position: Position;\n  };\n  priority: number;\n  assignedAt: number;\n}\n\ninterface ShipBehaviorEvents {\n  type: string;\n  data: {\n    taskAssigned?: { shipId: string; taskId: string; taskType: string };\n    taskCompleted?: { shipId: string; taskId: string; success: boolean };\n    shipAdded?: { shipId: string; category: ShipCategory };\n    shipRemoved?: { shipId: string };\n  };\n}\n\nclass ShipBehaviorManagerImpl extends EventEmitter<ShipBehaviorEvents> {\n  private tasks: Map<string, ShipTask> = new Map();\n  private ships: Map<string, ShipWithPosition> = new Map();\n  private salvageTargets: Map<string, string> = new Map(); // salvageId -> shipId\n\n  constructor() {\n    super();\n    this.setupEventListeners();\n  }\n\n  private setupEventListeners(): void {\n    window.addEventListener('salvageGenerated', ((event: CustomEvent) => {\n      const { items, position } = event?.detail;\n      this.handleNewSalvage(items, position);\n    }) as EventListener);\n  }\n\n  private handleNewSalvage(items: Salvage[], position: Position): void {\n    // Find nearby ships that can salvage\n    const nearbyShips = Array.from(this.ships.values())\n      .filter(ship => {\n        // Calculate distance\n        const distance = Math.sqrt(\n          Math.pow(ship.position.x - position.x, 2) + Math.pow(ship.position.y - position.y, 2)\n        );\n\n        // Check if ship can salvage\n        const category = getShipCategory(ship.type);\n        const capabilities = getDefaultCapabilities(category);\n\n        // War ships can salvage if they have the cutting laser\n        const techTreeInstance = TechTreeManager.getInstance();\n        if (category === 'war' && techTreeInstance && techTreeInstance.hasWarShipSalvage()) {\n          capabilities.canSalvage = true;\n        }\n\n        return capabilities.canSalvage && distance < 1000; // 1000 units range\n      })\n      .sort((a, b) => {\n        // Sort by distance\n        const distA = Math.sqrt(\n          Math.pow(a.position.x - position.x, 2) + Math.pow(a.position.y - position.y, 2)\n        );\n        const distB = Math.sqrt(\n          Math.pow(b.position.x - position.x, 2) + Math.pow(b.position.y - position.y, 2)\n        );\n        return distA - distB;\n      });\n\n    // Assign salvage tasks to nearby ships\n    items.forEach(salvage => {\n      const ship = nearbyShips[0]; // Get closest ship\n      if (ship) {\n        this.assignSalvageTask(ship.id!, salvage.id, position);\n        this.salvageTargets.set(salvage.id, ship.id!);\n      }\n    });\n  }\n\n  public assignTask(task: ShipTask): void {\n    if (!task.target) {\n      return;\n    }\n\n    this.tasks.set(task.id, task);\n    this.emit({\n      type: 'taskAssigned',\n      data: {\n        taskAssigned: {\n          shipId: task.id,\n          taskId: task.id,\n          taskType: task.type,\n        },\n      },\n    });\n  }\n\n  public assignSalvageTask(shipId: string, salvageId: string, position: Position): void {\n    const task: ShipTask = {\n      id: `salvage-${salvageId}`,\n      type: 'salvage',\n      target: {\n        id: salvageId,\n        position,\n      },\n      priority: 2, // Medium priority\n      assignedAt: Date.now(),\n    };\n\n    this.tasks.set(shipId, task);\n    this.emit({\n      type: 'taskAssigned',\n      data: {\n        taskAssigned: {\n          shipId,\n          taskId: task.id,\n          taskType: task.type,\n        },\n      },\n    });\n  }\n\n  public registerShip(ship: ShipWithPosition): void {\n    if (!ship.id) {\n      return;\n    }\n    this.ships.set(ship.id, ship);\n  }\n\n  public unregisterShip(shipId: string): void {\n    this.ships.delete(shipId);\n    this.tasks.delete(shipId);\n  }\n\n  public getShipTask(shipId: string): ShipTask | undefined {\n    return this.tasks.get(shipId);\n  }\n\n  public completeTask(shipId: string): void {\n    const task = this.tasks.get(shipId);\n    if (task) {\n      if (task.type === 'salvage' && task.target) {\n        this.salvageTargets.delete(task.target.id);\n      }\n      this.tasks.delete(shipId);\n      this.emit({\n        type: 'taskCompleted',\n        data: {\n          taskCompleted: {\n            shipId,\n            taskId: task.id,\n            success: true,\n          },\n        },\n      });\n    }\n  }\n\n  public isSalvageTargeted(salvageId: string): boolean {\n    return this.salvageTargets.has(salvageId);\n  }\n\n  public getTargetingShip(salvageId: string): string | undefined {\n    return this.salvageTargets.get(salvageId);\n  }\n}\n\nexport const shipBehaviorManager = new ShipBehaviorManagerImpl();\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/ai/shipMovement.ts","messages":[{"ruleId":"no-unsafe-optional-chaining","severity":2,"message":"Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.","line":39,"column":32,"nodeType":"ChainExpression","messageId":"unsafeOptionalChain","endLine":39,"endColumn":45}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { EventEmitter } from '../../lib/events/EventEmitter';\nimport { shipBehaviorManager } from './shipBehavior';\n\ninterface Position {\n  x: number;\n  y: number;\n}\n\ninterface MovementState {\n  targetPosition?: Position;\n  currentSpeed: number;\n  acceleration: number;\n  maxSpeed: number;\n  rotationSpeed: number;\n  currentRotation: number;\n  lastPosition: Position;\n}\n\ninterface ShipMovementEvents {\n  type: string;\n  data: {\n    movementStarted?: { shipId: string; targetPosition: Position };\n    movementUpdated?: { shipId: string; position: Position; rotation: number };\n    movementCompleted?: { shipId: string; finalPosition: Position };\n    movementStopped?: { shipId: string };\n  };\n}\n\nclass ShipMovementManagerImpl extends EventEmitter<ShipMovementEvents> {\n  private movementStates: Map<string, MovementState> = new Map();\n\n  constructor() {\n    super();\n    this.setupEventListeners();\n  }\n\n  private setupEventListeners(): void {\n    window.addEventListener('taskAssigned', ((event: CustomEvent) => {\n      const { shipId, task } = event?.detail;\n      if (task.type === 'salvage' && task.target) {\n        this.moveToPosition(shipId, task.target.position);\n      }\n    }) as EventListener);\n  }\n\n  public registerShip(\n    shipId: string,\n    initialPosition: Position,\n    stats: {\n      maxSpeed: number;\n      acceleration: number;\n      rotationSpeed: number;\n    }\n  ): void {\n    // Log initial position for debugging\n    console.warn(\n      `[ShipMovementSystem] Ship ${shipId} initial position: (${initialPosition.x}, ${initialPosition.y})`\n    );\n\n    this.movementStates.set(shipId, {\n      currentSpeed: 0,\n      acceleration: stats.acceleration,\n      maxSpeed: stats.maxSpeed,\n      rotationSpeed: stats.rotationSpeed,\n      currentRotation: 0,\n      // Store the initial position as the last known position\n      lastPosition: initialPosition,\n    });\n\n    // Emit an event to notify that the ship has been registered with its initial position\n    this.emit({\n      type: 'movementUpdated',\n      data: {\n        movementUpdated: {\n          shipId,\n          position: initialPosition,\n          rotation: 0,\n        },\n      },\n    });\n  }\n\n  public unregisterShip(shipId: string): void {\n    this.movementStates.delete(shipId);\n  }\n\n  public moveToPosition(shipId: string, targetPosition: Position): void {\n    const state = this.movementStates.get(shipId);\n    if (!state) {\n      return;\n    }\n\n    state.targetPosition = targetPosition;\n    this.emit({\n      type: 'movementStarted',\n      data: {\n        movementStarted: {\n          shipId,\n          targetPosition,\n        },\n      },\n    });\n  }\n\n  public update(deltaTime: number, shipPositions: Map<string, Position>): void {\n    this.movementStates.forEach((state, shipId) => {\n      if (!state.targetPosition) {\n        return;\n      }\n\n      const currentPosition = shipPositions.get(shipId);\n      if (!currentPosition) {\n        return;\n      }\n\n      // Calculate direction to target\n      const dx = state.targetPosition.x - currentPosition.x;\n      const dy = state.targetPosition.y - currentPosition.y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n\n      // If we're close enough to target, stop and complete the task\n      if (distance < 5) {\n        // 5 units threshold\n        state.currentSpeed = 0;\n        state.targetPosition = undefined;\n        const task = shipBehaviorManager.getShipTask(shipId);\n        if (task?.type === 'salvage') {\n          shipBehaviorManager.completeTask(shipId);\n        }\n        this.emit({\n          type: 'movementCompleted',\n          data: {\n            movementCompleted: {\n              shipId,\n              finalPosition: shipPositions.get(shipId) || { x: 0, y: 0 },\n            },\n          },\n        });\n        return;\n      }\n\n      // Calculate target rotation (in radians)\n      const targetRotation = Math.atan2(dy, dx);\n\n      // Smoothly rotate towards target\n      let rotationDiff = targetRotation - state.currentRotation;\n      if (rotationDiff > Math.PI) {\n        rotationDiff -= Math.PI * 2;\n      }\n      if (rotationDiff < -Math.PI) {\n        rotationDiff += Math.PI * 2;\n      }\n\n      state.currentRotation +=\n        Math.sign(rotationDiff) * Math.min(Math.abs(rotationDiff), state.rotationSpeed * deltaTime);\n\n      // Accelerate if pointing roughly towards target\n      if (Math.abs(rotationDiff) < Math.PI / 4) {\n        state.currentSpeed = Math.min(\n          state.maxSpeed,\n          state.currentSpeed + state.acceleration * deltaTime\n        );\n      } else {\n        state.currentSpeed = Math.max(0, state.currentSpeed - state.acceleration * deltaTime);\n      }\n\n      // Update position\n      const newPosition: Position = {\n        x: currentPosition.x + Math.cos(state.currentRotation) * state.currentSpeed * deltaTime,\n        y: currentPosition.y + Math.sin(state.currentRotation) * state.currentSpeed * deltaTime,\n      };\n\n      // Emit position update\n      this.emit({\n        type: 'movementUpdated',\n        data: {\n          movementUpdated: {\n            shipId,\n            position: newPosition,\n            rotation: state.currentRotation,\n          },\n        },\n      });\n    });\n  }\n\n  public stopMovement(shipId: string): void {\n    const state = this.movementStates.get(shipId);\n    if (state) {\n      state.targetPosition = undefined;\n      state.currentSpeed = 0;\n      this.emit({\n        type: 'movementStopped',\n        data: {\n          movementStopped: {\n            shipId,\n          },\n        },\n      });\n    }\n  }\n}\n\nexport const shipMovementManager = new ShipMovementManagerImpl();\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/automation/ConditionChecker.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'__RuntimeCondition' is defined but never used. Allowed unused vars must match /^ignored|^temp/u.","line":33,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":33,"endColumn":29}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Subject } from 'rxjs';\nimport { thresholdEvents } from '../../contexts/ThresholdTypes';\nimport {\n  AutomationCondition,\n  EventConditionValue,\n  StatusConditionValue,\n  TimeConditionValue,\n} from '../../managers/game/AutomationManager';\nimport { ResourceManager } from '../../managers/game/ResourceManager';\nimport { MiningShipManagerImpl } from '../../managers/mining/MiningShipManagerImpl';\nimport { moduleManager } from '../../managers/module/ModuleManager';\nimport { ResourceType } from './../../types/resources/ResourceTypes';\n\n// Create a resourceManager instance\nconst resourceManager = new ResourceManager();\n\n// Create a subject to handle condition state\nconst conditionState = new Subject<{\n  resourceId: ResourceType;\n  currentAmount: number;\n  thresholds: { min: number; max: number };\n}>();\n\n/**\n * Extended condition type with runtime state\n * This interface will be used in future implementations to:\n * 1. Track when conditions were last evaluated to optimize performance\n * 2. Store intermediate calculation results for complex conditions\n * 3. Maintain history of condition state changes for analytics\n * 4. Support condition debouncing to prevent rapid oscillation\n * 5. Enable condition-specific timeout and expiration logic\n */\ninterface __RuntimeCondition extends AutomationCondition {\n  lastChecked?: number;\n}\n\n/**\n * Extended condition type with additional properties for time-based conditions\n */\ninterface TimeCondition extends AutomationCondition {\n  value?: TimeConditionValue;\n}\n\n/**\n * Extended condition type with additional properties for status-based conditions\n */\ninterface StatusCondition extends AutomationCondition {\n  value?: StatusConditionValue;\n}\n\n/**\n * Type guard for TimeCondition\n */\nfunction isTimeCondition(condition: AutomationCondition): condition is TimeCondition {\n  return condition.type === 'TIME_ELAPSED';\n}\n\n/**\n * Type guard for StatusCondition\n */\nfunction isStatusCondition(condition: AutomationCondition): condition is StatusCondition {\n  return condition.type === 'STATUS_EQUALS';\n}\n\n/**\n * Helper function to get time value from condition\n */\nfunction getTimeValue(condition: AutomationCondition): number {\n  if (\n    condition.value &&\n    typeof condition.value === 'object' &&\n    'milliseconds' in condition.value &&\n    typeof condition.value.milliseconds === 'number'\n  ) {\n    return condition.value.milliseconds;\n  }\n  return 0;\n}\n\n/**\n * Helper function to get status value from condition\n */\nfunction getStatusValue(condition: AutomationCondition): string {\n  if (\n    condition.value &&\n    typeof condition.value === 'object' &&\n    'status' in condition.value &&\n    typeof condition.value.status === 'string'\n  ) {\n    return condition.value.status;\n  }\n  return '';\n}\n\n/**\n * Interface for mining events\n */\ninterface MiningEvent {\n  type: string;\n  data?: Record<string, unknown>;\n}\n\nexport class ConditionChecker {\n  private lastCheckedTimes: Map<string, number> = new Map();\n\n  /**\n   * Mining manager reference for checking mining-related conditions\n   * This will be used in future implementations to:\n   * 1. Check resource extraction rates for mining ships\n   * 2. Verify mining ship assignments to resource nodes\n   * 3. Optimize mining operations based on automation rules\n   * 4. Trigger mining ship reassignments when conditions are met\n   * 5. Monitor mining efficiency and adjust strategies\n   */\n  private _miningManager?: MiningShipManagerImpl;\n\n  constructor(_miningManager?: MiningShipManagerImpl) {\n    this._miningManager = _miningManager;\n\n    // Subscribe to threshold events\n    thresholdEvents.subscribe(event => {\n      if (event?.type === 'THRESHOLD_VIOLATED' || event?.type === 'STORAGE_FULL') {\n        conditionState.next({\n          resourceId: event?.resourceId,\n          currentAmount: event?.details?.current ?? 0,\n          thresholds: {\n            min: event?.details?.min ?? 0,\n            max: event?.details?.max || Infinity,\n          },\n        });\n      }\n    });\n  }\n\n  /**\n   * Get a unique key for a condition to track its state\n   */\n  private getConditionKey(condition: AutomationCondition): string {\n    return `${condition.type}-${condition.target || 'global'}-${JSON.stringify(condition.value)}`;\n  }\n\n  /**\n   * Check if a condition is met\n   */\n  public async checkCondition(condition: AutomationCondition): Promise<boolean> {\n    const now = Date.now();\n    const key = this.getConditionKey(condition);\n    const lastChecked = this.lastCheckedTimes.get(key) ?? 0;\n\n    // Implement debounce mechanism to prevent checking conditions too frequently\n    const debounceTime = 100; // 100ms debounce\n    if (now - lastChecked < debounceTime) {\n      console.warn(`Condition ${key} checked too recently, skipping`);\n      // Return the last result for debounced conditions\n      return false;\n    }\n\n    // Update last checked time\n    this.lastCheckedTimes.set(key, now);\n\n    // Check condition based on type\n    let result = false;\n\n    switch (condition.type) {\n      case 'MODULE_ACTIVE':\n      case 'MODULE_INACTIVE':\n        result = this.checkModuleCondition(condition);\n        break;\n      case 'TIME_ELAPSED':\n        // Use the isTimeCondition type guard to ensure type safety\n        if (isTimeCondition(condition)) {\n          result = this.checkTimeCondition(condition);\n        }\n        break;\n      case 'EVENT_OCCURRED':\n        result = this.checkEventCondition(condition);\n        break;\n      case 'STATUS_EQUALS':\n        // Use the isStatusCondition type guard to ensure type safety\n        if (isStatusCondition(condition)) {\n          result = this.checkStatusCondition(condition);\n        }\n        break;\n      case 'RESOURCE_ABOVE':\n      case 'RESOURCE_BELOW':\n        result = this.checkResourceCondition(condition);\n        break;\n      default:\n        console.warn(`Unknown condition type: ${condition.type as string}`);\n    }\n\n    return result;\n  }\n\n  /**\n   * Check if a module condition is met\n   */\n  private checkModuleCondition(condition: AutomationCondition): boolean {\n    if (!condition.target) {\n      return false;\n    }\n\n    const module = moduleManager.getModule(condition.target);\n    if (!module) {\n      return false;\n    }\n\n    const isActive = module.status === 'active';\n    return condition.type === 'MODULE_ACTIVE' ? isActive : !isActive;\n  }\n\n  /**\n   * Check if a time condition is met\n   */\n  private checkTimeCondition(condition: AutomationCondition): boolean {\n    const timeValue = getTimeValue(condition);\n    if (timeValue <= 0) {\n      return false;\n    }\n\n    // For time conditions, we check if enough time has passed since the last check\n    const now = Date.now();\n    const key = this.getConditionKey(condition);\n    const lastChecked = this.lastCheckedTimes.get(key) ?? 0;\n    const elapsed = now - lastChecked;\n\n    return elapsed >= timeValue;\n  }\n\n  /**\n   * Check if an event condition is met\n   */\n  private checkEventCondition(condition: AutomationCondition): boolean {\n    // Use the condition parameter to check if the event matches the condition\n    if (!condition.value) {\n      return false;\n    }\n\n    // Extract event type and data from condition value\n    // Cast to unknown first to avoid type errors\n    const conditionValue = condition.value as unknown;\n    const eventValue = conditionValue as EventConditionValue;\n    const { eventType, eventData } = eventValue;\n\n    // Check if this is a mining-related event and use _miningManager if available\n    if (this._miningManager && typeof eventType === 'string' && eventType.includes('mining')) {\n      // Check mining-specific events using the mining manager\n      // Use type assertion to access potential getRecentEvents method\n      const miningManagerWithEvents = this._miningManager as unknown as {\n        getRecentEvents?: () => MiningEvent[];\n      };\n\n      // If getRecentEvents exists, use it; otherwise, return an empty array\n      const miningEvents = miningManagerWithEvents.getRecentEvents?.() ?? [];\n\n      return miningEvents.some(\n        (event: MiningEvent) =>\n          event?.type === eventType &&\n          (!eventData || this.matchEventData(event?.data ?? {}, eventData))\n      );\n    }\n\n    // For non-mining events, check the general event log\n    // This is a placeholder for future implementation\n    return false;\n  }\n\n  /**\n   * Helper method to match event data with condition data\n   */\n  private matchEventData(\n    eventData: Record<string, unknown>,\n    conditionData: Record<string, unknown>\n  ): boolean {\n    // Check if all condition data properties match the event data\n    return Object.entries(conditionData).every(([key, value]) => eventData[key] === value);\n  }\n\n  /**\n   * Check if a status condition is met\n   */\n  private checkStatusCondition(condition: AutomationCondition): boolean {\n    if (!condition.target) {\n      return false;\n    }\n\n    const statusValue = getStatusValue(condition);\n    if (!statusValue) {\n      return false;\n    }\n\n    // Get the current status of the target\n    const module = moduleManager.getModule(condition.target);\n    if (!module) {\n      return false;\n    }\n\n    return module.status === statusValue;\n  }\n\n  /**\n   * Check if a resource condition is met\n   */\n  private checkResourceCondition(condition: AutomationCondition): boolean {\n    if (!condition.target) {\n      return false;\n    }\n\n    // Get the current amount of the resource\n    const resourceType = condition.target as ResourceType;\n    const currentAmount = resourceManager.getResourceAmount(resourceType);\n\n    // Get the threshold value\n    const thresholdValue =\n      typeof condition.value === 'number'\n        ? condition.value\n        : typeof condition.value === 'object' && 'amount' in condition.value\n          ? (condition.value as { amount: number }).amount\n          : 0;\n\n    // Check if the condition is met\n    return condition.type === 'RESOURCE_ABOVE'\n      ? currentAmount > thresholdValue\n      : currentAmount < thresholdValue;\n  }\n\n  /**\n   * Check if all conditions are met\n   */\n  public async checkConditions(conditions: AutomationCondition[]): Promise<boolean> {\n    if (!conditions.length) {\n      return true;\n    }\n\n    // Check each condition\n    for (const condition of conditions) {\n      const result = await this.checkCondition(condition);\n      if (!result) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Reset a condition's state\n   */\n  public resetCondition(condition: AutomationCondition): void {\n    const key = this.getConditionKey(condition);\n    this.lastCheckedTimes.delete(key);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/contexts/BaseContext.tsx","messages":[{"ruleId":"no-unsafe-optional-chaining","severity":2,"message":"Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.","line":349,"column":45,"nodeType":"ChainExpression","messageId":"unsafeOptionalChain","endLine":349,"endColumn":72}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @file BaseContext.tsx\n * Provides a standardized template for context providers in the application.\n *\n * This file implements:\n * 1. A consistent pattern for context creation and usage\n * 2. Built-in error handling and loading states\n * 3. Performance optimization through memoization and context selectors\n * 4. Standard connection pattern to manager services\n * 5. Standardized state update mechanisms\n */\n\nimport * as React from 'react';\nimport { createContext, useContext, useEffect, useMemo, useRef } from 'react';\nimport { BaseEvent, EventType } from '../../types/events/EventTypes';\nimport { EventBus } from '../events/EventBus';\n\n/**\n * Base state interface with common properties for all contexts\n */\nexport interface BaseState {\n  /**\n   * Whether the context is currently loading data\n   */\n  isLoading: boolean;\n\n  /**\n   * Error message if an error occurred\n   */\n  error: string | null;\n\n  /**\n   * Last time the state was updated\n   */\n  lastUpdated: number;\n}\n\n/**\n * Base action interface for all context actions\n */\nexport interface BaseAction<T extends string = string> {\n  /**\n   * The type of action being performed\n   */\n  type: T;\n\n  /**\n   * The payload for the action\n   */\n  payload?: unknown;\n}\n\n/**\n * Special action type for internal event-based updates\n */\nexport interface UpdateFromEventAction<TState extends BaseState>\n  extends BaseAction<'UPDATE_FROM_EVENT'> {\n  payload: TState;\n}\n\n/**\n * Selector function signature for extracting specific parts of state\n */\nexport type Selector<TState extends BaseState, TSelected> = (state: TState) => TSelected;\n\n/**\n * Type for manager method\n */\nexport type ManagerMethod<TManager, TArgs extends unknown[] = unknown[], TReturn = unknown> = (\n  manager: TManager,\n  ...args: TArgs\n) => TReturn;\n\n/**\n * Manager interaction configuration\n */\nexport interface ManagerConfig<TManager> {\n  /**\n   * The manager instance to interact with\n   */\n  manager: TManager;\n\n  /**\n   * Methods to call on the manager from the context\n   */\n  methods: Record<string, ManagerMethod<TManager>>;\n\n  /**\n   * Events to subscribe to from the manager (if it uses an event bus)\n   */\n  events?: {\n    /**\n     * The event bus to subscribe to\n     */\n    eventBus: EventBus<BaseEvent>;\n\n    /**\n     * Map of event types to state update handlers\n     */\n    subscriptions: Record<EventType, (event: BaseEvent, draft: unknown) => void>;\n  };\n}\n\n/**\n * Event handler function type\n */\nexport type EventHandler<TAction extends BaseAction> = (\n  event: BaseEvent,\n  dispatch: React.Dispatch<TAction>\n) => void;\n\n/**\n * Options for creating a context\n */\nexport interface ContextOptions<TState extends BaseState, TAction extends BaseAction> {\n  /**\n   * The name of the context (used for debugging)\n   */\n  name: string;\n\n  /**\n   * The initial state of the context\n   */\n  initialState: TState;\n\n  /**\n   * The reducer function for the context\n   */\n  reducer: (state: TState, action: TAction) => TState;\n\n  /**\n   * Event subscription options\n   */\n  eventSubscriptions?: {\n    /**\n     * Event bus to subscribe to\n     */\n    eventBus: EventBus<BaseEvent>;\n\n    /**\n     * Event types to subscribe to and their handlers\n     */\n    subscriptions: Record<EventType, EventHandler<TAction>>;\n  };\n\n  /**\n   * Performance monitoring configuration\n   */\n  performanceMonitoring?: {\n    /**\n     * Whether to enable performance monitoring\n     */\n    enabled: boolean;\n\n    /**\n     * Threshold in milliseconds for slow reducer warnings\n     */\n    reducerThreshold?: number;\n\n    /**\n     * Threshold in milliseconds for slow selector warnings\n     */\n    selectorThreshold?: number;\n  };\n\n  /**\n   * Debug mode options\n   */\n  debug?: {\n    /**\n     * Whether to log state changes\n     */\n    logStateChanges?: boolean;\n\n    /**\n     * Whether to log actions\n     */\n    logActions?: boolean;\n\n    /**\n     * Whether to log rendering\n     */\n    logRendering?: boolean;\n  };\n}\n\n/**\n * Context result with provider, hooks, and utilities\n */\nexport interface ContextResult<\n  TState extends BaseState,\n  TAction extends BaseAction,\n  TManager = unknown,\n> {\n  /**\n   * The name of the context\n   */\n  contextName: string;\n\n  /**\n   * The React context object\n   */\n  Context: React.Context<\n    | {\n        state: TState;\n        dispatch: React.Dispatch<TAction>;\n      }\n    | undefined\n  >;\n\n  /**\n   * The provider component for the context\n   */\n  Provider: React.FC<{\n    children: React.ReactNode;\n    manager?: TManager;\n    initialState?: Partial<TState>;\n  }>;\n\n  /**\n   * Hook to use the entire context state\n   */\n  useContextState: () => TState;\n\n  /**\n   * Hook to use the context dispatch function\n   */\n  useContextDispatch: () => React.Dispatch<TAction>;\n\n  /**\n   * Hook to select a specific part of the context state\n   */\n  useContextSelector: <TSelected>(selector: Selector<TState, TSelected>) => TSelected;\n\n  /**\n   * Connect the context to a manager\n   */\n  connectToManager: (config: ManagerConfig<TManager>) => void;\n}\n\n/**\n * Creates a standardized context with the given options\n */\nexport function createStandardContext<\n  TState extends BaseState,\n  TAction extends BaseAction,\n  TManager = unknown,\n>(options: ContextOptions<TState, TAction>): ContextResult<TState, TAction, TManager> {\n  type ContextType =\n    | {\n        state: TState;\n        dispatch: React.Dispatch<TAction>;\n      }\n    | undefined;\n\n  // Create a special action creator for internal event-based updates\n  const createUpdateFromEventAction = (payload: TState): TAction => {\n    return {\n      type: 'UPDATE_FROM_EVENT',\n      payload,\n    } as unknown as TAction;\n  };\n\n  // Create the context\n  const Context = createContext<ContextType>(undefined);\n  Context.displayName = `${options?.name}Context`;\n\n  // Reference to the manager connection config\n  const managerConfigRef = { current: null as ManagerConfig<TManager> | null };\n\n  // Provider component\n  const Provider: React.FC<{\n    children: React.ReactNode;\n    manager?: TManager;\n    initialState?: Partial<TState>;\n  }> = ({ children, manager, initialState }) => {\n    // Combine default initial state with override props\n    const combinedInitialState = {\n      ...options?.initialState,\n      ...initialState,\n    } as TState;\n\n    // State and reducer\n    const [state, dispatch] = React.useReducer((state: TState, action: TAction): TState => {\n      if (options?.debug?.logActions) {\n        console.warn(`[${options?.name}] Action:`, action);\n      }\n\n      const startTime = options?.performanceMonitoring?.enabled ? performance.now() : 0;\n\n      // Apply the reducer\n      const newState = options?.reducer(state, action);\n\n      // Update lastUpdated timestamp\n      newState.lastUpdated = Date.now();\n\n      if (options?.performanceMonitoring?.enabled) {\n        const endTime = performance.now();\n        const duration = endTime - startTime;\n\n        if (duration > (options?.performanceMonitoring.reducerThreshold || 5)) {\n          console.warn(\n            `[${options?.name}] Slow reducer for action ${action.type}: ${duration.toFixed(2)}ms`\n          );\n        }\n      }\n\n      if (options?.debug?.logStateChanges) {\n        console.warn(`[${options?.name}] New state:`, newState);\n      }\n\n      return newState;\n    }, combinedInitialState);\n\n    // Manager connection effect\n    useEffect(() => {\n      if (manager && managerConfigRef.current) {\n        const config = managerConfigRef.current;\n\n        // Set up event subscriptions if provided\n        if (config.events) {\n          const { eventBus, subscriptions } = config.events;\n\n          // Subscribe to events\n          const unsubscribers = Object.entries(subscriptions).map(([eventType, handler]) => {\n            return eventBus.subscribe(eventType as EventType, event => {\n              // Use Immer-like pattern with a draft\n              const draft = { ...state };\n              handler(event, draft);\n\n              // Dispatch an action to update the state\n              dispatch(createUpdateFromEventAction(draft as TState));\n            });\n          });\n\n          // Clean up subscriptions\n          return () => {\n            unsubscribers.forEach(unsubscribe => unsubscribe());\n          };\n        }\n      }\n\n      return undefined;\n    }, [manager, state]);\n\n    // Event subscriptions effect\n    useEffect(() => {\n      if (options?.eventSubscriptions) {\n        const { eventBus, subscriptions } = options?.eventSubscriptions;\n\n        // Subscribe to events\n        const unsubscribers = Object.entries(subscriptions).map(([eventType, handler]) => {\n          return eventBus.subscribe(eventType as EventType, event => {\n            handler(event, dispatch);\n          });\n        });\n\n        // Clean up subscriptions\n        return () => {\n          unsubscribers.forEach(unsubscribe => unsubscribe());\n        };\n      }\n\n      return undefined;\n    }, []);\n\n    // Memoize context value to prevent unnecessary renders\n    const contextValue = useMemo(() => {\n      if (options?.debug?.logRendering) {\n        console.warn(`[${options?.name}] Rendering provider`);\n      }\n      return { state, dispatch };\n    }, [state]);\n\n    return <Context.Provider value={contextValue}>{children}</Context.Provider>;\n  };\n\n  // Hook to use the context\n  const useContextState = (): TState => {\n    const context = useContext(Context);\n    if (!context) {\n      throw new Error(`use${options?.name} must be used within a ${options?.name}Provider`);\n    }\n    return context.state;\n  };\n\n  // Hook to use the dispatch function\n  const useContextDispatch = (): React.Dispatch<TAction> => {\n    const context = useContext(Context);\n    if (!context) {\n      throw new Error(`use${options?.name}Dispatch must be used within a ${options?.name}Provider`);\n    }\n    return context.dispatch;\n  };\n\n  // Hook to select a specific part of the context state\n  const useContextSelector = <TSelected,>(selector: Selector<TState, TSelected>): TSelected => {\n    const context = useContext(Context);\n    if (!context) {\n      throw new Error(`use${options?.name}Selector must be used within a ${options?.name}Provider`);\n    }\n\n    // Ref for the previous selected value\n    const prevSelectedRef = useRef<TSelected | undefined>(undefined);\n\n    // Performance monitoring\n    const startTime = options?.performanceMonitoring?.enabled ? performance.now() : 0;\n\n    // Apply the selector\n    const selected = selector(context.state);\n\n    // Performance monitoring\n    if (options?.performanceMonitoring?.enabled) {\n      const endTime = performance.now();\n      const duration = endTime - startTime;\n\n      if (duration > (options?.performanceMonitoring.selectorThreshold || 2)) {\n        console.warn(`[${options?.name}] Slow selector: ${duration.toFixed(2)}ms`);\n      }\n    }\n\n    // Memoize the selected value\n    const memoizedSelected = useMemo(() => {\n      const prevSelected = prevSelectedRef.current;\n\n      // If we have a previous value and it's equal to the current value, return the previous value\n      if (prevSelected !== undefined && Object.is(prevSelected, selected)) {\n        return prevSelected;\n      }\n\n      // Otherwise, update the ref and return the new value\n      prevSelectedRef.current = selected;\n      return selected;\n    }, [selected]);\n\n    return memoizedSelected;\n  };\n\n  // Function to connect the context to a manager\n  const connectToManager = (config: ManagerConfig<TManager>): void => {\n    managerConfigRef.current = config;\n  };\n\n  return {\n    contextName: options?.name,\n    Context,\n    Provider,\n    useContextState,\n    useContextDispatch,\n    useContextSelector,\n    connectToManager,\n  };\n}\n\n/**\n * Creates action creators for a context\n */\nexport function createActions<\n  TActionMap extends Record<string, (...args: unknown[]) => BaseAction>,\n>(actions: TActionMap): TActionMap {\n  return actions;\n}\n\n/**\n * Creates a selector for a specific part of the context state\n */\nexport function createSelector<TState extends BaseState, TSelected>(\n  selector: Selector<TState, TSelected>\n): Selector<TState, TSelected> {\n  return selector;\n}\n\n/**\n * Creates a selector for a specific property of the context state\n */\nexport function createPropertySelector<TState extends BaseState, K extends keyof TState>(\n  property: K\n): Selector<TState, TState[K]> {\n  return state => state[property];\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/events/BaseEventEmitter.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_eventType' is defined but never used.","line":65,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":65,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_handler' is defined but never used.","line":65,"column":49,"nodeType":null,"messageId":"unusedVar","endLine":65,"endColumn":57},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_eventType' is defined but never used.","line":99,"column":29,"nodeType":null,"messageId":"unusedVar","endLine":99,"endColumn":39},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_eventType' is defined but never used.","line":112,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":112,"endColumn":34}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * BaseEventEmitter.ts\n *\n * This file provides a base implementation of the EventEmitter interface\n * that manager classes can extend to gain event emitting capabilities.\n */\n\nimport { v4 as uuidv4 } from 'uuid';\nimport { ModuleType } from '../../types/buildings/ModuleTypes';\nimport {\n  EventHandler,\n  IEventEmitter,\n  SubscriptionOptions,\n} from '../../types/events/EventEmitterInterface';\nimport { BaseEvent, EventType } from '../../types/events/EventTypes';\nimport { EventEmitter } from './EventEmitter';\n\n/**\n * Base class for all event emitters in the system\n * Manager classes should extend this class to gain event emitting capabilities\n */\nexport class BaseEventEmitter implements IEventEmitter {\n  private eventEmitter: EventEmitter;\n\n  /**\n   * Creates a new BaseEventEmitter\n   * @param maxHistorySize Maximum number of events to keep in history\n   * @param trackPerformance Whether to track performance metrics\n   */\n  constructor(maxHistorySize = 100, trackPerformance = false) {\n    this.eventEmitter = new EventEmitter(maxHistorySize, trackPerformance);\n  }\n\n  /**\n   * Subscribe to an event\n   *\n   * @param eventType The type of event to subscribe to\n   * @param handler The function to call when the event is emitted\n   * @param options Additional subscription options\n   * @returns A function to unsubscribe the handler\n   */\n  public on<T>(\n    eventType: EventType | string,\n    handler: EventHandler<T>,\n    options?: SubscriptionOptions\n  ): () => void {\n    return this.eventEmitter.subscribe(\n      event => {\n        if (typeof event === 'object' && event !== null && 'type' in event) {\n          return (event as { type: string }).type === eventType;\n        }\n        return false;\n      },\n      handler as EventHandler<BaseEvent>,\n      options\n    );\n  }\n\n  /**\n   * Unsubscribe from an event\n   *\n   * @param _eventType The type of event to unsubscribe from\n   * @param _handler The handler function to remove\n   */\n  public off<T>(_eventType: EventType | string, _handler: EventHandler<T>): void {\n    // This is a simplified implementation since the EventEmitter class doesn't have a direct 'off' method\n    // In a real implementation, you would need to track subscriptions to properly remove them\n    console.warn('off method is not fully implemented in BaseEventEmitter');\n  }\n\n  /**\n   * Emit an event\n   *\n   * @param eventType The type of event to emit\n   * @param data The data to pass to the event handlers\n   */\n  public emit<T>(eventType: EventType | string, data: T): void {\n    // Create an event object that conforms to the BaseEvent interface\n    const event: BaseEvent = {\n      id: uuidv4(),\n      type: eventType as EventType,\n      name: eventType as EventType,\n      description: eventType as EventType,\n      category: eventType as EventType,\n      subCategory: eventType as EventType,\n      timestamp: Date.now(),\n      moduleId: (data as { moduleId?: string })?.moduleId || 'unknown',\n      moduleType: (data as { moduleType?: ModuleType })?.moduleType || 'radar',\n      data: data as Record<string, unknown>,\n    };\n    this.eventEmitter.emit(event);\n  }\n\n  /**\n   * Remove all event listeners\n   *\n   * @param _eventType Optional event type to remove listeners for. If not provided, all listeners are removed.\n   */\n  public removeAllListeners(_eventType?: EventType | string): void {\n    // This is a simplified implementation since the EventEmitter class doesn't have a direct 'removeAllListeners' method\n    // In a real implementation, you would need to track subscriptions to properly remove them\n    console.warn('removeAllListeners method is not fully implemented in BaseEventEmitter');\n    this.eventEmitter.clear();\n  }\n\n  /**\n   * Get the number of listeners for an event type\n   *\n   * @param _eventType The event type to get the listener count for\n   * @returns The number of listeners\n   */\n  public listenerCount(_eventType: EventType | string): number {\n    // This is a simplified implementation since the EventEmitter class doesn't track listeners by event type\n    return this.eventEmitter.handlerCount;\n  }\n\n  /**\n   * Get the event history\n   *\n   * @param eventType Optional event type to filter by\n   * @returns Array of events\n   */\n  public getHistory(eventType?: string): BaseEvent[] {\n    return this.eventEmitter.getHistory(eventType);\n  }\n\n  /**\n   * Get the latest event of a specific type\n   *\n   * @param eventType The event type to get\n   * @returns The latest event of the specified type, or undefined if none exists\n   */\n  public getLatestEvent(eventType: string): BaseEvent | undefined {\n    return this.eventEmitter.getLatestEvent(eventType);\n  }\n\n  /**\n   * Get performance metrics for event processing\n   *\n   * @param eventType Optional event type to get metrics for, defaults to 'all'\n   * @returns Performance metrics object\n   */\n  public getPerformanceMetrics(eventType?: string): unknown {\n    return this.eventEmitter.getPerformanceMetrics(eventType);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/events/BaseTypedEventEmitter.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'event' is defined but never used.","line":64,"column":42,"nodeType":null,"messageId":"unusedVar","endLine":64,"endColumn":47}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * BaseTypedEventEmitter.ts\n *\n * This file provides a base implementation of the ITypedEventEmitter interface\n * that manager classes can extend to gain typed event emitting capabilities.\n */\n\nimport { ITypedEventEmitter } from '../../types/events/EventEmitterInterface';\nimport { TypedEventEmitter } from './EventBus';\n\n/**\n * Base class for all typed event emitters in the system\n * Manager classes should extend this class to gain typed event emitting capabilities\n */\nexport class BaseTypedEventEmitter<T extends Record<string, unknown>>\n  extends TypedEventEmitter<T>\n  implements ITypedEventEmitter<T>\n{\n  /**\n   * Creates a new BaseTypedEventEmitter\n   */\n  constructor() {\n    super();\n  }\n\n  /**\n   * Emit an event\n   *\n   * @param event The event name (key of T)\n   * @param data The data to pass to the event handlers\n   */\n  public emit<K extends keyof T>(event: K, data: T[K]): void {\n    // Call the protected emit method from the parent class\n    super.emit(event, data);\n  }\n\n  /**\n   * Remove all event listeners\n   *\n   * @param event Optional event name to remove listeners for. If not provided, all listeners are removed.\n   */\n  public removeAllListeners<K extends keyof T>(event?: K): void {\n    if (event) {\n      // Clear listeners for a specific event\n      const handlers = this.getHandlers(event);\n      if (handlers) {\n        handlers.forEach(handler => {\n          this.off(event, handler);\n        });\n      }\n    } else {\n      // Clear all listeners\n      this.clearAllListeners();\n    }\n  }\n\n  /**\n   * Get all handlers for a specific event\n   * This is a helper method used by removeAllListeners\n   *\n   * @param event The event name\n   * @returns Array of handlers for the event\n   */\n  private getHandlers<K extends keyof T>(event: K): Array<(data: T[K]) => void> {\n    // This is a simplified implementation\n    // In a real implementation, we would track all handlers\n    return [];\n  }\n\n  /**\n   * Subscribe to an event (alias for on)\n   *\n   * @param event The event name (key of T)\n   * @param callback The function to call when the event is emitted\n   * @returns A function to unsubscribe the handler\n   */\n  public subscribe<K extends keyof T>(event: K, callback: (data: T[K]) => void): () => void {\n    return this.on(event, callback);\n  }\n\n  /**\n   * Unsubscribe from an event (alias for off)\n   *\n   * @param event The event name (key of T)\n   * @param callback The handler function to remove\n   */\n  public unsubscribe<K extends keyof T>(event: K, callback: (data: T[K]) => void): void {\n    this.off(event, callback);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/events/EventBatcher.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/events/EventBus.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":729,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":729,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21586,21589],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21586,21589],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":734,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":734,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21816,21819],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21816,21819],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/events/EventBusTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/events/EventEmitter.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_event' is defined but never used.","line":411,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":411,"endColumn":39},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_callback' is defined but never used.","line":411,"column":44,"nodeType":null,"messageId":"unusedVar","endLine":411,"endColumn":53}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * EventEmitter.ts\n *\n * A generic event emitter implementation that supports both typed events\n * and predicate-based subscriptions. This implementation is designed to be\n * compatible with the EventBus system while providing additional flexibility.\n */\n\nimport { BaseEvent, EventType } from '../../types/events/EventTypes';\n\n/**\n * Type for event handler functions\n */\nexport type EventHandler<T> = (event: T) => void;\n\n/**\n * Type for event predicate functions that can filter events\n */\nexport type EventPredicate<T> = (event: T) => boolean;\n\n/**\n * Options for event subscription\n */\nexport interface SubscriptionOptions {\n  /**\n   * Call listener immediately with last event of this type if available\n   */\n  emitLatest?: boolean;\n\n  /**\n   * Source identification for tracking subscriptions\n   */\n  source?: string;\n\n  /**\n   * Priority for event processing (lower numbers = higher priority)\n   */\n  priority?: number;\n}\n\n/**\n * Performance metrics for event processing\n */\nexport interface EventPerformanceMetrics {\n  eventType: string | 'all';\n  emitCount: number;\n  listenerCount: number;\n  totalProcessingTime: number;\n  averageProcessingTime: number;\n  lastProcessingTime: number;\n  maxProcessingTime: number;\n}\n\n/**\n * Generic EventEmitter class for simple event handling\n *\n * This implementation supports:\n * 1. Predicate-based subscriptions for filtering events\n * 2. Named event subscriptions with type safety\n * 3. Performance monitoring\n * 4. Event history tracking\n */\nexport class EventEmitter<T = BaseEvent> {\n  private handlers: Array<{\n    predicate: EventPredicate<T>;\n    handler: EventHandler<T>;\n    priority: number;\n  }> = [];\n\n  private history: T[] = [];\n  private latestEvents: Map<string, T> = new Map();\n  private maxHistorySize: number;\n  private metrics: Map<string, EventPerformanceMetrics> = new Map();\n  private trackPerformance: boolean;\n\n  /**\n   * Creates a new EventEmitter instance\n   * @param maxHistorySize Maximum number of events to keep in history\n   * @param trackPerformance Whether to track performance metrics\n   */\n  constructor(maxHistorySize = 100, trackPerformance = false) {\n    this.maxHistorySize = maxHistorySize;\n    this.trackPerformance = trackPerformance;\n\n    // Initialize metrics for all events\n    this.metrics.set('all', {\n      eventType: 'all',\n      emitCount: 0,\n      listenerCount: 0,\n      totalProcessingTime: 0,\n      averageProcessingTime: 0,\n      lastProcessingTime: 0,\n      maxProcessingTime: 0,\n    });\n  }\n\n  /**\n   * Subscribe to events that match the given predicate\n   *\n   * @param predicate Function to determine if an event should trigger the handler\n   * @param handler Function to call when a matching event is emitted\n   * @param options Additional subscription options\n   * @returns Function to unsubscribe the handler\n   */\n  public subscribe(\n    predicate: EventPredicate<T>,\n    handler: EventHandler<T>,\n    options: SubscriptionOptions = {}\n  ): () => void {\n    const subscription = {\n      predicate,\n      handler,\n      priority: options?.priority ?? 100,\n    };\n\n    this.handlers.push(subscription);\n\n    // Sort handlers by priority (lower numbers = higher priority)\n    this.handlers.sort((a, b) => a.priority - b.priority);\n\n    // Update metrics\n    if (this.trackPerformance) {\n      this.updateListenerCountMetrics();\n    }\n\n    // Return unsubscribe function\n    return () => {\n      const index = this.handlers.indexOf(subscription);\n      if (index !== -1) {\n        this.handlers.splice(index, 1);\n\n        // Update metrics\n        if (this.trackPerformance) {\n          this.updateListenerCountMetrics();\n        }\n      }\n    };\n  }\n\n  /**\n   * Subscribe to all events\n   *\n   * @param handler Function to call for all events\n   * @param options Additional subscription options\n   * @returns Function to unsubscribe the handler\n   */\n  public subscribeToAll(handler: EventHandler<T>, options: SubscriptionOptions = {}): () => void {\n    return this.subscribe(() => true, handler, options);\n  }\n\n  /**\n   * Subscribe to events using event name\n   */\n  public on<K extends keyof T>(event: K, handler: EventHandler<T[K]>): () => void {\n    return this.subscribe(\n      e => typeof e === 'object' && e !== null && 'type' in e && (e as { type: K }).type === event,\n      handler as EventHandler<T>\n    );\n  }\n\n  /**\n   * Unsubscribe from events using event name\n   */\n  public off<K extends keyof T>(event: K, handler: EventHandler<T[K]>): void {\n    const index = this.handlers.findIndex(\n      h => h.handler === handler && h.predicate({ type: event } as T)\n    );\n    if (index !== -1) {\n      this.handlers.splice(index, 1);\n    }\n  }\n\n  /**\n   * Emit an event to all matching subscribers\n   * Supports both single argument (event object) and double argument (event name, data) patterns\n   */\n  public emit<K extends keyof T>(eventOrType: T | K, data?: T[K]): void {\n    let event: T;\n    if (typeof eventOrType === 'object' && eventOrType !== null) {\n      event = eventOrType as T;\n    } else {\n      event = { type: eventOrType, ...data } as T;\n    }\n\n    // Add to history\n    this.history.push(event);\n    if (this.history.length > this.maxHistorySize) {\n      this.history.shift();\n    }\n\n    // Store as latest event if it has a type property\n    if (event && typeof event === 'object' && 'type' in event) {\n      const eventType = String((event as Record<string, unknown>).type);\n      this.latestEvents.set(eventType, event);\n    }\n\n    // Performance tracking\n    const startTime = this.trackPerformance ? performance.now() : 0;\n    let processingTime = 0;\n\n    // Call matching handlers\n    for (const { predicate, handler } of this.handlers) {\n      if (predicate(event)) {\n        try {\n          handler(event);\n        } catch (error) {\n          console.error('Error in event handler:', error);\n        }\n      }\n    }\n\n    // Update performance metrics\n    if (this.trackPerformance) {\n      processingTime = performance.now() - startTime;\n\n      // Update metrics for specific event type if available\n      if (event && typeof event === 'object' && 'type' in event) {\n        const eventType = String((event as Record<string, unknown>).type);\n        this.updatePerformanceMetrics(eventType, processingTime, this.handlers.length);\n      }\n\n      // Update overall metrics\n      this.updatePerformanceMetrics('all', processingTime, this.handlers.length);\n    }\n  }\n\n  /**\n   * Get the event history\n   *\n   * @param eventType Optional event type to filter by\n   * @returns Array of events\n   */\n  public getHistory(eventType?: string): T[] {\n    if (!eventType) {\n      return [...this.history];\n    }\n\n    return this.history.filter(event => {\n      return (\n        typeof event === 'object' &&\n        event !== null &&\n        'type' in event &&\n        (event as Record<string, unknown>).type === eventType\n      );\n    });\n  }\n\n  /**\n   * Get the latest event of a specific type\n   *\n   * @param eventType The event type to get\n   * @returns The latest event of the specified type, or undefined if none exists\n   */\n  public getLatestEvent(eventType: string): T | undefined {\n    return this.latestEvents.get(eventType);\n  }\n\n  /**\n   * Get performance metrics for event processing\n   *\n   * @param eventType Optional event type to get metrics for, defaults to 'all'\n   * @returns Performance metrics object\n   */\n  public getPerformanceMetrics(eventType: string = 'all'): EventPerformanceMetrics {\n    return (\n      this.metrics.get(eventType) || {\n        eventType,\n        emitCount: 0,\n        listenerCount: 0,\n        totalProcessingTime: 0,\n        averageProcessingTime: 0,\n        lastProcessingTime: 0,\n        maxProcessingTime: 0,\n      }\n    );\n  }\n\n  /**\n   * Remove all event handlers\n   */\n  public clear(): void {\n    this.handlers = [];\n    this.updateListenerCountMetrics();\n  }\n\n  /**\n   * Clear the event history\n   */\n  public clearHistory(): void {\n    this.history = [];\n    this.latestEvents.clear();\n  }\n\n  /**\n   * Reset performance metrics\n   */\n  public resetMetrics(): void {\n    this.metrics.clear();\n    this.metrics.set('all', {\n      eventType: 'all',\n      emitCount: 0,\n      listenerCount: 0,\n      totalProcessingTime: 0,\n      averageProcessingTime: 0,\n      lastProcessingTime: 0,\n      maxProcessingTime: 0,\n    });\n  }\n\n  /**\n   * Get the number of registered handlers\n   */\n  public get handlerCount(): number {\n    return this.handlers.length;\n  }\n\n  /**\n   * Update performance metrics for an event type\n   *\n   * @param eventType The event type to update metrics for\n   * @param processingTime The time taken to process the event\n   * @param listenerCount The number of listeners for the event\n   */\n  private updatePerformanceMetrics(\n    eventType: string,\n    processingTime: number,\n    listenerCount: number\n  ): void {\n    if (!this.trackPerformance) return;\n\n    // Create metrics object if it doesn't exist\n    if (!this.metrics.has(eventType)) {\n      this.metrics.set(eventType, {\n        eventType,\n        emitCount: 0,\n        listenerCount: 0,\n        totalProcessingTime: 0,\n        averageProcessingTime: 0,\n        lastProcessingTime: 0,\n        maxProcessingTime: 0,\n      });\n    }\n\n    const metrics = this.metrics.get(eventType)!;\n\n    // Update metrics\n    metrics.emitCount += 1;\n    metrics.listenerCount = listenerCount;\n    metrics.totalProcessingTime += processingTime;\n    metrics.lastProcessingTime = processingTime;\n    metrics.maxProcessingTime = Math.max(metrics.maxProcessingTime, processingTime);\n    metrics.averageProcessingTime = metrics.totalProcessingTime / metrics.emitCount;\n  }\n\n  /**\n   * Update listener count metrics\n   */\n  private updateListenerCountMetrics(): void {\n    if (!this.trackPerformance) return;\n\n    // Update all metrics objects with current listener count\n    for (const [_eventType, metrics] of this.metrics.entries()) {\n      metrics.listenerCount = this.handlers.length;\n    }\n  }\n}\n\n/**\n * Specialized EventEmitter for named events\n *\n * This implementation provides a more structured API for working with\n * named events, while maintaining compatibility with the base EventEmitter.\n */\nexport class TypedEventEmitter<T extends Record<string, unknown>> {\n  private emitter: EventEmitter<{ type: keyof T | EventType } & Record<string, unknown>>;\n\n  /**\n   * Creates a new TypedEventEmitter instance\n   *\n   * @param maxHistorySize Maximum number of events to keep in history\n   * @param trackPerformance Whether to track performance metrics\n   */\n  constructor(maxHistorySize = 100, trackPerformance = false) {\n    this.emitter = new EventEmitter<{ type: keyof T | EventType } & Record<string, unknown>>(\n      maxHistorySize,\n      trackPerformance\n    );\n  }\n\n  /**\n   * Subscribe to an event\n   *\n   * @param event The event type to subscribe to\n   * @param callback The function to call when the event occurs\n   * @returns A function that, when called, unsubscribes the listener\n   */\n  public on<K extends keyof T>(event: K, callback: (data: T[K]) => void): () => void {\n    return this.emitter.subscribe(\n      e => e.type === event,\n      e => callback(e.data as T[K])\n    );\n  }\n\n  /**\n   * Unsubscribe from an event\n   *\n   * @deprecated Use the returned function from on() instead\n   * @param event The event type to unsubscribe from\n   * @param callback The function to unsubscribe\n   */\n  public off<K extends keyof T>(_event: K, _callback: (data: T[K]) => void): void {\n    console.warn(\n      'TypedEventEmitter.off() is deprecated. Use the returned function from on() instead.'\n    );\n    // This method is kept for backward compatibility but doesn't actually work\n    // since we can't identify the original subscription\n  }\n\n  /**\n   * Emit an event with data\n   *\n   * @param event The event type to emit\n   * @param data The event data\n   */\n  public emit<K extends keyof T>(event: K, data: T[K]): void {\n    this.emitter.emit({\n      type: event,\n      data,\n      timestamp: Date.now(),\n    });\n  }\n\n  /**\n   * Subscribe to an event (alias for on)\n   *\n   * @param event The event type to subscribe to\n   * @param callback The function to call when the event occurs\n   * @returns A function that, when called, unsubscribes the listener\n   */\n  public subscribe<K extends keyof T>(event: K, callback: (data: T[K]) => void): () => void {\n    return this.on(event, callback);\n  }\n\n  /**\n   * Unsubscribe from an event (alias for off)\n   *\n   * @deprecated Use the returned function from subscribe() instead\n   * @param event The event type to unsubscribe from\n   * @param callback The function to unsubscribe\n   */\n  public unsubscribe<K extends keyof T>(_event: K, _callback: (data: T[K]) => void): void {\n    console.warn(\n      'TypedEventEmitter.unsubscribe() is deprecated. Use the returned function from subscribe() instead.'\n    );\n    this.off(_event, _callback);\n  }\n\n  /**\n   * Remove all listeners for an event\n   *\n   * @param event Optional event type to remove listeners for. If not provided, all listeners are removed.\n   */\n  public removeAllListeners<K extends keyof T>(event?: K): void {\n    // Since we can't selectively remove listeners by event type in the underlying implementation,\n    // we'll need to recreate the emitter if an event is specified\n    if (event) {\n      const newEmitter = new EventEmitter<{ type: keyof T | EventType } & Record<string, unknown>>(\n        this.emitter['maxHistorySize'],\n        this.emitter['trackPerformance']\n      );\n\n      // Copy over all handlers except those for the specified event\n      for (const handler of this.emitter['handlers']) {\n        if (\n          handler.predicate({ type: event } as { type: keyof T | EventType } & Record<\n            string,\n            unknown\n          >) === false\n        ) {\n          newEmitter['handlers'].push(handler);\n        }\n      }\n\n      this.emitter = newEmitter;\n    } else {\n      this.emitter.clear();\n    }\n  }\n\n  /**\n   * Get the event history\n   *\n   * @param event Optional event type to filter by\n   * @returns Array of events\n   */\n  public getHistory<K extends keyof T>(\n    event?: K\n  ): Array<{ type: keyof T | EventType; data: unknown; timestamp: number }> {\n    return this.emitter.getHistory(event as string) as Array<{\n      type: keyof T | EventType;\n      data: unknown;\n      timestamp: number;\n    }>;\n  }\n\n  /**\n   * Get performance metrics for event processing\n   *\n   * @param event Optional event type to get metrics for, defaults to 'all'\n   * @returns Performance metrics object\n   */\n  public getPerformanceMetrics<K extends keyof T>(event?: K): EventPerformanceMetrics {\n    return this.emitter.getPerformanceMetrics(event as string);\n  }\n\n  /**\n   * Clear the event history\n   */\n  public clearHistory(): void {\n    this.emitter.clearHistory();\n  }\n\n  /**\n   * Reset performance metrics\n   */\n  public resetMetrics(): void {\n    this.emitter.resetMetrics();\n  }\n\n  /**\n   * Get the number of registered handlers\n   */\n  public get handlerCount(): number {\n    return this.emitter.handlerCount;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/events/ModuleEventBus.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/events/UnifiedEventSystem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/managers/BaseManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/managers/ServiceRegistry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/modules/BaseTypedEventEmitter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/modules/ModuleEvents.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/optimization/EntityPool.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/optimization/QuadTree.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/optimization/RenderBatcher.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/optimization/RenderBatcher.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_key' is defined but never used.","line":147,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":147,"endColumn":36}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Position } from '../../types/core/Position';\nimport { EventEmitter } from '../events/EventEmitter';\n\nexport interface RenderBatch {\n  id: string;\n  type: string;\n  zIndex: number;\n  items: RenderItem[];\n}\n\nexport interface RenderItem {\n  id: string;\n  position: Position;\n  size: { width: number; height: number };\n  rotation: number;\n  opacity: number;\n  color: string;\n  texture?: string;\n  shader?: string;\n  uniforms?: Record<string, unknown>;\n}\n\nexport interface RenderBatcherEvent {\n  type: 'batchCreated' | 'batchUpdated' | 'batchRemoved' | 'frameStarted' | 'frameEnded';\n  batch?: RenderBatch;\n  batchId?: string;\n  timestamp?: number;\n  drawCalls?: number;\n}\n\nexport interface RenderBatcherEvents {\n  batchCreated: { batch: RenderBatch };\n  batchUpdated: { batch: RenderBatch };\n  batchRemoved: { batchId: string };\n  frameStarted: { timestamp: number };\n  frameEnded: { timestamp: number; drawCalls: number };\n  [key: string]: unknown;\n}\n\n/**\n * Manages render batching for optimized drawing\n */\nexport class RenderBatcher extends EventEmitter<RenderBatcherEvent> {\n  private batches: Map<string, RenderBatch> = new Map();\n  private sortedBatches: RenderBatch[] = [];\n  private needsSort: boolean = false;\n  private drawCalls: number = 0;\n\n  constructor() {\n    super();\n    console.warn('[RenderBatcher] Initialized');\n  }\n\n  /**\n   * Create a new render batch\n   */\n  public createBatch(type: string, zIndex: number = 0): string {\n    const id = `batch-${type}-${Date.now()}`;\n    const batch: RenderBatch = {\n      id,\n      type,\n      zIndex,\n      items: [],\n    };\n\n    this.batches.set(id, batch);\n    this.needsSort = true;\n    this.emit({ type: 'batchCreated', batch });\n\n    return id;\n  }\n\n  /**\n   * Add item to a batch\n   */\n  public addItem(batchId: string, item: RenderItem): void {\n    const batch = this.batches.get(batchId);\n    if (batch) {\n      batch.items.push(item);\n      this.emit({ type: 'batchUpdated', batch });\n    }\n  }\n\n  /**\n   * Remove item from a batch\n   */\n  public removeItem(batchId: string, itemId: string): void {\n    const batch = this.batches.get(batchId);\n    if (batch) {\n      const index = batch.items.findIndex(item => item?.id === itemId);\n      if (index !== -1) {\n        batch.items.splice(index, 1);\n        this.emit({ type: 'batchUpdated', batch });\n      }\n    }\n  }\n\n  /**\n   * Remove a batch\n   */\n  public removeBatch(batchId: string): void {\n    if (this.batches.delete(batchId)) {\n      this.needsSort = true;\n      this.emit({ type: 'batchRemoved', batchId });\n    }\n  }\n\n  /**\n   * Sort batches by z-index\n   */\n  private sortBatches(): void {\n    if (!this.needsSort) {\n      return;\n    }\n\n    this.sortedBatches = Array.from(this.batches.values()).sort((a, b) => a.zIndex - b.zIndex);\n    this.needsSort = false;\n  }\n\n  /**\n   * Begin frame\n   */\n  public beginFrame(timestamp: number): void {\n    this.drawCalls = 0;\n    this.emit({ type: 'frameStarted', timestamp });\n  }\n\n  /**\n   * Render all batches\n   */\n  public render(ctx: CanvasRenderingContext2D): void {\n    this.sortBatches();\n\n    // Group items by shader and texture to minimize state changes\n    this.sortedBatches.forEach(batch => {\n      const byShader = new Map<string, RenderItem[]>();\n\n      batch.items.forEach(item => {\n        const key = `${item?.shader || 'default'}-${item?.texture || 'none'}`;\n        if (!byShader.has(key)) {\n          byShader.set(key, []);\n        }\n        byShader.get(key)!.push(item);\n      });\n\n      // Render each group\n      byShader.forEach((items, _key) => {\n        // Set up shader and texture once for the group\n        this.setupShaderAndTexture(ctx, items[0]);\n        this.drawCalls++;\n\n        // Render all items in the group\n        items.forEach(item => {\n          this.renderItem(ctx, item);\n        });\n      });\n    });\n  }\n\n  /**\n   * Set up shader and texture for a group\n   */\n  private setupShaderAndTexture(ctx: CanvasRenderingContext2D, item: RenderItem): void {\n    // Set global alpha\n    ctx.globalAlpha = item?.opacity;\n\n    // Set blend mode based on shader\n    if (item?.shader === 'additive') {\n      ctx.globalCompositeOperation = 'lighter';\n    } else {\n      ctx.globalCompositeOperation = 'source-over';\n    }\n\n    // Set color\n    ctx.fillStyle = item?.color;\n    ctx.strokeStyle = item?.color;\n  }\n\n  /**\n   * Render a single item\n   */\n  private renderItem(ctx: CanvasRenderingContext2D, item: RenderItem): void {\n    ctx.save();\n\n    // Transform\n    ctx.translate(item?.position.x, item?.position.y);\n    ctx.rotate(item?.rotation);\n\n    // Draw\n    if (item?.texture) {\n      // Draw textured quad\n      ctx.fillRect(\n        -item?.size.width / 2,\n        -item?.size.height / 2,\n        item?.size.width,\n        item?.size.height\n      );\n    } else {\n      // Draw colored quad\n      ctx.fillRect(\n        -item?.size.width / 2,\n        -item?.size.height / 2,\n        item?.size.width,\n        item?.size.height\n      );\n    }\n\n    ctx.restore();\n  }\n\n  /**\n   * End frame\n   */\n  public endFrame(timestamp: number): void {\n    this.emit({ type: 'frameEnded', timestamp, drawCalls: this.drawCalls });\n  }\n\n  /**\n   * Clean up\n   */\n  public cleanup(): void {\n    this.batches.clear();\n    this.sortedBatches = [];\n    this.needsSort = false;\n    this.drawCalls = 0;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/optimization/WebGLShaderManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'deltaTime' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":690,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":690,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Position } from '../../types/core/Position';\n\n/**\n * Represents a WebGL shader uniform\n */\nexport interface ShaderUniform {\n  type: 'float' | 'vec2' | 'vec3' | 'vec4' | 'int' | 'bool' | 'sampler2D';\n  value: number | number[] | boolean | WebGLTexture | null;\n}\n\n/**\n * Supported shader types for data visualization\n */\nexport enum DataVisualizationShaderType {\n  HEATMAP = 'heatmap',\n  CONTOUR = 'contour',\n  POINT_CLUSTER = 'pointCluster',\n  HIGHLIGHT = 'highlight',\n  DENSITY = 'density',\n  FLOW = 'flow',\n  TRANSITION = 'transition',\n  CUSTOM = 'custom',\n}\n\n/**\n * Configuration for data visualization shaders\n */\nexport interface DataVisualizationShaderConfig {\n  type: DataVisualizationShaderType;\n  colors: string[];\n  intensity?: number;\n  resolution?: [number, number];\n  animate?: boolean;\n  animationSpeed?: number;\n  highlightRange?: [number, number];\n  dataRange?: [number, number];\n  dataPoints?: Float32Array;\n  customUniforms?: Record<string, ShaderUniform>;\n  customVertexShader?: string;\n  customFragmentShader?: string;\n}\n\n/**\n * WebGL Shader Manager for data visualization effects\n *\n * This utility manages WebGL shaders for data visualization, including\n * heatmaps, contour plots, point clustering, and data highlighting effects.\n */\nexport class WebGLShaderManager {\n  private gl: WebGLRenderingContext | null = null;\n  private canvas: HTMLCanvasElement | null = null;\n  private programs: Map<string, WebGLProgram> = new Map();\n  private shaders: Map<string, WebGLShader> = new Map();\n  private textures: Map<string, WebGLTexture> = new Map();\n  private framebuffers: Map<string, WebGLFramebuffer> = new Map();\n  private animationFrame: number | null = null;\n  private _lastTimestamp: number = 0;\n\n  /**\n   * Initialize the WebGL context\n   */\n  public initialize(canvas: HTMLCanvasElement): boolean {\n    try {\n      this.canvas = canvas;\n      this.gl = canvas.getContext('webgl', {\n        alpha: true,\n        premultipliedAlpha: false,\n        antialias: true,\n        powerPreference: 'high-performance',\n      });\n\n      if (!this.gl) {\n        console.error('[WebGLShaderManager] WebGL not supported');\n        return false;\n      }\n\n      this.initializeDefaultShaders();\n      console.warn('[WebGLShaderManager] Initialized successfully');\n      return true;\n    } catch (error) {\n      console.error('[WebGLShaderManager] Initialization failed', error);\n      return false;\n    }\n  }\n\n  /**\n   * Initialize default shaders for each visualization type\n   */\n  private initializeDefaultShaders(): void {\n    // Set up standard shaders for each visualization type\n    Object.values(DataVisualizationShaderType).forEach(type => {\n      if (typeof type === 'string') {\n        // Create a default shader with a predefined color array\n        this.createDataVisualizationShader({\n          type: type as DataVisualizationShaderType,\n          colors: [\n            '#3366cc', // Blue\n            '#cc6633', // Orange\n            '#33cc66', // Green\n            '#cc33cc', // Purple\n          ],\n        });\n      }\n    });\n  }\n\n  /**\n   * Convert hex color string to RGB array\n   * @param hex Hex color string (e.g. \"#ff0000\" or \"#f00\")\n   * @returns Array of RGB values [r, g, b] in range 0-1\n   */\n  private hexToRgb(hex: string): [number, number, number] {\n    // Remove # if present\n    hex = hex.replace(/^#/, '');\n\n    // Handle shorthand hex (e.g. #f00 -> #ff0000)\n    if (hex.length === 3) {\n      hex = hex\n        .split('')\n        .map(c => c + c)\n        .join('');\n    }\n\n    // Parse the hex values\n    const r = parseInt(hex.substring(0, 2), 16) / 255;\n    const g = parseInt(hex.substring(2, 4), 16) / 255;\n    const b = parseInt(hex.substring(4, 6), 16) / 255;\n\n    return [r, g, b];\n  }\n\n  /**\n   * Create a shader\n   */\n  private createShader(type: number, source: string): WebGLShader | undefined {\n    if (!this.gl) return undefined;\n\n    const shader = this.gl.createShader(type);\n    if (!shader) return undefined;\n\n    this.gl.shaderSource(shader, source);\n    this.gl.compileShader(shader);\n\n    if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {\n      console.error('An error occurred compiling the shaders:', this.gl.getShaderInfoLog(shader));\n      this.gl.deleteShader(shader);\n      return undefined;\n    }\n\n    return shader;\n  }\n\n  /**\n   * Create a shader program\n   */\n  private createShaderProgram(\n    name: string,\n    vertexShaderSource: string,\n    fragmentShaderSource: string\n  ): WebGLProgram | undefined {\n    if (!this.gl) return undefined;\n\n    const vertexShader = this.createShader(this.gl.VERTEX_SHADER, vertexShaderSource);\n    const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, fragmentShaderSource);\n\n    if (!vertexShader || !fragmentShader) return undefined;\n\n    const program = this.gl.createProgram();\n    if (!program) return undefined;\n\n    this.gl.attachShader(program, vertexShader);\n    this.gl.attachShader(program, fragmentShader);\n    this.gl.linkProgram(program);\n\n    if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {\n      console.error('Unable to initialize the shader program:', this.gl.getProgramInfoLog(program));\n      return undefined;\n    }\n\n    this.programs.set(name, program);\n    return program;\n  }\n\n  /**\n   * Render data visualization with WebGL shader\n   */\n  public renderDataVisualization(\n    config: DataVisualizationShaderConfig,\n    data: Float32Array,\n    positions: Position[],\n    width: number,\n    height: number\n  ): void {\n    if (!this.gl || !this.canvas) {\n      console.error('[WebGLShaderManager] WebGL context not initialized');\n      return;\n    }\n\n    // Update canvas size if needed\n    if (this.canvas.width !== width || this.canvas.height !== height) {\n      this.canvas.width = width;\n      this.canvas.height = height;\n      this.gl.viewport(0, 0, width, height);\n    }\n\n    // Get appropriate shader program\n    const programName = `data_${config.type}`;\n    let program = this.programs.get(programName);\n\n    // Create program if not exists\n    if (!program) {\n      program = this.createDataVisualizationShader(config);\n      if (!program) {\n        console.error(`[WebGLShaderManager] Failed to create shader for ${config.type}`);\n        return;\n      }\n    }\n\n    // Set up rendering\n    this.gl.useProgram(program);\n\n    // Clear canvas\n    this.gl.clearColor(0, 0, 0, 0);\n    this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n\n    // Prepare data\n    this.setupDataVisualizationBuffers(program, config, data, positions);\n\n    // Perform drawing\n    this.gl.drawArrays(this.gl.POINTS, 0, positions.length);\n  }\n\n  /**\n   * Create data visualization shader program\n   */\n  private createDataVisualizationShader(\n    config: DataVisualizationShaderConfig\n  ): WebGLProgram | undefined {\n    const vertexShader = this.getDataVisualizationVertexShader(config);\n    const fragmentShader = this.getDataVisualizationFragmentShader(config);\n\n    return this.createShaderProgram(`data_${config.type}`, vertexShader, fragmentShader);\n  }\n\n  /**\n   * Set up data visualization buffers and uniforms\n   */\n  private setupDataVisualizationBuffers(\n    program: WebGLProgram,\n    config: DataVisualizationShaderConfig,\n    data: Float32Array,\n    positions: Position[]\n  ): void {\n    if (!this.gl) return;\n\n    // Create position buffer\n    const positionBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, positionBuffer);\n\n    // Convert positions to flat array\n    const positionArray = new Float32Array(positions.length * 2);\n    positions.forEach((pos, index) => {\n      positionArray[index * 2] = pos.x;\n      positionArray[index * 2 + 1] = pos.y;\n    });\n\n    this.gl.bufferData(this.gl.ARRAY_BUFFER, positionArray, this.gl.STATIC_DRAW);\n\n    // Get attribute location\n    const positionLocation = this.gl.getAttribLocation(program, 'a_position');\n    this.gl.enableVertexAttribArray(positionLocation);\n    this.gl.vertexAttribPointer(positionLocation, 2, this.gl.FLOAT, false, 0, 0);\n\n    // Create data buffer\n    const dataBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, dataBuffer);\n    this.gl.bufferData(this.gl.ARRAY_BUFFER, data, this.gl.STATIC_DRAW);\n\n    // Get attribute location\n    const dataLocation = this.gl.getAttribLocation(program, 'a_data');\n    this.gl.enableVertexAttribArray(dataLocation);\n    this.gl.vertexAttribPointer(dataLocation, 1, this.gl.FLOAT, false, 0, 0);\n\n    // Set uniforms\n    this.setDataVisualizationUniforms(program, config);\n  }\n\n  /**\n   * Set data visualization uniforms\n   */\n  private setDataVisualizationUniforms(\n    program: WebGLProgram,\n    config: DataVisualizationShaderConfig\n  ): void {\n    if (!this.gl) return;\n\n    // Resolution\n    const resolution = config.resolution || [this.canvas?.width || 800, this.canvas?.height || 600];\n    const resolutionLocation = this.gl.getUniformLocation(program, 'u_resolution');\n    this.gl.uniform2f(resolutionLocation, resolution[0], resolution[1]);\n\n    // Colors\n    const colorCount = Math.min(config.colors.length, 5);\n    for (let i = 0; i < colorCount; i++) {\n      const color = this.hexToRgb(config.colors[i]);\n      const colorLocation = this.gl.getUniformLocation(program, `u_colors[${i}]`);\n      this.gl.uniform3f(colorLocation, color[0], color[1], color[2]);\n    }\n\n    // Color count\n    const colorCountLocation = this.gl.getUniformLocation(program, 'u_colorCount');\n    this.gl.uniform1i(colorCountLocation, colorCount);\n\n    // Intensity\n    const intensityLocation = this.gl.getUniformLocation(program, 'u_intensity');\n    this.gl.uniform1f(intensityLocation, config.intensity || 1.0);\n\n    // Time (for animations)\n    const timeLocation = this.gl.getUniformLocation(program, 'u_time');\n    this.gl.uniform1f(timeLocation, performance.now() / 1000.0);\n\n    // Animation speed\n    const speedLocation = this.gl.getUniformLocation(program, 'u_speed');\n    this.gl.uniform1f(speedLocation, config.animationSpeed || 1.0);\n\n    // Data range\n    const dataRange = config.dataRange || [0, 1];\n    const dataRangeLocation = this.gl.getUniformLocation(program, 'u_dataRange');\n    this.gl.uniform2f(dataRangeLocation, dataRange[0], dataRange[1]);\n\n    // Highlight range\n    const highlightRange = config.highlightRange || [0.7, 1.0];\n    const highlightRangeLocation = this.gl.getUniformLocation(program, 'u_highlightRange');\n    if (highlightRangeLocation !== null) {\n      this.gl.uniform2f(highlightRangeLocation, highlightRange[0], highlightRange[1]);\n    }\n\n    // Custom uniforms\n    if (config.customUniforms) {\n      Object.entries(config.customUniforms).forEach(([name, uniform]) => {\n        if (!this.gl) return;\n        const location = this.gl.getUniformLocation(program, name);\n        if (location) {\n          this.setUniform(location, uniform);\n        }\n      });\n    }\n  }\n\n  /**\n   * Set uniform value\n   */\n  private setUniform(location: WebGLUniformLocation | null, uniform: ShaderUniform): void {\n    const gl = this.gl;\n    if (!gl || !location) return;\n\n    switch (uniform.type) {\n      case 'float':\n        gl.uniform1f(location, uniform.value as number);\n        break;\n      case 'vec2':\n        gl.uniform2fv(location, uniform.value as number[]);\n        break;\n      case 'vec3':\n        gl.uniform3fv(location, uniform.value as number[]);\n        break;\n      case 'vec4':\n        gl.uniform4fv(location, uniform.value as number[]);\n        break;\n      case 'int':\n        gl.uniform1i(location, uniform.value as number);\n        break;\n      case 'bool':\n        gl.uniform1i(location, uniform.value ? 1 : 0);\n        break;\n      case 'sampler2D':\n        if (uniform.value instanceof WebGLTexture) {\n          gl.uniform1i(location, 0);\n          gl.activeTexture(gl.TEXTURE0);\n          gl.bindTexture(gl.TEXTURE_2D, uniform.value);\n        }\n        break;\n    }\n  }\n\n  /**\n   * Get vertex shader source for data visualization\n   */\n  private getDataVisualizationVertexShader(config: DataVisualizationShaderConfig): string {\n    // Use custom vertex shader if provided\n    if (config.type === DataVisualizationShaderType.CUSTOM && config.customVertexShader) {\n      return config.customVertexShader;\n    }\n\n    // Default vertex shader\n    return `\n      attribute vec2 a_position;\n      attribute float a_data;\n      \n      uniform vec2 u_resolution;\n      uniform float u_time;\n      uniform float u_speed;\n      uniform vec2 u_dataRange;\n      uniform vec2 u_highlightRange;\n      \n      varying float v_data;\n      varying vec2 v_position;\n      varying float v_time;\n      \n      void main() {\n        // Normalize data\n        v_data = (a_data - u_dataRange.x) / (u_dataRange.y - u_dataRange.x);\n        v_position = a_position;\n        v_time = u_time * u_speed;\n        \n        // Set point size based on data\n        float highlightFactor = 1.0;\n        \n        // Highlight range\n        if (v_data >= u_highlightRange.x && v_data <= u_highlightRange.y) {\n          // Pulsing effect for highlighted data\n          highlightFactor = 1.0 + 0.3 * sin(u_time * 3.0);\n        }\n        \n        // Calculate point size \n        float baseSize = 1.0;\n        ${this.getPointSizeShaderCode(config)}\n        \n        // Position conversion\n        vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;\n        gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\n      }\n    `;\n  }\n\n  /**\n   * Get fragment shader source for data visualization\n   */\n  private getDataVisualizationFragmentShader(config: DataVisualizationShaderConfig): string {\n    // Use custom fragment shader if provided\n    if (config.type === DataVisualizationShaderType.CUSTOM && config.customFragmentShader) {\n      return config.customFragmentShader;\n    }\n\n    // Default fragment shader\n    return `\n      precision mediump float;\n      \n      uniform vec3 u_colors[5];\n      uniform int u_colorCount;\n      uniform float u_intensity;\n      uniform float u_time;\n      uniform vec2 u_highlightRange;\n      \n      varying float v_data;\n      varying vec2 v_position;\n      varying float v_time;\n      \n      // Helper function to interpolate colors\n      vec3 getColor(float value) {\n        if (u_colorCount == 1) return u_colors[0];\n        \n        float indexFloat = value * float(u_colorCount - 1);\n        int index = int(floor(indexFloat));\n        float t = fract(indexFloat);\n        \n        if (index >= u_colorCount - 1) {\n          return u_colors[u_colorCount - 1];\n        }\n        \n        return mix(u_colors[index], u_colors[index + 1], t);\n      }\n      \n      void main() {\n        // Get base color from data value\n        vec3 color = getColor(v_data);\n        float alpha = u_intensity;\n        \n        ${this.getFragmentShaderEffects(config)}\n        \n        // Apply highlight effect if in range\n        if (v_data >= u_highlightRange.x && v_data <= u_highlightRange.y) {\n          // Pulse effect\n          float pulse = 0.5 + 0.5 * sin(u_time * 3.0);\n          \n          // Brighten color \n          color = mix(color, vec3(1.0), pulse * 0.3);\n          \n          // Increase opacity\n          alpha = mix(alpha, 1.0, pulse * 0.5);\n          \n          // Add glow based on distance from center of point\n          float dist = length(gl_PointCoord - vec2(0.5));\n          float glow = smoothstep(0.5, 0.0, dist);\n          color += glow * pulse * 0.3;\n        }\n        \n        gl_FragColor = vec4(color, alpha);\n      }\n    `;\n  }\n\n  /**\n   * Get point size shader code based on visualization type\n   */\n  private getPointSizeShaderCode(config: DataVisualizationShaderConfig): string {\n    let code = '';\n\n    switch (config.type) {\n      case DataVisualizationShaderType.CUSTOM:\n        code = `gl_PointSize = max(baseSize, 8.0) * highlightFactor;`;\n        break;\n\n      case DataVisualizationShaderType.HEATMAP:\n        code = `gl_PointSize = max(baseSize, 10.0) * highlightFactor;`;\n        break;\n\n      case DataVisualizationShaderType.CONTOUR:\n        code = `\n          // For contour, size based on data thresholds\n          float thresholdFactor = abs(fract(v_data * 10.0) - 0.5) * 2.0;\n          gl_PointSize = mix(baseSize, 12.0, thresholdFactor) * highlightFactor;\n        `;\n        break;\n\n      case DataVisualizationShaderType.POINT_CLUSTER:\n        code = `\n          // For clustering, vary size by data value\n          gl_PointSize = mix(baseSize, 15.0, v_data) * highlightFactor;\n        `;\n        break;\n\n      case DataVisualizationShaderType.HIGHLIGHT:\n        code = `\n          // For highlighting, emphasize highlighted ranges\n          float inHighlight = (v_data >= u_highlightRange.x && v_data <= u_highlightRange.y) ? 1.0 : 0.0;\n          gl_PointSize = mix(baseSize, 20.0, inHighlight) * highlightFactor;\n        `;\n        break;\n\n      case DataVisualizationShaderType.DENSITY:\n        code = `\n          // For density maps, size consistent\n          gl_PointSize = 8.0 * highlightFactor;\n        `;\n        break;\n\n      case DataVisualizationShaderType.FLOW:\n        code = `\n          // For flow visualization, animate size with time\n          float flowPulse = 0.7 + 0.3 * sin(v_time + v_data * 10.0);\n          gl_PointSize = mix(baseSize, 12.0, v_data) * flowPulse * highlightFactor;\n        `;\n        break;\n\n      case DataVisualizationShaderType.TRANSITION:\n        code = `\n          float dist = length(gl_PointCoord - vec2(0.5));\n          float transitionFactor = 0.5 + 0.5 * sin(v_time * 2.0 + v_data * 5.0);\n          \n          alpha *= smoothstep(0.5, 0.0, dist) * mix(0.5, 1.0, transitionFactor);\n          color = mix(color, color * vec3(1.2, 1.1, 0.9), transitionFactor);\n          \n          if (transitionFactor > 0.7) {\n            float glow = smoothstep(0.5, 0.0, dist) * (transitionFactor - 0.7) * 3.0;\n            color += glow * vec3(1.0, 0.9, 0.7);\n          }\n        `;\n        break;\n\n      default:\n        code = `gl_PointSize = max(baseSize, 8.0) * highlightFactor;`;\n    }\n\n    return code;\n  }\n\n  /**\n   * Get fragment shader effects based on visualization type\n   */\n  private getFragmentShaderEffects(config: DataVisualizationShaderConfig): string {\n    let effects = '';\n\n    switch (config.type) {\n      case DataVisualizationShaderType.CUSTOM:\n        effects = '';\n        break;\n\n      case DataVisualizationShaderType.HEATMAP:\n        effects = `\n          float dist = length(gl_PointCoord - vec2(0.5));\n          float fadeEdge = smoothstep(0.5, 0.35, dist);\n          alpha *= fadeEdge;\n        `;\n        break;\n\n      case DataVisualizationShaderType.CONTOUR:\n        effects = `\n          float contourBands = abs(fract(v_data * 10.0) - 0.5) * 2.0;\n          float isContour = step(0.8, contourBands);\n          alpha *= mix(0.3, 1.0, isContour);\n          \n          float dist = length(gl_PointCoord - vec2(0.5));\n          alpha *= smoothstep(0.5, 0.0, dist);\n        `;\n        break;\n\n      case DataVisualizationShaderType.POINT_CLUSTER:\n        effects = `\n          float dist = length(gl_PointCoord - vec2(0.5));\n          float center = smoothstep(0.5, 0.1, dist);\n          alpha *= center;\n          \n          if (v_data > 0.7) {\n            float glow = smoothstep(0.5, 0.0, dist) * 0.5;\n            color += glow * vec3(1.0, 0.8, 0.2);\n          }\n        `;\n        break;\n\n      case DataVisualizationShaderType.HIGHLIGHT:\n        effects = `\n          float dist = length(gl_PointCoord - vec2(0.5));\n          alpha *= smoothstep(0.5, 0.0, dist);\n          \n          if (v_data >= u_highlightRange.x && v_data <= u_highlightRange.y) {\n            float glow = smoothstep(1.0, 0.0, dist * 2.0) * 0.7;\n            color += glow * vec3(1.0, 0.9, 0.5);\n          }\n        `;\n        break;\n\n      case DataVisualizationShaderType.DENSITY:\n        effects = `\n          float dist = length(gl_PointCoord - vec2(0.5));\n          alpha *= smoothstep(0.5, 0.0, dist) * v_data;\n          \n          color *= 0.8 + 0.2 * v_data;\n        `;\n        break;\n\n      case DataVisualizationShaderType.FLOW:\n        effects = `\n          float dist = length(gl_PointCoord - vec2(0.5));\n          \n          vec2 dir = normalize(gl_PointCoord - vec2(0.5));\n          float dirFactor = 0.5 + 0.5 * dot(dir, vec2(cos(v_time), sin(v_time)));\n          \n          alpha *= smoothstep(0.5, 0.0, dist) * dirFactor;\n          color *= 0.8 + 0.2 * dirFactor;\n          \n          float streak = smoothstep(0.9, 0.0, abs(dot(dir, vec2(cos(v_time), sin(v_time)))));\n          color += streak * 0.2 * vec3(1.0, 0.9, 0.7);\n        `;\n        break;\n\n      case DataVisualizationShaderType.TRANSITION:\n        effects = `\n          float dist = length(gl_PointCoord - vec2(0.5));\n          float transitionFactor = 0.5 + 0.5 * sin(v_time * 2.0 + v_data * 5.0);\n          \n          alpha *= smoothstep(0.5, 0.0, dist) * mix(0.5, 1.0, transitionFactor);\n          color = mix(color, color * vec3(1.2, 1.1, 0.9), transitionFactor);\n          \n          if (transitionFactor > 0.7) {\n            float glow = smoothstep(0.5, 0.0, dist) * (transitionFactor - 0.7) * 3.0;\n            color += glow * vec3(1.0, 0.9, 0.7);\n          }\n        `;\n        break;\n\n      default:\n        effects = '';\n    }\n\n    return effects;\n  }\n\n  /**\n   * Start animation loop for continuous rendering\n   * @param renderCallback (...args: unknown[]) => unknown to call on each animation frame\n   */\n  public startAnimationLoop(renderCallback: () => void): void {\n    // Stop any existing animation loop\n    this.stopAnimationLoop();\n\n    // Animation frame handler\n    const animate = (timestamp: number) => {\n      // Calculate delta time\n      const deltaTime = this._lastTimestamp ? timestamp - this._lastTimestamp : 0;\n      this._lastTimestamp = timestamp;\n\n      // Call render callback\n      renderCallback();\n\n      // Request next frame\n      this.animationFrame = requestAnimationFrame(animate);\n    };\n\n    // Start the animation loop\n    this.animationFrame = requestAnimationFrame(animate);\n  }\n\n  /**\n   * Stop the animation loop\n   */\n  public stopAnimationLoop(): void {\n    if (this.animationFrame !== null) {\n      cancelAnimationFrame(this.animationFrame);\n      this.animationFrame = null;\n    }\n  }\n\n  /**\n   * Dispose of WebGL resources\n   */\n  public dispose(): void {\n    // Stop any running animation\n    this.stopAnimationLoop();\n\n    // Clean up WebGL resources\n    if (this.gl) {\n      // Delete shaders\n      this.shaders.forEach(shader => {\n        this.gl?.deleteShader(shader);\n      });\n      this.shaders.clear();\n\n      // Delete programs\n      this.programs.forEach(program => {\n        this.gl?.deleteProgram(program);\n      });\n      this.programs.clear();\n\n      // Delete textures\n      this.textures.forEach(texture => {\n        this.gl?.deleteTexture(texture);\n      });\n      this.textures.clear();\n\n      // Delete framebuffers\n      this.framebuffers.forEach(framebuffer => {\n        this.gl?.deleteFramebuffer(framebuffer);\n      });\n      this.framebuffers.clear();\n\n      // Reset context\n      this.gl = null;\n      this.canvas = null;\n    }\n\n    console.warn('[WebGLShaderManager] Resources disposed');\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/patterns/Singleton.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_T' is defined but never used. Allowed unused vars must match /^ignored|^temp/u.","line":31,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":31,"endColumn":35}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Generic Singleton implementation that can be extended by services and managers.\n * Provides a common pattern for singleton instances throughout the application.\n *\n * The type parameter _T represents the specific singleton class that extends this base class.\n * This allows for type-safe getInstance() method that returns the correct type.\n *\n * @example\n * ```typescript\n * class MyService extends Singleton<MyService> {\n *   private constructor() {\n *     super();\n *     // initialization code\n *   }\n *\n *   public doSomething(): void {\n *     // implementation\n *   }\n *\n *   // Override getInstance with proper return type\n *   public static getInstance(): MyService {\n *     return Singleton.getInstance.call(this);\n *   }\n * }\n *\n * // Usage:\n * const service = MyService.getInstance();\n * service.doSomething();\n * ```\n */\nexport abstract class Singleton<_T> {\n  // Use Singleton<object> to allow storing any singleton type\n  private static instances = new Map<string, Singleton<object>>();\n\n  protected constructor() {\n    // Protected constructor to prevent direct instantiation\n  }\n\n  /**\n   * Gets the singleton instance of the class.\n   * Creates a new instance if one doesn't exist yet.\n   */\n  public static getInstance<T extends Singleton<T>>(this: new () => T): T {\n    const className = this.name;\n    if (!Singleton.instances.has(className)) {\n      Singleton.instances.set(className, new this());\n    }\n    return Singleton.instances.get(className) as T;\n  }\n\n  /**\n   * Initializes the singleton instance.\n   * This method should be overridden by subclasses that need initialization logic.\n   */\n  public async initialize?(): Promise<void>;\n\n  /**\n   * Disposes of resources used by the singleton instance.\n   * This method should be overridden by subclasses that need cleanup logic.\n   */\n  public async dispose?(): Promise<void>;\n\n  /**\n   * Resets the singleton instance.\n   * This is primarily useful for testing purposes.\n   */\n  public static resetInstance(className: string): void {\n    if (Singleton.instances.has(className)) {\n      const instance = Singleton.instances.get(className);\n      if (instance && typeof instance.dispose === 'function') {\n        instance.dispose();\n      }\n      Singleton.instances.delete(className);\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/registry/ServiceRegistry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/services/BaseService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'context' is defined but never used.","line":97,"column":29,"nodeType":null,"messageId":"unusedVar","endLine":97,"endColumn":36}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ErrorType } from '../../services/ErrorLoggingService';\nimport { Singleton } from '../patterns/Singleton';\n\n/**\n * Interface for service metadata\n */\nexport interface ServiceMetadata {\n  name: string;\n  version: string;\n  status: 'initializing' | 'ready' | 'error' | 'disposed';\n  lastError?: {\n    type: ErrorType;\n    message: string;\n    timestamp: number;\n  };\n  metrics?: Record<string, number>;\n}\n\n/**\n * Base interface that all services should implement\n */\nexport interface BaseService {\n  /**\n   * Initialize the service with optional dependencies\n   */\n  initialize(dependencies?: Record<string, unknown>): Promise<void>;\n\n  /**\n   * Dispose of any resources used by the service\n   */\n  dispose(): Promise<void>;\n\n  /**\n   * Get metadata about the service's current state\n   */\n  getMetadata(): ServiceMetadata;\n\n  /**\n   * Check if the service is ready to handle requests\n   */\n  isReady(): boolean;\n\n  /**\n   * Handle errors that occur within the service\n   */\n  handleError(error: Error, context?: Record<string, unknown>): void;\n}\n\n/**\n * Abstract base class that provides common service functionality\n * Extends the Singleton pattern to ensure only one instance exists\n */\nexport abstract class AbstractBaseService<T extends AbstractBaseService<T>>\n  extends Singleton<T>\n  implements BaseService\n{\n  protected metadata: ServiceMetadata;\n\n  public constructor(name: string, version: string) {\n    super();\n    this.metadata = {\n      name,\n      version,\n      status: 'initializing',\n    };\n  }\n\n  async initialize(dependencies?: Record<string, unknown>): Promise<void> {\n    try {\n      await this.onInitialize(dependencies);\n      this.metadata.status = 'ready';\n    } catch (error) {\n      this.metadata.status = 'error';\n      this.handleError(error as Error);\n      throw error;\n    }\n  }\n\n  async dispose(): Promise<void> {\n    try {\n      await this.onDispose();\n      this.metadata.status = 'disposed';\n    } catch (error) {\n      this.handleError(error as Error);\n      throw error;\n    }\n  }\n\n  getMetadata(): ServiceMetadata {\n    return { ...this.metadata };\n  }\n\n  isReady(): boolean {\n    return this.metadata?.status === 'ready';\n  }\n\n  handleError(error: Error, context?: Record<string, unknown>): void {\n    this.metadata.lastError = {\n      type: ErrorType.UNKNOWN,\n      message: error.message,\n      timestamp: Date.now(),\n    };\n    // Subclasses should override this to provide custom error handling\n  }\n\n  protected abstract onInitialize(dependencies?: Record<string, unknown>): Promise<void>;\n  protected abstract onDispose(): Promise<void>;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/services/ServiceRegistry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/visualization/ChartCoordinationManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/lib/visualization/ParticleSystem.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'id' is defined but never used.","line":466,"column":36,"nodeType":null,"messageId":"unusedVar","endLine":466,"endColumn":38}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Position } from '../../types/core/Position';\n\n/**\n * Particle animation easing functions\n */\nexport enum EasingType {\n  LINEAR = 'linear',\n  EASE_IN = 'easeIn',\n  EASE_OUT = 'easeOut',\n  EASE_IN_OUT = 'easeInOut',\n  BOUNCE = 'bounce',\n  ELASTIC = 'elastic',\n  BACK = 'back',\n}\n\n/**\n * Easing function type\n */\nexport type EasingFunction = (progress: number) => number;\n\n/**\n * Path type for particle movement\n */\nexport enum ParticlePath {\n  LINEAR = 'linear',\n  CURVED = 'curved',\n  SPIRAL = 'spiral',\n  BEZIER = 'bezier',\n  WAVE = 'wave',\n  RANDOM = 'random',\n}\n\n/**\n * Particle blend mode\n */\nexport enum ParticleBlendMode {\n  NORMAL = 'normal',\n  ADD = 'add',\n  MULTIPLY = 'multiply',\n  SCREEN = 'screen',\n}\n\n/**\n * Basic particle properties\n */\nexport interface Particle {\n  id: string;\n  position: Position;\n  prevPosition?: Position;\n  targetPosition?: Position;\n  startPosition?: Position;\n  velocity: { x: number; y: number };\n  acceleration: { x: number; y: number };\n  size: number;\n  startSize?: number;\n  targetSize?: number;\n  color: string;\n  startColor?: string;\n  targetColor?: string;\n  opacity: number;\n  startOpacity?: number;\n  targetOpacity?: number;\n  rotation: number;\n  startRotation?: number;\n  targetRotation?: number;\n  life: number;\n  maxLife: number;\n  active: boolean;\n  path?: ParticlePath;\n  pathParams?: Record<string, number>;\n  easing?: EasingFunction | EasingType;\n  blendMode?: ParticleBlendMode;\n  group?: string;\n  data?: Record<string, unknown>;\n}\n\n/**\n * Particle emitter configuration\n */\nexport interface ParticleEmitterConfig {\n  position: Position;\n  rate: number;\n  burstCount?: number;\n  emitRadius?: number;\n  direction?: number; // Angle in radians\n  spread?: number; // Angle in radians\n  minLife?: number;\n  maxLife?: number;\n  minSize?: number;\n  maxSize?: number;\n  minVelocity?: number;\n  maxVelocity?: number;\n  colors?: string[];\n  minOpacity?: number;\n  maxOpacity?: number;\n  gravity?: { x: number; y: number };\n  path?: ParticlePath;\n  pathParams?: Record<string, number>;\n  easing?: EasingFunction | EasingType;\n  blendMode?: ParticleBlendMode;\n  group?: string;\n}\n\n/**\n * Transition configuration for moving particles between data states\n */\nexport interface ParticleTransitionConfig {\n  /**\n   * Optional transition ID\n   */\n  id?: string;\n\n  /**\n   * Source data points with positions\n   */\n  sourceData?: DataPoint[];\n\n  /**\n   * Target data points with positions\n   */\n  targetData?: DataPoint[];\n\n  /**\n   * Transition duration in milliseconds\n   */\n  duration: number;\n\n  /**\n   * Easing function or type for the transition\n   */\n  easing?: EasingFunction | EasingType;\n\n  /**\n   * Path type for particle movement\n   */\n  path?: ParticlePath;\n\n  /**\n   * Additional path parameters\n   */\n  pathParams?: Record<string, number>;\n\n  /**\n   * Delay between individual particle transitions in milliseconds\n   */\n  staggerDelay?: number;\n\n  /**\n   * Whether to transition colors\n   */\n  transitionColors?: boolean;\n\n  /**\n   * Whether to transition sizes\n   */\n  transitionSizes?: boolean;\n\n  /**\n   * Whether to transition opacity\n   */\n  transitionOpacity?: boolean;\n\n  /**\n   * Whether to reverse the transition\n   */\n  reverse?: boolean;\n\n  /**\n   * Callback when transition is complete\n   */\n  onComplete?: () => void;\n\n  /**\n   * Callback when transition is updated\n   */\n  onUpdate?: (progress: number) => void;\n}\n\n/**\n * Data point for visualization\n */\nexport interface DataPoint {\n  id?: string;\n  x: number;\n  y: number;\n  value: number;\n  size?: number;\n  color?: string;\n  opacity?: number;\n  group?: string;\n  active?: boolean;\n  [key: string]: unknown;\n}\n\n/**\n * Manages a particle system for animated data transitions\n */\nexport class ParticleSystem {\n  private particles: Map<string, Particle> = new Map();\n  private emitters: Map<string, ParticleEmitterConfig> = new Map();\n  private lastFrameTime: number = 0;\n  private animationFrame: number | null = null;\n  private transitionConfigs: Map<string, ParticleTransitionConfig> = new Map();\n  private transitionTimers: Map<string, number> = new Map();\n  private transitionProgress: Map<string, number> = new Map();\n\n  /**\n   * Create a new particle system\n   */\n  constructor() {\n    this.lastFrameTime = performance.now();\n  }\n\n  /**\n   * Add a particle to the system\n   */\n  public addParticle(particle: Omit<Particle, 'id'>): string {\n    const id = `particle-${Math.random().toString(36).substring(2, 9)}`;\n    this.particles.set(id, {\n      ...particle,\n      id,\n    });\n    return id;\n  }\n\n  /**\n   * Remove a particle from the system\n   */\n  public removeParticle(id: string): boolean {\n    return this.particles.delete(id);\n  }\n\n  /**\n   * Add a particle emitter\n   */\n  public addEmitter(config: ParticleEmitterConfig): string {\n    const id = `emitter-${Math.random().toString(36).substring(2, 9)}`;\n    this.emitters.set(id, config);\n    return id;\n  }\n\n  /**\n   * Remove a particle emitter\n   */\n  public removeEmitter(id: string): boolean {\n    return this.emitters.delete(id);\n  }\n\n  /**\n   * Start the animation loop\n   */\n  public start(): void {\n    if (this.animationFrame !== null) {\n      return;\n    }\n\n    this.lastFrameTime = performance.now();\n    this.animationLoop();\n  }\n\n  /**\n   * Stop the animation loop\n   */\n  public stop(): void {\n    if (this.animationFrame !== null) {\n      cancelAnimationFrame(this.animationFrame);\n      this.animationFrame = null;\n    }\n  }\n\n  /**\n   * Clear all particles\n   */\n  public clear(): void {\n    this.particles.clear();\n  }\n\n  /**\n   * Set up a transition between data states\n   */\n  public setupTransition(id: string, config: ParticleTransitionConfig): void {\n    this.transitionConfigs.set(id, config);\n    this.transitionProgress.set(id, 0);\n\n    // Create particles for transition if needed\n    if (config.sourceData && config.targetData) {\n      this.createParticlesForTransition(id, config);\n    }\n  }\n\n  /**\n   * Start a transition between data states\n   */\n  public startTransition(id: string): void {\n    const config = this.transitionConfigs.get(id);\n    if (!config) {\n      console.warn(`No transition config found with id: ${id}`);\n      return;\n    }\n\n    // Start the transition timer\n    const startTime = performance.now();\n    this.transitionTimers.set(id, startTime);\n\n    // Ensure animation is running\n    this.start();\n  }\n\n  /**\n   * Stop a transition\n   */\n  public stopTransition(id: string): void {\n    this.transitionTimers.delete(id);\n  }\n\n  /**\n   * Create particles for a data transition\n   */\n  private createParticlesForTransition(\n    transitionId: string,\n    config: ParticleTransitionConfig\n  ): void {\n    if (!config.sourceData || !config.targetData) {\n      return;\n    }\n\n    // Clear any existing particles for this transition\n    this.particles.forEach((particle, id) => {\n      if (particle.group === transitionId) {\n        this.particles.delete(id);\n      }\n    });\n\n    // Determine how to map source to target\n    const isEqualSize = config.sourceData.length === config.targetData.length;\n\n    if (isEqualSize) {\n      // Direct mapping when source and target have same number of points\n      config.sourceData.forEach((sourcePoint, index) => {\n        const targetPoint = config.targetData![index];\n        this.createTransitionParticle(sourcePoint, targetPoint, transitionId, config);\n      });\n    } else if (config.sourceData.length < config.targetData.length) {\n      // Source has fewer points, need to generate additional particles\n      config.sourceData.forEach((sourcePoint, index) => {\n        const targetPoint = config.targetData![index % config.targetData!.length];\n        this.createTransitionParticle(sourcePoint, targetPoint, transitionId, config);\n      });\n\n      // Create additional particles starting from appropriate source points\n      for (let i = config.sourceData.length; i < config.targetData.length; i++) {\n        const sourceIndex = i % config.sourceData.length;\n        const sourcePoint = config.sourceData[sourceIndex];\n        const targetPoint = config.targetData[i];\n        this.createTransitionParticle(sourcePoint, targetPoint, transitionId, config);\n      }\n    } else {\n      // Target has fewer points, some source particles will converge\n      config.sourceData.forEach((sourcePoint, index) => {\n        const targetPoint = config.targetData![index % config.targetData!.length];\n        this.createTransitionParticle(sourcePoint, targetPoint, transitionId, config);\n      });\n    }\n  }\n\n  /**\n   * Create a single transition particle\n   */\n  private createTransitionParticle(\n    sourcePoint: DataPoint,\n    targetPoint: DataPoint,\n    transitionId: string,\n    config: ParticleTransitionConfig\n  ): string {\n    const sourceColor = sourcePoint.color || '#ffffff';\n    const targetColor = targetPoint.color || '#ffffff';\n    const sourceSize = sourcePoint.size || 10;\n    const targetSize = targetPoint.size || 10;\n    const sourceOpacity = sourcePoint.opacity !== undefined ? sourcePoint.opacity : 1;\n    const targetOpacity = targetPoint.opacity !== undefined ? targetPoint.opacity : 1;\n\n    return this.addParticle({\n      position: { x: sourcePoint.x, y: sourcePoint.y },\n      startPosition: { x: sourcePoint.x, y: sourcePoint.y },\n      targetPosition: { x: targetPoint.x, y: targetPoint.y },\n      velocity: { x: 0, y: 0 },\n      acceleration: { x: 0, y: 0 },\n      size: sourceSize,\n      startSize: sourceSize,\n      targetSize: targetSize,\n      color: sourceColor,\n      startColor: sourceColor,\n      targetColor: targetColor,\n      opacity: sourceOpacity,\n      startOpacity: sourceOpacity,\n      targetOpacity: targetOpacity,\n      rotation: 0,\n      life: 1,\n      maxLife: 1,\n      active: true,\n      path: config.path || ParticlePath.LINEAR,\n      easing: config.easing || this.getEasingFunction(EasingType.EASE_IN_OUT),\n      pathParams: config.pathParams,\n      group: transitionId,\n      data: {\n        sourcePoint,\n        targetPoint,\n        startTime: performance.now(),\n        staggerDelay: config.staggerDelay ?? 0,\n        transitionStarted: false,\n      },\n    });\n  }\n\n  /**\n   * Main animation loop\n   */\n  private animationLoop(): void {\n    const currentTime = performance.now();\n    const deltaTime = (currentTime - this.lastFrameTime) / 1000; // in seconds\n    this.lastFrameTime = currentTime;\n\n    // Update transitions\n    this.updateTransitions(currentTime);\n\n    // Update emitters\n    this.updateEmitters(deltaTime);\n\n    // Update particles\n    this.updateParticles(deltaTime);\n\n    // Schedule next frame\n    this.animationFrame = requestAnimationFrame(() => this.animationLoop());\n  }\n\n  /**\n   * Update particle transitions\n   */\n  private updateTransitions(currentTime: number): void {\n    this.transitionTimers.forEach((startTime, id) => {\n      const config = this.transitionConfigs.get(id);\n      if (!config) return;\n\n      // Calculate progress\n      const elapsedTime = currentTime - startTime;\n      const progress = Math.min(1, elapsedTime / config.duration);\n\n      // Store progress\n      this.transitionProgress.set(id, progress);\n\n      // Call update callback\n      config.onUpdate?.(progress);\n\n      // Check if transition is complete\n      if (progress >= 1) {\n        this.transitionTimers.delete(id);\n        config.onComplete?.();\n      }\n    });\n  }\n\n  /**\n   * Update particle emitters\n   */\n  private updateEmitters(deltaTime: number): void {\n    this.emitters.forEach((config, id) => {\n      // Calculate number of particles to emit\n      const emitCount = config.burstCount || Math.floor(config.rate * deltaTime);\n\n      // Emit particles\n      for (let i = 0; i < emitCount; i++) {\n        this.emitParticle(config);\n      }\n    });\n  }\n\n  /**\n   * Emit a single particle from an emitter\n   */\n  private emitParticle(config: ParticleEmitterConfig): string {\n    // Randomize position within emit radius\n    const angle = Math.random() * Math.PI * 2;\n    const radius = Math.random() * (config.emitRadius ?? 0);\n    const position = {\n      x: config.position.x + Math.cos(angle) * radius,\n      y: config.position.y + Math.sin(angle) * radius,\n    };\n\n    // Randomize velocity\n    const direction = (config.direction ?? 0) + (Math.random() - 0.5) * (config.spread ?? 0);\n    const speed =\n      config.minVelocity !== undefined && config.maxVelocity !== undefined\n        ? config.minVelocity + Math.random() * (config.maxVelocity - config.minVelocity)\n        : 50;\n\n    const velocity = {\n      x: Math.cos(direction) * speed,\n      y: Math.sin(direction) * speed,\n    };\n\n    // Randomize life\n    const life =\n      config.minLife !== undefined && config.maxLife !== undefined\n        ? config.minLife + Math.random() * (config.maxLife - config.minLife)\n        : 1;\n\n    // Randomize size\n    const size =\n      config.minSize !== undefined && config.maxSize !== undefined\n        ? config.minSize + Math.random() * (config.maxSize - config.minSize)\n        : 10;\n\n    // Randomize color\n    const color =\n      config.colors && config.colors.length > 0\n        ? config.colors[Math.floor(Math.random() * config.colors.length)]\n        : '#ffffff';\n\n    // Randomize opacity\n    const opacity =\n      config.minOpacity !== undefined && config.maxOpacity !== undefined\n        ? config.minOpacity + Math.random() * (config.maxOpacity - config.minOpacity)\n        : 1;\n\n    // Create particle\n    return this.addParticle({\n      position,\n      velocity,\n      acceleration: config.gravity || { x: 0, y: 0 },\n      size,\n      color,\n      opacity,\n      rotation: Math.random() * Math.PI * 2,\n      life,\n      maxLife: life,\n      active: true,\n      path: config.path,\n      pathParams: config.pathParams,\n      easing: config.easing,\n      blendMode: config.blendMode,\n      group: config.group,\n    });\n  }\n\n  /**\n   * Update all particles\n   */\n  private updateParticles(deltaTime: number): void {\n    this.particles.forEach((particle, id) => {\n      if (!particle.active) return;\n\n      // Handle transition particles\n      if (particle.group && this.transitionTimers.has(particle.group)) {\n        this.updateTransitionParticle(particle, this.transitionProgress.get(particle.group) ?? 0);\n      } else {\n        // Handle regular particles\n        this.updateRegularParticle(particle, deltaTime);\n      }\n\n      // Remove dead particles\n      if (particle.life <= 0) {\n        this.particles.delete(id);\n      }\n    });\n  }\n\n  /**\n   * Update a transition particle\n   */\n  private updateTransitionParticle(particle: Particle, transitionProgress: number): void {\n    if (!particle.startPosition || !particle.targetPosition) return;\n\n    const data = particle.data as Record<string, unknown>;\n    const staggerDelay = (data.staggerDelay as number) ?? 0;\n\n    // Handle staggered start\n    if (!data.transitionStarted) {\n      const elapsedSinceStart = performance.now() - (data.startTime as number);\n      if (elapsedSinceStart < staggerDelay) {\n        return;\n      }\n      data.transitionStarted = true;\n    }\n\n    // Apply easing\n    const easedProgress = this.applyEasing(\n      transitionProgress,\n      particle.easing || this.getEasingFunction(EasingType.LINEAR)\n    );\n\n    // Update position based on path type\n    this.updateParticlePosition(particle, easedProgress);\n\n    // Update size\n    if (particle.startSize !== undefined && particle.targetSize !== undefined) {\n      particle.size =\n        particle.startSize + (particle.targetSize - particle.startSize) * easedProgress;\n    }\n\n    // Update opacity\n    if (particle.startOpacity !== undefined && particle.targetOpacity !== undefined) {\n      particle.opacity =\n        particle.startOpacity + (particle.targetOpacity - particle.startOpacity) * easedProgress;\n    }\n\n    // Update color\n    if (particle.startColor && particle.targetColor) {\n      particle.color = this.interpolateColor(\n        particle.startColor,\n        particle.targetColor,\n        easedProgress\n      );\n    }\n\n    // Store previous position for trail effects\n    particle.prevPosition = { ...particle.position };\n  }\n\n  /**\n   * Update a regular particle\n   */\n  private updateRegularParticle(particle: Particle, deltaTime: number): void {\n    // Update velocity\n    particle.velocity.x += particle.acceleration.x * deltaTime;\n    particle.velocity.y += particle.acceleration.y * deltaTime;\n\n    // Store previous position for trail effects\n    particle.prevPosition = { ...particle.position };\n\n    // Update position\n    particle.position.x += particle.velocity.x * deltaTime;\n    particle.position.y += particle.velocity.y * deltaTime;\n\n    // Update life\n    particle.life -= deltaTime;\n\n    // Update opacity based on life\n    const lifeRatio = Math.max(0, particle.life / particle.maxLife);\n    particle.opacity = lifeRatio;\n  }\n\n  /**\n   * Update particle position based on path type\n   */\n  private updateParticlePosition(particle: Particle, progress: number): void {\n    const start = particle.startPosition || { x: 0, y: 0 };\n    const end = particle.targetPosition || { x: 0, y: 0 };\n    let position: Position;\n\n    switch (particle.path || ParticlePath.LINEAR) {\n      case ParticlePath.CURVED:\n        position = this.calculateCurvedPath(start, end, progress);\n        break;\n\n      case ParticlePath.SPIRAL:\n        position = this.calculateSpiralPath(start, end, progress, particle.pathParams?.turns);\n        break;\n\n      case ParticlePath.BEZIER:\n        position = this.calculateBezierPath(start, end, progress);\n        break;\n\n      case ParticlePath.WAVE:\n        position = this.calculateWavePath(\n          start,\n          end,\n          progress,\n          particle.pathParams?.amplitude,\n          particle.pathParams?.frequency\n        );\n        break;\n\n      case ParticlePath.RANDOM:\n        position = this.calculateRandomPath(\n          start,\n          end,\n          progress,\n          particle,\n          particle.pathParams?.jitter\n        );\n        break;\n\n      case ParticlePath.LINEAR:\n      default:\n        position = {\n          x: start.x + (end.x - start.x) * progress,\n          y: start.y + (end.y - start.y) * progress,\n        };\n    }\n\n    particle.position = position;\n  }\n\n  /**\n   * Calculate curved path position\n   */\n  private calculateCurvedPath(start: Position, end: Position, progress: number): Position {\n    const controlX = (start.x + end.x) / 2;\n    const controlY = Math.min(start.y, end.y) - Math.abs(end.x - start.x) * 0.2;\n\n    const t = progress;\n    const invT = 1 - t;\n\n    return {\n      x: invT * invT * start.x + 2 * invT * t * controlX + t * t * end.x,\n      y: invT * invT * start.y + 2 * invT * t * controlY + t * t * end.y,\n    };\n  }\n\n  /**\n   * Calculate spiral path position\n   */\n  private calculateSpiralPath(\n    start: Position,\n    end: Position,\n    progress: number,\n    turns = 2\n  ): Position {\n    const angle = progress * turns * Math.PI * 2;\n    const radius =\n      (1 - progress) * Math.min(Math.abs(end.x - start.x), Math.abs(end.y - start.y)) * 0.2;\n\n    return {\n      x: start.x + (end.x - start.x) * progress + Math.cos(angle) * radius,\n      y: start.y + (end.y - start.y) * progress + Math.sin(angle) * radius,\n    };\n  }\n\n  /**\n   * Calculate bezier path position\n   */\n  private calculateBezierPath(start: Position, end: Position, progress: number): Position {\n    const cp1x = start.x + (end.x - start.x) * 0.3;\n    const cp1y = start.y - Math.abs(end.y - start.y) * 0.3;\n    const cp2x = start.x + (end.x - start.x) * 0.7;\n    const cp2y = end.y + Math.abs(end.y - start.y) * 0.3;\n\n    const t1 = progress;\n    const t2 = t1 * t1;\n    const t3 = t2 * t1;\n    const invT1 = 1 - t1;\n    const invT2 = invT1 * invT1;\n    const invT3 = invT2 * invT1;\n\n    return {\n      x: invT3 * start.x + 3 * invT2 * t1 * cp1x + 3 * invT1 * t2 * cp2x + t3 * end.x,\n      y: invT3 * start.y + 3 * invT2 * t1 * cp1y + 3 * invT1 * t2 * cp2y + t3 * end.y,\n    };\n  }\n\n  /**\n   * Calculate wave path position\n   */\n  private calculateWavePath(\n    start: Position,\n    end: Position,\n    progress: number,\n    amplitude?: number,\n    frequency = 3\n  ): Position {\n    const actualAmplitude =\n      amplitude || Math.min(Math.abs(end.x - start.x), Math.abs(end.y - start.y)) * 0.1;\n    const waviness = Math.sin(progress * Math.PI * frequency) * actualAmplitude;\n\n    // Calculate the normal vector to the path\n    const dx = end.x - start.x;\n    const dy = end.y - start.y;\n    const length = Math.sqrt(dx * dx + dy * dy);\n    const normalX = -dy / length;\n    const normalY = dx / length;\n\n    return {\n      x: start.x + (end.x - start.x) * progress + normalX * waviness,\n      y: start.y + (end.y - start.y) * progress + normalY * waviness,\n    };\n  }\n\n  /**\n   * Calculate random path position\n   */\n  private calculateRandomPath(\n    start: Position,\n    end: Position,\n    progress: number,\n    particle: Particle,\n    jitter = 0.1\n  ): Position {\n    // Get or create random seeds\n    let seeds = (particle.data?.randomSeeds as number[]) ?? [];\n    if (!seeds.length) {\n      seeds = Array.from({ length: 10 }, () => Math.random());\n      (particle.data as Record<string, unknown>).randomSeeds = seeds;\n    }\n\n    const jitterSize = Math.min(Math.abs(end.x - start.x), Math.abs(end.y - start.y)) * jitter;\n\n    // Use seeds and progress to generate controlled randomness\n    const index = Math.floor(progress * 10);\n    const subProgress = (progress * 10) % 1;\n    const seed1 = seeds[index % seeds.length];\n    const seed2 = seeds[(index + 1) % seeds.length];\n\n    const randomX =\n      (seed1 * 2 - 1) * jitterSize * (1 - subProgress) + (seed2 * 2 - 1) * jitterSize * subProgress;\n    const randomY =\n      (seeds[(index + 2) % seeds.length] * 2 - 1) * jitterSize * (1 - subProgress) +\n      (seeds[(index + 3) % seeds.length] * 2 - 1) * jitterSize * subProgress;\n\n    return {\n      x: start.x + (end.x - start.x) * progress + randomX,\n      y: start.y + (end.y - start.y) * progress + randomY,\n    };\n  }\n\n  /**\n   * Bounce easing function\n   */\n  private bounceEasing(t: number): number {\n    const a = 7.5625;\n    const b = 2.75;\n\n    if (t < 1 / b) {\n      return a * t * t;\n    } else if (t < 2 / b) {\n      t -= 1.5 / b;\n      return a * t * t + 0.75;\n    } else if (t < 2.5 / b) {\n      t -= 2.25 / b;\n      return a * t * t + 0.9375;\n    } else {\n      t -= 2.625 / b;\n      return a * t * t + 0.984375;\n    }\n  }\n\n  /**\n   * Elastic easing function\n   */\n  private elasticEasing(t: number): number {\n    return t === 0\n      ? 0\n      : t === 1\n        ? 1\n        : Math.pow(2, -10 * t) * Math.sin(((t * 10 - 0.75) * Math.PI) / 1.5) + 1;\n  }\n\n  /**\n   * Back easing function\n   */\n  private backEasing(t: number): number {\n    const overshoot = 1.70158;\n    return t * t * ((overshoot + 1) * t - overshoot);\n  }\n\n  /**\n   * Get easing function by type\n   */\n  private getEasingFunction(type: EasingType): EasingFunction {\n    switch (type) {\n      case EasingType.LINEAR:\n        return (t: number) => t;\n\n      case EasingType.EASE_IN:\n        return (t: number) => t * t;\n\n      case EasingType.EASE_OUT:\n        return (t: number) => t * (2 - t);\n\n      case EasingType.EASE_IN_OUT:\n        return (t: number) => (t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t);\n\n      case EasingType.BOUNCE:\n        return this.bounceEasing.bind(this);\n\n      case EasingType.ELASTIC:\n        return this.elasticEasing.bind(this);\n\n      case EasingType.BACK:\n        return this.backEasing.bind(this);\n\n      default:\n        return (t: number) => t;\n    }\n  }\n\n  /**\n   * Apply easing function to progress\n   */\n  private applyEasing(progress: number, easing: EasingFunction | EasingType): number {\n    if (typeof easing === 'function') {\n      return easing(progress);\n    }\n    return this.getEasingFunction(easing)(progress);\n  }\n\n  /**\n   * Interpolate between two colors\n   */\n  private interpolateColor(color1: string, color2: string, progress: number): string {\n    // Parse colors\n    const parseColor = (color: string): [number, number, number] => {\n      // Handle hex colors\n      if (color.startsWith('#')) {\n        const hex = color.substring(1);\n        if (hex.length === 3) {\n          return [\n            parseInt(hex[0] + hex[0], 16),\n            parseInt(hex[1] + hex[1], 16),\n            parseInt(hex[2] + hex[2], 16),\n          ];\n        } else {\n          return [\n            parseInt(hex.substring(0, 2), 16),\n            parseInt(hex.substring(2, 4), 16),\n            parseInt(hex.substring(4, 6), 16),\n          ];\n        }\n      }\n\n      // Handle rgb colors\n      if (color.startsWith('rgb')) {\n        const match = color.match(/rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)/);\n        if (match) {\n          return [parseInt(match[1]), parseInt(match[2]), parseInt(match[3])];\n        }\n      }\n\n      // Default\n      return [255, 255, 255];\n    };\n\n    const [r1, g1, b1] = parseColor(color1);\n    const [r2, g2, b2] = parseColor(color2);\n\n    // Interpolate\n    const r = Math.round(r1 + (r2 - r1) * progress);\n    const g = Math.round(g1 + (g2 - g1) * progress);\n    const b = Math.round(b1 + (b2 - b1) * progress);\n\n    // Convert back to hex\n    return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;\n  }\n\n  /**\n   * Get all particles\n   */\n  public getParticles(): Particle[] {\n    return Array.from(this.particles.values());\n  }\n\n  /**\n   * Get particles by group\n   */\n  public getParticlesByGroup(group: string): Particle[] {\n    return Array.from(this.particles.values()).filter(p => p.group === group);\n  }\n\n  /**\n   * Check if a transition is running\n   */\n  public isTransitionRunning(id: string): boolean {\n    return this.transitionTimers.has(id);\n  }\n\n  /**\n   * Get transition progress\n   */\n  public getTransitionProgress(id: string): number {\n    return this.transitionProgress.get(id) ?? 0;\n  }\n\n  /**\n   * Clear everything\n   */\n  public dispose(): void {\n    this.stop();\n    this.particles.clear();\n    this.emitters.clear();\n    this.transitionConfigs.clear();\n    this.transitionTimers.clear();\n    this.transitionProgress.clear();\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/main.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/ManagerRegistry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/ai/BehaviorTreeManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/automation/GlobalAutomationManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'resourceType' is defined but never used.","line":415,"column":29,"nodeType":null,"messageId":"unusedVar","endLine":415,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_deltaTime' is defined but never used.","line":595,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":595,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_elapsedTime' is defined but never used.","line":595,"column":38,"nodeType":null,"messageId":"unusedVar","endLine":595,"endColumn":50},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_event' is defined but never used.","line":603,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":603,"endColumn":37},{"ruleId":"no-unsafe-optional-chaining","severity":2,"message":"Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.","line":631,"column":79,"nodeType":"ChainExpression","messageId":"unsafeOptionalChain","endLine":631,"endColumn":90},{"ruleId":"no-unsafe-optional-chaining","severity":2,"message":"Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.","line":657,"column":73,"nodeType":"ChainExpression","messageId":"unsafeOptionalChain","endLine":657,"endColumn":84}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ModuleEvent, moduleEventBus, ModuleEventType } from '../../lib/modules/ModuleEvents';\nimport { ModuleType } from '../../types/buildings/ModuleTypes';\nimport {\n  getSystemCommunication,\n  MessagePriority,\n  SystemId,\n} from '../../utils/events/EventCommunication';\nimport { EventPriorityQueue } from '../../utils/events/EventFiltering';\nimport {\n  AutomationAction,\n  AutomationCondition,\n  AutomationManager,\n  AutomationRule,\n  ResourceConditionValue,\n} from '../game/AutomationManager';\nimport { gameLoopManager, UpdatePriority } from '../game/GameLoopManager';\nimport { ResourceType } from './../../types/resources/ResourceTypes';\n\n/**\n * Global routine type\n */\nexport type GlobalRoutineType =\n  | 'system-maintenance'\n  | 'resource-balancing'\n  | 'performance-optimization'\n  | 'emergency-response'\n  | 'scheduled-task'\n  | 'custom';\n\n/**\n * Global routine interface\n */\nexport interface GlobalRoutine {\n  id: string;\n  name: string;\n  type: GlobalRoutineType;\n  description: string;\n  enabled: boolean;\n  priority: MessagePriority;\n  interval: number;\n  lastRun?: number;\n  conditions: AutomationCondition[];\n  actions: AutomationAction[];\n  systems: SystemId[];\n  tags: string[];\n}\n\n/**\n * Global automation manager\n * Extends the module-specific automation with system-wide routines\n */\nexport class GlobalAutomationManager {\n  private _automationManager: AutomationManager;\n  private routines: Map<string, GlobalRoutine>;\n  private activeRoutines: Map<string, boolean>;\n  private routineQueue: EventPriorityQueue<GlobalRoutine & { executionTime: number }>;\n  private systemCommunications: Map<SystemId, ReturnType<typeof getSystemCommunication>>;\n  private isInitialized: boolean = false;\n\n  constructor(_automationManager: AutomationManager) {\n    this._automationManager = _automationManager;\n    this.routines = new Map();\n    this.activeRoutines = new Map();\n    this.systemCommunications = new Map();\n\n    // Create a priority queue for routine execution\n    this.routineQueue = new EventPriorityQueue(routine => {\n      return this.executeRoutine(routine);\n    });\n  }\n\n  /**\n   * Initialize the global automation manager\n   */\n  public initialize(): void {\n    if (this.isInitialized) {\n      return;\n    }\n\n    console.warn('Initializing Global Automation Manager...');\n\n    // Log the automation manager status\n    if (this._automationManager) {\n      console.warn(\n        `[GlobalAutomationManager] Using automation manager for condition checking and rule management`\n      );\n    } else {\n      console.warn(\n        '[GlobalAutomationManager] No automation manager provided, some features may be limited'\n      );\n    }\n\n    // Initialize system communications\n    this.initializeSystemCommunications();\n\n    // Register with game loop for regular updates\n    gameLoopManager.registerUpdate(\n      'global-automation-manager',\n      this.update.bind(this),\n      UpdatePriority.NORMAL\n    );\n\n    // Subscribe to relevant events\n    moduleEventBus.subscribe('ERROR_OCCURRED' as ModuleEventType, this.handleErrorEvent);\n    moduleEventBus.subscribe('RESOURCE_SHORTAGE' as ModuleEventType, this.handleResourceShortage);\n    moduleEventBus.subscribe('STATUS_CHANGED' as ModuleEventType, this.handleStatusChanged);\n\n    this.isInitialized = true;\n\n    // Emit initialization event\n    moduleEventBus.emit({\n      type: 'AUTOMATION_STARTED' as ModuleEventType,\n      moduleId: 'global-automation',\n      moduleType: 'resource-manager',\n      timestamp: Date.now(),\n      data: {\n        routineCount: this.routines.size,\n        systems: Array.from(this.systemCommunications.keys()),\n      },\n    });\n  }\n\n  /**\n   * Initialize system communications\n   */\n  private initializeSystemCommunications(): void {\n    const systems: SystemId[] = [\n      'resource-system',\n      'module-system',\n      'combat-system',\n      'exploration-system',\n      'mining-system',\n      'tech-system',\n      'ui-system',\n      'game-loop',\n      'event-system',\n    ];\n\n    systems.forEach(systemId => {\n      const communication = getSystemCommunication(systemId);\n      this.systemCommunications.set(systemId, communication);\n\n      // Register message handler for automation requests\n      communication.registerHandler('automation-request', message => {\n        console.warn(`Received automation request from ${systemId}:`, message.payload);\n\n        // Use type guard instead of type assertion\n        const { payload } = message;\n        if (payload && typeof payload === 'object') {\n          const routineId = 'routineId' in payload ? String(payload.routineId) : undefined;\n          const createRoutine =\n            'createRoutine' in payload &&\n            payload.createRoutine &&\n            typeof payload.createRoutine === 'object'\n              ? (payload.createRoutine as GlobalRoutine)\n              : undefined;\n\n          if (routineId) {\n            const routine = this.routines.get(routineId);\n            if (routine && routine.enabled) {\n              this.scheduleRoutine(routine);\n              return;\n            }\n          }\n\n          if (createRoutine) {\n            this.registerRoutine(createRoutine);\n          }\n        }\n      });\n    });\n  }\n\n  /**\n   * Register a global routine\n   */\n  public registerRoutine(routine: GlobalRoutine): string {\n    // Generate ID if not provided\n    if (!routine.id) {\n      routine.id = `routine-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n    }\n\n    this.routines.set(routine.id, routine);\n    this.activeRoutines.set(routine.id, routine.enabled);\n\n    // If routine is enabled, schedule it\n    if (routine.enabled) {\n      this.scheduleRoutine(routine);\n    }\n\n    // Notify systems about the new routine\n    routine.systems.forEach(systemId => {\n      const communication = this.systemCommunications.get(systemId);\n      if (communication) {\n        communication.sendMessage('broadcast', 'routine-registered', {\n          routineId: routine.id,\n          name: routine.name,\n          type: routine.type,\n        });\n      }\n    });\n\n    return routine.id;\n  }\n\n  /**\n   * Unregister a global routine\n   */\n  public unregisterRoutine(routineId: string): boolean {\n    const routine = this.routines.get(routineId);\n    if (!routine) {\n      return false;\n    }\n\n    // Notify systems about routine removal\n    routine.systems.forEach(systemId => {\n      const communication = this.systemCommunications.get(systemId);\n      if (communication) {\n        communication.sendMessage(systemId, 'routine-unregistered', {\n          routineId: routine.id,\n        });\n      }\n    });\n\n    this.routines.delete(routineId);\n    this.activeRoutines.delete(routineId);\n    return true;\n  }\n\n  /**\n   * Enable a global routine\n   */\n  public enableRoutine(routineId: string): boolean {\n    const routine = this.routines.get(routineId);\n    if (!routine) {\n      return false;\n    }\n\n    routine.enabled = true;\n    this.activeRoutines.set(routineId, true);\n\n    // Schedule the routine\n    this.scheduleRoutine(routine);\n\n    return true;\n  }\n\n  /**\n   * Disable a global routine\n   */\n  public disableRoutine(routineId: string): boolean {\n    const routine = this.routines.get(routineId);\n    if (!routine) {\n      return false;\n    }\n\n    routine.enabled = false;\n    this.activeRoutines.set(routineId, false);\n    return true;\n  }\n\n  /**\n   * Schedule a routine for execution\n   */\n  private scheduleRoutine(routine: GlobalRoutine): void {\n    // Add to the priority queue\n    this.routineQueue.enqueue({\n      ...routine,\n      executionTime: Date.now() + (routine.interval ?? 0),\n    });\n  }\n\n  /**\n   * Execute a routine\n   */\n  private async executeRoutine(routine: GlobalRoutine & { executionTime: number }): Promise<void> {\n    try {\n      // Skip if routine is disabled\n      if (!routine.enabled) {\n        return;\n      }\n\n      // Skip if it's not time to run yet\n      if (Date.now() < routine.executionTime) {\n        // Re-queue for later execution\n        this.scheduleRoutine(routine);\n        return;\n      }\n\n      console.warn(`Executing routine: ${routine.name} (${routine.id})`);\n\n      // Check conditions\n      let conditionsMet = true;\n      try {\n        // Try to check conditions, but handle if the method is private\n        // We'll implement our own simple condition checking if needed\n        for (const condition of routine.conditions) {\n          if (condition.type === 'RESOURCE_BELOW') {\n            // Simple implementation for resource below condition\n            const { target, value } = condition;\n            if (target && value !== undefined) {\n              const resourceAmount = this.getResourceAmount(target as ResourceType);\n              // Extract numeric value for comparison\n              const threshold =\n                typeof value === 'number' ? value : (value as ResourceConditionValue).amount;\n              if (resourceAmount > threshold) {\n                conditionsMet = false;\n                break;\n              }\n            }\n          } else if (condition.type === 'RESOURCE_ABOVE') {\n            // Simple implementation for resource above condition\n            const { target, value } = condition;\n            if (target && value !== undefined) {\n              const resourceAmount = this.getResourceAmount(target as ResourceType);\n              // Extract numeric value for comparison\n              const threshold =\n                typeof value === 'number' ? value : (value as ResourceConditionValue).amount;\n              if (resourceAmount < threshold) {\n                conditionsMet = false;\n                break;\n              }\n            }\n          }\n          // Add more condition types as needed\n        }\n      } catch (error) {\n        console.warn('Error checking conditions, using simple implementation:', error);\n      }\n\n      if (!conditionsMet) {\n        console.warn(`Conditions not met for routine: ${routine.name}`);\n\n        // Re-schedule for next interval\n        this.scheduleRoutine({\n          ...routine,\n          lastRun: Date.now(),\n        });\n        return;\n      }\n\n      // Execute actions\n      try {\n        // Try to execute actions through the automation manager\n        // If that fails, implement our own simple action execution\n        for (const action of routine.actions) {\n          await this.executeAction(action);\n        }\n      } catch (error) {\n        console.warn('Error executing actions, using simple implementation:', error);\n      }\n\n      // Update last run time\n      const updatedRoutine = {\n        ...routine,\n        lastRun: Date.now(),\n      };\n      this.routines.set(routine.id, updatedRoutine);\n\n      // Emit routine completion event\n      moduleEventBus.emit({\n        type: 'AUTOMATION_CYCLE_COMPLETE' as ModuleEventType,\n        moduleId: 'global-automation',\n        moduleType: 'resource-manager',\n        timestamp: Date.now(),\n        data: {\n          routineId: routine.id,\n          routineName: routine.name,\n          routineType: routine.type,\n        },\n      });\n\n      // Notify relevant systems\n      routine.systems.forEach(systemId => {\n        const communication = this.systemCommunications.get(systemId);\n        if (communication) {\n          communication.sendMessage(systemId, 'routine-executed', {\n            routineId: routine.id,\n            success: true,\n            timestamp: Date.now(),\n          });\n        }\n      });\n\n      // Re-schedule for next interval\n      this.scheduleRoutine(updatedRoutine);\n    } catch (error) {\n      console.error(`Error executing routine ${routine.id}:`, error);\n\n      // Emit error event\n      moduleEventBus.emit({\n        type: 'ERROR_OCCURRED' as ModuleEventType,\n        moduleId: 'global-automation',\n        moduleType: 'resource-manager',\n        timestamp: Date.now(),\n        data: {\n          routineId: routine.id,\n          error: error instanceof Error ? error.message : String(error),\n        },\n      });\n\n      // Re-schedule for next interval\n      this.scheduleRoutine({\n        ...routine,\n        lastRun: Date.now(),\n      });\n    }\n  }\n\n  /**\n   * Get the current amount of a resource\n   * @param resourceType The type of resource to check\n   * @returns The current amount of the resource\n   */\n  private getResourceAmount(resourceType: ResourceType): number {\n    // Implementation would get the actual resource amount from the game state\n    // For now, return a mock value\n    return 100;\n  }\n\n  /**\n   * Helper method to execute a single action\n   */\n  private async executeAction(action: AutomationAction): Promise<void> {\n    switch (action.type) {\n      case 'ACTIVATE_MODULE':\n        if (!action.target) {\n          return;\n        }\n        // Emit an event to activate the module\n        moduleEventBus.emit({\n          type: 'MODULE_ACTIVATED' as ModuleEventType,\n          moduleId: action.target,\n          moduleType: 'resource-manager',\n          timestamp: Date.now(),\n          data: { source: 'automation' },\n        });\n        break;\n\n      case 'DEACTIVATE_MODULE':\n        if (!action.target) {\n          return;\n        }\n        // Emit an event to deactivate the module\n        moduleEventBus.emit({\n          type: 'MODULE_DEACTIVATED' as ModuleEventType,\n          moduleId: action.target,\n          moduleType: 'resource-manager',\n          timestamp: Date.now(),\n          data: { source: 'automation' },\n        });\n        break;\n\n      case 'TRANSFER_RESOURCES':\n        if (!action.target || !action.value) {\n          return;\n        }\n        // Emit an event to transfer resources\n        moduleEventBus.emit({\n          type: 'RESOURCE_TRANSFERRED' as ModuleEventType,\n          moduleId: 'automation',\n          moduleType: 'resource-manager',\n          timestamp: Date.now(),\n          data: this.convertActionValueToRecord(action.value),\n        });\n        break;\n\n      case 'EMIT_EVENT': {\n        if (!action.target || !action.value) {\n          return;\n        }\n\n        // Define interface for EmitEventValue\n        interface EmitEventValue {\n          moduleId?: string;\n          moduleType?: string;\n          data?: Record<string, unknown>;\n          [key: string]: unknown; // Add index signature to satisfy Record<string, unknown>\n        }\n\n        // Use type guard instead of type assertion\n        const emitValue: EmitEventValue = {};\n\n        if (typeof action.value === 'object' && action.value !== null) {\n          // First cast to unknown to avoid type errors\n          const value = action.value as unknown as Record<string, unknown>;\n\n          if ('moduleId' in value && typeof value.moduleId === 'string') {\n            emitValue.moduleId = value.moduleId;\n          }\n\n          if ('moduleType' in value && typeof value.moduleType === 'string') {\n            emitValue.moduleType = value.moduleType as ModuleType;\n          }\n\n          if ('data' in value && typeof value.data === 'object' && value.data !== null) {\n            emitValue.data = value.data as Record<string, unknown>;\n          }\n        }\n\n        // Validate that action.target is a valid ModuleEventType\n        const isValidEventType = (type: string): type is ModuleEventType => {\n          return [\n            'MODULE_CREATED',\n            'MODULE_ATTACHED',\n            'MODULE_DETACHED',\n            'MODULE_UPGRADED',\n            'MODULE_ACTIVATED',\n            'MODULE_DEACTIVATED',\n            'MODULE_UPDATED',\n            'ATTACHMENT_STARTED',\n            'ATTACHMENT_CANCELLED',\n            'ATTACHMENT_COMPLETED',\n            'ATTACHMENT_PREVIEW_SHOWN',\n            'RESOURCE_PRODUCED',\n            'RESOURCE_CONSUMED',\n            'RESOURCE_TRANSFERRED',\n            'RESOURCE_PRODUCTION_REGISTERED',\n            'RESOURCE_PRODUCTION_UNREGISTERED',\n            'RESOURCE_CONSUMPTION_REGISTERED',\n            'RESOURCE_CONSUMPTION_UNREGISTERED',\n            'RESOURCE_FLOW_REGISTERED',\n            'RESOURCE_FLOW_UNREGISTERED',\n            'RESOURCE_SHORTAGE',\n            'RESOURCE_UPDATED',\n            'AUTOMATION_STARTED',\n            'AUTOMATION_STOPPED',\n            'AUTOMATION_CYCLE_COMPLETE',\n            'STATUS_CHANGED',\n            'ERROR_OCCURRED',\n            'MISSION_STARTED',\n            'MISSION_COMPLETED',\n            'MISSION_FAILED',\n            'MISSION_PROGRESS_UPDATED',\n            'MISSION_REWARD_CLAIMED',\n            'SUB_MODULE_CREATED',\n            'SUB_MODULE_ATTACHED',\n            'SUB_MODULE_DETACHED',\n            'SUB_MODULE_UPGRADED',\n            'SUB_MODULE_ACTIVATED',\n            'SUB_MODULE_DEACTIVATED',\n            'SUB_MODULE_EFFECT_APPLIED',\n            'SUB_MODULE_EFFECT_REMOVED',\n            'COMBAT_UPDATED',\n            'TECH_UNLOCKED',\n            'TECH_UPDATED',\n          ].includes(type as ModuleEventType);\n        };\n\n        if (isValidEventType(action.target)) {\n          // Emit the specified event\n          moduleEventBus.emit({\n            type: action.target,\n            moduleId: emitValue.moduleId || 'automation',\n            moduleType: (emitValue.moduleType || 'resource-manager') as ModuleType,\n            timestamp: Date.now(),\n            data: emitValue.data ?? {},\n          });\n        } else {\n          console.warn(`Invalid event type: ${action.target}`);\n        }\n        break;\n      }\n\n      default:\n        console.warn(`Unsupported action type: ${action.type}`);\n    }\n  }\n\n  // Add a helper method to convert action values to Record<string, unknown>\n  private convertActionValueToRecord(value: unknown): Record<string, unknown> {\n    if (value === null || value === undefined) {\n      return {};\n    }\n\n    if (typeof value === 'object') {\n      // If it's already an object, convert it to a Record<string, unknown>\n      // First cast to unknown, then to Record<string, unknown> to avoid type errors\n      return Object.entries(value as unknown as Record<string, unknown>).reduce(\n        (acc, [key, val]) => {\n          acc[key] = val;\n          return acc;\n        },\n        {} as Record<string, unknown>\n      );\n    }\n\n    // If it's a primitive value, wrap it in an object\n    return { value };\n  }\n\n  /**\n   * Update method called by the game loop\n   */\n  private update(_deltaTime: number, _elapsedTime: number): void {\n    // Process any pending routines\n    // The queue itself handles the execution\n  }\n\n  /**\n   * Handle error events\n   */\n  private handleErrorEvent = (_event: ModuleEvent): void => {\n    // Find emergency response routines\n    const emergencyRoutines = Array.from(this.routines.values()).filter(\n      routine =>\n        routine.enabled &&\n        routine.type === 'emergency-response' &&\n        routine.tags.includes('error-handling')\n    );\n\n    // Schedule emergency routines immediately\n    emergencyRoutines.forEach(routine => {\n      this.routineQueue.enqueue({\n        ...routine,\n        executionTime: Date.now(), // Execute immediately\n      });\n    });\n  };\n\n  /**\n   * Handle resource shortage events\n   */\n  private handleResourceShortage = (event: ModuleEvent): void => {\n    // Find resource balancing routines\n    const resourceRoutines = Array.from(this.routines.values()).filter(\n      routine =>\n        routine.enabled &&\n        routine.type === 'resource-balancing' &&\n        routine.tags.includes(\n          event?.data && typeof event?.data === 'object' && 'resourceType' in event?.data\n            ? String(event?.data?.resourceType)\n            : 'general'\n        )\n    );\n\n    // Schedule resource routines with high priority\n    resourceRoutines.forEach(routine => {\n      this.routineQueue.enqueue({\n        ...routine,\n        executionTime: Date.now(), // Execute immediately\n        priority: MessagePriority.HIGH, // Override with high priority\n      });\n    });\n  };\n\n  /**\n   * Handle status changed events\n   */\n  private handleStatusChanged = (event: ModuleEvent): void => {\n    // Find relevant routines based on status\n    const statusRoutines = Array.from(this.routines.values()).filter(\n      routine =>\n        routine.enabled &&\n        (routine.type === 'system-maintenance' || routine.type === 'performance-optimization') &&\n        routine.tags.includes(\n          event?.data && typeof event?.data === 'object' && 'status' in event?.data\n            ? String(event?.data?.status)\n            : 'general'\n        )\n    );\n\n    // Schedule status routines\n    statusRoutines.forEach(routine => {\n      this.routineQueue.enqueue({\n        ...routine,\n        executionTime: Date.now() + 1000, // Small delay to allow system to stabilize\n      });\n    });\n  };\n\n  /**\n   * Get all routines\n   */\n  public getAllRoutines(): GlobalRoutine[] {\n    return Array.from(this.routines.values());\n  }\n\n  /**\n   * Get routines by type\n   */\n  public getRoutinesByType(type: GlobalRoutineType): GlobalRoutine[] {\n    return Array.from(this.routines.values()).filter(routine => routine.type === type);\n  }\n\n  /**\n   * Get routines by system\n   */\n  public getRoutinesBySystem(systemId: SystemId): GlobalRoutine[] {\n    return Array.from(this.routines.values()).filter(routine => routine.systems.includes(systemId));\n  }\n\n  /**\n   * Get routines by tag\n   */\n  public getRoutinesByTag(tag: string): GlobalRoutine[] {\n    return Array.from(this.routines.values()).filter(routine => routine.tags.includes(tag));\n  }\n\n  /**\n   * Get active routines\n   */\n  public getActiveRoutines(): GlobalRoutine[] {\n    return Array.from(this.routines.values()).filter(routine => routine.enabled);\n  }\n\n  /**\n   * Clean up resources\n   */\n  public cleanup(): void {\n    // Unregister from game loop\n    gameLoopManager.unregisterUpdate('global-automation-manager');\n\n    // Unsubscribe from events\n    const unsubscribeError = moduleEventBus.subscribe(\n      'ERROR_OCCURRED' as ModuleEventType,\n      this.handleErrorEvent\n    );\n    const unsubscribeShortage = moduleEventBus.subscribe(\n      'RESOURCE_SHORTAGE' as ModuleEventType,\n      this.handleResourceShortage\n    );\n    const unsubscribeStatus = moduleEventBus.subscribe(\n      'STATUS_CHANGED' as ModuleEventType,\n      this.handleStatusChanged\n    );\n\n    if (typeof unsubscribeError === 'function') {\n      unsubscribeError();\n    }\n    if (typeof unsubscribeShortage === 'function') {\n      unsubscribeShortage();\n    }\n    if (typeof unsubscribeStatus === 'function') {\n      unsubscribeStatus();\n    }\n\n    // Clear routines\n    this.routines.clear();\n    this.activeRoutines.clear();\n\n    // Clear system communications\n    this.systemCommunications.clear();\n\n    this.isInitialized = false;\n  }\n\n  /**\n   * Get the automation manager instance\n   * This method is used for testing and debugging purposes\n   */\n  public getAutomationManager(): AutomationManager | null {\n    return this._automationManager || null;\n  }\n\n  /**\n   * Get a rule by ID\n   */\n  public getRule(ruleId: string): AutomationRule | undefined {\n    // Delegate to AutomationManager\n    return this._automationManager.getRule(ruleId);\n  }\n\n  /**\n   * Update an existing rule\n   */\n  public updateRule(ruleId: string, rule: AutomationRule): void {\n    // Delegate to AutomationManager\n    this._automationManager.updateRule(ruleId, rule);\n\n    // Emit event\n    moduleEventBus.emit({\n      type: 'STATUS_CHANGED', // Use a valid ModuleEventType\n      moduleId: rule.moduleId,\n      moduleType: 'resource-manager',\n      timestamp: Date.now(),\n      data: { ruleId, rule, status: 'updated' },\n    });\n  }\n\n  /**\n   * Register a new rule\n   */\n  public registerRule(rule: AutomationRule): void {\n    // Delegate to AutomationManager\n    this._automationManager.registerRule(rule);\n\n    // Emit event\n    moduleEventBus.emit({\n      type: 'AUTOMATION_STARTED', // Use a valid ModuleEventType\n      moduleId: rule.moduleId,\n      moduleType: 'resource-manager',\n      timestamp: Date.now(),\n      data: { ruleId: rule.id, rule },\n    });\n  }\n}\n\n// Export singleton instance\nexport const globalAutomationManager = new GlobalAutomationManager(\n  // We'll need to import the actual instance in the initialization file\n  null as unknown as AutomationManager\n);\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/colony/ColonyManagerImpl.ts","messages":[{"ruleId":"no-unsafe-optional-chaining","severity":2,"message":"Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.","line":112,"column":43,"nodeType":"ChainExpression","messageId":"unsafeOptionalChain","endLine":112,"endColumn":54},{"ruleId":"no-unsafe-optional-chaining","severity":2,"message":"Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.","line":121,"column":26,"nodeType":"ChainExpression","messageId":"unsafeOptionalChain","endLine":121,"endColumn":37},{"ruleId":"no-unsafe-optional-chaining","severity":2,"message":"Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.","line":130,"column":35,"nodeType":"ChainExpression","messageId":"unsafeOptionalChain","endLine":130,"endColumn":46},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_dependencies' is defined but never used.","line":483,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":483,"endColumn":45},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_deltaTime' is defined but never used.","line":490,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":490,"endColumn":32}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { colonyRules } from '../../config/automation/colonyRules';\nimport { AbstractBaseManager } from '../../lib/managers/BaseManager';\nimport { ModuleType } from '../../types/buildings/ModuleTypes';\nimport { BaseEvent, EventType } from '../../types/events/EventTypes';\nimport { automationManager } from '../game/AutomationManager';\nimport { ResourceManager } from '../game/ResourceManager';\nimport { ResourceType } from './../../types/resources/ResourceTypes';\n\n// Create an instance of ResourceManager\nconst resourceManager = new ResourceManager();\n\ninterface ColonyStats {\n  population: number;\n  happiness: number;\n  infrastructure: number;\n  research: number;\n  foodProduction: number;\n  energyProduction: number;\n}\n\n// Add a ResearchBenefits interface\nexport interface ResearchBenefits {\n  resourceBonus?: Record<ResourceType, number>;\n  infrastructureBonus?: number;\n  populationBonus?: number;\n  happinessBonus?: number;\n  unlocks?: string[];\n  [key: string]: unknown;\n}\n\n/**\n * Colony event interface extending BaseEvent\n */\nexport interface ColonyEvent extends BaseEvent {\n  type: EventType;\n  moduleId: string;\n  moduleType: ModuleType;\n  data: ColonyEventData;\n}\n\n/**\n * Colony event data interface\n */\nexport interface ColonyEventData extends Record<string, unknown> {\n  colonyId?: string;\n  stats?: ColonyStats;\n  resourceAmounts?: Record<string, number>;\n  type?: string;\n  level?: number;\n  amount?: number;\n  partnerId?: string;\n  tradeResources?: ResourceType[];\n  threatLevel?: number;\n  project?: string;\n  benefits?: ResearchBenefits;\n  protocol?: string;\n}\n\n/**\n * Type guard for ColonyEvent\n */\nexport function isColonyEvent(event: unknown): event is ColonyEvent {\n  if (!event || typeof event !== 'object') return false;\n  const e = event as ColonyEvent;\n  return (\n    'type' in e &&\n    'moduleId' in e &&\n    'moduleType' in e &&\n    'data' in e &&\n    typeof e.type === 'string' &&\n    typeof e.moduleId === 'string' &&\n    typeof e.moduleType === 'string' &&\n    typeof e.data === 'object'\n  );\n}\n\nexport class ColonyManagerImpl extends AbstractBaseManager<ColonyEvent> {\n  private colonies: Map<\n    string,\n    {\n      id: string;\n      name: string;\n      level: number;\n      stats: ColonyStats;\n      tradeRoutes: Set<string>;\n      activeResearch: Set<string>;\n      emergencyProtocols: Set<string>;\n    }\n  > = new Map();\n\n  constructor() {\n    super('ColonyManager');\n    this.initializeEventHandlers();\n    this.initializeAutomationRules();\n  }\n\n  /**\n   * Initialize event handlers for colony-related events\n   */\n  private initializeEventHandlers(): void {\n    // Subscribe to relevant events\n    this.unsubscribeFunctions.push(\n      this.subscribe(EventType.RESOURCE_UPDATED, this.handleResourceUpdate.bind(this)),\n      this.subscribe(EventType.RESOURCE_SHORTAGE, this.handleResourceShortage.bind(this)),\n      this.subscribe(EventType.TECH_UNLOCKED, this.handleTechUnlock.bind(this))\n    );\n  }\n\n  private handleResourceUpdate(event: ColonyEvent): void {\n    if (!isColonyEvent(event)) return;\n    // Handle resource updates\n    const { colonyId, resourceAmounts } = event?.data;\n    if (colonyId && resourceAmounts) {\n      this.updateColonyResources(colonyId, resourceAmounts);\n    }\n  }\n\n  private handleResourceShortage(event: ColonyEvent): void {\n    if (!isColonyEvent(event)) return;\n    // Handle resource shortages\n    const { colonyId } = event?.data;\n    if (colonyId) {\n      this.activateEmergencyProtocol(colonyId, 'resource_shortage');\n    }\n  }\n\n  private handleTechUnlock(event: ColonyEvent): void {\n    if (!isColonyEvent(event)) return;\n    // Handle tech unlocks\n    const { colonyId, project } = event?.data;\n    if (colonyId && project) {\n      this.applyTechBenefits(colonyId, project as string);\n    }\n  }\n\n  private updateColonyResources(colonyId: string, resources: Record<string, number>): void {\n    const colony = this.colonies.get(colonyId);\n    if (!colony) return;\n\n    // Update colony stats based on resources\n    this.updateStats(colonyId, {\n      foodProduction: resources.food || colony.stats.foodProduction,\n      energyProduction: resources.energy || colony.stats.energyProduction,\n    });\n  }\n\n  private applyTechBenefits(colonyId: string, project: string): void {\n    const colony = this.colonies.get(colonyId);\n    if (!colony) return;\n\n    // Apply tech benefits\n    this.publish({\n      type: EventType.TECH_UPDATED,\n      moduleId: colonyId,\n      moduleType: 'colony' as ModuleType,\n      timestamp: Date.now(),\n      data: {\n        project,\n        colonyId,\n        stats: colony.stats,\n      },\n    });\n  }\n\n  private initializeAutomationRules(): void {\n    colonyRules.forEach(rule => {\n      automationManager.registerRule(rule);\n    });\n  }\n\n  public registerColony(id: string, name: string, initialStats: Partial<ColonyStats> = {}): void {\n    const defaultStats: ColonyStats = {\n      population: 100,\n      happiness: 100,\n      infrastructure: 1,\n      research: 0,\n      foodProduction: 10,\n      energyProduction: 10,\n    };\n\n    this.colonies.set(id, {\n      id,\n      name,\n      level: 1,\n      stats: { ...defaultStats, ...initialStats },\n      tradeRoutes: new Set(),\n      activeResearch: new Set(),\n      emergencyProtocols: new Set(),\n    });\n\n    // Emit initialization event\n    this.publish({\n      type: EventType.MODULE_ACTIVATED,\n      moduleId: id,\n      moduleType: 'colony' as ModuleType,\n      timestamp: Date.now(),\n      data: { name, stats: defaultStats },\n    });\n  }\n\n  public updateStats(colonyId: string, updates: Partial<ColonyStats>): void {\n    const colony = this.colonies.get(colonyId);\n    if (!colony) {\n      return;\n    }\n\n    colony.stats = { ...colony.stats, ...updates };\n    this.publish({\n      type: EventType.MODULE_UPDATED,\n      moduleId: colonyId,\n      moduleType: 'colony' as ModuleType,\n      timestamp: Date.now(),\n      data: { colonyId, stats: colony.stats },\n    });\n\n    // Check for level up\n    this.checkForLevelUp(colonyId);\n  }\n\n  private checkForLevelUp(colonyId: string): void {\n    const colony = this.colonies.get(colonyId);\n    if (!colony) {\n      return;\n    }\n\n    const { population, infrastructure } = colony.stats;\n    const newLevel = Math.floor(Math.sqrt(population * infrastructure) / 100);\n\n    if (newLevel > colony.level) {\n      colony.level = newLevel;\n      this.publish({\n        type: EventType.MODULE_UPGRADED,\n        moduleId: colonyId,\n        moduleType: 'colony' as ModuleType,\n        timestamp: Date.now(),\n        data: { level: newLevel },\n      });\n    }\n  }\n\n  public distributeResources(colonyId: string): void {\n    const colony = this.colonies.get(colonyId);\n    if (!colony) {\n      return;\n    }\n\n    // Calculate resource needs based on population and infrastructure\n    const resourceNeeds = this.calculateResourceNeeds(colony);\n\n    // Distribute resources\n    Object.entries(resourceNeeds).forEach(([resource, amount]) => {\n      // Convert string resource to ResourceType enum\n      let resourceType: ResourceType;\n      switch (resource) {\n        case ResourceType.FOOD:\n          resourceType = ResourceType.POPULATION; // Using POPULATION as a proxy for food\n          break;\n        case ResourceType.ENERGY:\n          resourceType = ResourceType.ENERGY;\n          break;\n        case ResourceType.MINERALS:\n          resourceType = ResourceType.MINERALS;\n          break;\n        default:\n          resourceType = ResourceType.MINERALS; // Default case\n      }\n      resourceManager.transferResources(resourceType, amount, 'storage', colonyId);\n    });\n\n    this.publish({\n      type: EventType.RESOURCE_TRANSFERRED,\n      moduleId: colonyId,\n      moduleType: 'colony' as ModuleType,\n      timestamp: Date.now(),\n      data: { colonyId, resourceAmounts: resourceNeeds },\n    });\n  }\n\n  private calculateResourceNeeds(\n    colony: NonNullable<ReturnType<typeof this.colonies.get>>\n  ): Record<string, number> {\n    const { population, infrastructure } = colony.stats;\n\n    return {\n      food: Math.ceil(population * 0.5),\n      energy: Math.ceil(population * 0.3 + infrastructure * 10),\n      minerals: Math.ceil(infrastructure * 5),\n    };\n  }\n\n  public buildInfrastructure(colonyId: string, type: string): void {\n    const colony = this.colonies.get(colonyId);\n    if (!colony) {\n      return;\n    }\n\n    // Check resource requirements\n    const requirements = this.getInfrastructureRequirements(type, colony.level);\n    if (!this.hasRequiredResources(requirements)) {\n      return;\n    }\n\n    // Consume resources\n    Object.entries(requirements).forEach(([resource, amount]) => {\n      // Convert string resource to ResourceType enum\n      let resourceType: ResourceType;\n      switch (resource) {\n        case ResourceType.MINERALS:\n          resourceType = ResourceType.MINERALS;\n          break;\n        case ResourceType.ENERGY:\n          resourceType = ResourceType.ENERGY;\n          break;\n        default:\n          resourceType = ResourceType.MINERALS; // Default case\n      }\n      resourceManager.removeResource(resourceType, amount);\n    });\n\n    // Update infrastructure\n    colony.stats.infrastructure += 1;\n    this.publish({\n      type: EventType.MODULE_UPDATED,\n      moduleId: colonyId,\n      moduleType: 'colony' as ModuleType,\n      timestamp: Date.now(),\n      data: {\n        colonyId,\n        type,\n        level: colony.stats.infrastructure,\n      },\n    });\n  }\n\n  private getInfrastructureRequirements(_type: string, level: number): Record<string, number> {\n    const baseRequirements = {\n      minerals: 100,\n      energy: 50,\n    };\n\n    // Scale requirements with level\n    return Object.entries(baseRequirements).reduce(\n      (acc, [resource, amount]) => ({\n        ...acc,\n        [resource]: Math.ceil(amount * Math.pow(1.5, level - 1)),\n      }),\n      {}\n    );\n  }\n\n  private hasRequiredResources(requirements: Record<string, number>): boolean {\n    return Object.entries(requirements).every(([resource, amount]) => {\n      // Convert string resource to ResourceType enum\n      let resourceType: ResourceType;\n      switch (resource) {\n        case ResourceType.MINERALS:\n          resourceType = ResourceType.MINERALS;\n          break;\n        case ResourceType.ENERGY:\n          resourceType = ResourceType.ENERGY;\n          break;\n        default:\n          resourceType = ResourceType.MINERALS; // Default case\n      }\n      return resourceManager.getResourceAmount(resourceType) >= amount;\n    });\n  }\n\n  public establishTradeRoute(colonyId: string, partnerId: string, resources: ResourceType[]): void {\n    const colony = this.colonies.get(colonyId);\n    if (!colony) {\n      return;\n    }\n\n    colony.tradeRoutes.add(partnerId);\n    this.publish({\n      type: EventType.AUTOMATION_STARTED,\n      moduleId: colonyId,\n      moduleType: 'colony' as ModuleType,\n      timestamp: Date.now(),\n      data: { type: 'trade', partnerId, tradeResources: resources },\n    });\n  }\n\n  public activateDefense(colonyId: string, threatLevel: number): void {\n    const colony = this.colonies.get(colonyId);\n    if (!colony) {\n      return;\n    }\n\n    this.publish({\n      type: EventType.AUTOMATION_STARTED,\n      moduleId: colonyId,\n      moduleType: 'colony' as ModuleType,\n      timestamp: Date.now(),\n      data: { type: 'defense', threatLevel },\n    });\n  }\n\n  public startResearch(colonyId: string, project: string): void {\n    const colony = this.colonies.get(colonyId);\n    if (!colony) {\n      return;\n    }\n\n    colony.activeResearch.add(project);\n    this.publish({\n      type: EventType.AUTOMATION_STARTED,\n      moduleId: colonyId,\n      moduleType: 'colony' as ModuleType,\n      timestamp: Date.now(),\n      data: { type: ResourceType.RESEARCH, project },\n    });\n  }\n\n  public completeResearch(colonyId: string, project: string, benefits: ResearchBenefits): void {\n    const colony = this.colonies.get(colonyId);\n    if (!colony) {\n      return;\n    }\n\n    colony.activeResearch.delete(project);\n    this.publish({\n      type: EventType.AUTOMATION_CYCLE_COMPLETE,\n      moduleId: colonyId,\n      moduleType: 'colony' as ModuleType,\n      timestamp: Date.now(),\n      data: { type: ResourceType.RESEARCH, project, benefits },\n    });\n  }\n\n  public activateEmergencyProtocol(colonyId: string, type: string): void {\n    const colony = this.colonies.get(colonyId);\n    if (!colony) {\n      return;\n    }\n\n    colony.emergencyProtocols.add(type);\n    this.publish({\n      type: EventType.AUTOMATION_STARTED,\n      moduleId: colonyId,\n      moduleType: 'colony' as ModuleType,\n      timestamp: Date.now(),\n      data: { type: 'emergency', protocol: type },\n    });\n  }\n\n  public deactivateEmergencyProtocol(colonyId: string, type: string): void {\n    const colony = this.colonies.get(colonyId);\n    if (!colony) {\n      return;\n    }\n\n    colony.emergencyProtocols.delete(type);\n    this.publish({\n      type: EventType.AUTOMATION_STOPPED,\n      moduleId: colonyId,\n      moduleType: 'colony' as ModuleType,\n      timestamp: Date.now(),\n      data: { type: 'emergency', protocol: type },\n    });\n  }\n\n  public getColonyStats(colonyId: string): ColonyStats | undefined {\n    return this.colonies.get(colonyId)?.stats;\n  }\n\n  public getActiveResearch(colonyId: string): string[] {\n    return Array.from(this.colonies.get(colonyId)?.activeResearch ?? []);\n  }\n\n  public getTradeRoutes(colonyId: string): string[] {\n    return Array.from(this.colonies.get(colonyId)?.tradeRoutes ?? []);\n  }\n\n  public getActiveEmergencyProtocols(colonyId: string): string[] {\n    return Array.from(this.colonies.get(colonyId)?.emergencyProtocols ?? []);\n  }\n\n  /**\n   * @inheritdoc\n   */\n  protected async onInitialize(_dependencies?: unknown): Promise<void> {\n    console.warn('ColonyManager initialized');\n  }\n\n  /**\n   * @inheritdoc\n   */\n  protected onUpdate(_deltaTime: number): void {\n    // Update colony stats and check for events\n    this.colonies.forEach((colony, id) => {\n      this.updateColonyState(id);\n    });\n  }\n\n  /**\n   * @inheritdoc\n   */\n  protected async onDispose(): Promise<void> {\n    // Clear all colonies and their data\n    this.colonies.clear();\n  }\n\n  /**\n   * @inheritdoc\n   */\n  protected getVersion(): string {\n    return '1.0.0';\n  }\n\n  /**\n   * @inheritdoc\n   */\n  protected getStats(): Record<string, number | string> {\n    return {\n      colonyCount: this.colonies.size,\n      totalPopulation: Array.from(this.colonies.values()).reduce(\n        (sum, c) => sum + c.stats.population,\n        0\n      ),\n      totalInfrastructure: Array.from(this.colonies.values()).reduce(\n        (sum, c) => sum + c.stats.infrastructure,\n        0\n      ),\n      activeResearch: Array.from(this.colonies.values()).reduce(\n        (sum, c) => sum + c.activeResearch.size,\n        0\n      ),\n      activeTradeRoutes: Array.from(this.colonies.values()).reduce(\n        (sum, c) => sum + c.tradeRoutes.size,\n        0\n      ),\n    };\n  }\n\n  private updateColonyState(colonyId: string): void {\n    const colony = this.colonies.get(colonyId);\n    if (!colony) return;\n\n    // Update population based on food production\n    const populationGrowth = Math.floor(colony.stats.foodProduction * 0.1);\n    if (populationGrowth > 0) {\n      this.updateStats(colonyId, {\n        population: colony.stats.population + populationGrowth,\n      });\n    }\n\n    // Update happiness based on resource availability\n    const resourceNeeds = this.calculateResourceNeeds(colony);\n    const resourceAvailability = Object.entries(resourceNeeds).every(([resource, amount]) => {\n      const resourceType =\n        resource === ResourceType.FOOD\n          ? ResourceType.POPULATION\n          : ResourceType[resource.toUpperCase() as keyof typeof ResourceType];\n      return resourceManager.getResourceAmount(resourceType) >= amount;\n    });\n\n    if (!resourceAvailability) {\n      this.updateStats(colonyId, {\n        happiness: Math.max(0, colony.stats.happiness - 5),\n      });\n    }\n  }\n}\n\n// Export singleton instance\nexport const colonyManager = new ColonyManagerImpl();\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/combat/CombatManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/combat/CombatMechanicsSystem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/combat/EnvironmentalHazardManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_tier' is defined but never used.","line":904,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":904,"endColumn":10}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ResourceType } from './../../types/resources/ResourceTypes';\n/**\n * Environmental Hazard Manager\n *\n * Manages the generation, behavior, and lifecycle of environmental hazards\n * in combat scenarios.\n */\n\nimport {\n  AnomalyHazardEffect,\n  DamageHazardEffect,\n  FieldHazardEffect,\n  HazardEffectType,\n  HazardGenerationConfig,\n  MovingHazard,\n  SplittingHazard,\n  WeatherHazardEffect,\n} from '../../effects/types_effects/EnvironmentalHazardEffects';\nimport { EventEmitter } from '../../lib/events/EventEmitter';\nimport { Position } from '../../types/core/GameTypes';\n\n// Event types for the hazard manager\ninterface HazardEvents {\n  hazardCreated: {\n    hazardId: string;\n    type: HazardEffectType['type'];\n    position: Position;\n  };\n  hazardRemoved: {\n    hazardId: string;\n  };\n  hazardModified: {\n    hazardId: string;\n    changes: Partial<HazardEffectType>;\n  };\n  hazardCollision: {\n    hazardId: string;\n    targetId: string;\n    effect: Partial<HazardEffectType>;\n  };\n  [key: string]: unknown; // Index signature to satisfy Record<string, unknown>\n}\n\n/**\n * Manager class for environmental hazards in combat\n */\nexport class EnvironmentalHazardManager extends EventEmitter<HazardEvents> {\n  private static instance: EnvironmentalHazardManager;\n\n  // Store active hazards with their complete data\n  private hazards: Map<string, HazardEffectType> = new Map();\n\n  // Track moving hazards for efficient updates\n  private movingHazards: Map<string, MovingHazard> = new Map();\n\n  // Track splitting hazards\n  private splittingHazards: Map<string, SplittingHazard> = new Map();\n\n  // Track hazard lifecycle timers\n  private hazardTimers: Map<string, number> = new Map();\n\n  private constructor() {\n    super();\n  }\n\n  /**\n   * Get the singleton instance\n   */\n  public static getInstance(): EnvironmentalHazardManager {\n    if (!EnvironmentalHazardManager.instance) {\n      EnvironmentalHazardManager.instance = new EnvironmentalHazardManager();\n    }\n    return EnvironmentalHazardManager.instance;\n  }\n\n  /**\n   * Generate environmental hazards based on configuration\n   */\n  public generateHazards(\n    config: HazardGenerationConfig,\n    battlefieldSize: { width: number; height: number }\n  ): string[] {\n    const { minHazards, maxHazards, techLevel, includeAnomalies, difficulty, theme } = config;\n\n    // Determine number of hazards to generate\n    const count = Math.floor(Math.random() * (maxHazards - minHazards + 1)) + minHazards;\n\n    const hazardIds: string[] = [];\n\n    // Generate the hazards\n    for (let i = 0; i < count; i++) {\n      // Generate position within battlefield\n      const position = {\n        x: Math.random() * battlefieldSize.width,\n        y: Math.random() * battlefieldSize.height,\n      };\n\n      const hazardId = this.createHazard(position, techLevel, includeAnomalies, difficulty, theme);\n      if (hazardId) {\n        hazardIds.push(hazardId);\n      }\n    }\n\n    return hazardIds;\n  }\n\n  /**\n   * Create a single hazard based on parameters\n   */\n  private createHazard(\n    position: Position,\n    techLevel: number,\n    includeAnomalies: boolean,\n    difficulty: HazardGenerationConfig['difficulty'],\n    theme?: HazardGenerationConfig['theme']\n  ): string {\n    // Generate a unique ID for the hazard\n    const hazardId = `hazard-${Date.now()}-${Math.floor(Math.random() * 1000)}`;\n\n    // Determine hazard type based on theme and tech level\n    let hazardType: HazardEffectType['type'] = 'damage';\n\n    // Higher tech levels allow more complex hazards\n    if (techLevel >= 2) {\n      const types: HazardEffectType['type'][] = ['damage', 'field'];\n      if (techLevel >= 3) {\n        types.push('weather');\n        if (includeAnomalies && techLevel >= 4) {\n          types.push('anomaly');\n        }\n      }\n\n      // Theme influences hazard type probability\n      if (theme) {\n        switch (theme) {\n          case 'asteroid':\n            // More likely to be damage type\n            hazardType =\n              Math.random() < 0.7 ? 'damage' : types[Math.floor(Math.random() * types.length)];\n            break;\n          case 'nebula':\n            // More likely to be field type\n            hazardType =\n              Math.random() < 0.7 ? 'field' : types[Math.floor(Math.random() * types.length)];\n            break;\n          case 'blackHole':\n            // More likely to be field or anomaly type\n            if (types.includes('anomaly')) {\n              hazardType =\n                Math.random() < 0.7\n                  ? Math.random() < 0.5\n                    ? 'field'\n                    : 'anomaly'\n                  : types[Math.floor(Math.random() * types.length)];\n            } else {\n              hazardType =\n                Math.random() < 0.7 ? 'field' : types[Math.floor(Math.random() * types.length)];\n            }\n            break;\n          case 'solarFlare':\n            // More likely to be weather type\n            if (types.includes('weather')) {\n              hazardType =\n                Math.random() < 0.7 ? 'weather' : types[Math.floor(Math.random() * types.length)];\n            } else {\n              hazardType = types[Math.floor(Math.random() * types.length)];\n            }\n            break;\n          default:\n            hazardType = types[Math.floor(Math.random() * types.length)];\n        }\n      } else {\n        hazardType = types[Math.floor(Math.random() * types.length)];\n      }\n    }\n\n    // Based on the selected type, generate the appropriate hazard\n    let hazard: HazardEffectType;\n\n    // Calculate base values using difficulty and tech level\n    const baseStrength = this.calculateBaseStrength(difficulty, techLevel);\n    const baseDuration = this.calculateBaseDuration(difficulty, techLevel);\n    const baseRadius = this.calculateBaseRadius(difficulty, hazardType);\n\n    // Determine if hazard should move\n    const shouldMove = Math.random() < 0.3 * techLevel;\n\n    // Determine hazard visual tier based on tech level\n    const visualTier = Math.min(Math.ceil(techLevel / 2), 3) as 1 | 2 | 3;\n\n    // Generate the specific hazard based on type\n    switch (hazardType) {\n      case 'damage':\n        hazard = this.createDamageHazard(\n          hazardId,\n          position,\n          baseStrength,\n          baseDuration,\n          baseRadius,\n          visualTier,\n          shouldMove,\n          difficulty,\n          theme\n        );\n        break;\n      case 'field':\n        hazard = this.createFieldHazard(\n          hazardId,\n          position,\n          baseStrength,\n          baseDuration,\n          baseRadius,\n          visualTier,\n          shouldMove,\n          difficulty,\n          theme\n        );\n        break;\n      case 'weather':\n        hazard = this.createWeatherHazard(\n          hazardId,\n          position,\n          baseStrength,\n          baseDuration,\n          baseRadius,\n          visualTier,\n          shouldMove,\n          difficulty,\n          theme\n        );\n        break;\n      case 'anomaly':\n        hazard = this.createAnomalyHazard(\n          hazardId,\n          position,\n          baseStrength,\n          baseDuration,\n          baseRadius,\n          visualTier,\n          shouldMove,\n          difficulty,\n          theme\n        );\n        break;\n      default:\n        // Fallback to damage hazard\n        hazard = this.createDamageHazard(\n          hazardId,\n          position,\n          baseStrength,\n          baseDuration,\n          baseRadius,\n          visualTier,\n          shouldMove,\n          difficulty,\n          theme\n        );\n    }\n\n    // Store the hazard\n    this.hazards.set(hazardId, hazard);\n\n    // Set up lifecycle management\n    this.setupHazardLifecycle(hazardId, hazard);\n\n    // Emit creation event\n    this.emit('hazardCreated', {\n      hazardId,\n      type: hazard.type,\n      position,\n    });\n\n    return hazardId;\n  }\n\n  /**\n   * Calculate the base strength of a hazard based on difficulty and tech level\n   */\n  private calculateBaseStrength(\n    difficulty: HazardGenerationConfig['difficulty'],\n    techLevel: number\n  ): number {\n    const difficultyMultiplier = {\n      easy: 0.6,\n      normal: 1.0,\n      hard: 1.5,\n      extreme: 2.0,\n    }[difficulty];\n\n    // Scale between 10-100 based on difficulty and tech level\n    return Math.floor(10 + techLevel * 15 * difficultyMultiplier);\n  }\n\n  /**\n   * Calculate the base duration of a hazard based on difficulty and tech level\n   */\n  private calculateBaseDuration(\n    difficulty: HazardGenerationConfig['difficulty'],\n    techLevel: number\n  ): number {\n    const difficultyMultiplier = {\n      easy: 0.8,\n      normal: 1.0,\n      hard: 1.3,\n      extreme: 1.7,\n    }[difficulty];\n\n    // Scale between 10-60 seconds based on difficulty and tech level\n    return 10 + techLevel * 5 * difficultyMultiplier;\n  }\n\n  /**\n   * Calculate the base radius of a hazard based on difficulty and type\n   */\n  private calculateBaseRadius(\n    difficulty: HazardGenerationConfig['difficulty'],\n    type: HazardEffectType['type']\n  ): number {\n    const difficultyMultiplier = {\n      easy: 0.8,\n      normal: 1.0,\n      hard: 1.2,\n      extreme: 1.5,\n    }[difficulty];\n\n    let baseValue = 50; // Default base radius\n\n    // Adjust base radius by hazard type\n    switch (type) {\n      case 'damage':\n        baseValue = 40; // Smaller damage areas\n        break;\n      case 'field':\n        baseValue = 80; // Larger field effects\n        break;\n      case 'weather':\n        baseValue = 120; // Large weather effects\n        break;\n      case 'anomaly':\n        baseValue = 60; // Medium anomaly sizes\n        break;\n    }\n\n    return baseValue * difficultyMultiplier;\n  }\n\n  /**\n   * Set up hazard lifecycle management\n   */\n  private setupHazardLifecycle(hazardId: string, hazard: HazardEffectType): void {\n    // Set up timeout to remove the hazard when its duration expires\n    const timerId = window.setTimeout(() => {\n      this.removeHazard(hazardId);\n    }, hazard.duration * 1000);\n\n    // Store the timer ID for cleanup\n    this.hazardTimers.set(hazardId, timerId);\n\n    // Set up movement if the hazard is moving\n    if (hazard.isMoving) {\n      // Create moving behavior\n      const movingHazard: MovingHazard = {\n        speed: 10 + hazard.strength / 10, // Faster for stronger hazards\n        direction: Math.random() * Math.PI * 2, // Random direction\n        isHoming: Math.random() < 0.2, // 20% chance to be homing\n      };\n\n      this.movingHazards.set(hazardId, movingHazard);\n    }\n\n    // Determine if hazard can split (only for certain types and strengths)\n    if (\n      (hazard.type === 'damage' || hazard.type === 'anomaly') &&\n      hazard.strength > 50 &&\n      Math.random() < 0.3\n    ) {\n      const splittingHazard: SplittingHazard = {\n        canSplit: true,\n        maxSplits: Math.floor(hazard.strength / 30),\n        splitTrigger: Math.random() < 0.5 ? 'time' : 'damage',\n        childSizeReduction: 0.5 + Math.random() * 0.3,\n      };\n\n      this.splittingHazards.set(hazardId, splittingHazard);\n    }\n  }\n\n  /**\n   * Remove a hazard and clean up resources\n   */\n  public removeHazard(hazardId: string): void {\n    // Clear the lifecycle timer\n    if (this.hazardTimers.has(hazardId)) {\n      clearTimeout(this.hazardTimers.get(hazardId));\n      this.hazardTimers.delete(hazardId);\n    }\n\n    // Remove from tracking maps\n    this.hazards.delete(hazardId);\n    this.movingHazards.delete(hazardId);\n    this.splittingHazards.delete(hazardId);\n\n    // Emit removal event\n    this.emit('hazardRemoved', { hazardId });\n  }\n\n  /**\n   * Get all active hazards\n   */\n  public getActiveHazards(): HazardEffectType[] {\n    return Array.from(this.hazards.values());\n  }\n\n  /**\n   * Get a specific hazard by ID\n   */\n  public getHazard(hazardId: string): HazardEffectType | undefined {\n    return this.hazards.get(hazardId);\n  }\n\n  /**\n   * Clean up all hazards and timers\n   */\n  public cleanup(): void {\n    // Clear all timers\n    for (const timerId of this.hazardTimers.values()) {\n      clearTimeout(timerId);\n    }\n\n    // Clear all maps\n    this.hazards.clear();\n    this.movingHazards.clear();\n    this.splittingHazards.clear();\n    this.hazardTimers.clear();\n  }\n\n  /**\n   * Create a damage-based hazard\n   */\n  private createDamageHazard(\n    id: string,\n    _position: Position,\n    strength: number,\n    duration: number,\n    radius: number,\n    visualTier: 1 | 2 | 3,\n    isMoving: boolean,\n    difficulty: HazardGenerationConfig['difficulty'],\n    theme?: HazardGenerationConfig['theme']\n  ): DamageHazardEffect {\n    // Determine damage type based on theme and randomness\n    let damageType: DamageHazardEffect['damageType'] = 'physical';\n\n    if (theme === 'solarFlare') {\n      damageType = Math.random() < 0.8 ? 'thermal' : ResourceType.ENERGY;\n    } else if (theme === 'nebula') {\n      damageType = Math.random() < 0.7 ? 'corrosive' : ResourceType.ENERGY;\n    } else if (theme === 'blackHole') {\n      damageType = Math.random() < 0.8 ? ResourceType.ENERGY : 'physical';\n    } else {\n      // Random selection for default case\n      const types: DamageHazardEffect['damageType'][] = [\n        'physical',\n        ResourceType.ENERGY,\n        'corrosive',\n        'thermal',\n      ];\n      damageType = types[Math.floor(Math.random() * types.length)];\n    }\n\n    // Calculate penetration based on damage type and difficulty\n    let penetration = 0.1; // Base penetration\n    if (damageType === ResourceType.ENERGY) {\n      penetration += 0.2;\n    }\n    if (damageType === 'corrosive') {\n      penetration += 0.3;\n    }\n\n    // Adjust based on difficulty\n    if (difficulty === 'hard') {\n      penetration += 0.1;\n    }\n    if (difficulty === 'extreme') {\n      penetration += 0.2;\n    }\n\n    // Cap between 0.1 and 0.8\n    penetration = Math.max(0.1, Math.min(0.8, penetration));\n\n    // Calculate damage per second based on strength\n    const damagePerSecond = strength * (0.5 + visualTier * 0.2);\n\n    // Determine if damage has falloff\n    const hasFalloff = Math.random() < 0.7; // 70% chance of falloff\n\n    // Create the hazard effect\n    return {\n      id,\n      type: 'damage',\n      duration,\n      strength,\n      magnitude: strength,\n      name: this.generateHazardName('damage', damageType, visualTier),\n      description: this.generateHazardDescription('damage', damageType, strength, visualTier),\n      radius,\n      isMoving,\n      visualTier,\n      damageType,\n      penetration,\n      damagePerSecond,\n      hasFalloff,\n      active: true,\n      cooldown: 0,\n    };\n  }\n\n  /**\n   * Create a field-based hazard\n   */\n  private createFieldHazard(\n    id: string,\n    _position: Position,\n    strength: number,\n    duration: number,\n    radius: number,\n    visualTier: 1 | 2 | 3,\n    isMoving: boolean,\n    difficulty: HazardGenerationConfig['difficulty'],\n    theme?: HazardGenerationConfig['theme']\n  ): FieldHazardEffect {\n    // Determine field type based on theme and randomness\n    let fieldType: FieldHazardEffect['fieldType'] = 'gravity';\n\n    if (theme === 'blackHole') {\n      fieldType = Math.random() < 0.8 ? 'gravity' : 'temporal';\n    } else if (theme === 'nebula') {\n      fieldType = Math.random() < 0.6 ? 'radiation' : 'magnetic';\n    } else if (theme === 'solarFlare') {\n      fieldType = Math.random() < 0.7 ? 'radiation' : 'magnetic';\n    } else {\n      // Random selection for default case\n      const types: FieldHazardEffect['fieldType'][] = [\n        'gravity',\n        'magnetic',\n        'radiation',\n        'temporal',\n      ];\n      fieldType = types[Math.floor(Math.random() * types.length)];\n    }\n\n    // Calculate modifiers based on field type and strength\n    let speedModifier = 0;\n    let accuracyModifier = 0;\n    let shieldModifier = 0;\n\n    // Normalize strength to a -1 to 1 scale for modifiers\n    // Higher strength means stronger negative effects\n    const normalizedStrength = (strength / 100) * 2 - 1;\n\n    switch (fieldType) {\n      case 'gravity':\n        // Gravity affects speed more than other attributes\n        speedModifier = -0.5 * normalizedStrength;\n        accuracyModifier = -0.2 * normalizedStrength;\n        shieldModifier = -0.1 * normalizedStrength;\n        break;\n      case 'magnetic':\n        // Magnetic fields affect shields and accuracy\n        speedModifier = -0.1 * normalizedStrength;\n        accuracyModifier = -0.4 * normalizedStrength;\n        shieldModifier = -0.4 * normalizedStrength;\n        break;\n      case 'radiation':\n        // Radiation affects shields the most\n        speedModifier = -0.2 * normalizedStrength;\n        accuracyModifier = -0.2 * normalizedStrength;\n        shieldModifier = -0.6 * normalizedStrength;\n        break;\n      case 'temporal':\n        // Temporal fields have varied effects\n        speedModifier = -0.3 * normalizedStrength;\n        accuracyModifier = -0.3 * normalizedStrength;\n        shieldModifier = -0.3 * normalizedStrength;\n        break;\n    }\n\n    // Adjust based on difficulty\n    if (difficulty === 'hard') {\n      speedModifier *= 1.2;\n      accuracyModifier *= 1.2;\n      shieldModifier *= 1.2;\n    } else if (difficulty === 'extreme') {\n      speedModifier *= 1.5;\n      accuracyModifier *= 1.5;\n      shieldModifier *= 1.5;\n    } else if (difficulty === 'easy') {\n      speedModifier *= 0.7;\n      accuracyModifier *= 0.7;\n      shieldModifier *= 0.7;\n    }\n\n    // Visual distortion based on strength and field type\n    let distortionStrength = (strength / 100) * (0.5 + visualTier * 0.2);\n    if (fieldType === 'temporal') {\n      distortionStrength *= 1.5;\n    }\n    if (fieldType === 'gravity') {\n      distortionStrength *= 1.3;\n    }\n\n    // Create the hazard effect\n    return {\n      id,\n      type: 'field',\n      duration,\n      strength,\n      magnitude: strength,\n      name: this.generateHazardName('field', fieldType, visualTier),\n      description: this.generateHazardDescription('field', fieldType, strength, visualTier),\n      radius,\n      isMoving,\n      visualTier,\n      fieldType,\n      speedModifier,\n      accuracyModifier,\n      shieldModifier,\n      distortionStrength,\n      active: true,\n      cooldown: 0,\n    };\n  }\n\n  /**\n   * Create a weather-based hazard\n   */\n  private createWeatherHazard(\n    id: string,\n    _position: Position,\n    strength: number,\n    duration: number,\n    radius: number,\n    visualTier: 1 | 2 | 3,\n    isMoving: boolean,\n    difficulty: HazardGenerationConfig['difficulty'],\n    theme?: HazardGenerationConfig['theme']\n  ): WeatherHazardEffect {\n    // Determine weather type based on theme and randomness\n    let weatherType: WeatherHazardEffect['weatherType'] = 'cosmicDust';\n\n    if (theme === 'solarFlare') {\n      weatherType = Math.random() < 0.8 ? 'solarFlare' : 'ionStorm';\n    } else if (theme === 'nebula') {\n      weatherType = Math.random() < 0.7 ? 'cosmicDust' : 'ionStorm';\n    } else if (theme === 'asteroid') {\n      weatherType = Math.random() < 0.8 ? 'spaceDebris' : 'cosmicDust';\n    } else {\n      // Random selection for default case\n      const types: WeatherHazardEffect['weatherType'][] = [\n        'solarFlare',\n        'ionStorm',\n        'cosmicDust',\n        'spaceDebris',\n      ];\n      weatherType = types[Math.floor(Math.random() * types.length)];\n    }\n\n    // Calculate effect values based on strength\n    const effectStrength = strength / 100;\n\n    // Different weather types have different primary effects\n    let visibilityReduction = 0.2 * effectStrength;\n    let sensorReduction = 0.2 * effectStrength;\n    let communicationInterference = 0.2 * effectStrength;\n\n    switch (weatherType) {\n      case 'solarFlare':\n        communicationInterference = 0.5 * effectStrength;\n        sensorReduction = 0.4 * effectStrength;\n        visibilityReduction = 0.3 * effectStrength;\n        break;\n      case 'ionStorm':\n        sensorReduction = 0.5 * effectStrength;\n        communicationInterference = 0.4 * effectStrength;\n        visibilityReduction = 0.3 * effectStrength;\n        break;\n      case 'cosmicDust':\n        visibilityReduction = 0.6 * effectStrength;\n        sensorReduction = 0.3 * effectStrength;\n        communicationInterference = 0.2 * effectStrength;\n        break;\n      case 'spaceDebris':\n        visibilityReduction = 0.4 * effectStrength;\n        sensorReduction = 0.2 * effectStrength;\n        communicationInterference = 0.1 * effectStrength;\n        break;\n    }\n\n    // Adjust based on difficulty\n    if (difficulty === 'hard') {\n      visibilityReduction = Math.min(1, visibilityReduction * 1.3);\n      sensorReduction = Math.min(1, sensorReduction * 1.3);\n      communicationInterference = Math.min(1, communicationInterference * 1.3);\n    } else if (difficulty === 'extreme') {\n      visibilityReduction = Math.min(1, visibilityReduction * 1.6);\n      sensorReduction = Math.min(1, sensorReduction * 1.6);\n      communicationInterference = Math.min(1, communicationInterference * 1.6);\n    } else if (difficulty === 'easy') {\n      visibilityReduction *= 0.7;\n      sensorReduction *= 0.7;\n      communicationInterference *= 0.7;\n    }\n\n    // Particle density for visual effects, higher for better visual quality\n    const particleDensity = 30 + 70 * (strength / 100) * (visualTier / 3);\n\n    // Create the hazard effect\n    return {\n      id,\n      type: 'weather',\n      duration,\n      strength,\n      magnitude: strength,\n      name: this.generateHazardName('weather', weatherType, visualTier),\n      description: this.generateHazardDescription('weather', weatherType, strength, visualTier),\n      radius,\n      isMoving,\n      visualTier,\n      weatherType,\n      visibilityReduction,\n      sensorReduction,\n      communicationInterference,\n      particleDensity,\n      active: true,\n      cooldown: 0,\n    };\n  }\n\n  /**\n   * Create an anomaly-based hazard\n   */\n  private createAnomalyHazard(\n    id: string,\n    _position: Position,\n    strength: number,\n    duration: number,\n    radius: number,\n    visualTier: 1 | 2 | 3,\n    isMoving: boolean,\n    difficulty: HazardGenerationConfig['difficulty'],\n    theme?: HazardGenerationConfig['theme']\n  ): AnomalyHazardEffect {\n    // Determine anomaly type - high tech levels allow more exotic anomalies\n    let anomalyType: AnomalyHazardEffect['anomalyType'] = 'wormhole';\n\n    if (theme === 'blackHole') {\n      anomalyType = Math.random() < 0.7 ? 'wormhole' : 'dimensionalTear';\n    } else {\n      // All anomaly types have equal chance otherwise\n      const types: AnomalyHazardEffect['anomalyType'][] = [\n        'wormhole',\n        'temporalRift',\n        'quantumFluctuation',\n        'dimensionalTear',\n      ];\n      anomalyType = types[Math.floor(Math.random() * types.length)];\n    }\n\n    // Determine teleportation capabilities\n    const canTeleport =\n      anomalyType === 'wormhole' || (anomalyType === 'dimensionalTear' && Math.random() < 0.5);\n\n    // Effect properties based on type and strength\n    const normalizedStrength = strength / 100;\n\n    // Random effect chance increases with strength and difficulty\n    let randomEffectChance = normalizedStrength * 0.5;\n    if (difficulty === 'hard') {\n      randomEffectChance *= 1.3;\n    }\n    if (difficulty === 'extreme') {\n      randomEffectChance *= 1.6;\n    }\n    if (difficulty === 'easy') {\n      randomEffectChance *= 0.7;\n    }\n\n    // Cap random effect chance\n    randomEffectChance = Math.min(0.8, randomEffectChance);\n\n    // Determine if anomaly pulsates\n    const isPulsating = Math.random() < 0.7 || anomalyType === 'quantumFluctuation';\n\n    // Different visual effects based on anomaly type\n    let specialEffect = 'standard';\n    switch (anomalyType) {\n      case 'wormhole':\n        specialEffect = 'vortex';\n        break;\n      case 'temporalRift':\n        specialEffect = 'timewarp';\n        break;\n      case 'quantumFluctuation':\n        specialEffect = 'quantum';\n        break;\n      case 'dimensionalTear':\n        specialEffect = 'rift';\n        break;\n    }\n\n    // Higher visual tier adds suffixes to the effect name\n    if (visualTier === 2) {\n      specialEffect += '-enhanced';\n    }\n    if (visualTier === 3) {\n      specialEffect += '-advanced';\n    }\n\n    // Create the hazard effect\n    return {\n      id,\n      type: 'anomaly',\n      duration,\n      strength,\n      magnitude: strength,\n      name: this.generateHazardName('anomaly', anomalyType, visualTier),\n      description: this.generateHazardDescription('anomaly', anomalyType, strength, visualTier),\n      radius,\n      isMoving,\n      visualTier,\n      anomalyType,\n      canTeleport,\n      randomEffectChance,\n      isPulsating,\n      specialEffect,\n      active: true,\n      cooldown: 0,\n    };\n  }\n\n  /**\n   * Generate a hazard name based on its type and properties\n   */\n  private generateHazardName(\n    type: HazardEffectType['type'],\n    subType: string,\n    tier: number\n  ): string {\n    const tierPrefix = tier === 1 ? '' : tier === 2 ? 'Strong ' : 'Intense ';\n\n    switch (type) {\n      case 'damage': {\n        const damageNames: Record<string, string> = {\n          physical: 'Asteroid Field',\n          energy: 'Energy Surge',\n          corrosive: 'Corrosive Cloud',\n          thermal: 'Thermal Vent',\n        };\n        return `${tierPrefix}${damageNames[subType] || 'Damaging Hazard'}`;\n      }\n\n      case 'field': {\n        const fieldNames: Record<string, string> = {\n          gravity: 'Gravity Well',\n          magnetic: 'Magnetic Distortion',\n          radiation: 'Radiation Zone',\n          temporal: 'Time Distortion',\n        };\n        return `${tierPrefix}${fieldNames[subType] || 'Field Hazard'}`;\n      }\n\n      case 'weather': {\n        const weatherNames: Record<string, string> = {\n          solarFlare: 'Solar Flare',\n          ionStorm: 'Ion Storm',\n          cosmicDust: 'Cosmic Dust Cloud',\n          spaceDebris: 'Space Debris Field',\n        };\n        return `${tierPrefix}${weatherNames[subType] || 'Space Weather'}`;\n      }\n\n      case 'anomaly': {\n        const anomalyNames: Record<string, string> = {\n          wormhole: 'Wormhole',\n          temporalRift: 'Temporal Rift',\n          quantumFluctuation: 'Quantum Fluctuation',\n          dimensionalTear: 'Dimensional Tear',\n        };\n        return `${tierPrefix}${anomalyNames[subType] || 'Spatial Anomaly'}`;\n      }\n\n      default:\n        return `${tierPrefix}Environmental Hazard`;\n    }\n  }\n\n  /**\n   * Generate a description for a hazard based on its type and properties\n   */\n  private generateHazardDescription(\n    type: HazardEffectType['type'],\n    subType: string,\n    strength: number,\n    _tier: number\n  ): string {\n    const intensity = strength < 40 ? 'minor' : strength < 70 ? 'significant' : 'severe';\n\n    switch (type) {\n      case 'damage': {\n        const damageDesc: Record<string, string> = {\n          physical: `Causes ${intensity} physical damage to ships traveling through it.`,\n          energy: `Emits ${intensity} energy discharges that damage ship systems.`,\n          corrosive: `Contains ${intensity} corrosive particles that eat through ship hulls.`,\n          thermal: `Generates ${intensity} heat that can damage ship components.`,\n        };\n        return damageDesc[subType] || `Causes ${intensity} damage to ships.`;\n      }\n\n      case 'field': {\n        const fieldDesc: Record<string, string> = {\n          gravity: `Creates a ${intensity} gravitational pull that affects ship movement.`,\n          magnetic: `Generates ${intensity} magnetic interference that affects ship systems.`,\n          radiation: `Emits ${intensity} radiation that disrupts shields and sensors.`,\n          temporal: `Creates ${intensity} temporal distortions that affect ship systems in unpredictable ways.`,\n        };\n        return fieldDesc[subType] || `Generates a ${intensity} field effect in the area.`;\n      }\n\n      case 'weather': {\n        const weatherDesc: Record<string, string> = {\n          solarFlare: `A ${intensity} solar flare causing interference with communications and sensors.`,\n          ionStorm: `A ${intensity} ion storm that can disrupt ship systems and shields.`,\n          cosmicDust: `A ${intensity} cloud of cosmic dust that reduces visibility and sensor range.`,\n          spaceDebris: `A ${intensity} field of space debris that can damage ship hulls.`,\n        };\n        return weatherDesc[subType] || `Creates ${intensity} space weather conditions.`;\n      }\n\n      case 'anomaly': {\n        const anomalyDesc: Record<string, string> = {\n          wormhole: `A ${intensity} spatial anomaly that can teleport ships to other locations.`,\n          temporalRift: `A ${intensity} tear in spacetime that causes temporal distortions.`,\n          quantumFluctuation: `A ${intensity} quantum phenomenon that has unpredictable effects on ships.`,\n          dimensionalTear: `A ${intensity} breach between dimensions with strange properties.`,\n        };\n        return anomalyDesc[subType] || `A ${intensity} spatial anomaly with unknown effects.`;\n      }\n\n      default:\n        return `An environmental hazard with ${intensity} effects.`;\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/combat/ObjectDetectionSystem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/combat/ThreatAssessmentManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/combat/WarShipManagerImpl.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/effects/EffectLifecycleManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/effects/ParticleSystemManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_deltaTime' is defined but never used.","line":272,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":272,"endColumn":36}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  AdditiveBlending,\n  BufferAttribute,\n  BufferGeometry,\n  Color,\n  PerspectiveCamera,\n  Points,\n  Scene,\n  ShaderMaterial,\n  WebGLRenderer,\n} from 'three';\nimport { EntityPool, PooledEntity } from '../../lib/optimization/EntityPool';\nimport { Position } from '../../types/core/GameTypes';\n\ninterface Particle extends PooledEntity {\n  id: string;\n  active: boolean;\n  position: Position;\n  velocity: Position;\n  acceleration: Position;\n  size: number;\n  color: string;\n  opacity: number;\n  life: number;\n  maxLife: number;\n  reset(): void;\n}\n\ninterface ParticleSystemConfig {\n  maxParticles: number;\n  spawnRate: number;\n  position: Position;\n  spread: number;\n  initialVelocity: {\n    min: Position;\n    max: Position;\n  };\n  acceleration: Position;\n  size: {\n    min: number;\n    max: number;\n  };\n  life: {\n    min: number;\n    max: number;\n  };\n  color: string | string[];\n  blendMode?: 'normal' | 'additive';\n  quality: 'low' | 'medium' | 'high';\n}\n\nexport class ParticleSystemManager {\n  private static instance: ParticleSystemManager;\n  private particlePools: Map<string, Map<number, EntityPool<Particle>>>;\n  private systems: Map<string, ParticleSystem>;\n  private renderer: WebGLRenderer;\n  private scene: Scene;\n  private camera: PerspectiveCamera;\n  private frameCount: number = 0;\n  private readonly FRAME_SKIP_THRESHOLD = 2;\n\n  private constructor() {\n    this.particlePools = new Map();\n    this.systems = new Map();\n    this.renderer = new WebGLRenderer({ antialias: true });\n    this.scene = new Scene();\n    this.camera = new PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);\n    this.camera.position.z = 5;\n    this.initializeRenderer();\n\n    // Start cleanup interval\n    setInterval(() => this.cleanupInactiveSystems(), 5000);\n  }\n\n  public static getInstance(): ParticleSystemManager {\n    if (!ParticleSystemManager.instance) {\n      ParticleSystemManager.instance = new ParticleSystemManager();\n    }\n    return ParticleSystemManager.instance;\n  }\n\n  private initializeRenderer(): void {\n    this.renderer.setSize(window.innerWidth, window.innerHeight);\n    this.renderer.setPixelRatio(window.devicePixelRatio);\n  }\n\n  private getPoolSizeForQuality(quality: 'low' | 'medium' | 'high'): number {\n    switch (quality) {\n      case 'low':\n        return 100;\n      case 'medium':\n        return 500;\n      case 'high':\n        return 1000;\n      default:\n        return 500;\n    }\n  }\n\n  private getOrCreatePool(\n    systemId: string,\n    particleSize: number,\n    quality: 'low' | 'medium' | 'high'\n  ): EntityPool<Particle> {\n    if (!this.particlePools.has(systemId)) {\n      this.particlePools.set(systemId, new Map());\n    }\n\n    const sizePools = this.particlePools.get(systemId)!;\n    if (!sizePools.has(particleSize)) {\n      const poolSize = this.getPoolSizeForQuality(quality);\n      sizePools.set(particleSize, new EntityPool<Particle>(() => this.createParticle(), poolSize));\n    }\n\n    return sizePools.get(particleSize)!;\n  }\n\n  private createParticle(): Particle {\n    return {\n      id: `particle-${Date.now()}-${Math.random()}`,\n      active: false,\n      position: { x: 0, y: 0 },\n      velocity: { x: 0, y: 0 },\n      acceleration: { x: 0, y: 0 },\n      size: 1,\n      color: '#ffffff',\n      opacity: 1,\n      life: 1,\n      maxLife: 1,\n      reset(): void {\n        this.active = false;\n        this.position = { x: 0, y: 0 };\n        this.velocity = { x: 0, y: 0 };\n        this.acceleration = { x: 0, y: 0 };\n        this.opacity = 1;\n        this.life = this.maxLife;\n      },\n    };\n  }\n\n  public createParticleSystem(id: string, config: ParticleSystemConfig): void {\n    const pool = this.getOrCreatePool(id, config.size.max, config.quality);\n    const geometry = new BufferGeometry();\n    const material = this.createParticleMaterial(config);\n    const points = new Points(geometry, material);\n\n    const system = new ParticleSystem(pool, config, points, this.scene);\n    this.systems.set(id, system);\n    this.scene.add(points);\n  }\n\n  private createParticleMaterial(config: ParticleSystemConfig): ShaderMaterial {\n    return new ShaderMaterial({\n      uniforms: {\n        time: { value: 0 },\n        color: { value: new Color(config.color as string) },\n      },\n      vertexShader: `\n        attribute float size;\n        attribute float opacity;\n        attribute vec3 color;\n        varying float vOpacity;\n        varying vec3 vColor;\n        \n        void main() {\n          vOpacity = opacity;\n          vColor = color;\n          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n          gl_PointSize = size * (300.0 / -mvPosition.z);\n          gl_Position = projectionMatrix * mvPosition;\n        }\n      `,\n      fragmentShader: `\n        varying float vOpacity;\n        varying vec3 vColor;\n        \n        void main() {\n          vec2 xy = gl_PointCoord.xy - vec2(0.5);\n          float r = length(xy);\n          if (r > 0.5) discard;\n          \n          float glow = exp(-r * 3.0);\n          gl_FragColor = vec4(vColor, vOpacity * glow);\n        }\n      `,\n      transparent: true,\n      blending: config.blendMode === 'additive' ? AdditiveBlending : undefined,\n      depthWrite: false,\n    });\n  }\n\n  public update(deltaTime: number): void {\n    this.frameCount++;\n\n    // Skip frames for low priority systems when under performance pressure\n    const shouldUpdate = this.frameCount % this.FRAME_SKIP_THRESHOLD === 0;\n    if (!shouldUpdate) {\n      return;\n    }\n\n    this.systems.forEach(system => system.update(deltaTime));\n    this.renderer.render(this.scene, this.camera);\n  }\n\n  private cleanupInactiveSystems(): void {\n    const now = Date.now();\n    this.systems.forEach((system, id) => {\n      if (!system.hasActiveParticles() && now - system.getLastUpdateTime() > 5000) {\n        this.removeSystem(id);\n      }\n    });\n  }\n\n  public removeSystem(id: string): void {\n    const system = this.systems.get(id);\n    if (system) {\n      system.cleanup();\n      this.systems.delete(id);\n\n      // Clean up size-based pools\n      const sizePools = this.particlePools.get(id);\n      if (sizePools) {\n        sizePools.forEach(pool => pool.clear());\n        this.particlePools.delete(id);\n      }\n    }\n  }\n\n  public cleanup(): void {\n    this.systems.forEach(system => system.cleanup());\n    this.systems.clear();\n    this.particlePools.forEach(sizePools => {\n      sizePools.forEach(pool => pool.clear());\n    });\n    this.particlePools.clear();\n    this.renderer.dispose();\n    this.scene.clear();\n  }\n}\n\nclass ParticleSystem {\n  private pool: EntityPool<Particle>;\n  private config: ParticleSystemConfig;\n  private points: Points;\n  private scene: Scene;\n  private particles: Set<Particle>;\n  private lastSpawnTime: number;\n  private lastUpdateTime: number;\n\n  constructor(\n    pool: EntityPool<Particle>,\n    config: ParticleSystemConfig,\n    points: Points,\n    scene: Scene\n  ) {\n    this.pool = pool;\n    this.config = config;\n    this.points = points;\n    this.scene = scene;\n    this.particles = new Set();\n    this.lastSpawnTime = 0;\n    this.lastUpdateTime = Date.now();\n  }\n\n  public update(deltaTime: number): void {\n    this.lastUpdateTime = Date.now();\n    this.spawnParticles(deltaTime);\n    this.updateParticles(deltaTime);\n    this.updateGeometry();\n  }\n\n  private spawnParticles(_deltaTime: number): void {\n    const now = performance.now();\n    const spawnInterval = 1000 / this.config.spawnRate;\n\n    while (\n      now - this.lastSpawnTime >= spawnInterval &&\n      this.particles.size < this.config.maxParticles\n    ) {\n      this.spawnParticle();\n      this.lastSpawnTime += spawnInterval;\n    }\n  }\n\n  private spawnParticle(): void {\n    const particle = this.pool.acquire();\n    if (!particle) {\n      return;\n    }\n\n    particle.active = true;\n    particle.position = { ...this.config.position };\n    particle.velocity = {\n      x:\n        this.config.initialVelocity.min.x +\n        Math.random() * (this.config.initialVelocity.max.x - this.config.initialVelocity.min.x),\n      y:\n        this.config.initialVelocity.min.y +\n        Math.random() * (this.config.initialVelocity.max.y - this.config.initialVelocity.min.y),\n    };\n    particle.acceleration = { ...this.config.acceleration };\n    particle.size =\n      this.config.size.min + Math.random() * (this.config.size.max - this.config.size.min);\n    particle.life =\n      this.config.life.min + Math.random() * (this.config.life.max - this.config.life.min);\n    particle.maxLife = particle.life;\n\n    this.particles.add(particle);\n  }\n\n  private updateParticles(deltaTime: number): void {\n    this.particles.forEach(particle => {\n      particle.life -= deltaTime;\n      if (particle.life <= 0) {\n        this.particles.delete(particle);\n        this.pool.release(particle);\n        return;\n      }\n\n      particle.velocity.x += particle.acceleration.x * deltaTime;\n      particle.velocity.y += particle.acceleration.y * deltaTime;\n      particle.position.x += particle.velocity.x * deltaTime;\n      particle.position.y += particle.velocity.y * deltaTime;\n      particle.opacity = particle.life / particle.maxLife;\n    });\n  }\n\n  private updateGeometry(): void {\n    const positions = new Float32Array(this.particles.size * 3);\n    const sizes = new Float32Array(this.particles.size);\n    const opacities = new Float32Array(this.particles.size);\n    const colors = new Float32Array(this.particles.size * 3);\n\n    let i = 0;\n    this.particles.forEach(particle => {\n      positions[i * 3] = particle.position.x;\n      positions[i * 3 + 1] = particle.position.y;\n      positions[i * 3 + 2] = 0;\n\n      sizes[i] = particle.size;\n      opacities[i] = particle.opacity;\n\n      const color = new Color(particle.color);\n      colors[i * 3] = color.r;\n      colors[i * 3 + 1] = color.g;\n      colors[i * 3 + 2] = color.b;\n\n      i++;\n    });\n\n    const geometry = this.points.geometry as BufferGeometry;\n    geometry.setAttribute('position', new BufferAttribute(positions, 3));\n    geometry.setAttribute('size', new BufferAttribute(sizes, 1));\n    geometry.setAttribute('opacity', new BufferAttribute(opacities, 1));\n    geometry.setAttribute('color', new BufferAttribute(colors, 3));\n  }\n\n  public hasActiveParticles(): boolean {\n    return this.particles.size > 0;\n  }\n\n  public getLastUpdateTime(): number {\n    return this.lastUpdateTime;\n  }\n\n  public cleanup(): void {\n    this.particles.forEach(particle => {\n      this.pool.release(particle);\n    });\n    this.particles.clear();\n    this.scene.remove(this.points);\n    this.points.geometry.dispose();\n    (this.points.material as ShaderMaterial).dispose();\n  }\n}\n\n// Export singleton instance\nexport const particleSystemManager = ParticleSystemManager.getInstance();\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/exploration/ExplorationManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_dependencies' is defined but never used.","line":200,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":200,"endColumn":45},{"ruleId":"no-unsafe-optional-chaining","severity":2,"message":"Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.","line":244,"column":32,"nodeType":"ChainExpression","messageId":"unsafeOptionalChain","endLine":244,"endColumn":43},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_deltaTime' is defined but never used.","line":256,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":256,"endColumn":42}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ResourceType } from './../../types/resources/ResourceTypes';\n/**\n * @file ExplorationManager.ts\n * Implementation of the ExplorationManager that conforms to the BaseManager interface.\n *\n * This class handles:\n * 1. Star system management and ship assignments\n * 2. Sector scanning and discovery tracking\n * 3. Integration with ReconShipManager for ship operations\n * 4. Event-based communication with UI components\n */\n\nimport { v4 as uuidv4 } from 'uuid';\nimport { AbstractBaseManager } from '../../lib/managers/BaseManager';\nimport { ModuleType } from '../../types/buildings/ModuleTypes';\nimport { BaseEvent, EventType } from '../../types/events/EventTypes';\nimport { ReconShipManagerImpl, Ship } from './ReconShipManagerImpl';\n\n/**\n * Exploration event interface extending BaseEvent\n */\nexport interface ExplorationEvent extends BaseEvent {\n  type: EventType;\n  moduleId: string;\n  moduleType: ModuleType;\n  data: ExplorationEventData;\n}\n\n/**\n * Type guard for ExplorationEvent\n */\nexport function isExplorationEvent(event: unknown): event is ExplorationEvent {\n  if (!event || typeof event !== 'object') return false;\n  const e = event as ExplorationEvent;\n  return (\n    'type' in e &&\n    'moduleId' in e &&\n    'moduleType' in e &&\n    'data' in e &&\n    typeof e.type === 'string' &&\n    typeof e.moduleId === 'string' &&\n    typeof e.moduleType === 'string' &&\n    typeof e.data === 'object'\n  );\n}\n\n// Map exploration events to standard EventType enum\nexport const EXPLORATION_EVENTS = {\n  SECTOR_DISCOVERED: EventType.EXPLORATION_SECTOR_DISCOVERED,\n  SECTOR_SCANNED: EventType.EXPLORATION_SECTOR_SCANNED,\n  ANOMALY_DETECTED: EventType.EXPLORATION_ANOMALY_DETECTED,\n  RESOURCE_DETECTED: EventType.EXPLORATION_RESOURCE_DETECTED,\n  SCAN_STARTED: EventType.EXPLORATION_SCAN_STARTED,\n  SCAN_COMPLETED: EventType.EXPLORATION_SCAN_COMPLETED,\n  SCAN_FAILED: EventType.EXPLORATION_SCAN_FAILED,\n  SHIP_ASSIGNED: EventType.EXPLORATION_SHIP_ASSIGNED,\n  SHIP_UNASSIGNED: EventType.EXPLORATION_SHIP_UNASSIGNED,\n} as const;\n\n// Define a type for our exploration event data\nexport interface ExplorationEventData extends Record<string, unknown> {\n  sector?: Sector;\n  operation?: ScanOperation;\n  resource?: {\n    type: ResourceType;\n    amount: number;\n    quality: number;\n  };\n  anomaly?: Anomaly;\n  ship?: Ship;\n  reason?: string;\n  sectorId?: string;\n  shipId?: string;\n  anomalyId?: string;\n}\n\n// Define interfaces for the types used\nexport interface StarSystem {\n  id: string;\n  name: string;\n  type?: string;\n  resources?: ResourceType[];\n  status: 'unmapped' | 'mapped' | 'scanning' | 'analyzed';\n  assignedShips: string[];\n  position: {\n    x: number;\n    y: number;\n  };\n  lastScanned?: number;\n  discoveredAt?: number;\n}\n\nexport interface Sector {\n  id: string;\n  name: string;\n  coordinates: { x: number; y: number };\n  status: 'unmapped' | 'mapped' | 'scanning' | 'analyzed';\n  resourcePotential: number;\n  habitabilityScore: number;\n  anomalies: Anomaly[];\n  lastScanned?: number;\n  discoveredAt?: number;\n  resources?: Array<{\n    type: ResourceType;\n    amount: number;\n    quality?: number;\n  }>;\n}\n\nexport interface Anomaly {\n  id: string;\n  type: string;\n  severity: 'low' | 'medium' | 'high';\n  description: string;\n  position: { x: number; y: number };\n  discoveredAt: number;\n  investigatedAt?: number;\n  sectorId: string;\n  data?: Record<string, unknown>;\n}\n\nexport interface SystemSearchCriteria {\n  name?: string;\n  type?: string;\n  resources?: ResourceType[];\n  status?: string;\n}\n\nexport interface ScanOperation {\n  id: string;\n  sectorId: string;\n  shipId: string;\n  startTime: number;\n  estimatedDuration: number;\n  progress: number;\n  status: 'active' | 'completed' | 'failed' | 'cancelled';\n  results?: Record<string, unknown>;\n}\n\n/**\n * ExplorationManager implements the exploration system functionality,\n * managing star systems, sectors, anomalies, and coordinating with ship operations.\n */\nexport class ExplorationManager extends AbstractBaseManager<ExplorationEvent> {\n  // Maps to store exploration data\n  private sectors: Map<string, Sector> = new Map();\n  private anomalies: Map<string, Anomaly> = new Map();\n  private scanOperations: Map<string, ScanOperation> = new Map();\n\n  // References to other managers\n  private shipManager: ReconShipManagerImpl;\n\n  // Stats tracking\n  private stats = {\n    sectorsDiscovered: 0,\n    sectorsScanned: 0,\n    anomaliesDetected: 0,\n    resourcesDetected: 0,\n    activeScans: 0,\n    completedScans: 0,\n    failedScans: 0,\n  };\n\n  // Module ID for this manager (used in events)\n  private moduleId: string = uuidv4();\n\n  /**\n   * Creates a new ExplorationManager\n   *\n   * @param shipManager The ship manager to use for ship operations\n   * @param id Optional ID for the manager\n   */\n  constructor(shipManager: ReconShipManagerImpl, id?: string) {\n    super('ExplorationManager', id);\n    this.shipManager = shipManager;\n  }\n\n  /**\n   * Get the version of this manager implementation\n   */\n  protected getVersion(): string {\n    return '1.0.0';\n  }\n\n  /**\n   * Get statistics for this manager (for monitoring)\n   */\n  protected getStats(): Record<string, number | string> {\n    return {\n      ...this.stats,\n      sectorCount: this.sectors.size,\n      anomalyCount: this.anomalies.size,\n      activeScans: this.getActiveScans().length,\n    };\n  }\n\n  /**\n   * Initialize the exploration manager\n   */\n  protected async onInitialize(_dependencies?: Record<string, unknown>): Promise<void> {\n    console.warn('ExplorationManager initialized');\n\n    // Subscribe to ship-related events to update exploration data\n    this.subscribe(EventType.STATUS_CHANGED, this.handleShipStatusChange);\n  }\n\n  /**\n   * Handle updates on each tick\n   */\n  protected onUpdate(_deltaTime: number): void {\n    // Update active scan operations\n    this.updateScanOperations(_deltaTime);\n  }\n\n  /**\n   * Clean up resources\n   */\n  protected async onDispose(): Promise<void> {\n    // Clear all data\n    this.sectors.clear();\n    this.anomalies.clear();\n    this.scanOperations.clear();\n  }\n\n  /**\n   * Creates a standard ExplorationEvent\n   */\n  private createEvent(type: EventType, data: ExplorationEventData): ExplorationEvent {\n    return {\n      type,\n      timestamp: Date.now(),\n      moduleId: this.moduleId,\n      moduleType: 'exploration' as ModuleType,\n      data,\n    };\n  }\n\n  /**\n   * Handle ship status changes\n   */\n  private handleShipStatusChange = (event: ExplorationEvent): void => {\n    if (!isExplorationEvent(event)) return;\n\n    const { shipId, status } = event?.data;\n    if (!shipId || !status) return;\n\n    // If the ship is no longer available, cancel its scan operations\n    if (status === 'unavailable' || status === 'destroyed') {\n      this.cancelScanOperationsForShip(shipId as string);\n    }\n  };\n\n  /**\n   * Update active scan operations\n   */\n  private updateScanOperations(_deltaTime: number): void {\n    // Calculate progress for active scan operations\n    for (const [id, operation] of this.scanOperations.entries()) {\n      if (operation.status === 'active') {\n        const elapsedTime = Date.now() - operation.startTime;\n        const progress = Math.min(1, elapsedTime / operation.estimatedDuration);\n\n        // Update the operation with new progress\n        operation.progress = progress;\n\n        // Check if the operation is complete\n        if (progress >= 1) {\n          this.completeScanOperation(id);\n        }\n      }\n    }\n  }\n\n  /**\n   * Complete a scan operation\n   */\n  private completeScanOperation(operationId: string): void {\n    const operation = this.scanOperations.get(operationId);\n    if (!operation) return;\n\n    // Update the operation status\n    operation.status = 'completed';\n    operation.progress = 1;\n    this.stats.completedScans++;\n    this.stats.activeScans--;\n\n    // Update the sector\n    const sector = this.sectors.get(operation.sectorId);\n    if (sector) {\n      sector.status = 'analyzed';\n      sector.lastScanned = Date.now();\n\n      // Generate discoveries based on the scan\n      this.generateDiscoveries(sector);\n\n      // Emit a scan completed event\n      this.publishEvent(\n        this.createEvent(EXPLORATION_EVENTS.SCAN_COMPLETED, {\n          sector,\n          operation,\n        })\n      );\n    }\n  }\n\n  /**\n   * Generate discoveries (resources and anomalies) for a sector\n   */\n  private generateDiscoveries(sector: Sector): void {\n    // Logic to generate discoveries based on sector properties\n    // This is simplified for now\n\n    // Generate resources\n    const resourceCount = Math.floor(sector.resourcePotential * 5);\n    if (resourceCount > 0) {\n      const resources = [];\n      for (let i = 0; i < resourceCount; i++) {\n        const resource = {\n          type: this.getRandomResourceType(),\n          amount: Math.floor(Math.random() * 100) + 10,\n          quality: Math.random(),\n        };\n        resources.push(resource);\n        this.stats.resourcesDetected++;\n\n        // Emit a resource detected event\n        this.publishEvent(\n          this.createEvent(EXPLORATION_EVENTS.RESOURCE_DETECTED, {\n            resource,\n            sector,\n          })\n        );\n      }\n      sector.resources = resources;\n    }\n\n    // Generate anomalies\n    const anomalyChance = 0.3 + sector.habitabilityScore * 0.2;\n    if (Math.random() < anomalyChance) {\n      const anomaly: Anomaly = {\n        id: uuidv4(),\n        type: this.getRandomAnomalyType(),\n        severity: this.getRandomSeverity(),\n        description: 'Anomalous readings detected in this sector',\n        position: {\n          x: sector.coordinates.x + (Math.random() * 0.4 - 0.2),\n          y: sector.coordinates.y + (Math.random() * 0.4 - 0.2),\n        },\n        discoveredAt: Date.now(),\n        sectorId: sector.id,\n      };\n\n      sector.anomalies = [...(sector.anomalies ?? []), anomaly];\n      this.anomalies.set(anomaly.id, anomaly);\n      this.stats.anomaliesDetected++;\n\n      // Emit an anomaly detected event\n      this.publishEvent(\n        this.createEvent(EXPLORATION_EVENTS.ANOMALY_DETECTED, {\n          anomaly,\n          sector,\n          anomalyId: anomaly.id,\n        })\n      );\n    }\n  }\n\n  /**\n   * Start a new scan operation\n   */\n  private startScanOperation(shipId: string, sectorId: string): void {\n    const sector = this.sectors.get(sectorId);\n    if (!sector) return;\n\n    // Create a new scan operation\n    const operation: ScanOperation = {\n      id: uuidv4(),\n      sectorId,\n      shipId,\n      startTime: Date.now(),\n      estimatedDuration: this.calculateScanDuration(sector),\n      progress: 0,\n      status: 'active',\n    };\n\n    // Add the operation to the map\n    this.scanOperations.set(operation.id, operation);\n    this.stats.activeScans++;\n\n    // Update the sector status\n    sector.status = 'scanning';\n\n    // Emit a scan started event\n    this.publishEvent(\n      this.createEvent(EXPLORATION_EVENTS.SCAN_STARTED, {\n        operation,\n        sector,\n        sectorId,\n        shipId,\n      })\n    );\n  }\n\n  /**\n   * Cancel scan operations for a ship\n   */\n  private cancelScanOperationsForShip(shipId: string): void {\n    for (const [_id, operation] of this.scanOperations.entries()) {\n      if (operation.shipId === shipId && operation.status === 'active') {\n        operation.status = 'cancelled';\n        this.stats.activeScans--;\n\n        // Emit a scan failed event\n        this.publishEvent(\n          this.createEvent(EXPLORATION_EVENTS.SCAN_FAILED, {\n            operation,\n            reason: 'cancelled_by_ship',\n            sectorId: operation.sectorId,\n            shipId,\n          })\n        );\n      }\n    }\n  }\n\n  /**\n   * Calculate the duration for a scan operation\n   */\n  private calculateScanDuration(sector: Sector): number {\n    // Base duration is 30 seconds\n    let duration = 30000;\n\n    // Adjust for resource potential\n    duration += sector.resourcePotential * 10000;\n\n    // Adjust for habitability score\n    duration += sector.habitabilityScore * 5000;\n\n    // Add some randomness\n    duration *= 0.8 + Math.random() * 0.4;\n\n    return duration;\n  }\n\n  /**\n   * Get a random resource type\n   */\n  private getRandomResourceType(): ResourceType {\n    const resourceTypes = [\n      ResourceType.MINERALS,\n      ResourceType.ENERGY,\n      ResourceType.PLASMA,\n      ResourceType.GAS,\n      ResourceType.EXOTIC,\n      ResourceType.IRON,\n      ResourceType.COPPER,\n      ResourceType.TITANIUM,\n      ResourceType.URANIUM,\n      ResourceType.WATER,\n      ResourceType.HELIUM,\n      ResourceType.DEUTERIUM,\n      ResourceType.ANTIMATTER,\n      ResourceType.DARK_MATTER,\n      ResourceType.EXOTIC_MATTER,\n    ];\n    return resourceTypes[Math.floor(Math.random() * resourceTypes.length)];\n  }\n\n  /**\n   * Get a random anomaly type\n   */\n  private getRandomAnomalyType(): string {\n    const types = ['spatial', 'temporal', 'quantum', 'biological', 'gravitational', 'unknown'];\n    return types[Math.floor(Math.random() * types.length)];\n  }\n\n  /**\n   * Get a random severity level\n   */\n  private getRandomSeverity(): 'low' | 'medium' | 'high' {\n    const severities = ['low', 'medium', 'high'];\n    return severities[Math.floor(Math.random() * severities.length)] as 'low' | 'medium' | 'high';\n  }\n\n  /**\n   * Create or add a new sector\n   */\n  public addSector(sectorData: Omit<Sector, 'id' | 'anomalies' | 'discoveredAt'>): Sector {\n    const now = Date.now();\n    const id = uuidv4();\n\n    const sector: Sector = {\n      ...sectorData,\n      id,\n      anomalies: [],\n      discoveredAt: now,\n    };\n\n    this.sectors.set(sector.id, sector);\n    this.stats.sectorsDiscovered++;\n\n    // Emit a sector discovered event\n    this.publishEvent(\n      this.createEvent(EXPLORATION_EVENTS.SECTOR_DISCOVERED, {\n        sector,\n        sectorId: sector.id,\n      })\n    );\n\n    return sector;\n  }\n\n  /**\n   * Assign a ship to scan a sector\n   */\n  public assignShipToSector(shipId: string, sectorId: string): boolean {\n    const sector = this.sectors.get(sectorId);\n    if (!sector) return false;\n\n    // Check if ship exists and update its status using the ship manager\n    const ship = this.shipManager.getShipById(shipId);\n    if (!ship) return false;\n\n    // Assign the ship to the sector in the ship manager\n    if (!this.shipManager.assignShipToSector(shipId, sectorId)) {\n      return false;\n    }\n\n    // Start the scan operation\n    this.startScanOperation(shipId, sectorId);\n\n    // Emit a ship assigned event\n    this.publishEvent(\n      this.createEvent(EXPLORATION_EVENTS.SHIP_ASSIGNED, {\n        sectorId,\n        shipId,\n        sector,\n        ship,\n      })\n    );\n\n    return true;\n  }\n\n  /**\n   * Unassign a ship from scanning a sector\n   */\n  public unassignShip(shipId: string): boolean {\n    // Get the ship\n    const ship = this.shipManager.getShipById(shipId);\n    if (!ship) return false;\n\n    // Cancel any active scan operations\n    this.cancelScanOperationsForShip(shipId);\n\n    // Unassign the ship in the ship manager\n    if (!this.shipManager.unassignShip(shipId)) {\n      return false;\n    }\n\n    // Emit a ship unassigned event\n    this.publishEvent(\n      this.createEvent(EXPLORATION_EVENTS.SHIP_UNASSIGNED, {\n        shipId,\n        ship,\n      })\n    );\n\n    return true;\n  }\n\n  /**\n   * Get a sector by id\n   */\n  public getSector(sectorId: string): Sector | undefined {\n    return this.sectors.get(sectorId);\n  }\n\n  /**\n   * Get all sectors\n   */\n  public getAllSectors(): Sector[] {\n    return Array.from(this.sectors.values());\n  }\n\n  /**\n   * Get sectors by status\n   */\n  public getSectorsByStatus(status: Sector['status']): Sector[] {\n    return Array.from(this.sectors.values()).filter(sector => sector.status === status);\n  }\n\n  /**\n   * Get an anomaly by id\n   */\n  public getAnomaly(anomalyId: string): Anomaly | undefined {\n    return this.anomalies.get(anomalyId);\n  }\n\n  /**\n   * Get all anomalies\n   */\n  public getAllAnomalies(): Anomaly[] {\n    return Array.from(this.anomalies.values());\n  }\n\n  /**\n   * Get anomalies by sector\n   */\n  public getAnomaliesBySector(sectorId: string): Anomaly[] {\n    return Array.from(this.anomalies.values()).filter(anomaly => anomaly.sectorId === sectorId);\n  }\n\n  /**\n   * Get active scan operations\n   */\n  public getActiveScans(): ScanOperation[] {\n    return Array.from(this.scanOperations.values()).filter(op => op.status === 'active');\n  }\n\n  /**\n   * Get scan operations by sector\n   */\n  public getScanOperationsBySector(sectorId: string): ScanOperation[] {\n    return Array.from(this.scanOperations.values()).filter(op => op.sectorId === sectorId);\n  }\n\n  /**\n   * Get scan operations by ship\n   */\n  public getScanOperationsByShip(shipId: string): ScanOperation[] {\n    return Array.from(this.scanOperations.values()).filter(op => op.shipId === shipId);\n  }\n}\n\n// Mock event bus and ship manager for demonstration purposes\nconst shipManager = new ReconShipManagerImpl();\n\n// Export a singleton instance of the ExplorationManager\nexport const explorationManager = new ExplorationManager(shipManager);\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/exploration/ExplorationManagerImpl.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_dependencies' is defined but never used.","line":135,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":135,"endColumn":45},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_deltaTime' is defined but never used.","line":145,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":145,"endColumn":32}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @file ExplorationManagerImpl.ts\n * Implementation of the ExplorationManager that conforms to the BaseManager interface.\n *\n * This class handles:\n * 1. Star system management and ship assignments\n * 2. Sector scanning and discovery tracking\n * 3. Integration with ship managers for operation\n * 4. Event-based communication with UI components\n */\n\nimport { v4 as uuidv4 } from 'uuid';\nimport { EventBus } from '../../lib/events/EventBus';\nimport { AbstractBaseManager } from '../../lib/managers/BaseManager';\nimport { ModuleType } from '../../types/buildings/ModuleTypes';\nimport { BaseEvent, EventType } from '../../types/events/EventTypes';\nimport { ResourceType } from '../../types/resources/ResourceTypes';\n\n// Define Exploration specific event types\nexport enum ExplorationEvents {\n  SECTOR_DISCOVERED = 'EXPLORATION_SECTOR_DISCOVERED',\n  SECTOR_SCANNED = 'EXPLORATION_SECTOR_SCANNED',\n  ANOMALY_DETECTED = 'EXPLORATION_ANOMALY_DETECTED',\n  RESOURCE_DETECTED = 'EXPLORATION_RESOURCE_DETECTED',\n  SCAN_STARTED = 'EXPLORATION_SCAN_STARTED',\n  SCAN_COMPLETED = 'EXPLORATION_SCAN_COMPLETED',\n  SCAN_FAILED = 'EXPLORATION_SCAN_FAILED',\n  SHIP_ASSIGNED = 'EXPLORATION_SHIP_ASSIGNED',\n  SHIP_UNASSIGNED = 'EXPLORATION_SHIP_UNASSIGNED',\n  SYSTEM_CREATED = 'EXPLORATION_SYSTEM_CREATED',\n  SYSTEM_UPDATED = 'EXPLORATION_SYSTEM_UPDATED',\n}\n\n// Define interfaces for the types used\nexport interface StarSystem {\n  id: string;\n  name: string;\n  type?: string;\n  resources?: ResourceType[];\n  status: 'unmapped' | 'mapped' | 'scanning' | 'analyzed';\n  assignedShips: string[];\n  position: {\n    x: number;\n    y: number;\n  };\n  lastScanned?: number;\n  discoveredAt?: number;\n}\n\nexport interface SystemSearchCriteria {\n  name?: string;\n  type?: string;\n  resources?: ResourceType[];\n  status?: string;\n}\n\n// Ship interface to break circular dependency\nexport interface IShip {\n  id: string;\n  name: string;\n  type: string;\n  status: string;\n  assignedTo?: string;\n}\n\n// Ship manager interface to break circular dependency\nexport interface IShipManager {\n  getShipById(shipId: string): IShip | undefined;\n  updateShipStatus(shipId: string, status: string): void;\n  updateShipAssignment(shipId: string, systemId: string): void;\n  getAllShips(): IShip[];\n  getShipsByType(type: string): IShip[];\n  getShipsByStatus(status: string): IShip[];\n}\n\n// Event data interface\nexport interface ExplorationEventData extends Record<string, unknown> {\n  system?: StarSystem;\n  shipId?: string;\n  systemId?: string;\n  reason?: string;\n}\n\n/**\n * ExplorationManagerImpl implements the exploration manager functionality,\n * managing star systems and their assignments.\n */\nexport class ExplorationManagerImpl extends AbstractBaseManager<BaseEvent> {\n  private systems: Map<string, StarSystem> = new Map();\n\n  // Module ID for this manager (used in events)\n  private moduleId: string = uuidv4();\n\n  // Statistics\n  private stats = {\n    systemsCreated: 0,\n    systemsUpdated: 0,\n    shipsAssigned: 0,\n    shipsUnassigned: 0,\n  };\n\n  /**\n   * Create a new ExplorationManagerImpl\n   *\n   * @param eventBus The event bus for events\n   * @param shipManager The ship manager implementation\n   */\n  constructor(\n    private eventBus: EventBus<BaseEvent>,\n    private shipManager: IShipManager\n  ) {\n    super('ExplorationManagerImpl');\n  }\n\n  /**\n   * Get the version of this manager implementation\n   */\n  protected getVersion(): string {\n    return '1.0.0';\n  }\n\n  /**\n   * Get statistics for this manager (for monitoring)\n   */\n  protected getStats(): Record<string, number | string> {\n    return {\n      ...this.stats,\n      systemCount: this.systems.size,\n    };\n  }\n\n  /**\n   * Initialize the exploration manager\n   */\n  protected async onInitialize(_dependencies?: Record<string, unknown>): Promise<void> {\n    console.warn('ExplorationManagerImpl initialized');\n\n    // No initialization needed at this time\n    return Promise.resolve();\n  }\n\n  /**\n   * Handle updates on each tick\n   */\n  protected onUpdate(_deltaTime: number): void {\n    // Currently no time-based updates needed\n  }\n\n  /**\n   * Clean up resources\n   */\n  protected async onDispose(): Promise<void> {\n    this.systems.clear();\n    return Promise.resolve();\n  }\n\n  /**\n   * Create an event with proper structure\n   */\n  private createEvent(eventType: ExplorationEvents, data: ExplorationEventData): BaseEvent {\n    return {\n      type: eventType as unknown as EventType,\n      timestamp: Date.now(),\n      moduleId: this.moduleId,\n      moduleType: 'EXPLORATION' as ModuleType,\n      data,\n    };\n  }\n\n  /**\n   * Create a new star system in the exploration manager\n   */\n  public createStarSystem(system: {\n    id: string;\n    name: string;\n    status: 'unmapped' | 'mapped' | 'scanning' | 'analyzed';\n    position?: { x: number; y: number };\n  }): StarSystem {\n    const now = Date.now();\n\n    const newSystem: StarSystem = {\n      ...system,\n      position: system.position || { x: 0, y: 0 },\n      assignedShips: [],\n      discoveredAt: now,\n    };\n\n    this.systems.set(system.id, newSystem);\n    this.stats.systemsCreated++;\n\n    // Emit event\n    const event = this.createEvent(ExplorationEvents.SYSTEM_CREATED, {\n      system: newSystem,\n    });\n    this.publishEvent(event);\n\n    return newSystem;\n  }\n\n  /**\n   * Get a star system by ID\n   */\n  public getSystemById(systemId: string): StarSystem | undefined {\n    return this.systems.get(systemId);\n  }\n\n  /**\n   * Get all star systems\n   */\n  public getAllSystems(): StarSystem[] {\n    return Array.from(this.systems.values());\n  }\n\n  /**\n   * Add an existing star system to the exploration manager\n   */\n  public addStarSystem(system: {\n    id: string;\n    name: string;\n    type: ResourceType;\n    resources: ResourceType[];\n    status: 'unmapped' | 'mapped' | 'scanning' | 'analyzed';\n    position?: { x: number; y: number };\n  }): StarSystem {\n    const now = Date.now();\n\n    const newSystem: StarSystem = {\n      ...system,\n      position: system.position || { x: 0, y: 0 },\n      assignedShips: [],\n      discoveredAt: now,\n    };\n\n    this.systems.set(system.id, newSystem);\n    this.stats.systemsCreated++;\n\n    // Emit event\n    const event = this.createEvent(ExplorationEvents.SYSTEM_CREATED, {\n      system: newSystem,\n    });\n    this.publishEvent(event);\n\n    return newSystem;\n  }\n\n  /**\n   * Update a star system\n   */\n  public updateSystem(\n    systemId: string,\n    updates: Partial<Omit<StarSystem, 'id'>>\n  ): StarSystem | undefined {\n    const system = this.systems.get(systemId);\n    if (!system) {\n      return undefined;\n    }\n\n    const updatedSystem = {\n      ...system,\n      ...updates,\n    };\n\n    this.systems.set(systemId, updatedSystem);\n    this.stats.systemsUpdated++;\n\n    // Emit event\n    const event = this.createEvent(ExplorationEvents.SYSTEM_UPDATED, {\n      system: updatedSystem,\n    });\n    this.publishEvent(event);\n\n    return updatedSystem;\n  }\n\n  /**\n   * Assign a ship to a star system\n   */\n  public assignShipToSystem(shipId: string, systemId: string): boolean {\n    const system = this.systems.get(systemId);\n    if (!system) {\n      return false;\n    }\n\n    const ship = this.shipManager.getShipById(shipId);\n    if (!ship) {\n      return false;\n    }\n\n    // Update the system\n    system.assignedShips.push(shipId);\n    this.systems.set(systemId, system);\n\n    // Update the ship\n    this.shipManager.updateShipStatus(shipId, 'assigned');\n    this.shipManager.updateShipAssignment(shipId, systemId);\n\n    this.stats.shipsAssigned++;\n\n    // Emit event\n    const event = this.createEvent(ExplorationEvents.SHIP_ASSIGNED, {\n      system,\n      shipId,\n      systemId,\n    });\n    this.publishEvent(event);\n\n    return true;\n  }\n\n  /**\n   * Unassign a ship from a system\n   */\n  public unassignShipFromSystem(shipId: string, systemId: string): boolean {\n    const system = this.systems.get(systemId);\n    if (!system) {\n      return false;\n    }\n\n    // Check if the ship is actually assigned to this system\n    const shipIndex = system.assignedShips.indexOf(shipId);\n    if (shipIndex === -1) {\n      return false;\n    }\n\n    // Update the system\n    system.assignedShips.splice(shipIndex, 1);\n    this.systems.set(systemId, system);\n\n    // Update the ship\n    this.shipManager.updateShipStatus(shipId, 'idle');\n    this.shipManager.updateShipAssignment(shipId, '');\n\n    this.stats.shipsUnassigned++;\n\n    // Emit event\n    const event = this.createEvent(ExplorationEvents.SHIP_UNASSIGNED, {\n      system,\n      shipId,\n      systemId,\n    });\n    this.publishEvent(event);\n\n    return true;\n  }\n\n  /**\n   * Search star systems based on criteria\n   */\n  public searchSystems(criteria: SystemSearchCriteria): StarSystem[] {\n    const results: StarSystem[] = [];\n\n    for (const system of this.systems.values()) {\n      if (this.matchesCriteria(system, criteria)) {\n        results.push(system);\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Check if a system matches the search criteria\n   */\n  private matchesCriteria(system: StarSystem, criteria: SystemSearchCriteria): boolean {\n    // Check name\n    if (criteria.name && !system.name.toLowerCase().includes(criteria.name.toLowerCase())) {\n      return false;\n    }\n\n    // Check type\n    if (criteria.type && system.type !== criteria.type) {\n      return false;\n    }\n\n    // Check resources\n    if (criteria.resources && criteria.resources.length > 0) {\n      if (!system.resources) {\n        return false;\n      }\n\n      if (!criteria.resources.every(resource => system.resources?.includes(resource))) {\n        return false;\n      }\n    }\n\n    // Check status\n    if (criteria.status && system.status !== criteria.status) {\n      return false;\n    }\n\n    return true;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/exploration/ReconShipManagerImpl.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_dependencies' is defined but never used.","line":359,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":359,"endColumn":45},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_deltaTime' is defined but never used.","line":363,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":363,"endColumn":32}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @file ReconShipManagerImpl.ts\n * Implementation of the ReconShipManager for exploration ships.\n *\n * This file provides a basic implementation of ship management\n * functionality used by the ExplorationManager.\n */\n\nimport { v4 as uuidv4 } from 'uuid';\nimport { AbstractBaseManager } from '../../lib/managers/BaseManager';\nimport { ModuleType } from '../../types/buildings/ModuleTypes';\nimport { Position } from '../../types/core/GameTypes';\nimport { BaseEvent, EventType } from '../../types/events/EventTypes';\n\n/**\n * Interface for exploration ship data\n */\nexport interface Ship {\n  id: string;\n  name: string;\n  type: string;\n  status: 'idle' | 'assigned' | 'scanning' | 'returning';\n  assignedSectorId?: string;\n  position?: { x: number; y: number };\n  sensorRange?: number;\n  speed?: number;\n  efficiency?: number;\n  sectorId?: string;\n  capabilities?: {\n    canScan: boolean;\n    canSalvage: boolean;\n    canMine: boolean;\n    canJump: boolean;\n  };\n  stealth?: {\n    active: boolean;\n    level: number;\n    cooldown: number;\n  };\n  sensors?: {\n    range: number;\n    accuracy: number;\n    anomalyDetection: number;\n  };\n  discoveries?: {\n    mappedSectors: number;\n    anomaliesFound: number;\n    resourcesLocated: number;\n  };\n  [key: string]: unknown;\n}\n\nexport interface ExplorationTask {\n  id: string;\n  type: 'explore' | 'investigate' | 'evade';\n  target: {\n    id: string;\n    position: Position;\n  };\n  priority: number;\n  assignedAt: number;\n  specialization: 'mapping' | 'anomaly' | 'resource';\n  status: 'queued' | 'in-progress' | 'completed' | 'failed';\n  progress?: number;\n  threatLevel?: number;\n}\n\nexport interface ShipEvent extends BaseEvent {\n  type: EventType;\n  moduleId: string;\n  moduleType: ModuleType;\n  data: ShipEventData;\n}\n\nexport interface ShipEventData extends Record<string, unknown> {\n  shipId: string;\n  ship?: Ship;\n  sectorId?: string;\n  status?: Ship['status'];\n  position?: { x: number; y: number };\n}\n\n/**\n * Type guard for ShipEvent\n */\nexport function isShipEvent(event: unknown): event is ShipEvent {\n  if (!event || typeof event !== 'object') return false;\n  const e = event as ShipEvent;\n  return (\n    'type' in e &&\n    'moduleId' in e &&\n    'moduleType' in e &&\n    'data' in e &&\n    typeof e.type === 'string' &&\n    typeof e.moduleId === 'string' &&\n    typeof e.moduleType === 'string' &&\n    typeof e.data === 'object' &&\n    'shipId' in e.data &&\n    typeof e.data?.shipId === 'string'\n  );\n}\n\n/**\n * Implementation of the ship manager for exploration ships\n */\nexport class ReconShipManagerImpl extends AbstractBaseManager<ShipEvent> {\n  private ships: Map<string, Ship> = new Map();\n  private tasks: Map<string, ExplorationTask> = new Map();\n\n  constructor() {\n    super('ReconShipManager');\n    this.ships = new Map();\n    this.tasks = new Map();\n\n    // Add some sample ships\n    this.addShip({\n      id: uuidv4(),\n      name: 'Explorer I',\n      type: 'recon',\n      status: 'idle',\n      sensorRange: 5,\n      speed: 3,\n      efficiency: 0.8,\n      position: { x: 0, y: 0 },\n    });\n\n    this.addShip({\n      id: uuidv4(),\n      name: 'Explorer II',\n      type: 'recon',\n      status: 'idle',\n      sensorRange: 6,\n      speed: 2.5,\n      efficiency: 0.9,\n      position: { x: 0, y: 0 },\n    });\n\n    this.addShip({\n      id: uuidv4(),\n      name: 'Scout I',\n      type: 'scout',\n      status: 'idle',\n      sensorRange: 3,\n      speed: 5,\n      efficiency: 0.7,\n      position: { x: 0, y: 0 },\n    });\n  }\n\n  /**\n   * Add a new ship to the manager\n   * @param ship The ship to add\n   * @returns The added ship\n   */\n  public addShip(ship: Ship): Ship {\n    this.ships.set(ship.id, ship);\n    this.publish({\n      type: EventType.EXPLORATION_SHIP_REGISTERED,\n      moduleId: ship.id,\n      moduleType: 'ship' as ModuleType,\n      timestamp: Date.now(),\n      data: { shipId: ship.id, ship },\n    });\n    return ship;\n  }\n\n  /**\n   * Get a ship by its ID\n   * @param shipId The ID of the ship to get\n   * @returns The ship or undefined if not found\n   */\n  public getShipById(shipId: string): Ship | undefined {\n    return this.ships.get(shipId);\n  }\n\n  /**\n   * Get all ships\n   * @returns All ships\n   */\n  public getAllShips(): Ship[] {\n    return Array.from(this.ships.values());\n  }\n\n  /**\n   * Get ships by status\n   * @param status The status to filter by\n   * @returns Ships with the given status\n   */\n  public getShipsByStatus(status: string): Ship[] {\n    return Array.from(this.ships.values()).filter(ship => ship.status === status);\n  }\n\n  /**\n   * Update a ship's status\n   * @param shipId The ID of the ship to update\n   * @param status The new status\n   * @returns True if the ship was updated, false otherwise\n   */\n  public updateShipStatus(shipId: string, status: Ship['status']): void {\n    const ship = this.ships.get(shipId);\n    if (!ship) return;\n\n    ship.status = status;\n    this.ships.set(shipId, ship);\n\n    this.publish({\n      type: EventType.STATUS_CHANGED,\n      moduleId: shipId,\n      moduleType: 'ship' as ModuleType,\n      timestamp: Date.now(),\n      data: { shipId, status, ship },\n    });\n  }\n\n  /**\n   * Assign a ship to a sector\n   * @param shipId The ID of the ship to assign\n   * @param sectorId The ID of the sector to assign to\n   * @returns True if the ship was assigned, false otherwise\n   */\n  public assignShipToSector(shipId: string, sectorId: string): boolean {\n    const ship = this.ships.get(shipId);\n    if (!ship) return false;\n\n    ship.assignedSectorId = sectorId || undefined;\n    ship.status = 'scanning';\n    this.ships.set(shipId, ship);\n\n    this.publish({\n      type: EventType.MODULE_UPDATED,\n      moduleId: shipId,\n      moduleType: 'ship' as ModuleType,\n      timestamp: Date.now(),\n      data: { shipId, sectorId, ship },\n    });\n    return true;\n  }\n\n  /**\n   * Unassign a ship from its current assignment\n   * @param shipId The ID of the ship to unassign\n   * @returns True if the ship was unassigned, false otherwise\n   */\n  public unassignShip(shipId: string): boolean {\n    const ship = this.ships.get(shipId);\n    if (!ship) return false;\n\n    delete ship.assignedSectorId;\n    ship.status = 'idle';\n    this.ships.set(shipId, ship);\n\n    this.publish({\n      type: EventType.MODULE_UPDATED,\n      moduleId: shipId,\n      moduleType: 'ship' as ModuleType,\n      timestamp: Date.now(),\n      data: { shipId, ship },\n    });\n    return true;\n  }\n\n  public registerShip(ship: Ship): void {\n    this.ships.set(ship.id, ship);\n    this.publish({\n      type: EventType.EXPLORATION_SHIP_REGISTERED,\n      moduleId: ship.id,\n      moduleType: 'ship' as ModuleType,\n      timestamp: Date.now(),\n      data: { shipId: ship.id, ship },\n    });\n  }\n\n  public unregisterShip(shipId: string): void {\n    this.ships.delete(shipId);\n    this.publish({\n      type: EventType.EXPLORATION_SHIP_UNREGISTERED,\n      moduleId: shipId,\n      moduleType: 'ship' as ModuleType,\n      timestamp: Date.now(),\n      data: { shipId },\n    });\n  }\n\n  public assignExplorationTask(\n    shipId: string,\n    sectorId: string,\n    position: Position,\n    specialization: 'mapping' | 'anomaly' | 'resource'\n  ): void {\n    const task: ExplorationTask = {\n      id: uuidv4(),\n      type: 'explore',\n      target: {\n        id: sectorId,\n        position,\n      },\n      priority: 1,\n      assignedAt: Date.now(),\n      specialization,\n      status: 'queued',\n    };\n\n    this.tasks.set(task.id, task);\n    this.publish({\n      type: EventType.EXPLORATION_TASK_ASSIGNED,\n      moduleId: task.id,\n      moduleType: 'task' as ModuleType,\n      timestamp: Date.now(),\n      data: { shipId, task },\n    });\n  }\n\n  public update(deltaTime: number): void {\n    // Update all active tasks\n    for (const [taskId, task] of this.tasks) {\n      if (task.status === 'in-progress') {\n        // Simulate task progress\n        const progress = (task.progress ?? 0) + (deltaTime / 1000) * 0.1; // 10% per second\n        if (progress >= 1) {\n          task.status = 'completed';\n          this.publish({\n            type: EventType.EXPLORATION_TASK_COMPLETED,\n            moduleId: taskId,\n            moduleType: 'task' as ModuleType,\n            timestamp: Date.now(),\n            data: { shipId: taskId, task },\n          });\n          this.tasks.delete(taskId);\n        } else {\n          task.progress = progress;\n          this.publish({\n            type: EventType.EXPLORATION_TASK_PROGRESS,\n            moduleId: taskId,\n            moduleType: 'task' as ModuleType,\n            timestamp: Date.now(),\n            data: { shipId: taskId, task, progress },\n          });\n        }\n      }\n    }\n  }\n\n  public updateShipPosition(shipId: string, position: { x: number; y: number }): void {\n    const ship = this.ships.get(shipId);\n    if (!ship) return;\n\n    ship.position = position;\n    this.ships.set(shipId, ship);\n\n    this.publish({\n      type: EventType.EXPLORATION_POSITION_UPDATED,\n      moduleId: shipId,\n      moduleType: 'ship' as ModuleType,\n      timestamp: Date.now(),\n      data: { shipId, position, ship },\n    });\n  }\n\n  protected async onInitialize(_dependencies?: unknown): Promise<void> {\n    console.warn('ReconShipManager initialized');\n  }\n\n  protected onUpdate(_deltaTime: number): void {\n    // Update ship states if needed\n  }\n\n  protected async onDispose(): Promise<void> {\n    this.ships.clear();\n    this.tasks.clear();\n  }\n\n  protected getVersion(): string {\n    return '1.0.0';\n  }\n\n  protected getStats(): Record<string, number | string> {\n    return {\n      totalShips: this.ships.size,\n      idleShips: Array.from(this.ships.values()).filter(s => s.status === 'idle').length,\n      assignedShips: Array.from(this.ships.values()).filter(s => s.status === 'assigned').length,\n      scanningShips: Array.from(this.ships.values()).filter(s => s.status === 'scanning').length,\n      returningShips: Array.from(this.ships.values()).filter(s => s.status === 'returning').length,\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/factions/FactionBehaviorManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/factions/FactionRelationshipManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/factions/factionManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/game/AsteroidFieldManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_type' is defined but never used.","line":132,"column":40,"nodeType":null,"messageId":"unusedVar","endLine":132,"endColumn":45}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { TypedEventEmitter } from '../../lib/events/EventEmitter';\nimport { moduleEventBus } from '../../lib/modules/ModuleEvents';\nimport { ModuleType } from '../../types/buildings/ModuleTypes';\nimport { Position } from '../../types/core/GameTypes';\nimport { ResourceType } from './../../types/resources/ResourceTypes';\n\ninterface Hazard {\n  id: string;\n  type: 'asteroids' | 'debris' | 'radiation' | 'anomaly';\n  position: Position;\n  radius: number;\n  severity: 'low' | 'medium' | 'high';\n  effect: {\n    type: 'damage' | 'slow' | 'shield' | 'weapon';\n    value: number;\n  };\n  movement?: {\n    speed: number;\n    direction: number;\n  };\n  particles?: number;\n}\n\ninterface AsteroidField {\n  id: string;\n  position: Position;\n  radius: number;\n  density: number;\n  resources: Map<ResourceType, number>;\n  hazards: Array<Hazard>;\n  status: 'active' | 'depleted';\n  createdAt: number;\n  lastUpdated: number;\n}\n\ninterface AsteroidFieldState {\n  fields: Map<string, AsteroidField>;\n  activeHazards: Set<string>;\n  resourceNodes: Map<string, { fieldId: string; type: ResourceType; amount: number }>;\n}\n\ninterface AsteroidFieldEvents extends Record<string, unknown> {\n  fieldGenerated: { fieldId: string; position: Position };\n  fieldDepleted: { fieldId: string };\n  resourceDiscovered: { fieldId: string; resourceType: ResourceType; amount: number };\n  hazardCreated: { fieldId: string; hazard: Hazard };\n  hazardRemoved: { fieldId: string; hazardId: string };\n  resourceNodeRegistered: {\n    nodeId: string;\n    fieldId: string;\n    type: ResourceType;\n    position: Position;\n  };\n  resourceExtracted: { nodeId: string; type: ResourceType; amount: number; remaining: number };\n  shipHazardCollision: { shipId: string; hazardId: string; effect: Hazard['effect'] };\n  shipPositionUpdated: { shipId: string; position: Position; inField: boolean };\n}\n\nexport class AsteroidFieldManager extends TypedEventEmitter<AsteroidFieldEvents> {\n  private state: AsteroidFieldState = {\n    fields: new Map(),\n    activeHazards: new Set(),\n    resourceNodes: new Map(),\n  };\n  private updateInterval: NodeJS.Timeout | null = null;\n\n  constructor() {\n    super();\n    this.setupEventListeners();\n    this.startUpdateLoop();\n\n    // Debug logging\n    console.warn('[AsteroidFieldManager] Initialized');\n  }\n\n  private setupEventListeners(): void {\n    moduleEventBus.subscribe(\n      'MODULE_ACTIVATED',\n      (event: { moduleType: string; moduleId: string }) => {\n        if (event?.moduleType === 'asteroidField') {\n          this.handleModuleActivation(event?.moduleId);\n        }\n      }\n    );\n\n    moduleEventBus.subscribe(\n      'MODULE_DEACTIVATED',\n      (event: { moduleType: string; moduleId: string }) => {\n        if (event?.moduleType === 'asteroidField') {\n          this.handleModuleDeactivation(event?.moduleId);\n        }\n      }\n    );\n  }\n\n  private startUpdateLoop(): void {\n    if (this.updateInterval) {\n      clearInterval(this.updateInterval);\n    }\n\n    this.updateInterval = setInterval(() => {\n      this.updateFields();\n    }, 1000); // Update every second\n  }\n\n  private updateFields(): void {\n    const now = Date.now();\n    this.state.fields.forEach((field, fieldId) => {\n      if (field.status === 'depleted') {\n        return;\n      }\n\n      // Update hazards\n      field.hazards = field.hazards.filter(hazard => {\n        const isActive = this.state.activeHazards.has(hazard.id);\n        if (!isActive) {\n          this.emit('hazardRemoved', { fieldId, hazardId: hazard.id });\n        }\n        return isActive;\n      });\n\n      // Generate new hazards if needed\n      if (field.hazards.length < Math.ceil(field.density * 5)) {\n        const hazard = this.generateHazard(field);\n        field.hazards.push(hazard);\n        this.state.activeHazards.add(hazard.id);\n        this.emit('hazardCreated', { fieldId, hazard });\n      }\n\n      // Update resources\n      let totalResources = 0;\n      field.resources.forEach((amount, _type) => {\n        totalResources += amount;\n      });\n\n      if (totalResources <= 0) {\n        field.status = 'depleted';\n        this.emit('fieldDepleted', { fieldId });\n      }\n\n      field.lastUpdated = now;\n    });\n  }\n\n  private generateHazard(field: AsteroidField): Hazard {\n    const angle = Math.random() * Math.PI * 2;\n    const distance = Math.random() * field.radius;\n    const position = {\n      x: field.position.x + Math.cos(angle) * distance,\n      y: field.position.y + Math.sin(angle) * distance,\n    };\n\n    return {\n      id: `hazard-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      type: 'asteroids',\n      position,\n      radius: 20 + Math.random() * 30,\n      severity: Math.random() > 0.7 ? 'high' : Math.random() > 0.4 ? 'medium' : 'low',\n      effect: {\n        type: 'damage',\n        value: 10 + Math.random() * 20,\n      },\n      movement: {\n        speed: 0.5 + Math.random(),\n        direction: Math.random() * Math.PI * 2,\n      },\n    };\n  }\n\n  public generateField(position: Position, radius: number, density: number): string {\n    const fieldId = `field-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n\n    const field: AsteroidField = {\n      id: fieldId,\n      position,\n      radius,\n      density: Math.max(0.1, Math.min(1, density)),\n      resources: new Map(),\n      hazards: [],\n      status: 'active',\n      createdAt: Date.now(),\n      lastUpdated: Date.now(),\n    };\n\n    // Generate initial resources\n    const resourceTypes: ResourceType[] = [\n      ResourceType.MINERALS,\n      ResourceType.GAS,\n      ResourceType.EXOTIC,\n    ];\n    resourceTypes.forEach(type => {\n      const amount = Math.floor(1000 + Math.random() * 4000 * density);\n      field.resources.set(type, amount);\n\n      const nodeId = `node-${fieldId}-${type}`;\n      this.state.resourceNodes.set(nodeId, {\n        fieldId,\n        type,\n        amount,\n      });\n\n      this.emit('resourceDiscovered', {\n        fieldId,\n        resourceType: type,\n        amount,\n      });\n    });\n\n    // Generate initial hazards\n    for (let i = 0; i < Math.ceil(density * 5); i++) {\n      const hazard = this.generateHazard(field);\n      field.hazards.push(hazard);\n      this.state.activeHazards.add(hazard.id);\n      this.emit('hazardCreated', { fieldId, hazard });\n    }\n\n    this.state.fields.set(fieldId, field);\n    this.emit('fieldGenerated', { fieldId, position });\n\n    // Debug logging\n    console.warn(\n      `[AsteroidFieldManager] Generated field ${fieldId} at (${position.x}, ${position.y}) with density ${density}`\n    );\n\n    return fieldId;\n  }\n\n  public getField(fieldId: string): AsteroidField | undefined {\n    return this.state.fields.get(fieldId);\n  }\n\n  public getAllFields(): AsteroidField[] {\n    return Array.from(this.state.fields.values());\n  }\n\n  public getActiveFields(): AsteroidField[] {\n    return Array.from(this.state.fields.values()).filter(field => field.status === 'active');\n  }\n\n  public getResourceNodes(): Map<string, { fieldId: string; type: ResourceType; amount: number }> {\n    return new Map(this.state.resourceNodes);\n  }\n\n  public extractResource(nodeId: string, amount: number): boolean {\n    const node = this.state.resourceNodes.get(nodeId);\n    if (!node || amount <= 0) {\n      return false;\n    }\n\n    const field = this.state.fields.get(node.fieldId);\n    if (!field || field.status === 'depleted') {\n      return false;\n    }\n\n    const currentAmount = field.resources.get(node.type) ?? 0;\n    if (currentAmount < amount) {\n      return false;\n    }\n\n    field.resources.set(node.type, currentAmount - amount);\n    node.amount = currentAmount - amount;\n\n    // Debug logging\n    console.warn(`[AsteroidFieldManager] Extracted ${amount} ${node.type} from node ${nodeId}`);\n\n    return true;\n  }\n\n  private handleModuleActivation(moduleId: string): void {\n    console.warn(`[AsteroidFieldManager] Module ${moduleId} activated`);\n  }\n\n  private handleModuleDeactivation(moduleId: string): void {\n    console.warn(`[AsteroidFieldManager] Module ${moduleId} deactivated`);\n  }\n\n  public cleanup(): void {\n    if (this.updateInterval) {\n      clearInterval(this.updateInterval);\n      this.updateInterval = null;\n    }\n\n    this.state.fields.clear();\n    this.state.activeHazards.clear();\n    this.state.resourceNodes.clear();\n\n    console.warn('[AsteroidFieldManager] Cleaned up');\n  }\n\n  public registerResourceNode(fieldId: string, _type: ResourceType): string {\n    const field = this.state.fields.get(fieldId);\n    if (!field) {\n      return '';\n    }\n\n    const nodeId = `node-${fieldId}-${_type}-${Date.now()}`;\n    const amount = field.resources.get(_type) ?? 0;\n\n    this.state.resourceNodes.set(nodeId, {\n      fieldId,\n      type: _type,\n      amount,\n    });\n\n    // Register with mining system\n    moduleEventBus.emit({\n      type: 'MODULE_ACTIVATED',\n      moduleId: nodeId,\n      moduleType: 'mineral' as ModuleType,\n      timestamp: Date.now(),\n      data: {\n        id: nodeId,\n        type: _type,\n        position: field.position,\n        amount,\n        thresholds: {\n          min: Math.floor(amount * 0.2),\n          max: amount,\n        },\n      },\n    });\n\n    this.emit('resourceNodeRegistered', {\n      nodeId,\n      fieldId,\n      type: _type,\n      position: field.position,\n    });\n\n    console.warn(`[AsteroidFieldManager] Registered resource node ${nodeId} for field ${fieldId}`);\n    return nodeId;\n  }\n\n  public handleMiningTask(nodeId: string, shipId: string, amount: number): boolean {\n    const node = this.state.resourceNodes.get(nodeId);\n    if (!node) {\n      console.warn(`[AsteroidFieldManager] Node ${nodeId} not found`);\n      return false;\n    }\n\n    const field = this.state.fields.get(node.fieldId);\n    if (!field || field.status === 'depleted') {\n      console.warn(`[AsteroidFieldManager] Field ${node.fieldId} not found`);\n      return false;\n    }\n\n    const extracted = this.extractResource(nodeId, amount);\n    if (!extracted) {\n      console.warn(\n        `[AsteroidFieldManager] Mining task failed: Could not extract ${amount} resources from node ${nodeId}`\n      );\n      return false;\n    }\n\n    const remaining = field.resources.get(node.type) ?? 0;\n    this.emit('resourceExtracted', {\n      nodeId,\n      type: node.type,\n      amount,\n      remaining,\n    });\n\n    // Update mining system\n    moduleEventBus.emit({\n      type: 'RESOURCE_TRANSFERRED',\n      moduleId: nodeId,\n      moduleType: 'mineral' as ModuleType,\n      timestamp: Date.now(),\n      data: {\n        shipId,\n        amount,\n        remaining,\n        resourceType: node.type,\n      },\n    });\n\n    console.warn(\n      `[AsteroidFieldManager] Ship ${shipId} extracted ${amount} of ${node.type} from node ${nodeId}`\n    );\n    return true;\n  }\n\n  public getNodeThresholds(nodeId: string): { min: number; max: number } | null {\n    const node = this.state.resourceNodes.get(nodeId);\n    if (!node) {\n      return null;\n    }\n\n    const field = this.state.fields.get(node.fieldId);\n    if (!field) {\n      return null;\n    }\n\n    const amount = field.resources.get(node.type) ?? 0;\n    return {\n      min: Math.floor(amount * 0.2),\n      max: amount,\n    };\n  }\n\n  public handleShipMovement(shipId: string, position: Position): void {\n    let inField = false;\n    let nearestHazard: Hazard | null = null;\n    let nearestDistance = Infinity;\n\n    // Convert Map entries to array to avoid MapIterator error\n    const fieldValues = Array.from(this.state.fields.values());\n    for (const field of fieldValues) {\n      // Calculate distance to field center\n      const distanceToField = Math.sqrt(\n        Math.pow(position.x - field.position.x, 2) + Math.pow(position.y - field.position.y, 2)\n      );\n\n      if (distanceToField <= field.radius) {\n        inField = true;\n\n        // Find nearest hazard in field\n        for (const hazard of field.hazards) {\n          const distanceToHazard = Math.sqrt(\n            Math.pow(position.x - hazard.position.x, 2) +\n              Math.pow(position.y - hazard.position.y, 2)\n          );\n\n          if (distanceToHazard < nearestDistance) {\n            nearestDistance = distanceToHazard;\n            nearestHazard = hazard;\n          }\n        }\n      }\n    }\n\n    // Emit position update\n    this.emit('shipPositionUpdated', { shipId, position, inField });\n\n    // Handle hazard collision if ship is near a hazard\n    if (nearestHazard && nearestDistance <= nearestHazard.radius) {\n      this.handleHazardCollision(shipId, nearestHazard);\n    }\n\n    console.warn(\n      `[AsteroidFieldManager] Ship ${shipId} position updated: (${position.x}, ${position.y}), in field: ${inField}`\n    );\n  }\n\n  public calculateAvoidanceVector(shipId: string, position: Position): Position | null {\n    let nearestHazard: Hazard | null = null;\n    let nearestDistance = Infinity;\n\n    // Find nearest hazard across all fields\n    // Convert Map entries to array to avoid MapIterator error\n    const fieldValues = Array.from(this.state.fields.values());\n    for (const field of fieldValues) {\n      for (const hazard of field.hazards) {\n        const distance = Math.sqrt(\n          Math.pow(position.x - hazard.position.x, 2) + Math.pow(position.y - hazard.position.y, 2)\n        );\n\n        if (distance < nearestDistance) {\n          nearestDistance = distance;\n          nearestHazard = hazard;\n        }\n      }\n    }\n\n    // If no hazard is nearby or distance is safe, return null\n    if (!nearestHazard || nearestDistance > nearestHazard.radius * 1.5) {\n      return null;\n    }\n\n    // Calculate avoidance vector\n    const dx = position.x - nearestHazard.position.x;\n    const dy = position.y - nearestHazard.position.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    // Return position that moves away from hazard\n    const avoidanceVector = {\n      x: position.x + (dx / distance) * 50, // Move 50 units away\n      y: position.y + (dy / distance) * 50,\n    };\n\n    console.warn(`[AsteroidFieldManager] Calculated avoidance vector for ship ${shipId}`);\n\n    return avoidanceVector;\n  }\n\n  private handleHazardCollision(shipId: string, hazard: Hazard): void {\n    this.emit('shipHazardCollision', {\n      shipId,\n      hazardId: hazard.id,\n      effect: hazard.effect,\n    });\n\n    // Update hazard state if needed\n    if (hazard.type === 'asteroids') {\n      // Asteroids might break apart or move after collision\n      const newPosition = {\n        x: hazard.position.x + (Math.random() - 0.5) * 20,\n        y: hazard.position.y + (Math.random() - 0.5) * 20,\n      };\n\n      hazard.position = newPosition;\n\n      // Sometimes create smaller hazards after collision\n      if (Math.random() < 0.3 && hazard.radius > 20) {\n        const newHazard: Hazard = {\n          id: `${hazard.id}_fragment_${Date.now()}`,\n          type: hazard.type,\n          severity: hazard.severity,\n          radius: hazard.radius * 0.5,\n          position: newPosition,\n          effect: hazard.effect,\n          movement: hazard.movement,\n          particles: hazard.particles,\n        };\n\n        // Add to parent field\n        // Convert Map entries to array to avoid MapIterator error\n        const fieldEntries = Array.from(this.state.fields.entries());\n        for (const [fieldId, field] of fieldEntries) {\n          if (field.hazards.some(h => h.id === hazard.id)) {\n            field.hazards.push(newHazard);\n            this.state.activeHazards.add(newHazard.id);\n            this.emit('hazardCreated', { fieldId, hazard: newHazard });\n            break;\n          }\n        }\n      }\n    }\n\n    console.warn(`[AsteroidFieldManager] Ship ${shipId} collided with hazard ${hazard.id}`);\n  }\n\n  public getShipBonuses(\n    shipId: string,\n    position: Position\n  ): {\n    speedMultiplier: number;\n    hazardResistance: number;\n    miningEfficiency: number;\n  } {\n    const defaultBonuses = {\n      speedMultiplier: 1.0,\n      hazardResistance: 1.0,\n      miningEfficiency: 1.0,\n    };\n\n    // Check if ship is in any asteroid field\n    for (const field of Array.from(this.state.fields.values())) {\n      if (field.status === 'depleted') {\n        continue;\n      }\n\n      const distanceToField = Math.sqrt(\n        Math.pow(position.x - field.position.x, 2) + Math.pow(position.y - field.position.y, 2)\n      );\n\n      if (distanceToField <= field.radius) {\n        // Apply field density effects\n        defaultBonuses.speedMultiplier *= Math.max(0.5, 1 - field.density * 0.5);\n        defaultBonuses.hazardResistance *= Math.max(0.6, 1 - field.density * 0.4);\n        defaultBonuses.miningEfficiency *= 1 + field.density * 0.3;\n\n        // Log the bonuses\n        console.warn(`[AsteroidFieldManager] Ship ${shipId} field bonuses:\n          Speed: ${defaultBonuses.speedMultiplier.toFixed(2)}x\n          Hazard Resistance: ${defaultBonuses.hazardResistance.toFixed(2)}x\n          Mining Efficiency: ${defaultBonuses.miningEfficiency.toFixed(2)}x`);\n\n        break; // Only apply bonuses from one field\n      }\n    }\n\n    return defaultBonuses;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/game/AutomationManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/game/GameLoopManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/game/ParticleSystemManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/game/ResourceManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_dependencies' is defined but never used.","line":260,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":260,"endColumn":45}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  DEFAULT_PRODUCTION_RATES,\n  PRODUCTION_INTERVALS,\n  RESOURCE_MANAGER_CONFIG,\n  RESOURCE_PRIORITIES,\n  RESOURCE_THRESHOLDS,\n  STORAGE_EFFICIENCY,\n  TRANSFER_CONFIG,\n} from '../../config/resource/ResourceConfig';\nimport { AbstractBaseManager } from '../../lib/managers/BaseManager';\nimport { EventHandler } from '../../types/events/EventEmitterInterface';\nimport { BaseEvent, EventType } from '../../types/events/EventTypes';\nimport {\n  ResourceConsumption as ImportedResourceConsumption,\n  ResourceFlow as ImportedResourceFlow,\n  ResourceProduction as ImportedResourceProduction,\n  ResourceTransfer as ImportedResourceTransfer,\n  ResourceState,\n  ResourceThreshold,\n  ResourceTypeHelpers,\n  ResourceTypeString,\n} from '../../types/resources/ResourceTypes';\nimport {\n  ensureEnumResourceType,\n  ensureStringResourceType,\n  toEnumResourceType,\n} from '../../utils/resources/ResourceTypeMigration';\nimport { resourcePerformanceMonitor } from '../resource/ResourcePerformanceMonitor';\nimport { ResourceType } from './../../types/resources/ResourceTypes';\n\n// Define ResourceManagerConfig interface based on the config structure\ninterface ResourceManagerConfig {\n  defaultResourceLimits?: Record<ResourceType, { min: number; max: number }>;\n  // Add other config properties as needed\n}\n\n// Update TRANSFER_CONFIG type to include MIN_INTERVAL\nconst TRANSFER_CONFIG_WITH_MIN = {\n  ...TRANSFER_CONFIG,\n  MIN_INTERVAL: 500, // Minimum 500ms between transfers\n};\n\n/**\n * Resource operation error types\n */\ntype ResourceError = {\n  code: 'INVALID_RESOURCE' | 'INSUFFICIENT_RESOURCES' | 'INVALID_TRANSFER' | 'THRESHOLD_VIOLATION';\n  message: string;\n  details?: unknown;\n};\n\n/**\n * Resource optimization strategies\n */\ninterface OptimizationStrategy {\n  id: string;\n  type: 'production' | 'consumption' | 'transfer';\n  priority: number;\n  condition: () => boolean;\n  apply: () => void;\n}\n\n/**\n * Resource manager event interface\n */\nexport interface ResourceManagerEvent extends BaseEvent {\n  type: EventType;\n  resourceType: ResourceType;\n  amount?: number;\n  source?: string;\n  target?: string;\n  details?: Record<string, unknown>;\n}\n\n// Type guard for ResourceManagerEvent\nexport function isResourceManagerEvent(event: unknown): event is ResourceManagerEvent {\n  if (!event || typeof event !== 'object') return false;\n  const e = event as ResourceManagerEvent;\n  return (\n    'type' in e &&\n    'resourceType' in e &&\n    typeof e.type === 'string' &&\n    Object.values(EventType).includes(e.type as EventType) &&\n    Object.values(ResourceType).includes(e.resourceType as ResourceType)\n  );\n}\n\n// Update the ResourceProduction interface to properly use standardized resource types\ninterface ResourceProduction extends Omit<ImportedResourceProduction, 'type'> {\n  type: ResourceType;\n  rate: number;\n  maxRate: number;\n  minRate?: number;\n  efficiency?: number;\n}\n\n// Update the ResourceConsumption interface to properly use standardized resource types\ninterface ResourceConsumption extends Omit<ImportedResourceConsumption, 'type'> {\n  type: ResourceType;\n}\n\n// Update the ResourceFlow interface to properly use standardized resource types\ninterface ResourceFlow extends Omit<ImportedResourceFlow, 'resources'> {\n  resources: Array<{\n    type: ResourceType;\n    amount: number;\n    interval?: number;\n  }>;\n}\n\n// Update the ResourceTransfer interface to properly use standardized resource types\ninterface ResourceTransfer extends Omit<ImportedResourceTransfer, 'type'> {\n  type: ResourceType;\n}\n\n/**\n * Manages game resources\n */\nexport class ResourceManager extends AbstractBaseManager<ResourceManagerEvent> {\n  private resources: Map<ResourceType, ResourceState>;\n  private transfers: ResourceTransfer[];\n  private maxTransferHistory: number;\n  private productions: Map<string, ResourceProduction>;\n  private consumptions: Map<string, ResourceConsumption>;\n  private flows: Map<string, ResourceFlow>;\n  private storageEfficiency: number;\n  private config: ResourceManagerConfig;\n  private productionIntervals: Map<string, NodeJS.Timeout>;\n  private errors: Map<string, ResourceError>;\n  private optimizationStrategies: Map<string, OptimizationStrategy>;\n  private optimizationMetrics: {\n    productionEfficiency: number;\n    consumptionEfficiency: number;\n    transferEfficiency: number;\n    lastOptimizationTime: number;\n  };\n  private eventHandlers: Map<EventType, Set<EventHandler<ResourceManagerEvent>>>;\n\n  constructor(\n    maxTransferHistory = 1000,\n    config: ResourceManagerConfig = RESOURCE_MANAGER_CONFIG as ResourceManagerConfig\n  ) {\n    super('ResourceManager');\n\n    this.resources = new Map();\n    this.transfers = [];\n    this.maxTransferHistory = maxTransferHistory;\n    this.productions = new Map();\n    this.consumptions = new Map();\n    this.flows = new Map();\n    this.storageEfficiency = STORAGE_EFFICIENCY.BASE;\n    this.config = config;\n    this.productionIntervals = new Map();\n    this.errors = new Map();\n    this.optimizationStrategies = new Map();\n    this.optimizationMetrics = {\n      productionEfficiency: 1.0,\n      consumptionEfficiency: 1.0,\n      transferEfficiency: 1.0,\n      lastOptimizationTime: Date.now(),\n    };\n    this.eventHandlers = new Map();\n\n    // Initialize event handlers for resource-related events\n    this.initializeEventHandlers();\n\n    console.warn('[ResourceManager] Created with config:', config);\n  }\n\n  /**\n   * Initialize event handlers for resource-related events\n   */\n  private initializeEventHandlers(): void {\n    // Resource production events\n    this.subscribe(EventType.RESOURCE_PRODUCED, this.handleResourceProduced.bind(this));\n    this.subscribe(EventType.RESOURCE_CONSUMED, this.handleResourceConsumed.bind(this));\n    this.subscribe(EventType.RESOURCE_TRANSFERRED, this.handleResourceTransferred.bind(this));\n    this.subscribe(EventType.RESOURCE_SHORTAGE, this.handleResourceShortage.bind(this));\n    this.subscribe(EventType.RESOURCE_THRESHOLD_TRIGGERED, this.handleResourceThreshold.bind(this));\n  }\n\n  /**\n   * Handle resource production events\n   */\n  private handleResourceProduced(event: ResourceManagerEvent): void {\n    if (!isResourceManagerEvent(event)) return;\n    const { resourceType, amount = 0 } = event;\n    this.addResource(resourceType, amount);\n  }\n\n  /**\n   * Handle resource consumption events\n   */\n  private handleResourceConsumed(event: ResourceManagerEvent): void {\n    if (!isResourceManagerEvent(event)) return;\n    const { resourceType, amount = 0 } = event;\n    this.removeResource(resourceType, amount);\n  }\n\n  /**\n   * Handle resource transfer events\n   */\n  private handleResourceTransferred(event: ResourceManagerEvent): void {\n    if (!isResourceManagerEvent(event)) return;\n    const { resourceType, amount = 0, source, target } = event;\n    if (source && target) {\n      this.transferResources(resourceType, amount, source, target);\n    }\n  }\n\n  /**\n   * Handle resource shortage events\n   */\n  private handleResourceShortage(event: ResourceManagerEvent): void {\n    if (!isResourceManagerEvent(event)) return;\n    const { resourceType } = event;\n    // Implement shortage handling logic\n    this.optimizeResourceProduction(resourceType);\n  }\n\n  /**\n   * Handle resource threshold events\n   */\n  private handleResourceThreshold(event: ResourceManagerEvent): void {\n    if (!isResourceManagerEvent(event)) return;\n    const { resourceType, details } = event;\n    if (details?.thresholds) {\n      this.checkThresholds(details.thresholds as ResourceThreshold[]);\n    } else {\n      this.logResourceError(`threshold-${resourceType}`, {\n        code: 'THRESHOLD_VIOLATION',\n        message: `No thresholds provided for ${resourceType}`,\n      });\n    }\n  }\n\n  /**\n   * Optimize resource production for a specific resource type\n   */\n  private optimizeResourceProduction(resourceType: ResourceType): void {\n    // Implement optimization logic\n    const currentAmount = this.getResourceAmount(resourceType);\n    const state = this.getResourceState(resourceType);\n\n    if (state && currentAmount < state.min) {\n      // Increase production if possible\n      const producers = Array.from(this.productions.values()).filter(p => p.type === resourceType);\n\n      for (const producer of producers) {\n        if (producer.rate < producer.maxRate) {\n          producer.rate = Math.min(producer.rate * 1.5, producer.maxRate);\n        }\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc\n   */\n  protected async onInitialize(_dependencies?: unknown): Promise<void> {\n    // Initialize resources with config limits\n    if (this.config.defaultResourceLimits) {\n      Object.entries(this.config.defaultResourceLimits).forEach(([type, limits]) => {\n        const resourceType = ResourceType[type as keyof typeof ResourceType];\n        if (limits && typeof limits.min === 'number' && typeof limits.max === 'number') {\n          this.initializeResource(resourceType, limits.min, limits.max);\n        }\n      });\n    } else {\n      console.warn(\n        '[ResourceManager] Warning: defaultResourceLimits is null or undefined in config'\n      );\n    }\n\n    // Initialize optimization strategies\n    this.initializeOptimizationStrategies();\n\n    // Publish initialization event\n    this.publish({\n      type: EventType.SYSTEM_STARTUP,\n      resourceType: ResourceType.MINERALS,\n      moduleId: this.id,\n      moduleType: 'resource-manager',\n      timestamp: Date.now(),\n      data: { config: this.config },\n    });\n\n    console.warn('[ResourceManager] Initialized with config:', this.config);\n  }\n\n  /**\n   * @inheritdoc\n   */\n  protected onUpdate(deltaTime: number): void {\n    // Process optimizations every 5 seconds\n    if (Date.now() - this.optimizationMetrics.lastOptimizationTime > 5000) {\n      this.runOptimizations();\n      this.optimizationMetrics.lastOptimizationTime = Date.now();\n    }\n\n    // Publish update event with current resource states\n    this.publish({\n      type: EventType.RESOURCE_UPDATED,\n      resourceType: ResourceType.MINERALS,\n      moduleId: this.id,\n      moduleType: 'resource-manager',\n      timestamp: Date.now(),\n      data: {\n        resources: this.getAllResourceStates(),\n        deltaTime,\n      },\n    });\n  }\n\n  /**\n   * @inheritdoc\n   */\n  protected async onDispose(): Promise<void> {\n    // Stop all production intervals\n    for (const [_id, interval] of this.productionIntervals.entries()) {\n      clearInterval(interval);\n    }\n    this.productionIntervals.clear();\n\n    // Save state before disposing\n    this.saveState();\n\n    // Clear all maps\n    this.resources.clear();\n    this.transfers = [];\n    this.productions.clear();\n    this.consumptions.clear();\n    this.flows.clear();\n    this.errors.clear();\n    this.optimizationStrategies.clear();\n\n    console.warn('[ResourceManager] Disposed');\n  }\n\n  /**\n   * @inheritdoc\n   */\n  protected getVersion(): string {\n    return '1.0.0';\n  }\n\n  /**\n   * @inheritdoc\n   */\n  protected getStats(): Record<string, number | string> {\n    return {\n      resourceCount: this.resources.size,\n      transferCount: this.transfers.length,\n      productionCount: this.productions.size,\n      consumptionCount: this.consumptions.size,\n      flowCount: this.flows.size,\n      productionEfficiency: this.optimizationMetrics.productionEfficiency,\n      consumptionEfficiency: this.optimizationMetrics.consumptionEfficiency,\n      transferEfficiency: this.optimizationMetrics.transferEfficiency,\n    };\n  }\n\n  /**\n   * Initialize a resource with min and max values\n   * @param type Resource type\n   * @param min Minimum value\n   * @param max Maximum value\n   */\n  private initializeResource(type: ResourceType, min: number, max: number): void {\n    // Ensure we're using the enum resource type\n    const resourceType = ensureEnumResourceType(type);\n\n    // Create resource state if it doesn't exist\n    if (!this.resources.has(resourceType)) {\n      this.resources.set(resourceType, {\n        current: min,\n        max,\n        min,\n        production: 0,\n        consumption: 0,\n      });\n    }\n  }\n\n  /**\n   * Get the current amount of a resource\n   */\n  getResourceAmount(type: ResourceType): number {\n    const state = this.resources.get(type);\n    return state?.current ?? 0;\n  }\n\n  /**\n   * Get the current state of a resource\n   */\n  getResourceState(type: ResourceType): ResourceState | undefined {\n    return this.resources.get(type);\n  }\n\n  /**\n   * Set the amount of a resource\n   */\n  setResourceAmount(type: ResourceType, amount: number): void {\n    const state = this.resources.get(type);\n    if (!state) {\n      this.logResourceError('set-amount', {\n        code: 'INVALID_RESOURCE',\n        message: `Invalid resource type: ${type}`,\n      });\n      return;\n    }\n\n    // Clamp amount between min and max\n    const clampedAmount = Math.max(state.min, Math.min(state.max, amount));\n    state.current = clampedAmount;\n\n    // Update the resource state\n    this.resources.set(type, state);\n\n    // Publish resource update event\n    this.publish({\n      type: EventType.RESOURCE_UPDATED,\n      resourceType: type,\n      moduleId: this.id,\n      moduleType: 'resource-manager',\n      timestamp: Date.now(),\n      amount: clampedAmount,\n      data: {\n        previous: state.current,\n        current: clampedAmount,\n        min: state.min,\n        max: state.max,\n      },\n    });\n\n    // Update performance metrics\n    resourcePerformanceMonitor.recordMetrics(\n      type,\n      state.production,\n      state.consumption,\n      this.calculateTransferRate(type),\n      clampedAmount / state.max\n    );\n  }\n\n  /**\n   * Adds to a resource amount\n   */\n  addResource(type: ResourceType, amount: number): void {\n    const state = this.resources.get(type);\n    if (!state) {\n      return;\n    }\n    this.setResourceAmount(type, state.current + amount);\n  }\n\n  /**\n   * Removes from a resource amount\n   */\n  removeResource(type: ResourceType, amount: number): boolean {\n    const state = this.resources.get(type);\n    if (!state) {\n      return false;\n    }\n\n    // Check if we have enough\n    if (state.current < amount) {\n      // Emit shortage event\n      this.publish({\n        type: EventType.RESOURCE_SHORTAGE,\n        resourceType: type,\n        moduleId: this.id,\n        moduleType: 'resource-manager',\n        timestamp: Date.now(),\n        amount: amount,\n        data: {\n          resourceType: type,\n          requiredAmount: amount,\n          availableAmount: state.current,\n          deficit: amount - state.current,\n        },\n      });\n      return false;\n    }\n\n    this.setResourceAmount(type, state.current - amount);\n    return true;\n  }\n\n  /**\n   * Updates resource production rate\n   */\n  setResourceProduction(type: ResourceType, amount: number): void {\n    const state = this.resources.get(type);\n    if (!state) {\n      return;\n    }\n    state.production = amount;\n  }\n\n  /**\n   * Updates resource consumption rate\n   */\n  setResourceConsumption(type: ResourceType, amount: number): void {\n    const state = this.resources.get(type);\n    if (!state) {\n      return;\n    }\n    state.consumption = amount;\n  }\n\n  /**\n   * Sets the storage efficiency level\n   */\n  setStorageEfficiency(level: keyof typeof STORAGE_EFFICIENCY): void {\n    const oldEfficiency = this.storageEfficiency;\n    this.storageEfficiency = STORAGE_EFFICIENCY[level];\n\n    // Update max capacities with new efficiency\n    if (this.config.defaultResourceLimits) {\n      for (const [type, limits] of Object.entries(this.config.defaultResourceLimits)) {\n        // Convert string type to ResourceType\n        let resourceType: ResourceType;\n        try {\n          // Try to convert directly if it's already in the correct format\n          resourceType = type as unknown as ResourceType;\n        } catch (_e) {\n          // If that fails, try to use the helper\n          resourceType = ResourceTypeHelpers.stringToEnum(type.toLowerCase() as ResourceTypeString);\n        }\n\n        const state = this.resources.get(resourceType);\n        if (state && limits && typeof limits.max === 'number') {\n          const oldMax = state.max;\n          state.max = limits.max * this.storageEfficiency;\n          console.warn(\n            `[ResourceManager] Updated ${type} storage capacity: ${oldMax.toFixed(2)} -> ${state.max.toFixed(2)}`\n          );\n        }\n      }\n    }\n\n    this.publish({\n      type: EventType.RESOURCE_THRESHOLD_CHANGED,\n      moduleId: this.id,\n      moduleType: 'resource-manager',\n      timestamp: Date.now(),\n      data: {\n        type: 'storage_efficiency',\n        oldValue: oldEfficiency,\n        newValue: this.storageEfficiency,\n      },\n    });\n  }\n\n  /**\n   * Handles and logs resource operation errors\n   */\n  private logResourceError(id: string, error: ResourceError): void {\n    this.errors.set(id, error);\n    console.error(`[ResourceManager] Error in ${id}:`, error.message);\n\n    this.publish({\n      type: EventType.ERROR_OCCURRED,\n      moduleId: id,\n      moduleType: 'resource-manager',\n      timestamp: Date.now(),\n      data: error,\n    });\n  }\n\n  /**\n   * @inheritdoc\n   */\n  public override handleError(error: Error, context?: Record<string, unknown>): void {\n    // Call the parent class implementation\n    super.handleError(error, context);\n\n    // Additional resource manager specific error handling\n    console.error(`[ResourceManager] Error:`, error.message);\n  }\n\n  /**\n   * Validates resource transfer operation\n   */\n  private validateTransfer(\n    type: ResourceType,\n    amount: number,\n    source: string,\n    target: string\n  ): ResourceError | null {\n    if (!this.resources.has(type)) {\n      return {\n        code: 'INVALID_RESOURCE',\n        message: `Invalid resource type: ${type}`,\n      };\n    }\n\n    const sourceAmount = this.getResourceAmount(type);\n    if (sourceAmount < amount) {\n      return {\n        code: 'INSUFFICIENT_RESOURCES',\n        message: `Insufficient ${type}: required ${amount}, available ${sourceAmount}`,\n        details: { required: amount, available: sourceAmount },\n      };\n    }\n\n    if (source === target) {\n      return {\n        code: 'INVALID_TRANSFER',\n        message: 'Source and target cannot be the same',\n        details: { source, target },\n      };\n    }\n\n    return null;\n  }\n\n  /**\n   * Transfers resources between modules with error handling\n   */\n  transferResources(type: ResourceType, amount: number, source: string, target: string): boolean {\n    const error = this.validateTransfer(type, amount, source, target);\n    if (error) {\n      this.logResourceError(`transfer-${source}-${target}`, error);\n      return false;\n    }\n\n    try {\n      // Apply transfer configuration limits\n      amount = Math.max(\n        TRANSFER_CONFIG_WITH_MIN.MIN_AMOUNT,\n        Math.min(amount, TRANSFER_CONFIG_WITH_MIN.MAX_BATCH_SIZE)\n      );\n\n      // Apply transfer rate multiplier for efficiency\n      const transferAmount = amount * TRANSFER_CONFIG_WITH_MIN.TRANSFER_RATE_MULTIPLIER;\n\n      // Record transfer with configured history limit\n      const transfer: ResourceTransfer = {\n        type,\n        amount: transferAmount,\n        source,\n        target,\n        timestamp: Date.now(),\n      };\n\n      this.transfers.push(transfer);\n      if (this.transfers.length > this.maxTransferHistory) {\n        this.transfers.shift();\n      }\n\n      // Emit transfer event\n      this.publish({\n        type: EventType.RESOURCE_TRANSFERRED,\n        resourceType: type,\n        moduleId: source,\n        moduleType: 'resource-manager',\n        timestamp: Date.now(),\n        data: { transfer },\n      });\n\n      console.warn(\n        `[ResourceManager] Transferred ${transferAmount.toFixed(2)} ${type} from ${source} to ${target}`\n      );\n\n      return true;\n    } catch (err) {\n      this.logResourceError(`transfer-${source}-${target}`, {\n        code: 'INVALID_TRANSFER',\n        message: 'Transfer operation failed',\n        details: err,\n      });\n      return false;\n    }\n  }\n\n  /**\n   * Gets resource transfer history\n   */\n  getTransferHistory(): ResourceTransfer[] {\n    return [...this.transfers];\n  }\n\n  /**\n   * Gets transfer history for a specific module\n   */\n  getModuleTransferHistory(moduleId: string): ResourceTransfer[] {\n    return this.transfers.filter(t => t.source === moduleId || t.target === moduleId);\n  }\n\n  /**\n   * Gets transfer history for a specific resource type\n   */\n  getResourceTransferHistory(type: ResourceType): ResourceTransfer[] {\n    return this.transfers.filter(t => t.type === type);\n  }\n\n  /**\n   * Updates resource limits\n   */\n  setResourceLimits(type: ResourceType, min: number, max: number): void {\n    const state = this.resources.get(type);\n    if (!state) {\n      return;\n    }\n    state.min = min;\n    state.max = max;\n\n    // Clamp current value to new limits\n    this.setResourceAmount(type, state.current);\n  }\n\n  /**\n   * Registers a new resource production\n   */\n  registerProduction(id: string, production: ResourceProduction): void {\n    const oldProduction = this.productions.get(id);\n    this.productions.set(id, production);\n\n    // Emit production registration event\n    this.publish({\n      type: EventType.RESOURCE_PRODUCTION_REGISTERED,\n      moduleId: id,\n      moduleType: 'resource-manager',\n      timestamp: Date.now(),\n      data: {\n        production,\n        oldProduction,\n      },\n    });\n\n    console.warn(\n      `[ResourceManager] Registered production for ${production.type}: ${production.amount}/tick every ${production.interval}ms`\n    );\n  }\n\n  /**\n   * Registers a new resource consumption\n   */\n  registerConsumption(id: string, consumption: ResourceConsumption): void {\n    const oldConsumption = this.consumptions.get(id);\n    this.consumptions.set(id, consumption);\n\n    // Emit consumption registration event\n    this.publish({\n      type: EventType.RESOURCE_CONSUMPTION_REGISTERED,\n      moduleId: id,\n      moduleType: 'resource-manager',\n      timestamp: Date.now(),\n      data: {\n        consumption,\n        oldConsumption,\n      },\n    });\n\n    console.warn(\n      `[ResourceManager] Registered consumption for ${consumption.type}: ${consumption.amount}/tick every ${consumption.interval}ms`\n    );\n  }\n\n  /**\n   * Registers a new resource flow between modules\n   */\n  registerFlow(id: string, flow: ResourceFlow): void {\n    const oldFlow = this.flows.get(id);\n    this.flows.set(id, flow);\n\n    // Emit flow registration event\n    this.publish({\n      type: EventType.RESOURCE_FLOW_REGISTERED,\n      moduleId: id,\n      moduleType: 'resource-manager',\n      timestamp: Date.now(),\n      data: {\n        flow,\n        oldFlow,\n      },\n    });\n\n    console.warn(\n      `[ResourceManager] Registered flow from ${flow.source} to ${flow.target} for ${flow.resources.length} resource types`\n    );\n  }\n\n  /**\n   * Unregisters a production\n   */\n  unregisterProduction(id: string): void {\n    const production = this.productions.get(id);\n    if (production) {\n      this.productions.delete(id);\n      this.publish({\n        type: EventType.RESOURCE_PRODUCTION_UNREGISTERED,\n        moduleId: id,\n        moduleType: 'resource-manager',\n        timestamp: Date.now(),\n        data: { production },\n      });\n    }\n  }\n\n  /**\n   * Unregisters a consumption\n   */\n  unregisterConsumption(id: string): void {\n    const consumption = this.consumptions.get(id);\n    if (consumption) {\n      this.consumptions.delete(id);\n      this.publish({\n        type: EventType.RESOURCE_CONSUMPTION_UNREGISTERED,\n        moduleId: id,\n        moduleType: 'resource-manager',\n        timestamp: Date.now(),\n        data: { consumption },\n      });\n    }\n  }\n\n  /**\n   * Unregisters a flow\n   */\n  unregisterFlow(id: string): void {\n    const flow = this.flows.get(id);\n    if (flow) {\n      this.flows.delete(id);\n      this.publish({\n        type: EventType.RESOURCE_FLOW_UNREGISTERED,\n        moduleId: id,\n        moduleType: 'resource-manager',\n        timestamp: Date.now(),\n        data: { flow },\n      });\n    }\n  }\n\n  /**\n   * Initializes resource optimization strategies\n   */\n  private initializeOptimizationStrategies(): void {\n    // Production optimization - balance production rates based on demand\n    this.optimizationStrategies.set('balance-production', {\n      id: 'balance-production',\n      type: 'production',\n      priority: 1,\n      condition: () => {\n        const now = Date.now();\n        return now - this.optimizationMetrics.lastOptimizationTime > 60000; // Run every minute\n      },\n      apply: () => {\n        // Convert Map entries to array to avoid MapIterator error\n        const resourceEntries = Array.from(this.resources.entries());\n        for (const [type, state] of resourceEntries) {\n          const usage = this.calculateResourceUsage(type);\n          const currentProduction = state.production;\n          const targetProduction = usage * 1.2; // 20% buffer\n\n          if (Math.abs(currentProduction - targetProduction) > 0.1) {\n            const oldProduction = state.production;\n            state.production = targetProduction;\n            console.warn(\n              `[ResourceManager] Optimized production for ${type}: ${oldProduction.toFixed(2)} -> ${targetProduction.toFixed(2)}`\n            );\n          }\n        }\n        this.optimizationMetrics.productionEfficiency = this.calculateProductionEfficiency();\n      },\n    });\n\n    // Consumption optimization - reduce waste and optimize resource usage\n    this.optimizationStrategies.set('optimize-consumption', {\n      id: 'optimize-consumption',\n      type: 'consumption',\n      priority: 2,\n      condition: () => {\n        return Array.from(this.resources.values()).some(\n          state => state.current / state.max > RESOURCE_THRESHOLDS.HIGH\n        );\n      },\n      apply: () => {\n        // Convert Map entries to array to avoid MapIterator error\n        const resourceEntries = Array.from(this.resources.entries());\n        for (const [type, state] of resourceEntries) {\n          if (state.current / state.max > RESOURCE_THRESHOLDS.HIGH) {\n            const consumers = Array.from(this.consumptions.values())\n              .filter(c => {\n                // Convert enum type to string type for comparison\n                const stringType = ensureStringResourceType(c.type);\n                return stringType === type;\n              })\n              .sort((_a, b) => (b.required ? 1 : -1));\n\n            for (const consumer of consumers) {\n              if (!consumer.required) {\n                const oldRate = consumer.amount;\n                consumer.amount *= 1.5;\n                console.warn(\n                  `[ResourceManager] Increased consumption of ${type}: ${oldRate.toFixed(2)} -> ${consumer.amount.toFixed(2)}`\n                );\n                break;\n              }\n            }\n          }\n        }\n        this.optimizationMetrics.consumptionEfficiency = this.calculateConsumptionEfficiency();\n      },\n    });\n\n    // Transfer optimization - optimize resource distribution\n    this.optimizationStrategies.set('optimize-transfers', {\n      id: 'optimize-transfers',\n      type: 'transfer',\n      priority: 3,\n      condition: () => this.flows.size > 0,\n      apply: () => {\n        // Convert Map values to array to avoid MapIterator error\n        const flowValues = Array.from(this.flows.values());\n        for (const flow of flowValues) {\n          const sourceStates = flow.resources.map(r => ({\n            resource: r,\n            state: this.resources.get(this.ensureResourceType(r.type)),\n          }));\n\n          // Check if any source is below threshold\n          const belowThreshold = sourceStates.some(\n            s => s.state && s.state.current / s.state.max < RESOURCE_THRESHOLDS.LOW\n          );\n\n          if (belowThreshold) {\n            // Reduce flow rate\n            flow.resources.forEach(r => {\n              const oldRate = r.amount;\n              r.amount *= 0.8;\n              console.warn(\n                `[ResourceManager] Reduced flow rate for ${this.ensureResourceType(r.type)}: ${oldRate.toFixed(2)} -> ${r.amount.toFixed(2)}`\n              );\n            });\n          }\n        }\n        this.optimizationMetrics.transferEfficiency = this.calculateTransferEfficiency();\n      },\n    });\n  }\n\n  /**\n   * Calculates resource usage rate\n   */\n  private calculateResourceUsage(type: ResourceType): number {\n    const consumers = Array.from(this.consumptions.values())\n      .filter(c => {\n        // Handle string type comparison\n        return ensureStringResourceType(c.type) === ensureStringResourceType(type);\n      })\n      .reduce((total, c) => total + c.amount, 0);\n\n    const transfers = Array.from(this.flows.values())\n      .flatMap(f => f.resources)\n      .filter(r => {\n        // Handle string type comparison\n        return ensureStringResourceType(r.type) === ensureStringResourceType(type);\n      })\n      .reduce((total, r) => total + r.amount, 0);\n\n    return consumers + transfers;\n  }\n\n  /**\n   * Calculates production efficiency\n   */\n  private calculateProductionEfficiency(): number {\n    const efficiencies = Array.from(this.resources.entries()).map(([type, state]) => {\n      const usage = this.calculateResourceUsage(type);\n      const { production } = state;\n      return usage > 0 ? Math.min(production / usage, 1.5) : 1.0;\n    });\n\n    return efficiencies.reduce((sum, e) => sum + e, 0) / efficiencies.length;\n  }\n\n  /**\n   * Calculates consumption efficiency\n   */\n  private calculateConsumptionEfficiency(): number {\n    const efficiencies = Array.from(this.resources.entries()).map(([type, state]) => {\n      const usage = this.calculateResourceUsage(type);\n      return usage > 0 ? Math.min(state.current / (usage * 10), 1.0) : 1.0;\n    });\n\n    return efficiencies.reduce((sum, e) => sum + e, 0) / efficiencies.length;\n  }\n\n  /**\n   * Calculates transfer efficiency\n   */\n  private calculateTransferEfficiency(): number {\n    if (this.transfers.length === 0) {\n      return 1.0;\n    }\n\n    const recentTransfers = this.transfers.filter(t => Date.now() - t.timestamp < 60000).length; // Last minute\n\n    const successRate = recentTransfers / Math.max(this.errors.size, 1);\n    return Math.min(successRate, 1.0);\n  }\n\n  /**\n   * Runs optimization strategies\n   */\n  private runOptimizations(): void {\n    const strategies = Array.from(this.optimizationStrategies.values())\n      .sort((a, b) => b.priority - a.priority)\n      .filter(s => s.condition());\n\n    for (const strategy of strategies) {\n      try {\n        strategy.apply();\n        console.warn(`[ResourceManager] Applied optimization strategy: ${strategy.id}`);\n      } catch (err) {\n        console.error(\n          `[ResourceManager] Failed to apply optimization strategy ${strategy.id}:`,\n          err\n        );\n      }\n    }\n\n    this.optimizationMetrics.lastOptimizationTime = Date.now();\n\n    // Emit optimization metrics\n    this.publish({\n      type: EventType.RESOURCE_FLOW_OPTIMIZATION_COMPLETED,\n      moduleId: this.id,\n      moduleType: 'resource-manager',\n      timestamp: Date.now(),\n      data: {\n        productionEfficiency: this.optimizationMetrics.productionEfficiency,\n        consumptionEfficiency: this.optimizationMetrics.consumptionEfficiency,\n        transferEfficiency: this.optimizationMetrics.transferEfficiency,\n        metrics: this.optimizationMetrics,\n      },\n    });\n  }\n\n  /**\n   * Updates resource production and consumption with configured intervals\n   */\n  update(deltaTime: number): void {\n    // Run optimizations first\n    this.runOptimizations();\n\n    // Update performance metrics for each resource\n    const resourceEntries = Array.from(this.resources.entries());\n    for (const [type, state] of resourceEntries) {\n      const usage = this.calculateResourceUsage(type);\n\n      // Convert string type to enum type for the performance monitor\n      const enumType = toEnumResourceType(type);\n      resourcePerformanceMonitor.recordMetrics(\n        enumType,\n        state.production,\n        usage,\n        this.calculateTransferRate(type),\n        state.current / state.max\n      );\n    }\n\n    // Handle production with configured rates\n    const productionEntries = Array.from(this.productions.entries());\n    for (const [id, production] of productionEntries) {\n      if (!this.checkThresholds(production.conditions)) {\n        continue;\n      }\n\n      // Calculate amount to produce based on rate and time\n      const amount = (production.amount * deltaTime) / production.interval;\n      // Add resource using the enum type directly\n      this.addResource(production.type, amount);\n\n      console.warn(`[ResourceManager] Produced ${amount.toFixed(2)} ${production.type} from ${id}`);\n    }\n\n    // Handle consumption with configured rates\n    const consumptionEntries = Array.from(this.consumptions.entries());\n    for (const [id, consumption] of consumptionEntries) {\n      if (!this.checkThresholds(consumption.conditions)) {\n        continue;\n      }\n\n      // Calculate amount to consume based on rate and time\n      const amount = (consumption.amount * deltaTime) / consumption.interval;\n      // Remove resource using the enum type directly\n      this.removeResource(consumption.type, amount);\n\n      if (consumption.required) {\n        // Log error for required consumption\n        this.logResourceError(id, {\n          code: 'INSUFFICIENT_RESOURCES',\n          message: `Failed to consume required resource: ${consumption.type}`,\n          details: {\n            type: consumption.type,\n            amount,\n            consumer: id,\n            priority: RESOURCE_PRIORITIES[consumption.type as ResourceType],\n          },\n        });\n      }\n    }\n\n    // Handle flows with configured transfer settings\n    const flowEntries = Array.from(this.flows.entries());\n    for (const [id, flow] of flowEntries) {\n      if (!this.checkThresholds(flow.conditions)) {\n        console.warn(`[ResourceManager] Flow ${id} skipped due to threshold conditions`);\n        continue;\n      }\n\n      // Process each resource in the flow\n      flow.resources.forEach(resource => {\n        // Calculate amount to transfer based on rate and time\n        const amount = (resource.amount * deltaTime) / (resource.interval || 1000);\n        // Transfer resources using the enum type directly\n        this.transferResources(resource.type, amount, flow.source, flow.target);\n      });\n    }\n  }\n\n  /**\n   * Checks resource thresholds against configured values\n   */\n  private checkThresholds(thresholds?: ResourceThreshold[]): boolean {\n    if (!thresholds) {\n      return true;\n    }\n\n    return thresholds.every(threshold => {\n      const state = this.resources.get(threshold.resourceId);\n      if (!state) {\n        return false;\n      }\n\n      const currentRatio = state.current / state.max;\n\n      // Use configured threshold values\n      if (threshold.min !== undefined && currentRatio < RESOURCE_THRESHOLDS.LOW) {\n        return false;\n      }\n\n      if (threshold.max !== undefined && currentRatio > RESOURCE_THRESHOLDS.HIGH) {\n        return false;\n      }\n\n      if (threshold.target !== undefined) {\n        const targetRatio = threshold.target / state.max;\n        return Math.abs(currentRatio - targetRatio) < 0.1; // 10% tolerance\n      }\n\n      return true;\n    });\n  }\n\n  /**\n   * Schedules a production cycle with configured intervals\n   */\n  scheduleProduction(id: string, production: ResourceProduction): void {\n    // Clear any existing interval\n    this.clearProductionSchedule(id);\n\n    // Register the production\n    this.registerProduction(id, production);\n\n    // Set up the interval\n    const interval = setInterval(() => {\n      if (this.checkThresholds(production.conditions)) {\n        const baseRate = DEFAULT_PRODUCTION_RATES[production.type];\n        const amount = baseRate * production.amount;\n        // Add resource using the enum type directly\n        this.addResource(production.type, amount);\n\n        console.warn(\n          `[ResourceManager] Scheduled production: ${amount.toFixed(2)} ${production.type} from ${id}`\n        );\n      }\n    }, production.interval || PRODUCTION_INTERVALS.NORMAL);\n\n    this.productionIntervals.set(id, interval);\n\n    console.warn(\n      `[ResourceManager] Scheduled production for ${id} every ${\n        production.interval || PRODUCTION_INTERVALS.NORMAL\n      }ms`\n    );\n  }\n\n  /**\n   * Clears a production schedule\n   */\n  clearProductionSchedule(id: string): void {\n    const interval = this.productionIntervals.get(id);\n    if (interval) {\n      clearInterval(interval);\n      this.productionIntervals.delete(id);\n      this.unregisterProduction(id);\n\n      console.warn(`[ResourceManager] Cleared production schedule for ${id}`);\n    }\n  }\n\n  /**\n   * Schedules a resource flow with configured intervals\n   */\n  scheduleFlow(id: string, flow: ResourceFlow): boolean {\n    try {\n      // Clear any existing flow\n      this.clearFlowSchedule(id);\n\n      // Validate flow configuration\n      if (!flow.resources.length) {\n        throw new Error('Flow must have at least one resource');\n      }\n\n      // Register the flow\n      this.registerFlow(id, flow);\n\n      // Set up intervals for each resource\n      flow.resources.forEach(resource => {\n        const interval = setInterval(() => {\n          if (this.checkThresholds(flow.conditions)) {\n            const amount = resource.amount;\n            // Transfer resources using the enum type directly\n            this.transferResources(resource.type, amount, flow.source, flow.target);\n          }\n        }, resource.interval || TRANSFER_CONFIG_WITH_MIN.DEFAULT_INTERVAL);\n\n        this.productionIntervals.set(`${id}-${resource.type}`, interval);\n\n        console.warn(\n          `[ResourceManager] Scheduled flow for ${resource.type} from ${flow.source} to ${\n            flow.target\n          } every ${resource.interval || TRANSFER_CONFIG_WITH_MIN.DEFAULT_INTERVAL}ms`\n        );\n      });\n\n      return true;\n    } catch (err) {\n      console.error(`[ResourceManager] Failed to schedule flow for ${id}:`, err);\n      return false;\n    }\n  }\n\n  /**\n   * Clears a flow schedule\n   */\n  private clearFlowSchedule(id: string): void {\n    const intervals = Array.from(this.productionIntervals.entries())\n      .filter(entry => entry[0].startsWith(`${id}-`))\n      .map(entry => entry[1]);\n\n    intervals.forEach(interval => {\n      clearInterval(interval);\n    });\n\n    this.productionIntervals.delete(`${id}-`);\n    this.unregisterFlow(id);\n\n    console.warn(`[ResourceManager] Cleared flow schedule for ${id}`);\n  }\n\n  public getAllResources(): Record<ResourceType, number> {\n    const resources: Record<ResourceType, number> = {} as Record<ResourceType, number>;\n\n    // Convert Map entries to array to avoid MapIterator error\n    const resourceEntries = Array.from(this.resources.entries());\n    for (const [type, state] of resourceEntries) {\n      resources[type] = state.current;\n    }\n\n    return resources;\n  }\n\n  public getAllResourceStates(): Record<ResourceType, ResourceState> {\n    const states: Record<ResourceType, ResourceState> = {} as Record<ResourceType, ResourceState>;\n    this.resources.forEach((state, type) => {\n      states[type] = { ...state };\n    });\n    return states;\n  }\n\n  /**\n   * Get production and consumption rates for all resources\n   * @returns Record of resource rates by type\n   */\n  public getAllResourceRates(): Record<\n    ResourceType,\n    { production: number; consumption: number; net: number }\n  > {\n    const rates: Record<ResourceType, { production: number; consumption: number; net: number }> =\n      {} as Record<ResourceType, { production: number; consumption: number; net: number }>;\n\n    // Initialize with default rates for all resource types\n    // Use string keys and then cast to StringResourceType to avoid TS error\n    const resourceTypes = [\n      ResourceType.MINERALS,\n      ResourceType.ENERGY,\n      ResourceType.POPULATION,\n      ResourceType.RESEARCH,\n      ResourceType.PLASMA,\n      ResourceType.GAS,\n      ResourceType.EXOTIC,\n    ];\n\n    // Set rates for each resource type\n    resourceTypes.forEach(typeKey => {\n      const type = typeKey as ResourceType;\n      const state = this.getResourceState(type);\n      rates[type] = {\n        production: state?.production ?? 0,\n        consumption: state?.consumption ?? 0,\n        net: (state?.production ?? 0) - (state?.consumption ?? 0),\n      };\n    });\n\n    return rates;\n  }\n\n  /**\n   * Get all resource flows\n   * @returns Array of all registered resource flows\n   */\n  public getAllResourceFlows(): ResourceFlow[] {\n    const flows: ResourceFlow[] = [];\n\n    // Convert Map values to array to avoid MapIterator error\n    const flowValues = Array.from(this.flows.values());\n    for (const flow of flowValues) {\n      flows.push({ ...flow });\n    }\n\n    return flows;\n  }\n\n  /**\n   * Saves the current resource state\n   */\n  public saveState(): void {\n    // Implementation of saveState method\n    console.warn('[ResourceManager] Saving resource state');\n    // Add your implementation here\n  }\n\n  /**\n   * Calculates transfer rate for a resource\n   */\n  private calculateTransferRate(type: ResourceType): number {\n    const recentTransfers = this.transfers\n      .filter(t => t.type === type && Date.now() - t.timestamp < 60000)\n      .reduce((sum, t) => sum + t.amount, 0);\n\n    return recentTransfers / 60; // Transfers per second\n  }\n\n  // Helper function to ensure type safety when converting resource types\n  private ensureResourceType(type: ResourceType | string): ResourceType {\n    if (typeof type === 'string') {\n      return ResourceType[type as keyof typeof ResourceType];\n    }\n    return type;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/game/animationManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/game/assetManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/game/gameManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/game/salvageManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_shipId' is defined but never used.","line":111,"column":37,"nodeType":null,"messageId":"unusedVar","endLine":111,"endColumn":44}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { v4 as uuidv4 } from 'uuid';\nimport {\n  Salvage,\n  SalvageCapability,\n  SalvageDropConfig,\n  SalvageManager,\n} from '../../types/combat/SalvageTypes';\nimport { ShipType } from '../../types/ships/CommonShipTypes';\n\nconst DEFAULT_DROP_CONFIG: SalvageDropConfig = {\n  baseDropRate: 0.5,\n  rarityWeights: {\n    common: 0.7,\n    rare: 0.25,\n    epic: 0.05,\n  },\n  typeWeights: {\n    resources: 0.6,\n    components: 0.3,\n    technology: 0.1,\n  },\n};\n\nclass SalvageManagerImpl implements SalvageManager {\n  private activeSalvage: Salvage[] = [];\n  private dropConfig: SalvageDropConfig;\n  private techTree: { unlockedNodes: Set<string> };\n\n  constructor(dropConfig = DEFAULT_DROP_CONFIG, techTree: { unlockedNodes: Set<string> }) {\n    this.dropConfig = dropConfig;\n    this.techTree = techTree;\n  }\n\n  checkSalvageCapability(ship: ShipType): SalvageCapability {\n    // Mining ships can always salvage\n    if (ship.type.includes('mining')) {\n      return { canSalvage: true, reason: 'mining-ship' };\n    }\n\n    // Recon ships can always salvage\n    if (ship.type.includes('recon')) {\n      return { canSalvage: true, reason: 'recon-ship' };\n    }\n\n    // War ships can salvage if they have the cutting laser upgrade\n    if (this.techTree.unlockedNodes.has('cutting-laser')) {\n      return { canSalvage: true, reason: 'cutting-laser' };\n    }\n\n    return { canSalvage: false, reason: 'none' };\n  }\n\n  generateSalvageDrops(position: { x: number; y: number }, tier: number): Salvage[] {\n    if (Math.random() > this.dropConfig.baseDropRate) {\n      return [];\n    }\n\n    const numDrops = Math.floor(Math.random() * 3) + 1; // 1-3 drops\n    const drops: Salvage[] = [];\n\n    for (let i = 0; i < numDrops; i++) {\n      // Determine rarity\n      const rarityRoll = Math.random();\n      let rarity: Salvage['rarity'];\n      if (rarityRoll < this.dropConfig.rarityWeights.epic) {\n        rarity = 'epic';\n      } else if (\n        rarityRoll <\n        this.dropConfig.rarityWeights.epic + this.dropConfig.rarityWeights.rare\n      ) {\n        rarity = 'rare';\n      } else {\n        rarity = 'common';\n      }\n\n      // Determine type\n      const typeRoll = Math.random();\n      let type: Salvage['type'];\n      if (typeRoll < this.dropConfig.typeWeights.technology) {\n        type = 'technology';\n      } else if (\n        typeRoll <\n        this.dropConfig.typeWeights.technology + this.dropConfig.typeWeights.components\n      ) {\n        type = 'components';\n      } else {\n        type = 'resources';\n      }\n\n      // Generate salvage item\n      const salvage: Salvage = {\n        id: uuidv4(),\n        type,\n        name: this.generateSalvageName(type, rarity, tier),\n        amount: this.calculateAmount(type, rarity, tier),\n        rarity,\n        position: {\n          x: position.x + (Math.random() - 0.5) * 50, // Spread drops slightly\n          y: position.y + (Math.random() - 0.5) * 50,\n        },\n        collected: false,\n      };\n\n      drops.push(salvage);\n    }\n\n    this.activeSalvage.push(...drops);\n    return drops;\n  }\n\n  collectSalvage(salvageId: string, _shipId: string): void {\n    const salvageIndex = this.activeSalvage.findIndex(s => s.id === salvageId);\n    if (salvageIndex >= 0) {\n      this.activeSalvage[salvageIndex].collected = true;\n    }\n  }\n\n  getActiveSalvage(): Salvage[] {\n    return this.activeSalvage.filter(s => !s.collected);\n  }\n\n  private generateSalvageName(\n    type: Salvage['type'],\n    rarity: Salvage['rarity'],\n    tier: number\n  ): string {\n    const prefix = rarity === 'epic' ? 'Ancient' : rarity === 'rare' ? 'Advanced' : 'Standard';\n\n    switch (type) {\n      case 'resources':\n        return `${prefix} ${tier === 3 ? 'Dark Matter' : tier === 2 ? 'Plasma' : 'Metal'} Crystal`;\n      case 'components':\n        return `${prefix} ${tier === 3 ? 'Quantum' : tier === 2 ? 'Enhanced' : 'Basic'} Components`;\n      case 'technology':\n        return `${prefix} ${tier === 3 ? 'Forbidden' : tier === 2 ? 'Experimental' : 'Prototype'} Tech`;\n    }\n  }\n\n  private calculateAmount(type: Salvage['type'], rarity: Salvage['rarity'], tier: number): number {\n    const baseAmount = type === 'resources' ? 100 : type === 'components' ? 50 : 25;\n    const rarityMultiplier = rarity === 'epic' ? 3 : rarity === 'rare' ? 2 : 1;\n    const tierMultiplier = tier;\n\n    return Math.floor(baseAmount * rarityMultiplier * tierMultiplier);\n  }\n}\n\nexport const salvageManager = new SalvageManagerImpl(DEFAULT_DROP_CONFIG, {\n  unlockedNodes: new Set(),\n});\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/game/techTreeManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/mining/MiningResourceIntegration.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/mining/MiningShipManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/mining/MiningShipManagerImpl.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/module/BaseModuleManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/module/ModuleAttachmentManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/module/ModuleManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_deltaTime' is defined but never used.","line":113,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":113,"endColumn":32}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseTypedEventEmitter } from '../../lib/events/BaseTypedEventEmitter';\nimport { AbstractBaseManager } from '../../lib/managers/BaseManager';\nimport { moduleEventBus } from '../../lib/modules/ModuleEvents';\nimport {\n  BaseModule,\n  ModularBuilding,\n  ModuleConfig,\n  ModuleType,\n} from '../../types/buildings/ModuleTypes';\nimport { Position } from '../../types/core/GameTypes';\nimport { BaseEvent, EventType } from '../../types/events/EventTypes';\nimport { ResourceType } from '../../types/resources/ResourceTypes';\nimport { moduleStatusManager } from './ModuleStatusManager';\n\n/**\n * Module manager event types\n */\nexport type ModuleEventType = EventType | ModuleManagerEventType;\n\n/**\n * Module manager specific event types\n */\nexport enum ModuleManagerEventType {\n  MODULE_CONFIG_REGISTERED = 'MODULE_CONFIG_REGISTERED',\n  BUILDING_REGISTERED = 'BUILDING_REGISTERED',\n}\n\n/**\n * Module manager event interface\n */\nexport interface ModuleManagerEvent extends Omit<BaseEvent, 'type'> {\n  type: ModuleEventType;\n  moduleId?: string;\n  buildingId?: string;\n  moduleType?: ModuleType;\n  resourceType?: ResourceType;\n  data?: Record<string, unknown>;\n  timestamp: number;\n  [key: string]: unknown;\n}\n\n/**\n * Manages the lifecycle and state of all modules in the game.\n * Handles module creation, attachment, upgrades, and state updates.\n */\nexport class ModuleManager extends AbstractBaseManager<ModuleManagerEvent> {\n  private modules: Map<string, BaseModule>;\n  private buildings: Map<string, ModularBuilding>;\n  private configs: Map<ModuleType, ModuleConfig>;\n  private eventEmitter: BaseTypedEventEmitter<ModuleManagerEvent>;\n\n  constructor() {\n    super('ModuleManager');\n\n    this.modules = new Map();\n    this.buildings = new Map();\n    this.configs = new Map();\n    this.eventEmitter = new BaseTypedEventEmitter<ModuleManagerEvent>();\n  }\n\n  /**\n   * @inheritdoc\n   */\n  protected async onInitialize(dependencies?: Record<string, unknown>): Promise<void> {\n    // Subscribe to events from other managers if needed\n    if (dependencies?.resourceManager) {\n      // Connect to resource manager events if needed\n    }\n\n    // Subscribe to module events\n    this.subscribe(EventType.MODULE_CREATED, this.handleModuleCreated);\n    this.subscribe(EventType.MODULE_ATTACHED, this.handleModuleAttached);\n    this.subscribe(EventType.MODULE_UPGRADED, this.handleModuleUpgraded);\n    this.subscribe(EventType.MODULE_ACTIVATED, this.handleModuleActivated);\n\n    console.warn('ModuleManager initialized');\n  }\n\n  /**\n   * Event handlers\n   */\n  private handleModuleCreated = (event: ModuleManagerEvent): void => {\n    // Handle module creation event\n    if (event?.moduleId && event?.moduleType) {\n      console.warn(`Module created: ${event?.moduleId} of type ${event?.moduleType}`);\n    }\n  };\n\n  private handleModuleAttached = (event: ModuleManagerEvent): void => {\n    // Handle module attachment event\n    if (event?.moduleId && event?.buildingId) {\n      console.warn(`Module ${event?.moduleId} attached to building ${event?.buildingId}`);\n    }\n  };\n\n  private handleModuleUpgraded = (event: ModuleManagerEvent): void => {\n    // Handle module upgrade event\n    if (event?.moduleId) {\n      console.warn(`Module upgraded: ${event?.moduleId}`);\n    }\n  };\n\n  private handleModuleActivated = (event: ModuleManagerEvent): void => {\n    // Handle module activation event\n    if (event?.moduleId) {\n      console.warn(`Module activation state changed: ${event?.moduleId}`);\n    }\n  };\n\n  /**\n   * @inheritdoc\n   */\n  protected onUpdate(_deltaTime: number): void {\n    // Update modules if needed on each game tick\n    // This could involve updating module progress, checking status, etc.\n\n    // Publish module stats update\n    this.publishEvent({\n      type: EventType.STATUS_CHANGED,\n      moduleId: this.id,\n      moduleType: 'resource-manager' as ModuleType,\n      timestamp: Date.now(),\n      data: {\n        moduleCount: this.modules.size,\n        buildingCount: this.buildings.size,\n        configCount: this.configs.size,\n      },\n    });\n  }\n\n  /**\n   * @inheritdoc\n   */\n  protected async onDispose(): Promise<void> {\n    // Cleanup any resources\n    this.modules.clear();\n    this.buildings.clear();\n    this.configs.clear();\n\n    console.warn('ModuleManager disposed');\n  }\n\n  /**\n   * @inheritdoc\n   */\n  protected getVersion(): string {\n    return '1.0.0';\n  }\n\n  /**\n   * @inheritdoc\n   */\n  protected getStats(): Record<string, number | string> {\n    return {\n      modulesCount: this.modules.size,\n      buildingsCount: this.buildings.size,\n      configsCount: this.configs.size,\n      activeModulesCount: this.getActiveModules().length,\n    };\n  }\n\n  /**\n   * Registers a new module configuration\n   */\n  registerModuleConfig(config: ModuleConfig): void {\n    this.configs.set(config.type, config);\n\n    // Emit config registration event\n    this.publishEvent({\n      type: EventType.SYSTEM_STARTUP, // Use existing event type for compatibility\n      moduleId: this.id,\n      moduleType: 'module-manager' as ModuleType, // Cast for type compatibility\n      timestamp: Date.now(),\n      data: {\n        action: 'config_registered',\n        config,\n      },\n    });\n  }\n\n  /**\n   * Creates a new module instance\n   */\n  createModule(type: ModuleType, position: Position): BaseModule {\n    const config = this.configs.get(type);\n    if (!config) {\n      throw new Error(`No configuration found for module type: ${type}`);\n    }\n\n    const module: BaseModule = {\n      id: `${type}-${Date.now()}`,\n      name: config.name,\n      type,\n      position,\n      isActive: false,\n      level: 1,\n      status: 'constructing',\n      progress: 0,\n    };\n\n    this.modules.set(module.id, module);\n\n    // Initialize status tracking for the new module\n    moduleStatusManager.initializeModuleStatus(module.id);\n\n    // Emit creation event using our event bus\n    this.publishEvent({\n      type: EventType.MODULE_CREATED,\n      moduleId: module.id,\n      moduleType: module.type,\n      timestamp: Date.now(),\n      data: { position, config },\n    });\n\n    // Also emit to legacy event bus for backward compatibility\n    moduleEventBus.emit({\n      type: 'MODULE_CREATED',\n      moduleId: module.id,\n      moduleType: module.type,\n      timestamp: Date.now(),\n      data: { position, config },\n    });\n\n    return module;\n  }\n\n  /**\n   * Attaches a module to a building\n   */\n  attachModule(moduleId: string, buildingId: string, attachmentPointId: string): boolean {\n    const module = this.modules.get(moduleId);\n    const building = this.buildings.get(buildingId);\n\n    if (!module || !building) {\n      return false;\n    }\n\n    const attachmentPoint = building.attachmentPoints.find(p => p.id === attachmentPointId);\n    if (!attachmentPoint || !attachmentPoint.allowedTypes.includes(module.type)) {\n      return false;\n    }\n\n    attachmentPoint.currentModule = module;\n    building.modules.push(module);\n\n    // Emit attachment event using our event bus\n    this.publishEvent({\n      type: EventType.MODULE_ATTACHED,\n      moduleId: module.id,\n      moduleType: module.type,\n      timestamp: Date.now(),\n      data: { buildingId, attachmentPointId },\n    });\n\n    // Also emit to legacy event bus for backward compatibility\n    moduleEventBus.emit({\n      type: 'MODULE_ATTACHED',\n      moduleId: module.id,\n      moduleType: module.type,\n      timestamp: Date.now(),\n      data: { buildingId, attachmentPointId },\n    });\n\n    return true;\n  }\n\n  /**\n   * Upgrades a module to the next level\n   */\n  upgradeModule(moduleId: string): boolean {\n    // Keep existing implementation but update event emission\n    const module = this.modules.get(moduleId);\n    if (!module) {\n      return false;\n    }\n\n    module.level += 1;\n\n    // Emit upgrade event using our event bus\n    this.publishEvent({\n      type: EventType.MODULE_UPGRADED,\n      moduleId: module.id,\n      moduleType: module.type,\n      timestamp: Date.now(),\n      data: { newLevel: module.level },\n    });\n\n    // Also emit to legacy event bus for backward compatibility\n    moduleEventBus.emit({\n      type: 'MODULE_UPGRADED',\n      moduleId: module.id,\n      moduleType: module.type,\n      timestamp: Date.now(),\n      data: { newLevel: module.level },\n    });\n\n    return true;\n  }\n\n  /**\n   * Sets a module's active state\n   */\n  setModuleActive(moduleId: string, active: boolean): boolean {\n    const module = this.modules.get(moduleId);\n    if (!module) {\n      return false;\n    }\n\n    const previousState = module.isActive;\n    module.isActive = active;\n    module.status = active ? 'active' : 'inactive';\n\n    // Only emit event if the state actually changed\n    if (previousState !== active) {\n      const eventType = active ? EventType.MODULE_ACTIVATED : EventType.MODULE_DEACTIVATED;\n\n      // Emit activation/deactivation event using our event bus\n      this.publishEvent({\n        type: eventType,\n        moduleId: module.id,\n        moduleType: module.type,\n        timestamp: Date.now(),\n        data: { active },\n      });\n\n      // Also emit to legacy event bus for backward compatibility\n      moduleEventBus.emit({\n        type: active ? 'MODULE_ACTIVATED' : 'MODULE_DEACTIVATED',\n        moduleId: module.id,\n        moduleType: module.type,\n        timestamp: Date.now(),\n        data: { active },\n      });\n    }\n\n    return true;\n  }\n\n  /**\n   * Gets a module by ID\n   */\n  getModule(moduleId: string): BaseModule | undefined {\n    return this.modules.get(moduleId);\n  }\n\n  /**\n   * Gets all modules of a specific type\n   */\n  getModulesByType(type: ModuleType): BaseModule[] {\n    return Array.from(this.modules.values()).filter(module => module.type === type);\n  }\n\n  /**\n   * Gets all active modules\n   */\n  getActiveModules(): BaseModule[] {\n    return Array.from(this.modules.values()).filter(module => module.isActive);\n  }\n\n  /**\n   * Registers a building\n   */\n  registerBuilding(building: ModularBuilding): void {\n    this.buildings.set(building.id, building);\n\n    // Emit building registration event using a standard event type\n    this.publishEvent({\n      type: EventType.SYSTEM_STARTUP, // Using a standard event type\n      moduleId: building.id,\n      moduleType: 'building' as ModuleType, // Cast for type compatibility\n      timestamp: Date.now(),\n      data: {\n        action: 'building_registered',\n        building,\n      },\n    });\n  }\n\n  /**\n   * Gets all buildings\n   */\n  getBuildings(): ModularBuilding[] {\n    return Array.from(this.buildings.values());\n  }\n\n  /**\n   * Gets a building by ID\n   */\n  getBuilding(buildingId: string): ModularBuilding | undefined {\n    return this.buildings.get(buildingId);\n  }\n\n  /**\n   * Gets all modules in a building\n   */\n  getBuildingModules(buildingId: string): BaseModule[] {\n    const building = this.buildings.get(buildingId);\n    return building ? building.modules : [];\n  }\n}\n\n// Create singleton instance\nexport const moduleManager = ModuleManager.getInstance();\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/module/ModuleManagerWrapper.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/module/ModuleManagerWrapper.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/module/ModuleStatusManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/module/ModuleUpgradeManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_event' is defined but never used.","line":557,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":557,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_event' is defined but never used.","line":564,"column":35,"nodeType":null,"messageId":"unusedVar","endLine":564,"endColumn":41}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { moduleEventBus, ModuleEventType } from '../../lib/modules/ModuleEvents';\nimport { ModuleType } from '../../types/buildings/ModuleTypes';\nimport { ResourceManager } from '../game/ResourceManager';\nimport { ResourceType } from './../../types/resources/ResourceTypes';\nimport { moduleManager } from './ModuleManager';\nimport { moduleStatusManager } from './ModuleStatusManager';\n\n// Create an instance of ResourceManager\nconst resourceManager = new ResourceManager();\n\n// Define the ModuleEvent interface\ninterface ModuleEvent {\n  type: ModuleEventType;\n  moduleId: string;\n  moduleType: ModuleType;\n  timestamp: number;\n  data?: Record<string, unknown>;\n}\n\n/**\n * Upgrade path for a module\n * Defines the progression of a module through levels\n */\nexport interface ModuleUpgradePath {\n  moduleType: ModuleType;\n  levels: ModuleUpgradeLevel[];\n}\n\n/**\n * Upgrade level definition\n * Contains requirements and effects for a specific level\n */\nexport interface ModuleUpgradeLevel {\n  level: number;\n  name: string;\n  description: string;\n  requirements: ModuleUpgradeRequirements;\n  effects: ModuleUpgradeEffect[];\n  visualChanges?: ModuleVisualChange[];\n}\n\n/**\n * Requirements for upgrading a module\n */\nexport interface ModuleUpgradeRequirements {\n  minLevel: number;\n  resourceCosts: {\n    type: ResourceType;\n    amount: number;\n  }[];\n  techRequirements?: string[];\n  moduleRequirements?: {\n    type: ModuleType;\n    level: number;\n  }[];\n  buildingLevel?: number;\n}\n\n/**\n * Effect of upgrading a module\n */\nexport interface ModuleUpgradeEffect {\n  type: 'stat' | 'resource' | 'ability' | 'special';\n  target: string;\n  value: number;\n  isPercentage: boolean;\n  description: string;\n}\n\n/**\n * Visual change for a module upgrade\n */\nexport interface ModuleVisualChange {\n  type: 'color' | 'size' | 'shape' | 'texture' | 'effect';\n  description: string;\n  value: string;\n}\n\n/**\n * Upgrade status for a module\n */\nexport interface ModuleUpgradeStatus {\n  moduleId: string;\n  moduleType: ModuleType;\n  currentLevel: number;\n  maxLevel: number;\n  nextLevel?: ModuleUpgradeLevel;\n  upgradeAvailable: boolean;\n  requirementsMet: boolean;\n  missingRequirements: string[];\n  upgradeProgress?: number;\n  estimatedTimeRemaining?: number;\n  effects: ModuleUpgradeEffect[];\n}\n\n/**\n * Module upgrade manager\n * Manages upgrade paths, requirements, and effects for modules\n */\nexport class ModuleUpgradeManager {\n  private upgradePaths: Map<ModuleType, ModuleUpgradePath>;\n  private activeUpgrades: Map<\n    string,\n    {\n      startTime: number;\n      duration: number;\n      targetLevel: number;\n      timer: NodeJS.Timeout;\n    }\n  >;\n\n  constructor() {\n    this.upgradePaths = new Map();\n    this.activeUpgrades = new Map();\n\n    // Subscribe to events\n    this.subscribeToEvents();\n  }\n\n  /**\n   * Subscribe to module events\n   */\n  private subscribeToEvents(): void {\n    moduleEventBus.subscribe('MODULE_CREATED' as ModuleEventType, this.handleModuleCreated);\n    moduleEventBus.subscribe('MODULE_UPGRADED' as ModuleEventType, this.handleModuleUpgraded);\n  }\n\n  /**\n   * Register an upgrade path for a module type\n   */\n  public registerUpgradePath(path: ModuleUpgradePath): void {\n    this.upgradePaths.set(path.moduleType, path);\n  }\n\n  /**\n   * Get the upgrade path for a module type\n   */\n  public getUpgradePath(moduleType: ModuleType): ModuleUpgradePath | undefined {\n    return this.upgradePaths.get(moduleType);\n  }\n\n  /**\n   * Get the upgrade level for a module\n   */\n  public getUpgradeLevel(moduleType: ModuleType, level: number): ModuleUpgradeLevel | undefined {\n    const path = this.upgradePaths.get(moduleType);\n    if (!path) {\n      return undefined;\n    }\n\n    return path.levels.find(l => l.level === level);\n  }\n\n  /**\n   * Get the next upgrade level for a module\n   */\n  public getNextUpgradeLevel(moduleId: string): ModuleUpgradeLevel | undefined {\n    const module = moduleManager.getModule(moduleId);\n    if (!module) {\n      return undefined;\n    }\n\n    const path = this.upgradePaths.get(module.type);\n    if (!path) {\n      return undefined;\n    }\n\n    return path.levels.find(l => l.level === module.level + 1);\n  }\n\n  /**\n   * Check if a module can be upgraded\n   */\n  public canUpgrade(moduleId: string): boolean {\n    const module = moduleManager.getModule(moduleId);\n    if (!module) {\n      return false;\n    }\n\n    // Check if module is already being upgraded\n    if (this.activeUpgrades.has(moduleId)) {\n      return false;\n    }\n\n    // Check if module is active\n    if (!module.isActive) {\n      return false;\n    }\n\n    // Get next upgrade level\n    const nextLevel = this.getNextUpgradeLevel(moduleId);\n    if (!nextLevel) {\n      return false;\n    }\n\n    // Check requirements\n    return this.checkUpgradeRequirements(moduleId, nextLevel);\n  }\n\n  /**\n   * Check if a module meets the requirements for an upgrade\n   */\n  public checkUpgradeRequirements(moduleId: string, upgradeLevel: ModuleUpgradeLevel): boolean {\n    const module = moduleManager.getModule(moduleId);\n    if (!module) {\n      return false;\n    }\n\n    const { requirements } = upgradeLevel;\n\n    // Check minimum level requirement\n    if (module.level < requirements.minLevel) {\n      return false;\n    }\n\n    // Check resource costs\n    for (const cost of requirements.resourceCosts) {\n      const available = resourceManager.getResourceAmount(cost.type as ResourceType);\n      if (available < cost.amount) {\n        return false;\n      }\n    }\n\n    // Check tech requirements\n    if (requirements.techRequirements) {\n      // TODO: Implement tech requirement checking\n      // This would require integration with a tech tree system\n    }\n\n    // Check module requirements\n    if (requirements.moduleRequirements) {\n      for (const req of requirements.moduleRequirements) {\n        const modules = moduleManager.getModulesByType(req.type);\n        const hasRequiredModule = modules.some(m => m.level >= req.level);\n        if (!hasRequiredModule) {\n          return false;\n        }\n      }\n    }\n\n    // Check building level\n    if (requirements.buildingLevel) {\n      // Find the building this module is attached to\n      let attachedBuilding = undefined;\n      for (const building of moduleManager.getBuildings()) {\n        if (building.modules.some(m => m.id === moduleId)) {\n          attachedBuilding = building;\n          break;\n        }\n      }\n\n      if (!attachedBuilding || attachedBuilding.level < requirements.buildingLevel) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Get missing requirements for a module upgrade\n   */\n  public getMissingRequirements(moduleId: string): string[] {\n    const module = moduleManager.getModule(moduleId);\n    if (!module) {\n      return ['Module not found'];\n    }\n\n    const nextLevel = this.getNextUpgradeLevel(moduleId);\n    if (!nextLevel) {\n      return ['No upgrade available'];\n    }\n\n    const { requirements } = nextLevel;\n    const missingRequirements: string[] = [];\n\n    // Check minimum level requirement\n    if (module.level < requirements.minLevel) {\n      missingRequirements.push(\n        `Module level ${module.level} is below required level ${requirements.minLevel}`\n      );\n    }\n\n    // Check resource costs\n    for (const cost of requirements.resourceCosts) {\n      const available = resourceManager.getResourceAmount(cost.type as ResourceType);\n      if (available < cost.amount) {\n        missingRequirements.push(`Insufficient ${cost.type}: ${available}/${cost.amount}`);\n      }\n    }\n\n    // Check tech requirements\n    if (requirements.techRequirements) {\n      // TODO: Implement tech requirement checking\n      // This would require integration with a tech tree system\n    }\n\n    // Check module requirements\n    if (requirements.moduleRequirements) {\n      for (const req of requirements.moduleRequirements) {\n        const modules = moduleManager.getModulesByType(req.type);\n        const hasRequiredModule = modules.some(m => m.level >= req.level);\n        if (!hasRequiredModule) {\n          missingRequirements.push(`Requires ${req.type} module at level ${req.level}`);\n        }\n      }\n    }\n\n    // Check building level\n    if (requirements.buildingLevel) {\n      // Find the building this module is attached to\n      let attachedBuilding = undefined;\n      for (const building of moduleManager.getBuildings()) {\n        if (building.modules.some(m => m.id === moduleId)) {\n          attachedBuilding = building;\n          break;\n        }\n      }\n\n      if (!attachedBuilding) {\n        missingRequirements.push(`Module not attached to a building`);\n      } else if (attachedBuilding.level < requirements.buildingLevel) {\n        missingRequirements.push(\n          `Building level ${attachedBuilding.level} is below required level ${requirements.buildingLevel}`\n        );\n      }\n    }\n\n    return missingRequirements;\n  }\n\n  /**\n   * Get upgrade status for a module\n   */\n  public getUpgradeStatus(moduleId: string): ModuleUpgradeStatus | undefined {\n    const module = moduleManager.getModule(moduleId);\n    if (!module) {\n      return undefined;\n    }\n\n    const path = this.upgradePaths.get(module.type);\n    if (!path) {\n      return undefined;\n    }\n\n    const nextLevel = this.getNextUpgradeLevel(moduleId);\n    const maxLevel =\n      path.levels.length > 0 ? path.levels[path.levels.length - 1].level : module.level;\n\n    // Get active upgrade info\n    const activeUpgrade = this.activeUpgrades.get(moduleId);\n    let upgradeProgress: number | undefined;\n    let estimatedTimeRemaining: number | undefined;\n\n    if (activeUpgrade) {\n      const elapsed = Date.now() - activeUpgrade.startTime;\n      upgradeProgress = Math.min(1, elapsed / activeUpgrade.duration);\n      estimatedTimeRemaining = Math.max(0, activeUpgrade.duration - elapsed);\n    }\n\n    // Get upgrade effects\n    const effects: ModuleUpgradeEffect[] = [];\n    if (nextLevel) {\n      effects.push(...nextLevel.effects);\n    }\n\n    // Check requirements\n    const requirementsMet = nextLevel ? this.checkUpgradeRequirements(moduleId, nextLevel) : false;\n    const missingRequirements = nextLevel\n      ? this.getMissingRequirements(moduleId)\n      : ['No upgrade available'];\n\n    return {\n      moduleId,\n      moduleType: module.type,\n      currentLevel: module.level,\n      maxLevel,\n      nextLevel,\n      upgradeAvailable: !!nextLevel && module.level < maxLevel,\n      requirementsMet,\n      missingRequirements,\n      upgradeProgress,\n      estimatedTimeRemaining,\n      effects,\n    };\n  }\n\n  /**\n   * Start upgrading a module\n   */\n  public startUpgrade(moduleId: string): boolean {\n    // Check if module can be upgraded\n    if (!this.canUpgrade(moduleId)) {\n      return false;\n    }\n\n    const module = moduleManager.getModule(moduleId);\n    if (!module) {\n      return false;\n    }\n\n    const nextLevel = this.getNextUpgradeLevel(moduleId);\n    if (!nextLevel) {\n      return false;\n    }\n\n    // Consume resources\n    for (const cost of nextLevel.requirements.resourceCosts) {\n      resourceManager.removeResource(cost.type as ResourceType, cost.amount);\n    }\n\n    // Calculate upgrade time (1 minute per level)\n    const baseUpgradeTime = 60000; // 1 minute\n    const upgradeTime = baseUpgradeTime * nextLevel.level;\n\n    // Update module status\n    moduleStatusManager.updateModuleStatus(\n      moduleId,\n      'upgrading',\n      `Upgrading to level ${nextLevel.level}`\n    );\n\n    // Start upgrade timer\n    const timer = setTimeout(() => {\n      this.completeUpgrade(moduleId, nextLevel.level);\n    }, upgradeTime);\n\n    // Store upgrade info\n    this.activeUpgrades.set(moduleId, {\n      startTime: Date.now(),\n      duration: upgradeTime,\n      targetLevel: nextLevel.level,\n      timer,\n    });\n\n    // Emit upgrade started event\n    moduleEventBus.emit({\n      type: 'MODULE_UPGRADE_STARTED' as ModuleEventType,\n      moduleId,\n      moduleType: module.type,\n      timestamp: Date.now(),\n      data: {\n        currentLevel: module.level,\n        targetLevel: nextLevel.level,\n        duration: upgradeTime,\n        requirements: nextLevel.requirements,\n        effects: nextLevel.effects,\n      },\n    });\n\n    return true;\n  }\n\n  /**\n   * Cancel an active module upgrade\n   */\n  public cancelUpgrade(moduleId: string): boolean {\n    const activeUpgrade = this.activeUpgrades.get(moduleId);\n    if (!activeUpgrade) {\n      return false;\n    }\n\n    // Clear timer\n    clearTimeout(activeUpgrade.timer);\n\n    // Remove from active upgrades\n    this.activeUpgrades.delete(moduleId);\n\n    // Update module status\n    moduleStatusManager.updateModuleStatus(moduleId, 'active', 'Upgrade cancelled');\n\n    // Emit upgrade cancelled event\n    const module = moduleManager.getModule(moduleId);\n    if (module) {\n      moduleEventBus.emit({\n        type: 'MODULE_UPGRADE_CANCELLED' as ModuleEventType,\n        moduleId,\n        moduleType: module.type,\n        timestamp: Date.now(),\n        data: {\n          currentLevel: module.level,\n          targetLevel: activeUpgrade.targetLevel,\n        },\n      });\n    }\n\n    return true;\n  }\n\n  /**\n   * Complete a module upgrade\n   */\n  private completeUpgrade(moduleId: string, targetLevel: number): void {\n    const activeUpgrade = this.activeUpgrades.get(moduleId);\n    if (!activeUpgrade) {\n      return;\n    }\n\n    // Remove from active upgrades\n    this.activeUpgrades.delete(moduleId);\n\n    // Get module\n    const module = moduleManager.getModule(moduleId);\n    if (!module) {\n      return;\n    }\n\n    // Get upgrade level\n    const upgradeLevel = this.getUpgradeLevel(module.type, targetLevel);\n    if (!upgradeLevel) {\n      return;\n    }\n\n    // Update module level\n    const oldLevel = module.level;\n    module.level = targetLevel;\n\n    // Update module status\n    moduleStatusManager.updateModuleStatus(moduleId, 'active', `Upgraded to level ${targetLevel}`);\n\n    // Apply upgrade effects\n    this.applyUpgradeEffects(moduleId, upgradeLevel);\n\n    // Emit upgrade completed event\n    moduleEventBus.emit({\n      type: 'MODULE_UPGRADED' as ModuleEventType,\n      moduleId,\n      moduleType: module.type,\n      timestamp: Date.now(),\n      data: {\n        oldLevel,\n        newLevel: targetLevel,\n        effects: upgradeLevel.effects,\n        visualChanges: upgradeLevel.visualChanges,\n      },\n    });\n  }\n\n  /**\n   * Apply upgrade effects to a module\n   */\n  private applyUpgradeEffects(moduleId: string, upgradeLevel: ModuleUpgradeLevel): void {\n    // This would apply the effects of the upgrade to the module\n    // For now, we'll just log the effects\n    console.warn(\n      `[ModuleUpgradeManager] Applying effects to module ${moduleId}:`,\n      upgradeLevel.effects\n    );\n\n    // In a real implementation, this would modify the module's stats, abilities, etc.\n    // based on the effects defined in the upgrade level\n  }\n\n  /**\n   * Handle module created event\n   */\n  private handleModuleCreated = (_event: ModuleEvent): void => {\n    // Nothing to do here for now\n  };\n\n  /**\n   * Handle module upgraded event\n   */\n  private handleModuleUpgraded = (_event: ModuleEvent): void => {\n    // Nothing to do here for now\n  };\n\n  /**\n   * Clean up resources\n   */\n  public cleanup(): void {\n    // Clear all active upgrade timers\n    for (const [moduleId, upgrade] of Array.from(this.activeUpgrades.entries())) {\n      clearTimeout(upgrade.timer);\n\n      // Update module status\n      moduleStatusManager.updateModuleStatus(\n        moduleId,\n        'active',\n        'Upgrade cancelled due to cleanup'\n      );\n    }\n\n    // Clear active upgrades\n    this.activeUpgrades.clear();\n\n    // Unsubscribe from events\n    const unsubscribeCreated = moduleEventBus.subscribe(\n      'MODULE_CREATED' as ModuleEventType,\n      this.handleModuleCreated\n    );\n    const unsubscribeUpgraded = moduleEventBus.subscribe(\n      'MODULE_UPGRADED' as ModuleEventType,\n      this.handleModuleUpgraded\n    );\n\n    if (typeof unsubscribeCreated === 'function') {\n      unsubscribeCreated();\n    }\n    if (typeof unsubscribeUpgraded === 'function') {\n      unsubscribeUpgraded();\n    }\n  }\n}\n\n// Export singleton instance\nexport const moduleUpgradeManager = new ModuleUpgradeManager();\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/module/OfficerManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/module/ShipHangarManager.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":2309,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":2309,"endColumn":16,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[66758,66807],"text":""},"desc":"Remove the console.log()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { v4 as uuidv4 } from 'uuid';\nimport { SHIP_BLUEPRINTS, ShipBlueprint } from '../../config/ShipBlueprints';\nimport { WeaponEffectType } from '../../effects/types_effects/WeaponEffects';\nimport { TypedEventEmitter } from '../../lib/events/EventEmitter';\nimport { ModuleEvent, moduleEventBus } from '../../lib/modules/ModuleEvents';\nimport {\n  ShipHangarManager as IShipHangarManager,\n  ShipBuildQueueItem,\n  ShipBuildRequirements,\n  ShipHangarBay,\n  ShipHangarEvents,\n  ShipHangarState,\n  ShipUpgradeInfo,\n  ShipUpgradeRequirement,\n  ShipUpgradeStats,\n  ShipVisualUpgrade,\n} from '../../types/buildings/ShipHangarTypes';\nimport { Effect, Tier } from '../../types/core/GameTypes';\nimport { Officer } from '../../types/officers/OfficerTypes';\nimport { ResourceCost } from '../../types/resources/ResourceTypes';\nimport { CommonShip, CommonShipAbility, CommonShipStats } from '../../types/ships/CommonShipTypes';\nimport { PlayerShipCategory, PlayerShipClass } from '../../types/ships/PlayerShipTypes';\nimport {\n  WeaponCategory,\n  WeaponConfig,\n  WeaponInstance,\n  WeaponMount,\n  WeaponMountPosition,\n  WeaponMountSize,\n  WeaponState,\n  WeaponStats,\n  WeaponStatus,\n} from '../../types/weapons/WeaponTypes';\nimport { ResourceManager } from '../game/ResourceManager';\nimport { TechTreeManager } from '../game/techTreeManager';\nimport { ResourceType } from './../../types/resources/ResourceTypes';\nimport { OfficerManager } from './OfficerManager';\n\n// Extend CommonShip to include state\ninterface ShipWithState extends CommonShip {\n  state: ShipState;\n}\n\n// Update ShipEffect to extend Effect properly\ninterface ShipEffect extends Effect {\n  name: string;\n  description: string;\n  type: 'buff' | 'debuff' | 'status';\n  magnitude: number;\n  duration: number;\n  active: boolean;\n  cooldown: number;\n  source?: {\n    type: 'ability' | 'weapon' | 'module';\n    id: string;\n  };\n}\n\n// Add effect management to ship state\ninterface ShipState {\n  activeEffects: ShipEffect[];\n  effectHistory: {\n    effect: ShipEffect;\n    appliedAt: number;\n    removedAt?: number;\n  }[];\n}\n\n// Define the missing RequirementCheckResult interface\ninterface RequirementCheckResult {\n  type: string;\n  name: string;\n  met: boolean;\n}\n\n// Define DEFAULT ship designs from the blueprints\nconst DEFAULT_SCOUT_SHIP_DESIGN = SHIP_BLUEPRINTS.find(bp => bp.category === 'recon' && bp.tier === 1);\nconst DEFAULT_MINING_SHIP_DESIGN = SHIP_BLUEPRINTS.find(bp => bp.category === 'mining' && bp.tier === 1);\nconst DEFAULT_COMBAT_SHIP_DESIGN = SHIP_BLUEPRINTS.find(bp => bp.category === 'war' && bp.tier === 1);\n\n/**\n * Implementation of the Ship Hangar Manager\n * Handles ship production, docking, and hangar bay management\n */\nexport class ShipHangarManager\n  extends TypedEventEmitter<ShipHangarEvents>\n  implements IShipHangarManager\n{\n  private state: ShipHangarState;\n  private resourceManager: ResourceManager;\n  private officerManager: OfficerManager;\n  private activeRepairs: Map<\n    string,\n    {\n      timer: NodeJS.Timeout;\n      resourceCost: ResourceCost[];\n      startTime: number;\n      duration: number;\n    }\n  > = new Map();\n  private activeUpgrades: Map<\n    string,\n    {\n      timer: NodeJS.Timeout;\n      resourceCost: ResourceCost[];\n      startTime: number;\n      duration: number;\n      targetStats: ShipUpgradeStats;\n    }\n  > = new Map();\n  private activeAbilities: Map<\n    string,\n    {\n      timer: NodeJS.Timeout;\n      ability: CommonShipAbility;\n      startTime: number;\n    }\n  > = new Map();\n  private abilityCooldowns: Map<\n    string,\n    {\n      timer: NodeJS.Timeout;\n      endTime: number;\n    }\n  > = new Map();\n  private bayMaintenanceTimers: Map<\n    string,\n    {\n      timer: NodeJS.Timeout;\n      lastMaintenance: number;\n      efficiency: number;\n    }\n  > = new Map();\n  private assignedOfficers: Map<string, string> = new Map(); // shipId -> officerId\n  private techTreeInstance: TechTreeManager | null = TechTreeManager.getInstance();\n\n  constructor(resourceManager: ResourceManager, officerManager: OfficerManager) {\n    super();\n    this.resourceManager = resourceManager;\n    this.officerManager = officerManager;\n    this.state = this.initializeState();\n    this.setupEventListeners();\n\n    // Subscribe to module events\n    moduleEventBus.subscribe('MODULE_ACTIVATED', (event: ModuleEvent) => {\n      if (event?.moduleType === 'hangar') {\n        this.handleModuleActivation(event?.moduleId);\n      }\n    });\n\n    moduleEventBus.subscribe('MODULE_DEACTIVATED', (event: ModuleEvent) => {\n      if (event?.moduleType === 'hangar') {\n        this.handleModuleDeactivation(event?.moduleId);\n      }\n    });\n\n    moduleEventBus.subscribe('STATUS_CHANGED', (event: ModuleEvent) => {\n      if (\n        event?.moduleType === 'hangar' &&\n        event?.data &&\n        typeof event?.data === 'object' &&\n        'status' in event.data\n      ) {\n        const status = String(event.data.status);\n        this.handleModuleStatusChange(event.moduleId, status);\n      }\n    });\n\n    // Add built-in ships\n    this.addShipDesign(DEFAULT_SCOUT_SHIP_DESIGN);\n    this.addShipDesign(DEFAULT_MINING_SHIP_DESIGN);\n    this.addShipDesign(DEFAULT_COMBAT_SHIP_DESIGN);\n  }\n\n  /**\n   * Initialize hangar state\n   */\n  private initializeState(): ShipHangarState {\n    return {\n      tier: 1,\n      buildQueue: [],\n      bays: [\n        {\n          id: uuidv4(),\n          tier: 1,\n          capacity: 3,\n          ships: [],\n          status: 'available',\n          efficiency: 1.0,\n          lastMaintenance: Date.now(),\n          maintenanceCost: [\n            { type: ResourceType.ENERGY, amount: 10 },\n            { type: ResourceType.MINERALS, amount: 5 },\n          ],\n        },\n      ],\n      maxQueueSize: 3,\n      buildSpeedMultiplier: 1.0,\n      resourceEfficiency: 1.0,\n    };\n  }\n\n  /**\n   * Set up event listeners\n   */\n  private setupEventListeners(): void {\n    if (this.techTreeInstance) {\n      this.techTreeInstance.on('nodeUnlocked', ((event: {\n        nodeId: string;\n        node: { type: string; tier: number };\n      }) => {\n        if (event?.node.type === 'hangar') {\n          this.handleTierUpgrade(event?.node.tier as Tier);\n        }\n      }) as (data: unknown) => void);\n    }\n  }\n\n  /**\n   * Handle tier upgrades\n   */\n  private handleTierUpgrade(tier: Tier): void {\n    if (tier > this.state.tier) {\n      this.state.tier = tier;\n      this.state.maxQueueSize += 2;\n      this.state.buildSpeedMultiplier *= 1.25;\n      this.state.resourceEfficiency *= 0.9;\n\n      // Add new bay with maintenance costs\n      const newBay: ShipHangarBay = {\n        id: uuidv4(),\n        tier,\n        capacity: 3 + (tier - 1) * 2,\n        ships: [],\n        status: 'available',\n        efficiency: 1.0,\n        lastMaintenance: Date.now(),\n        maintenanceCost: [\n          { type: ResourceType.ENERGY, amount: 10 * tier },\n          { type: ResourceType.MINERALS, amount: 5 * tier },\n        ],\n      };\n      this.state.bays.push(newBay);\n      this.setupBayMaintenance(newBay);\n\n      this.emit('tierUpgraded', {\n        tier,\n        unlockedShips: this.getUnlockedShipsForTier(tier),\n      });\n    }\n  }\n\n  /**\n   * Handle module activation\n   */\n  private handleModuleActivation(moduleId: string): void {\n    console.warn(`[ShipHangarManager] Module ${moduleId} activated`);\n    const oldEfficiency = this.state.resourceEfficiency;\n    const oldSpeed = this.state.buildSpeedMultiplier;\n\n    // Increase resource efficiency when module is activated\n    this.state.resourceEfficiency *= 0.9; // 10% reduction in resource costs\n    this.state.buildSpeedMultiplier *= 1.1; // 10% increase in build speed\n\n    console.warn(`[ShipHangarManager] Efficiency changes for module ${moduleId}:\n      Resource Efficiency: ${oldEfficiency.toFixed(2)} -> ${this.state.resourceEfficiency.toFixed(2)}\n      Build Speed: ${oldSpeed.toFixed(2)} -> ${this.state.buildSpeedMultiplier.toFixed(2)}`);\n  }\n\n  /**\n   * Handle module deactivation\n   */\n  private handleModuleDeactivation(moduleId: string): void {\n    console.warn(`[ShipHangarManager] Module ${moduleId} deactivated`);\n    const oldEfficiency = this.state.resourceEfficiency;\n    const oldSpeed = this.state.buildSpeedMultiplier;\n\n    // Reset efficiency bonuses when module is deactivated\n    this.state.resourceEfficiency /= 0.9; // Remove 10% reduction\n    this.state.buildSpeedMultiplier /= 1.1; // Remove 10% increase\n\n    console.warn(`[ShipHangarManager] Efficiency changes for module ${moduleId}:\n      Resource Efficiency: ${oldEfficiency.toFixed(2)} -> ${this.state.resourceEfficiency.toFixed(2)}\n      Build Speed: ${oldSpeed.toFixed(2)} -> ${this.state.buildSpeedMultiplier.toFixed(2)}`);\n  }\n\n  /**\n   * Handle module status change\n   */\n  private handleModuleStatusChange(moduleId: string, status: string): void {\n    console.warn(`[ShipHangarManager] Module ${moduleId} status changed to ${status}`);\n    const oldEfficiency = this.state.resourceEfficiency;\n    const oldSpeed = this.state.buildSpeedMultiplier;\n\n    switch (status) {\n      case 'optimized':\n        // Additional efficiency bonus for optimized state\n        this.state.resourceEfficiency *= 0.85; // 15% reduction in resource costs\n        this.state.buildSpeedMultiplier *= 1.15; // 15% increase in build speed\n        break;\n      case 'degraded':\n        // Penalty for degraded state\n        this.state.resourceEfficiency /= 0.85; // Remove optimization bonus\n        this.state.buildSpeedMultiplier /= 1.15; // Remove speed bonus\n        break;\n      default:\n        // Reset to base values for other states\n        this.state.resourceEfficiency = 1.0;\n        this.state.buildSpeedMultiplier = 1.0;\n        break;\n    }\n\n    console.warn(`[ShipHangarManager] Efficiency changes for module ${moduleId}:\n      Resource Efficiency: ${oldEfficiency.toFixed(2)} -> ${this.state.resourceEfficiency.toFixed(2)}\n      Build Speed: ${oldSpeed.toFixed(2)} -> ${this.state.buildSpeedMultiplier.toFixed(2)}`);\n  }\n\n  /**\n   * Get unlocked ships for a tier\n   */\n  private getUnlockedShipsForTier(tier: Tier): PlayerShipClass[] {\n    // This should be moved to a configuration file\n    switch (tier) {\n      case 1:\n        return ['spitflare', 'void-dredger-miner', 'andromeda-cutter'];\n      case 2:\n        return ['star-schooner', 'orion-frigate'];\n      case 3:\n        return ['harbringer-galleon', 'midway-carrier', 'mother-earth-revenge'];\n      default:\n        return [];\n    }\n  }\n\n  /**\n   * Start building a ship\n   */\n  public startBuild(shipClass: PlayerShipClass): void {\n    if (this.state.buildQueue.length >= this.state.maxQueueSize) {\n      throw new Error('Build queue is full');\n    }\n\n    const requirements = this.getBuildRequirements(shipClass);\n\n    // Check tier requirement\n    if (requirements.tier > this.state.tier) {\n      throw new Error(\n        `Insufficient hangar tier. Required: ${requirements.tier}, Current: ${this.state.tier}`\n      );\n    }\n\n    // Check tech requirements\n    if (!this.checkTechRequirements(requirements)) {\n      throw new Error('Missing required technologies');\n    }\n\n    // Check officer requirements\n    if (requirements.prerequisites?.officers) {\n      const { minLevel, specialization } = requirements.prerequisites.officers;\n\n      // Find an assigned officer that meets the requirements\n      let hasQualifiedOfficer = false;\n      for (const [shipId, officerId] of Array.from(this.assignedOfficers.entries())) {\n        const officer = this.officerManager.getOfficer(officerId);\n        const ship = this.getDockedShips().find(s => s.id === shipId);\n        if (\n          officer &&\n          ship &&\n          officer.level >= minLevel &&\n          officer.specialization === specialization &&\n          ship.status === 'ready'\n        ) {\n          hasQualifiedOfficer = true;\n          break;\n        }\n      }\n\n      if (!hasQualifiedOfficer) {\n        throw new Error(`Requires a level ${minLevel} ${specialization} officer`);\n      }\n    }\n\n    // Check resources\n    const canAfford = requirements.resourceCost.every(\n      cost => this.resourceManager.getResourceAmount(cost.type) >= cost.amount\n    );\n    if (!canAfford) {\n      throw new Error('Insufficient resources');\n    }\n\n    // Consume resources with efficiency bonus\n    requirements.resourceCost.forEach(cost => {\n      const adjustedAmount = Math.floor(cost.amount * this.state.resourceEfficiency);\n      this.resourceManager.removeResource(cost.type, adjustedAmount);\n    });\n\n    // Create queue item with adjusted build time based on speed multiplier\n    const queueItem: ShipBuildQueueItem = {\n      id: uuidv4(),\n      shipClass,\n      progress: 0,\n      startTime: Date.now(),\n      duration: Math.floor(requirements.buildTime / this.state.buildSpeedMultiplier),\n      resourceCost: requirements.resourceCost,\n      tier: requirements.tier,\n      status: 'building',\n      totalPausedTime: 0,\n    };\n\n    this.state.buildQueue.push(queueItem);\n    this.emit('buildStarted', { queueItem });\n  }\n\n  /**\n   * Cancel a build in progress\n   */\n  public cancelBuild(queueItemId: string): void {\n    const index = this.state.buildQueue.findIndex(item => item?.id === queueItemId);\n    if (index === -1) {\n      return;\n    }\n\n    const item = this.state.buildQueue[index];\n\n    // Calculate refund based on progress\n    const refundedResources = item?.resourceCost.map(cost => ({\n      type: cost.type,\n      amount: Math.floor(cost.amount * (1 - item?.progress) * 0.75), // 75% refund of remaining resources\n    }));\n\n    // Return resources\n    refundedResources.forEach(refund => {\n      this.resourceManager.addResource(refund.type, refund.amount);\n    });\n\n    this.state.buildQueue.splice(index, 1);\n    this.emit('buildCancelled', { queueItemId, refundedResources });\n  }\n\n  /**\n   * Pause a build in progress\n   */\n  public pauseBuild(queueItemId: string): void {\n    const item = this.state.buildQueue.find(item => item?.id === queueItemId);\n    if (!item || item?.status !== 'building') {\n      throw new Error('Cannot pause: Invalid build or already paused');\n    }\n\n    item.status = 'paused';\n    item.pausedAt = Date.now();\n    this.emit('buildPaused', { queueItemId });\n  }\n\n  /**\n   * Resume a paused build\n   */\n  public resumeBuild(queueItemId: string): void {\n    const item = this.state.buildQueue.find(item => item?.id === queueItemId);\n    if (!item || item?.status !== 'paused') {\n      throw new Error('Cannot resume: Invalid build or not paused');\n    }\n\n    // Calculate total paused time\n    if (item?.pausedAt) {\n      item.totalPausedTime = (item.totalPausedTime ?? 0) + (Date.now() - item.pausedAt);\n    }\n\n    item.status = 'building';\n    item.pausedAt = undefined;\n    this.emit('buildResumed', { queueItemId });\n  }\n\n  /**\n   * Get the current build queue\n   */\n  public getBuildQueue(): ShipBuildQueueItem[] {\n    return [...this.state.buildQueue];\n  }\n\n  /**\n   * Get build requirements for a ship class\n   */\n  public getBuildRequirements(shipClass: PlayerShipClass): ShipBuildRequirements {\n    // Find the ship blueprint\n    const blueprint = SHIP_BLUEPRINTS.find(bp => bp.shipClass === shipClass);\n    if (!blueprint) {\n      throw new Error(`No blueprint found for ship class: ${shipClass}`);\n    }\n\n    // Get base requirements from blueprint\n    const requirements: ShipBuildRequirements = {\n      tier: blueprint.requirements.tier,\n      resourceCost: blueprint.requirements.resourceCost,\n      buildTime: blueprint.requirements.buildTime,\n      prerequisites: blueprint.requirements.prerequisites,\n    };\n\n    // Add tech tree requirements based on tier and category\n    if (!requirements.prerequisites) {\n      requirements.prerequisites = {};\n    }\n\n    if (!requirements.prerequisites.technology) {\n      requirements.prerequisites.technology = [];\n    }\n\n    // Add base tech requirements based on tier\n    switch (blueprint.tier) {\n      case 3:\n        requirements.prerequisites.technology.push('mega-hangar');\n        break;\n      case 2:\n        requirements.prerequisites.technology.push('expanded-hangar');\n        break;\n      case 1:\n        requirements.prerequisites.technology.push('basic-ship-hangar');\n        break;\n    }\n\n    // Add category-specific tech requirements\n    switch (blueprint.category) {\n      case 'war':\n        requirements.prerequisites.technology.push(\n          blueprint.tier === 3\n            ? 'advanced-weapons'\n            : blueprint.tier === 2\n              ? 'enhanced-weapons'\n              : 'basic-weapons'\n        );\n        break;\n      case 'recon':\n        requirements.prerequisites.technology.push(\n          blueprint.tier === 3\n            ? 'quantum-recon'\n            : blueprint.tier === 2\n              ? 'enhanced-sensors'\n              : 'basic-sensors'\n        );\n        break;\n      case 'mining':\n        requirements.prerequisites.technology.push(\n          blueprint.tier === 3\n            ? 'exotic-mining'\n            : blueprint.tier === 2\n              ? 'improved-extraction'\n              : 'mining-lasers'\n        );\n        break;\n    }\n\n    return requirements;\n  }\n\n  /**\n   * Dock a ship in an available bay\n   */\n  public dockShip(ship: CommonShip): void {\n    const availableBays = this.getAvailableBays();\n    if (availableBays.length === 0) {\n      this.emit('error', { message: 'No available bays for docking' });\n      return;\n    }\n\n    // Find the bay with the most space\n    const targetBay = availableBays.reduce((prev, current) =>\n      prev.capacity - prev.ships.length > current.capacity - current.ships.length ? prev : current\n    );\n\n    // Initialize ship stats if needed\n    if (!ship.stats || Object.keys(ship.stats).length === 0) {\n      const shipClass = this.getShipClass(ship);\n      ship.stats = this.getBaseStats(shipClass);\n    }\n\n    targetBay.ships.push(ship);\n    this.emit('shipDocked', { ship, bay: targetBay });\n  }\n\n  /**\n   * Launch a ship from its bay\n   */\n  public launchShip(shipId: string): void {\n    for (const bay of this.state.bays) {\n      const index = bay.ships.findIndex(ship => ship.id === shipId);\n      if (index !== -1) {\n        const ship = bay.ships[index];\n        bay.ships.splice(index, 1);\n        bay.status = 'available';\n        this.emit('shipLaunched', { ship, bay });\n        return;\n      }\n    }\n  }\n\n  /**\n   * Upgrade a hangar bay\n   */\n  public upgradeBay(bayId: string): void {\n    const bay = this.state.bays.find(b => b.id === bayId);\n    if (!bay || bay.tier >= this.state.tier) {\n      return;\n    }\n\n    // Calculate upgrade costs\n    const upgradeCosts: ResourceCost[] = [\n      { type: ResourceType.MINERALS, amount: 100 * bay.tier },\n      { type: ResourceType.ENERGY, amount: 50 * bay.tier },\n    ];\n\n    // Add plasma cost for higher tiers\n    if (bay.tier >= 2) {\n      upgradeCosts.push({ type: ResourceType.PLASMA, amount: 25 * bay.tier });\n    }\n\n    // Check if we can afford upgrade\n    const canAfford = upgradeCosts.every(\n      cost => this.resourceManager.getResourceAmount(cost.type) >= cost.amount\n    );\n\n    if (!canAfford) {\n      throw new Error('Insufficient resources for bay upgrade');\n    }\n\n    // Consume resources\n    upgradeCosts.forEach(cost => {\n      this.resourceManager.removeResource(cost.type, cost.amount);\n    });\n\n    const newTier = (bay.tier + 1) as Tier;\n    const newCapacity = bay.capacity + 2;\n\n    // Update bay\n    bay.tier = newTier;\n    bay.capacity = newCapacity;\n    bay.status = bay.ships.length >= newCapacity ? 'full' : 'available';\n    bay.efficiency = Math.min(1.0, bay.efficiency + 0.2); // Bonus efficiency from upgrade\n    bay.maintenanceCost = [\n      { type: ResourceType.ENERGY, amount: 10 * newTier },\n      { type: ResourceType.MINERALS, amount: 5 * newTier },\n    ];\n\n    // Reset maintenance timer with new values\n    this.setupBayMaintenance(bay);\n\n    this.emit('bayUpgraded', {\n      bayId,\n      newTier,\n      newCapacity,\n      newEfficiency: bay.efficiency,\n    });\n  }\n\n  /**\n   * Get all hangar bays\n   */\n  public getBays(): ShipHangarBay[] {\n    return [...this.state.bays];\n  }\n\n  /**\n   * Get available hangar bays\n   */\n  public getAvailableBays(): ShipHangarBay[] {\n    return this.state.bays.filter(bay => bay.status === 'available');\n  }\n\n  /**\n   * Get current hangar tier\n   */\n  public getCurrentTier(): Tier {\n    return this.state.tier;\n  }\n\n  /**\n   * Get current hangar state\n   */\n  public getState(): ShipHangarState {\n    return { ...this.state };\n  }\n\n  /**\n   * Update build progress\n   */\n  public update(): void {\n    const now = Date.now();\n    const completedItems: ShipBuildQueueItem[] = [];\n\n    // Update progress for each building item\n    this.state.buildQueue.forEach(item => {\n      if (item?.status !== 'building') {\n        return;\n      }\n\n      // Calculate elapsed time considering pauses\n      const elapsedTime = now - item?.startTime - (item?.totalPausedTime ?? 0);\n      const newProgress = Math.min(1, elapsedTime / item?.duration);\n\n      if (newProgress !== item?.progress) {\n        item.progress = newProgress;\n        this.emit('buildProgressed', { queueItemId: item?.id, progress: newProgress });\n      }\n\n      // Check for completion\n      if (newProgress >= 1) {\n        item.status = 'completed';\n        completedItems.push(item);\n      }\n    });\n\n    // Handle completed items\n    completedItems.forEach(item => {\n      this.completeBuild(item);\n      const index = this.state.buildQueue.indexOf(item);\n      if (index !== -1) {\n        this.state.buildQueue.splice(index, 1);\n      }\n    });\n  }\n\n  /**\n   * Complete a ship build and assign it to a bay\n   */\n  private completeBuild(item: ShipBuildQueueItem): void {\n    // Get ship blueprint\n    const blueprint = SHIP_BLUEPRINTS.find((bp: ShipBlueprint) => bp.shipClass === item?.shipClass);\n    if (!blueprint) {\n      throw new Error(`No blueprint found for ship class: ${item?.shipClass}`);\n    }\n\n    // Find an available bay\n    const availableBay = this.state.bays.find(\n      bay => bay.status === 'available' && bay.ships.length < bay.capacity\n    );\n    if (!availableBay) {\n      throw new Error('No available bay to dock the completed ship');\n    }\n\n    // Create the ship instance\n    const ship: CommonShip = {\n      id: uuidv4(),\n      name: blueprint.name,\n      category: blueprint.category,\n      status: 'ready',\n      stats: {\n        health: blueprint.baseStats.hull,\n        maxHealth: blueprint.baseStats.hull,\n        shield: blueprint.baseStats.shield,\n        maxShield: blueprint.baseStats.shield,\n        energy: blueprint.baseStats.energy,\n        maxEnergy: blueprint.baseStats.energy,\n        speed: blueprint.baseStats.speed,\n        turnRate: 2,\n        cargo: blueprint.baseStats.cargo ?? 0,\n        weapons: (blueprint.weapons ?? []).map(weapon =>\n          this.createWeaponMount(weapon, blueprint.tier)\n        ),\n        abilities:\n          blueprint.abilities?.map(ability => ({\n            id: uuidv4(),\n            name: ability.name,\n            description: ability.description,\n            cooldown: ability.cooldown,\n            duration: ability.duration,\n            active: false,\n            effect: {\n              id: uuidv4(),\n              name: ability.name,\n              description: ability.description,\n              type: 'ability',\n              magnitude: 1,\n              duration: ability.duration,\n              active: false,\n              cooldown: ability.cooldown,\n            },\n          })) ?? [],\n        defense: {\n          armor: Math.floor(blueprint.baseStats.hull * 0.3),\n          shield: blueprint.baseStats.shield,\n          evasion: 0.2,\n          regeneration: Math.floor(blueprint.baseStats.shield * 0.02),\n        },\n        mobility: {\n          speed: blueprint.baseStats.speed,\n          turnRate: 2,\n          acceleration: blueprint.baseStats.speed * 0.5,\n        },\n      },\n      abilities:\n        blueprint.abilities?.map(ability => ({\n          id: uuidv4(),\n          name: ability.name,\n          description: ability.description,\n          cooldown: ability.cooldown,\n          duration: ability.duration,\n          active: false,\n          effect: {\n            id: uuidv4(),\n            name: ability.name,\n            description: ability.description,\n            type: 'ability',\n            magnitude: 1,\n            duration: ability.duration,\n            active: false,\n            cooldown: ability.cooldown,\n          },\n        })) ?? [],\n    };\n\n    // Add ship to bay\n    availableBay.ships.push(ship);\n    if (availableBay.ships.length >= availableBay.capacity) {\n      availableBay.status = 'full';\n    }\n\n    // Emit completion event\n    this.emit('buildCompleted', { ship, bay: availableBay });\n  }\n\n  /**\n   * Get ship class from ship\n   */\n  private getShipClass(ship: CommonShip): PlayerShipClass {\n    // Map ship names to their corresponding class\n    const classMap: Record<string, PlayerShipClass> = {\n      'Harbringer Galleon': 'harbringer-galleon',\n      'Midway Carrier': 'midway-carrier',\n      \"Mother Earth's Revenge\": 'mother-earth-revenge',\n      'Orion Frigate': 'orion-frigate',\n      Spitflare: 'spitflare',\n      'Star Schooner': 'star-schooner',\n      'Void Dredger Miner': 'void-dredger-miner',\n      'Andromeda Cutter': 'andromeda-cutter',\n    };\n\n    return classMap[ship.name] || 'spitflare'; // Default to spitflare if name not found\n  }\n\n  private getShipCategory(shipClass: PlayerShipClass): PlayerShipCategory {\n    if (shipClass.includes('void-dredger')) {\n      return 'mining';\n    }\n    if (shipClass.includes('andromeda') || shipClass.includes('schooner')) {\n      return 'recon';\n    }\n    return 'war';\n  }\n\n  private createWeaponMount(\n    weapon: { name: string; damage: number; range: number; cooldown: number },\n    tier: number\n  ): WeaponMount {\n    const damageEffect: WeaponEffectType = {\n      id: uuidv4(),\n      type: 'damage',\n      duration: 0,\n      strength: weapon.damage,\n      magnitude: weapon.damage,\n      name: 'Direct Damage',\n      description: 'Deals direct damage to target',\n      damageType: 'physical',\n      penetration: 0,\n    };\n\n    const weaponStats: WeaponStats = {\n      damage: weapon.damage,\n      range: weapon.range,\n      accuracy: 0.8,\n      rateOfFire: 1 / weapon.cooldown,\n      energyCost: 5,\n      cooldown: weapon.cooldown,\n      effects: [damageEffect],\n      special: {\n        armorPenetration: 0,\n        shieldDamageBonus: 0,\n        areaOfEffect: 0,\n        disableChance: 0,\n      },\n    };\n\n    const weaponState: WeaponState = {\n      status: 'ready' as WeaponStatus,\n      currentStats: weaponStats,\n      effects: [damageEffect],\n      currentAmmo: undefined,\n      maxAmmo: undefined,\n    };\n\n    const weaponInstance: WeaponInstance = {\n      config: {\n        id: weapon.name.toLowerCase().replace(/\\s+/g, '-'),\n        name: weapon.name,\n        category: 'machineGun' as WeaponCategory,\n        tier: tier,\n        baseStats: weaponStats,\n        visualAsset: `weapons/${weapon.name.toLowerCase().replace(/\\s+/g, '-')}`,\n        mountRequirements: {\n          size: 'medium' as WeaponMountSize,\n          power: 20,\n        },\n      },\n      state: weaponState,\n    };\n\n    return {\n      id: uuidv4(),\n      size: 'medium' as WeaponMountSize,\n      position: 'front' as WeaponMountPosition,\n      rotation: 0,\n      allowedCategories: ['machineGun' as WeaponCategory],\n      currentWeapon: weaponInstance,\n    };\n  }\n\n  private getBaseStats(shipClass: PlayerShipClass): CommonShipStats {\n    const blueprint = SHIP_BLUEPRINTS.find((bp: ShipBlueprint) => bp.shipClass === shipClass);\n    if (!blueprint) {\n      throw new Error(`No blueprint found for ship class ${shipClass}`);\n    }\n\n    const weapons: WeaponMount[] = (blueprint.weapons ?? []).map(weapon =>\n      this.createWeaponMount(weapon, blueprint.tier)\n    );\n\n    return {\n      health: blueprint.baseStats.hull,\n      maxHealth: blueprint.baseStats.hull,\n      shield: blueprint.baseStats.shield,\n      maxShield: blueprint.baseStats.shield,\n      energy: blueprint.baseStats.energy,\n      maxEnergy: blueprint.baseStats.energy,\n      speed: blueprint.baseStats.speed,\n      turnRate: 2,\n      cargo: blueprint.baseStats.cargo ?? 0,\n      weapons,\n      abilities:\n        blueprint.abilities?.map(ability => ({\n          id: uuidv4(),\n          name: ability.name,\n          description: ability.description,\n          cooldown: ability.cooldown,\n          duration: ability.duration,\n          active: false,\n          effect: {\n            id: uuidv4(),\n            name: ability.name,\n            description: ability.description,\n            type: 'ability',\n            magnitude: 1,\n            duration: ability.duration,\n            active: false,\n            cooldown: ability.cooldown,\n          },\n        })) ?? [],\n      defense: {\n        armor: Math.floor(blueprint.baseStats.hull * 0.3),\n        shield: blueprint.baseStats.shield,\n        evasion: 0.2,\n        regeneration: Math.floor(blueprint.baseStats.shield * 0.02),\n      },\n      mobility: {\n        speed: blueprint.baseStats.speed,\n        turnRate: 2,\n        acceleration: blueprint.baseStats.speed * 0.5,\n      },\n    };\n  }\n\n  /**\n   * Get available ships\n   */\n  public getAvailableShips(category?: PlayerShipCategory): CommonShip[] {\n    const ships = this.state.bays.flatMap(bay => bay.ships);\n    if (category) {\n      return ships.filter(ship => ship.category === category);\n    }\n    return ships;\n  }\n\n  /**\n   * Get all docked ships\n   */\n  public getDockedShips(): CommonShip[] {\n    return this.state.bays.flatMap(bay => bay.ships);\n  }\n\n  /**\n   * Get ships by category\n   */\n  public getShipsByCategory(category: PlayerShipCategory): CommonShip[] {\n    return this.getDockedShips().filter(ship => {\n      const shipClass = this.getShipClass(ship);\n      return this.getShipCategory(shipClass) === category;\n    });\n  }\n\n  /**\n   * Start repairing a ship\n   */\n  public startRepair(shipId: string): void {\n    // Find the ship in any bay\n    let targetShip: CommonShip | undefined;\n    let targetBay: ShipHangarBay | undefined;\n\n    for (const bay of this.state.bays) {\n      const ship = bay.ships.find(s => s.id === shipId);\n      if (ship) {\n        targetShip = ship;\n        targetBay = bay;\n        break;\n      }\n    }\n\n    if (!targetShip || !targetBay) {\n      throw new Error('Ship not found in any bay');\n    }\n\n    if (targetShip.status !== 'damaged') {\n      throw new Error('Ship does not need repairs');\n    }\n\n    // Calculate repair costs based on damage\n    const healthDamage = targetShip.stats.maxHealth - targetShip.stats.health;\n    const shieldDamage = targetShip.stats.maxShield - targetShip.stats.shield;\n    const totalDamage = healthDamage + shieldDamage;\n\n    const resourceCost: ResourceCost[] = [\n      { type: ResourceType.MINERALS, amount: Math.ceil(totalDamage * 0.5) }, // Base mineral cost\n      { type: ResourceType.ENERGY, amount: Math.ceil(totalDamage * 0.3) }, // Base energy cost\n    ];\n\n    // Add plasma cost for higher tier ships\n    if (targetShip.stats.maxHealth >= 200) {\n      // Higher tier ships have more health\n      resourceCost.push({ type: ResourceType.PLASMA, amount: Math.ceil(totalDamage * 0.2) });\n    }\n\n    // Check if we have enough resources\n    const canAfford = resourceCost.every(\n      cost => this.resourceManager.getResourceAmount(cost.type) >= cost.amount\n    );\n    if (!canAfford) {\n      throw new Error('Insufficient resources for repairs');\n    }\n\n    // Consume resources\n    resourceCost.forEach(cost => {\n      this.resourceManager.removeResource(cost.type, cost.amount);\n    });\n\n    // Calculate repair time based on damage and tier\n    const baseRepairTime = 30000; // 30 seconds base time\n    const damageMultiplier = totalDamage / targetShip.stats.maxHealth;\n    const estimatedTime = Math.ceil(baseRepairTime * damageMultiplier);\n\n    // Update ship status\n    targetShip.status = 'repairing';\n\n    // Start repair timer\n    const repairTimer = setTimeout(() => {\n      this.completeRepair(shipId);\n    }, estimatedTime);\n\n    // Store repair info\n    this.activeRepairs.set(shipId, {\n      timer: repairTimer,\n      resourceCost,\n      startTime: Date.now(),\n      duration: estimatedTime,\n    });\n\n    // Emit event\n    this.emit('repairStarted', {\n      shipId,\n      resourceCost,\n      estimatedTime,\n    });\n  }\n\n  /**\n   * Cancel an ongoing repair\n   */\n  public cancelRepair(shipId: string): void {\n    const repairInfo = this.activeRepairs.get(shipId);\n    if (!repairInfo) {\n      throw new Error('No active repair found for ship');\n    }\n\n    // Clear the timer\n    clearTimeout(repairInfo.timer);\n\n    // Calculate progress and refund resources\n    const progress = Math.min(1, (Date.now() - repairInfo.startTime) / repairInfo.duration);\n    const refundedResources = repairInfo.resourceCost.map(cost => ({\n      type: cost.type,\n      amount: Math.floor(cost.amount * (1 - progress) * 0.75), // 75% refund of remaining resources\n    }));\n\n    // Return resources\n    refundedResources.forEach(refund => {\n      this.resourceManager.addResource(refund.type, refund.amount);\n    });\n\n    // Find and update ship status\n    for (const bay of this.state.bays) {\n      const ship = bay.ships.find(s => s.id === shipId);\n      if (ship) {\n        ship.status = 'damaged';\n        break;\n      }\n    }\n\n    // Clean up\n    this.activeRepairs.delete(shipId);\n\n    // Emit event\n    this.emit('repairCancelled', {\n      shipId,\n      refundedResources,\n    });\n  }\n\n  /**\n   * Complete a ship repair\n   */\n  private completeRepair(shipId: string): void {\n    // Find the ship\n    let repairedShip: CommonShip | undefined;\n\n    for (const bay of this.state.bays) {\n      const ship = bay.ships.find(s => s.id === shipId);\n      if (ship) {\n        repairedShip = ship;\n        break;\n      }\n    }\n\n    if (!repairedShip) {\n      console.error('Ship not found for repair completion');\n      return;\n    }\n\n    // Restore ship to full health\n    repairedShip.stats.health = repairedShip.stats.maxHealth;\n    repairedShip.stats.shield = repairedShip.stats.maxShield;\n    repairedShip.status = 'ready';\n\n    // Clean up\n    this.activeRepairs.delete(shipId);\n\n    // Emit event\n    this.emit('repairCompleted', { shipId });\n  }\n\n  /**\n   * Get upgrade info for a ship\n   */\n  public getUpgradeInfo(shipId: string): ShipUpgradeInfo | undefined {\n    // Find the ship\n    let targetShip: CommonShip | undefined;\n    let targetBay: ShipHangarBay | undefined;\n\n    for (const bay of this.state.bays) {\n      const ship = bay.ships.find(s => s.id === shipId);\n      if (ship) {\n        targetShip = ship;\n        targetBay = bay;\n        break;\n      }\n    }\n\n    if (!targetShip || !targetBay) {\n      return undefined;\n    }\n\n    // Find the ship blueprint\n    const blueprint = SHIP_BLUEPRINTS.find(bp => bp.shipClass === this.getShipClass(targetShip));\n    if (!blueprint) {\n      return undefined;\n    }\n\n    // Check if upgrade is available\n    const upgradeAvailable = targetBay.tier < this.state.tier;\n\n    // Calculate upgrade stats\n    const stats: ShipUpgradeStats = {\n      hull: {\n        current: targetShip.stats.health,\n        upgraded: Math.floor(targetShip.stats.health * 1.5),\n      },\n      shield: {\n        current: targetShip.stats.shield,\n        upgraded: Math.floor(targetShip.stats.shield * 1.5),\n      },\n      weapons: {\n        current: 100,\n        upgraded: 150,\n      },\n      speed: {\n        current: targetShip.stats.speed,\n        upgraded: Math.floor(targetShip.stats.speed * 1.2),\n      },\n    };\n\n    // Calculate resource costs\n    const resourceCost: ResourceCost[] = [\n      { type: ResourceType.MINERALS, amount: Math.floor(targetShip.stats.health * 0.5) },\n      { type: ResourceType.ENERGY, amount: Math.floor(targetShip.stats.shield * 0.5) },\n    ];\n\n    // Add plasma cost for higher tier upgrades\n    if (targetBay.tier >= 2) {\n      resourceCost.push({\n        type: ResourceType.PLASMA,\n        amount: Math.floor((targetShip.stats.health + targetShip.stats.shield) * 0.2),\n      });\n    }\n\n    // Check tech requirements\n    const requirements: ShipUpgradeRequirement[] = [];\n\n    // Tech tree requirements\n    if (blueprint.requirements.prerequisites?.technology) {\n      const missingTech = blueprint.requirements.prerequisites.technology.filter(\n        techId => !this.techTreeInstance?.getNode(techId)?.unlocked\n      );\n      if (missingTech.length > 0) {\n        throw new Error(`Missing required technologies: ${missingTech.join(', ')}`);\n      }\n\n      blueprint.requirements.prerequisites.technology.forEach(tech => {\n        requirements.push({\n          type: 'tech',\n          name: tech,\n          met: this.techTreeInstance?.getNode(tech)?.unlocked || false,\n        });\n      });\n    }\n\n    // Resource requirements\n    resourceCost.forEach(cost => {\n      requirements.push({\n        type: 'resource',\n        name: `${cost.type}: ${cost.amount}`,\n        met: this.resourceManager.getResourceAmount(cost.type) >= cost.amount,\n      });\n    });\n\n    // Facility requirements\n    requirements.push({\n      type: 'facility',\n      name: `Tier ${targetBay.tier + 1} Hangar Bay`,\n      met: this.state.tier > targetBay.tier,\n    });\n\n    // Visual upgrades\n    const visualUpgrades: ShipVisualUpgrade[] = [\n      {\n        name: 'Enhanced Hull Plating',\n        description: 'Reinforced armor panels with improved damage resistance',\n        preview: `ships/${targetShip.category}/tier${targetBay.tier + 1}/hull`,\n      },\n      {\n        name: 'Advanced Shield Matrix',\n        description: 'Upgraded shield emitters with better regeneration',\n        preview: `ships/${targetShip.category}/tier${targetBay.tier + 1}/shield`,\n      },\n    ];\n\n    return {\n      shipId,\n      tier: targetBay.tier as Tier,\n      upgradeAvailable,\n      requirements,\n      stats,\n      resourceCost,\n      visualUpgrades,\n    };\n  }\n\n  /**\n   * Start upgrading a ship\n   */\n  public startUpgrade(shipId: string): void {\n    const upgradeInfo = this.getUpgradeInfo(shipId);\n    if (!upgradeInfo) {\n      throw new Error('Ship not found or upgrade info not available');\n    }\n\n    if (!upgradeInfo.upgradeAvailable) {\n      throw new Error('Ship is not eligible for upgrade');\n    }\n\n    // Check requirements\n    if (!upgradeInfo.requirements.every(req => req.met)) {\n      throw new Error('Not all upgrade requirements are met');\n    }\n\n    // Find the ship\n    let targetShip: CommonShip | undefined;\n    let targetBay: ShipHangarBay | undefined;\n\n    for (const bay of this.state.bays) {\n      const ship = bay.ships.find(s => s.id === shipId);\n      if (ship) {\n        targetShip = ship;\n        targetBay = bay;\n        break;\n      }\n    }\n\n    if (!targetShip || !targetBay) {\n      throw new Error('Ship not found in any bay');\n    }\n\n    // Consume resources\n    upgradeInfo.resourceCost.forEach(cost => {\n      this.resourceManager.removeResource(cost.type, cost.amount);\n    });\n\n    // Calculate upgrade time\n    const baseUpgradeTime = 60000; // 1 minute base time\n    const tierMultiplier = targetBay.tier;\n    const estimatedTime = baseUpgradeTime * tierMultiplier;\n\n    // Update ship status\n    targetShip.status = 'upgrading';\n\n    // Start upgrade timer\n    const upgradeTimer = setTimeout(() => {\n      this.completeUpgrade(shipId, upgradeInfo.stats);\n    }, estimatedTime);\n\n    // Store upgrade info\n    this.activeUpgrades.set(shipId, {\n      timer: upgradeTimer,\n      resourceCost: upgradeInfo.resourceCost,\n      startTime: Date.now(),\n      duration: estimatedTime,\n      targetStats: upgradeInfo.stats,\n    });\n\n    // Emit event\n    this.emit('upgradeStarted', {\n      shipId,\n      resourceCost: upgradeInfo.resourceCost,\n      estimatedTime,\n    });\n  }\n\n  /**\n   * Cancel an ongoing upgrade\n   */\n  public cancelUpgrade(shipId: string): void {\n    const upgradeInfo = this.activeUpgrades.get(shipId);\n    if (!upgradeInfo) {\n      throw new Error('No active upgrade found for ship');\n    }\n\n    // Clear the timer\n    clearTimeout(upgradeInfo.timer);\n\n    // Calculate progress and refund resources\n    const progress = Math.min(1, (Date.now() - upgradeInfo.startTime) / upgradeInfo.duration);\n    const refundedResources = upgradeInfo.resourceCost.map(cost => ({\n      type: cost.type,\n      amount: Math.floor(cost.amount * (1 - progress) * 0.75), // 75% refund of remaining resources\n    }));\n\n    // Return resources\n    refundedResources.forEach(refund => {\n      this.resourceManager.addResource(refund.type, refund.amount);\n    });\n\n    // Find and update ship status\n    for (const bay of this.state.bays) {\n      const ship = bay.ships.find(s => s.id === shipId);\n      if (ship) {\n        ship.status = 'ready';\n        break;\n      }\n    }\n\n    // Clean up\n    this.activeUpgrades.delete(shipId);\n\n    // Emit event\n    this.emit('upgradeCancelled', {\n      shipId,\n      refundedResources,\n    });\n  }\n\n  /**\n   * Complete a ship upgrade\n   */\n  private completeUpgrade(shipId: string, targetStats: ShipUpgradeStats): void {\n    // Find the ship\n    let upgradedShip: CommonShip | undefined;\n    let upgradedBay: ShipHangarBay | undefined;\n\n    for (const bay of this.state.bays) {\n      const ship = bay.ships.find(s => s.id === shipId);\n      if (ship) {\n        upgradedShip = ship;\n        upgradedBay = bay;\n        break;\n      }\n    }\n\n    if (!upgradedShip || !upgradedBay) {\n      console.error('Ship not found for upgrade completion');\n      return;\n    }\n\n    // Update ship stats\n    upgradedShip.stats.health = targetStats.hull.upgraded;\n    upgradedShip.stats.maxHealth = targetStats.hull.upgraded;\n    upgradedShip.stats.shield = targetStats.shield.upgraded;\n    upgradedShip.stats.maxShield = targetStats.shield.upgraded;\n    upgradedShip.stats.speed = targetStats.speed.upgraded;\n    upgradedShip.status = 'ready';\n\n    // Update bay tier\n    upgradedBay.tier = (upgradedBay.tier + 1) as Tier;\n\n    // Clean up\n    this.activeUpgrades.delete(shipId);\n\n    // Emit event\n    this.emit('upgradeCompleted', {\n      shipId,\n      newTier: upgradedBay.tier,\n      stats: targetStats,\n    });\n  }\n\n  /**\n   * Apply ship effects when activating abilities\n   */\n  public activateAbility(shipId: string, abilityName: string): void {\n    const ship = this.findShipById(shipId);\n    if (!ship || !ship.abilities) {\n      this.emit('error', { message: `Ship ${shipId} not found or has no abilities` });\n      return;\n    }\n\n    const ability = ship.abilities.find(a => a.name === abilityName);\n    if (!ability) {\n      this.emit('error', { message: `Ability ${abilityName} not found on ship ${shipId}` });\n      return;\n    }\n\n    // Check if ability is on cooldown\n    const cooldownKey = `${shipId}-${abilityName}`;\n    if (this.abilityCooldowns.has(cooldownKey)) {\n      const remainingCooldown = this.getAbilityCooldown(shipId, abilityName);\n      this.emit('error', {\n        message: `Ability ${abilityName} is on cooldown for ${remainingCooldown}s`,\n      });\n      return;\n    }\n\n    // Apply ability effect\n    if (ability.effect) {\n      const shipWithState = ship as ShipWithState;\n      // Create a ShipEffect from the ability's Effect\n      const shipEffect: ShipEffect = {\n        id: `${ability.id}-effect`,\n        name: abilityName, // Use ability name since Effect doesn't have name\n        description: `Effect of ${abilityName}`, // Use a generated description\n        type: 'buff', // Default to buff\n        magnitude: ability.effect.magnitude,\n        duration: ability.effect.duration,\n        active: true,\n        cooldown: ability.effect.cooldown ?? 0,\n        source: {\n          type: 'ability',\n          id: ability.id,\n        },\n      };\n      this.applyShipEffect(shipWithState, shipEffect);\n    }\n\n    // Set up ability timer\n    const timer = setTimeout(() => {\n      this.deactivateAbility(shipId, abilityName);\n    }, ability.duration * 1000);\n\n    this.activeAbilities.set(`${shipId}-${abilityName}`, {\n      timer,\n      ability,\n      startTime: Date.now(),\n    });\n\n    this.emit('abilityActivated', {\n      shipId,\n      abilityName,\n      duration: ability.duration,\n      effect: ability.effect,\n    });\n  }\n\n  /**\n   * Deactivate a ship's ability\n   */\n  private deactivateAbility(shipId: string, abilityName: string): void {\n    // Find the ship\n    let targetShip: CommonShip | undefined;\n\n    for (const bay of this.state.bays) {\n      const ship = bay.ships.find(s => s.id === shipId);\n      if (ship) {\n        targetShip = ship;\n        break;\n      }\n    }\n\n    if (!targetShip) {\n      console.error('Ship not found for ability deactivation');\n      return;\n    }\n\n    // Find and update the ability\n    const ability = targetShip.abilities.find(a => a.name === abilityName);\n    if (ability) {\n      ability.active = false;\n      ability.effect.active = false;\n    }\n\n    // Clean up active ability\n    const activeKey = `${shipId}-${abilityName}`;\n    const activeInfo = this.activeAbilities.get(activeKey);\n    if (activeInfo) {\n      clearTimeout(activeInfo.timer);\n      this.activeAbilities.delete(activeKey);\n    }\n\n    // Emit event\n    this.emit('abilityDeactivated', {\n      shipId,\n      abilityName,\n    });\n  }\n\n  /**\n   * Get ability cooldown info\n   */\n  public getAbilityCooldown(shipId: string, abilityName: string): number {\n    const cooldownInfo = this.abilityCooldowns.get(`${shipId}-${abilityName}`);\n    if (!cooldownInfo) {\n      return 0;\n    }\n\n    const remainingTime = Math.max(0, cooldownInfo.endTime - Date.now());\n    return Math.ceil(remainingTime / 1000);\n  }\n\n  /**\n   * Get active abilities for a ship\n   */\n  public getActiveAbilities(shipId: string): string[] {\n    const shipAbilities = Array.from(this.activeAbilities.entries()).filter(([key]) =>\n      key.startsWith(`${shipId}-`)\n    );\n\n    return shipAbilities.map(([key]) => key.split('-')[1]);\n  }\n\n  /**\n   * Cancel all active abilities for a ship\n   */\n  public cancelShipAbilities(shipId: string): void {\n    // Find all active abilities for this ship\n    const shipAbilities = Array.from(this.activeAbilities.entries()).filter(([key]) =>\n      key.startsWith(`${shipId}-`)\n    );\n\n    // Deactivate each ability\n    shipAbilities.forEach(([key]) => {\n      const abilityName = key.split('-')[1];\n      this.deactivateAbility(shipId, abilityName);\n    });\n  }\n\n  /**\n   * Get available weapons for a ship\n   */\n  public getAvailableWeapons(shipId: string): WeaponConfig[] {\n    // Find the ship\n    let targetShip: CommonShip | undefined;\n\n    for (const bay of this.state.bays) {\n      const ship = bay.ships.find(s => s.id === shipId);\n      if (ship) {\n        targetShip = ship;\n        break;\n      }\n    }\n\n    if (!targetShip) {\n      throw new Error('Ship not found');\n    }\n\n    // Get ship blueprint\n    const blueprint = SHIP_BLUEPRINTS.find(bp => bp.shipClass === this.getShipClass(targetShip));\n    if (!blueprint) {\n      return [];\n    }\n\n    // Return available weapons based on ship tier and requirements\n    return (\n      blueprint.weapons?.map(weapon => ({\n        id: weapon.name.toLowerCase().replace(/\\s+/g, '-'),\n        name: weapon.name,\n        category: 'machineGun' as WeaponCategory,\n        tier: blueprint.tier,\n        baseStats: {\n          damage: weapon.damage,\n          range: weapon.range,\n          accuracy: 0.8,\n          rateOfFire: 1 / weapon.cooldown,\n          energyCost: 5,\n          cooldown: weapon.cooldown,\n          effects: [\n            {\n              id: uuidv4(),\n              type: 'damage',\n              duration: 0,\n              magnitude: weapon.damage,\n              strength: weapon.damage,\n              name: 'Direct Damage',\n              description: 'Deals direct damage to target',\n              damageType: 'physical',\n              penetration: 0,\n            },\n          ] as WeaponEffectType[],\n        },\n        visualAsset: `weapons/${weapon.name.toLowerCase().replace(/\\s+/g, '-')}`,\n        mountRequirements: {\n          size: 'medium' as WeaponMountSize,\n          power: 20,\n        },\n      })) ?? []\n    );\n  }\n\n  /**\n   * Equip a weapon to a ship's mount\n   */\n  public equipWeapon(shipId: string, mountId: string, weaponId: string): void {\n    // Find the ship\n    let targetShip: CommonShip | undefined;\n\n    for (const bay of this.state.bays) {\n      const ship = bay.ships.find(s => s.id === shipId);\n      if (ship) {\n        targetShip = ship;\n        break;\n      }\n    }\n\n    if (!targetShip) {\n      throw new Error('Ship not found');\n    }\n\n    // Find the mount\n    const mount = targetShip.stats.weapons.find(m => m.id === mountId);\n    if (!mount) {\n      throw new Error('Mount not found');\n    }\n\n    // Find the weapon config\n    const availableWeapons = this.getAvailableWeapons(shipId);\n    const weaponConfig = availableWeapons.find(w => w.id === weaponId);\n    if (!weaponConfig) {\n      throw new Error('Weapon not found');\n    }\n\n    // Check mount compatibility\n    if (mount.size !== weaponConfig.mountRequirements.size) {\n      throw new Error('Incompatible mount size');\n    }\n\n    if (!mount.allowedCategories.includes(weaponConfig.category)) {\n      throw new Error('Incompatible weapon category');\n    }\n\n    // Create weapon instance\n    mount.currentWeapon = {\n      config: weaponConfig,\n      state: {\n        status: 'ready',\n        currentStats: { ...weaponConfig.baseStats },\n        effects: [\n          {\n            id: uuidv4(),\n            type: 'damage',\n            duration: 0,\n            magnitude: weaponConfig.baseStats.damage,\n            strength: weaponConfig.baseStats.damage,\n            name: 'Direct Damage',\n            description: 'Deals direct damage to target',\n            damageType: 'physical',\n            penetration: 0,\n          },\n        ] as WeaponEffectType[],\n      },\n    };\n\n    // Emit event\n    this.emit('weaponEquipped', {\n      shipId,\n      mountId,\n      weaponId,\n    });\n  }\n\n  /**\n   * Unequip a weapon from a ship's mount\n   */\n  public unequipWeapon(shipId: string, mountId: string): void {\n    // Find the ship\n    let targetShip: CommonShip | undefined;\n\n    for (const bay of this.state.bays) {\n      const ship = bay.ships.find(s => s.id === shipId);\n      if (ship) {\n        targetShip = ship;\n        break;\n      }\n    }\n\n    if (!targetShip) {\n      throw new Error('Ship not found');\n    }\n\n    // Find the mount\n    const mount = targetShip.stats.weapons.find(m => m.id === mountId);\n    if (!mount) {\n      throw new Error('Mount not found');\n    }\n\n    if (!mount.currentWeapon) {\n      throw new Error('No weapon equipped');\n    }\n\n    // Store weapon info for event\n    const weaponId = mount.currentWeapon.config.id;\n\n    // Remove weapon\n    mount.currentWeapon = undefined;\n\n    // Emit event\n    this.emit('weaponUnequipped', {\n      shipId,\n      mountId,\n      weaponId,\n    });\n  }\n\n  /**\n   * Get weapon loadout for a ship\n   */\n  public getWeaponLoadout(shipId: string): WeaponMount[] {\n    // Find the ship\n    let targetShip: CommonShip | undefined;\n\n    for (const bay of this.state.bays) {\n      const ship = bay.ships.find(s => s.id === shipId);\n      if (ship) {\n        targetShip = ship;\n        break;\n      }\n    }\n\n    if (!targetShip) {\n      throw new Error('Ship not found');\n    }\n\n    return targetShip.stats.weapons;\n  }\n\n  /**\n   * Set up maintenance timer for a bay\n   */\n  private setupBayMaintenance(bay: ShipHangarBay): void {\n    // Clear existing timer if any\n    const existingTimer = this.bayMaintenanceTimers.get(bay.id);\n    if (existingTimer) {\n      clearTimeout(existingTimer.timer);\n    }\n\n    // Set up new maintenance timer\n    const maintenanceInterval = 300000; // 5 minutes\n    const timer = setInterval(() => {\n      this.performBayMaintenance(bay.id);\n    }, maintenanceInterval);\n\n    this.bayMaintenanceTimers.set(bay.id, {\n      timer,\n      lastMaintenance: bay.lastMaintenance,\n      efficiency: bay.efficiency,\n    });\n  }\n\n  /**\n   * Perform maintenance on a bay\n   */\n  private performBayMaintenance(bayId: string): void {\n    const bay = this.state.bays.find(b => b.id === bayId);\n    if (!bay) {\n      return;\n    }\n\n    // Check if we have enough resources for maintenance\n    const canAfford = bay.maintenanceCost.every(cost => {\n      const currentAmount = this.resourceManager.getResourceAmount(cost.type);\n      return currentAmount >= cost.amount;\n    });\n\n    if (!canAfford) {\n      // Reduce efficiency if maintenance is skipped\n      bay.efficiency = Math.max(0.5, bay.efficiency - 0.1);\n      this.emit('bayMaintenanceSkipped', {\n        bayId,\n        newEfficiency: bay.efficiency,\n        reason: 'insufficient_resources',\n      });\n      return;\n    }\n\n    // Deduct maintenance costs\n    bay.maintenanceCost.forEach(cost => {\n      this.resourceManager.removeResource(cost.type, cost.amount);\n    });\n\n    // Update efficiency based on bay status\n    const efficiencyBonus = this.getBayEfficiencyBonus(bay);\n    bay.efficiency = Math.min(1.0, bay.efficiency + 0.1 * efficiencyBonus);\n    bay.lastMaintenance = Date.now();\n\n    this.emit('bayMaintained', {\n      bayId,\n      newEfficiency: bay.efficiency,\n      maintenanceCost: bay.maintenanceCost,\n    });\n  }\n\n  /**\n   * Get bay efficiency bonus\n   */\n  private getBayEfficiencyBonus(bay: ShipHangarBay): number {\n    // Base multiplier from tier\n    const tierMultiplier = 1 + (bay.tier - 1) * 0.1; // 10% per tier\n\n    // Efficiency factor\n    const efficiencyFactor = bay.efficiency;\n\n    // Capacity utilization bonus\n    const utilizationBonus =\n      bay.ships.length > 0 ? Math.min(1.2, 1 + (bay.ships.length / bay.capacity) * 0.2) : 1.0;\n\n    return tierMultiplier * efficiencyFactor * utilizationBonus;\n  }\n\n  /**\n   * Assign an officer to a ship\n   */\n  public assignOfficer(shipId: string, officerId: string): void {\n    // Find the ship\n    let targetShip: CommonShip | undefined;\n\n    for (const bay of this.state.bays) {\n      const ship = bay.ships.find(s => s.id === shipId);\n      if (ship) {\n        targetShip = ship;\n        break;\n      }\n    }\n\n    if (!targetShip) {\n      throw new Error('Ship not found');\n    }\n\n    // Get the officer\n    const officer = this.officerManager.getOfficer(officerId);\n    if (!officer) {\n      throw new Error('Officer not found');\n    }\n\n    // Check if officer is available\n    if (officer.status !== 'available') {\n      throw new Error('Officer is not available');\n    }\n\n    // Calculate bonuses based on officer skills and specialization\n    const bonuses = this.calculateOfficerBonuses(officer, targetShip);\n\n    // Assign officer\n    this.assignedOfficers.set(shipId, officerId);\n    this.officerManager.assignOfficer(officerId, shipId);\n\n    // Apply bonuses to ship\n    this.applyOfficerBonuses(targetShip, bonuses);\n\n    // Emit event\n    this.emit('officerAssigned', {\n      shipId,\n      officerId,\n      bonuses,\n    });\n  }\n\n  /**\n   * Unassign an officer from a ship\n   */\n  public unassignOfficer(shipId: string): void {\n    const officerId = this.assignedOfficers.get(shipId);\n    if (!officerId) {\n      return;\n    }\n\n    // Find the ship\n    let targetShip: CommonShip | undefined;\n\n    for (const bay of this.state.bays) {\n      const ship = bay.ships.find(s => s.id === shipId);\n      if (ship) {\n        targetShip = ship;\n        break;\n      }\n    }\n\n    if (!targetShip) {\n      return;\n    }\n\n    // Remove bonuses\n    this.removeOfficerBonuses(targetShip);\n\n    // Unassign officer\n    this.assignedOfficers.delete(shipId);\n    this.officerManager.assignOfficer(officerId, null as unknown as string);\n\n    // Emit event\n    this.emit('officerUnassigned', {\n      shipId,\n      officerId,\n    });\n  }\n\n  /**\n   * Calculate bonuses provided by an officer\n   */\n  private calculateOfficerBonuses(\n    officer: Officer,\n    ship: CommonShip\n  ): {\n    buildSpeed?: number;\n    resourceEfficiency?: number;\n    combatEffectiveness?: number;\n  } {\n    const bonuses = {\n      buildSpeed: 0,\n      resourceEfficiency: 0,\n      combatEffectiveness: 0,\n    };\n\n    // Base bonuses from level\n    const levelBonus = (officer.level - 1) * 0.05; // 5% per level\n\n    // Specialization bonuses\n    switch (officer.specialization) {\n      case 'War':\n        if (ship.category === 'war') {\n          bonuses.combatEffectiveness = 0.2 + levelBonus; // 20% base + level bonus\n          bonuses.buildSpeed = 0.1 + levelBonus; // 10% base + level bonus\n        }\n        break;\n      case 'Mining':\n        bonuses.resourceEfficiency = 0.2 + levelBonus; // 20% base + level bonus\n        break;\n      case 'Recon':\n        bonuses.buildSpeed = 0.15 + levelBonus; // 15% base + level bonus\n        bonuses.resourceEfficiency = 0.1 + levelBonus; // 10% base + level bonus\n        break;\n    }\n\n    // Skill bonuses\n    bonuses.combatEffectiveness += officer.skills.combat * 0.01; // 1% per combat skill\n    bonuses.resourceEfficiency += officer.skills.technical * 0.01; // 1% per technical skill\n    bonuses.buildSpeed += officer.skills.leadership * 0.01; // 1% per leadership skill\n\n    return bonuses;\n  }\n\n  /**\n   * Apply officer bonuses to a ship\n   */\n  private applyOfficerBonuses(\n    ship: CommonShip,\n    bonuses: {\n      buildSpeed?: number;\n      resourceEfficiency?: number;\n      combatEffectiveness?: number;\n    }\n  ): void {\n    if (bonuses.combatEffectiveness) {\n      // Apply combat bonuses\n      ship.stats.weapons?.forEach(mount => {\n        if (mount.currentWeapon) {\n          const stats = mount.currentWeapon.state.currentStats;\n          stats.damage *= 1 + bonuses.combatEffectiveness!;\n          stats.accuracy *= 1 + bonuses.combatEffectiveness! * 0.5;\n        }\n      });\n    }\n\n    // Store bonuses for build speed and resource efficiency\n    ship.officerBonuses = bonuses;\n  }\n\n  /**\n   * Remove officer bonuses from a ship\n   */\n  private removeOfficerBonuses(ship: CommonShip): void {\n    if (!ship.officerBonuses) {\n      return;\n    }\n\n    if (ship.officerBonuses.combatEffectiveness) {\n      // Remove combat bonuses\n      ship.stats.weapons?.forEach(mount => {\n        if (mount.currentWeapon) {\n          const stats = mount.currentWeapon.state.currentStats;\n          stats.damage /= 1 + ship.officerBonuses!.combatEffectiveness!;\n          stats.accuracy /= 1 + ship.officerBonuses!.combatEffectiveness! * 0.5;\n        }\n      });\n    }\n\n    // Clear stored bonuses\n    delete ship.officerBonuses;\n  }\n\n  /**\n   * Cleanup resources\n   */\n  public cleanup(): void {\n    // Clear all repair timers\n    this.activeRepairs.forEach((repair, shipId) => {\n      clearTimeout(repair.timer);\n      // Update ship status\n      const ship = this.getDockedShips().find(s => s.id === shipId);\n      if (ship) {\n        ship.status = 'damaged'; // Revert to damaged state if repair was interrupted\n      }\n    });\n    this.activeRepairs.clear();\n\n    // Clear all upgrade timers\n    this.activeUpgrades.forEach((upgrade, shipId) => {\n      clearTimeout(upgrade.timer);\n      // Revert ship status and refund resources for interrupted upgrades\n      const ship = this.getDockedShips().find(s => s.id === shipId);\n      if (ship) {\n        ship.status = 'ready';\n        // Refund 75% of remaining upgrade costs\n        const remainingProgress = 1 - (Date.now() - upgrade.startTime) / upgrade.duration;\n        upgrade.resourceCost.forEach(cost => {\n          const refundAmount = Math.floor(cost.amount * remainingProgress * 0.75);\n          this.resourceManager.addResource(cost.type, refundAmount);\n        });\n      }\n    });\n    this.activeUpgrades.clear();\n\n    // Clear all ability timers\n    this.activeAbilities.forEach((active, key) => {\n      clearTimeout(active.timer);\n      // Parse shipId and ability name from compound key\n      const [shipId, abilityName] = key.split('-');\n      const ship = this.getDockedShips().find(s => s.id === shipId);\n      if (ship) {\n        const ability = ship.abilities.find(a => a.name === abilityName);\n        if (ability) {\n          ability.active = false;\n          ability.effect.active = false;\n        }\n      }\n    });\n    this.activeAbilities.clear();\n\n    // Clear all cooldown timers\n    this.abilityCooldowns.forEach((cooldown, key) => {\n      clearTimeout(cooldown.timer);\n      // Parse shipId and ability name from compound key\n      const [shipId, abilityName] = key.split('-');\n      const ship = this.getDockedShips().find(s => s.id === shipId);\n      if (ship) {\n        const ability = ship.abilities.find(a => a.name === abilityName);\n        if (ability) {\n          ability.effect.cooldown = 0; // Reset cooldown\n        }\n      }\n    });\n    this.abilityCooldowns.clear();\n\n    // Clear all weapon states\n    this.state.bays.forEach(bay => {\n      bay.ships.forEach(ship => {\n        ship.stats.weapons.forEach(mount => {\n          if (mount.currentWeapon) {\n            mount.currentWeapon.state.status = 'ready';\n            // Ensure effects array exists\n            if (!mount.currentWeapon.state.effects) {\n              mount.currentWeapon.state.effects = [];\n            }\n          }\n        });\n      });\n    });\n\n    // Clear all bay maintenance timers\n    this.bayMaintenanceTimers.forEach((info, bayId) => {\n      clearTimeout(info.timer);\n      // Update bay maintenance state\n      const bay = this.state.bays.find(b => b.id === bayId);\n      if (bay) {\n        bay.lastMaintenance = info.lastMaintenance;\n        bay.efficiency = info.efficiency;\n        // Emit maintenance failed event since cleanup interrupts maintenance\n        this.emit('bayMaintenanceFailed', {\n          bayId,\n          newEfficiency: bay.efficiency,\n          requiredResources: bay.maintenanceCost,\n        });\n      }\n    });\n    this.bayMaintenanceTimers.clear();\n\n    // Clean up officer assignments and remove bonuses\n    for (const [shipId, officerId] of Array.from(this.assignedOfficers.entries())) {\n      const ship = this.getDockedShips().find(s => s.id === shipId);\n      if (ship) {\n        this.removeOfficerBonuses(ship); // Remove any active bonuses\n        this.officerManager.assignOfficer(officerId, null as unknown as string); // Free up the officer\n      }\n      this.unassignOfficer(shipId);\n    }\n    this.assignedOfficers.clear();\n  }\n\n  /**\n   * Get all assigned officers\n   */\n  public getAssignedOfficers(): { shipId: string; officerId: string }[] {\n    const assignments: { shipId: string; officerId: string }[] = [];\n    for (const [shipId, officerId] of Array.from(this.assignedOfficers.entries())) {\n      assignments.push({ shipId, officerId });\n    }\n    return assignments;\n  }\n\n  // Add effect handling methods\n  /**\n   * Apply an effect to a ship\n   */\n  private applyShipEffect(ship: ShipWithState, effect: ShipEffect): void {\n    // Initialize ship state if needed\n    if (!ship.state) {\n      ship.state = { activeEffects: [], effectHistory: [] };\n    }\n\n    // Apply effect modifiers\n    switch (effect.type) {\n      case 'buff':\n        if (effect.name.includes('damage')) {\n          ship.stats.weapons?.forEach(mount => {\n            if (mount.currentWeapon) {\n              mount.currentWeapon.state.currentStats.damage *= 1 + effect.magnitude;\n            }\n          });\n        }\n        break;\n      case 'debuff':\n        if (effect.name.includes('shield')) {\n          ship.stats.shield *= 1 - effect.magnitude;\n        }\n        break;\n      case 'status':\n        // Just track status effects\n        break;\n    }\n\n    // Add to active effects\n    ship.state.activeEffects.push(effect);\n    ship.state.effectHistory.push({\n      effect,\n      appliedAt: Date.now(),\n    });\n\n    // Set up effect expiration\n    if (effect.duration > 0) {\n      setTimeout(() => {\n        this.removeShipEffect(ship, effect);\n      }, effect.duration * 1000);\n    }\n  }\n\n  private removeShipEffect(ship: ShipWithState, effect: ShipEffect): void {\n    if (!ship.state) {\n      return;\n    }\n\n    // Remove effect modifiers\n    switch (effect.type) {\n      case 'buff':\n        if (effect.name.includes('damage')) {\n          ship.stats.weapons?.forEach(mount => {\n            if (mount.currentWeapon) {\n              mount.currentWeapon.state.currentStats.damage /= 1 + effect.magnitude;\n            }\n          });\n        }\n        break;\n      case 'debuff':\n        if (effect.name.includes('shield')) {\n          ship.stats.shield /= 1 - effect.magnitude;\n        }\n        break;\n    }\n\n    // Remove from active effects\n    ship.state.activeEffects = ship.state.activeEffects.filter(e => e !== effect);\n\n    // Update history\n    const historyEntry = ship.state.effectHistory.find(h => h.effect === effect && !h.removedAt);\n    if (historyEntry) {\n      historyEntry.removedAt = Date.now();\n    }\n  }\n\n  public hasOfficerMeetingRequirements(minLevel: number, specialization: string): boolean {\n    // Check all assigned officers for one that meets requirements\n    for (const [_, officerId] of Array.from(this.assignedOfficers.entries())) {\n      const officer = this.officerManager.getOfficer(officerId);\n      if (officer && officer.level >= minLevel && officer.specialization === specialization) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Find a ship by ID across all bays\n   */\n  private findShipById(shipId: string): CommonShip | undefined {\n    for (const bay of this.state.bays) {\n      const ship = bay.ships.find(s => s.id === shipId);\n      if (ship) {\n        return ship;\n      }\n    }\n    return undefined;\n  }\n\n  private checkTechRequirements(requirements: ShipBuildRequirements): boolean {\n    if (!requirements.prerequisites?.technology || !this.techTreeInstance) {\n      return true; // No tech requirements or tech tree unavailable\n    }\n    \n    const missingTech = requirements.prerequisites.technology.filter(\n      techId => !this.techTreeInstance?.getNode(techId)?.unlocked\n    );\n    \n    return missingTech.length === 0;\n  }\n\n  private getRequirementsStatus(requirements: ShipBuildRequirements): RequirementCheckResult[] {\n    const result: RequirementCheckResult[] = [];\n    \n    // Check tech requirements\n    if (requirements.prerequisites?.technology && this.techTreeInstance) {\n      requirements.prerequisites.technology.forEach((tech: string) => {\n        result.push({\n          type: 'tech',\n          name: tech,\n          met: this.techTreeInstance?.getNode(tech)?.unlocked || false,\n        });\n      });\n    }\n    \n    // Rest of method...\n    \n    return result;\n  }\n\n  /**\n   * Add a ship design to the available designs\n   * @param design The ship design blueprint to add\n   */\n  private addShipDesign(design: ShipBlueprint | undefined): void {\n    if (!design) {\n      console.warn('[ShipHangarManager] Attempted to add undefined ship design');\n      return;\n    }\n    // Implementation details would go here\n    console.log(`Added ship design: ${design.name}`);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/module/SubModuleManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/resource/AdaptivePerformanceManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/resource/ResourceConversionManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_recipeId' is defined but never used.","line":269,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":269,"endColumn":43},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_processId' is defined but never used.","line":411,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":411,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_process' is defined but never used.","line":412,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":412,"endColumn":13},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_converter' is defined but never used.","line":413,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":413,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_recipe' is defined but never used.","line":414,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":414,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_efficiency' is defined but never used.","line":427,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":427,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_inputs' is defined but never used.","line":476,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":476,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_converter' is defined but never used.","line":488,"column":40,"nodeType":null,"messageId":"unusedVar","endLine":488,"endColumn":50}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * ResourceConversionManager.ts\n *\n * This module handles resource conversion functionality extracted from ResourceFlowManager.\n * It manages conversion recipes, processes, and chains.\n */\n\nimport { AbstractBaseManager } from '../../lib/managers/BaseManager';\nimport { Singleton } from '../../lib/patterns/Singleton';\nimport { ModuleType } from '../../types/buildings/ModuleTypes';\nimport { BaseEvent, EventType } from '../../types/events/EventTypes';\nimport { ResourceConversionRecipe as ExtendedResourceConversionRecipe } from '../../types/resources/ResourceConversionTypes';\nimport { ResourceType } from '../../types/resources/ResourceTypes';\nimport {\n  ChainExecutionStatus,\n  ConversionChain,\n  ConverterFlowNode,\n  FlowNode,\n  ResourceConversionRecipe,\n} from '../../types/resources/StandardizedResourceTypes';\nimport {\n  ConversionResult,\n  ExtendedResourceConversionProcess,\n  ResourceFlowEvent,\n} from './ResourceFlowTypes';\n\n/**\n * Manager for resource conversion processes\n */\n// @ts-expect-error: The Singleton class has a type compatibility issue that needs to be addressed at a higher level\nexport class ResourceConversionManager extends Singleton<ResourceConversionManager> {\n  // Singleton instance\n  private static _instance: ResourceConversionManager | null = null;\n\n  /**\n   * Get the singleton instance of ResourceConversionManager\n   */\n  public static getInstance(): ResourceConversionManager {\n    if (!ResourceConversionManager._instance) {\n      ResourceConversionManager._instance = new ResourceConversionManager();\n    }\n    return ResourceConversionManager._instance;\n  }\n\n  // Conversion processing\n  private processingQueue: ExtendedResourceConversionProcess[] = [];\n  private _completedProcesses: ExtendedResourceConversionProcess[] = [];\n  private conversionRecipes: Map<string, ResourceConversionRecipe> = new Map();\n  private conversionChains: Map<string, ConversionChain> = new Map();\n  private chainExecutions: Map<string, ChainExecutionStatus> = new Map();\n\n  // Intervals\n  private processingInterval: number | null = null;\n  private processingIntervalMs = 1000;\n\n  // Resource flow settings\n  private _resourceCapacityBuffer = 0.05; // 5% buffer to prevent overflow\n  private _lastProcessingTime = 0;\n  private maxHistorySize = 1000;\n\n  // Parent manager reference for event publishing\n  private parentManager: AbstractBaseManager<ResourceFlowEvent> | null = null;\n\n  /**\n   * Private constructor to enforce singleton pattern\n   */\n  protected constructor() {\n    super();\n  }\n\n  /**\n   * Set the parent manager for event publishing\n   */\n  public setParentManager(manager: AbstractBaseManager<ResourceFlowEvent>): void {\n    this.parentManager = manager;\n  }\n\n  /**\n   * Initialize the conversion manager\n   */\n  public async initialize(): Promise<void> {\n    this.startProcessingInterval(this.processingIntervalMs);\n  }\n\n  /**\n   * Dispose of resources\n   */\n  public async dispose(): Promise<void> {\n    if (this.processingInterval !== null) {\n      clearInterval(this.processingInterval);\n      this.processingInterval = null;\n    }\n\n    this.processingQueue = [];\n    this._completedProcesses = [];\n    this.conversionRecipes.clear();\n    this.conversionChains.clear();\n    this.chainExecutions.clear();\n  }\n\n  /**\n   * Register a conversion recipe\n   */\n  public registerConversionRecipe(recipe: ResourceConversionRecipe): boolean {\n    if (!recipe.id) {\n      return false;\n    }\n\n    this.conversionRecipes.set(recipe.id, recipe);\n    return true;\n  }\n\n  /**\n   * Register a conversion chain\n   */\n  public registerConversionChain(chain: ConversionChain): boolean {\n    if (!chain.id) {\n      return false;\n    }\n\n    this.conversionChains.set(chain.id, chain);\n    return true;\n  }\n\n  /**\n   * Start a conversion chain\n   */\n  public startConversionChain(chainId: string): boolean {\n    const chain = this.conversionChains.get(chainId);\n    if (!chain) {\n      return false;\n    }\n\n    // Create chain execution status\n    const status: ChainExecutionStatus = {\n      chainId,\n      active: true,\n      paused: false,\n      completed: false,\n      failed: false,\n      startTime: Date.now(),\n      currentStepIndex: 0,\n      recipeIds: chain.steps,\n      estimatedEndTime: 0,\n      progress: 0,\n      resourceTransfers: [],\n      stepStatus: chain.steps.map((recipeId: string) => ({\n        recipeId,\n        status: 'pending',\n        startTime: 0,\n        endTime: 0,\n        processId: '',\n      })),\n    };\n\n    this.chainExecutions.set(chainId, status);\n\n    // Start the first step\n    this.processNextChainStep(chainId);\n\n    return true;\n  }\n\n  /**\n   * Process next step in a conversion chain\n   */\n  private processNextChainStep(chainId: string): void {\n    const status = this.chainExecutions.get(chainId);\n    if (!status || !status.active || status.completed || status.failed) {\n      return;\n    }\n\n    // Get the current step\n    const currentStepIndex = status.currentStepIndex;\n    if (currentStepIndex >= status.recipeIds.length) {\n      // Chain is complete\n      status.completed = true;\n      status.active = false;\n      return;\n    }\n\n    const currentRecipeId = status.recipeIds[currentStepIndex];\n    const stepStatus = status.stepStatus[currentStepIndex];\n\n    // If step is already in progress or completed, skip\n    if (stepStatus.status !== 'pending') {\n      return;\n    }\n\n    // Find a converter that can process this recipe\n    const converters = this.getConvertersForRecipe(currentRecipeId);\n    if (converters.length === 0) {\n      status.failed = true;\n      status.errorMessage = `No converters available for recipe ${currentRecipeId}`;\n      return;\n    }\n\n    // Find an available converter\n    let availableConverter: ConverterFlowNode | null = null;\n    for (const converter of converters) {\n      // Check if converter has capacity\n      if (\n        converter.converterStatus &&\n        converter.converterConfig &&\n        converter.converterStatus.activeProcesses.length >=\n          converter.converterConfig.maxConcurrentProcesses\n      ) {\n        continue;\n      }\n\n      availableConverter = converter;\n      break;\n    }\n\n    if (!availableConverter) {\n      return; // No available converters, try again later\n    }\n\n    // Start conversion process\n    const result = this.startConversionProcess(availableConverter.id, currentRecipeId);\n    if (!result?.success) {\n      status.failed = true;\n      status.errorMessage =\n        result?.error || `Failed to start conversion for recipe ${currentRecipeId}`;\n      return;\n    }\n\n    // Update step status\n    stepStatus.status = 'in-progress';\n    stepStatus.startTime = Date.now();\n    stepStatus.processId = result?.processId;\n    stepStatus.converterId = availableConverter.id;\n\n    // Emit event for chain step started\n    if (this.parentManager) {\n      // Create event data\n      const eventData = {\n        // Use a valid EventType enum value\n        type: EventType.RESOURCE_UPDATED, // Use an existing EventType value\n        chainId,\n        stepIndex: currentStepIndex,\n        recipeId: currentRecipeId,\n        processId: result?.processId,\n        converterId: availableConverter.id,\n        // Add required BaseEvent properties\n        moduleId: 'resource-conversion-manager',\n        moduleType: 'resource-manager' as ModuleType,\n        timestamp: Date.now(),\n        data: {\n          type: 'CHAIN_STEP_STARTED',\n          chainId,\n          stepIndex: currentStepIndex,\n          recipeId: currentRecipeId,\n          processId: result?.processId,\n          converterId: availableConverter.id,\n        },\n      };\n\n      // Use the protected method to publish the event\n      if (typeof this.parentManager['publishEvent'] === 'function') {\n        this.parentManager['publishEvent'](eventData);\n      }\n    }\n  }\n\n  /**\n   * Get converters that can handle a specific recipe\n   */\n  private getConvertersForRecipe(_recipeId: string): ConverterFlowNode[] {\n    // Implementation would query the resource flow manager for converters\n    // For now, return an empty array\n    return [];\n  }\n\n  /**\n   * Start the processing interval\n   */\n  private startProcessingInterval(interval: number): void {\n    if (this.processingInterval !== null) {\n      clearInterval(this.processingInterval);\n    }\n\n    this.processingInterval = setInterval(() => {\n      this.processConversions();\n    }, interval) as unknown as number;\n  }\n\n  /**\n   * Process active conversions\n   */\n  private processConversions(): void {\n    // Process each active conversion\n    for (let i = 0; i < this.processingQueue.length; i++) {\n      const process = this.processingQueue[i];\n      if (!process.active || process.paused) {\n        continue;\n      }\n\n      // Update progress\n      const now = Date.now();\n      const elapsed = now - process.startTime;\n      const recipe = this.conversionRecipes.get(\n        process.recipeId\n      ) as ExtendedResourceConversionRecipe;\n      if (!recipe) {\n        continue;\n      }\n\n      const duration = recipe.processingTime;\n      process.progress = Math.min(1, elapsed / duration);\n\n      // Check if process is complete\n      if (process.progress >= 1) {\n        this.completeProcess(process);\n        this.processingQueue.splice(i, 1);\n        i--;\n      }\n    }\n\n    // Limit history size\n    if (this._completedProcesses.length > this.maxHistorySize) {\n      this._completedProcesses = this._completedProcesses.slice(\n        this._completedProcesses.length - this.maxHistorySize\n      );\n    }\n  }\n\n  /**\n   * Complete a conversion process\n   */\n  private completeProcess(process: ExtendedResourceConversionProcess): void {\n    // Mark process as complete\n    process.active = false;\n    process.progress = 1;\n    process.endTime = Date.now();\n\n    // Get the recipe\n    const recipe = this.conversionRecipes.get(process.recipeId) as ExtendedResourceConversionRecipe;\n    if (!recipe) {\n      return;\n    }\n\n    // Produce outputs\n    if (this.parentManager) {\n      // Create event data with required BaseEvent properties\n      const eventData = {\n        type: EventType.RESOURCE_UPDATED, // Use a valid EventType enum value\n        processId: process.processId,\n        recipeId: process.recipeId,\n        converterId: process.sourceId,\n        inputs: recipe.inputs,\n        outputs: recipe.outputs,\n        efficiency: process.appliedEfficiency || 1,\n        timestamp: Date.now(),\n        // Add required BaseEvent properties\n        moduleId: 'resource-conversion-manager',\n        moduleType: 'resource-manager' as ModuleType,\n        data: {\n          type: 'RESOURCE_CONVERSION_COMPLETED', // Store the original type in data\n          processId: process.processId,\n          recipeId: process.recipeId,\n          converterId: process.sourceId,\n          inputs: recipe.inputs,\n          outputs: recipe.outputs,\n          efficiency: process.appliedEfficiency || 1,\n        },\n      } as unknown as BaseEvent;\n\n      // Use the protected method to publish the event\n      if (typeof this.parentManager['publishEvent'] === 'function') {\n        this.parentManager['publishEvent'](eventData);\n      }\n    }\n\n    // Update chain execution if this process is part of a chain\n    for (const [chainId, chainStatus] of this.chainExecutions.entries()) {\n      for (let i = 0; i < chainStatus.stepStatus.length; i++) {\n        const step = chainStatus.stepStatus[i];\n        if (step.processId === process.processId) {\n          // Mark step as complete\n          step.status = 'completed';\n          step.endTime = Date.now();\n\n          // Move to next step\n          chainStatus.currentStepIndex = i + 1;\n          this.processNextChainStep(chainId);\n          break;\n        }\n      }\n    }\n  }\n\n  /**\n   * Start a conversion process\n   */\n  private startConversionProcess(converterId: string, recipeId: string): ConversionResult {\n    // Implementation would start a conversion process\n    // For now, return a placeholder result\n    return {\n      success: false,\n      processId: '',\n      recipeId: recipeId,\n    };\n  }\n\n  /**\n   * Apply efficiency to a conversion process\n   * @private\n   */\n  private _applyEfficiencyToProcess(\n    _processId: string,\n    _process: ExtendedResourceConversionProcess,\n    _converter: FlowNode,\n    _recipe: ResourceConversionRecipe\n  ): number {\n    // Implementation would apply efficiency to a process\n    // For now, return a placeholder value\n    return 1;\n  }\n\n  /**\n   * Apply efficiency to conversion outputs\n   * @private\n   */\n  private _applyEfficiencyToOutputs(\n    _result: ConversionResult,\n    _efficiency: number\n  ): ConversionResult {\n    // Implementation would apply efficiency to outputs\n    // For now, return the input result\n    return _result;\n  }\n\n  /**\n   * Calculate the efficiency of a converter for a specific recipe\n   */\n  private calculateConverterEfficiency(\n    converter: ConverterFlowNode,\n    recipe: ExtendedResourceConversionRecipe\n  ): number {\n    // Base efficiency from recipe\n    let efficiency = recipe.baseEfficiency || 1;\n\n    // Apply converter efficiency\n    if (converter.efficiency) {\n      efficiency *= converter.efficiency;\n    }\n\n    // Apply converter config modifiers\n    if (converter.converterConfig?.efficiencyModifiers) {\n      const recipeModifier = converter.converterConfig.efficiencyModifiers[recipe.id] || 1;\n      efficiency *= recipeModifier;\n    }\n\n    // Apply resource quality factors\n    // Cast to the required type to fix the type compatibility issue\n    const inputs = recipe.inputs as unknown as { type: ResourceType | number; amount: number }[];\n    const qualityFactors = this.calculateResourceQualityFactors(inputs);\n\n    // Apply quality factors\n    Object.entries(qualityFactors).forEach(([_key, value]) => {\n      efficiency *= value;\n    });\n\n    // Apply network stress factor\n    const stressFactor = this.calculateNetworkStressFactor(converter);\n    efficiency *= stressFactor;\n\n    return efficiency;\n  }\n\n  /**\n   * Calculate resource quality factors for a set of inputs\n   */\n  private calculateResourceQualityFactors(\n    _inputs: { type: ResourceType | number; amount: number }[]\n  ): Record<string, number> {\n    // Implementation would calculate quality factors\n    // For now, return a placeholder object\n    return {\n      quality: 1,\n    };\n  }\n\n  /**\n   * Calculate network stress factor for a converter\n   */\n  private calculateNetworkStressFactor(_converter: ConverterFlowNode): number {\n    // Implementation would calculate network stress\n    // For now, return a placeholder value\n    return 1;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/resource/ResourceCostManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/resource/ResourceExchangeManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/resource/ResourceFlowManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_dependencies' is defined but never used.","line":251,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":251,"endColumn":45},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_adaptedConnections' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":840,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":840,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_completedSteps' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":1245,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":1245,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_chainId' is defined but never used.","line":1335,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":1335,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_converter' is defined but never used.","line":1335,"column":51,"nodeType":null,"messageId":"unusedVar","endLine":1335,"endColumn":61},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_activeConnections' is defined but never used.","line":1465,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":1465,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_id' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":1471,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":1471,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_converter' is defined but never used.","line":1477,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":1477,"endColumn":41}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  ResourceStateClass,\n  ResourceType,\n  ResourceTypeString,\n} from '../../types/resources/ResourceTypes';\nimport {\n  ChainExecutionStatus,\n  ConversionChain,\n  ConverterFlowNode,\n  FlowConnection,\n  FlowNode,\n  FlowNodeType,\n  ResourceConversionProcess,\n  ResourceConversionRecipe,\n  ResourceFlow,\n  ResourceState,\n} from '../../types/resources/StandardizedResourceTypes';\n// Import new utility classes\nimport { BaseEvent } from '../../lib/events/UnifiedEventSystem';\nimport { AbstractBaseManager } from '../../lib/managers/BaseManager';\nimport { ResourceTransfer } from '../../types/resources/ResourceTypes';\nimport { SpatialIndex, SpatialObject } from '../../utils/spatial/SpatialPartitioning';\nimport {\n  FlowOptimizationResult,\n  ResourceFlowWorkerUtil,\n} from '../../utils/workers/ResourceFlowWorkerUtil';\n// Import ResourceRegistry and ResourceRegistryIntegration\nimport { ResourceRegistry } from '../../registry/ResourceRegistry';\nimport { ResourceRegistryIntegration } from '../../registry/ResourceRegistryIntegration';\n// Import ResourceTypeConverter functions\nimport {\n  ensureStringResourceType,\n  enumToStringResourceType,\n  stringToEnumResourceType,\n} from '../../utils/resources/ResourceTypeConverter';\n// Import ExtendedResourceConversionRecipe\nimport { ModuleType } from '../../types/buildings/ModuleTypes';\nimport { ExtendedResourceConversionRecipe } from '../../types/resources/ResourceConversionTypes';\n\n// Add type alias for StandardizedResourceType for backward compatibility\ntype StandardizedResourceType = ResourceType;\n\n// Add StandardizedResourceTransfer type definition\ninterface StandardizedResourceTransfer {\n  type: ResourceType;\n  source: string;\n  target: string;\n  amount: number;\n  timestamp: number;\n}\n\n// Extend ConverterNodeConfig with additional properties\ninterface ExtendedConverterNodeConfig {\n  maxConcurrentProcesses: number;\n  efficiencyModifiers: Record<string, number>;\n  tier?: number;\n  chainBonus?: number;\n  type?: string;\n}\n\n/**\n * Interface for ResourceFlowManager\n */\nexport interface IResourceFlowManager {\n  registerNode(node: FlowNode): boolean;\n  unregisterNode(id: string): boolean;\n  registerConnection(connection: FlowConnection): boolean;\n  unregisterConnection(id: string): boolean;\n  updateResourceState(type: ResourceTypeString | ResourceType, state: ResourceState): void;\n  getResourceState(type: ResourceTypeString | ResourceType): ResourceState | undefined;\n  getNode(id: string): FlowNode | undefined;\n  getNodes(): FlowNode[];\n  getConnections(): FlowConnection[];\n  getConnection(id: string): FlowConnection | undefined;\n  createFlow(flow: ResourceFlow): boolean;\n  optimizeFlows(): Promise<FlowOptimizationResult>;\n  getAllResourceStates(): Map<string, { available: number }>;\n  getAllConversionRecipes(): Array<{\n    input: { type: string; amount: number };\n    output: { type: string; amount: number };\n  }>;\n  setConversionRate(sourceType: string, targetType: string, rate: number): void;\n}\n\n// Define ConversionResult interface\ninterface ConversionResult {\n  success: boolean;\n  processId: string;\n  recipeId: string;\n  outputsProduced?: { type: ResourceTypeString; amount: number }[];\n  byproductsProduced?: { type: ResourceTypeString; amount: number }[];\n  error?: string;\n}\n\n// Extend ResourceConversionProcess to include processId\ninterface ExtendedResourceConversionProcess extends ResourceConversionProcess {\n  processId: string;\n}\n\n// Re-export FlowNode interface for use in other components\nexport type { FlowNode } from '../../types/resources/StandardizedResourceTypes';\n\n/**\n * Extended FlowNode with spatial coordinates for geographical networks\n */\ninterface GeoFlowNode extends FlowNode, SpatialObject {\n  // Spatial coordinates\n  x: number;\n  y: number;\n}\n\n/**\n * Resource flow events\n */\nexport interface ResourceFlowEvent extends BaseEvent {\n  type:\n    | 'RESOURCE_FLOW_INITIALIZED'\n    | 'RESOURCE_FLOW_OPTIMIZED'\n    | 'RESOURCE_NODE_REGISTERED'\n    | 'RESOURCE_NODE_UPDATED'\n    | 'RESOURCE_NODE_UNREGISTERED'\n    | 'RESOURCE_CONNECTION_REGISTERED'\n    | 'RESOURCE_CONNECTION_UPDATED'\n    | 'RESOURCE_CONNECTION_UNREGISTERED'\n    | 'RESOURCE_CONVERSION_STARTED'\n    | 'RESOURCE_CONVERSION_COMPLETED'\n    | 'RESOURCE_CONVERSION_FAILED'\n    | 'RESOURCE_TRANSFER_COMPLETED';\n  nodeId?: string;\n  connectionId?: string;\n  resourceType?: ResourceTypeString | ResourceType;\n  processId?: string;\n  data?: unknown;\n}\n\n// Define a type for the resource map to ensure consistency\ntype ResourceStateMap = Map<string, ResourceState>;\ntype ResourceProducersMap = Map<string, string[]>;\ntype ResourceConsumersMap = Map<string, string[]>;\ntype ResourceStorageMap = Map<string, string[]>;\ntype ResourceConvertersMap = Map<string, string[]>;\n\n/**\n * Manager for resource flow through the game systems\n * Responsible for:\n * - Tracking resource nodes (producers, consumers, storage, converters)\n * - Managing connections between nodes\n * - Optimizing resource distribution\n * - Processing resource conversions\n */\n// @ts-expect-error The Singleton class has a type compatibility issue that needs to be addressed at a higher level\nexport class ResourceFlowManager\n  extends AbstractBaseManager<ResourceFlowEvent>\n  implements IResourceFlowManager\n{\n  // Singleton instance\n  private static _instance: ResourceFlowManager | null = null;\n\n  /**\n   * Get the singleton instance of ResourceFlowManager\n   */\n  public static getInstance(): ResourceFlowManager {\n    if (!ResourceFlowManager._instance) {\n      ResourceFlowManager._instance = new ResourceFlowManager();\n    }\n    return ResourceFlowManager._instance;\n  }\n\n  // Flow network data structures\n  private nodes: Map<string, FlowNode> = new Map();\n  private connections: Map<string, FlowConnection> = new Map();\n  private sourceConnections: Map<string, string[]> = new Map();\n  private targetConnections: Map<string, string[]> = new Map();\n\n  // Categorized nodes for faster lookups\n  private producerNodes: Map<string, FlowNode> = new Map();\n  private consumerNodes: Map<string, FlowNode> = new Map();\n  private storageNodes: Map<string, FlowNode> = new Map();\n  private converterNodes: Map<string, ConverterFlowNode> = new Map();\n\n  // Resource state tracking\n  private resourceStates: ResourceStateMap = new Map();\n  private resourceProducers: ResourceProducersMap = new Map();\n  private resourceConsumers: ResourceConsumersMap = new Map();\n  private resourceStorage: ResourceStorageMap = new Map();\n  private resourceConverters: ResourceConvertersMap = new Map();\n\n  // Caching\n  private resourceCache: Map<\n    ResourceTypeString,\n    { state: ResourceState; lastUpdated: number; expiresAt: number }\n  > = new Map();\n  private cacheTTL = 5000; // 5 seconds\n\n  // Transfer history\n  private transferHistory: ResourceTransfer[] = [];\n  private maxHistorySize = 1000;\n\n  // Conversion processing\n  private processingQueue: ExtendedResourceConversionProcess[] = [];\n  private _completedProcesses: ExtendedResourceConversionProcess[] = [];\n  private conversionRecipes: Map<string, ResourceConversionRecipe> = new Map();\n  private conversionChains: Map<string, ConversionChain> = new Map();\n  private chainExecutions: Map<string, ChainExecutionStatus> = new Map();\n\n  // Optimization state\n  private isOptimizing = false;\n  private lastOptimizationResult: FlowOptimizationResult | null = null;\n\n  // Intervals\n  private processingInterval: number | null = null;\n  private optimizationInterval: number | null = null;\n  private optimizationIntervalMs = 5000; // 5 seconds\n\n  // Performance settings\n  private batchSize = 100;\n  private useWorkerOffloading = true;\n  private workerUtil: ResourceFlowWorkerUtil | null = null;\n\n  // Spatial partitioning for geographical networks\n  private spatialIndex: SpatialIndex<GeoFlowNode> | null = null;\n\n  // Resource flow settings\n  private flowOptimizationEnabled = true;\n  private _resourceCapacityBuffer = 0.05; // 5% buffer to prevent overflow\n  private _lastProcessingTime = 0;\n\n  // New properties\n  public useSpatialPartitioning = false;\n  public worldBounds = { minX: 0, minY: 0, maxX: 10000, maxY: 10000 };\n  public processingIntervalMs = 1000;\n\n  // ResourceRegistry integration\n  private resourceRegistry: ResourceRegistry;\n  private registryIntegration: ResourceRegistryIntegration;\n\n  /**\n   * Private constructor to enforce singleton pattern\n   */\n  protected constructor() {\n    super('ResourceFlowManager');\n    this.resourceRegistry = ResourceRegistry.getInstance();\n    this.registryIntegration = ResourceRegistryIntegration.getInstance();\n    this.initializeResourceStates();\n  }\n\n  /**\n   * Implementation of abstract method from AbstractBaseManager\n   * Initialize the manager\n   */\n  protected async onInitialize(_dependencies?: Record<string, unknown>): Promise<void> {\n    // Initialize resource states\n    this.initializeResourceStates();\n\n    // Initialize Web Worker utility if enabled\n    if (this.useWorkerOffloading) {\n      try {\n        this.workerUtil = new ResourceFlowWorkerUtil();\n      } catch (error) {\n        this.handleError(error instanceof Error ? error : new Error(String(error)), {\n          context: 'initializeWorker',\n        });\n        this.useWorkerOffloading = false;\n      }\n    }\n\n    // Initialize spatial index if enabled\n    if (this.useSpatialPartitioning) {\n      this.spatialIndex = new SpatialIndex<GeoFlowNode>(this.worldBounds);\n    }\n\n    // Sync with ResourceRegistry\n    this.syncWithResourceRegistry();\n\n    // Subscribe to module events that might affect resource flow\n    this.subscribeToModuleEvents();\n\n    // Start optimization and processing intervals\n    this.startAsyncOptimizationInterval();\n    this.startProcessingInterval(this.processingIntervalMs);\n\n    // Publish initialization event\n    this.publish({\n      type: 'RESOURCE_FLOW_INITIALIZED',\n      timestamp: Date.now(),\n      data: {\n        optimizationIntervalMs: this.optimizationIntervalMs,\n        cacheTTL: this.cacheTTL,\n        batchSize: this.batchSize,\n        useWorkerOffloading: this.useWorkerOffloading,\n        useSpatialPartitioning: this.useSpatialPartitioning,\n      },\n    });\n  }\n\n  /**\n   * Sync with ResourceRegistry\n   * This method synchronizes the ResourceFlowManager with the ResourceRegistry\n   */\n  private syncWithResourceRegistry(): void {\n    // Register resource flow manager with registry integration\n    // Cast to a specific interface to avoid circular dependency issues\n    interface MinimalResourceFlowManager {\n      getAllResourceStates?: () => Map<string, { available: number }>;\n      getAllConversionRecipes?: () => Array<{\n        input: { type: string; amount: number };\n        output: { type: string; amount: number };\n      }>;\n      setConversionRate?: (sourceType: string, targetType: string, rate: number) => void;\n    }\n\n    this.registryIntegration.syncResourceAvailability(\n      this as unknown as MinimalResourceFlowManager\n    );\n    this.registryIntegration.syncConversionRecipes(this as unknown as MinimalResourceFlowManager);\n\n    // Subscribe to registry events\n    this.resourceRegistry.subscribe('resourceRegistered', data => {\n      if ('resourceType' in data && 'metadata' in data) {\n        // Update local resource state when a new resource is registered\n        const enumType = this.safeResourceTypeConversion(data?.resourceType);\n        const stringType = enumToStringResourceType(enumType);\n\n        if (stringType && !this.resourceStates.has(stringType)) {\n          // Initialize resource state for the new resource\n          const resourceState = new ResourceStateClass({\n            type: enumType,\n          });\n          this.resourceStates.set(stringType, resourceState.asObject());\n          this.resourceProducers.set(stringType, []);\n          this.resourceConsumers.set(stringType, []);\n          this.resourceStorage.set(stringType, []);\n        }\n      }\n    });\n\n    this.resourceRegistry.subscribe('conversionRateChanged', data => {\n      if ('sourceType' in data && 'targetType' in data && 'rate' in data) {\n        // Update conversion recipes when rates change\n        // This is a placeholder for actual implementation\n        console.warn(\n          `Conversion rate changed: ${data?.sourceType} -> ${data?.targetType} = ${data?.rate}`\n        );\n      }\n    });\n  }\n\n  /**\n   * Implementation of abstract method from AbstractBaseManager\n   * Update the manager state\n   */\n  protected onUpdate(deltaTime: number): void {\n    // Process any pending conversions\n    this.processConversions();\n\n    // Update any active chains\n    for (const [chainId, chainStatus] of this.chainExecutions.entries()) {\n      if (chainStatus.active && !chainStatus.paused) {\n        this.updateChainProgress(chainId);\n      }\n    }\n\n    // Update metrics\n    this.updateMetric('nodesCount', this.nodes.size);\n    this.updateMetric('connectionsCount', this.connections.size);\n    this.updateMetric('activeProcessesCount', this.processingQueue.length);\n    this.updateMetric('deltaTime', deltaTime);\n  }\n\n  /**\n   * Implementation of abstract method from AbstractBaseManager\n   * Dispose of the manager's resources\n   */\n  protected async onDispose(): Promise<void> {\n    // Clean up intervals\n    if (this.processingInterval !== null) {\n      clearInterval(this.processingInterval);\n      this.processingInterval = null;\n    }\n\n    if (this.optimizationInterval !== null) {\n      clearInterval(this.optimizationInterval);\n      this.optimizationInterval = null;\n    }\n\n    // Cleanup Web Worker\n    if (this.workerUtil) {\n      this.workerUtil.terminate();\n      this.workerUtil = null;\n    }\n\n    // Clear spatial index\n    if (this.spatialIndex) {\n      this.spatialIndex.clear();\n    }\n\n    // Unsubscribe from module events\n    this.unsubscribeFromModuleEvents();\n\n    // Clear data structures\n    this.nodes.clear();\n    this.connections.clear();\n    this.sourceConnections.clear();\n    this.targetConnections.clear();\n\n    this.producerNodes.clear();\n    this.consumerNodes.clear();\n    this.storageNodes.clear();\n    this.converterNodes.clear();\n\n    this.resourceCache.clear();\n    this.transferHistory = [];\n    this.processingQueue = [];\n    this._completedProcesses = [];\n    this.conversionRecipes.clear();\n    this.conversionChains.clear();\n    this.chainExecutions.clear();\n  }\n\n  /**\n   * Subscribe to module events that might affect resource flow\n   */\n  private subscribeToModuleEvents(): void {\n    // Use the subscribe method from AbstractBaseManager to keep track of subscriptions\n    this.subscribe('MODULE_CREATED', this.handleModuleCreated);\n    this.subscribe('MODULE_UPDATED', this.handleModuleUpdated);\n    this.subscribe('MODULE_DESTROYED', this.handleModuleDestroyed);\n    this.subscribe('MODULE_ENABLED', this.handleModuleStateChanged);\n    this.subscribe('MODULE_DISABLED', this.handleModuleStateChanged);\n  }\n\n  /**\n   * Unsubscribe from module events\n   */\n  private unsubscribeFromModuleEvents(): void {\n    // The AbstractBaseManager.dispose() method will handle unsubscribing from all events\n  }\n\n  /**\n   * Initialize resource states for all known resource types\n   */\n  private initializeResourceStates(): void {\n    // Initialize resource states for all known resource types\n    const resourceTypes: ResourceTypeString[] = [\n      ResourceType.MINERALS,\n      ResourceType.ENERGY,\n      ResourceType.POPULATION,\n      ResourceType.RESEARCH,\n      ResourceType.PLASMA,\n      ResourceType.GAS,\n      ResourceType.EXOTIC,\n    ];\n\n    // Create default resource states\n    resourceTypes.forEach(type => {\n      if (!this.resourceStates.has(type)) {\n        this.resourceStates.set(type, {\n          current: 0,\n          max: 1000,\n          min: 0,\n          production: 0,\n          consumption: 0,\n        });\n      }\n    });\n  }\n\n  /**\n   * Register a node in the resource flow network\n   *\n   * @param node The node to register\n   * @returns True if the node was successfully registered, false otherwise\n   */\n  public registerNode(node: FlowNode): boolean {\n    if (!node.id || !node.resources || node.resources.size === 0) {\n      this.handleError(new Error('Invalid flow node'), { node });\n      return false;\n    }\n\n    this.nodes.set(node.id, node);\n\n    // Add node to type-specific maps\n    if (node.type === FlowNodeType.PRODUCER) {\n      this.producerNodes.set(node.id, node);\n    } else if (node.type === FlowNodeType.CONSUMER) {\n      this.consumerNodes.set(node.id, node);\n    } else if (node.type === FlowNodeType.STORAGE) {\n      this.storageNodes.set(node.id, node);\n    } else if (node.type === FlowNodeType.CONVERTER) {\n      this.converterNodes.set(node.id, node as ConverterFlowNode);\n    }\n\n    // Invalidate cache for affected resource types\n    for (const [resourceType] of node.resources.entries()) {\n      this.invalidateCache(resourceType);\n    }\n\n    // Publish event\n    this.publish({\n      type: 'RESOURCE_NODE_REGISTERED',\n      timestamp: Date.now(),\n      nodeId: node.id,\n      data: { node },\n    });\n\n    return true;\n  }\n\n  /**\n   * Unregister a node from the resource flow network\n   *\n   * @param id The ID of the node to unregister\n   * @returns True if the node was successfully unregistered, false otherwise\n   */\n  public unregisterNode(id: string): boolean {\n    if (!this.nodes.has(id)) {\n      return false;\n    }\n\n    // Get node resources before removing it\n    const node = this.nodes.get(id);\n    const affectedResources = node?.resources ? Array.from(node.resources.keys()) : [];\n\n    // Remove all connections to/from this node\n    // Convert Map entries to array to avoid MapIterator error\n    const connectionEntries = Array.from(this.connections.entries());\n    const removedConnections: FlowConnection[] = [];\n\n    for (const [connectionId, connection] of connectionEntries) {\n      if (connection.source === id || connection.target === id) {\n        this.connections.delete(connectionId);\n        removedConnections.push(connection);\n      }\n    }\n\n    this.nodes.delete(id);\n\n    // Invalidate cache for affected resource types\n    for (const resourceType of affectedResources) {\n      this.invalidateCache(resourceType);\n    }\n\n    // Publish event\n    this.publish({\n      type: 'RESOURCE_NODE_UNREGISTERED',\n      timestamp: Date.now(),\n      nodeId: id,\n      data: {\n        node,\n        removedConnections,\n      },\n    });\n\n    return true;\n  }\n\n  /**\n   * Register a connection between nodes in the resource flow network\n   *\n   * @param connection The connection to register\n   * @returns True if the connection was successfully registered, false otherwise\n   */\n  public registerConnection(connection: FlowConnection): boolean {\n    if (\n      !connection.id ||\n      !connection.source ||\n      !connection.target ||\n      !connection.resourceType ||\n      (connection.maxRate !== undefined && connection.maxRate <= 0)\n    ) {\n      console.warn('Invalid connection:', connection);\n      return false;\n    }\n\n    // Ensure source and target nodes exist\n    if (!this.nodes.has(connection.source)) {\n      console.warn(`Source node ${connection.source} does not exist`);\n      return false;\n    }\n\n    if (!this.nodes.has(connection.target)) {\n      console.warn(`Target node ${connection.target} does not exist`);\n      return false;\n    }\n\n    // Ensure source node has the resource type\n    const sourceNode = this.nodes.get(connection.source);\n    if (\n      sourceNode?.resources &&\n      connection.resourceType &&\n      !sourceNode.resources.has(connection.resourceType)\n    ) {\n      console.warn(\n        `Source node ${connection.source} does not have resource type ${connection.resourceType}`\n      );\n      return false;\n    }\n\n    this.connections.set(connection.id, connection);\n\n    // Invalidate cache for the affected resource type\n    this.invalidateCache(connection.resourceType as ResourceType);\n\n    return true;\n  }\n\n  /**\n   * Unregister a connection from the resource flow network\n   *\n   * @param id The ID of the connection to unregister\n   * @returns True if the connection was successfully unregistered, false otherwise\n   */\n  public unregisterConnection(id: string): boolean {\n    const connection = this.connections.get(id);\n    if (!connection) {\n      return false;\n    }\n\n    // Get resource type before removing\n    const resourceType = this.safeResourceTypeConversion(connection.resourceType);\n\n    this.connections.delete(id);\n\n    // Invalidate cache for the affected resource type\n    this.invalidateCache(resourceType);\n\n    return true;\n  }\n\n  /**\n   * Update the state of a resource\n   *\n   * @param type The type of resource to update\n   * @param state The new state of the resource\n   */\n  public updateResourceState(type: ResourceTypeString | ResourceType, state: ResourceState): void {\n    const stringType = ensureStringResourceType(this.safeResourceTypeConversion(type));\n    this.resourceStates.set(stringType, state);\n\n    // Invalidate cache for the affected resource type\n    this.invalidateCache(this.safeResourceTypeConversion(stringType));\n  }\n\n  /**\n   * Get the state of a resource\n   *\n   * @param type The type of resource to get the state for\n   * @returns The resource state, or undefined if not found\n   */\n  public getResourceState(type: ResourceTypeString | ResourceType): ResourceState | undefined {\n    const stringType = ensureStringResourceType(this.safeResourceTypeConversion(type));\n\n    // Check cache first\n    const now = Date.now();\n    const cachedEntry = this.resourceCache.get(stringType);\n\n    if (cachedEntry && now < cachedEntry.expiresAt) {\n      return cachedEntry.state;\n    }\n\n    // Cache miss or expired, get from network\n    const state = this.resourceStates.get(stringType);\n\n    // Update cache if state exists\n    if (state) {\n      this.resourceCache.set(stringType, {\n        state,\n        lastUpdated: now,\n        expiresAt: now + this.cacheTTL,\n      });\n    }\n\n    return state;\n  }\n\n  /**\n   * Helper function to adapt FlowConnection for different module interfaces\n   * Handles the priority property compatibility issues\n   */\n  private adaptFlowConnection(\n    connection: FlowConnection\n  ): import('../../types/resources/ResourceTypes').FlowConnection {\n    const adaptedConnection = { ...connection };\n\n    // Convert priority to ResourcePriorityConfig if it's a number\n    if (typeof adaptedConnection.priority === 'number') {\n      adaptedConnection.priority = {\n        type: adaptedConnection.resourceType ? adaptedConnection.resourceType : ResourceType.ENERGY,\n        priority: adaptedConnection.priority,\n        consumers: [],\n      };\n    }\n\n    return adaptedConnection as import('../../types/resources/ResourceTypes').FlowConnection;\n  }\n\n  /**\n   * Adapts an array of FlowConnections for compatibility with resource types module\n   */\n  private adaptFlowConnections(\n    connections: FlowConnection[]\n  ): import('../../types/resources/ResourceTypes').FlowConnection[] {\n    return connections.map(conn => this.adaptFlowConnection(conn));\n  }\n\n  /**\n   * Utility function to convert between resource type formats safely\n   */\n  private convertResourceType(type: ResourceType | ResourceTypeString): ResourceTypeString {\n    return ensureStringResourceType(this.safeResourceTypeConversion(type));\n  }\n\n  /**\n   * Optimizes resource flows with proper type handling\n   */\n  public async optimizeFlows(): Promise<FlowOptimizationResult> {\n    // Prevent concurrent optimization runs\n    if (this.isOptimizing) {\n      return (\n        this.lastOptimizationResult || {\n          transfers: [],\n          updatedConnections: [],\n          bottlenecks: [],\n          underutilized: [],\n          performanceMetrics: {\n            executionTimeMs: 0,\n            nodesProcessed: 0,\n            connectionsProcessed: 0,\n            transfersGenerated: 0,\n          },\n        }\n      );\n    }\n\n    this.isOptimizing = true;\n    const startTime = Date.now();\n\n    try {\n      // Get active nodes and connections\n      const activeNodes = Array.from(this.nodes.values()).filter(node => node.active);\n      const activeConnections = Array.from(this.connections.values()).filter(conn => conn.active);\n      const adaptedConnections = this.adaptFlowConnections(activeConnections);\n\n      // Check if we should use Web Worker offloading\n      if (this.useWorkerOffloading && this.workerUtil && activeNodes.length > this.batchSize) {\n        try {\n          // Convert resourceStates to the format expected by the worker\n          const standardizedResourceStates = new Map<StandardizedResourceType, ResourceState>();\n\n          // Convert keys from ResourceType to StandardizedResourceType\n          for (const [key, value] of this.resourceStates.entries()) {\n            // This is a simplified conversion - in a real implementation, you would need to map\n            // the string resource types to the corresponding enum values\n            standardizedResourceStates.set(key as unknown as StandardizedResourceType, value);\n          }\n\n          // Offload optimization to Web Worker\n          const result = await this.workerUtil.optimizeFlows(\n            activeNodes,\n            adaptedConnections,\n            standardizedResourceStates\n          );\n\n          // Apply the results from the worker\n          this.applyOptimizationResults(result);\n\n          // Add execution time to performance metrics\n          result.performanceMetrics = result.performanceMetrics || {\n            executionTimeMs: 0,\n            nodesProcessed: activeNodes.length,\n            connectionsProcessed: activeConnections.length,\n            transfersGenerated: result.transfers.length,\n          };\n\n          result.performanceMetrics.executionTimeMs = Date.now() - startTime;\n\n          // Convert transfers to the expected format\n          const transfers: StandardizedResourceTransfer[] = result.transfers.map(t => ({\n            type: this.safeResourceTypeConversion(t.type),\n            amount: t.amount,\n            source: t.source,\n            target: t.target,\n            timestamp: t.timestamp,\n          }));\n\n          this.lastOptimizationResult = {\n            ...result,\n            transfers,\n          };\n          this.isOptimizing = false;\n          return this.lastOptimizationResult;\n        } catch (error) {\n          console.warn('Web Worker optimization failed, falling back to main thread:', error);\n          // Fall back to main thread optimization\n        }\n      }\n\n      // Rest of method remains the same\n      // ...\n    } finally {\n      this.isOptimizing = false;\n    }\n\n    // Default fallback result\n    return {\n      transfers: [],\n      updatedConnections: [],\n      bottlenecks: [],\n      underutilized: [],\n      performanceMetrics: {\n        executionTimeMs: 0,\n        nodesProcessed: 0,\n        connectionsProcessed: 0,\n        transfersGenerated: 0,\n      },\n    };\n  }\n\n  /**\n   * Process converter nodes in batches with proper type handling\n   */\n  private async processConverters(\n    converters: FlowNode[],\n    activeConnections: FlowConnection[]\n  ): Promise<void> {\n    // Don't process if no converters or connections\n    if (\n      !converters ||\n      converters.length === 0 ||\n      !activeConnections ||\n      activeConnections.length === 0\n    ) {\n      return;\n    }\n\n    // Apply worker offloading if available\n    if (this.workerUtil && this.useWorkerOffloading) {\n      try {\n        // Use adapter for type compatibility\n        const _adaptedConnections = this.adaptFlowConnections(activeConnections);\n        // Placeholder for worker offloading\n        return;\n      } catch (error) {\n        this.handleError(error instanceof Error ? error : new Error(String(error)), {\n          context: 'workerProcessConverters',\n        });\n      }\n    }\n\n    // Process in batches\n    const batchSize = Math.min(this.batchSize, 20);\n    for (let i = 0; i < converters.length; i += batchSize) {\n      const batch = converters.slice(i, i + batchSize);\n      for (const converter of batch) {\n        // Original converter processing logic\n        const converterNode = converter as ConverterFlowNode;\n        if (\n          converterNode.converterConfig &&\n          'type' in converterNode.converterConfig &&\n          converterNode.converterConfig.type === 'advanced'\n        ) {\n          this.processAdvancedConverter(converterNode, activeConnections);\n        } else {\n          this.tryStartConversions(converterNode);\n        }\n      }\n    }\n  }\n\n  /**\n   * Calculate resource balance with proper type handling\n   */\n  private async calculateResourceBalance(\n    producers: FlowNode[],\n    consumers: FlowNode[],\n    storages: FlowNode[],\n    activeConnections: FlowConnection[]\n  ): Promise<{\n    availability: Partial<Record<ResourceTypeString, number>>;\n    demand: Partial<Record<ResourceTypeString, number>>;\n  }> {\n    // If using worker offloading and network is large, use worker\n    if (\n      this.useWorkerOffloading &&\n      this.workerUtil &&\n      producers.length + consumers.length + storages.length > this.batchSize\n    ) {\n      try {\n        // Use adapter for type compatibility\n        const adaptedConnections = this.adaptFlowConnections(activeConnections);\n\n        // Offload calculation to Web Worker\n        return (await this.workerUtil.calculateResourceBalance(\n          producers,\n          consumers,\n          storages,\n          adaptedConnections\n        )) as {\n          availability: Partial<Record<ResourceTypeString, number>>;\n          demand: Partial<Record<ResourceTypeString, number>>;\n        };\n      } catch (error) {\n        console.warn('Worker calculation failed, falling back to main thread', error);\n      }\n    }\n\n    // Default implementation (placeholder)\n    return { availability: {}, demand: {} };\n  }\n\n  /**\n   * Optimize flow rates with proper type handling\n   */\n  private async optimizeFlowRates(\n    activeConnections: FlowConnection[],\n    availability: Partial<Record<ResourceTypeString, number>>,\n    demand: Partial<Record<ResourceTypeString, number>>\n  ): Promise<{\n    updatedConnections: FlowConnection[];\n    transfers: ResourceTransfer[];\n  }> {\n    // If using worker offloading and network is large, use worker\n    if (this.useWorkerOffloading && this.workerUtil && activeConnections.length > this.batchSize) {\n      try {\n        // Use adapter for type compatibility\n        const adaptedConnections = this.adaptFlowConnections(activeConnections);\n\n        // Convert the availability and demand to the format expected by the worker\n        const standardizedAvailability: Partial<Record<StandardizedResourceType, number>> = {};\n        const standardizedDemand: Partial<Record<StandardizedResourceType, number>> = {};\n\n        // Convert keys from ResourceType to StandardizedResourceType\n        Object.entries(availability).forEach(([key, value]) => {\n          standardizedAvailability[key as unknown as StandardizedResourceType] = value;\n        });\n\n        Object.entries(demand).forEach(([key, value]) => {\n          standardizedDemand[key as unknown as StandardizedResourceType] = value;\n        });\n\n        const result = await this.workerUtil.optimizeFlowRates(\n          adaptedConnections,\n          standardizedAvailability,\n          standardizedDemand\n        );\n\n        // Convert the result back to the format expected by the caller\n        return {\n          updatedConnections: result?.updatedConnections,\n          transfers: result?.transfers.map(t => this.convertResourceTransfer(t)),\n        };\n      } catch (error) {\n        console.warn('Worker flow rate optimization failed, falling back to main thread:', error);\n        // Fall back to main thread optimization\n      }\n    }\n\n    // Main thread implementation (simplified for example)\n    const updatedConnections: FlowConnection[] = [];\n    const transfers: ResourceTransfer[] = [];\n\n    // Create dummy transfers for compilation\n    for (const connection of activeConnections) {\n      const currentRate = connection.currentRate ?? 0;\n      if (currentRate > 0 && connection.resourceType) {\n        const transfer: ResourceTransfer = {\n          type: this.safeResourceTypeConversion(connection.resourceType),\n          source: connection.source,\n          target: connection.target,\n          amount: currentRate,\n          timestamp: Date.now(),\n        };\n\n        transfers.push(transfer);\n      }\n    }\n\n    return { updatedConnections, transfers };\n  }\n\n  /**\n   * Calculate the efficiency for a converter with null checking\n   */\n  private calculateConverterEfficiency(\n    converter: ConverterFlowNode,\n    recipe: ResourceConversionRecipe\n  ): number {\n    let efficiency = 1.0;\n\n    // Apply recipe base efficiency if it exists\n    if ('baseEfficiency' in recipe) {\n      efficiency *= (recipe as ExtendedResourceConversionRecipe).baseEfficiency;\n    }\n\n    // Check for converter config efficiency modifiers\n    if (converter.converterConfig?.efficiencyModifiers) {\n      const modifiers = converter.converterConfig.efficiencyModifiers;\n\n      // Apply general modifiers\n      if (modifiers['global']) {\n        efficiency *= modifiers['global'];\n      }\n\n      // Apply recipe-specific modifiers\n      if (modifiers[recipe.id]) {\n        efficiency *= modifiers[recipe.id];\n      }\n\n      // Apply resource-specific modifiers\n      for (const input of recipe.inputs) {\n        if (modifiers[input.type]) {\n          efficiency *= modifiers[input.type];\n        }\n      }\n    }\n\n    // Apply dynamic efficiency based on resource quality (simulated)\n    const qualityFactors = this.calculateResourceQualityFactors(recipe.inputs);\n    for (const [_resourceType, factor] of Object.entries(qualityFactors)) {\n      efficiency *= factor;\n    }\n\n    // Apply technology tier bonus (1-10% per tier) with null check\n    const converterConfig = converter.converterConfig as ExtendedConverterNodeConfig | undefined;\n    if (converterConfig && typeof converterConfig.tier === 'number') {\n      const tierBonus = 1 + converterConfig.tier * 0.05;\n      efficiency *= tierBonus;\n    }\n\n    // Apply network stress factor\n    const networkStressFactor = this.calculateNetworkStressFactor(converter);\n    efficiency *= networkStressFactor;\n\n    // Apply chain bonus if this is part of a chain with null check\n    if (converterConfig && typeof converterConfig.chainBonus === 'number') {\n      efficiency *= converterConfig.chainBonus;\n    }\n\n    // Clamp efficiency to reasonable range (0.1 to 5.0)\n    efficiency = Math.max(0.1, Math.min(5.0, efficiency));\n\n    return efficiency;\n  }\n\n  /**\n   * Calculate network stress factor with null checks\n   */\n  private calculateNetworkStressFactor(converter: FlowNode): number {\n    // Default to neutral factor\n    let stressFactor = 1.0;\n\n    // Check resource states for converter's resources\n    if (converter.resources) {\n      for (const [resourceType] of converter.resources.entries()) {\n        const convertedType = this.convertResourceType(resourceType);\n        const state = this.getResourceState(convertedType);\n        if (state) {\n          // Calculate resource utilization\n          const utilization = state.consumption / Math.max(state.production, 0.001);\n\n          // High utilization reduces efficiency\n          if (utilization > 0.9) {\n            stressFactor *= 0.9;\n          }\n          // Low utilization increases efficiency\n          else if (utilization < 0.5) {\n            stressFactor *= 1.1;\n          }\n        }\n      }\n    }\n\n    // Clamp to reasonable range\n    return Math.max(0.7, Math.min(1.3, stressFactor));\n  }\n\n  /**\n   * Calculate quality factors for input resources\n   */\n  private calculateResourceQualityFactors(\n    inputs: { type: StandardizedResourceType | ResourceTypeString; amount: number }[]\n  ): Record<string, number> {\n    const qualityFactors: Record<string, number> = {};\n\n    for (const input of inputs) {\n      // Convert the type to ensure compatibility\n      const convertedType = this.convertResourceType(input.type);\n\n      // For now, use a simulated quality factor\n      // In the future, this would be based on actual resource quality attributes\n      const baseQuality = 1.0;\n      const randomVariation = Math.random() * 0.2 - 0.1; // -10% to +10%\n      qualityFactors[convertedType] = baseQuality + randomVariation;\n    }\n\n    return qualityFactors;\n  }\n\n  /**\n   * Apply optimization results from the worker to the main thread\n   */\n  private applyOptimizationResults(result: FlowOptimizationResult): void {\n    // Update connections with optimized rates\n    for (const connection of result.updatedConnections) {\n      this.connections.set(connection.id, connection);\n    }\n\n    // Add transfers to history\n    for (const transfer of result.transfers) {\n      // Convert StandardizedResourceTransfer to ResourceTransfer\n      const convertedTransfer = this.convertResourceTransfer(transfer);\n      this.addToTransferHistory(convertedTransfer);\n    }\n  }\n\n  /**\n   * Get a node by ID\n   *\n   * @param id The ID of the node to get\n   * @returns The node, or undefined if not found\n   */\n  public getNode(id: string): FlowNode | undefined {\n    return this.nodes.get(id);\n  }\n\n  /**\n   * Get all nodes in the resource flow network\n   *\n   * @returns Array of all nodes\n   */\n  public getNodes(): FlowNode[] {\n    return Array.from(this.nodes.values());\n  }\n\n  /**\n   * Get all connections in the resource flow network\n   *\n   * @returns Array of all connections\n   */\n  public getConnections(): FlowConnection[] {\n    return Array.from(this.connections.values());\n  }\n\n  /**\n   * Get a connection by ID\n   *\n   * @param id The ID of the connection to get\n   * @returns The connection, or undefined if not found\n   */\n  public getConnection(id: string): FlowConnection | undefined {\n    return this.connections.get(id);\n  }\n\n  /**\n   * Create a resource flow\n   *\n   * @param flow The resource flow to create\n   * @returns True if the flow was successfully created, false otherwise\n   */\n  public createFlow(flow: ResourceFlow): boolean {\n    if (!flow.source || !flow.target || !flow.resources || flow.resources.length === 0) {\n      console.warn('[ResourceFlowManager] Invalid flow configuration:', flow);\n      return false;\n    }\n\n    // Create nodes if they don't exist\n    if (!this.nodes.has(flow.source)) {\n      // Convert resources array to Map\n      const resourcesMap = new Map<ResourceType, number>();\n      flow.resources.forEach(r => resourcesMap.set(r.type, r.amount));\n\n      this.registerNode({\n        id: flow.source,\n        type: FlowNodeType.PRODUCER,\n        name: `Producer ${flow.source}`,\n        description: `Auto-created producer node from flow creation`,\n        capacity: 100,\n        currentLoad: 0,\n        efficiency: 1.0,\n        status: 'active',\n        resources: resourcesMap,\n        active: true,\n      });\n    }\n\n    if (!this.nodes.has(flow.target)) {\n      // Convert resources array to Map\n      const resourcesMap = new Map<ResourceType, number>();\n      flow.resources.forEach(r => resourcesMap.set(r.type, r.amount));\n\n      this.registerNode({\n        id: flow.target,\n        type: FlowNodeType.CONSUMER,\n        name: `Consumer ${flow.target}`,\n        description: `Auto-created consumer node from flow creation`,\n        capacity: 100,\n        currentLoad: 0,\n        efficiency: 1.0,\n        status: 'active',\n        resources: resourcesMap,\n        active: true,\n      });\n    }\n\n    // Create connections for each resource\n    let success = true;\n    for (const resource of flow.resources) {\n      const connectionId = `${flow.source}-${flow.target}-${resource.type}`;\n      const connection: FlowConnection = {\n        id: connectionId,\n        source: flow.source,\n        target: flow.target,\n        resourceType: resource.type,\n        resourceTypes: [resource.type], // Add resourceTypes array\n        maxRate: resource.amount,\n        currentRate: 0,\n        priority: { type: resource.type, priority: 1, consumers: [] },\n        active: true,\n      };\n\n      const registered = this.registerConnection(connection);\n      if (!registered) {\n        success = false;\n      }\n    }\n\n    return success;\n  }\n\n  /**\n   * Update the progress of a conversion chain\n   */\n  private updateChainProgress(chainId: string): void {\n    const chainStatus = this.chainExecutions.get(chainId);\n    if (!chainStatus) return;\n\n    // Calculate overall progress\n    const completedSteps = 0;\n    let totalProgress = 0;\n\n    for (const step of chainStatus.stepStatus) {\n      if (step.status === 'completed') {\n        // Prefix with underscore to indicate it's unused\n        let _completedSteps = completedSteps;\n        _completedSteps++;\n        totalProgress += 1;\n      } else if (step.status === 'in_progress') {\n        // Calculate step progress based on process progress\n        const process = this.processingQueue.find(p => p.processId === step.processId);\n        if (process) {\n          const stepProgress = process.progress ?? 0;\n          totalProgress += stepProgress;\n        }\n      }\n    }\n\n    // Update chain progress\n    const totalSteps = chainStatus.stepStatus.length;\n    chainStatus.progress = totalSteps > 0 ? totalProgress / totalSteps : 0;\n\n    // Update chain in map\n    this.chainExecutions.set(chainId, chainStatus);\n\n    // Update metrics\n    this.updateMetric(\n      'activeChains',\n      Array.from(this.chainExecutions.values()).filter(c => c.active).length\n    );\n    this.updateMetric(\n      'completedChains',\n      Array.from(this.chainExecutions.values()).filter(c => c.completed).length\n    );\n  }\n\n  /**\n   * Get the version of this manager implementation (for compatibility)\n   * @override\n   */\n  protected getVersion(): string {\n    return '2.0.0';\n  }\n\n  // Module event handlers\n  private handleModuleCreated = (data: unknown) => {\n    // Handle module creation\n    const moduleData = data as { id: string; type: ModuleType };\n    // Register module as appropriate node type based on module type\n    this.registerModuleAsNode(moduleData.id, moduleData.type);\n  };\n\n  private handleModuleUpdated = (data: unknown) => {\n    // Handle module update\n    const moduleData = data as { id: string; changes: unknown };\n    this.updateNodeFromModule(moduleData.id, moduleData.changes);\n  };\n\n  private handleModuleDestroyed = (data: unknown) => {\n    // Handle module destruction\n    const moduleData = data as { id: string };\n    this.unregisterNode(moduleData.id);\n  };\n\n  private handleModuleStateChanged = (data: unknown) => {\n    // Handle module state change (enabled/disabled)\n    const moduleData = data as { id: string; active: boolean };\n    this.setNodeActive(moduleData.id, moduleData.active);\n  };\n\n  // Register a module as a node based on its type\n  private registerModuleAsNode(moduleId: string, moduleType: ModuleType): void {\n    // Implementation will determine node type based on module type\n    // This is a placeholder\n    console.warn(`Registering module ${moduleId} of type ${moduleType} as node`);\n  }\n\n  // Update a node based on module changes\n  private updateNodeFromModule(moduleId: string, changes: unknown): void {\n    // Implementation will update node properties based on module changes\n    // This is a placeholder\n    console.warn(`Updating node for module ${moduleId} with changes`, changes);\n  }\n\n  // Set a node's active state\n  private setNodeActive(nodeId: string, active: boolean): void {\n    const node = this.nodes.get(nodeId);\n    if (node) {\n      node.active = active;\n      this.nodes.set(nodeId, node);\n    }\n  }\n\n  /**\n   * Process the next step in a conversion chain\n   */\n  private _processNextChainStep(_chainId: string, _converter?: ConverterFlowNode): void {\n    // Implementation would process the next step in a chain\n    // For now, do nothing\n  }\n\n  /**\n   * Start the asynchronous optimization interval\n   */\n  private startAsyncOptimizationInterval(): void {\n    if (this.optimizationInterval !== null) {\n      clearInterval(this.optimizationInterval);\n    }\n\n    // Use setInterval for regular optimization\n    this.optimizationInterval = setInterval(() => {\n      if (this.flowOptimizationEnabled && this.getStatus() === 'ready') {\n        // Call async optimize without waiting (fire and forget)\n        this.optimizeFlows().catch(error => {\n          this.handleError(error instanceof Error ? error : new Error(String(error)), {\n            context: 'asyncOptimizationInterval',\n          });\n        });\n      }\n    }, this.optimizationIntervalMs) as unknown as number;\n  }\n\n  /**\n   * Start the processing interval for conversion processes\n   */\n  private startProcessingInterval(interval: number): void {\n    // Clear any existing interval\n    if (this.processingInterval) {\n      clearInterval(this.processingInterval);\n    }\n\n    // Set new interval\n    this.processingInterval = window.setInterval(() => {\n      this.processConversions();\n    }, interval) as unknown as number;\n  }\n\n  /**\n   * Process all active conversion processes\n   */\n  private processConversions(): void {\n    const now = Date.now();\n    const updatedProcesses: ExtendedResourceConversionProcess[] = [];\n\n    // Check if any paused processes are ready to resume\n    for (const process of this.processingQueue) {\n      if (process.paused) {\n        // Check if it's time to resume the process\n        if (process.endTime && now >= process.endTime) {\n          process.paused = false;\n          process.endTime = undefined;\n          updatedProcesses.push(process);\n        }\n      } else if (process.active) {\n        // Update progress for active processes\n        const elapsedTime = now - process.startTime;\n        const converter = this.converterNodes.get(process.sourceId) as ConverterFlowNode;\n        const recipe = this.conversionRecipes.get(process.recipeId);\n\n        if (converter && recipe) {\n          // Calculate the process duration based on recipe and efficiency\n          const duration = recipe.duration / process.appliedEfficiency;\n          process.progress = Math.min(1, elapsedTime / duration);\n\n          // Check if process is complete\n          if (process.progress >= 1) {\n            this.completeProcess(process);\n          } else {\n            updatedProcesses.push(process);\n          }\n        }\n      }\n    }\n\n    // Filter out completed processes\n    this.processingQueue = this.processingQueue.filter(p => p.active);\n\n    // Process converters\n    if (this.converterNodes.size > 0) {\n      const activeConnections = Array.from(this.connections.values()).filter(c => c.active);\n\n      for (const [_id, converter] of this.converterNodes.entries()) {\n        // Skip inactive converters\n        if (converter.active === false) continue;\n\n        // Check converter type if it has converterConfig\n        if (\n          converter.converterConfig &&\n          converter.converterConfig.efficiencyModifiers &&\n          'type' in converter.converterConfig &&\n          converter.converterConfig.type === 'advanced'\n        ) {\n          this.processAdvancedConverter(converter, activeConnections);\n        } else {\n          this.tryStartConversions(converter);\n        }\n      }\n    }\n\n    this._lastProcessingTime = Date.now() - now;\n  }\n\n  /**\n   * Complete a process\n   */\n  private completeProcess(process: ExtendedResourceConversionProcess): void {\n    // Remove process from active processes\n    this.processingQueue = this.processingQueue.filter(p => p.processId !== process.processId);\n\n    // Add to completed processes\n    this._completedProcesses.push(process);\n\n    // Trim completed processes if needed\n    if (this._completedProcesses.length > this.maxHistorySize) {\n      this._completedProcesses = this._completedProcesses.slice(-this.maxHistorySize);\n    }\n\n    // Update last processing time\n    this._lastProcessingTime = Date.now();\n  }\n\n  /**\n   * Process advanced converter with multi-step production chains\n   */\n  private processAdvancedConverter(\n    converter: ConverterFlowNode,\n    _activeConnections: FlowConnection[]\n  ): void {\n    // Advanced converter implementation\n    if (!converter.converterConfig) return;\n\n    // Implementation details...\n    const _id = converter.id; // Change to _id since it's unused\n  }\n\n  /**\n   * Try to start conversion processes for a converter node\n   */\n  private tryStartConversions(_converter: ConverterFlowNode): void {\n    // Implementation details...\n  }\n\n  /**\n   * Start a conversion process\n   */\n  private startConversionProcess(converterId: string, recipeId: string): ConversionResult {\n    // Implementation for starting a conversion process\n    console.warn(\n      `Starting conversion process for converter ${converterId} with recipe ${recipeId}`\n    );\n\n    return {\n      success: true,\n      processId: `${converterId}-${recipeId}-${Date.now()}`,\n      recipeId: recipeId,\n    };\n  }\n\n  /**\n   * Identifies resource bottlenecks and underutilized resources\n   */\n  private identifyResourceIssues(\n    availability: Partial<Record<ResourceTypeString, number>>,\n    demand: Partial<Record<ResourceTypeString, number>>\n  ): {\n    bottlenecks: string[];\n    underutilized: string[];\n  } {\n    const bottlenecks: string[] = [];\n    const underutilized: string[] = [];\n\n    // Find bottlenecks (resources where demand exceeds availability)\n    for (const type in demand) {\n      const demandValue = demand[type as ResourceTypeString] ?? 0;\n      const availabilityValue = availability[type as ResourceTypeString] ?? 0;\n\n      if (demandValue > availabilityValue * 1.1) {\n        // 10% threshold to avoid minor imbalances\n        bottlenecks.push(type);\n      } else if (availabilityValue > demandValue * 1.5) {\n        // 50% threshold for underutilization\n        underutilized.push(type);\n      }\n    }\n\n    return { bottlenecks, underutilized };\n  }\n\n  /**\n   * Get all resource states\n   * This method is used by ResourceRegistryIntegration\n   *\n   * @returns Map of resource types to their states\n   */\n  public getAllResourceStates(): Map<string, { available: number }> {\n    const result = new Map<string, { available: number }>();\n\n    for (const [type, state] of this.resourceStates.entries()) {\n      result?.set(type, {\n        available: state.current ?? 0,\n      });\n    }\n\n    return result;\n  }\n\n  /**\n   * Get all conversion recipes\n   * This method is used by ResourceRegistryIntegration\n   *\n   * @returns Array of conversion recipes\n   */\n  public getAllConversionRecipes(): Array<{\n    input: { type: string; amount: number };\n    output: { type: string; amount: number };\n  }> {\n    const result: Array<{\n      input: { type: string; amount: number };\n      output: { type: string; amount: number };\n    }> = [];\n\n    // Convert conversion recipes to the expected format\n    for (const [_recipeId, recipe] of this.conversionRecipes.entries()) {\n      if (recipe.inputs.length > 0 && recipe.outputs.length > 0) {\n        // For simplicity, we're just using the first input and output\n        const input = recipe.inputs[0];\n        const output = recipe.outputs[0];\n\n        result?.push({\n          input: {\n            type: this.convertResourceType(input.type),\n            amount: input.amount,\n          },\n          output: {\n            type: this.convertResourceType(output.type),\n            amount: output.amount,\n          },\n        });\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Set conversion rate\n   * This method is used by ResourceRegistryIntegration\n   *\n   * @param sourceType Source resource type\n   * @param targetType Target resource type\n   * @param rate Conversion rate\n   */\n  public setConversionRate(sourceType: string, targetType: string, rate: number): void {\n    // Find or create a recipe for this conversion\n    const recipeId = `${sourceType}_to_${targetType}`;\n\n    // Check if recipe already exists\n    if (this.conversionRecipes.has(recipeId)) {\n      // Update existing recipe\n      const recipe = this.conversionRecipes.get(recipeId)!;\n      recipe.outputs[0].amount = rate;\n      this.conversionRecipes.set(recipeId, recipe);\n    } else {\n      // Create new recipe\n      const recipe: ResourceConversionRecipe = {\n        id: recipeId,\n        name: `Convert ${sourceType} to ${targetType}`,\n        description: `Converts ${sourceType} to ${targetType} at a rate of ${rate}:1`,\n        inputs: [\n          {\n            // Use toEnumResourceType from the imported utility\n            type: stringToEnumResourceType(sourceType as ResourceTypeString),\n            amount: 1,\n          },\n        ],\n        outputs: [\n          {\n            // Use toEnumResourceType from the imported utility\n            type: stringToEnumResourceType(targetType as ResourceTypeString),\n            amount: rate,\n          },\n        ],\n        duration: 1000,\n        energyCost: 0,\n        requiredLevel: 1,\n      };\n\n      this.conversionRecipes.set(recipeId, recipe);\n    }\n  }\n\n  /**\n   * Add a resource type to a node\n   */\n  private addResourceToNode(\n    nodeId: string,\n    resourceType: ResourceTypeString | ResourceType\n  ): boolean {\n    const node = this.nodes.get(nodeId);\n    if (!node) {\n      return false;\n    }\n\n    const enumType = this.safeResourceTypeConversion(resourceType);\n\n    // Ensure the node has a resources map\n    if (!node.resources) {\n      node.resources = new Map<ResourceType, number>();\n    }\n\n    // Check if the resource type is already in the node\n    if (node.resources.has(enumType)) {\n      return true;\n    }\n\n    // Add the resource type to the node\n    node.resources.set(enumType, 0);\n    this.nodes.set(nodeId, node);\n\n    // Update resource type indices\n    this.addNodeToResourceIndex(node, this.convertResourceType(enumType));\n\n    // Invalidate cache for the affected resource type\n    this.invalidateCache(enumType);\n\n    return true;\n  }\n\n  /**\n   * Add a value to an array in a map, creating the array if it doesn't exist\n   * @param map The map to add to\n   * @param key The key in the map\n   * @param value The value to add to the array\n   */\n  private addToArray<K, V>(map: Map<K, V[]>, key: K, value: V): void {\n    if (!map.has(key)) {\n      map.set(key, []);\n    }\n    const array = map.get(key);\n    if (array && !array.includes(value)) {\n      array.push(value);\n    }\n  }\n\n  /**\n   * Add a node to the appropriate resource type index\n   */\n  private addNodeToResourceIndex(node: FlowNode, resourceType: ResourceTypeString): void {\n    const stringType = ensureStringResourceType(resourceType);\n\n    switch (node.type) {\n      case FlowNodeType.PRODUCER:\n        this.addToArray(this.resourceProducers, stringType, node.id);\n        break;\n      case FlowNodeType.CONSUMER:\n        this.addToArray(this.resourceConsumers, stringType, node.id);\n        break;\n      case FlowNodeType.STORAGE:\n        this.addToArray(this.resourceStorage, stringType, node.id);\n        break;\n      case FlowNodeType.CONVERTER:\n        // Create resourceConverters map if it doesn't exist\n        if (!this.resourceConverters) {\n          this.resourceConverters = new Map<ResourceTypeString, string[]>();\n        }\n        this.addToArray(this.resourceConverters, stringType, node.id);\n        break;\n    }\n  }\n\n  // Helper method to safely convert resource types with proper typing\n  private safeResourceTypeConversion(\n    type: ResourceType | ResourceTypeString | unknown\n  ): ResourceType {\n    if (type === undefined) {\n      return ResourceType.ENERGY; // Default fallback\n    }\n\n    if (typeof type === 'string') {\n      // Convert string to ResourceType enum\n      try {\n        return stringToEnumResourceType(type as ResourceTypeString);\n      } catch (error) {\n        console.warn(`Failed to convert string resource type: ${type}`, error);\n        return ResourceType.ENERGY;\n      }\n    }\n\n    // If it's already a ResourceType enum value\n    if (typeof type === 'number') {\n      // Check if the number is a valid ResourceType enum value by comparing with known values\n      const resourceTypeValues = Object.values(ResourceType).filter(\n        value => typeof value === 'number'\n      ) as number[];\n\n      if (resourceTypeValues.includes(type)) {\n        return type as unknown as ResourceType;\n      }\n    }\n\n    // Default fallback\n    return ResourceType.ENERGY;\n  }\n\n  /**\n   * Convert StandardizedResourceTransfer to ResourceTransfer with proper types\n   */\n  private convertResourceTransfer(transfer: StandardizedResourceTransfer): ResourceTransfer {\n    // Ensure the type is ResourceType as required by ResourceTransfer\n    const resourceType = transfer.type ? transfer.type : ResourceType.ENERGY;\n\n    return {\n      type: resourceType,\n      source: transfer.source,\n      target: transfer.target,\n      amount: transfer.amount,\n      timestamp: transfer.timestamp,\n    };\n  }\n\n  /**\n   * Invalidate cache for a resource type\n   */\n  private invalidateCache(type: ResourceType | ResourceTypeString): void {\n    const convertedType = this.convertResourceType(type);\n    this.resourceCache.delete(convertedType);\n  }\n\n  /**\n   * Adds a transfer to history\n   */\n  private addToTransferHistory(transfer: ResourceTransfer): void {\n    this.transferHistory.push(transfer);\n\n    // Trim history if needed\n    if (this.transferHistory.length > this.maxHistorySize) {\n      this.transferHistory = this.transferHistory.slice(-this.maxHistorySize);\n    }\n  }\n\n  /**\n   * Fix the sorting function for FlowConnection priorities\n   */\n  private getConnectionPriority(connection: FlowConnection): number {\n    if (!connection.priority) return 0;\n\n    if (typeof connection.priority === 'number') {\n      return connection.priority;\n    }\n\n    return connection.priority.priority ?? 0;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/resource/ResourceFlowTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/resource/ResourceIntegration.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_deltaTime' is defined but never used.","line":495,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":495,"endColumn":27}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { moduleEventBus, ModuleEventType } from '../../lib/modules/ModuleEvents';\nimport { ModuleType } from '../../types/buildings/ModuleTypes';\nimport {\n  FlowConnection,\n  FlowNode,\n  FlowNodeType,\n  ResourcePriorityConfig,\n  ResourceState,\n  ResourceTransfer,\n  ResourceType,\n  ResourceTypeString,\n  toEnumResourceType,\n} from '../../types/resources/ResourceTypes';\nimport { FlowNode as StandardizedFlowNode } from '../../types/resources/StandardizedResourceTypes';\nimport { ResourceManager } from '../game/ResourceManager';\nimport { ResourceCostManager } from './ResourceCostManager';\nimport { ResourceExchangeManager } from './ResourceExchangeManager';\nimport { ResourceFlowManager } from './ResourceFlowManager';\nimport { ResourcePoolManager } from './ResourcePoolManager';\nimport { ResourceStorageManager, StorageContainerConfig } from './ResourceStorageManager';\nimport { ResourceThresholdManager, ThresholdConfig } from './ResourceThresholdManager';\n\n/**\n * ResourceIntegration\n *\n * Integrates the new resource management system with existing game systems.\n * Acts as a bridge between the legacy ResourceManager and the new specialized managers.\n */\nexport class ResourceIntegration {\n  private resourceManager: ResourceManager;\n  private thresholdManager: ResourceThresholdManager;\n  private flowManager: ResourceFlowManager;\n  private storageManager: ResourceStorageManager;\n  private costManager: ResourceCostManager;\n  private exchangeManager: ResourceExchangeManager;\n  private poolManager: ResourcePoolManager;\n  private initialized: boolean = false;\n  private transferHistory: ResourceTransfer[] = [];\n\n  constructor(\n    resourceManager: ResourceManager,\n    thresholdManager: ResourceThresholdManager,\n    flowManager: ResourceFlowManager,\n    storageManager: ResourceStorageManager,\n    costManager: ResourceCostManager,\n    exchangeManager: ResourceExchangeManager,\n    poolManager: ResourcePoolManager\n  ) {\n    this.resourceManager = resourceManager;\n    this.thresholdManager = thresholdManager;\n    this.flowManager = flowManager;\n    this.storageManager = storageManager;\n    this.costManager = costManager;\n    this.exchangeManager = exchangeManager;\n    this.poolManager = poolManager;\n  }\n\n  /**\n   * Initialize the integration\n   */\n  public initialize(): void {\n    if (this.initialized) {\n      return;\n    }\n\n    // Subscribe to resource events from the legacy system\n    this.subscribeToLegacyEvents();\n\n    // Initialize threshold monitoring\n    this.initializeThresholds();\n\n    // Initialize storage containers\n    this.initializeStorage();\n\n    // Initialize resource flows\n    this.initializeFlows();\n\n    // Start the threshold monitoring\n    this.thresholdManager.start();\n\n    this.initialized = true;\n    console.warn('[ResourceIntegration] Resource management system integrated');\n  }\n\n  /**\n   * Subscribe to legacy resource events\n   */\n  private subscribeToLegacyEvents(): void {\n    // Subscribe to resource produced events\n    moduleEventBus.subscribe('RESOURCE_PRODUCED' as ModuleEventType, event => {\n      // Type guard for event data\n      if (!event?.data || typeof event?.data !== 'object') {\n        return;\n      }\n\n      // Extract and validate resource type\n      const resourceType = event?.data?.type;\n      if (!this.isValidResourceType(resourceType)) {\n        return;\n      }\n\n      const enumType = toEnumResourceType(resourceType);\n\n      // Get resource state\n      const resourceState = this.resourceManager.getResourceState(enumType);\n      if (resourceState) {\n        this.updateResourceState(resourceType, resourceState);\n      }\n    });\n\n    // Subscribe to resource consumed events\n    moduleEventBus.subscribe('RESOURCE_CONSUMED' as ModuleEventType, event => {\n      // Type guard for event data\n      if (!event?.data || typeof event?.data !== 'object') {\n        return;\n      }\n\n      // Extract and validate resource type\n      const resourceType = event?.data?.type;\n      if (!this.isValidResourceType(resourceType)) {\n        return;\n      }\n\n      const enumType = toEnumResourceType(resourceType);\n\n      // Get resource state\n      const resourceState = this.resourceManager.getResourceState(enumType);\n      if (resourceState) {\n        this.updateResourceState(resourceType, resourceState);\n      }\n    });\n\n    // Subscribe to resource transferred events\n    moduleEventBus.subscribe('RESOURCE_TRANSFERRED' as ModuleEventType, event => {\n      // Type guard for event data\n      if (!event.data || typeof event.data !== 'object') {\n        return;\n      }\n\n      // Extract and validate transfer properties\n      const { resourceType, amount, source, target } = event.data;\n      if (\n        !this.isValidResourceType(resourceType) ||\n        typeof amount !== 'number' ||\n        typeof source !== 'string' ||\n        typeof target !== 'string'\n      ) {\n        return;\n      }\n\n      const enumType = toEnumResourceType(resourceType);\n\n      // Record transfer in history\n      this.transferHistory.push({\n        type: enumType,\n        amount,\n        source,\n        target,\n        timestamp: Date.now(),\n      });\n\n      // Keep history size manageable\n      if (this.transferHistory.length > 100) {\n        this.transferHistory.shift();\n      }\n    });\n\n    // Subscribe to resource shortage events\n    moduleEventBus.subscribe('RESOURCE_SHORTAGE' as ModuleEventType, event => {\n      // Type guard for event data\n      if (!event.data || typeof event.data !== 'object') {\n        return;\n      }\n\n      // Extract and validate threshold properties\n      const { resourceType, requiredAmount } = event.data;\n      if (!this.isValidResourceType(resourceType) || typeof requiredAmount !== 'number') {\n        return;\n      }\n\n      const enumType = toEnumResourceType(resourceType);\n\n      // Get current resource state\n      const currentAmount = this.resourceManager.getResourceAmount(enumType);\n      const status = currentAmount < requiredAmount ? 'warning' : 'inactive';\n\n      // Emit a status change event for the resource module\n      moduleEventBus.emit({\n        type: 'STATUS_CHANGED' as ModuleEventType,\n        moduleId: `resource-${resourceType}`,\n        moduleType: 'resource' as ModuleType,\n        timestamp: Date.now(),\n        data: {\n          status,\n          previousStatus: 'unknown',\n          reason: `Resource ${resourceType} ${status === 'warning' ? 'shortage' : 'sufficient'}`,\n          currentAmount,\n          requiredAmount,\n          deficit: status === 'warning' ? requiredAmount - currentAmount : 0,\n        },\n      });\n\n      // Log the status change\n      console.warn(\n        `[ResourceIntegration] Resource ${resourceType} status: ${status} (${currentAmount}/${requiredAmount})`\n      );\n\n      // Find or create threshold configuration\n      const existingConfig = this.thresholdManager\n        .getThresholdConfigs()\n        .find(config => config.threshold.resourceId === enumType);\n\n      if (existingConfig) {\n        // Update existing threshold if needed\n        existingConfig.threshold.min = Math.max(existingConfig.threshold.min ?? 0, requiredAmount);\n        // Update the threshold configuration\n        this.thresholdManager.registerThreshold({\n          ...existingConfig,\n          threshold: {\n            ...existingConfig.threshold,\n            min: Math.max(existingConfig.threshold.min ?? 0, requiredAmount),\n          },\n        });\n      } else {\n        // Create new threshold configuration\n        this.thresholdManager.registerThreshold({\n          id: `shortage-${resourceType}-${Date.now()}`,\n          threshold: {\n            resourceId: enumType,\n            min: requiredAmount,\n          },\n          actions: [\n            {\n              type: 'notification',\n              target: 'system',\n              message: `Low ${resourceType} resources`,\n              priority: 1,\n            },\n          ],\n          enabled: true,\n          autoResolve: true,\n        });\n      }\n    });\n  }\n\n  /**\n   * Type guard to validate if a value is a valid ResourceType\n   */\n  private isValidResourceType(value: unknown): value is ResourceTypeString {\n    if (typeof value !== 'string') {\n      return false;\n    }\n\n    // Check if the value is one of the known resource types\n    return Object.values(ResourceType).includes(value as ResourceType);\n  }\n\n  /**\n   * Initialize thresholds based on the legacy resource manager\n   */\n  private initializeThresholds(): void {\n    // Get all resource types\n    const resourceTypes = Array.from(\n      this.resourceManager['resources'].keys()\n    ) as ResourceTypeString[];\n\n    // Create thresholds for each resource type\n    resourceTypes.forEach(type => {\n      const enumType = toEnumResourceType(type);\n      const resourceState = this.resourceManager.getResourceState(enumType);\n      if (!resourceState) {\n        return;\n      }\n\n      // Create a threshold config\n      const config: ThresholdConfig = {\n        id: `resource-${type}`,\n        threshold: {\n          resourceId: enumType,\n          min: resourceState.min,\n          max: resourceState.max,\n          target: (resourceState.min + resourceState.max) / 2,\n        },\n        actions: [\n          {\n            type: 'notification',\n            target: 'system',\n            message: `${type} threshold triggered`,\n          },\n        ],\n        enabled: true,\n      };\n\n      this.thresholdManager.registerThreshold(config);\n    });\n  }\n\n  /**\n   * Initialize storage containers based on the legacy resource manager\n   */\n  private initializeStorage(): void {\n    // Get all resource types\n    const resourceTypes = Array.from(\n      this.resourceManager['resources'].keys()\n    ) as ResourceTypeString[];\n\n    // Create a main storage container for each resource type\n    resourceTypes.forEach(type => {\n      const enumType = toEnumResourceType(type);\n      const resourceState = this.resourceManager.getResourceState(enumType);\n      if (!resourceState) {\n        return;\n      }\n\n      // Create a storage container config\n      const config: StorageContainerConfig = {\n        id: `main-storage-${type}`,\n        name: `Main ${type} Storage`,\n        type: 'storage',\n        capacity: resourceState.max,\n        resourceTypes: [enumType],\n        priority: 10, // High priority for main storage\n      };\n\n      this.storageManager.registerContainer(config);\n\n      // Initialize with current amount\n      this.storageManager.storeResource(config.id, enumType, resourceState.current);\n    });\n  }\n\n  /**\n   * Initialize resource flows based on the legacy resource manager\n   */\n  private initializeFlows(): void {\n    // Get all resource types\n    const resourceTypes = Array.from(\n      this.resourceManager['resources'].keys()\n    ) as ResourceTypeString[];\n\n    // Create producer and consumer nodes for each resource type\n    resourceTypes.forEach(type => {\n      const enumType = toEnumResourceType(type);\n      const resourceState = this.resourceManager.getResourceState(enumType);\n      if (!resourceState) {\n        return;\n      }\n\n      const resourcePriority: ResourcePriorityConfig = {\n        type: enumType,\n        priority: 1,\n        consumers: [],\n      };\n\n      // Create empty resource records with all required keys\n      const emptyResources = Object.values(ResourceType).reduce(\n        (acc, rt) => {\n          acc[rt] = {\n            current: 0,\n            max: 0,\n            min: 0,\n            production: 0,\n            consumption: 0,\n            rate: 0,\n            value: 0,\n          };\n          return acc;\n        },\n        {} as Record<ResourceType, ResourceState>\n      );\n\n      // Create producer node\n      const producerNode: FlowNode = {\n        id: `producer-${type}`,\n        type: FlowNodeType.PRODUCER,\n        resources: { ...emptyResources, [enumType]: resourceState },\n        priority: resourcePriority,\n        active: true,\n      };\n      this.flowManager.registerNode(this.adaptFlowNode(producerNode));\n\n      // Create consumer node\n      const consumerNode: FlowNode = {\n        id: `consumer-${type}`,\n        type: FlowNodeType.CONSUMER,\n        resources: { ...emptyResources, [enumType]: resourceState },\n        priority: resourcePriority,\n        active: true,\n      };\n      this.flowManager.registerNode(this.adaptFlowNode(consumerNode));\n\n      // Create storage node\n      const storageNode: FlowNode = {\n        id: `storage-${type}`,\n        type: FlowNodeType.STORAGE,\n        resources: { ...emptyResources, [enumType]: resourceState },\n        priority: resourcePriority,\n        capacity: resourceState.max,\n        active: true,\n      };\n      this.flowManager.registerNode(this.adaptFlowNode(storageNode));\n\n      // Create connections\n      const productionConnection: FlowConnection = {\n        id: `production-${type}`,\n        source: `producer-${type}`,\n        target: `storage-${type}`,\n        resourceTypes: [enumType],\n        maxRate: resourceState.production,\n        currentRate: 0,\n        priority: resourcePriority,\n        active: true,\n      };\n      this.flowManager.registerConnection(productionConnection);\n\n      const consumptionConnection: FlowConnection = {\n        id: `consumption-${type}`,\n        source: `storage-${type}`,\n        target: `consumer-${type}`,\n        resourceTypes: [enumType],\n        maxRate: resourceState.consumption,\n        currentRate: 0,\n        priority: resourcePriority,\n        active: true,\n      };\n      this.flowManager.registerConnection(consumptionConnection);\n\n      // Update resource state in flow manager\n      this.flowManager.updateResourceState(enumType, resourceState);\n    });\n  }\n\n  /**\n   * Helper method to convert FlowNode from ResourceTypes to StandardizedResourceTypes format\n   */\n  private adaptFlowNode(node: FlowNode): StandardizedFlowNode {\n    // Convert resources from Record to Map if it exists\n    const resourcesMap = new Map<ResourceType, number>();\n    if (node.resources) {\n      Object.entries(node.resources).forEach(([key, value]) => {\n        // Convert the key string to ResourceType enum\n        const resourceType = key as unknown as ResourceType;\n        // Get the current value from ResourceState\n        resourcesMap.set(resourceType, value.current ?? 0);\n      });\n    }\n\n    // Create a StandardizedFlowNode with all required properties\n    return {\n      id: node.id,\n      type: node.type,\n      name: node.id, // Use ID as name if not provided\n      description: `Auto-generated ${node.type} node for resource ${node.id}`,\n      currentLoad: 0, // Default value\n      efficiency: 1.0, // Default value (100% efficiency)\n      status: 'active', // Default to active status\n      capacity: node.capacity || 100, // Ensure capacity is always a number, default to 100\n      resources: resourcesMap,\n      active: node.active !== undefined ? node.active : true,\n    };\n  }\n\n  /**\n   * Update resource state in all managers\n   */\n  private updateResourceState(type: ResourceTypeString, state: ResourceState): void {\n    const enumType = toEnumResourceType(type);\n\n    // Update in threshold manager via event\n    moduleEventBus.emit({\n      type: 'resource:update' as ModuleEventType,\n      moduleId: 'resource-integration',\n      moduleType: 'resource-manager',\n      timestamp: Date.now(),\n      data: {\n        type: enumType,\n        state,\n      },\n    });\n\n    // Update in flow manager\n    this.flowManager.updateResourceState(enumType, state);\n\n    // Update in cost manager\n    this.costManager.updateResourceState(enumType, state);\n\n    // Update in exchange manager\n    this.exchangeManager.updateResourceState(enumType, state);\n  }\n\n  /**\n   * Update method to be called on game loop\n   */\n  public update(_deltaTime: number): void {\n    if (!this.initialized) {\n      return;\n    }\n\n    // Optimize resource flows\n    const flowResult = this.flowManager.optimizeFlows();\n\n    // Apply transfers to the legacy resource manager\n    flowResult.then(result => {\n      result?.transfers.forEach(transfer => {\n        // Only apply transfers to/from storage\n        if (transfer.source.startsWith('storage-') || transfer.target.startsWith('storage-')) {\n          // Extract the resource type from the node ID\n          const sourceType = transfer.source.replace('storage-', '') as ResourceTypeString;\n          const targetType = transfer.target.replace('storage-', '') as ResourceTypeString;\n\n          // If transferring from storage to consumer, remove from legacy manager\n          if (transfer.source.startsWith('storage-') && transfer.target.startsWith('consumer-')) {\n            const enumSourceType = toEnumResourceType(sourceType);\n            this.resourceManager.removeResource(enumSourceType, transfer.amount);\n          }\n\n          // If transferring from producer to storage, add to legacy manager\n          if (transfer.source.startsWith('producer-') && transfer.target.startsWith('storage-')) {\n            const enumTargetType = toEnumResourceType(targetType);\n            this.resourceManager.addResource(enumTargetType, transfer.amount);\n          }\n        }\n      });\n    });\n  }\n\n  /**\n   * Clean up resources\n   */\n  public cleanup(): void {\n    if (!this.initialized) {\n      return;\n    }\n\n    // Stop threshold monitoring\n    this.thresholdManager.stop();\n\n    // Clean up all managers\n    this.thresholdManager.cleanup();\n    this.flowManager.dispose(); // Use dispose instead of cleanup\n    this.storageManager.cleanup();\n    this.costManager.cleanup();\n    this.exchangeManager.cleanup();\n    this.poolManager.cleanup();\n\n    this.initialized = false;\n  }\n}\n\n/**\n * Factory function to create and initialize the resource integration\n */\nexport function createResourceIntegration(resourceManager: ResourceManager): ResourceIntegration {\n  // Create all the resource managers\n  const thresholdManager = new ResourceThresholdManager();\n  const flowManager = ResourceFlowManager.getInstance(); // Use getInstance instead of new\n  const storageManager = new ResourceStorageManager();\n  const costManager = new ResourceCostManager();\n  const exchangeManager = new ResourceExchangeManager();\n  const poolManager = new ResourcePoolManager();\n\n  // Create the integration\n  const integration = new ResourceIntegration(\n    resourceManager,\n    thresholdManager,\n    flowManager,\n    storageManager,\n    costManager,\n    exchangeManager,\n    poolManager\n  );\n\n  // Initialize the integration\n  integration.initialize();\n\n  return integration;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/resource/ResourcePerformanceMonitor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/resource/ResourcePoolManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/resource/ResourceStorageManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":280,"column":38,"nodeType":null,"messageId":"unusedVar","endLine":280,"endColumn":39},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":329,"column":38,"nodeType":null,"messageId":"unusedVar","endLine":329,"endColumn":39},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_type' is defined but never used.","line":439,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":439,"endColumn":32},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_amount' is defined but never used.","line":439,"column":48,"nodeType":null,"messageId":"unusedVar","endLine":439,"endColumn":55}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  ResourceState,\n  ResourceTransfer,\n  ResourceType,\n} from './../../types/resources/ResourceTypes';\n\n/**\n * Storage allocation strategy\n */\nexport type StorageAllocationStrategy = 'balanced' | 'prioritized' | 'dedicated';\n\n/**\n * Storage container configuration\n */\nexport interface StorageContainerConfig {\n  id: string;\n  name: string;\n  type: 'container' | 'pool' | 'storage';\n  capacity: number;\n  resourceTypes: ResourceType[];\n  priority: number;\n  location?: string;\n  efficiency?: number;\n  accessSpeed?: number;\n  upgradeLevel?: number;\n  maxUpgradeLevel?: number;\n}\n\n/**\n * Storage container state\n */\nexport interface StorageContainerState {\n  config: StorageContainerConfig;\n  resources: Map<ResourceType, ResourceState>;\n  totalStored: number;\n  lastUpdated: number;\n}\n\n/**\n * Storage allocation\n */\nexport interface StorageAllocation {\n  containerId: string;\n  resourceType: ResourceType;\n  amount: number;\n  percentage: number;\n}\n\n/**\n * Storage overflow policy\n */\nexport type StorageOverflowPolicy = 'reject' | 'redistribute' | 'convert' | 'discard';\n\n/**\n * Storage manager configuration\n */\nexport interface StorageManagerConfig {\n  defaultAllocationStrategy: StorageAllocationStrategy;\n  overflowPolicy: StorageOverflowPolicy;\n  autoRebalance: boolean;\n  rebalanceThreshold: number;\n  priorityWeights: {\n    containerPriority: number;\n    resourcePriority: number;\n    fillPercentage: number;\n  };\n}\n\n/**\n * Resource Storage Manager\n * Manages resource storage containers, pools, and allocation strategies\n */\nexport class ResourceStorageManager {\n  private containers: Map<string, StorageContainerState>;\n  private resourcePriorities: Map<ResourceType, number>;\n  private config: StorageManagerConfig;\n  private transferHistory: ResourceTransfer[];\n  private maxHistorySize: number;\n\n  constructor(config?: Partial<StorageManagerConfig>) {\n    this.containers = new Map();\n    this.resourcePriorities = new Map();\n    this.transferHistory = [];\n    this.maxHistorySize = 100;\n\n    // Default configuration\n    this.config = {\n      defaultAllocationStrategy: 'balanced',\n      overflowPolicy: 'redistribute',\n      autoRebalance: true,\n      rebalanceThreshold: 0.2, // 20% imbalance triggers rebalance\n      priorityWeights: {\n        containerPriority: 0.4,\n        resourcePriority: 0.4,\n        fillPercentage: 0.2,\n      },\n      ...config,\n    };\n\n    // Set default resource priorities\n    this.setDefaultResourcePriorities();\n  }\n\n  /**\n   * Set default resource priorities\n   */\n  private setDefaultResourcePriorities(): void {\n    // Higher number = higher priority\n    this.resourcePriorities.set(ResourceType.ENERGY, 10);\n    this.resourcePriorities.set(ResourceType.MINERALS, 8);\n    // Replace non-existent resource types with valid ones\n    this.resourcePriorities.set(ResourceType.POPULATION, 9);\n    this.resourcePriorities.set(ResourceType.RESEARCH, 10);\n    this.resourcePriorities.set(ResourceType.PLASMA, 10);\n    this.resourcePriorities.set(ResourceType.GAS, 7);\n    this.resourcePriorities.set(ResourceType.EXOTIC, 6);\n    this.resourcePriorities.set(ResourceType.RESEARCH, 5);\n    this.resourcePriorities.set(ResourceType.POPULATION, 10);\n  }\n\n  /**\n   * Register a storage container\n   */\n  public registerContainer(config: StorageContainerConfig): boolean {\n    if (!config.id || !config.resourceTypes || config.resourceTypes.length === 0) {\n      console.error('Invalid storage container configuration:', config);\n      return false;\n    }\n\n    // Initialize resource states\n    const resources = new Map<ResourceType, ResourceState>();\n\n    for (const type of config.resourceTypes) {\n      resources.set(type, {\n        current: 0,\n        min: 0,\n        max: config.capacity / config.resourceTypes.length, // Divide capacity equally by default\n        production: 0,\n        consumption: 0,\n      });\n    }\n\n    this.containers.set(config.id, {\n      config,\n      resources,\n      totalStored: 0,\n      lastUpdated: Date.now(),\n    });\n\n    return true;\n  }\n\n  /**\n   * Unregister a storage container\n   */\n  public unregisterContainer(id: string): boolean {\n    if (!this.containers.has(id)) {\n      return false;\n    }\n\n    this.containers.delete(id);\n    return true;\n  }\n\n  /**\n   * Get a storage container\n   */\n  public getContainer(id: string): StorageContainerState | undefined {\n    return this.containers.get(id);\n  }\n\n  /**\n   * Get all storage containers\n   */\n  public getAllContainers(): StorageContainerState[] {\n    return Array.from(this.containers.values());\n  }\n\n  /**\n   * Get containers by resource type\n   */\n  public getContainersByResourceType(type: ResourceType): StorageContainerState[] {\n    return Array.from(this.containers.values()).filter(container => container.resources.has(type));\n  }\n\n  /**\n   * Store resource in a specific container\n   */\n  public storeResource(containerId: string, type: ResourceType, amount: number): number {\n    const container = this.containers.get(containerId);\n    if (!container || !container.resources.has(type) || amount <= 0) {\n      return 0;\n    }\n\n    const resourceState = container.resources.get(type)!;\n    const availableSpace = resourceState.max - resourceState.current;\n\n    if (availableSpace <= 0) {\n      return 0;\n    }\n\n    const amountToStore = Math.min(amount, availableSpace);\n\n    resourceState.current += amountToStore;\n\n    container.totalStored += amountToStore;\n    container.lastUpdated = Date.now();\n\n    // Record transfer\n    this.recordTransfer({\n      type,\n      source: 'external',\n      target: containerId,\n      amount: amountToStore,\n      timestamp: Date.now(),\n    });\n\n    return amountToStore;\n  }\n\n  /**\n   * Retrieve resource from a specific container\n   */\n  public retrieveResource(containerId: string, type: ResourceType, amount: number): number {\n    const container = this.containers.get(containerId);\n    if (!container || !container.resources.has(type) || amount <= 0) {\n      return 0;\n    }\n\n    const resourceState = container.resources.get(type)!;\n\n    if (resourceState.current <= 0) {\n      return 0;\n    }\n\n    const amountToRetrieve = Math.min(amount, resourceState.current);\n\n    resourceState.current -= amountToRetrieve;\n\n    container.totalStored -= amountToRetrieve;\n    container.lastUpdated = Date.now();\n\n    // Record transfer\n    this.recordTransfer({\n      type,\n      source: containerId,\n      target: 'external',\n      amount: amountToRetrieve,\n      timestamp: Date.now(),\n    });\n\n    return amountToRetrieve;\n  }\n\n  /**\n   * Store resource in the best available container\n   */\n  public storeResourceOptimal(type: ResourceType, amount: number): number {\n    if (amount <= 0) {\n      return 0;\n    }\n\n    // Get all containers that can store this resource type\n    const availableContainers = this.getContainersByResourceType(type);\n\n    if (availableContainers.length === 0) {\n      return 0;\n    }\n\n    // Calculate scores for each container based on the allocation strategy\n    const containerScores = this.calculateContainerScores(availableContainers, type);\n\n    // Sort containers by score (highest first)\n    const sortedContainers = [...containerScores].sort((a, b) => b.score - a.score);\n\n    let remainingAmount = amount;\n    let totalStored = 0;\n\n    // Try to store in containers by score order\n    for (const { containerId, score: _ } of sortedContainers) {\n      if (remainingAmount <= 0) {\n        break;\n      }\n\n      const amountStored = this.storeResource(containerId, type, remainingAmount);\n      totalStored += amountStored;\n      remainingAmount -= amountStored;\n    }\n\n    // Handle overflow if needed\n    if (remainingAmount > 0 && this.config.overflowPolicy !== 'reject') {\n      totalStored += this.handleOverflow(type, remainingAmount);\n    }\n\n    // Check if rebalancing is needed\n    if (this.config.autoRebalance) {\n      this.checkAndRebalance(type);\n    }\n\n    return totalStored;\n  }\n\n  /**\n   * Retrieve resource from the best available container\n   */\n  public retrieveResourceOptimal(type: ResourceType, amount: number): number {\n    if (amount <= 0) {\n      return 0;\n    }\n\n    // Get all containers that store this resource type\n    const availableContainers = this.getContainersByResourceType(type);\n\n    if (availableContainers.length === 0) {\n      return 0;\n    }\n\n    // Calculate scores for each container based on the allocation strategy\n    // For retrieval, we want to prioritize containers with higher fill percentage\n    const containerScores = this.calculateContainerScores(availableContainers, type, true);\n\n    // Sort containers by score (highest first)\n    const sortedContainers = [...containerScores].sort((a, b) => b.score - a.score);\n\n    let remainingAmount = amount;\n    let totalRetrieved = 0;\n\n    // Try to retrieve from containers by score order\n    for (const { containerId, score: _ } of sortedContainers) {\n      if (remainingAmount <= 0) {\n        break;\n      }\n\n      const amountRetrieved = this.retrieveResource(containerId, type, remainingAmount);\n      totalRetrieved += amountRetrieved;\n      remainingAmount -= amountRetrieved;\n    }\n\n    return totalRetrieved;\n  }\n\n  /**\n   * Calculate container scores for allocation\n   */\n  private calculateContainerScores(\n    containers: StorageContainerState[],\n    resourceType: ResourceType,\n    forRetrieval = false\n  ): Array<{ containerId: string; score: number }> {\n    const { containerPriority, resourcePriority, fillPercentage } = this.config.priorityWeights;\n    const resourcePriorityValue = this.resourcePriorities.get(resourceType) || 5;\n\n    return containers.map(container => {\n      const resourceState = container.resources.get(resourceType)!;\n      const fillRatio = resourceState.current / resourceState.max;\n\n      // For storage, we prefer containers with lower fill percentage\n      // For retrieval, we prefer containers with higher fill percentage\n      const fillScore = forRetrieval ? fillRatio : 1 - fillRatio;\n\n      // Calculate weighted score\n      const score =\n        container.config.priority * containerPriority +\n        resourcePriorityValue * resourcePriority +\n        fillScore * fillPercentage;\n\n      return {\n        containerId: container.config.id,\n        score,\n      };\n    });\n  }\n\n  /**\n   * Handle overflow based on policy\n   */\n  private handleOverflow(type: ResourceType, amount: number): number {\n    switch (this.config.overflowPolicy) {\n      case 'redistribute':\n        return this.redistributeOverflow(type, amount);\n\n      case 'convert':\n        return this.convertOverflow(type, amount);\n\n      case 'discard':\n        // Just discard the overflow\n        return 0;\n\n      default:\n        return 0;\n    }\n  }\n\n  /**\n   * Redistribute overflow by expanding container capacity\n   */\n  private redistributeOverflow(type: ResourceType, amount: number): number {\n    // Find containers that can store this resource type\n    const relevantContainers = this.getContainersByResourceType(type);\n\n    if (relevantContainers.length === 0) {\n      return 0;\n    }\n\n    // Sort by upgrade potential (containers with lower upgrade level first)\n    const upgradableContainers = relevantContainers\n      .filter(\n        container =>\n          container.config.upgradeLevel !== undefined &&\n          container.config.maxUpgradeLevel !== undefined &&\n          container.config.upgradeLevel < container.config.maxUpgradeLevel\n      )\n      .sort((a, b) => (a.config.upgradeLevel ?? 0) - (b.config.upgradeLevel ?? 0));\n\n    if (upgradableContainers.length === 0) {\n      return 0;\n    }\n\n    // Upgrade the first container\n    const containerToUpgrade = upgradableContainers[0];\n    const resourceState = containerToUpgrade.resources.get(type)!;\n\n    // Increase capacity by 20%\n    const capacityIncrease = resourceState.max * 0.2;\n    resourceState.max += capacityIncrease;\n\n    // Increment upgrade level\n    if (containerToUpgrade.config.upgradeLevel !== undefined) {\n      containerToUpgrade.config.upgradeLevel += 1;\n    }\n\n    // Try to store again\n    return this.storeResource(containerToUpgrade.config.id, type, amount);\n  }\n\n  /**\n   * Convert overflow to another resource type\n   */\n  private convertOverflow(_type: ResourceType, _amount: number): number {\n    // This is a placeholder for resource conversion logic\n    // In a real implementation, this would convert the resource to another type\n    // based on conversion rules\n\n    // For now, we'll just return 0 (no storage)\n    return 0;\n  }\n\n  /**\n   * Check if rebalancing is needed and perform it\n   */\n  private checkAndRebalance(type: ResourceType): void {\n    const containers = this.getContainersByResourceType(type);\n\n    if (containers.length <= 1) {\n      return;\n    }\n\n    // Calculate fill ratios\n    const fillRatios = containers.map(container => {\n      const resourceState = container.resources.get(type)!;\n      return {\n        id: container.config.id,\n        fillRatio: resourceState.current / resourceState.max,\n      };\n    });\n\n    // Find min and max fill ratios\n    const minFill = Math.min(...fillRatios.map(r => r.fillRatio));\n    const maxFill = Math.max(...fillRatios.map(r => r.fillRatio));\n\n    // Check if imbalance exceeds threshold\n    if (maxFill - minFill > this.config.rebalanceThreshold) {\n      this.rebalanceContainers(type, containers);\n    }\n  }\n\n  /**\n   * Rebalance resources between containers\n   */\n  private rebalanceContainers(type: ResourceType, containers: StorageContainerState[]): void {\n    // Calculate target fill ratio (average)\n    let totalCurrent = 0;\n    let totalMax = 0;\n\n    for (const container of containers) {\n      const resourceState = container.resources.get(type)!;\n      totalCurrent += resourceState.current;\n      totalMax += resourceState.max;\n    }\n\n    const targetFillRatio = totalCurrent / totalMax;\n\n    // Calculate transfers needed\n    for (const container of containers) {\n      const resourceState = container.resources.get(type)!;\n      const currentFillRatio = resourceState.current / resourceState.max;\n\n      if (Math.abs(currentFillRatio - targetFillRatio) < 0.05) {\n        // Close enough, skip\n        continue;\n      }\n\n      const targetAmount = resourceState.max * targetFillRatio;\n      const difference = targetAmount - resourceState.current;\n\n      if (difference > 0) {\n        // Need to add resources\n        // Find container with excess\n        const sourceContainer = containers.find(c => {\n          const rs = c.resources.get(type)!;\n          return rs.current / rs.max > targetFillRatio + 0.05;\n        });\n\n        if (sourceContainer) {\n          const sourceState = sourceContainer.resources.get(type)!;\n          const availableToTransfer = sourceState.current - sourceState.max * targetFillRatio;\n          const transferAmount = Math.min(difference, availableToTransfer);\n\n          // Transfer resources\n          this.transferBetweenContainers(\n            sourceContainer.config.id,\n            container.config.id,\n            type,\n            transferAmount\n          );\n        }\n      }\n    }\n  }\n\n  /**\n   * Transfer resources between containers\n   */\n  public transferBetweenContainers(\n    sourceId: string,\n    targetId: string,\n    type: ResourceType,\n    amount: number\n  ): number {\n    if (amount <= 0 || sourceId === targetId) {\n      return 0;\n    }\n\n    // Retrieve from source\n    const retrievedAmount = this.retrieveResource(sourceId, type, amount);\n\n    if (retrievedAmount <= 0) {\n      return 0;\n    }\n\n    // Store in target\n    const storedAmount = this.storeResource(targetId, type, retrievedAmount);\n\n    // If not all was stored, return remainder to source\n    if (storedAmount < retrievedAmount) {\n      const remainder = retrievedAmount - storedAmount;\n      this.storeResource(sourceId, type, remainder);\n    }\n\n    // Record transfer\n    this.recordTransfer({\n      type,\n      source: sourceId,\n      target: targetId,\n      amount: storedAmount,\n      timestamp: Date.now(),\n    });\n\n    return storedAmount;\n  }\n\n  /**\n   * Record a transfer in history\n   */\n  private recordTransfer(transfer: ResourceTransfer): void {\n    this.transferHistory.push(transfer);\n\n    // Trim history if needed\n    if (this.transferHistory.length > this.maxHistorySize) {\n      this.transferHistory = this.transferHistory.slice(-this.maxHistorySize);\n    }\n  }\n\n  /**\n   * Get transfer history\n   */\n  public getTransferHistory(): ResourceTransfer[] {\n    return [...this.transferHistory];\n  }\n\n  /**\n   * Get transfer history for a specific resource type\n   */\n  public getTransferHistoryByType(type: ResourceType): ResourceTransfer[] {\n    return this.transferHistory.filter(transfer => transfer.type === type);\n  }\n\n  /**\n   * Get total stored amount of a resource type\n   */\n  public getTotalStored(type: ResourceType): number {\n    let total = 0;\n\n    for (const container of Array.from(this.containers.values())) {\n      const resourceState = container.resources.get(type);\n      if (resourceState) {\n        total += resourceState.current;\n      }\n    }\n\n    return total;\n  }\n\n  /**\n   * Get total capacity for a resource type\n   */\n  public getTotalCapacity(type: ResourceType): number {\n    let total = 0;\n\n    for (const container of Array.from(this.containers.values())) {\n      const resourceState = container.resources.get(type);\n      if (resourceState) {\n        total += resourceState.max;\n      }\n    }\n\n    return total;\n  }\n\n  /**\n   * Set resource priority\n   */\n  public setResourcePriority(type: ResourceType, priority: number): void {\n    this.resourcePriorities.set(type, priority);\n  }\n\n  /**\n   * Get resource priority\n   */\n  public getResourcePriority(type: ResourceType): number {\n    return this.resourcePriorities.get(type) || 5;\n  }\n\n  /**\n   * Update container configuration\n   */\n  public updateContainerConfig(id: string, config: Partial<StorageContainerConfig>): boolean {\n    const container = this.containers.get(id);\n    if (!container) {\n      return false;\n    }\n\n    // Update config\n    container.config = {\n      ...container.config,\n      ...config,\n    };\n\n    return true;\n  }\n\n  /**\n   * Clean up resources\n   */\n  public cleanup(): void {\n    this.containers.clear();\n    this.resourcePriorities.clear();\n    this.transferHistory = [];\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/resource/ResourceThresholdManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'resourceType' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":347,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":347,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'resourceType' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":379,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":379,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'state' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":423,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":423,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ResourceAlert } from '../../hooks/resources/useResourceTracking';\nimport { ModuleEvent, moduleEventBus, ModuleEventType } from '../../lib/modules/ModuleEvents';\nimport { ModuleType } from '../../types/buildings/ModuleTypes';\nimport {\n  ResourceState,\n  ResourceThreshold,\n  ResourceType,\n} from '../../types/resources/ResourceTypes';\nimport { validateResourceThreshold } from '../../utils/resources/resourceValidation';\n\n// Map our custom event types to the standard ModuleEventType\nconst RESOURCE_UPDATE: ModuleEventType = 'RESOURCE_UPDATED';\nconst RESOURCE_THRESHOLD_TRIGGERED: ModuleEventType = 'STATUS_CHANGED';\nconst RESOURCE_THRESHOLD_RESOLVED: ModuleEventType = 'STATUS_CHANGED';\nconst RESOURCE_PRODUCTION_ADJUST: ModuleEventType = 'RESOURCE_PRODUCTION_REGISTERED';\nconst RESOURCE_CONSUMPTION_ADJUST: ModuleEventType = 'RESOURCE_CONSUMPTION_REGISTERED';\nconst RESOURCE_TRANSFER_REQUEST: ModuleEventType = 'RESOURCE_TRANSFERRED';\nconst NOTIFICATION_CREATE: ModuleEventType = 'STATUS_CHANGED';\nconst RESOURCE_ALERT_CREATED: ModuleEventType = 'STATUS_CHANGED';\nconst RESOURCE_ALERT_CLEARED: ModuleEventType = 'STATUS_CHANGED';\n\n// Resource manager module ID and type\nconst RESOURCE_MANAGER_ID = 'resource-threshold-manager';\nconst RESOURCE_MANAGER_TYPE: ModuleType = 'resource-manager';\n\n/**\n * Interface for resource update event data\n */\ninterface ResourceUpdateEventData {\n  type: ResourceType;\n  state: ResourceState;\n}\n\n/**\n * Type guard for ResourceUpdateEventData\n */\nfunction isResourceUpdateEventData(data: unknown): data is ResourceUpdateEventData {\n  if (!data || typeof data !== 'object') {\n    return false;\n  }\n\n  const updateData = data as Record<string, unknown>;\n\n  return (\n    typeof updateData.type === 'string' &&\n    updateData.state !== undefined &&\n    typeof updateData.state === 'object'\n  );\n}\n\n/**\n * Threshold action types\n */\nexport type ThresholdActionType = 'production' | 'consumption' | 'transfer' | 'notification';\n\n/**\n * Threshold action\n */\nexport interface ThresholdAction {\n  type: ThresholdActionType;\n  target: string;\n  amount?: number;\n  message?: string;\n  priority?: number;\n}\n\n/**\n * Threshold configuration\n */\nexport interface ThresholdConfig {\n  id: string;\n  threshold: ResourceThreshold;\n  actions: ThresholdAction[];\n  enabled: boolean;\n  autoResolve?: boolean;\n}\n\n/**\n * Threshold status\n */\nexport type ThresholdStatus = 'inactive' | 'warning' | 'critical' | 'resolved';\n\n/**\n * Threshold state\n */\nexport interface ThresholdState {\n  config: ThresholdConfig;\n  status: ThresholdStatus;\n  lastTriggered?: number;\n  lastResolved?: number;\n  actionsTaken: number;\n  lastValue?: number;\n  rateOfChange?: number;\n}\n\n/**\n * Resource Threshold Manager\n * Manages resource thresholds and triggers actions when thresholds are crossed\n */\nexport class ResourceThresholdManager {\n  private thresholds: Map<string, ThresholdConfig>;\n  private thresholdStates: Map<string, ThresholdState>;\n  private activeAlerts: Map<string, ResourceAlert>;\n  private resourceStates: Map<ResourceType, ResourceState>;\n  private checkInterval: number;\n  private intervalId: NodeJS.Timeout | null;\n  private lastCheck: number;\n\n  constructor(checkInterval = 1000) {\n    this.thresholds = new Map();\n    this.thresholdStates = new Map();\n    this.activeAlerts = new Map();\n    this.resourceStates = new Map();\n    this.checkInterval = checkInterval;\n    this.intervalId = null;\n    this.lastCheck = Date.now();\n\n    // Register event listeners\n    moduleEventBus.subscribe(RESOURCE_UPDATE, this.handleResourceUpdate);\n  }\n\n  /**\n   * Start threshold monitoring\n   */\n  public start(): void {\n    if (this.intervalId) {\n      return;\n    }\n\n    this.intervalId = setInterval(() => {\n      this.checkThresholds();\n    }, this.checkInterval);\n  }\n\n  /**\n   * Stop threshold monitoring\n   */\n  public stop(): void {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n      this.intervalId = null;\n    }\n  }\n\n  /**\n   * Register a threshold configuration\n   */\n  public registerThreshold(config: ThresholdConfig): boolean {\n    if (!config.id || !validateResourceThreshold(config.threshold)) {\n      console.error('Invalid threshold configuration:', config);\n      return false;\n    }\n\n    this.thresholds.set(config.id, config);\n    this.thresholdStates.set(config.id, {\n      config,\n      status: 'inactive',\n      actionsTaken: 0,\n    });\n\n    return true;\n  }\n\n  /**\n   * Unregister a threshold configuration\n   */\n  public unregisterThreshold(id: string): boolean {\n    if (!this.thresholds.has(id)) {\n      return false;\n    }\n\n    this.thresholds.delete(id);\n    this.thresholdStates.delete(id);\n    return true;\n  }\n\n  /**\n   * Enable a threshold\n   */\n  public enableThreshold(id: string): boolean {\n    const config = this.thresholds.get(id);\n    if (!config) {\n      return false;\n    }\n\n    config.enabled = true;\n    return true;\n  }\n\n  /**\n   * Disable a threshold\n   */\n  public disableThreshold(id: string): boolean {\n    const config = this.thresholds.get(id);\n    if (!config) {\n      return false;\n    }\n\n    config.enabled = false;\n    return true;\n  }\n\n  /**\n   * Update resource state\n   */\n  private handleResourceUpdate = (event: ModuleEvent): void => {\n    if (!event?.data) {\n      console.warn('Resource update event missing data');\n      return;\n    }\n\n    if (!isResourceUpdateEventData(event?.data)) {\n      console.warn('Invalid resource update event data:', event?.data);\n      return;\n    }\n\n    const { type, state } = event.data;\n    this.resourceStates.set(type, state);\n  };\n\n  /**\n   * Check all thresholds\n   */\n  private checkThresholds(): void {\n    const now = Date.now();\n    const _deltaTime = now - this.lastCheck;\n    this.lastCheck = now;\n\n    // Convert Map entries to array to avoid MapIterator error\n    const thresholdEntries = Array.from(this.thresholds.entries());\n\n    for (let i = 0; i < thresholdEntries.length; i++) {\n      const [id, config] = thresholdEntries[i];\n\n      if (!config.enabled) {\n        continue;\n      }\n\n      const state = this.thresholdStates.get(id);\n\n      // Use _deltaTime to calculate rate of change for time-sensitive thresholds\n      if (_deltaTime > 0 && state) {\n        const resourceType = config.threshold.resourceId;\n        const resourceState = this.resourceStates.get(resourceType);\n\n        if (resourceState && state.lastValue !== undefined) {\n          // Calculate rate of change per second\n          const currentValue = resourceState.current;\n          const rateOfChange = ((currentValue - state.lastValue) / _deltaTime) * 1000;\n\n          // Log significant rate changes for monitoring\n          if (Math.abs(rateOfChange) > 0.5) {\n            // Threshold for significant change\n            console.warn(\n              `[ResourceThresholdManager] Significant rate change detected for ${resourceType}: ${rateOfChange.toFixed(2)} units/sec`\n            );\n          }\n\n          // Update the last value for next calculation\n          this.thresholdStates.set(id, {\n            ...state,\n            lastValue: currentValue,\n            rateOfChange,\n          });\n        } else if (resourceState) {\n          // Initialize lastValue if not set\n          this.thresholdStates.set(id, {\n            ...state,\n            lastValue: resourceState.current,\n          });\n        }\n      }\n\n      if (!state) {\n        continue;\n      }\n\n      const resourceState = this.resourceStates.get(config.threshold.resourceId);\n      if (!resourceState) {\n        continue;\n      }\n\n      const isTriggered = this.isThresholdTriggered(config.threshold, resourceState);\n\n      if (isTriggered && state.status === 'inactive') {\n        // Threshold triggered\n        state.status = this.getThresholdSeverity(config.threshold, resourceState);\n        state.lastTriggered = now;\n        this.executeThresholdActions(config, state.status);\n        state.actionsTaken++;\n\n        // Create alert\n        this.createAlert(config, state.status);\n\n        // Emit event\n        moduleEventBus.emit({\n          type: RESOURCE_THRESHOLD_TRIGGERED,\n          moduleId: RESOURCE_MANAGER_ID,\n          moduleType: RESOURCE_MANAGER_TYPE,\n          timestamp: now,\n          data: {\n            id,\n            type: config.threshold.resourceId,\n            status: state.status,\n            timestamp: now,\n            severity: state.status === 'critical' ? 'high' : 'medium',\n          },\n        });\n      } else if (!isTriggered && state.status !== 'inactive') {\n        // Threshold resolved\n        state.status = 'resolved';\n        state.lastResolved = now;\n\n        // Clear alert if auto-resolve is enabled\n        if (config.autoResolve) {\n          this.clearAlert(id);\n        }\n\n        // Emit event\n        moduleEventBus.emit({\n          type: RESOURCE_THRESHOLD_RESOLVED,\n          moduleId: RESOURCE_MANAGER_ID,\n          moduleType: RESOURCE_MANAGER_TYPE,\n          timestamp: now,\n          data: {\n            id,\n            type: config.threshold.resourceId,\n            timestamp: now,\n            severity: 'info',\n          },\n        });\n\n        // Reset to inactive after a short delay\n        setTimeout(() => {\n          if (state.status === 'resolved') {\n            state.status = 'inactive';\n          }\n        }, 5000);\n      }\n    }\n  }\n\n  /**\n   * Check if a threshold is triggered\n   */\n  private isThresholdTriggered(threshold: ResourceThreshold, state: ResourceState): boolean {\n    const resourceType = threshold.resourceId;\n    if (!state) {\n      return false;\n    }\n\n    if (threshold.min !== undefined && state.current < threshold.min) {\n      return true;\n    }\n\n    if (threshold.max !== undefined && state.current > threshold.max) {\n      return true;\n    }\n\n    if (threshold.target !== undefined) {\n      const deviation = Math.abs(state.current - threshold.target);\n      const maxDeviation = threshold.target * 0.1; // 10% deviation\n\n      if (deviation > maxDeviation) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Get threshold severity based on how far the value is from the threshold\n   */\n  private getThresholdSeverity(\n    threshold: ResourceThreshold,\n    state: ResourceState\n  ): ThresholdStatus {\n    const resourceType = threshold.resourceId;\n    if (!state) {\n      return 'inactive';\n    }\n\n    if (threshold.min !== undefined && state.current < threshold.min) {\n      const ratio = state.current / threshold.min;\n\n      if (ratio < 0.5) {\n        return 'critical';\n      } else {\n        return 'warning';\n      }\n    }\n\n    if (threshold.max !== undefined && state.current > threshold.max) {\n      const ratio = state.current / threshold.max;\n\n      if (ratio > 1.5) {\n        return 'critical';\n      } else {\n        return 'warning';\n      }\n    }\n\n    if (threshold.target !== undefined) {\n      const deviation = Math.abs(state.current - threshold.target);\n      const deviationRatio = deviation / threshold.target;\n\n      if (deviationRatio > 0.25) {\n        return 'critical';\n      } else {\n        return 'warning';\n      }\n    }\n\n    return 'warning';\n  }\n\n  /**\n   * Execute threshold actions\n   */\n  private executeThresholdActions(config: ThresholdConfig, status: ThresholdStatus): void {\n    const resourceType = config.threshold.resourceId;\n    const state = this.resourceStates.get(resourceType);\n    const now = Date.now();\n\n    for (const action of config.actions) {\n      switch (action.type) {\n        case 'production':\n          moduleEventBus.emit({\n            type: RESOURCE_PRODUCTION_ADJUST,\n            moduleId: RESOURCE_MANAGER_ID,\n            moduleType: RESOURCE_MANAGER_TYPE,\n            timestamp: now,\n            data: {\n              type: resourceType,\n              target: action.target,\n              amount: action.amount ?? 0,\n              priority: action.priority || 1,\n              severity: 'info',\n            },\n          });\n          break;\n\n        case 'consumption':\n          moduleEventBus.emit({\n            type: RESOURCE_CONSUMPTION_ADJUST,\n            moduleId: RESOURCE_MANAGER_ID,\n            moduleType: RESOURCE_MANAGER_TYPE,\n            timestamp: now,\n            data: {\n              type: resourceType,\n              target: action.target,\n              amount: action.amount ?? 0,\n              priority: action.priority || 1,\n              severity: 'info',\n            },\n          });\n          break;\n\n        case 'transfer':\n          moduleEventBus.emit({\n            type: RESOURCE_TRANSFER_REQUEST,\n            moduleId: RESOURCE_MANAGER_ID,\n            moduleType: RESOURCE_MANAGER_TYPE,\n            timestamp: now,\n            data: {\n              type: resourceType,\n              target: action.target,\n              amount: action.amount ?? 0,\n              priority: action.priority || 1,\n              severity: 'info',\n            },\n          });\n          break;\n\n        case 'notification':\n          moduleEventBus.emit({\n            type: NOTIFICATION_CREATE,\n            moduleId: RESOURCE_MANAGER_ID,\n            moduleType: RESOURCE_MANAGER_TYPE,\n            timestamp: now,\n            data: {\n              type: 'resource',\n              message: action.message || `Resource ${resourceType} threshold triggered`,\n              severity: status === 'critical' ? 'high' : 'medium',\n              timestamp: now,\n            },\n          });\n          break;\n      }\n    }\n  }\n\n  /**\n   * Create a resource alert\n   */\n  private createAlert(config: ThresholdConfig, status: ThresholdStatus): void {\n    const resourceType = config.threshold.resourceId;\n    const state = this.resourceStates.get(resourceType);\n    if (!state) return;\n\n    const alert: ResourceAlert = {\n      id: config.id,\n      type: resourceType,\n      message: `Resource ${resourceType} threshold triggered`,\n      severity: status === 'critical' ? 'critical' : 'medium',\n      timestamp: Date.now(),\n      threshold: config.threshold,\n    };\n\n    this.activeAlerts.set(config.id, alert);\n    moduleEventBus.emit({\n      type: RESOURCE_ALERT_CREATED,\n      moduleId: RESOURCE_MANAGER_ID,\n      moduleType: RESOURCE_MANAGER_TYPE,\n      timestamp: Date.now(),\n      data: { ...alert },\n    });\n  }\n\n  /**\n   * Clear a resource alert\n   */\n  private clearAlert(id: string): void {\n    const alert = this.activeAlerts.get(id);\n    if (!alert) return;\n\n    const resourceType = alert.type;\n    const state = this.resourceStates.get(resourceType);\n    if (!state) return;\n\n    this.activeAlerts.delete(id);\n    moduleEventBus.emit({\n      type: RESOURCE_ALERT_CLEARED,\n      moduleId: RESOURCE_MANAGER_ID,\n      moduleType: RESOURCE_MANAGER_TYPE,\n      timestamp: Date.now(),\n      data: {\n        id,\n        type: resourceType,\n        timestamp: Date.now(),\n        severity: 'info',\n      },\n    });\n  }\n\n  /**\n   * Get all active alerts\n   */\n  public getActiveAlerts(): ResourceAlert[] {\n    return Array.from(this.activeAlerts.values());\n  }\n\n  /**\n   * Get all threshold configurations\n   */\n  public getThresholdConfigs(): ThresholdConfig[] {\n    return Array.from(this.thresholds.values());\n  }\n\n  /**\n   * Get all threshold states\n   */\n  public getThresholdStates(): ThresholdState[] {\n    return Array.from(this.thresholdStates.values());\n  }\n\n  /**\n   * Get a specific threshold state\n   */\n  public getThresholdState(id: string): ThresholdState | undefined {\n    return this.thresholdStates.get(id);\n  }\n\n  /**\n   * Clean up resources\n   */\n  public cleanup(): void {\n    this.stop();\n    // Use the unsubscribe function returned by subscribe\n    moduleEventBus.subscribe(RESOURCE_UPDATE, this.handleResourceUpdate)();\n    this.thresholds.clear();\n    this.thresholdStates.clear();\n    this.activeAlerts.clear();\n    this.resourceStates.clear();\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/resource/ResourceTransferManager.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/ships/ShipHangarManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/ships/ShipManagerImpl.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/ships/StandardShipHangarManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/weapons/AdvancedWeaponEffectManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/weapons/WeaponEffectManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_position' is defined but never used.","line":166,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":166,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_direction' is defined but never used.","line":167,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":167,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_config' is defined but never used.","line":168,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":168,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_quality' is defined but never used.","line":169,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":169,"endColumn":13}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseTypedEventEmitter } from '../../lib/modules/BaseTypedEventEmitter';\nimport { Position } from '../../types/core/GameTypes';\nimport { WeaponCategory, WeaponVariant } from '../../types/weapons/WeaponTypes';\nimport { effectLifecycleManager } from '../effects/EffectLifecycleManager';\nimport { particleSystemManager } from '../effects/ParticleSystemManager';\n\ninterface WeaponEffectEvents {\n  effectStarted: { weaponId: string; effectType: string };\n  effectEnded: { weaponId: string; effectType: string };\n  qualityChanged: { weaponId: string; quality: 'low' | 'medium' | 'high' };\n  [key: string]: unknown;\n}\n\ninterface WeaponEffectConfig {\n  duration: number;\n  particleCount: number;\n  color: string;\n  size: number;\n  spread: number;\n  speed: number;\n  pattern: 'beam' | 'projectile' | 'explosion' | 'continuous';\n  quality?: 'low' | 'medium' | 'high';\n}\n\nexport class WeaponEffectManager extends BaseTypedEventEmitter<WeaponEffectEvents> {\n  private static instance: WeaponEffectManager;\n  private activeEffects: Map<string, Set<string>>;\n  private effectConfigs: Map<WeaponCategory, Map<WeaponVariant, WeaponEffectConfig>>;\n  private qualitySettings: Map<string, 'low' | 'medium' | 'high'>;\n\n  private constructor() {\n    super();\n    this.activeEffects = new Map();\n    this.effectConfigs = new Map();\n    this.qualitySettings = new Map();\n    this.initializeEffectConfigs();\n  }\n\n  public static getInstance(): WeaponEffectManager {\n    if (!WeaponEffectManager.instance) {\n      WeaponEffectManager.instance = new WeaponEffectManager();\n    }\n    return WeaponEffectManager.instance;\n  }\n\n  private initializeEffectConfigs(): void {\n    // Machine Gun effects\n    this.setEffectConfig('machineGun', 'basic', {\n      duration: 200,\n      particleCount: 10,\n      color: '#ffaa00',\n      size: 2,\n      spread: 0.1,\n      speed: 2,\n      pattern: 'projectile',\n    });\n\n    // Plasma Cannon effects\n    this.setEffectConfig('plasmaCannon', 'basic', {\n      duration: 1000,\n      particleCount: 30,\n      color: '#00ffff',\n      size: 4,\n      spread: 0.2,\n      speed: 1,\n      pattern: 'beam',\n    });\n\n    // Beam Weapon effects\n    this.setEffectConfig('beamWeapon', 'basic', {\n      duration: 2000,\n      particleCount: 50,\n      color: '#ff00ff',\n      size: 3,\n      spread: 0.05,\n      speed: 3,\n      pattern: 'continuous',\n    });\n  }\n\n  private setEffectConfig(\n    category: WeaponCategory,\n    variant: WeaponVariant,\n    config: WeaponEffectConfig\n  ): void {\n    if (!this.effectConfigs.has(category)) {\n      this.effectConfigs.set(category, new Map());\n    }\n    this.effectConfigs.get(category)!.set(variant, config);\n  }\n\n  public createWeaponEffect(\n    weaponId: string,\n    category: WeaponCategory,\n    variant: WeaponVariant,\n    position: Position,\n    direction: number\n  ): string[] {\n    const config = this.effectConfigs.get(category)?.get(variant);\n    if (!config) {\n      return [];\n    }\n\n    const quality = this.qualitySettings.get(weaponId) || 'medium';\n\n    const systemIds: string[] = [];\n\n    // Create main weapon effect\n    const mainEffectId = this.createMainEffect(weaponId, position, direction, config, quality);\n    if (mainEffectId) {\n      systemIds.push(mainEffectId);\n    }\n\n    // Create additional effects based on pattern\n    switch (config.pattern) {\n      case 'beam':\n        systemIds.push(...this.createBeamEffect(position, direction, config, quality));\n        break;\n      case 'explosion':\n        systemIds.push(...this.createExplosionEffect(position, config, quality));\n        break;\n      case 'continuous':\n        systemIds.push(...this.createContinuousEffect(position, direction, config, quality));\n        break;\n    }\n\n    // Register with effect lifecycle manager\n    const effectId = effectLifecycleManager.registerEffect(\n      `weapon-${category}-${variant}`,\n      position,\n      config.duration,\n      systemIds,\n      () => this.cleanupWeaponEffect(weaponId, systemIds)\n    );\n\n    // Track active effects\n    if (!this.activeEffects.has(weaponId)) {\n      this.activeEffects.set(weaponId, new Set());\n    }\n    this.activeEffects.get(weaponId)!.add(effectId);\n\n    this.emit('effectStarted', { weaponId, effectType: `${category}-${variant}` });\n    return systemIds;\n  }\n\n  /**\n   * Adjusts particle count based on quality setting\n   * Currently unused but kept for future implementation of quality-based particle effects\n   */\n  private _getQualityAdjustedParticleCount(\n    baseCount: number,\n    quality: 'low' | 'medium' | 'high'\n  ): number {\n    switch (quality) {\n      case 'low':\n        return Math.floor(baseCount * 0.5);\n      case 'high':\n        return Math.floor(baseCount * 1.5);\n      default:\n        return baseCount;\n    }\n  }\n\n  private createMainEffect(\n    weaponId: string,\n    _position: Position,\n    _direction: number,\n    _config: WeaponEffectConfig,\n    _quality: 'low' | 'medium' | 'high'\n  ): string {\n    return `${weaponId}-main-${Date.now()}`;\n  }\n\n  private createBeamEffect(\n    _position: Position,\n    _direction: number,\n    _config: WeaponEffectConfig,\n    _quality: 'low' | 'medium' | 'high'\n  ): string[] {\n    // Adjust particle count based on quality setting\n    const adjustedParticleCount = this._getQualityAdjustedParticleCount(\n      _config.particleCount,\n      _quality\n    );\n\n    console.warn(\n      `[WeaponEffectManager] Creating beam effect with ${adjustedParticleCount} particles at quality ${_quality}`\n    );\n\n    return [`beam-${Date.now()}`];\n  }\n\n  private createExplosionEffect(\n    _position: Position,\n    _config: WeaponEffectConfig,\n    _quality: 'low' | 'medium' | 'high'\n  ): string[] {\n    // Adjust particle count based on quality setting\n    const adjustedParticleCount = this._getQualityAdjustedParticleCount(\n      _config.particleCount,\n      _quality\n    );\n\n    console.warn(\n      `[WeaponEffectManager] Creating explosion effect with ${adjustedParticleCount} particles at quality ${_quality}`\n    );\n\n    return [`explosion-${Date.now()}`];\n  }\n\n  private createContinuousEffect(\n    _position: Position,\n    _direction: number,\n    _config: WeaponEffectConfig,\n    _quality: 'low' | 'medium' | 'high'\n  ): string[] {\n    // Adjust particle count based on quality setting\n    const adjustedParticleCount = this._getQualityAdjustedParticleCount(\n      _config.particleCount,\n      _quality\n    );\n\n    console.warn(\n      `[WeaponEffectManager] Creating continuous effect with ${adjustedParticleCount} particles at quality ${_quality}`\n    );\n\n    return [`continuous-${Date.now()}`];\n  }\n\n  private cleanupWeaponEffect(weaponId: string, systemIds: string[]): void {\n    // Remove particle systems\n    systemIds.forEach(id => {\n      particleSystemManager.removeSystem(id);\n    });\n\n    // Update active effects tracking\n    const effects = this.activeEffects.get(weaponId);\n    if (effects) {\n      effects.forEach(effectId => {\n        this.emit('effectEnded', { weaponId, effectType: effectId });\n      });\n      effects.clear();\n    }\n  }\n\n  public setQuality(weaponId: string, quality: 'low' | 'medium' | 'high'): void {\n    this.qualitySettings.set(weaponId, quality);\n    this.emit('qualityChanged', { weaponId, quality });\n  }\n\n  public getActiveEffects(weaponId: string): string[] {\n    return Array.from(this.activeEffects.get(weaponId) ?? []);\n  }\n\n  public cleanup(): void {\n    // Clean up all active effects\n    for (const [_weaponId, effects] of this.activeEffects) {\n      effects.forEach(effectId => {\n        effectLifecycleManager.cleanupEffectsByType(`weapon-${effectId}`);\n      });\n      effects.clear();\n    }\n    this.activeEffects.clear();\n    this.qualitySettings.clear();\n  }\n}\n\n// Export singleton instance\nexport const weaponEffectManager = WeaponEffectManager.getInstance();\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/managers/weapons/WeaponUpgradeManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/modules/ModuleManagerWrapper.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/pages/ColonyManagementPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/pages/CombatSystemPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/pages/ConverterManagementPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/pages/PerformanceAnalysisDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/pages/ResourceManagementPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/pages/ResourceRegistryDemo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/pages/performance/LongSessionMemoryPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/pages/performance/MultitabPerformanceTestPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/registry/ResourceRegistry.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'relatedResources' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":274,"column":48,"nodeType":null,"messageId":"unusedVar","endLine":274,"endColumn":64},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'resourceType' is defined but never used. Allowed unused elements of array destructuring must match /^_/u.","line":836,"column":49,"nodeType":null,"messageId":"unusedVar","endLine":836,"endColumn":61}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { EventEmitter } from '../lib/events/EventEmitter';\nimport { ResourceType, ResourceTypeMetadata } from '../types/resources/ResourceTypes';\nimport { ResourceCategory } from '../types/resources/StandardizedResourceTypes';\n/**\n * ResourceRegistry.ts\n *\n * A centralized registry for resource types and metadata to ensure consistency across the codebase.\n * This registry serves as the single source of truth for resource information and helps standardize\n * the resource type system throughout the application.\n */\n\n/**\n * Resource quality levels\n */\nexport enum ResourceQuality {\n  LOW = 'low',\n  MEDIUM = 'medium',\n  HIGH = 'high',\n  PREMIUM = 'premium',\n}\n\n/**\n * Extended resource metadata with additional properties\n */\nexport interface ExtendedResourceMetadata extends ResourceTypeMetadata {\n  // Additional properties for resource management\n  baseValue: number;\n  weight: number;\n  storageEfficiency: number;\n  qualityLevels: Record<ResourceQuality, number>;\n  tags: string[];\n  relatedResources: ResourceType[];\n  conversionRates?: Partial<Record<ResourceType, number>>;\n  storageMultiplier: number;\n  valueMultiplier: number;\n  isRare: boolean;\n  isStackable: boolean;\n  maxStackSize: number;\n}\n\n/**\n * Resource registration options\n */\nexport interface ResourceRegistrationOptions {\n  metadata: ExtendedResourceMetadata;\n  overrideExisting?: boolean;\n}\n\n/**\n * Event data types for type safety\n */\nexport interface ResourceRegisteredEvent {\n  resourceType: ResourceType;\n  metadata: ExtendedResourceMetadata;\n}\n\nexport interface ResourceUnregisteredEvent {\n  resourceType: ResourceType;\n}\n\nexport interface ConversionRateChangedEvent {\n  sourceType: ResourceType;\n  targetType: ResourceType;\n  rate: number;\n}\n\nexport interface TagAddedEvent {\n  resourceType: ResourceType;\n  tag: string;\n}\n\nexport interface TagRemovedEvent {\n  resourceType: ResourceType;\n  tag: string;\n}\n\nexport interface ResourceMetadataUpdatedEvent {\n  resourceType: ResourceType;\n  updates: Partial<ExtendedResourceMetadata>;\n}\n\nexport interface QualityLevelChangedEvent {\n  resourceType: ResourceType;\n  quality: ResourceQuality;\n  value: number;\n}\n\nexport interface InitializationCompleteEvent {\n  resourceCount: number;\n}\n\nexport interface ImportCompleteEvent {\n  resourceCount: number;\n  conversionRateCount: number;\n}\n\nexport type RegistryEventData =\n  | ResourceRegisteredEvent\n  | ResourceUnregisteredEvent\n  | ConversionRateChangedEvent\n  | TagAddedEvent\n  | TagRemovedEvent\n  | ResourceMetadataUpdatedEvent\n  | QualityLevelChangedEvent\n  | InitializationCompleteEvent\n  | ImportCompleteEvent;\n\nexport type RegistryEventType =\n  | 'resourceRegistered'\n  | 'resourceUnregistered'\n  | 'conversionRateChanged'\n  | 'tagAdded'\n  | 'tagRemoved'\n  | 'resourceMetadataUpdated'\n  | 'qualityLevelChanged'\n  | 'initializationComplete'\n  | 'importComplete';\n\n/**\n * Resource Registry Event interface for use with EventEmitter\n */\nexport interface ResourceRegistryEvent {\n  type: RegistryEventType;\n  data: RegistryEventData;\n  timestamp: number;\n}\n\n/**\n * Resource Registry class\n *\n * Provides a centralized registry for resource types and metadata?.\n * Implements the Singleton pattern to ensure only one instance exists.\n */\nexport class ResourceRegistry {\n  // Singleton instance\n  private static _instance: ResourceRegistry | null = null;\n\n  // Resource metadata storage\n  private resourceMetadata: Map<ResourceType, ExtendedResourceMetadata> = new Map();\n\n  // Resource category mappings\n  private resourcesByCategory: Map<ResourceCategory, Set<ResourceType>> = new Map();\n\n  // Resource tag mappings\n  private resourcesByTag: Map<string, Set<ResourceType>> = new Map();\n\n  // Resource quality mappings\n  private resourcesByQuality: Map<ResourceQuality, Map<ResourceType, number>> = new Map();\n\n  // Resource conversion mappings\n  private conversionRates: Map<ResourceType, Map<ResourceType, number>> = new Map();\n\n  // Event listeners\n  private listeners: Map<RegistryEventType, Set<(data: RegistryEventData) => void>> = new Map();\n\n  // Event emitter for typed events\n  private eventEmitter: EventEmitter<ResourceRegistryEvent>;\n\n  /**\n   * Get the singleton instance of ResourceRegistry\n   */\n  public static getInstance(): ResourceRegistry {\n    if (!ResourceRegistry._instance) {\n      ResourceRegistry._instance = new ResourceRegistry();\n    }\n    return ResourceRegistry._instance;\n  }\n\n  /**\n   * Private constructor to enforce singleton pattern\n   */\n  private constructor() {\n    this.eventEmitter = new EventEmitter<ResourceRegistryEvent>();\n    this.initializeRegistry();\n  }\n\n  /**\n   * Initialize the registry with default resources\n   */\n  private initializeRegistry(): void {\n    // Initialize category maps\n    Object.values(ResourceCategory).forEach(category => {\n      this.resourcesByCategory.set(category, new Set());\n    });\n\n    // Initialize quality maps\n    Object.values(ResourceQuality).forEach(quality => {\n      this.resourcesByQuality.set(quality, new Map());\n    });\n\n    // Register built-in resources from StandardizedResourceTypes\n    this.registerBuiltInResources();\n  }\n\n  /**\n   * Register built-in resources from StandardizedResourceTypes\n   */\n  private registerBuiltInResources(): void {\n    // Register each resource type with extended metadata\n    // This would normally come from a configuration file or database\n    // For now, we'll hardcode some example values\n\n    // Example for MINERALS\n    this.registerResource({\n      metadata: {\n        id: ResourceType.MINERALS,\n        displayName: 'Minerals',\n        description: 'Basic building materials',\n        icon: 'minerals-icon',\n        category: ResourceCategory.BASIC,\n        defaultMax: 1000,\n        baseValue: 1.0,\n        weight: 1.0,\n        storageEfficiency: 0.9,\n        qualityLevels: {\n          [ResourceQuality.LOW]: 0.8,\n          [ResourceQuality.MEDIUM]: 1.0,\n          [ResourceQuality.HIGH]: 1.2,\n          [ResourceQuality.PREMIUM]: 1.5,\n        },\n        tags: ['basic', 'construction', 'mining'],\n        relatedResources: [ResourceType.IRON, ResourceType.COPPER, ResourceType.TITANIUM],\n        storageMultiplier: 1.0,\n        valueMultiplier: 1.0,\n        isRare: false,\n        isStackable: true,\n        maxStackSize: 100,\n      },\n    });\n\n    // Example for ENERGY\n    this.registerResource({\n      metadata: {\n        id: ResourceType.ENERGY,\n        displayName: 'Energy',\n        description: 'Power for modules and systems',\n        icon: 'energy-icon',\n        category: ResourceCategory.BASIC,\n        defaultMax: 1000,\n        baseValue: 1.2,\n        weight: 0.0,\n        storageEfficiency: 0.7,\n        qualityLevels: {\n          [ResourceQuality.LOW]: 0.7,\n          [ResourceQuality.MEDIUM]: 1.0,\n          [ResourceQuality.HIGH]: 1.3,\n          [ResourceQuality.PREMIUM]: 1.6,\n        },\n        tags: ['basic', 'power', 'production'],\n        relatedResources: [ResourceType.PLASMA],\n        conversionRates: {\n          [ResourceType.PLASMA]: 0.5,\n        },\n        storageMultiplier: 1.0,\n        valueMultiplier: 1.0,\n        isRare: false,\n        isStackable: true,\n        maxStackSize: 100,\n      },\n    });\n\n    // Additional resources would be registered here\n    // ...\n  }\n\n  /**\n   * Register a resource with the registry\n   *\n   * @param options Registration options including metadata\n   * @returns True if registration was successful, false otherwise\n   */\n  public registerResource(options: ResourceRegistrationOptions): boolean {\n    const { metadata, overrideExisting = false } = options;\n    const { id, category, tags, qualityLevels, relatedResources, conversionRates } = metadata;\n\n    // Check if resource already exists\n    if (this.resourceMetadata?.has(id) && !overrideExisting) {\n      console.warn(`Resource ${id} already registered. Use overrideExisting=true to replace.`);\n      return false;\n    }\n\n    // Register metadata\n    this.resourceMetadata?.set(id, metadata);\n\n    // Register category\n    const categorySet = this.resourcesByCategory.get(category) || new Set();\n    categorySet.add(id);\n    this.resourcesByCategory.set(category, categorySet);\n\n    // Register tags\n    tags.forEach(tag => {\n      const tagSet = this.resourcesByTag.get(tag) || new Set();\n      tagSet.add(id);\n      this.resourcesByTag.set(tag, tagSet);\n    });\n\n    // Register quality levels\n    Object.entries(qualityLevels).forEach(([quality, value]) => {\n      const qualityMap = this.resourcesByQuality.get(quality as ResourceQuality) || new Map();\n      qualityMap.set(id, value);\n      this.resourcesByQuality.set(quality as ResourceQuality, qualityMap);\n    });\n\n    // Register conversion rates\n    if (conversionRates) {\n      const rateMap = new Map<ResourceType, number>();\n      Object.entries(conversionRates).forEach(([targetType, rate]) => {\n        rateMap.set(targetType as ResourceType, rate);\n      });\n      this.conversionRates.set(id, rateMap);\n    }\n\n    // Emit resource registered event\n    this.emit('resourceRegistered', { resourceType: id, metadata });\n\n    return true;\n  }\n\n  /**\n   * Unregister a resource from the registry\n   *\n   * @param resourceType The resource type to unregister\n   * @returns True if unregistration was successful, false otherwise\n   */\n  public unregisterResource(resourceType: ResourceType): boolean {\n    if (!this.resourceMetadata?.has(resourceType)) {\n      return false;\n    }\n\n    const metadata = this.resourceMetadata?.get(resourceType);\n\n    // Remove from metadata\n    this.resourceMetadata?.delete(resourceType);\n\n    // Remove from category\n    const categorySet = this.resourcesByCategory.get(metadata?.category as ResourceCategory);\n    if (categorySet) {\n      categorySet.delete(resourceType);\n    }\n\n    // Remove from tags\n    metadata?.tags.forEach(tag => {\n      const tagSet = this.resourcesByTag.get(tag);\n      if (tagSet) {\n        tagSet.delete(resourceType);\n        if (tagSet.size === 0) {\n          this.resourcesByTag.delete(tag);\n        }\n      }\n    });\n\n    // Remove from quality levels\n    Object.keys(metadata?.qualityLevels ?? {}).forEach(quality => {\n      const qualityMap = this.resourcesByQuality.get(quality as ResourceQuality);\n      if (qualityMap) {\n        qualityMap.delete(resourceType);\n      }\n    });\n\n    // Remove from conversion rates\n    this.conversionRates.delete(resourceType);\n\n    // Emit resource unregistered event\n    this.emit('resourceUnregistered', { resourceType });\n\n    return true;\n  }\n\n  /**\n   * Get resource metadata\n   *\n   * @param resourceType The resource type\n   * @returns The resource metadata or undefined if not found\n   */\n  public getResourceMetadata(resourceType: ResourceType): ExtendedResourceMetadata | undefined {\n    return this.resourceMetadata?.get(resourceType);\n  }\n\n  /**\n   * Get all registered resource types\n   *\n   * @returns Array of all registered resource types\n   */\n  public getAllResourceTypes(): ResourceType[] {\n    return Array.from(this.resourceMetadata?.keys());\n  }\n\n  /**\n   * Get resources by category\n   *\n   * @param category The resource category\n   * @returns Array of resource types in the category\n   */\n  public getResourcesByCategory(category: ResourceCategory): ResourceType[] {\n    const categorySet = this.resourcesByCategory.get(category);\n    return categorySet ? Array.from(categorySet) : [];\n  }\n\n  /**\n   * Get resources by tag\n   *\n   * @param tag The resource tag\n   * @returns Array of resource types with the tag\n   */\n  public getResourcesByTag(tag: string): ResourceType[] {\n    const tagSet = this.resourcesByTag.get(tag);\n    return tagSet ? Array.from(tagSet) : [];\n  }\n\n  /**\n   * Get resources by quality level\n   *\n   * @param quality The resource quality level\n   * @returns Map of resource types to quality values\n   */\n  public getResourcesByQuality(quality: ResourceQuality): Map<ResourceType, number> {\n    return this.resourcesByQuality.get(quality) || new Map();\n  }\n\n  /**\n   * Get conversion rate between resources\n   *\n   * @param sourceType Source resource type\n   * @param targetType Target resource type\n   * @returns Conversion rate or undefined if not found\n   */\n  public getConversionRate(sourceType: ResourceType, targetType: ResourceType): number | undefined {\n    const rateMap = this.conversionRates.get(sourceType);\n    return rateMap ? rateMap.get(targetType) : undefined;\n  }\n\n  /**\n   * Set conversion rate between resources\n   *\n   * @param sourceType Source resource type\n   * @param targetType Target resource type\n   * @param rate Conversion rate\n   */\n  public setConversionRate(sourceType: ResourceType, targetType: ResourceType, rate: number): void {\n    let rateMap = this.conversionRates.get(sourceType);\n    if (!rateMap) {\n      rateMap = new Map();\n      this.conversionRates.set(sourceType, rateMap);\n    }\n    rateMap.set(targetType, rate);\n\n    // Update metadata\n    const metadata = this.resourceMetadata?.get(sourceType);\n    if (metadata) {\n      if (!metadata?.conversionRates) {\n        metadata.conversionRates = {};\n      }\n      metadata.conversionRates[targetType] = rate;\n    }\n\n    // Emit conversion rate changed event\n    this.emit('conversionRateChanged', { sourceType, targetType, rate });\n  }\n\n  /**\n   * Get all possible conversion rates for a resource\n   *\n   * @param resourceType The resource type\n   * @returns Map of target resource types to conversion rates\n   */\n  public getAllConversionRates(resourceType: ResourceType): Map<ResourceType, number> {\n    return this.conversionRates.get(resourceType) || new Map();\n  }\n\n  /**\n   * Find resources that can be converted to the specified resource\n   *\n   * @param targetType Target resource type\n   * @returns Map of source resource types to conversion rates\n   */\n  public findConversionSources(targetType: ResourceType): Map<ResourceType, number> {\n    const sources = new Map<ResourceType, number>();\n\n    this.conversionRates.forEach((rateMap, sourceType) => {\n      const rate = rateMap.get(targetType);\n      if (rate !== undefined) {\n        sources.set(sourceType, rate);\n      }\n    });\n\n    return sources;\n  }\n\n  /**\n   * Subscribe to registry events using the EventEmitter\n   *\n   * @param eventType Event type\n   * @param callback Callback function\n   * @returns Unsubscribe function\n   */\n  public subscribe(\n    eventType: RegistryEventType,\n    callback: (data: RegistryEventData) => void\n  ): () => void {\n    return this.eventEmitter.subscribe(\n      event => event?.type === eventType,\n      event => callback(event?.data)\n    );\n  }\n\n  /**\n   * Emit an event to all subscribers using the EventEmitter\n   *\n   * @param eventType Event type\n   * @param data Event data\n   */\n  private emit(eventType: RegistryEventType, data: RegistryEventData): void {\n    this.eventEmitter.emit({\n      type: eventType,\n      data,\n      timestamp: Date.now(),\n    });\n  }\n\n  /**\n   * Get display name for a resource type\n   *\n   * @param resourceType The resource type\n   * @returns The display name or the resource type string if not found\n   */\n  public getDisplayName(resourceType: ResourceType): ResourceType {\n    const metadata = this.resourceMetadata?.get(resourceType);\n    return metadata ? (metadata?.displayName as ResourceType) : resourceType;\n  }\n\n  /**\n   * Get icon for a resource type\n   *\n   * @param resourceType The resource type\n   * @returns The icon or undefined if not found\n   */\n  public getIcon(resourceType: ResourceType): string | undefined {\n    const metadata = this.resourceMetadata?.get(resourceType);\n    return metadata ? metadata?.icon : undefined;\n  }\n\n  /**\n   * Get related resources for a resource type\n   *\n   * @param resourceType The resource type\n   * @returns Array of related resource types\n   */\n  public getRelatedResources(resourceType: ResourceType): ResourceType[] {\n    const metadata = this.resourceMetadata?.get(resourceType);\n    return metadata ? metadata?.relatedResources : [];\n  }\n\n  /**\n   * Check if a resource has a specific tag\n   *\n   * @param resourceType The resource type\n   * @param tag The tag to check\n   * @returns True if the resource has the tag, false otherwise\n   */\n  public hasTag(resourceType: ResourceType, tag: string): boolean {\n    const metadata = this.resourceMetadata?.get(resourceType);\n    return metadata ? metadata?.tags.includes(tag) : false;\n  }\n\n  /**\n   * Get all tags for a resource\n   *\n   * @param resourceType The resource type\n   * @returns Array of tags\n   */\n  public getTags(resourceType: ResourceType): ResourceType[] {\n    const metadata = this.resourceMetadata?.get(resourceType);\n    return metadata ? (metadata?.tags as ResourceType[]) : [];\n  }\n\n  /**\n   * Add a tag to a resource\n   *\n   * @param resourceType The resource type\n   * @param tag The tag to add\n   * @returns True if the tag was added, false otherwise\n   */\n  public addTag(resourceType: ResourceType, tag: string): boolean {\n    const metadata = this.resourceMetadata?.get(resourceType);\n    if (!metadata) {\n      return false;\n    }\n\n    if (!metadata?.tags.includes(tag)) {\n      metadata?.tags.push(tag);\n\n      // Update tag mapping\n      const tagSet = this.resourcesByTag.get(tag) || new Set();\n      tagSet.add(resourceType);\n      this.resourcesByTag.set(tag, tagSet);\n\n      // Emit tag added event\n      this.emit('tagAdded', { resourceType, tag });\n\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Remove a tag from a resource\n   *\n   * @param resourceType The resource type\n   * @param tag The tag to remove\n   * @returns True if the tag was removed, false otherwise\n   */\n  public removeTag(resourceType: ResourceType, tag: string): boolean {\n    const metadata = this.resourceMetadata?.get(resourceType);\n    if (!metadata) {\n      return false;\n    }\n\n    const index = metadata?.tags.indexOf(tag);\n    if (index !== -1) {\n      metadata?.tags.splice(index, 1);\n\n      // Update tag mapping\n      const tagSet = this.resourcesByTag.get(tag);\n      if (tagSet) {\n        tagSet.delete(resourceType);\n        if (tagSet.size === 0) {\n          this.resourcesByTag.delete(tag);\n        }\n      }\n\n      // Emit tag removed event\n      this.emit('tagRemoved', { resourceType, tag });\n\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Update resource metadata\n   *\n   * @param resourceType The resource type\n   * @param updates Partial metadata updates\n   * @returns True if the update was successful, false otherwise\n   */\n  public updateResourceMetadata(\n    resourceType: ResourceType,\n    updates: Partial<ExtendedResourceMetadata>\n  ): boolean {\n    const metadata = this.resourceMetadata?.get(resourceType);\n    if (!metadata) {\n      return false;\n    }\n\n    // Apply updates\n    Object.assign(metadata, updates);\n\n    // Update category if changed\n    if (updates.category && updates.category !== metadata?.category) {\n      // Remove from old category\n      const oldCategorySet = this.resourcesByCategory.get(metadata?.category);\n      if (oldCategorySet) {\n        oldCategorySet.delete(resourceType);\n      }\n\n      // Add to new category\n      const newCategorySet = this.resourcesByCategory.get(updates.category) || new Set();\n      newCategorySet.add(resourceType);\n      this.resourcesByCategory.set(updates.category, newCategorySet);\n    }\n\n    // Emit metadata updated event\n    this.emit('resourceMetadataUpdated', { resourceType, updates });\n\n    return true;\n  }\n\n  /**\n   * Get quality level for a resource\n   *\n   * @param resourceType The resource type\n   * @param quality The quality level\n   * @returns The quality value or undefined if not found\n   */\n  public getQualityLevel(resourceType: ResourceType, quality: ResourceQuality): number | undefined {\n    const metadata = this.resourceMetadata?.get(resourceType);\n    return metadata ? metadata?.qualityLevels[quality] : undefined;\n  }\n\n  /**\n   * Set quality level for a resource\n   *\n   * @param resourceType The resource type\n   * @param quality The quality level\n   * @param value The quality value\n   * @returns True if the quality level was set, false otherwise\n   */\n  public setQualityLevel(\n    resourceType: ResourceType,\n    quality: ResourceQuality,\n    value: number\n  ): boolean {\n    const metadata = this.resourceMetadata?.get(resourceType);\n    if (!metadata) {\n      return false;\n    }\n\n    metadata.qualityLevels[quality] = value;\n\n    // Update quality mapping\n    const qualityMap = this.resourcesByQuality.get(quality) || new Map();\n    qualityMap.set(resourceType, value);\n    this.resourcesByQuality.set(quality, qualityMap);\n\n    // Emit quality level changed event\n    this.emit('qualityLevelChanged', { resourceType, quality, value });\n\n    return true;\n  }\n\n  /**\n   * Get all quality levels for a resource\n   *\n   * @param resourceType The resource type\n   * @returns Record of quality levels or empty object if not found\n   */\n  public getAllQualityLevels(resourceType: ResourceType): Record<ResourceQuality, number> {\n    const metadata = this.resourceMetadata?.get(resourceType);\n    return metadata ? metadata?.qualityLevels : ({} as Record<ResourceQuality, number>);\n  }\n\n  /**\n   * Initialize the registry from async data source\n   * This method can be used to load resource data from an API or database\n   *\n   * @param dataSource Function that returns a promise with resource data\n   * @returns Promise that resolves when initialization is complete\n   */\n  public async initializeFromDataSource(\n    dataSource: () => Promise<ResourceRegistrationOptions[]>\n  ): Promise<void> {\n    try {\n      const resources = await dataSource();\n\n      // Clear existing resources\n      this.resourceMetadata?.clear();\n      this.resourcesByCategory.clear();\n      this.resourcesByTag.clear();\n      this.resourcesByQuality.clear();\n      this.conversionRates.clear();\n\n      // Initialize category maps\n      Object.values(ResourceCategory).forEach(category => {\n        this.resourcesByCategory.set(category, new Set());\n      });\n\n      // Initialize quality maps\n      Object.values(ResourceQuality).forEach(quality => {\n        this.resourcesByQuality.set(quality, new Map());\n      });\n\n      // Register resources\n      resources.forEach(resource => {\n        this.registerResource(resource);\n      });\n\n      // Emit initialization complete event\n      this.emit('initializationComplete', { resourceCount: resources.length });\n    } catch (error) {\n      console.error('Error initializing resource registry:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Export registry data\n   * This method can be used to save resource data to a file or database\n   *\n   * @returns Object containing all registry data\n   */\n  public exportRegistryData(): {\n    resources: Record<string, ExtendedResourceMetadata>;\n    conversionRates: Record<string, Record<string, number>>;\n  } {\n    const resources: Record<string, ExtendedResourceMetadata> = {};\n    const conversionRates: Record<string, Record<string, number>> = {};\n\n    // Export resources\n    this.resourceMetadata?.forEach((metadata, resourceType) => {\n      resources[resourceType] = { ...metadata };\n    });\n\n    // Export conversion rates\n    this.conversionRates.forEach((rateMap, sourceType) => {\n      conversionRates[sourceType] = {};\n      rateMap.forEach((rate, targetType) => {\n        conversionRates[sourceType][targetType] = rate;\n      });\n    });\n\n    return { resources, conversionRates };\n  }\n\n  /**\n   * Import registry data\n   * This method can be used to load resource data from a file or database\n   *\n   * @param data Object containing registry data\n   * @returns True if import was successful, false otherwise\n   */\n  public importRegistryData(data: {\n    resources: Record<string, ExtendedResourceMetadata>;\n    conversionRates: Record<string, Record<string, number>>;\n  }): boolean {\n    try {\n      // Clear existing data\n      this.resourceMetadata?.clear();\n      this.resourcesByCategory.clear();\n      this.resourcesByTag.clear();\n      this.resourcesByQuality.clear();\n      this.conversionRates.clear();\n\n      // Initialize category maps\n      Object.values(ResourceCategory).forEach(category => {\n        this.resourcesByCategory.set(category, new Set());\n      });\n\n      // Initialize quality maps\n      Object.values(ResourceQuality).forEach(quality => {\n        this.resourcesByQuality.set(quality, new Map());\n      });\n\n      // Import resources\n      Object.entries(data?.resources).forEach(([resourceType, metadata]) => {\n        this.registerResource({\n          metadata: metadata as ExtendedResourceMetadata,\n          overrideExisting: true,\n        });\n      });\n\n      // Import conversion rates\n      Object.entries(data?.conversionRates).forEach(([sourceType, rates]) => {\n        Object.entries(rates).forEach(([targetType, rate]) => {\n          this.setConversionRate(sourceType as ResourceType, targetType as ResourceType, rate);\n        });\n      });\n\n      // Emit import complete event\n      this.emit('importComplete', {\n        resourceCount: Object.keys(data?.resources).length,\n        conversionRateCount: Object.keys(data?.conversionRates).length,\n      });\n\n      return true;\n    } catch (error) {\n      console.error('Error importing registry data:', error);\n      return false;\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/registry/ResourceRegistryIntegration.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'resourceFlowManager' is defined but never used.","line":78,"column":35,"nodeType":null,"messageId":"unusedVar","endLine":78,"endColumn":54},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'resourceFlowManager' is defined but never used.","line":104,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":104,"endColumn":51},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'resourceFlowManager' is defined but never used.","line":131,"column":44,"nodeType":null,"messageId":"unusedVar","endLine":131,"endColumn":63}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * ResourceRegistryIntegration.ts\n *\n * Integration between ResourceRegistry and ResourceFlowManager to standardize\n * resource type handling throughout the application.\n */\n\nimport { ResourceType } from '../types/resources/ResourceTypes';\nimport { ResourceTypeConverter } from '../utils/ResourceTypeConverter';\nimport { RegistryEventData, ResourceRegistry } from './ResourceRegistry';\n\n// Forward declaration of ResourceFlowManager to avoid circular dependencies\ninterface ResourceFlowManager {\n  // Add minimal interface needed for this integration\n  getAllResourceStates?: () => Map<string, { available: number }>;\n  getAllConversionRecipes?: () => Array<{\n    input: { type: string; amount: number };\n    output: { type: string; amount: number };\n  }>;\n  setConversionRate?: (sourceType: string, targetType: string, rate: number) => void;\n}\n\n/**\n * ResourceRegistryIntegration class\n *\n * Provides integration methods between ResourceRegistry and other resource-related systems.\n * This class serves as a bridge to help transition from string-based resource types to enum-based types.\n */\nexport class ResourceRegistryIntegration {\n  private static _instance: ResourceRegistryIntegration | null = null;\n  private registry: ResourceRegistry;\n\n  /**\n   * Get the singleton instance of ResourceRegistryIntegration\n   */\n  public static getInstance(): ResourceRegistryIntegration {\n    if (!ResourceRegistryIntegration._instance) {\n      ResourceRegistryIntegration._instance = new ResourceRegistryIntegration();\n    }\n    return ResourceRegistryIntegration._instance;\n  }\n\n  /**\n   * Private constructor to enforce singleton pattern\n   */\n  private constructor() {\n    this.registry = ResourceRegistry.getInstance();\n    this.initializeIntegration();\n  }\n\n  /**\n   * Initialize the integration\n   */\n  private initializeIntegration(): void {\n    // Subscribe to registry events to sync with other systems\n    this.registry.subscribe('resourceRegistered', (data: RegistryEventData) => {\n      if ('resourceType' in data && 'metadata' in data) {\n        console.warn(`Resource registered: ${data?.resourceType}`);\n        // Here you would notify other systems about the new resource\n      }\n    });\n\n    this.registry.subscribe('conversionRateChanged', (data: RegistryEventData) => {\n      if ('sourceType' in data && 'targetType' in data && 'rate' in data) {\n        console.warn(\n          `Conversion rate changed: ${data?.sourceType} -> ${data?.targetType} = ${data?.rate}`\n        );\n        // Here you would update conversion rates in other systems\n      }\n    });\n  }\n\n  /**\n   * Get resource availability from ResourceFlowManager and register with ResourceRegistry\n   *\n   * @param resourceFlowManager The ResourceFlowManager instance\n   */\n  public syncResourceAvailability(resourceFlowManager: ResourceFlowManager): void {\n    // This is a placeholder for actual integration code\n    // In a real implementation, you would:\n    // 1. Get all resource states from ResourceFlowManager\n    // 2. Update the ResourceRegistry with the current availability\n    // Example (pseudo-code):\n    // const resourceStates = resourceFlowManager.getAllResourceStates();\n    // resourceStates.forEach((state, resourceType) => {\n    //   const standardizedType = ResourceTypeConverter.stringToEnum(resourceType);\n    //   if (standardizedType) {\n    //     // Update registry with availability information\n    //     const metadata = this.registry.getResourceMetadata(standardizedType);\n    //     if (metadata) {\n    //       this.registry.updateResourceMetadata(standardizedType, {\n    //         currentAvailability: state.available\n    //       });\n    //     }\n    //   }\n    // });\n  }\n\n  /**\n   * Register conversion recipes from ResourceFlowManager with ResourceRegistry\n   *\n   * @param resourceFlowManager The ResourceFlowManager instance\n   */\n  public syncConversionRecipes(resourceFlowManager: ResourceFlowManager): void {\n    // This is a placeholder for actual integration code\n    // In a real implementation, you would:\n    // 1. Get all conversion recipes from ResourceFlowManager\n    // 2. Register them with the ResourceRegistry\n    // Example (pseudo-code):\n    // const recipes = resourceFlowManager.getAllConversionRecipes();\n    // recipes.forEach(recipe => {\n    //   const inputType = ResourceTypeConverter.stringToEnum(recipe.input.type);\n    //   const outputType = ResourceTypeConverter.stringToEnum(recipe.output.type);\n    //\n    //   if (inputType && outputType) {\n    //     this.registry.setConversionRate(\n    //       inputType,\n    //       outputType,\n    //       recipe.output.amount / recipe.input.amount\n    //     );\n    //   }\n    // });\n  }\n\n  // TODO: Implement this placeholder function\n  /**\n   * Get conversion rates from ResourceRegistry and update ResourceFlowManager\n   *\n   * @param resourceFlowManager The ResourceFlowManager instance\n   */\n  public applyConversionRatesToFlowManager(resourceFlowManager: ResourceFlowManager): void {\n    // This is a placeholder for actual integration code\n    // In a real implementation, you would:\n    // 1. Get all conversion rates from ResourceRegistry\n    // 2. Apply them to ResourceFlowManager\n    // Example (pseudo-code):\n    // const resourceTypes = this.registry.getAllResourceTypes();\n    //\n    // resourceTypes.forEach(sourceType => {\n    //   const conversionRates = this.registry.getAllConversionRates(sourceType);\n    //\n    //   conversionRates.forEach((rate, targetType) => {\n    //     const stringSourceType = ResourceTypeConverter.enumToString(sourceType);\n    //     const stringTargetType = ResourceTypeConverter.enumToString(targetType);\n    //\n    //     if (stringSourceType && stringTargetType) {\n    //       resourceFlowManager.setConversionRate(\n    //         stringSourceType,\n    //         stringTargetType,\n    //         rate\n    //       );\n    //     }\n    //   });\n    // });\n  }\n\n  /**\n   * Get resource metadata from ResourceRegistry\n   *\n   * @param resourceType The resource type (string or enum)\n   * @returns The resource metadata or undefined if not found\n   */\n  public getResourceMetadata(resourceType: ResourceType | string): unknown {\n    if (typeof resourceType === 'string') {\n      const enumType = ResourceTypeConverter.stringToEnum(resourceType);\n      if (!enumType) {\n        return undefined;\n      }\n      return this.registry.getResourceMetadata(enumType);\n    }\n\n    return this.registry.getResourceMetadata(resourceType);\n  }\n\n  /**\n   * Get display name for a resource type\n   *\n   * @param resourceType The resource type (string or enum)\n   * @returns The display name or the resource type string if not found\n   */\n  public getDisplayName(resourceType: ResourceType | string): ResourceType {\n    if (typeof resourceType === 'string') {\n      const enumType = ResourceTypeConverter.stringToEnum(resourceType);\n      if (!enumType) {\n        return resourceType as ResourceType;\n      }\n      return this.registry.getDisplayName(enumType);\n    }\n\n    return this.registry.getDisplayName(resourceType);\n  }\n\n  /**\n   * Get icon for a resource type\n   *\n   * @param resourceType The resource type (string or enum)\n   * @returns The icon or undefined if not found\n   */\n  public getIcon(resourceType: ResourceType | string): string | undefined {\n    if (typeof resourceType === 'string') {\n      const enumType = ResourceTypeConverter.stringToEnum(resourceType);\n      if (!enumType) {\n        return undefined;\n      }\n      return this.registry.getIcon(enumType);\n    }\n\n    return this.registry.getIcon(resourceType);\n  }\n\n  /**\n   * Check if a resource is of a specific category\n   *\n   * @param resourceType The resource type (string or enum)\n   * @param category The category to check\n   * @returns True if the resource is of the category, false otherwise\n   */\n  public isResourceOfCategory(resourceType: ResourceType | string, category: string): boolean {\n    let enumType: ResourceType | undefined;\n\n    if (typeof resourceType === 'string') {\n      enumType = ResourceTypeConverter.stringToEnum(resourceType);\n      if (!enumType) {\n        return false;\n      }\n    } else {\n      enumType = resourceType;\n    }\n\n    const metadata = this.registry.getResourceMetadata(enumType);\n    return metadata ? metadata?.category === category : false;\n  }\n\n  /**\n   * Check if a resource has a specific tag\n   *\n   * @param resourceType The resource type (string or enum)\n   * @param tag The tag to check\n   * @returns True if the resource has the tag, false otherwise\n   */\n  public hasTag(resourceType: ResourceType | string, tag: string): boolean {\n    let enumType: ResourceType | undefined;\n\n    if (typeof resourceType === 'string') {\n      enumType = ResourceTypeConverter.stringToEnum(resourceType);\n      if (!enumType) {\n        return false;\n      }\n    } else {\n      enumType = resourceType;\n    }\n\n    return this.registry.hasTag(enumType, tag);\n  }\n\n  /**\n   * Get all resources with a specific tag\n   *\n   * @param tag The tag to filter by\n   * @returns Array of resource types with the tag\n   */\n  public getResourcesByTag(tag: string): ResourceType[] {\n    return this.registry.getResourcesByTag(tag);\n  }\n\n  /**\n   * Get all resources that can be converted to a specific resource\n   *\n   * @param targetType The target resource type (string or enum)\n   * @returns Array of resource types that can be converted to the target\n   */\n  public getConversionSources(targetType: ResourceType | string): ResourceType[] {\n    let enumType: ResourceType | undefined;\n\n    if (typeof targetType === 'string') {\n      enumType = ResourceTypeConverter.stringToEnum(targetType);\n      if (!enumType) {\n        return [];\n      }\n    } else {\n      enumType = targetType;\n    }\n\n    const sources = this.registry.findConversionSources(enumType);\n    return Array.from(sources.keys());\n  }\n\n  /**\n   * Get conversion rate between resources\n   *\n   * @param sourceType Source resource type (string or enum)\n   * @param targetType Target resource type (string or enum)\n   * @returns Conversion rate or undefined if not found\n   */\n  public getConversionRate(\n    sourceType: ResourceType | string,\n    targetType: ResourceType | string\n  ): number | undefined {\n    let enumSourceType: ResourceType | undefined;\n    let enumTargetType: ResourceType | undefined;\n\n    if (typeof sourceType === 'string') {\n      enumSourceType = ResourceTypeConverter.stringToEnum(sourceType);\n      if (!enumSourceType) {\n        return undefined;\n      }\n    } else {\n      enumSourceType = sourceType;\n    }\n\n    if (typeof targetType === 'string') {\n      enumTargetType = ResourceTypeConverter.stringToEnum(targetType);\n      if (!enumTargetType) {\n        return undefined;\n      }\n    } else {\n      enumTargetType = targetType;\n    }\n\n    return this.registry.getConversionRate(enumSourceType, enumTargetType);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/resource/ResourceSystem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/resource/subsystems/ResourceFlowSubsystem.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_activeConnections' is defined but never used.","line":758,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":758,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { eventSystem } from '../../lib/events/UnifiedEventSystem';\nimport { EventType } from '../../types/events/EventTypes';\nimport {\n  ResourceState,\n  ResourceTransfer,\n  ResourceType as StringResourceType,\n} from '../../types/resources/ResourceTypes';\nimport {\n  FlowNode as StandardizedFlowNode,\n  FlowNodeType as StandardizedFlowNodeType,\n} from '../../types/resources/StandardizedResourceTypes';\nimport {\n  isStringResourceType,\n  toStringResourceType,\n} from '../../utils/resources/ResourceTypeConverter';\nimport { validateResourceTransfer } from '../../utils/resources/resourceValidation';\nimport { ResourceFlowWorkerUtil } from '../../utils/workers/ResourceFlowWorkerUtil';\nimport { ResourceSystem, ResourceSystemConfig } from '../ResourceSystem';\nimport { ResourceType } from './../../types/resources/ResourceTypes';\n\n/**\n * Flow node types\n */\nexport type FlowNodeType = 'producer' | 'consumer' | 'storage' | 'converter';\n\n/**\n * Flow priority configuration\n */\nexport interface FlowPriority {\n  type: StringResourceType;\n  priority: number;\n  consumers: string[];\n}\n\n/**\n * Flow node\n */\nexport interface FlowNode {\n  id: string;\n  type: FlowNodeType;\n  resources: StringResourceType[];\n  priority: FlowPriority;\n  active: boolean;\n  efficiency?: number;\n  converterConfig?: Record<string, unknown>; // Configuration for converters\n  converterStatus?: Record<string, unknown>; // Status information for converters\n  config?: Record<string, unknown>; // Generic config for additional properties\n}\n\n/**\n * Flow connection\n */\nexport interface FlowConnection {\n  id: string;\n  source: string;\n  target: string;\n  resourceType: StringResourceType;\n  maxRate: number;\n  currentRate: number;\n  priority: FlowPriority;\n  active: boolean;\n}\n\n/**\n * Resource flow\n */\nexport interface ResourceFlow {\n  source: string;\n  target: string;\n  resourceType: StringResourceType;\n  maxRate: number;\n}\n\n/**\n * Flow optimization result\n */\nexport interface FlowOptimizationResult {\n  transfers: ResourceTransfer[];\n  updatedConnections: FlowConnection[];\n  bottlenecks: string[];\n  underutilized: string[];\n  performanceMetrics?: {\n    executionTimeMs: number;\n    nodesProcessed: number;\n    connectionsProcessed: number;\n    transfersGenerated: number;\n  };\n}\n\n/**\n * Interface for worker connection results\n */\ninterface WorkerConnectionResult {\n  id: string;\n  source: string;\n  target: string;\n  resourceType?: StringResourceType;\n  resourceTypes?: StringResourceType[];\n  maxRate?: number;\n  currentRate?: number;\n  priority?: number | { priority: number };\n  active?: boolean;\n}\n\ninterface WorkerOptimizationResult {\n  transfers: ResourceTransfer[];\n  updatedConnections: WorkerConnectionResult[];\n  bottlenecks: string[];\n  underutilized: string[];\n  performanceMetrics?: {\n    executionTimeMs: number;\n    nodesProcessed: number;\n    connectionsProcessed: number;\n    transfersGenerated: number;\n  };\n}\n\n/**\n * ResourceFlowSubsystem\n *\n * Manages resource flow through the game systems\n * Responsible for:\n * - Tracking resource nodes (producers, consumers, storage, converters)\n * - Managing connections between nodes\n * - Optimizing resource distribution\n * - Processing resource conversions\n */\nexport class ResourceFlowSubsystem {\n  // Flow network data structures\n  private nodes: Map<string, FlowNode> = new Map();\n  private connections: Map<string, FlowConnection> = new Map();\n  private sourceConnections: Map<string, string[]> = new Map();\n  private targetConnections: Map<string, string[]> = new Map();\n\n  // Type-specific node registries\n  private producerNodes: Map<string, FlowNode> = new Map();\n  private consumerNodes: Map<string, FlowNode> = new Map();\n  private storageNodes: Map<string, FlowNode> = new Map();\n  private converterNodes: Map<string, FlowNode> = new Map();\n\n  // Resource tracking\n  private resourceStates: Map<StringResourceType, ResourceState> = new Map();\n  private resourceProducers: Map<StringResourceType, string[]> = new Map();\n  private resourceConsumers: Map<StringResourceType, string[]> = new Map();\n  private resourceStorage: Map<StringResourceType, string[]> = new Map();\n\n  // Processing state\n  private transferHistory: ResourceTransfer[] = [];\n  private lastOptimizationTime = 0;\n  private isOptimizing = false;\n  private lastOptimizationResult: FlowOptimizationResult | null = null;\n\n  // Worker utility\n  private workerUtil: ResourceFlowWorkerUtil | null = null;\n\n  // Parent system reference\n  private parentSystem: ResourceSystem;\n  private config: ResourceSystemConfig;\n  private isInitialized = false;\n\n  constructor(parentSystem: ResourceSystem, config: ResourceSystemConfig) {\n    this.parentSystem = parentSystem;\n    this.config = config;\n\n    // Initialize resource states\n    this.initializeResourceStates();\n\n    // Initialize Web Worker utility if enabled\n    if (this.config.useWorkerOffloading) {\n      try {\n        this.workerUtil = new ResourceFlowWorkerUtil();\n      } catch (error) {\n        console.error('Failed to initialize ResourceFlowWorkerUtil:', error);\n      }\n    }\n  }\n\n  /**\n   * Initialize the subsystem\n   */\n  public async initialize(): Promise<void> {\n    if (this.isInitialized) {\n      return;\n    }\n\n    try {\n      // Subscribe to relevant events\n      this.initializeEventSubscriptions();\n\n      this.isInitialized = true;\n    } catch (error) {\n      console.error('Failed to initialize ResourceFlowSubsystem:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Dispose of the subsystem\n   */\n  public async dispose(): Promise<void> {\n    if (!this.isInitialized) {\n      return;\n    }\n\n    try {\n      // Clean up Web Worker\n      if (this.workerUtil) {\n        this.workerUtil.terminate();\n        this.workerUtil = null;\n      }\n\n      // Clear data structures\n      this.nodes.clear();\n      this.connections.clear();\n      this.sourceConnections.clear();\n      this.targetConnections.clear();\n\n      this.producerNodes.clear();\n      this.consumerNodes.clear();\n      this.storageNodes.clear();\n      this.converterNodes.clear();\n\n      this.resourceStates.clear();\n      this.resourceProducers.clear();\n      this.resourceConsumers.clear();\n      this.resourceStorage.clear();\n\n      this.transferHistory = [];\n\n      this.isInitialized = false;\n    } catch (error) {\n      console.error('Failed to dispose ResourceFlowSubsystem:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Initialize event subscriptions\n   */\n  private initializeEventSubscriptions(): void {\n    // Subscribe to relevant events\n    eventSystem.subscribe('MODULE_CREATED', this.handleModuleCreated);\n    eventSystem.subscribe('MODULE_UPDATED', this.handleModuleUpdated);\n    eventSystem.subscribe('MODULE_DESTROYED', this.handleModuleDestroyed);\n    eventSystem.subscribe('MODULE_ENABLED', this.handleModuleStateChanged);\n    eventSystem.subscribe('MODULE_DISABLED', this.handleModuleStateChanged);\n  }\n\n  /**\n   * Initialize with default states for all resource types\n   */\n  private initializeResourceStates(): void {\n    const defaultResourceTypes: StringResourceType[] = [\n      ResourceType.ENERGY,\n      ResourceType.MINERALS,\n      ResourceType.POPULATION,\n      ResourceType.RESEARCH,\n      ResourceType.PLASMA,\n      ResourceType.GAS,\n      ResourceType.EXOTIC,\n    ];\n\n    // Initialize resource states for all resource types\n    for (const type of defaultResourceTypes) {\n      const resourceState: ResourceState = {\n        current: 0,\n        max: 1000,\n        min: 0,\n        production: 0,\n        consumption: 0,\n      };\n\n      this.resourceStates.set(type, resourceState);\n      this.resourceProducers.set(type, []);\n      this.resourceConsumers.set(type, []);\n      this.resourceStorage.set(type, []);\n    }\n  }\n\n  /**\n   * Registers a node in the resource flow network\n   */\n  public registerNode(node: FlowNode): boolean {\n    if (!node.id || !node.resources || node.resources.length === 0) {\n      console.warn('Invalid flow node:', node);\n      return false;\n    }\n\n    // Add to main nodes map\n    this.nodes.set(node.id, node);\n\n    // Add to type-specific map\n    switch (node.type) {\n      case 'producer':\n        this.producerNodes.set(node.id, node);\n        break;\n      case 'consumer':\n        this.consumerNodes.set(node.id, node);\n        break;\n      case 'storage':\n        this.storageNodes.set(node.id, node);\n        break;\n      case 'converter':\n        this.converterNodes.set(node.id, node);\n        break;\n    }\n\n    // Add to resource-specific tracking\n    for (const resourceType of node.resources) {\n      // Invalidate parent system cache\n      this.invalidateCache(resourceType);\n\n      // Add to the appropriate resource tracking maps\n      switch (node.type) {\n        case 'producer':\n          this.addToArray(this.resourceProducers, resourceType, node.id);\n          break;\n        case 'consumer':\n          this.addToArray(this.resourceConsumers, resourceType, node.id);\n          break;\n        case 'storage':\n          this.addToArray(this.resourceStorage, resourceType, node.id);\n          break;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Unregisters a node from the resource flow network\n   */\n  public unregisterNode(id: string): boolean {\n    if (!this.nodes.has(id)) {\n      return false;\n    }\n\n    // Get node before removing it\n    const node = this.nodes.get(id);\n    if (!node) return false;\n\n    // Remove from type-specific map\n    switch (node.type) {\n      case 'producer':\n        this.producerNodes.delete(id);\n        break;\n      case 'consumer':\n        this.consumerNodes.delete(id);\n        break;\n      case 'storage':\n        this.storageNodes.delete(id);\n        break;\n      case 'converter':\n        this.converterNodes.delete(id);\n        break;\n    }\n\n    // Remove from resource-specific tracking\n    for (const resourceType of node.resources) {\n      // Invalidate parent system cache\n      this.invalidateCache(resourceType);\n\n      // Remove from the appropriate resource tracking maps\n      switch (node.type) {\n        case 'producer':\n          this.removeFromArray(this.resourceProducers, resourceType, id);\n          break;\n        case 'consumer':\n          this.removeFromArray(this.resourceConsumers, resourceType, id);\n          break;\n        case 'storage':\n          this.removeFromArray(this.resourceStorage, resourceType, id);\n          break;\n      }\n    }\n\n    // Remove all connections to/from this node\n    const connectionEntries = Array.from(this.connections.entries());\n    for (const [connectionId, connection] of connectionEntries) {\n      if (connection.source === id || connection.target === id) {\n        this.unregisterConnection(connectionId);\n      }\n    }\n\n    // Remove from main nodes map\n    this.nodes.delete(id);\n\n    return true;\n  }\n\n  /**\n   * Registers a connection between nodes in the resource flow network\n   */\n  public registerConnection(connection: FlowConnection): boolean {\n    if (\n      !connection.id ||\n      !connection.source ||\n      !connection.target ||\n      !connection.resourceType ||\n      connection.maxRate <= 0\n    ) {\n      console.warn('Invalid connection:', connection);\n      return false;\n    }\n\n    // Ensure source and target nodes exist\n    if (!this.nodes.has(connection.source)) {\n      console.warn(`Source node ${connection.source} does not exist`);\n      return false;\n    }\n\n    if (!this.nodes.has(connection.target)) {\n      console.warn(`Target node ${connection.target} does not exist`);\n      return false;\n    }\n\n    // Ensure source node has the resource type\n    const sourceNode = this.nodes.get(connection.source);\n    if (!sourceNode?.resources.includes(connection.resourceType)) {\n      console.warn(\n        `Source node ${connection.source} does not have resource type ${connection.resourceType}`\n      );\n      return false;\n    }\n\n    // Add to connections map\n    this.connections.set(connection.id, connection);\n\n    // Update source and target connection maps\n    this.addToArray(this.sourceConnections, connection.source, connection.id);\n    this.addToArray(this.targetConnections, connection.target, connection.id);\n\n    // Invalidate cache for affected resource\n    this.invalidateCache(connection.resourceType);\n\n    return true;\n  }\n\n  /**\n   * Unregisters a connection from the resource flow network\n   */\n  public unregisterConnection(id: string): boolean {\n    const connection = this.connections.get(id);\n    if (!connection) {\n      return false;\n    }\n\n    // Remove from source and target connection maps\n    this.removeFromArray(this.sourceConnections, connection.source, id);\n    this.removeFromArray(this.targetConnections, connection.target, id);\n\n    // Remove from connections map\n    this.connections.delete(id);\n\n    // Invalidate cache for affected resource\n    this.invalidateCache(connection.resourceType);\n\n    return true;\n  }\n\n  /**\n   * Registers a resource flow between nodes\n   */\n  public registerResourceFlow(\n    sourceId: string,\n    targetId: string,\n    resourceType: StringResourceType | ResourceType,\n    rate: number\n  ): boolean {\n    // Ensure we're using string resource type for internal storage\n    const stringType = isStringResourceType(resourceType)\n      ? (resourceType as StringResourceType)\n      : toStringResourceType(resourceType as ResourceType);\n\n    // Check if source and target nodes exist\n    const source = this.nodes.get(sourceId);\n    const target = this.nodes.get(targetId);\n\n    if (!source || !target) {\n      console.error(`Cannot register flow: source or target node not found`);\n      return false;\n    }\n\n    // Check if source produces this resource\n    if (!source.resources.includes(stringType as ResourceType)) {\n      console.error(`Source node ${sourceId} does not produce ${stringType}`);\n      return false;\n    }\n\n    // Check if target accepts this resource\n    if (!target.resources.includes(stringType as ResourceType)) {\n      console.error(`Target node ${targetId} does not accept ${stringType}`);\n      return false;\n    }\n\n    // Create a unique ID for the connection\n    const connectionId = `${sourceId}-${targetId}-${stringType}`;\n\n    // Create the connection\n    const connection: FlowConnection = {\n      id: connectionId,\n      source: sourceId,\n      target: targetId,\n      resourceType: stringType as StringResourceType,\n      maxRate: rate,\n      currentRate: 0,\n      priority: {\n        type: stringType as StringResourceType,\n        priority: 1,\n        consumers: [targetId],\n      },\n      active: true,\n    };\n\n    // Register the connection\n    return this.registerConnection(connection);\n  }\n\n  /**\n   * Updates the state of a resource in the network\n   */\n  public updateResourceState(type: StringResourceType | ResourceType, state: ResourceState): void {\n    // Ensure we're using string resource type for internal storage\n    const stringType = isStringResourceType(type)\n      ? (type as StringResourceType)\n      : toStringResourceType(type as ResourceType);\n\n    this.resourceStates.set(stringType as ResourceType, state);\n    this.invalidateCache(stringType as StringResourceType);\n  }\n\n  /**\n   * Gets the current state of a resource in the network\n   */\n  public getResourceState(type: StringResourceType | ResourceType): ResourceState | undefined {\n    // Ensure we're using string resource type for internal storage\n    const stringType = isStringResourceType(type)\n      ? (type as StringResourceType)\n      : toStringResourceType(type as ResourceType);\n\n    return this.resourceStates.get(stringType as ResourceType);\n  }\n\n  /**\n   * Invalidate cache for a resource type\n   */\n  private invalidateCache(type: StringResourceType): void {\n    // Publish event for resource state change\n    eventSystem.publish({\n      type: EventType.RESOURCE_UPDATED,\n      timestamp: Date.now(),\n      data: {\n        resourceType: type,\n      },\n    });\n  }\n\n  /**\n   * Optimize resource flows across the network\n   */\n  public async optimizeFlows(): Promise<FlowOptimizationResult> {\n    // Prevent concurrent optimization runs\n    if (this.isOptimizing) {\n      return (\n        this.lastOptimizationResult || {\n          transfers: [],\n          updatedConnections: [],\n          bottlenecks: [],\n          underutilized: [],\n          performanceMetrics: {\n            executionTimeMs: 0,\n            nodesProcessed: 0,\n            connectionsProcessed: 0,\n            transfersGenerated: 0,\n          },\n        }\n      );\n    }\n\n    this.isOptimizing = true;\n    const startTime = Date.now();\n\n    try {\n      // Get active nodes and connections\n      const activeNodes = Array.from(this.nodes.values()).filter(node => node.active);\n      const activeConnections = Array.from(this.connections.values()).filter(conn => conn.active);\n\n      // Check if we should use Web Worker offloading\n      if (\n        this.config.useWorkerOffloading &&\n        this.workerUtil &&\n        activeNodes.length > this.config.batchSize\n      ) {\n        try {\n          // Offload optimization to Web Worker\n          const result = await this.workerUtil.optimizeFlows(\n            // Convert to the expected FlowNode type from StandardizedResourceTypes\n            activeNodes.map(node => {\n              // Create a Map from the string array for the resources property\n              const resourcesMap = new Map<ResourceType, number>();\n              node.resources.forEach(resource => {\n                resourcesMap.set(resource as unknown as ResourceType, 0);\n              });\n\n              // Cast to StandardizedFlowNode type\n              return {\n                id: node.id,\n                type: node.type as unknown as StandardizedFlowNodeType,\n                name: node.id, // Use ID as name since our internal nodes don't have names\n                capacity: 100, // Default values for required fields\n                currentLoad: 0,\n                efficiency: node.efficiency || 1.0,\n                status: node.active ? 'active' : 'inactive',\n                resources: resourcesMap,\n              } as StandardizedFlowNode;\n            }),\n            // Convert to the expected FlowConnection type\n            activeConnections.map(conn => ({\n              id: conn.id,\n              source: conn.source,\n              target: conn.target,\n              resourceTypes: [conn.resourceType as unknown as ResourceType],\n              resourceType: conn.resourceType as unknown as ResourceType,\n              maxRate: conn.maxRate,\n              currentRate: conn.currentRate,\n              active: conn.active,\n            })),\n            // Convert Map to expected parameter type\n            new Map(\n              Object.entries(Object.fromEntries(this.resourceStates)).map(([key, value]) => [\n                key as unknown as ResourceType,\n                value as ResourceState,\n              ])\n            )\n          );\n\n          // Apply the results from the worker\n          this.applyOptimizationResults(this.convertWorkerResult(result));\n\n          // Add execution time to performance metrics\n          if (!result.performanceMetrics) {\n            result.performanceMetrics = {\n              executionTimeMs: 0,\n              nodesProcessed: activeNodes.length,\n              connectionsProcessed: activeConnections.length,\n              transfersGenerated: result.transfers?.length || 0,\n            };\n          }\n\n          if (result.performanceMetrics) {\n            result.performanceMetrics.executionTimeMs = Date.now() - startTime;\n          }\n\n          const convertedResult = this.convertWorkerResult(result);\n          this.lastOptimizationResult = convertedResult;\n          this.lastOptimizationTime = Date.now();\n          return convertedResult;\n        } catch (error) {\n          console.warn('Web Worker optimization failed, falling back to main thread:', error);\n          // Fall back to main thread optimization\n        }\n      }\n\n      // Categorize nodes by type\n      const producers = activeNodes.filter(node => node.type === 'producer');\n      const consumers = activeNodes.filter(node => node.type === 'consumer');\n      const storages = activeNodes.filter(node => node.type === 'storage');\n      const converters = activeNodes.filter(node => node.type === 'converter');\n\n      // Process converters\n      this.processConverters(converters, activeConnections);\n\n      // Calculate resource balance\n      const { availability, demand } = this.calculateResourceBalance(\n        producers,\n        consumers,\n        storages,\n        activeConnections\n      );\n\n      // Identify resource issues\n      const { bottlenecks, underutilized } = this.identifyResourceIssues(availability, demand);\n\n      // Optimize flow rates\n      const { updatedConnections, transfers } = this.optimizeFlowRates(\n        activeConnections,\n        availability,\n        demand\n      );\n\n      // Update connections with optimized rates\n      for (const connection of updatedConnections) {\n        this.connections.set(connection.id, connection);\n      }\n\n      // Create and store result\n      const result: FlowOptimizationResult = {\n        transfers,\n        updatedConnections,\n        bottlenecks,\n        underutilized,\n        performanceMetrics: {\n          executionTimeMs: Date.now() - startTime,\n          nodesProcessed: activeNodes.length,\n          connectionsProcessed: activeConnections.length,\n          transfersGenerated: transfers.length,\n        },\n      };\n\n      this.lastOptimizationResult = result;\n      this.lastOptimizationTime = Date.now();\n      return result;\n    } finally {\n      this.isOptimizing = false;\n    }\n  }\n\n  /**\n   * Apply optimization results\n   */\n  private applyOptimizationResults(result: FlowOptimizationResult): void {\n    if (!result) return;\n\n    // Update connections with optimized rates\n    if (result.updatedConnections) {\n      for (const connection of result.updatedConnections) {\n        if (this.connections.has(connection.id)) {\n          this.connections.set(connection.id, connection);\n        }\n      }\n    }\n\n    // Process transfers\n    if (result.transfers) {\n      for (const transfer of result.transfers) {\n        if (validateResourceTransfer(transfer)) {\n          this.addToTransferHistory(transfer);\n        }\n      }\n    }\n  }\n\n  /**\n   * Process converters\n   */\n  private processConverters(converters: FlowNode[], activeConnections: FlowConnection[]): void {\n    // Process each converter node\n    converters.forEach(converter => {\n      this.processAdvancedConverter(converter, activeConnections);\n    });\n  }\n\n  /**\n   * Process an advanced converter\n   */\n  private processAdvancedConverter(\n    converter: FlowNode,\n    _activeConnections: FlowConnection[]\n  ): void {\n    // Implementation of advanced converter logic will go here\n    console.warn(`Processing advanced converter: ${converter.id}`);\n  }\n\n  /**\n   * Calculate resource balance between producers, consumers, and storage\n   */\n  private calculateResourceBalance(\n    producers: FlowNode[],\n    consumers: FlowNode[],\n    storages: FlowNode[],\n    activeConnections: FlowConnection[]\n  ): {\n    availability: Partial<Record<StringResourceType, number>>;\n    demand: Partial<Record<StringResourceType, number>>;\n  } {\n    const availability: Partial<Record<StringResourceType, number>> = {};\n    const demand: Partial<Record<StringResourceType, number>> = {};\n\n    // Initialize with zero values for all resource types\n    for (const type of this.resourceStates.keys()) {\n      availability[type] = 0;\n      demand[type] = 0;\n    }\n\n    // Calculate production capacity\n    for (const producer of producers) {\n      for (const resourceType of producer.resources) {\n        // Find outgoing connections for this resource\n        const outgoingConnections = activeConnections.filter(\n          conn => conn.source === producer.id && conn.resourceType === resourceType\n        );\n\n        // Sum up max rates\n        const totalMaxRate = outgoingConnections.reduce((sum, conn) => sum + conn.maxRate, 0);\n\n        // Apply efficiency if available\n        const effectiveRate = producer.efficiency\n          ? totalMaxRate * producer.efficiency\n          : totalMaxRate;\n\n        availability[resourceType] = (availability[resourceType] ?? 0) + effectiveRate;\n      }\n    }\n\n    // Calculate consumer demand\n    for (const consumer of consumers) {\n      for (const resourceType of consumer.resources) {\n        // Find incoming connections for this resource\n        const incomingConnections = activeConnections.filter(\n          conn => conn.target === consumer.id && conn.resourceType === resourceType\n        );\n\n        // Sum up max rates\n        const totalMaxRate = incomingConnections.reduce((sum, conn) => sum + conn.maxRate, 0);\n\n        demand[resourceType] = (demand[resourceType] ?? 0) + totalMaxRate;\n      }\n    }\n\n    // Factor in storage capacity\n    for (const storage of storages) {\n      for (const resourceType of storage.resources) {\n        // Use resource state if available\n        const resourceState = this.resourceStates.get(resourceType);\n        if (!resourceState) {\n          continue;\n        }\n\n        // If storage is near capacity, reduce availability\n        if (resourceState.current > resourceState.max * 0.9) {\n          availability[resourceType] = Math.max(\n            0,\n            (availability[resourceType] ?? 0) - (resourceState.max - resourceState.current)\n          );\n        }\n\n        // If storage is near empty, increase demand\n        if (resourceState.current < resourceState.max * 0.1) {\n          demand[resourceType] = (demand[resourceType] ?? 0) + resourceState.max * 0.2;\n        }\n      }\n    }\n\n    return { availability, demand };\n  }\n\n  /**\n   * Identify resource bottlenecks and underutilized resources\n   */\n  private identifyResourceIssues(\n    availability: Partial<Record<StringResourceType, number>>,\n    demand: Partial<Record<StringResourceType, number>>\n  ): {\n    bottlenecks: string[];\n    underutilized: string[];\n  } {\n    const bottlenecks: string[] = [];\n    const underutilized: string[] = [];\n\n    for (const [type, availableAmount] of Object.entries(availability)) {\n      const demandAmount = demand[type as StringResourceType] ?? 0;\n\n      if (availableAmount < demandAmount * 0.9) {\n        bottlenecks.push(type);\n      } else if (availableAmount > demandAmount * 1.5) {\n        underutilized.push(type);\n      }\n    }\n\n    return { bottlenecks, underutilized };\n  }\n\n  /**\n   * Optimize flow rates based on priorities\n   */\n  private optimizeFlowRates(\n    activeConnections: FlowConnection[],\n    availability: Partial<Record<StringResourceType, number>>,\n    demand: Partial<Record<StringResourceType, number>>\n  ): {\n    updatedConnections: FlowConnection[];\n    transfers: ResourceTransfer[];\n  } {\n    const updatedConnections: FlowConnection[] = [];\n    const transfers: ResourceTransfer[] = [];\n    const now = Date.now();\n\n    // Sort connections by priority (high to low)\n    const prioritizedConnections = [...activeConnections].sort(\n      (a, b) => b.priority.priority - a.priority.priority\n    );\n\n    // Adjust flow rates\n    for (const connection of prioritizedConnections) {\n      const { resourceType } = connection;\n      const availableForType = availability[resourceType] ?? 0;\n      const demandForType = demand[resourceType] ?? 0;\n\n      if (availableForType <= 0 || demandForType <= 0) {\n        // No flow possible\n        connection.currentRate = 0;\n      } else if (availableForType >= demandForType) {\n        // Full flow possible\n        connection.currentRate = Math.min(connection.maxRate, demandForType);\n      } else {\n        // Partial flow based on ratio\n        const ratio = availableForType / demandForType;\n        connection.currentRate = connection.maxRate * ratio;\n      }\n\n      updatedConnections.push({ ...connection });\n\n      // Generate transfer if flow is positive\n      if (connection.currentRate > 0) {\n        const transfer: ResourceTransfer = {\n          type: connection.resourceType,\n          source: connection.source,\n          target: connection.target,\n          amount: connection.currentRate,\n          timestamp: now,\n        };\n\n        if (validateResourceTransfer(transfer)) {\n          transfers.push(transfer);\n          this.addToTransferHistory(transfer);\n        }\n      }\n    }\n\n    return { updatedConnections, transfers };\n  }\n\n  /**\n   * Add a transfer to the history\n   */\n  private addToTransferHistory(transfer: ResourceTransfer): void {\n    this.transferHistory.push(transfer);\n\n    // Trim history if needed\n    if (this.transferHistory.length > this.config.maxHistorySize) {\n      this.transferHistory = this.transferHistory.slice(-this.config.maxHistorySize);\n    }\n  }\n\n  /**\n   * Get the transfer history\n   */\n  public getTransferHistory(): ResourceTransfer[] {\n    return [...this.transferHistory];\n  }\n\n  /**\n   * Get a specific node\n   */\n  public getNode(id: string): FlowNode | undefined {\n    return this.nodes.get(id);\n  }\n\n  /**\n   * Get all nodes\n   */\n  public getNodes(): FlowNode[] {\n    return Array.from(this.nodes.values());\n  }\n\n  /**\n   * Get a specific connection\n   */\n  public getConnection(id: string): FlowConnection | undefined {\n    return this.connections.get(id);\n  }\n\n  /**\n   * Get all connections\n   */\n  public getConnections(): FlowConnection[] {\n    return Array.from(this.connections.values());\n  }\n\n  /**\n   * Add an item to an array in a map\n   */\n  private addToArray<K, V>(map: Map<K, V[]>, key: K, value: V): void {\n    const array = map.get(key) ?? [];\n    if (!array.includes(value)) {\n      array.push(value);\n      map.set(key, array);\n    }\n  }\n\n  /**\n   * Remove an item from an array in a map\n   */\n  private removeFromArray<K, V>(map: Map<K, V[]>, key: K, value: V): void {\n    const array = map.get(key);\n    if (array) {\n      const index = array.indexOf(value);\n      if (index >= 0) {\n        array.splice(index, 1);\n        map.set(key, array);\n      }\n    }\n  }\n\n  // Module event handlers\n  private handleModuleCreated = (event: unknown): void => {\n    // Type guard to ensure the event has the expected properties\n    if (!event || typeof event !== 'object') return;\n\n    const eventData = event as {\n      moduleId?: string;\n      moduleType?: string;\n      resources?: StringResourceType[];\n    };\n\n    if (!eventData.moduleId || !eventData.moduleType) return;\n\n    // Determine node type based on module type\n    let nodeType: FlowNodeType = 'consumer';\n    if (eventData.moduleType === 'producer' || eventData.moduleType === 'mining') {\n      nodeType = 'producer';\n    } else if (eventData.moduleType === 'storage') {\n      nodeType = 'storage';\n    } else if (eventData.moduleType === 'converter') {\n      nodeType = 'converter';\n    }\n\n    // Create and register node\n    const node: FlowNode = {\n      id: eventData.moduleId,\n      type: nodeType,\n      resources: eventData.resources ?? [],\n      priority: {\n        type: eventData.resources?.[0] || ResourceType.ENERGY,\n        priority: 1,\n        consumers: [],\n      },\n      active: true,\n    };\n\n    this.registerNode(node);\n  };\n\n  private handleModuleUpdated = (event: unknown): void => {\n    // Type guard to ensure the event has the expected properties\n    if (!event || typeof event !== 'object') return;\n\n    const eventData = event as {\n      moduleId?: string;\n      changes?: {\n        resources?: StringResourceType[];\n        active?: boolean;\n        efficiency?: number;\n      };\n    };\n\n    if (!eventData.moduleId || !eventData.changes) return;\n\n    // Get existing node\n    const node = this.nodes.get(eventData.moduleId);\n    if (!node) return;\n\n    // Apply changes\n    if (eventData.changes.resources) {\n      node.resources = eventData.changes.resources;\n    }\n\n    if (eventData.changes.active !== undefined) {\n      node.active = eventData.changes.active;\n    }\n\n    if (eventData.changes.efficiency !== undefined) {\n      node.efficiency = eventData.changes.efficiency;\n    }\n\n    // Update node\n    this.nodes.set(eventData.moduleId, node);\n\n    // Invalidate cache for affected resources\n    for (const resource of node.resources) {\n      this.invalidateCache(resource);\n    }\n  };\n\n  private handleModuleDestroyed = (event: unknown): void => {\n    // Type guard to ensure the event has the expected properties\n    if (!event || typeof event !== 'object') return;\n\n    const eventData = event as { moduleId?: string };\n    if (!eventData.moduleId) return;\n\n    this.unregisterNode(eventData.moduleId);\n  };\n\n  private handleModuleStateChanged = (event: unknown): void => {\n    // Type guard to ensure the event has the expected properties\n    if (!event || typeof event !== 'object') return;\n\n    const eventData = event as { moduleId?: string; active?: boolean };\n    if (!eventData.moduleId || eventData.active === undefined) return;\n\n    // Get existing node\n    const node = this.nodes.get(eventData.moduleId);\n    if (!node) return;\n\n    // Update active state\n    node.active = eventData.active;\n\n    // Update node\n    this.nodes.set(eventData.moduleId, node);\n\n    // Invalidate cache for affected resources\n    for (const resource of node.resources) {\n      this.invalidateCache(resource);\n    }\n  };\n\n  /**\n   * Convert worker result to the format expected by the subsystem\n   */\n  private convertWorkerResult(result: WorkerOptimizationResult): FlowOptimizationResult {\n    if (!result) {\n      return {\n        transfers: [],\n        updatedConnections: [],\n        bottlenecks: [],\n        underutilized: [],\n      };\n    }\n\n    // Convert the connections to our internal format\n    const updatedConnections =\n      result.updatedConnections?.map((conn: WorkerConnectionResult) => {\n        return {\n          id: conn.id,\n          source: conn.source,\n          target: conn.target,\n          resourceType:\n            conn.resourceType ||\n            (conn.resourceTypes && conn.resourceTypes[0]) ||\n            ResourceType.ENERGY,\n          maxRate: conn.maxRate || 0,\n          currentRate: conn.currentRate || 0,\n          priority: {\n            type:\n              conn.resourceType ||\n              (conn.resourceTypes && conn.resourceTypes[0]) ||\n              ResourceType.ENERGY,\n            priority:\n              typeof conn.priority === 'number'\n                ? conn.priority\n                : (conn.priority as { priority: number })?.priority || 1,\n            consumers: [conn.target],\n          },\n          active: conn.active !== undefined ? conn.active : true,\n        } as FlowConnection;\n      }) || [];\n\n    return {\n      transfers: result.transfers || [],\n      updatedConnections,\n      bottlenecks: result.bottlenecks || [],\n      underutilized: result.underutilized || [],\n      performanceMetrics: result.performanceMetrics,\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/resource/subsystems/ResourceStorageSubsystem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/resource/subsystems/ResourceThresholdSubsystem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/resource/subsystems/ResourceTransferSubsystem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/router/routes.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/scripts/runNetworkTests.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/services/APIService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/services/AnalysisAlgorithmService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_pendingResult' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":153,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":153,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sampleRate' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":340,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":340,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'options' is defined but never used.","line":433,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":433,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'options' is defined but never used.","line":694,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":694,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'options' is defined but never used.","line":1003,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":1003,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'normalize' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":1070,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":1070,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'i' is defined but never used.","line":1530,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":1530,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'options' is defined but never used.","line":2145,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":2145,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'normalizedTestFeatures' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":2634,"column":38,"nodeType":null,"messageId":"unusedVar","endLine":2634,"endColumn":60},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'normalizedTestTargets' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":2645,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":2645,"endColumn":32},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'batchLoss' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":2729,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":2729,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'options' is defined but never used.","line":3049,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":3049,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'dataset' is defined but never used.","line":3411,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":3411,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'options' is defined but never used.","line":3412,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":3412,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'normalizeValues' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":3421,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":3421,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'timeRange' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":3422,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":3422,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'groupBy' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":3423,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":3423,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'dataset' is defined but never used.","line":3451,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":3451,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'options' is defined but never used.","line":3452,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":3452,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'includeNeighbors' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":3458,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":3458,"endColumn":49},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'timeRange' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":3458,"column":59,"nodeType":null,"messageId":"unusedVar","endLine":3458,"endColumn":68}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":21,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @file AnalysisAlgorithmService.ts\n * Service for implementing data analysis algorithms\n *\n * This service:\n * 1. Provides implementation for various analysis types\n * 2. Processes datasets using appropriate algorithms\n * 3. Generates insights from data patterns\n * 4. Implements caching for expensive calculations\n */\n\nimport { v4 as uuidv4 } from 'uuid';\nimport {\n  AnalysisConfig,\n  AnalysisResult,\n  ClusteringAnalysisConfig,\n  ComparisonAnalysisConfig,\n  CorrelationAnalysisConfig,\n  DataPoint,\n  Dataset,\n  DistributionAnalysisConfig,\n  PredictionAnalysisConfig,\n  ResourceMappingAnalysisConfig,\n  SectorAnalysisConfig,\n  TrendAnalysisConfig,\n} from '../types/exploration/DataAnalysisTypes';\nimport { ResourceType } from '../types/resources/ResourceTypes';\n\n/**\n * Interface for algorithm options\n */\ninterface AlgorithmOptions {\n  timeoutMs?: number;\n  maxSamples?: number;\n  normalize?: boolean;\n  includeDetails?: boolean;\n  confidenceThreshold?: number;\n  useWorker?: boolean; // Option to use WebWorker for heavy calculations\n  sampleData?: boolean; // Option to sample large datasets for faster processing\n  sampleSize?: number; // Number of samples to use when sampleData is true\n}\n\n// Type definition for property extraction and value memoization\ntype PropertyExtractor = (point: DataPoint) => unknown;\n\n/**\n * Interface for distribution bins\n */\ninterface DistributionBin {\n  binStart: number;\n  binEnd: number;\n  count: number;\n  normalizedCount?: number;\n}\n\n/**\n * Interface for resource cells in mapping\n */\ninterface ResourceCell {\n  x: number;\n  y: number;\n  resources: Array<{ type: string; amount: number }>;\n  totalValue: number;\n  dominantResource?: string;\n  dominantPercentage?: number;\n  totalResourceCount: number;\n}\n\n/**\n * Service for implementing analysis algorithms\n */\nexport class AnalysisAlgorithmService {\n  // Cache for storing computed results to improve performance\n  private resultCache: Map<string, { result: AnalysisResult; expiresAt: number }> = new Map();\n\n  // Cache expiration time (10 minutes)\n  private cacheExpirationMs = 10 * 60 * 1000;\n\n  // Property access cache for faster property extraction\n  private propertyExtractorCache: Map<string, PropertyExtractor> = new Map();\n\n  // Default sample size for large datasets\n  private defaultSampleSize = 1000;\n\n  // Memoization for common statistical operations\n  private memoizedMeans: Map<string, number> = new Map();\n  private memoizedVariances: Map<string, number> = new Map();\n\n  // WebWorker pool for parallel processing\n  private workerPool: Worker[] = [];\n  private isWorkerSupported = typeof Worker !== 'undefined';\n  private maxWorkers = navigator.hardwareConcurrency || 4;\n\n  constructor() {\n    // Initialize WebWorker pool if supported\n    if (this.isWorkerSupported) {\n      this.initWorkerPool();\n    }\n  }\n\n  /**\n   * Initialize WebWorker pool for parallel processing\n   */\n  private initWorkerPool(): void {\n    // Create workers up to the maximum number allowed\n    for (let i = 0; i < this.maxWorkers; i++) {\n      try {\n        // Create a worker for calculation-intensive tasks\n        const worker = new Worker(new URL('../workers/AnalysisWorker.ts', import.meta.url));\n        this.workerPool.push(worker);\n      } catch (error) {\n        console.error('Failed to create worker:', error);\n      }\n    }\n  }\n\n  /**\n   * Run analysis on a dataset\n   */\n  public async runAnalysis(\n    config: AnalysisConfig,\n    dataset: Dataset,\n    options: AlgorithmOptions = {}\n  ): Promise<AnalysisResult> {\n    // Set default options\n    const effectiveOptions = {\n      ...options,\n      sampleData: options?.sampleData ?? dataset.dataPoints.length > this.defaultSampleSize,\n      sampleSize: options?.sampleSize ?? this.defaultSampleSize,\n      useWorker: options?.useWorker ?? (this.isWorkerSupported && dataset.dataPoints.length > 5000),\n    };\n\n    // Generate a cache key based on config, dataset, and options\n    const cacheKey = this.generateCacheKey(config, dataset, effectiveOptions);\n\n    // Check if a cached result exists and is still valid\n    const cachedResult = this.resultCache.get(cacheKey);\n    if (cachedResult && cachedResult.expiresAt > Date.now()) {\n      return cachedResult.result;\n    }\n\n    // Clear memoization caches for new analysis\n    this.clearMemoizationCaches();\n\n    // Sample the dataset if needed\n    const dataToProcess = this.getSampledDataset(dataset, effectiveOptions);\n\n    // Start the analysis\n    const resultId = uuidv4();\n    const startTime = Date.now();\n\n    // Create a pending result\n    const _pendingResult: AnalysisResult = {\n      id: resultId,\n      analysisConfigId: config.id,\n      status: 'processing',\n      startTime,\n      data: {},\n    };\n\n    try {\n      // Use a worker if available and needed\n      let result: AnalysisResult;\n\n      if (effectiveOptions.useWorker && this.workerPool.length > 0) {\n        result = await this.runAnalysisInWorker(config, dataToProcess, effectiveOptions);\n      } else {\n        // Run the appropriate analysis algorithm based on the type\n        switch (config.type) {\n          case 'trend':\n            result = await this.analyzeTrend(\n              config as TrendAnalysisConfig,\n              dataToProcess,\n              effectiveOptions\n            );\n            break;\n          case 'correlation':\n            result = await this.analyzeCorrelation(\n              config as CorrelationAnalysisConfig,\n              dataToProcess,\n              effectiveOptions\n            );\n            break;\n          case 'distribution':\n            result = await this.analyzeDistribution(\n              config as DistributionAnalysisConfig,\n              dataToProcess,\n              effectiveOptions\n            );\n            break;\n          case 'clustering':\n            result = await this.analyzeClustering(\n              config as ClusteringAnalysisConfig,\n              dataToProcess,\n              effectiveOptions\n            );\n            break;\n          case 'prediction':\n            result = await this.analyzePrediction(\n              config as PredictionAnalysisConfig,\n              dataToProcess,\n              effectiveOptions\n            );\n            break;\n          case 'comparison':\n            result = await this.analyzeComparison(\n              config as ComparisonAnalysisConfig,\n              dataToProcess,\n              effectiveOptions\n            );\n            break;\n          case 'resourceMapping':\n            result = await this.analyzeResourceMapping(\n              config as ResourceMappingAnalysisConfig,\n              dataToProcess,\n              effectiveOptions\n            );\n            break;\n          case 'sectorAnalysis':\n            result = await this.analyzeSector(\n              config as SectorAnalysisConfig,\n              dataToProcess,\n              effectiveOptions\n            );\n            break;\n          default:\n            throw new Error(`Unsupported analysis type: ${config.type}`);\n        }\n      }\n\n      // Add data sampling info to result if sampling was used\n      if (\n        effectiveOptions.sampleData &&\n        dataset.dataPoints.length > effectiveOptions.sampleSize &&\n        result &&\n        result.data\n      ) {\n        result.data.samplingInfo = {\n          originalSize: dataset.dataPoints.length,\n          sampleSize: effectiveOptions.sampleSize,\n          samplingRatio: effectiveOptions.sampleSize / dataset.dataPoints.length,\n        };\n      }\n\n      // Update the result cache\n      this.resultCache.set(cacheKey, {\n        result,\n        expiresAt: Date.now() + this.cacheExpirationMs,\n      });\n\n      return result;\n    } catch (error) {\n      // Return a failed result if an error occurred\n      const failedResult: AnalysisResult = {\n        id: resultId,\n        analysisConfigId: config.id,\n        status: 'failed',\n        startTime,\n        endTime: Date.now(),\n        data: {},\n        error: error instanceof Error ? error.message : 'Unknown error',\n      };\n\n      return failedResult;\n    }\n  }\n\n  /**\n   * Run analysis in a WebWorker for improved performance\n   */\n  private runAnalysisInWorker(\n    config: AnalysisConfig,\n    dataset: Dataset,\n    options: AlgorithmOptions\n  ): Promise<AnalysisResult> {\n    return new Promise((resolve, reject) => {\n      // Find an available worker\n      const worker = this.workerPool[0]; // Simple round-robin for now\n\n      // Create a unique message ID for this analysis\n      const messageId = uuidv4();\n\n      // Set up message handler\n      const handleMessage = (event: MessageEvent) => {\n        if (event?.data?.messageId === messageId) {\n          // Clean up message handler\n          worker.removeEventListener('message', handleMessage);\n\n          if (event?.data?.error) {\n            reject(new Error(event?.data?.error));\n          } else {\n            resolve(event?.data?.result);\n          }\n        }\n      };\n\n      // Set up error handler\n      const handleError = (error: ErrorEvent) => {\n        worker.removeEventListener('error', handleError);\n        reject(new Error(`Worker error: ${error.message}`));\n      };\n\n      // Register handlers\n      worker.addEventListener('message', handleMessage);\n      worker.addEventListener('error', handleError);\n\n      // Post message to worker\n      worker.postMessage({\n        messageId,\n        action: 'runAnalysis',\n        config,\n        dataset,\n        options,\n      });\n\n      // Set up timeout if specified\n      if (options?.timeoutMs) {\n        setTimeout(() => {\n          worker.removeEventListener('message', handleMessage);\n          worker.removeEventListener('error', handleError);\n          reject(new Error(`Analysis timed out after ${options?.timeoutMs}ms`));\n        }, options?.timeoutMs);\n      }\n    });\n  }\n\n  /**\n   * Sample dataset for faster processing\n   */\n  private getSampledDataset(dataset: Dataset, options: AlgorithmOptions): Dataset {\n    if (\n      !options?.sampleData ||\n      !options?.sampleSize ||\n      dataset.dataPoints.length <= options.sampleSize\n    ) {\n      return dataset;\n    }\n\n    // Create a sampled copy of the dataset\n    const sampleRate = options.sampleSize / dataset.dataPoints.length;\n    const sampledPoints = this.stratifiedSample(dataset.dataPoints, options.sampleSize);\n\n    return {\n      ...dataset,\n      dataPoints: sampledPoints,\n    };\n  }\n\n  /**\n   * Create a stratified sample of data points ensuring representation across types\n   */\n  private stratifiedSample(dataPoints: DataPoint[], sampleSize: number): DataPoint[] {\n    // Group data points by type\n    const byType: Record<string, DataPoint[]> = {};\n    for (const point of dataPoints) {\n      if (!byType[point.type]) {\n        byType[point.type] = [];\n      }\n      byType[point.type].push(point);\n    }\n\n    const result: DataPoint[] = [];\n    const types = Object.keys(byType);\n\n    // Calculate samples per type\n    let remaining = sampleSize;\n    const typeAllocations: Record<string, number> = {};\n\n    for (const type of types) {\n      // Allocate proportionally to original size\n      const proportion = byType[type].length / dataPoints.length;\n      const allocation = Math.floor(sampleSize * proportion);\n      typeAllocations[type] = allocation;\n      remaining -= allocation;\n    }\n\n    // Distribute any remaining sample slots\n    let typeIndex = 0;\n    while (remaining > 0) {\n      typeAllocations[types[typeIndex % types.length]]++;\n      remaining--;\n      typeIndex++;\n    }\n\n    // Sample from each type\n    for (const type of types) {\n      const typeSampleSize = typeAllocations[type];\n      const typeDataPoints = byType[type];\n\n      // Randomly select data points\n      const selected = new Set<number>();\n      while (selected.size < typeSampleSize) {\n        const index = Math.floor(Math.random() * typeDataPoints.length);\n        selected.add(index);\n      }\n\n      // Add selected points to result\n      for (const index of selected) {\n        result?.push(typeDataPoints[index]);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Clear memoization caches before starting a new analysis\n   */\n  private clearMemoizationCaches(): void {\n    this.memoizedMeans.clear();\n    this.memoizedVariances.clear();\n  }\n\n  /**\n   * Generate a cache key for a specific analysis configuration and dataset\n   */\n  private generateCacheKey(\n    config: AnalysisConfig,\n    dataset: Dataset,\n    options: AlgorithmOptions\n  ): string {\n    // Create a key based on configuration ID, dataset ID, last updated time, and options\n    const optionsKey = JSON.stringify(options);\n    return `${config.id}:${dataset.id}:${dataset.updatedAt}:${optionsKey}`;\n  }\n\n  /**\n   * Analyze trend data\n   */\n  private async analyzeTrend(\n    config: TrendAnalysisConfig,\n    dataset: Dataset,\n    options: AlgorithmOptions\n  ): Promise<AnalysisResult> {\n    const startTime = Date.now();\n\n    // Extract parameters\n    const { xAxis, yAxis, groupBy, timeRange, aggregation } = config.parameters;\n\n    // Filter data points based on time range\n    let dataPoints = dataset.dataPoints;\n    if (timeRange) {\n      dataPoints = dataPoints.filter(dp => dp.date >= timeRange[0] && dp.date <= timeRange[1]);\n    }\n\n    // Get or create optimized property extractors\n    const xExtractor = this.getPropertyExtractor(xAxis);\n    const yExtractor = this.getPropertyExtractor(yAxis);\n    const groupExtractor = groupBy ? this.getPropertyExtractor(groupBy) : null;\n\n    // Group data by the groupBy parameter if specified\n    let groupedData: Record<string, DataPoint[]> = {};\n    if (groupExtractor) {\n      // Group data using the optimized extractor\n      groupedData = this.groupDataByExtractor(dataPoints, groupExtractor);\n    } else {\n      // Just use one group with all data points\n      groupedData = { all: dataPoints };\n    }\n\n    // Prepare the result data structure\n    const resultData: Record<string, unknown> = {\n      xAxis,\n      yAxis,\n      groupBy,\n      timeRange,\n      aggregation,\n      groups: {},\n    };\n\n    // Process each group\n    for (const [group, points] of Object.entries(groupedData)) {\n      // Sort by the x-axis property (usually date)\n      const sortedPoints = this.sortDataPointsByExtractor(points, xExtractor);\n\n      // Extract x and y values using optimized extractors\n      const values = sortedPoints\n        .map(point => {\n          // Extract the x and y values using optimized extractors\n          const x = xExtractor(point);\n          const y = yExtractor(point);\n\n          // Only include points with valid x and y values\n          if (x !== undefined && y !== undefined && typeof y === 'number') {\n            return { x, y };\n          }\n\n          return null;\n        })\n        .filter(Boolean) as Array<{ x: unknown; y: number }>;\n\n      // Apply aggregation if specified\n      let aggregatedValues = values;\n      if (aggregation) {\n        aggregatedValues = this.aggregateValues(values, aggregation);\n      }\n\n      // Calculate trend line with optimized algorithm\n      const trendLine = this.calculateTrendLineOptimized(aggregatedValues);\n\n      // Add group data to result\n      (resultData.groups as Record<string, unknown>)[group] = {\n        values: aggregatedValues,\n        trendLine,\n      };\n    }\n\n    // Generate insights\n    const insights = this.generateTrendInsights(resultData);\n\n    // Create the result\n    const result: AnalysisResult = {\n      id: uuidv4(),\n      analysisConfigId: config.id,\n      status: 'completed',\n      startTime,\n      endTime: Date.now(),\n      data: resultData,\n      summary: this.generateTrendSummary(resultData),\n      insights,\n    };\n\n    return result;\n  }\n\n  /**\n   * Optimize property access with compiled accessor functions\n   */\n  private getPropertyExtractor(path: string): PropertyExtractor {\n    // Check if we already have a cached extractor\n    if (this.propertyExtractorCache.has(path)) {\n      return this.propertyExtractorCache.get(path)!;\n    }\n\n    // Parse the property path\n    const parts = path.split('.');\n\n    // Create an optimized extractor function\n    const extractor = (obj: DataPoint): unknown => {\n      if (parts.length === 1) {\n        // Direct property access (most common case)\n        const property = parts[0];\n        if (property in obj) {\n          return obj[property as keyof DataPoint];\n        } else if (property in obj.properties) {\n          return obj.properties[property];\n        } else if (obj.metadata && property in obj.metadata) {\n          return obj.metadata[property];\n        }\n        return undefined;\n      } else {\n        // Handle nested properties\n        let current: Record<string, unknown> = obj as Record<string, unknown>;\n        for (let i = 0; i < parts.length; i++) {\n          if (current === null || current === undefined) {\n            return undefined;\n          }\n\n          // Check in standard properties\n          if (current[parts[i]] !== undefined) {\n            current = current[parts[i]] as Record<string, unknown>;\n            continue;\n          }\n\n          // Check in DataPoint's properties or metadata\n          if (i === 0) {\n            if (parts[i] === 'properties' && obj.properties) {\n              current = obj.properties as Record<string, unknown>;\n            } else if (parts[i] === 'metadata' && obj.metadata) {\n              current = obj.metadata as Record<string, unknown>;\n            } else {\n              return undefined;\n            }\n          } else {\n            return undefined;\n          }\n        }\n        return current;\n      }\n    };\n\n    // Cache the extractor for future use\n    this.propertyExtractorCache.set(path, extractor);\n    return extractor;\n  }\n\n  /**\n   * Sort data points using the optimized property extractor\n   */\n  private sortDataPointsByExtractor(\n    dataPoints: DataPoint[],\n    extractor: PropertyExtractor\n  ): DataPoint[] {\n    return [...dataPoints].sort((a, b) => {\n      const aValue = extractor(a);\n      const bValue = extractor(b);\n\n      if (aValue === undefined) return 1;\n      if (bValue === undefined) return -1;\n\n      if (typeof aValue === 'number' && typeof bValue === 'number') {\n        return aValue - bValue;\n      }\n\n      return String(aValue).localeCompare(String(bValue));\n    });\n  }\n\n  /**\n   * Group data points using the optimized property extractor\n   */\n  private groupDataByExtractor(\n    dataPoints: DataPoint[],\n    extractor: PropertyExtractor\n  ): Record<string, DataPoint[]> {\n    const result: Record<string, DataPoint[]> = {};\n\n    for (const point of dataPoints) {\n      const value = extractor(point);\n\n      if (value !== undefined) {\n        const key = String(value);\n        if (!result[key]) {\n          result[key] = [];\n        }\n        result[key].push(point);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Optimized trend line calculation using single-pass algorithm\n   */\n  private calculateTrendLineOptimized(values: Array<{ x: unknown; y: number }>): {\n    slope: number;\n    intercept: number;\n  } {\n    if (values.length < 2) {\n      return { slope: 0, intercept: 0 };\n    }\n\n    // Convert x values to numbers for calculation\n    const points = values\n      .map(v => {\n        const xNum =\n          typeof v.x === 'number'\n            ? v.x\n            : v.x instanceof Date\n              ? v.x.getTime()\n              : parseFloat(String(v.x));\n\n        return isNaN(xNum) ? null : { x: xNum, y: v.y };\n      })\n      .filter(Boolean) as { x: number; y: number }[];\n\n    if (points.length < 2) {\n      return { slope: 0, intercept: 0 };\n    }\n\n    // Use optimized single-pass algorithm for calculating linear regression\n    let sumX = 0;\n    let sumY = 0;\n    let sumXY = 0;\n    let sumX2 = 0;\n    const n = points.length;\n\n    for (const point of points) {\n      sumX += point.x;\n      sumY += point.y;\n      sumXY += point.x * point.y;\n      sumX2 += point.x * point.x;\n    }\n\n    const denominator = n * sumX2 - sumX * sumX;\n\n    if (Math.abs(denominator) < 1e-10) {\n      return { slope: 0, intercept: sumY / n };\n    }\n\n    const slope = (n * sumXY - sumX * sumY) / denominator;\n    const intercept = (sumY - slope * sumX) / n;\n\n    return { slope, intercept };\n  }\n\n  /**\n   * Analyze correlation between variables with optimized algorithms\n   */\n  private async analyzeCorrelation(\n    config: CorrelationAnalysisConfig,\n    dataset: Dataset,\n    options: AlgorithmOptions\n  ): Promise<AnalysisResult> {\n    const startTime = Date.now();\n\n    // Extract parameters\n    const { variables, method = 'pearson', threshold = 0.5 } = config.parameters;\n\n    // Prepare the result data structure\n    const resultData: Record<string, unknown> = {\n      variables,\n      method,\n      threshold,\n      correlations: [],\n    };\n\n    // Create optimized property extractors for all variables\n    const extractors = variables.map(variable => this.getPropertyExtractor(variable));\n\n    // Pre-extract all values to optimize computation\n    const extractedValues: number[][] = [];\n\n    for (const extractor of extractors) {\n      const values = dataset.dataPoints\n        .map(point => {\n          const value = extractor(point);\n          return typeof value === 'number' ? value : undefined;\n        })\n        .filter((v): v is number => v !== undefined);\n\n      extractedValues.push(values);\n    }\n\n    // Calculate correlation for each pair of variables\n    const promises: Promise<{\n      var1: string;\n      var2: string;\n      coefficient: number;\n      strength: string;\n      sampleSize: number;\n    } | null>[] = [];\n\n    for (let i = 0; i < variables.length; i++) {\n      for (let j = i + 1; j < variables.length; j++) {\n        const var1 = variables[i];\n        const var2 = variables[j];\n\n        const values1 = extractedValues[i];\n        const values2 = extractedValues[j];\n\n        // Find common indices where both variables have values\n        const commonValues: { var1: number; var2: number }[] = [];\n\n        // Optimize by using Set for faster lookups\n        const values1Set = new Set(values1);\n\n        for (let k = 0; k < Math.min(values1.length, values2.length); k++) {\n          if (values1Set.has(values1[k]) && values2[k] !== undefined) {\n            commonValues.push({ var1: values1[k], var2: values2[k] });\n          }\n        }\n\n        // Skip if not enough data points\n        if (commonValues.length < 3) {\n          continue;\n        }\n\n        // Calculate correlation coefficient based on method\n        const promise = (async () => {\n          let coefficient: number;\n\n          const var1Values = commonValues.map(v => v.var1);\n          const var2Values = commonValues.map(v => v.var2);\n\n          switch (method) {\n            case 'pearson':\n              coefficient = this.calculatePearsonCorrelationOptimized(var1Values, var2Values);\n              break;\n            case 'spearman':\n              coefficient = this.calculateSpearmanCorrelationOptimized(var1Values, var2Values);\n              break;\n            case 'kendall':\n              coefficient = this.calculateKendallCorrelationOptimized(var1Values, var2Values);\n              break;\n            default:\n              coefficient = this.calculatePearsonCorrelationOptimized(var1Values, var2Values);\n          }\n\n          // Add to correlations if above threshold\n          if (Math.abs(coefficient) >= threshold) {\n            return {\n              var1,\n              var2,\n              coefficient,\n              strength: this.getCorrelationStrength(coefficient),\n              sampleSize: commonValues.length,\n            };\n          }\n\n          return null;\n        })();\n\n        promises.push(promise);\n      }\n    }\n\n    // Wait for all correlation calculations\n    const correlations = (await Promise.all(promises)).filter(Boolean);\n    resultData.correlations = correlations;\n\n    // Generate insights\n    const insights = this.generateCorrelationInsights(resultData);\n\n    // Create the result\n    const result: AnalysisResult = {\n      id: uuidv4(),\n      analysisConfigId: config.id,\n      status: 'completed',\n      startTime,\n      endTime: Date.now(),\n      data: resultData,\n      summary: this.generateCorrelationSummary(resultData),\n      insights,\n    };\n\n    return result;\n  }\n\n  /**\n   * Optimized Pearson correlation calculation\n   */\n  private calculatePearsonCorrelationOptimized(xValues: number[], yValues: number[]): number {\n    if (xValues.length !== yValues.length || xValues.length === 0) {\n      return 0;\n    }\n\n    // Use memoization for means\n    const xArrayKey = xValues.join(',');\n    const yArrayKey = yValues.join(',');\n\n    // Calculate or retrieve means\n    let xMean = this.memoizedMeans.get(xArrayKey);\n    if (xMean === undefined) {\n      xMean = xValues.reduce((sum, x) => sum + x, 0) / xValues.length;\n      this.memoizedMeans.set(xArrayKey, xMean);\n    }\n\n    let yMean = this.memoizedMeans.get(yArrayKey);\n    if (yMean === undefined) {\n      yMean = yValues.reduce((sum, y) => sum + y, 0) / yValues.length;\n      this.memoizedMeans.set(yArrayKey, yMean);\n    }\n\n    // Calculate correlation with optimized algorithm\n    let numerator = 0;\n    let xDenominator = 0;\n    let yDenominator = 0;\n\n    // Optimize loop by avoiding repeated subtraction operations\n    const xDiffs = new Float64Array(xValues.length);\n    const yDiffs = new Float64Array(yValues.length);\n\n    for (let i = 0; i < xValues.length; i++) {\n      xDiffs[i] = xValues[i] - xMean;\n      yDiffs[i] = yValues[i] - yMean;\n    }\n\n    for (let i = 0; i < xValues.length; i++) {\n      numerator += xDiffs[i] * yDiffs[i];\n      xDenominator += xDiffs[i] * xDiffs[i];\n      yDenominator += yDiffs[i] * yDiffs[i];\n    }\n\n    if (xDenominator === 0 || yDenominator === 0) {\n      return 0;\n    }\n\n    return numerator / Math.sqrt(xDenominator * yDenominator);\n  }\n\n  /**\n   * Optimized Spearman correlation calculation\n   */\n  private calculateSpearmanCorrelationOptimized(xValues: number[], yValues: number[]): number {\n    // Optimized implementation using faster ranking and cached calculations\n    const xRanks = this.rankValuesOptimized(xValues);\n    const yRanks = this.rankValuesOptimized(yValues);\n\n    return this.calculatePearsonCorrelationOptimized(xRanks, yRanks);\n  }\n\n  /**\n   * Optimized Kendall correlation calculation\n   */\n  private calculateKendallCorrelationOptimized(xValues: number[], yValues: number[]): number {\n    if (xValues.length !== yValues.length || xValues.length < 2) {\n      return 0;\n    }\n\n    const n = xValues.length;\n    let concordant = 0;\n    let discordant = 0;\n\n    // Optimize by using a more efficient algorithm for Kendall's tau\n    // This implementation has O(n log n) complexity rather than O(nÂ²)\n    const indices = Array.from({ length: n }, (_, i) => i);\n    indices.sort((i, j) => xValues[i] - xValues[j]);\n\n    // Count inversions (equivalent to counting discordant pairs)\n    const yValuesRanked = indices.map(i => yValues[i]);\n    discordant = this.countInversions(yValuesRanked);\n\n    // Calculate total possible pairs\n    const totalPairs = (n * (n - 1)) / 2;\n\n    // Concordant pairs = total pairs - discordant pairs\n    concordant = totalPairs - discordant;\n\n    // Calculate Kendall's tau coefficient\n    return (concordant - discordant) / totalPairs;\n  }\n\n  /**\n   * Count inversions in an array (used for Kendall's tau calculation)\n   * Using an efficient divide-and-conquer algorithm (merge sort based)\n   */\n  private countInversions(arr: number[]): number {\n    if (arr.length <= 1) return 0;\n\n    const mid = Math.floor(arr.length / 2);\n    const left = arr.slice(0, mid);\n    const right = arr.slice(mid);\n\n    // Recursively count inversions in left and right halves\n    let count = this.countInversions(left) + this.countInversions(right);\n\n    // Count inversions during merge\n    let i = 0,\n      j = 0,\n      k = 0;\n    const merged = new Array(arr.length);\n\n    while (i < left.length && j < right.length) {\n      if (left[i] <= right[j]) {\n        merged[k++] = left[i++];\n      } else {\n        // Inversion found - all remaining elements in left are inversions\n        merged[k++] = right[j++];\n        count += left.length - i;\n      }\n    }\n\n    // Copy remaining elements\n    while (i < left.length) merged[k++] = left[i++];\n    while (j < right.length) merged[k++] = right[j++];\n\n    // Copy merged array back to original\n    for (let i = 0; i < merged.length; i++) {\n      arr[i] = merged[i];\n    }\n\n    return count;\n  }\n\n  /**\n   * Optimized rank calculation for correlation methods\n   */\n  private rankValuesOptimized(values: number[]): number[] {\n    const n = values.length;\n    if (n <= 1) return values.slice();\n\n    // Create indexed values\n    const indexedValues = values.map((value, index) => ({ value, index }));\n\n    // Sort by value using a more efficient sort for numeric data\n    indexedValues.sort((a, b) => a.value - b.value);\n\n    // Optimize rank assignment with a single pass and linked structure\n    const ranks = new Float64Array(n);\n\n    let i = 0;\n    while (i < n) {\n      const value = indexedValues[i].value;\n\n      // Find all values equal to the current value\n      let j = i + 1;\n      while (j < n && indexedValues[j].value === value) {\n        j++;\n      }\n\n      // Calculate average rank for tied values\n      const rank = (i + j - 1) / 2 + 1;\n\n      // Assign ranks in a single pass\n      for (let k = i; k < j; k++) {\n        ranks[indexedValues[k].index] = rank;\n      }\n\n      i = j;\n    }\n\n    return Array.from(ranks);\n  }\n\n  /**\n   * Analyze distribution of a variable\n   */\n  private async analyzeDistribution(\n    config: DistributionAnalysisConfig,\n    dataset: Dataset,\n    options: AlgorithmOptions\n  ): Promise<AnalysisResult> {\n    const startTime = Date.now();\n\n    // Extract parameters\n    const { variable, bins = 10, normalize = false } = config.parameters;\n\n    // Extract values for the variable\n    const values = dataset.dataPoints\n      .map(point => {\n        const value = this.getPropertyByPath(point, variable);\n        return typeof value === 'number' ? value : null;\n      })\n      .filter(Boolean) as number[];\n\n    // Calculate distribution\n    const distribution = this.calculateDistribution(values, bins, normalize);\n\n    // Calculate statistics\n    const statistics = this.calculateStatistics(values);\n\n    // Prepare the result data\n    const resultData: Record<string, unknown> = {\n      variable,\n      bins,\n      normalize,\n      distribution,\n      statistics,\n    };\n\n    // Generate insights\n    const insights = this.generateDistributionInsights(resultData);\n\n    // Create the result\n    const result: AnalysisResult = {\n      id: uuidv4(),\n      analysisConfigId: config.id,\n      status: 'completed',\n      startTime,\n      endTime: Date.now(),\n      data: resultData,\n      summary: this.generateDistributionSummary(resultData),\n      insights,\n    };\n\n    return result;\n  }\n\n  /**\n   * Analyze clustering patterns in the dataset using k-means algorithm\n   */\n  private async analyzeClustering(\n    config: ClusteringAnalysisConfig,\n    dataset: Dataset,\n    options: AlgorithmOptions\n  ): Promise<AnalysisResult> {\n    const startTime = Date.now();\n\n    // Extract parameters from the config\n    const { variables, clusters: clusterCount = 3, method = 'kmeans' } = config.parameters;\n\n    // Map to the expected variable names\n    const features = variables;\n    const k = clusterCount;\n    const algorithm = method;\n    const maxIterations = 100;\n    const distanceMetric = 'euclidean';\n    const normalize = true;\n\n    // Validate input parameters\n    if (features.length < 1) {\n      return {\n        id: uuidv4(),\n        analysisConfigId: config.id,\n        status: 'failed',\n        startTime,\n        endTime: Date.now(),\n        data: {},\n        error: 'At least one feature must be specified for clustering analysis',\n      };\n    }\n\n    if (dataset.dataPoints.length < k) {\n      return {\n        id: uuidv4(),\n        analysisConfigId: config.id,\n        status: 'failed',\n        startTime,\n        endTime: Date.now(),\n        data: {},\n        error: `Not enough data points (${dataset.dataPoints.length}) for ${k} clusters`,\n      };\n    }\n\n    // Create extractors for each feature\n    const extractors = features.map(feature => this.getPropertyExtractor(feature));\n\n    // Extract feature vectors from data points\n    const featureVectors: number[][] = [];\n    const validIndices: number[] = [];\n\n    dataset.dataPoints.forEach((point, index) => {\n      const vector: number[] = [];\n      let valid = true;\n\n      // Extract each feature value\n      for (const extractor of extractors) {\n        const value = extractor(point);\n\n        if (typeof value === 'number' && !isNaN(value) && isFinite(value)) {\n          vector.push(value);\n        } else {\n          valid = false;\n          break;\n        }\n      }\n\n      if (valid && vector.length === features.length) {\n        featureVectors.push(vector);\n        validIndices.push(index);\n      }\n    });\n\n    // Not enough valid points for clustering\n    if (featureVectors.length < k) {\n      return {\n        id: uuidv4(),\n        analysisConfigId: config.id,\n        status: 'failed',\n        startTime,\n        endTime: Date.now(),\n        data: {},\n        error: `Not enough valid data points (${featureVectors.length}) for ${k} clusters`,\n      };\n    }\n\n    // Normalize feature vectors if specified\n    const normalizedVectors = options?.normalize\n      ? this.normalizeFeatureVectors(featureVectors)\n      : featureVectors;\n\n    // Run k-means clustering algorithm\n    const clusterResult = this.runKMeansClustering(\n      normalizedVectors,\n      k,\n      maxIterations,\n      distanceMetric\n    );\n\n    // Map cluster assignments back to original data points\n    const clusteredPoints = validIndices.map((originalIndex, vectorIndex) => {\n      const clusterIndex = clusterResult.clusters[vectorIndex];\n      const point = dataset.dataPoints[originalIndex];\n      const featureValues = features.map(feature => {\n        const value = this.getPropertyByPath(point, feature);\n        return typeof value === 'number' ? value : null;\n      });\n\n      return {\n        id: point.id,\n        name: point.name,\n        type: point.type,\n        cluster: clusterIndex,\n        features: featureValues,\n        distanceToCentroid: this.calculateDistance(\n          normalizedVectors[vectorIndex],\n          clusterResult.centroids[clusterIndex],\n          distanceMetric\n        ),\n      };\n    });\n\n    // Group points by cluster\n    const clusterGroups: Record<string, unknown[]> = {};\n    clusteredPoints.forEach(point => {\n      const clusterKey = String(point.cluster);\n      if (!clusterGroups[clusterKey]) {\n        clusterGroups[clusterKey] = [];\n      }\n      clusterGroups[clusterKey].push(point);\n    });\n\n    // Calculate statistics for each cluster\n    const clusterStats = Object.entries(clusterGroups).map(([clusterKey, points]) => {\n      const clusterIndex = parseInt(clusterKey, 10);\n      const centroid = clusterResult.centroids[clusterIndex];\n\n      // Calculate statistics for each feature within this cluster\n      const featureStats = features.map((feature: string, featureIndex: number) => {\n        const typedPoints = points as Array<{ features: number[]; id: string }>;\n        const values = typedPoints\n          .map(p => p.features[featureIndex])\n          .filter((v: unknown): v is number => v !== null);\n\n        return {\n          feature,\n          mean:\n            values.length > 0\n              ? values.reduce((sum: number, v: number) => sum + v, 0) / values.length\n              : 0,\n          min: values.length > 0 ? Math.min(...values) : 0,\n          max: values.length > 0 ? Math.max(...values) : 0,\n          count: values.length,\n        };\n      });\n\n      return {\n        cluster: clusterIndex,\n        size: points.length,\n        percentage: (points.length / clusteredPoints.length) * 100,\n        centroid,\n        featureStats,\n        pointIds: (points as Array<{ id: string }>).map(p => p.id),\n      };\n    });\n\n    // Prepare result data\n    const resultData: Record<string, unknown> = {\n      algorithm,\n      features,\n      k,\n      distanceMetric,\n      inertia: clusterResult.inertia,\n      clusters: clusterStats,\n      normalized: options?.normalize,\n    };\n\n    // Generate insights and summary\n    const insights = this.generateClusteringInsights(resultData);\n    const summary = this.generateClusteringSummary(resultData);\n\n    // Create the result\n    const result: AnalysisResult = {\n      id: uuidv4(),\n      analysisConfigId: config.id,\n      status: 'completed',\n      startTime,\n      endTime: Date.now(),\n      data: resultData,\n      summary,\n      insights,\n    };\n\n    return result;\n  }\n\n  /**\n   * Normalize feature vectors using z-score normalization\n   */\n  private normalizeFeatureVectors(vectors: number[][]): number[][] {\n    if (vectors.length === 0) return [];\n\n    const dimensions = vectors[0].length;\n    const means = new Array(dimensions).fill(0);\n    const stdDevs = new Array(dimensions).fill(0);\n\n    // Calculate means\n    for (const vector of vectors) {\n      for (let d = 0; d < dimensions; d++) {\n        means[d] += vector[d];\n      }\n    }\n\n    for (let d = 0; d < dimensions; d++) {\n      means[d] /= vectors.length;\n    }\n\n    // Calculate standard deviations\n    for (const vector of vectors) {\n      for (let d = 0; d < dimensions; d++) {\n        stdDevs[d] += Math.pow(vector[d] - means[d], 2);\n      }\n    }\n\n    for (let d = 0; d < dimensions; d++) {\n      stdDevs[d] = Math.sqrt(stdDevs[d] / vectors.length);\n    }\n\n    // Apply z-score normalization\n    return vectors.map(vector =>\n      vector.map((value, d) => (stdDevs[d] > 0 ? (value - means[d]) / stdDevs[d] : 0))\n    );\n  }\n\n  /**\n   * Run k-means clustering algorithm on feature vectors\n   */\n  private runKMeansClustering(\n    vectors: number[][],\n    k: number,\n    maxIterations: number,\n    distanceMetric: string\n  ): {\n    clusters: number[];\n    centroids: number[][];\n    inertia: number;\n  } {\n    const n = vectors.length;\n    const dimensions = vectors[0].length;\n\n    // Initialize centroids using k-means++ method\n    const centroids = this.initializeKMeansPlusPlusCentroids(vectors, k, distanceMetric);\n\n    // Initialize cluster assignments\n    const clusters = new Array(n).fill(0);\n    let prevClusters = new Array(n).fill(-1);\n    let iteration = 0;\n\n    // Repeat until convergence or max iterations reached\n    while (!this.arraysEqual(clusters, prevClusters) && iteration < maxIterations) {\n      // Store previous cluster assignments\n      prevClusters = [...clusters];\n\n      // Assign each point to the nearest centroid\n      for (let i = 0; i < n; i++) {\n        const vector = vectors[i];\n        let minDistance = Infinity;\n        let nearestCluster = 0;\n\n        for (let j = 0; j < k; j++) {\n          const distance = this.calculateDistance(vector, centroids[j], distanceMetric);\n          if (distance < minDistance) {\n            minDistance = distance;\n            nearestCluster = j;\n          }\n        }\n\n        clusters[i] = nearestCluster;\n      }\n\n      // Update centroids based on new cluster assignments\n      const newCentroids: number[][] = Array(k)\n        .fill(0)\n        .map(() => Array(dimensions).fill(0));\n      const counts = Array(k).fill(0);\n\n      for (let i = 0; i < n; i++) {\n        const cluster = clusters[i];\n        counts[cluster]++;\n\n        for (let d = 0; d < dimensions; d++) {\n          newCentroids[cluster][d] += vectors[i][d];\n        }\n      }\n\n      // Calculate new centroid as average of points in cluster\n      for (let j = 0; j < k; j++) {\n        // Handle empty clusters by reinitializing with a random point\n        if (counts[j] === 0) {\n          const randomIndex = Math.floor(Math.random() * n);\n          newCentroids[j] = [...vectors[randomIndex]];\n        } else {\n          for (let d = 0; d < dimensions; d++) {\n            newCentroids[j][d] /= counts[j];\n          }\n        }\n      }\n\n      centroids.splice(0, centroids.length, ...newCentroids);\n      iteration++;\n    }\n\n    // Calculate inertia (sum of squared distances to nearest centroid)\n    const inertia = vectors.reduce((sum, vector, i) => {\n      const centroid = centroids[clusters[i]];\n      const distance = this.calculateDistance(vector, centroid, distanceMetric);\n      return sum + distance * distance;\n    }, 0);\n\n    return { clusters, centroids, inertia };\n  }\n\n  /**\n   * Initialize k-means centroids using k-means++ algorithm\n   * This gives better initial centroids than random selection\n   */\n  private initializeKMeansPlusPlusCentroids(\n    vectors: number[][],\n    k: number,\n    distanceMetric: string\n  ): number[][] {\n    const n = vectors.length;\n    const centroids: number[][] = [];\n\n    // Choose first centroid randomly\n    const firstIndex = Math.floor(Math.random() * n);\n    centroids.push([...vectors[firstIndex]]);\n\n    // Choose remaining centroids using weighted probabilities\n    for (let i = 1; i < k; i++) {\n      // Calculate minimum distance from each point to any existing centroid\n      const distances = vectors.map(vector => {\n        const minDistance = centroids.reduce((min, centroid) => {\n          const distance = this.calculateDistance(vector, centroid, distanceMetric);\n          return Math.min(min, distance);\n        }, Infinity);\n        return minDistance * minDistance; // Square the distance for weighted probability\n      });\n\n      // Calculate sum of squared distances\n      const distanceSum = distances.reduce((sum, distance) => sum + distance, 0);\n\n      // Choose next centroid with probability proportional to squared distance\n      let random = Math.random() * distanceSum;\n      let index = 0;\n\n      while (index < n && random > 0) {\n        random -= distances[index];\n        index++;\n      }\n\n      // Adjust index since we incremented one extra time\n      index = Math.max(0, index - 1);\n\n      centroids.push([...vectors[index]]);\n    }\n\n    return centroids;\n  }\n\n  /**\n   * Calculate distance between two vectors\n   */\n  private calculateDistance(a: number[], b: number[], metric: string = 'euclidean'): number {\n    switch (metric) {\n      case 'euclidean':\n        return Math.sqrt(a.reduce((sum, val, i) => sum + Math.pow(val - b[i], 2), 0));\n\n      case 'manhattan':\n        return a.reduce((sum, val, i) => sum + Math.abs(val - b[i]), 0);\n\n      case 'cosine': {\n        const dotProduct = a.reduce((sum, val, i) => sum + val * b[i], 0);\n        const magnitudeA = Math.sqrt(a.reduce((sum, val) => sum + val * val, 0));\n        const magnitudeB = Math.sqrt(b.reduce((sum, val) => sum + val * val, 0));\n\n        if (magnitudeA === 0 || magnitudeB === 0) return 1; // Maximum distance\n        return 1 - dotProduct / (magnitudeA * magnitudeB);\n      }\n\n      default:\n        return Math.sqrt(a.reduce((sum, val, i) => sum + Math.pow(val - b[i], 2), 0));\n    }\n  }\n\n  /**\n   * Check if two arrays are equal\n   */\n  private arraysEqual(a: unknown[], b: unknown[]): boolean {\n    if (a.length !== b.length) return false;\n\n    for (let i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Generate insights about clustering results\n   */\n  private generateClusteringInsights(data: Record<string, unknown>): string[] {\n    const insights: string[] = [];\n\n    // Extract relevant data\n    const numClusters = data.numClusters ? (data.numClusters as number) : 0;\n    const inertia = data.inertia ? (data.inertia as number) : undefined;\n    const clusters = data.clusters\n      ? (data.clusters as Array<{\n          id: number;\n          size: number;\n          featureStats: Array<{\n            feature: string;\n            mean: number;\n            min: number;\n            max: number;\n          }>;\n        }>)\n      : [];\n\n    // Generate general insights\n    if (numClusters > 0) {\n      // Check for imbalanced clusters\n      const clusterSizes = clusters.map(c => (c as { size: number }).size);\n      const maxSize = Math.max(...clusterSizes);\n      const minSize = Math.min(...clusterSizes);\n      const sizeRatio = maxSize / minSize;\n\n      if (sizeRatio > 5) {\n        insights.push(\n          `The clusters are highly imbalanced. The largest cluster is ${sizeRatio.toFixed(1)}x larger than the smallest.`\n        );\n      } else if (sizeRatio > 2) {\n        insights.push(\n          `The clusters show some size variation. The largest cluster is ${sizeRatio.toFixed(1)}x larger than the smallest.`\n        );\n      } else {\n        insights.push(`The clusters are relatively balanced in size.`);\n      }\n\n      // Add algorithm-specific insights\n      if (data.algorithm === 'kmeans') {\n        insights.push(\n          `K-means clustering identified ${numClusters} clusters based on the specified features.`\n        );\n\n        // Check inertia\n        if (inertia !== undefined) {\n          insights.push(\n            `The clustering has an inertia (sum of squared distances) of ${inertia.toFixed(2)}.`\n          );\n        }\n      }\n\n      // Add feature-specific insights\n      clusters.forEach(\n        (\n          cluster: {\n            id: number;\n            size: number;\n            featureStats: Array<{\n              feature: string;\n              mean: number;\n              min: number;\n              max: number;\n            }>;\n          },\n          i\n        ) => {\n          // Find distinctive features for this cluster\n          const distinctiveFeatures = cluster.featureStats\n            .filter(stat => stat.mean > 0.5 || stat.mean < -0.5)\n            .sort((a, b) => Math.abs(b.mean) - Math.abs(a.mean));\n\n          if (distinctiveFeatures.length > 0) {\n            const topFeature = distinctiveFeatures[0];\n            const featureType = topFeature.mean > 0 ? 'high' : 'low';\n\n            insights.push(\n              `Cluster ${cluster.id} is characterized by ${featureType} values of ${topFeature.feature}.`\n            );\n          }\n        }\n      );\n    }\n\n    return insights;\n  }\n\n  /**\n   * Generate summary of clustering results\n   */\n  private generateClusteringSummary(data: Record<string, unknown>): string {\n    const algorithm = data?.algorithm as string;\n    const k = data?.k as number;\n    const features = data?.features as string[];\n\n    let summary = `Clustering analysis using ${algorithm} algorithm identified ${k} clusters`;\n\n    if (features && features.length > 0) {\n      summary += ` based on the following features: ${features.join(', ')}.`;\n    } else {\n      summary += '.';\n    }\n\n    return summary;\n  }\n\n  /**\n   * Helper method to sort data points by a property\n   */\n  private sortDataPoints(dataPoints: DataPoint[], property: string): DataPoint[] {\n    return [...dataPoints].sort((a, b) => {\n      const aValue = this.getPropertyByPath(a, property);\n      const bValue = this.getPropertyByPath(b, property);\n\n      if (aValue === undefined) return 1;\n      if (bValue === undefined) return -1;\n\n      if (typeof aValue === 'number' && typeof bValue === 'number') {\n        return aValue - bValue;\n      }\n\n      return String(aValue).localeCompare(String(bValue));\n    });\n  }\n\n  /**\n   * Helper method to group data points by a property\n   */\n  private groupDataByProperty(\n    dataPoints: DataPoint[],\n    property: string\n  ): Record<string, DataPoint[]> {\n    const groups: Record<string, DataPoint[]> = {};\n\n    for (const point of dataPoints) {\n      const value = this.getPropertyByPath(point, property);\n      if (value === undefined) continue;\n\n      const groupKey = String(value);\n      if (!groups[groupKey]) {\n        groups[groupKey] = [];\n      }\n\n      groups[groupKey].push(point);\n    }\n\n    return groups;\n  }\n\n  /**\n   * Helper method to get a property value using a dot-notation path\n   */\n  private getPropertyByPath(obj: Record<string, unknown>, path: string): unknown {\n    const parts = path.split('.');\n    let value: unknown = obj;\n\n    for (const part of parts) {\n      if (value === undefined || value === null) {\n        return undefined;\n      }\n\n      value = (value as Record<string, unknown>)[part];\n    }\n\n    return value;\n  }\n\n  /**\n   * Helper method to aggregate values\n   */\n  private aggregateValues(\n    values: Array<{ x: unknown; y: number }>,\n    aggregation: 'sum' | 'average' | 'min' | 'max' | 'count'\n  ): Array<{ x: unknown; y: number }> {\n    // Group by x value\n    const groups = new Map<unknown, number[]>();\n\n    for (const { x, y } of values) {\n      if (!groups.has(x)) {\n        groups.set(x, []);\n      }\n\n      groups.get(x)!.push(y);\n    }\n\n    // Aggregate each group\n    const result: Array<{ x: unknown; y: number }> = [];\n\n    for (const [x, yValues] of groups.entries()) {\n      let aggregatedValue: number;\n\n      switch (aggregation) {\n        case 'sum':\n          aggregatedValue = yValues.reduce((sum, value) => sum + value, 0);\n          break;\n        case 'average':\n          aggregatedValue = yValues.reduce((sum, value) => sum + value, 0) / yValues.length;\n          break;\n        case 'min':\n          aggregatedValue = Math.min(...yValues);\n          break;\n        case 'max':\n          aggregatedValue = Math.max(...yValues);\n          break;\n        case 'count':\n          aggregatedValue = yValues.length;\n          break;\n        default:\n          aggregatedValue = yValues.reduce((sum, value) => sum + value, 0);\n      }\n\n      result?.push({ x, y: aggregatedValue });\n    }\n\n    // Sort by x value\n    return result?.sort((a, b) => {\n      if (typeof a.x === 'number' && typeof b.x === 'number') {\n        return a.x - b.x;\n      }\n\n      return String(a.x).localeCompare(String(b.x));\n    });\n  }\n\n  /**\n   * Calculate Pearson correlation coefficient between two sets of values\n   */\n  private calculatePearsonCorrelation(xValues: number[], yValues: number[]): number {\n    if (xValues.length !== yValues.length || xValues.length === 0) {\n      return 0;\n    }\n\n    // Calculate means\n    const xMean = xValues.reduce((sum, x) => sum + x, 0) / xValues.length;\n    const yMean = yValues.reduce((sum, y) => sum + y, 0) / yValues.length;\n\n    // Calculate terms for correlation\n    let numerator = 0;\n    let xDenominator = 0;\n    let yDenominator = 0;\n\n    for (let i = 0; i < xValues.length; i++) {\n      const xDiff = xValues[i] - xMean;\n      const yDiff = yValues[i] - yMean;\n\n      numerator += xDiff * yDiff;\n      xDenominator += xDiff * xDiff;\n      yDenominator += yDiff * yDiff;\n    }\n\n    if (xDenominator === 0 || yDenominator === 0) {\n      return 0;\n    }\n\n    return numerator / Math.sqrt(xDenominator * yDenominator);\n  }\n\n  /**\n   * Calculate Spearman correlation coefficient (placeholder implementation)\n   */\n  private calculateSpearmanCorrelation(xValues: number[], yValues: number[]): number {\n    // Simplified implementation - in a real system this would be more complex\n    return this.calculatePearsonCorrelation(this.rankValues(xValues), this.rankValues(yValues));\n  }\n\n  /**\n   * Calculate Kendall correlation coefficient (placeholder implementation)\n   */\n  private calculateKendallCorrelation(xValues: number[], yValues: number[]): number {\n    // Simplified placeholder - in a real system this would be properly implemented\n    return (\n      this.calculatePearsonCorrelation(this.rankValues(xValues), this.rankValues(yValues)) * 0.9\n    ); // Adjusting factor for demonstration\n  }\n\n  /**\n   * Convert values to ranks for rank-based correlation methods\n   */\n  private rankValues(values: number[]): number[] {\n    // Create indexed values\n    const indexedValues = values.map((value, index) => ({ value, index }));\n\n    // Sort by value\n    indexedValues.sort((a, b) => a.value - b.value);\n\n    // Assign ranks (with ties handled by averaging)\n    const ranks = new Array(values.length).fill(0);\n\n    let i = 0;\n    while (i < indexedValues.length) {\n      const value = indexedValues[i].value;\n\n      // Find all values equal to the current value\n      let j = i + 1;\n      while (j < indexedValues.length && indexedValues[j].value === value) {\n        j++;\n      }\n\n      // Assign average rank to all tied values\n      const rank = (i + j - 1) / 2 + 1;\n      for (let k = i; k < j; k++) {\n        ranks[indexedValues[k].index] = rank;\n      }\n\n      i = j;\n    }\n\n    return ranks;\n  }\n\n  /**\n   * Calculate linear trend line\n   */\n  private calculateTrendLine(values: Array<{ x: unknown; y: number }>): {\n    slope: number;\n    intercept: number;\n  } {\n    if (values.length < 2) {\n      return { slope: 0, intercept: 0 };\n    }\n\n    // Convert x values to numbers (assume date values or indices if not numbers)\n    const xyValues = values.map((value, index) => ({\n      x: typeof value.x === 'number' ? value.x : index,\n      y: value.y,\n    }));\n\n    // Calculate means\n    const xMean = xyValues.reduce((sum, { x }) => sum + (x as number), 0) / xyValues.length;\n    const yMean = xyValues.reduce((sum, { y }) => sum + y, 0) / xyValues.length;\n\n    // Calculate slope and intercept using least squares method\n    let numerator = 0;\n    let denominator = 0;\n\n    for (const { x, y } of xyValues) {\n      const xDiff = (x as number) - xMean;\n      numerator += xDiff * (y - yMean);\n      denominator += xDiff * xDiff;\n    }\n\n    if (denominator === 0) {\n      return { slope: 0, intercept: yMean };\n    }\n\n    const slope = numerator / denominator;\n    const intercept = yMean - slope * xMean;\n\n    return { slope, intercept };\n  }\n\n  /**\n   * Calculate distribution\n   */\n  private calculateDistribution(\n    values: number[],\n    bins: number,\n    normalize: boolean\n  ): Array<{\n    binStart: number;\n    binEnd: number;\n    count: number;\n    normalizedCount?: number;\n  }> {\n    if (values.length === 0) {\n      return [];\n    }\n\n    // Calculate range\n    const min = Math.min(...values);\n    const max = Math.max(...values);\n    const range = max - min;\n\n    // Handle special case where all values are the same\n    if (range === 0) {\n      return [\n        {\n          binStart: min,\n          binEnd: max,\n          count: values.length,\n          normalizedCount: normalize ? 1 : undefined,\n        },\n      ];\n    }\n\n    // Calculate bin width\n    const binWidth = range / bins;\n\n    // Initialize bins\n    const distribution: DistributionBin[] = Array.from({ length: bins }, (_, i) => {\n      const binStart = min + i * binWidth;\n      const binEnd = binStart + binWidth;\n\n      return {\n        binStart,\n        binEnd,\n        count: 0,\n        normalizedCount: undefined, // Set to undefined initially\n      };\n    });\n\n    // Count values in each bin\n    for (const value of values) {\n      const binIndex = Math.min(\n        Math.floor((value - min) / binWidth),\n        bins - 1 // Handle edge case where value === max\n      );\n\n      distribution[binIndex].count++;\n    }\n\n    // Normalize counts if requested\n    if (normalize) {\n      const maxCount = Math.max(...distribution.map(bin => bin.count));\n      for (const bin of distribution) {\n        // Now this assignment is safe because normalizedCount is optional\n        bin.normalizedCount = bin.count / (maxCount || 1);\n      }\n    }\n\n    return distribution;\n  }\n\n  /**\n   * Calculate statistics for a set of values\n   */\n  private calculateStatistics(values: number[]): Record<string, number> {\n    if (values.length === 0) {\n      return {\n        count: 0,\n        min: 0,\n        max: 0,\n        mean: 0,\n        median: 0,\n        standardDeviation: 0,\n        variance: 0,\n      };\n    }\n\n    // Sort values for median and quartiles\n    const sortedValues = [...values].sort((a, b) => a - b);\n\n    // Calculate basic statistics\n    const count = values.length;\n    const min = sortedValues[0];\n    const max = sortedValues[count - 1];\n    const sum = values.reduce((sum, value) => sum + value, 0);\n    const mean = sum / count;\n\n    // Calculate median\n    const midIndex = Math.floor(count / 2);\n    const median =\n      count % 2 === 0\n        ? (sortedValues[midIndex - 1] + sortedValues[midIndex]) / 2\n        : sortedValues[midIndex];\n\n    // Calculate variance and standard deviation\n    const squaredDiffs = values.map(value => Math.pow(value - mean, 2));\n    const variance = squaredDiffs.reduce((sum, value) => sum + value, 0) / count;\n    const standardDeviation = Math.sqrt(variance);\n\n    // Calculate quartiles\n    const q1Index = Math.floor(count / 4);\n    const q3Index = Math.floor((3 * count) / 4);\n    const q1 = sortedValues[q1Index];\n    const q3 = sortedValues[q3Index];\n    const interquartileRange = q3 - q1;\n\n    return {\n      count,\n      min,\n      max,\n      mean,\n      median,\n      standardDeviation,\n      variance,\n      q1,\n      q3,\n      interquartileRange,\n      range: max - min,\n    };\n  }\n\n  /**\n   * Generate insights for trend analysis\n   */\n  private generateTrendInsights(data: Record<string, unknown>): string[] {\n    const insights: string[] = [];\n    const groups = data?.groups as Record<\n      string,\n      { values: unknown[]; trendLine: { slope: number; intercept: number } }\n    >;\n\n    // Add insights for each group\n    for (const [group, groupData] of Object.entries(groups)) {\n      const { values, trendLine } = groupData;\n\n      if (values.length === 0) continue;\n\n      // Add insight about trend direction\n      if (Math.abs(trendLine.slope) < 0.001) {\n        insights.push(`The ${group} group shows a stable trend with minimal change.`);\n      } else if (trendLine.slope > 0) {\n        insights.push(\n          `The ${group} group shows an increasing trend with a slope of ${trendLine.slope.toFixed(3)}.`\n        );\n      } else {\n        insights.push(\n          `The ${group} group shows a decreasing trend with a slope of ${trendLine.slope.toFixed(3)}.`\n        );\n      }\n\n      // Add insight about data points\n      insights.push(`Analysis of ${group} is based on ${values.length} data points.`);\n    }\n\n    return insights;\n  }\n\n  /**\n   * Generate a summary for trend analysis\n   */\n  private generateTrendSummary(data: Record<string, unknown>): string {\n    const groups = data?.groups as Record<\n      string,\n      { values: unknown[]; trendLine: { slope: number; intercept: number } }\n    >;\n    const groupCount = Object.keys(groups).length;\n\n    if (groupCount === 0) {\n      return 'No valid data found for trend analysis.';\n    }\n\n    if (groupCount === 1) {\n      const [group, groupData] = Object.entries(groups)[0];\n      const { trendLine } = groupData;\n\n      if (Math.abs(trendLine.slope) < 0.001) {\n        return `Analysis shows a stable trend for ${group} with minimal change over time.`;\n      } else if (trendLine.slope > 0) {\n        return `Analysis shows an increasing trend for ${group} over time.`;\n      } else {\n        return `Analysis shows a decreasing trend for ${group} over time.`;\n      }\n    }\n\n    return `Analysis of ${groupCount} groups shows varying trends over time.`;\n  }\n\n  /**\n   * Generate insights for correlation analysis\n   */\n  private generateCorrelationInsights(data: Record<string, unknown>): string[] {\n    const insights: string[] = [];\n    const correlations = data?.correlations as Array<{\n      variables: string[];\n      coefficient: number;\n      strength: string;\n      sampleSize: number;\n    }>;\n\n    if (correlations.length === 0) {\n      insights.push('No significant correlations were found between the analyzed variables.');\n      return insights;\n    }\n\n    // Sort correlations by absolute coefficient value\n    correlations.sort((a, b) => Math.abs(b.coefficient) - Math.abs(a.coefficient));\n\n    // Add insight for strongest correlation\n    const strongest = correlations[0];\n    insights.push(\n      `The strongest correlation is between \"${strongest.variables[0]}\" and \"${strongest.variables[1]}\" with a ${strongest.strength} coefficient of ${strongest.coefficient.toFixed(3)}.`\n    );\n\n    // Add insights for positive and negative correlations\n    const positiveCorrelations = correlations.filter(c => c.coefficient > 0);\n    const negativeCorrelations = correlations.filter(c => c.coefficient < 0);\n\n    if (positiveCorrelations.length > 0) {\n      insights.push(\n        `Found ${positiveCorrelations.length} positive correlations among the variables.`\n      );\n    }\n\n    if (negativeCorrelations.length > 0) {\n      insights.push(\n        `Found ${negativeCorrelations.length} negative correlations among the variables.`\n      );\n    }\n\n    return insights;\n  }\n\n  /**\n   * Generate a summary for correlation analysis\n   */\n  private generateCorrelationSummary(data: Record<string, unknown>): string {\n    const correlations = data?.correlations as Array<{\n      variables: string[];\n      coefficient: number;\n      strength: string;\n      sampleSize: number;\n    }>;\n\n    if (correlations.length === 0) {\n      return 'No significant correlations were found between the analyzed variables.';\n    }\n\n    return `Found ${correlations.length} significant correlations among the analyzed variables.`;\n  }\n\n  /**\n   * Generate insights for distribution analysis\n   */\n  private generateDistributionInsights(data: Record<string, unknown>): string[] {\n    const insights: string[] = [];\n    const statistics = data?.statistics as Record<string, number>;\n\n    if (!statistics) {\n      return ['No valid statistics found for distribution analysis.'];\n    }\n\n    // Add insight about central tendency\n    insights.push(\n      `The mean value is ${statistics.mean.toFixed(2)} and the median is ${statistics.median.toFixed(2)}.`\n    );\n\n    // Add insight about dispersion\n    insights.push(\n      `The data has a standard deviation of ${statistics.standardDeviation.toFixed(2)} and a range of ${statistics.range.toFixed(2)}.`\n    );\n\n    // Add insight about distribution shape\n    const skewness = (statistics.mean - statistics.median) / statistics.standardDeviation;\n    if (Math.abs(skewness) < 0.1) {\n      insights.push('The distribution appears to be approximately symmetric.');\n    } else if (skewness > 0) {\n      insights.push('The distribution shows a positive skew (tail extends to the right).');\n    } else {\n      insights.push('The distribution shows a negative skew (tail extends to the left).');\n    }\n\n    return insights;\n  }\n\n  /**\n   * Generate a summary for distribution analysis\n   */\n  private generateDistributionSummary(data: Record<string, unknown>): string {\n    const statistics = data?.statistics as Record<string, number>;\n\n    if (!statistics) {\n      return 'No valid statistics found for distribution analysis.';\n    }\n\n    return `Distribution analysis of ${data?.variable} with mean=${statistics.mean.toFixed(2)} and SD=${statistics.standardDeviation.toFixed(2)}.`;\n  }\n\n  /**\n   * Get correlation strength description based on coefficient\n   */\n  private getCorrelationStrength(coefficient: number): string {\n    const absoluteCoefficient = Math.abs(coefficient);\n\n    if (absoluteCoefficient < 0.3) {\n      return 'weak';\n    } else if (absoluteCoefficient < 0.7) {\n      return 'moderate';\n    } else {\n      return 'strong';\n    }\n  }\n\n  /**\n   * Analyze data to generate predictions using various models\n   */\n  private async analyzePrediction(\n    config: PredictionAnalysisConfig,\n    dataset: Dataset,\n    options: AlgorithmOptions\n  ): Promise<AnalysisResult> {\n    const startTime = Date.now();\n\n    // Extract parameters from config\n    const { target, features = [], method = 'linear', testSize = 0.2 } = config.parameters;\n\n    // Map to the expected variable names\n    const targetVariable = target;\n    const model = method;\n    const testSplit = testSize;\n    const epochs = 100; // Default value for neural network\n    const predictionHorizon = 1; // Default prediction horizon\n\n    // Validate input parameters\n    if (!targetVariable) {\n      return {\n        id: uuidv4(),\n        analysisConfigId: config.id,\n        status: 'failed',\n        startTime,\n        endTime: Date.now(),\n        data: {},\n        error: 'Target variable must be specified for prediction analysis',\n      };\n    }\n\n    if (dataset.dataPoints.length < 10) {\n      return {\n        id: uuidv4(),\n        analysisConfigId: config.id,\n        status: 'failed',\n        startTime,\n        endTime: Date.now(),\n        data: {},\n        error: 'Insufficient data points for prediction analysis (minimum 10 required)',\n      };\n    }\n\n    // Create extractors for each feature and the target variable\n    const featureExtractors = features.map(feature => this.getPropertyExtractor(feature));\n    const targetExtractor = this.getPropertyExtractor(targetVariable);\n\n    // Extract feature vectors and target values\n    const dataPoints: Array<{\n      features: number[];\n      target: number;\n      date?: number;\n      original: DataPoint;\n    }> = [];\n\n    dataset.dataPoints.forEach(point => {\n      // Extract feature values\n      const featureValues: number[] = [];\n      let allFeaturesValid = true;\n\n      // Extract each feature value\n      for (const extractor of featureExtractors) {\n        const value = extractor(point);\n\n        if (typeof value === 'number' && !isNaN(value) && isFinite(value)) {\n          featureValues.push(value);\n        } else {\n          allFeaturesValid = false;\n          break;\n        }\n      }\n\n      // Extract target value\n      const targetValue = targetExtractor(point);\n\n      if (\n        allFeaturesValid &&\n        typeof targetValue === 'number' &&\n        !isNaN(targetValue) &&\n        isFinite(targetValue)\n      ) {\n        dataPoints.push({\n          features: featureValues,\n          target: targetValue,\n          date: point.date, // For time series forecasting\n          original: point,\n        });\n      }\n    });\n\n    // Sort data by date if available (for time series)\n    if (dataPoints.length > 0 && dataPoints[0].date !== undefined) {\n      dataPoints.sort((a, b) => (a.date ?? 0) - (b.date ?? 0));\n    }\n\n    // Split data into training and testing sets\n    const splitIndex = Math.floor(dataPoints.length * (1 - testSplit));\n    const trainingData = dataPoints.slice(0, splitIndex);\n    const testingData = dataPoints.slice(splitIndex);\n\n    // Train the appropriate prediction model\n    let modelResult: {\n      predictions: Array<{\n        features: number[];\n        actual: number;\n        predicted: number;\n        error?: number;\n      }>;\n      forecast: Array<{\n        features: number[];\n        predicted: number;\n        confidence?: [number, number]; // Lower and upper bounds\n      }>;\n      metrics: {\n        mse: number;\n        rmse: number;\n        mae: number;\n        r2?: number;\n      };\n      modelDetails: Record<string, unknown>;\n    };\n\n    switch (model) {\n      case 'linear':\n        modelResult = this.runLinearRegression(\n          trainingData,\n          testingData,\n          features,\n          predictionHorizon\n        );\n        break;\n      case 'neuralNetwork':\n        modelResult = await this.runNeuralNetwork(\n          trainingData,\n          testingData,\n          features,\n          predictionHorizon,\n          epochs\n        );\n        break;\n      default:\n        modelResult = this.runLinearRegression(\n          trainingData,\n          testingData,\n          features,\n          predictionHorizon\n        );\n    }\n\n    // Generate insights and prepare result data\n    const resultData: Record<string, unknown> = {\n      model,\n      targetVariable,\n      features,\n      predictionHorizon,\n      dataPointCount: dataPoints.length,\n      trainTestSplit: {\n        training: trainingData.length,\n        testing: testingData.length,\n        ratio: 1 - testSplit,\n      },\n      metrics: modelResult.metrics,\n      predictions: modelResult.predictions,\n      forecast: modelResult.forecast,\n      modelDetails: modelResult.modelDetails,\n    };\n\n    // Generate insights about the prediction model\n    const insights = this.generatePredictionInsights(resultData);\n\n    // Create the result\n    const result: AnalysisResult = {\n      id: uuidv4(),\n      analysisConfigId: config.id,\n      status: 'completed',\n      startTime,\n      endTime: Date.now(),\n      data: resultData,\n      summary: this.generatePredictionSummary(resultData),\n      insights,\n    };\n\n    return result;\n  }\n\n  /**\n   * Run linear regression model for prediction\n   */\n  private runLinearRegression(\n    trainingData: Array<{\n      features: number[];\n      target: number;\n      date?: number;\n      original: DataPoint;\n    }>,\n    testingData: Array<{\n      features: number[];\n      target: number;\n      date?: number;\n      original: DataPoint;\n    }>,\n    featureNames: string[],\n    predictionHorizon: number\n  ): {\n    predictions: Array<{\n      features: number[];\n      actual: number;\n      predicted: number;\n      error?: number;\n    }>;\n    forecast: Array<{\n      features: number[];\n      predicted: number;\n      confidence?: [number, number];\n    }>;\n    metrics: {\n      mse: number;\n      rmse: number;\n      mae: number;\n      r2: number;\n    };\n    modelDetails: Record<string, unknown>;\n  } {\n    // Extract feature and target matrices\n    const X_train = trainingData.map(point => point.features);\n    const y_train = trainingData.map(point => point.target);\n\n    const X_test = testingData.map(point => point.features);\n    const y_test = testingData.map(point => point.target);\n\n    // Add bias term (intercept) to feature matrices\n    const X_train_with_bias = X_train.map(features => [1, ...features]);\n    const X_test_with_bias = X_test.map(features => [1, ...features]);\n\n    // Calculate coefficients using normal equation\n    // (X^T * X)^(-1) * X^T * y\n    const coefficients = this.calculateLinearRegressionCoefficients(X_train_with_bias, y_train);\n\n    // Make predictions on test set\n    const testPredictions = X_test_with_bias.map(features =>\n      features.reduce((sum, value, index) => sum + value * coefficients[index], 0)\n    );\n\n    // Calculate metrics\n    const errors = testPredictions.map((predicted, i) => predicted - y_test[i]);\n    const squaredErrors = errors.map(error => error * error);\n    const absErrors = errors.map(error => Math.abs(error));\n\n    const mse = squaredErrors.reduce((sum, sq) => sum + sq, 0) / squaredErrors.length;\n    const rmse = Math.sqrt(mse);\n    const mae = absErrors.reduce((sum, abs) => sum + abs, 0) / absErrors.length;\n\n    // Calculate R^2 (coefficient of determination)\n    const mean_y = y_test.reduce((sum, y) => sum + y, 0) / y_test.length;\n    const total_variance = y_test.reduce((sum, y) => sum + Math.pow(y - mean_y, 2), 0);\n    const r2 = 1 - squaredErrors.reduce((sum, sq) => sum + sq, 0) / total_variance;\n\n    // Create prediction results\n    const predictions = testingData.map((point, i) => ({\n      features: point.features,\n      actual: point.target,\n      predicted: testPredictions[i],\n      error: errors[i],\n    }));\n\n    // Generate forecast for future periods\n    const forecast: Array<{\n      features: number[];\n      predicted: number;\n      confidence?: [number, number];\n    }> = [];\n\n    // For time series forecasting\n    if (trainingData[0].date !== undefined && predictionHorizon > 0) {\n      // Start with the last point's features\n      let lastFeatures = [...testingData[testingData.length - 1].features];\n\n      for (let i = 0; i < predictionHorizon; i++) {\n        // Predict the next value\n        const nextPrediction = [1, ...lastFeatures].reduce(\n          (sum, value, index) => sum + value * coefficients[index],\n          0\n        );\n\n        // Add confidence interval (2 * RMSE for 95% confidence)\n        const confidence: [number, number] = [nextPrediction - 2 * rmse, nextPrediction + 2 * rmse];\n\n        // Add to forecast\n        forecast.push({\n          features: lastFeatures,\n          predicted: nextPrediction,\n          confidence,\n        });\n\n        // Update feature vector for next iteration (simple autoregressive approach)\n        // This assumes the target becomes a feature in the next step\n        // More sophisticated approaches would be needed for real applications\n        if (lastFeatures.length > 0) {\n          lastFeatures = [nextPrediction, ...lastFeatures.slice(0, -1)];\n        }\n      }\n    }\n\n    // Return model result\n    return {\n      predictions,\n      forecast,\n      metrics: {\n        mse,\n        rmse,\n        mae,\n        r2,\n      },\n      modelDetails: {\n        coefficients,\n        intercept: coefficients[0],\n        weights: coefficients.slice(1),\n        featureImportance: coefficients.slice(1).map((coef, i) => ({\n          feature: featureNames[i],\n          importance: Math.abs(coef),\n        })),\n      },\n    };\n  }\n\n  /**\n   * Calculate linear regression coefficients using normal equation\n   */\n  private calculateLinearRegressionCoefficients(X: number[][], y: number[]): number[] {\n    const numSamples = X.length;\n    const numFeatures = X[0].length;\n\n    // Calculate X^T (transpose of X)\n    const X_T = Array(numFeatures)\n      .fill(0)\n      .map(() => Array(numSamples).fill(0));\n    for (let i = 0; i < numSamples; i++) {\n      for (let j = 0; j < numFeatures; j++) {\n        X_T[j][i] = X[i][j];\n      }\n    }\n\n    // Calculate X^T * X\n    const X_T_X = Array(numFeatures)\n      .fill(0)\n      .map(() => Array(numFeatures).fill(0));\n    for (let i = 0; i < numFeatures; i++) {\n      for (let j = 0; j < numFeatures; j++) {\n        for (let k = 0; k < numSamples; k++) {\n          X_T_X[i][j] += X_T[i][k] * X[k][j];\n        }\n      }\n    }\n\n    // Calculate inverse of X^T * X\n    const X_T_X_inv = this.calculateMatrixInverse(X_T_X);\n\n    // Calculate X^T * y\n    const X_T_y = Array(numFeatures).fill(0);\n    for (let i = 0; i < numFeatures; i++) {\n      for (let j = 0; j < numSamples; j++) {\n        X_T_y[i] += X_T[i][j] * y[j];\n      }\n    }\n\n    // Calculate coefficients = (X^T * X)^(-1) * X^T * y\n    const coefficients = Array(numFeatures).fill(0);\n    for (let i = 0; i < numFeatures; i++) {\n      for (let j = 0; j < numFeatures; j++) {\n        coefficients[i] += X_T_X_inv[i][j] * X_T_y[j];\n      }\n    }\n\n    return coefficients;\n  }\n\n  /**\n   * Calculate the inverse of a matrix using Gaussian elimination\n   * This is a simple implementation for demonstration purposes\n   * For production, consider using a library like math.js\n   */\n  private calculateMatrixInverse(matrix: number[][]): number[][] {\n    const n = matrix.length;\n\n    // Create augmented matrix [A|I]\n    const augMatrix: number[][] = [];\n    for (let i = 0; i < n; i++) {\n      augMatrix.push([...matrix[i], ...Array(n).fill(0)]);\n      augMatrix[i][n + i] = 1;\n    }\n\n    // Apply Gaussian elimination\n    for (let i = 0; i < n; i++) {\n      // Find pivot\n      let maxRow = i;\n      for (let j = i + 1; j < n; j++) {\n        if (Math.abs(augMatrix[j][i]) > Math.abs(augMatrix[maxRow][i])) {\n          maxRow = j;\n        }\n      }\n\n      // Swap rows\n      if (maxRow !== i) {\n        [augMatrix[i], augMatrix[maxRow]] = [augMatrix[maxRow], augMatrix[i]];\n      }\n\n      // Pivot value\n      const pivot = augMatrix[i][i];\n\n      // Skip singular matrix\n      if (Math.abs(pivot) < 1e-10) {\n        // Return identity matrix (fallback)\n        const identityMatrix = Array(n)\n          .fill(0)\n          .map((_, i) =>\n            Array(n)\n              .fill(0)\n              .map((_, j) => (i === j ? 1 : 0))\n          );\n        return identityMatrix;\n      }\n\n      // Scale pivot row\n      for (let j = i; j < 2 * n; j++) {\n        augMatrix[i][j] /= pivot;\n      }\n\n      // Eliminate other rows\n      for (let j = 0; j < n; j++) {\n        if (j !== i) {\n          const factor = augMatrix[j][i];\n          for (let k = i; k < 2 * n; k++) {\n            augMatrix[j][k] -= factor * augMatrix[i][k];\n          }\n        }\n      }\n    }\n\n    // Extract right part (inverse matrix)\n    const inverseMatrix: number[][] = [];\n    for (let i = 0; i < n; i++) {\n      inverseMatrix.push(augMatrix[i].slice(n));\n    }\n\n    return inverseMatrix;\n  }\n\n  /**\n   * Run neural network model for prediction\n   */\n  private async runNeuralNetwork(\n    trainingData: Array<{\n      features: number[];\n      target: number;\n      date?: number;\n      original: DataPoint;\n    }>,\n    testingData: Array<{\n      features: number[];\n      target: number;\n      date?: number;\n      original: DataPoint;\n    }>,\n    featureNames: string[],\n    predictionHorizon: number,\n    epochs: number\n  ): Promise<{\n    predictions: Array<{\n      features: number[];\n      actual: number;\n      predicted: number;\n      error?: number;\n    }>;\n    forecast: Array<{\n      features: number[];\n      predicted: number;\n      confidence?: [number, number];\n    }>;\n    metrics: {\n      mse: number;\n      rmse: number;\n      mae: number;\n    };\n    modelDetails: Record<string, unknown>;\n  }> {\n    // Extract feature and target matrices\n    const X_train = trainingData.map(point => point.features);\n    const y_train = trainingData.map(point => point.target);\n\n    const X_test = testingData.map(point => point.features);\n    const y_test = testingData.map(point => point.target);\n\n    // Normalize features\n    const { normalizedTrainFeatures, normalizedTestFeatures, featureMeans, featureStdDevs } =\n      this.normalizeFeatures(X_train, X_test);\n\n    // Normalize targets\n    const allTargets = [...y_train, ...y_test];\n    const targetMean = allTargets.reduce((sum, y) => sum + y, 0) / allTargets.length;\n    const targetStdDev = Math.sqrt(\n      allTargets.reduce((sum, y) => sum + Math.pow(y - targetMean, 2), 0) / allTargets.length\n    );\n\n    const normalizedTrainTargets = y_train.map(y => (y - targetMean) / targetStdDev);\n    const normalizedTestTargets = y_test.map(y => (y - targetMean) / targetStdDev);\n\n    // Simple neural network implementation (2-layer NN)\n    const numFeatures = normalizedTrainFeatures[0].length;\n    const hiddenSize = Math.max(5, Math.min(20, Math.floor(numFeatures * 2)));\n\n    // Initialize weights randomly\n    const weights1 = Array(numFeatures)\n      .fill(0)\n      .map(() =>\n        Array(hiddenSize)\n          .fill(0)\n          .map(() => (Math.random() - 0.5) * 0.1)\n      );\n\n    const bias1 = Array(hiddenSize)\n      .fill(0)\n      .map(() => (Math.random() - 0.5) * 0.1);\n\n    const weights2 = Array(hiddenSize)\n      .fill(0)\n      .map(() => (Math.random() - 0.5) * 0.1);\n    let bias2 = (Math.random() - 0.5) * 0.1; // Change from const to let\n\n    // Training parameters\n    const learningRate = 0.01;\n    const batchSize = Math.min(32, normalizedTrainFeatures.length);\n\n    // Training loop\n    for (let epoch = 0; epoch < epochs; epoch++) {\n      // Shuffle training data\n      const indices = Array(normalizedTrainFeatures.length)\n        .fill(0)\n        .map((_, i) => i);\n      for (let i = indices.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [indices[i], indices[j]] = [indices[j], indices[i]];\n      }\n\n      // Mini-batch training\n      for (\n        let batchStart = 0;\n        batchStart < normalizedTrainFeatures.length;\n        batchStart += batchSize\n      ) {\n        const batchEnd = Math.min(batchStart + batchSize, normalizedTrainFeatures.length);\n        const batchIndices = indices.slice(batchStart, batchEnd);\n\n        // Initialize gradients\n        const gradWeights1 = Array(numFeatures)\n          .fill(0)\n          .map(() => Array(hiddenSize).fill(0));\n        const gradBias1 = Array(hiddenSize).fill(0);\n        const gradWeights2 = Array(hiddenSize).fill(0);\n        let gradBias2 = 0; // Change from const to let\n\n        let batchLoss = 0;\n\n        // Process each sample in the batch\n        for (const idx of batchIndices) {\n          const x = normalizedTrainFeatures[idx];\n          const y = normalizedTrainTargets[idx];\n\n          // Forward pass\n          // Hidden layer with ReLU activation\n          const hidden = Array(hiddenSize).fill(0);\n          for (let i = 0; i < hiddenSize; i++) {\n            for (let j = 0; j < numFeatures; j++) {\n              hidden[i] += x[j] * weights1[j][i];\n            }\n            hidden[i] += bias1[i];\n            // ReLU activation\n            hidden[i] = Math.max(0, hidden[i]);\n          }\n\n          // Output layer (linear)\n          let output = 0;\n          for (let i = 0; i < hiddenSize; i++) {\n            output += hidden[i] * weights2[i];\n          }\n          output += bias2;\n\n          // Loss (MSE)\n          const error = output - y;\n          batchLoss += error * error;\n\n          // Backward pass\n          // Output layer gradient\n          const gradOutput = 2 * error;\n\n          // Hidden layer gradient\n          for (let i = 0; i < hiddenSize; i++) {\n            if (hidden[i] > 0) {\n              // ReLU gradient\n              gradWeights2[i] += gradOutput * hidden[i];\n              for (let j = 0; j < numFeatures; j++) {\n                gradWeights1[j][i] += gradOutput * weights2[i] * x[j];\n              }\n              gradBias1[i] += gradOutput * weights2[i];\n            }\n          }\n\n          gradBias2 += gradOutput;\n        }\n\n        // Update weights\n        const batchScale = 1 / batchIndices.length;\n\n        for (let i = 0; i < numFeatures; i++) {\n          for (let j = 0; j < hiddenSize; j++) {\n            weights1[i][j] -= learningRate * gradWeights1[i][j] * batchScale;\n          }\n        }\n\n        for (let i = 0; i < hiddenSize; i++) {\n          bias1[i] -= learningRate * gradBias1[i] * batchScale;\n          weights2[i] -= learningRate * gradWeights2[i] * batchScale;\n        }\n\n        bias2 -= learningRate * gradBias2 * batchScale; // This is fine, bias2 is a let\n      }\n    }\n\n    // (...args: unknown[]) => unknown to make predictions\n    const predict = (features: number[]): number => {\n      // Normalize features\n      const normalizedFeatures = features.map(\n        (value, i) => (value - featureMeans[i]) / featureStdDevs[i]\n      );\n\n      // Forward pass through the network\n      const hidden = Array(hiddenSize).fill(0);\n      for (let i = 0; i < hiddenSize; i++) {\n        for (let j = 0; j < numFeatures; j++) {\n          hidden[i] += normalizedFeatures[j] * weights1[j][i];\n        }\n        hidden[i] += bias1[i];\n        hidden[i] = Math.max(0, hidden[i]); // ReLU\n      }\n\n      let output = 0;\n      for (let i = 0; i < hiddenSize; i++) {\n        output += hidden[i] * weights2[i];\n      }\n      output += bias2;\n\n      // Denormalize the output\n      return output * targetStdDev + targetMean;\n    };\n\n    // Make predictions on test data\n    const testPredictions = X_test.map(features => predict(features));\n\n    // Calculate metrics\n    const errors = testPredictions.map((predicted, i) => predicted - y_test[i]);\n    const squaredErrors = errors.map(error => error * error);\n    const absErrors = errors.map(error => Math.abs(error));\n\n    const mse = squaredErrors.reduce((sum, sq) => sum + sq, 0) / squaredErrors.length;\n    const rmse = Math.sqrt(mse);\n    const mae = absErrors.reduce((sum, abs) => sum + abs, 0) / absErrors.length;\n\n    // Create prediction results\n    const predictions = testingData.map((point, i) => ({\n      features: point.features,\n      actual: point.target,\n      predicted: testPredictions[i],\n      error: errors[i],\n    }));\n\n    // Generate forecast for future periods\n    const forecast: Array<{\n      features: number[];\n      predicted: number;\n      confidence?: [number, number];\n    }> = [];\n\n    // For time series forecasting\n    if (trainingData[0].date !== undefined && predictionHorizon > 0) {\n      // Start with the last point's features\n      let lastFeatures = [...testingData[testingData.length - 1].features];\n\n      for (let i = 0; i < predictionHorizon; i++) {\n        // Predict the next value\n        const nextPrediction = predict(lastFeatures);\n\n        // Add confidence interval (2 * RMSE for 95% confidence)\n        const confidence: [number, number] = [nextPrediction - 2 * rmse, nextPrediction + 2 * rmse];\n\n        // Add to forecast\n        forecast.push({\n          features: lastFeatures,\n          predicted: nextPrediction,\n          confidence,\n        });\n\n        // Update feature vector for next iteration (simple autoregressive approach)\n        if (lastFeatures.length > 0) {\n          lastFeatures = [nextPrediction, ...lastFeatures.slice(0, -1)];\n        }\n      }\n    }\n\n    // Return model result\n    return {\n      predictions,\n      forecast,\n      metrics: {\n        mse,\n        rmse,\n        mae,\n      },\n      modelDetails: {\n        architecture: {\n          inputSize: numFeatures,\n          hiddenSize,\n          outputSize: 1,\n        },\n        normalization: {\n          featureMeans,\n          featureStdDevs,\n          targetMean,\n          targetStdDev,\n        },\n        training: {\n          epochs,\n          finalMSE: mse,\n        },\n      },\n    };\n  }\n\n  /**\n   * Normalize features for neural network training\n   */\n  private normalizeFeatures(\n    trainFeatures: number[][],\n    testFeatures: number[][]\n  ): {\n    normalizedTrainFeatures: number[][];\n    normalizedTestFeatures: number[][];\n    featureMeans: number[];\n    featureStdDevs: number[];\n  } {\n    const numFeatures = trainFeatures[0].length;\n    const featureMeans = Array(numFeatures).fill(0);\n    const featureStdDevs = Array(numFeatures).fill(0);\n\n    // Calculate means\n    for (const features of trainFeatures) {\n      for (let i = 0; i < numFeatures; i++) {\n        featureMeans[i] += features[i];\n      }\n    }\n\n    for (let i = 0; i < numFeatures; i++) {\n      featureMeans[i] /= trainFeatures.length;\n    }\n\n    // Calculate standard deviations\n    for (const features of trainFeatures) {\n      for (let i = 0; i < numFeatures; i++) {\n        featureStdDevs[i] += Math.pow(features[i] - featureMeans[i], 2);\n      }\n    }\n\n    for (let i = 0; i < numFeatures; i++) {\n      featureStdDevs[i] = Math.sqrt(featureStdDevs[i] / trainFeatures.length);\n      if (featureStdDevs[i] === 0) {\n        featureStdDevs[i] = 1; // Avoid division by zero\n      }\n    }\n\n    // Normalize train features\n    const normalizedTrainFeatures = trainFeatures.map(features =>\n      features.map((value, i) => (value - featureMeans[i]) / featureStdDevs[i])\n    );\n\n    // Normalize test features\n    const normalizedTestFeatures = testFeatures.map(features =>\n      features.map((value, i) => (value - featureMeans[i]) / featureStdDevs[i])\n    );\n\n    return {\n      normalizedTrainFeatures,\n      normalizedTestFeatures,\n      featureMeans,\n      featureStdDevs,\n    };\n  }\n\n  /**\n   * Generate insights about prediction results\n   */\n  private generatePredictionInsights(data: Record<string, unknown>): string[] {\n    const insights: string[] = [];\n    const model = data?.model as string;\n    const metrics = data?.metrics as { mse: number; rmse: number; mae: number; r2?: number };\n    const forecast = data?.forecast as Array<{ predicted: number; confidence?: [number, number] }>;\n\n    // Model type and quality insights\n    insights.push(\n      `Prediction model: ${model === 'linear' ? 'Linear Regression' : 'Neural Network'}.`\n    );\n\n    if (metrics.r2 !== undefined) {\n      const r2 = metrics.r2;\n      if (r2 > 0.8) {\n        insights.push(\n          `The model explains ${(r2 * 100).toFixed(1)}% of the variance in the data, indicating a strong fit.`\n        );\n      } else if (r2 > 0.5) {\n        insights.push(\n          `The model explains ${(r2 * 100).toFixed(1)}% of the variance in the data, indicating a moderate fit.`\n        );\n      } else {\n        insights.push(\n          `The model explains only ${(r2 * 100).toFixed(1)}% of the variance, suggesting a weak relationship between features and target.`\n        );\n      }\n    }\n\n    insights.push(\n      `Mean Absolute Error (MAE): ${metrics.mae.toFixed(3)}, Root Mean Squared Error (RMSE): ${metrics.rmse.toFixed(3)}.`\n    );\n\n    // Feature importance for linear models\n    if (model === 'linear' && data?.modelDetails) {\n      const modelDetails = data.modelDetails as Record<string, unknown>;\n      if ('featureImportance' in modelDetails) {\n        const featureImportance = modelDetails.featureImportance as Array<{\n          feature: string;\n          importance: number;\n        }>;\n\n        // Sort features by importance\n        const sortedFeatures = [...featureImportance].sort((a, b) => b.importance - a.importance);\n\n        if (sortedFeatures.length > 0) {\n          const topFeatures = sortedFeatures.slice(0, Math.min(3, sortedFeatures.length));\n\n          insights.push(\n            `Top influential features: ${topFeatures\n              .map(f => `${f.feature} (importance: ${f.importance.toFixed(3)})`)\n              .join(', ')}.`\n          );\n        }\n      }\n    }\n\n    // Forecast insights\n    if (forecast && forecast.length > 0) {\n      const firstPrediction = forecast[0].predicted;\n      const lastPrediction = forecast[forecast.length - 1].predicted;\n      const trend =\n        lastPrediction > firstPrediction\n          ? 'upward'\n          : lastPrediction < firstPrediction\n            ? 'downward'\n            : 'stable';\n\n      insights.push(\n        `The ${forecast.length}-step forecast shows a ${trend} trend from ${firstPrediction.toFixed(2)} to ${lastPrediction.toFixed(2)}.`\n      );\n\n      if (forecast[0].confidence) {\n        const confidenceWidth = forecast[0].confidence[1] - forecast[0].confidence[0];\n\n        insights.push(\n          `Forecast confidence interval width: ${confidenceWidth.toFixed(2)} (Â±${(confidenceWidth / 2).toFixed(2)}).`\n        );\n      }\n    }\n\n    return insights;\n  }\n\n  /**\n   * Generate summary of prediction results\n   */\n  private generatePredictionSummary(data: Record<string, unknown>): string {\n    const model = data?.model as string;\n    const targetVariable = data?.targetVariable as string;\n    const metrics = data?.metrics as { mse: number; rmse: number; mae: number; r2?: number };\n\n    let summary = `${model === 'linear' ? 'Linear regression' : 'Neural network'} model `;\n\n    if (metrics.r2 !== undefined) {\n      const r2Description =\n        metrics.r2 > 0.7 ? 'strongly' : metrics.r2 > 0.4 ? 'moderately' : 'weakly';\n      summary += `${r2Description} predicts ${targetVariable} with RÂ² of ${metrics.r2.toFixed(2)} and RMSE of ${metrics.rmse.toFixed(2)}.`;\n    } else {\n      summary += `predicts ${targetVariable} with RMSE of ${metrics.rmse.toFixed(2)}.`;\n    }\n\n    return summary;\n  }\n\n  /**\n   * Analyze the spatial distribution of resources\n   */\n  private async analyzeResourceMapping(\n    config: ResourceMappingAnalysisConfig,\n    dataset: Dataset,\n    options: AlgorithmOptions\n  ): Promise<AnalysisResult> {\n    const startTime = Date.now();\n\n    // Extract parameters\n    const { resourceTypes = [], valueMetric = 'amount', regionSize = 10 } = config.parameters;\n\n    // Validate dataset content\n    if (dataset.dataPoints.length === 0) {\n      throw new Error('Dataset contains no data points for resource mapping analysis.');\n    }\n\n    // Filter data points by resource type if specified\n    let resourcePoints = dataset.dataPoints.filter(\n      point => point.type === 'resource' || (point.properties && point.properties.resourceType)\n    );\n\n    if (resourceTypes.length > 0) {\n      resourcePoints = resourcePoints.filter(point => {\n        const typeValue = point.properties.resourceType || point.properties.type;\n        // Handle type conversion more safely\n        return resourceTypes.some(rt => rt.toString() === typeValue.toString());\n      });\n    }\n\n    if (resourcePoints.length === 0) {\n      throw new Error('No resource data points found in the dataset.');\n    }\n\n    // Determine the x and y range from the data\n    let minX = Infinity;\n    let maxX = -Infinity;\n    let minY = Infinity;\n    let maxY = -Infinity;\n\n    // Find the bounds of the area\n    resourcePoints.forEach(point => {\n      const x = point.coordinates.x;\n      const y = point.coordinates.y;\n\n      minX = Math.min(minX, x);\n      maxX = Math.max(maxX, x);\n      minY = Math.min(minY, y);\n      maxY = Math.max(maxY, y);\n    });\n\n    // Add some padding to the bounds\n    const padding = regionSize * 0.5;\n    minX = Math.floor(minX - padding);\n    maxX = Math.ceil(maxX + padding);\n    minY = Math.floor(minY - padding);\n    maxY = Math.ceil(maxY + padding);\n\n    // Create a grid with cells of regionSize\n    const gridCells: Record<\n      string,\n      {\n        x: number;\n        y: number;\n        resources: Array<{\n          type: ResourceType;\n          amount: number;\n          quality?: number;\n          accessibility?: number;\n          estimatedValue?: number;\n        }>;\n        points: DataPoint[];\n      }\n    > = {};\n\n    // Assign each resource point to a grid cell\n    resourcePoints.forEach(point => {\n      const cellX = Math.floor(point.coordinates.x / regionSize) * regionSize;\n      const cellY = Math.floor(point.coordinates.y / regionSize) * regionSize;\n      const cellKey = `${cellX},${cellY}`;\n\n      if (!gridCells[cellKey]) {\n        gridCells[cellKey] = {\n          x: cellX,\n          y: cellY,\n          resources: [],\n          points: [],\n        };\n      }\n\n      // Add the point to the cell\n      gridCells[cellKey].points.push(point);\n\n      // Extract resource information\n      const resourceType = point.properties.resourceType || point.properties.type;\n      const amount = typeof point.properties.amount === 'number' ? point.properties.amount : 1;\n      const quality =\n        typeof point.properties.quality === 'number' ? point.properties.quality : undefined;\n      const accessibility =\n        typeof point.properties.accessibility === 'number'\n          ? point.properties.accessibility\n          : undefined;\n      const estimatedValue =\n        typeof point.properties.estimatedValue === 'number'\n          ? point.properties.estimatedValue\n          : undefined;\n\n      // Check if this resource type already exists in the cell\n      const existingResource = gridCells[cellKey].resources.find(r => r.type === resourceType);\n\n      if (existingResource) {\n        // Update existing resource\n        existingResource.amount += amount;\n\n        // Update other properties if they exist\n        if (quality !== undefined) {\n          existingResource.quality =\n            existingResource.quality !== undefined\n              ? (existingResource.quality + quality) / 2 // Average the quality\n              : quality;\n        }\n\n        if (accessibility !== undefined) {\n          existingResource.accessibility =\n            existingResource.accessibility !== undefined\n              ? (existingResource.accessibility + accessibility) / 2 // Average the accessibility\n              : accessibility;\n        }\n\n        if (estimatedValue !== undefined) {\n          existingResource.estimatedValue =\n            existingResource.estimatedValue !== undefined\n              ? existingResource.estimatedValue + estimatedValue // Sum the estimated value\n              : estimatedValue;\n        }\n      } else {\n        // Add new resource type to the cell\n        gridCells[cellKey].resources.push({\n          type: resourceType as unknown as ResourceType,\n          amount,\n          quality,\n          accessibility,\n          estimatedValue,\n        });\n      }\n    });\n\n    // Calculate aggregate metrics for each cell\n    const processedCells = Object.values(gridCells).map(cell => {\n      // Calculate total value in the cell based on the selected metric\n      let totalValue = 0;\n\n      // Count total resources in the cell\n      const totalResourceCount = cell.resources.reduce((sum, resource) => sum + resource.amount, 0);\n\n      // Calculate total value based on selected metric\n      cell.resources.forEach(resource => {\n        const metricValue =\n          resource[valueMetric] !== undefined ? (resource[valueMetric] as number) : resource.amount;\n\n        totalValue += metricValue;\n      });\n\n      // Determine dominant resource type\n      let dominantResource: string | undefined;\n      let dominantPercentage = 0;\n\n      if (cell.resources.length > 0) {\n        // Sort resources by amount\n        const sortedResources = [...cell.resources].sort((a, b) => b.amount - a.amount);\n        dominantResource = sortedResources[0].type;\n        dominantPercentage = sortedResources[0].amount / totalResourceCount;\n      }\n\n      return {\n        x: cell.x,\n        y: cell.y,\n        resources: cell.resources,\n        totalValue,\n        dominantResource,\n        dominantPercentage,\n        totalResourceCount,\n      };\n    });\n\n    // Calculate resource type density\n    const resourceTypeDensity: Record<string, number> = {};\n    const allResourceTypes = new Set<string>();\n\n    processedCells.forEach(cell => {\n      cell.resources.forEach(resource => {\n        allResourceTypes.add(resource.type);\n\n        if (!resourceTypeDensity[resource.type]) {\n          resourceTypeDensity[resource.type] = 0;\n        }\n\n        resourceTypeDensity[resource.type] += resource.amount;\n      });\n    });\n\n    // Normalize densities\n    const totalResources = Object.values(resourceTypeDensity).reduce((sum, val) => sum + val, 0);\n\n    Object.keys(resourceTypeDensity).forEach(type => {\n      resourceTypeDensity[type] = resourceTypeDensity[type] / totalResources;\n    });\n\n    // Generate insights\n    const insights = this.generateResourceMappingInsights({\n      cells: processedCells,\n      resourceDensity: resourceTypeDensity,\n      xRange: [minX, maxX],\n      yRange: [minY, maxY],\n      valueMetric,\n    });\n\n    // Generate summary\n    const summary = this.generateResourceMappingSummary({\n      cells: processedCells,\n      resourceDensity: resourceTypeDensity,\n      xRange: [minX, maxX],\n      yRange: [minY, maxY],\n      valueMetric,\n    });\n\n    // Prepare result\n    const result: AnalysisResult = {\n      id: crypto.randomUUID(),\n      analysisConfigId: config.id,\n      status: 'completed',\n      startTime,\n      endTime: Date.now(),\n      data: {\n        resourcePoints,\n        gridCells: processedCells,\n        resourceTypes: Array.from(allResourceTypes),\n        valueMetric,\n        regionSize,\n        xRange: [minX, maxX],\n        yRange: [minY, maxY],\n        density: resourceTypeDensity,\n      },\n      insights,\n      summary,\n    };\n\n    return result;\n  }\n\n  /**\n   * Generate insights from resource mapping analysis\n   */\n  private generateResourceMappingInsights(data: Record<string, unknown>): string[] {\n    const insights: string[] = [];\n    const resourceDensity = data.resourceDensity as Record<string, number>;\n    const valueMetric = data.valueMetric as string;\n\n    // Cast cells to the proper type\n    const typedCells = (data.cells || []) as ResourceCell[];\n\n    // Add insights about most abundant resource types\n    const sortedDensities = Object.entries(resourceDensity).sort(([, a], [, b]) => b - a);\n\n    if (sortedDensities.length > 0) {\n      const [topType, topDensity] = sortedDensities[0];\n      insights.push(\n        `${topType} is the most abundant resource in the mapped region, making up ${(topDensity * 100).toFixed(1)}% of all resources.`\n      );\n    }\n\n    if (sortedDensities.length > 1) {\n      const [, , ...restTypes] = sortedDensities;\n      const rareTypes = restTypes.filter(([, density]) => density < 0.1);\n\n      if (rareTypes.length > 0) {\n        insights.push(\n          `Rare resources include: ${rareTypes.map(([type]) => type).join(', ')}, each comprising less than 10% of the total.`\n        );\n      }\n    }\n\n    // Find resource-rich regions\n    if (typedCells.length > 0) {\n      const sortedCells = [...typedCells].sort((a, b) => b.totalValue - a.totalValue);\n      const topCell = sortedCells[0];\n\n      if (topCell && topCell.dominantResource) {\n        insights.push(\n          `The region with the highest ${valueMetric} concentration is located at coordinates (${topCell.x}, ${topCell.y}), containing primarily ${topCell.dominantResource}.`\n        );\n      }\n\n      // Find clusters of similar resources\n      const resourceClusters: Record<string, number> = {};\n\n      typedCells.forEach(cell => {\n        if (cell.dominantResource) {\n          if (!resourceClusters[cell.dominantResource]) {\n            resourceClusters[cell.dominantResource] = 0;\n          }\n          resourceClusters[cell.dominantResource]++;\n        }\n      });\n\n      const sortedClusters = Object.entries(resourceClusters).sort(([, a], [, b]) => b - a);\n\n      if (sortedClusters.length > 0) {\n        const [mostClusteredType, clusterCount] = sortedClusters[0];\n\n        if (clusterCount > 1) {\n          insights.push(\n            `${mostClusteredType} tends to form clusters across the map, with ${clusterCount} regions where it's the dominant resource.`\n          );\n        }\n      }\n    }\n\n    // Identify resource diversity\n    const avgResourceTypesPerCell =\n      typedCells.length > 0\n        ? typedCells.reduce((sum, cell) => sum + cell.resources.length, 0) / typedCells.length\n        : 0;\n\n    if (avgResourceTypesPerCell > 2.5) {\n      insights.push(\n        `The mapped region shows high resource diversity with an average of ${avgResourceTypesPerCell.toFixed(1)} resource types per region.`\n      );\n    } else if (avgResourceTypesPerCell < 1.5) {\n      insights.push(\n        `The mapped region shows low resource diversity with an average of ${avgResourceTypesPerCell.toFixed(1)} resource types per region.`\n      );\n    }\n\n    return insights;\n  }\n\n  /**\n   * Generate summary from resource mapping analysis\n   */\n  private generateResourceMappingSummary(data: Record<string, unknown>): string {\n    const typedCells = (data.cells || []) as ResourceCell[];\n    const resourceDensity = data.resourceDensity as Record<string, number>;\n    const xRange = data.xRange as [number, number];\n    const yRange = data.yRange as [number, number];\n    const valueMetric = data.valueMetric as string;\n\n    const sortedDensities = Object.entries(resourceDensity)\n      .sort(([, a], [, b]) => b - a)\n      .slice(0, 3);\n\n    const topResourceTypes = sortedDensities\n      .map(([type, density]) => `${type} (${(density * 100).toFixed(1)}%)`)\n      .join(', ');\n\n    const mapSize = `${xRange[1] - xRange[0]}x${yRange[1] - yRange[0]}`;\n    const regionCount = typedCells.length;\n    const totalResourceAmount = typedCells.reduce((sum, cell) => sum + cell.totalResourceCount, 0);\n\n    return `Resource mapping analysis of a ${mapSize} area identified ${regionCount} resource regions containing a total of ${totalResourceAmount} resource units. The predominant resource types are ${topResourceTypes}. This analysis used ${valueMetric} as the primary metric for evaluation.`;\n  }\n\n  /**\n   * Analyze comparison between datasets or variables\n   */\n  private async analyzeComparison(\n    config: ComparisonAnalysisConfig,\n    dataset: Dataset,\n    options: AlgorithmOptions\n  ): Promise<AnalysisResult> {\n    // This is a stub implementation that will be fully implemented later\n    const startTime = Date.now();\n\n    // Extract parameters\n    const {\n      baseVariable,\n      comparisonVariables,\n      normalizeValues = false,\n      timeRange,\n      groupBy,\n    } = config.parameters;\n\n    // For now, just return a basic result structure\n    const result: AnalysisResult = {\n      id: crypto.randomUUID(),\n      analysisConfigId: config.id,\n      status: 'completed',\n      startTime,\n      endTime: Date.now(),\n      data: {\n        baseVariable,\n        comparisonVariables,\n        comparisonData: [],\n        summary: 'Comparison analysis stub implementation',\n      },\n      summary: 'Comparison analysis stub implementation',\n      insights: ['This is a stub implementation of the comparison analysis.'],\n    };\n\n    return result;\n  }\n\n  /**\n   * Analyze sectors for various metrics\n   */\n  private async analyzeSector(\n    config: SectorAnalysisConfig,\n    dataset: Dataset,\n    options: AlgorithmOptions\n  ): Promise<AnalysisResult> {\n    // This is a stub implementation that will be fully implemented later\n    const startTime = Date.now();\n\n    // Extract parameters\n    const { metrics, sectorIds, includeNeighbors = false, timeRange } = config.parameters;\n\n    // For now, just return a basic result structure\n    const result: AnalysisResult = {\n      id: crypto.randomUUID(),\n      analysisConfigId: config.id,\n      status: 'completed',\n      startTime,\n      endTime: Date.now(),\n      data: {\n        metrics,\n        sectorIds,\n        sectorData: [],\n        summary: 'Sector analysis stub implementation',\n      },\n      summary: 'Sector analysis stub implementation',\n      insights: ['This is a stub implementation of the sector analysis.'],\n    };\n\n    return result;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/services/AnomalyDetectionService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/services/ComponentRegistryService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'dependencies' is defined but never used.","line":42,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":42,"endColumn":44},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'eventData' is defined but never used.","line":181,"column":53,"nodeType":null,"messageId":"unusedVar","endLine":181,"endColumn":62}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { AbstractBaseService } from '../lib/services/BaseService';\nimport { ErrorType, errorLoggingService } from './ErrorLoggingService';\n\n/**\n * Metadata for a registered UI component\n *\n * Includes information about the component's identity, subscriptions, and performance metrics\n */\nexport interface ComponentMetadata {\n  id: string;\n  type: string;\n  eventSubscriptions: string[]; // Event types this component is interested in\n  updatePriority: 'high' | 'medium' | 'low';\n  lastUpdated?: number;\n  renderCount?: number;\n  averageRenderTime?: number;\n  totalRenderTime?: number;\n}\n\nexport interface ComponentRegistration {\n  id: string;\n  type: string;\n  eventSubscriptions: string[];\n  updatePriority: 'high' | 'medium' | 'low';\n  lastRenderTime?: number;\n  renderCount?: number;\n}\n\n/**\n * @context: service-system\n * Service for registering and tracking UI components and their event subscriptions\n */\nclass ComponentRegistryServiceImpl extends AbstractBaseService<ComponentRegistryServiceImpl> {\n  private components: Map<string, ComponentRegistration> = new Map();\n  private typeIndex: Map<string, Set<string>> = new Map();\n  private eventIndex: Map<string, Set<string>> = new Map();\n\n  public constructor() {\n    super('ComponentRegistryService', '1.0.0');\n  }\n\n  protected async onInitialize(dependencies?: Record<string, unknown>): Promise<void> {\n    // Initialize metrics\n    if (!this.metadata.metrics) {\n      this.metadata.metrics = {};\n    }\n    this.metadata.metrics = {\n      total_components: 0,\n      total_types: 0,\n      total_event_types: 0,\n      total_renders: 0,\n      total_notifications: 0,\n      total_errors: 0,\n    };\n  }\n\n  protected async onDispose(): Promise<void> {\n    // Clear all registrations\n    this.components.clear();\n    this.typeIndex.clear();\n    this.eventIndex.clear();\n  }\n\n  public registerComponent(registration: Omit<ComponentRegistration, 'id'>): string {\n    const id = crypto.randomUUID();\n    const fullRegistration: ComponentRegistration = {\n      ...registration,\n      id,\n      renderCount: 0,\n    };\n\n    // Store in main registry\n    this.components.set(id, fullRegistration);\n\n    // Update type index\n    if (!this.typeIndex.has(registration.type)) {\n      this.typeIndex.set(registration.type, new Set());\n    }\n    this.typeIndex.get(registration.type)!.add(id);\n\n    // Update event index\n    for (const event of registration.eventSubscriptions) {\n      if (!this.eventIndex.has(event)) {\n        this.eventIndex.set(event, new Set());\n      }\n      this.eventIndex.get(event)!.add(id);\n    }\n\n    // Update metrics\n    if (!this.metadata.metrics) {\n      this.metadata.metrics = {};\n    }\n    const metrics = this.metadata.metrics;\n    metrics.total_components = this.components.size;\n    metrics.total_types = this.typeIndex.size;\n    metrics.total_event_types = this.eventIndex.size;\n    this.metadata.metrics = metrics;\n\n    return id;\n  }\n\n  public unregisterComponent(id: string): void {\n    const registration = this.components.get(id);\n    if (!registration) {\n      return;\n    }\n\n    // Remove from type index\n    this.typeIndex.get(registration.type)?.delete(id);\n    if (this.typeIndex.get(registration.type)?.size === 0) {\n      this.typeIndex.delete(registration.type);\n    }\n\n    // Remove from event index\n    for (const event of registration.eventSubscriptions) {\n      this.eventIndex.get(event)?.delete(id);\n      if (this.eventIndex.get(event)?.size === 0) {\n        this.eventIndex.delete(event);\n      }\n    }\n\n    // Remove from main registry\n    this.components.delete(id);\n\n    // Update metrics\n    if (!this.metadata.metrics) {\n      this.metadata.metrics = {};\n    }\n    const metrics = this.metadata.metrics;\n    metrics.total_components = this.components.size;\n    metrics.total_types = this.typeIndex.size;\n    metrics.total_event_types = this.eventIndex.size;\n    this.metadata.metrics = metrics;\n  }\n\n  public getComponent(id: string): ComponentRegistration | undefined {\n    return this.components.get(id);\n  }\n\n  public getComponentsByType(type: string): ComponentRegistration[] {\n    const ids = this.typeIndex.get(type);\n    if (!ids) {\n      return [];\n    }\n\n    return Array.from(ids)\n      .map(id => this.components.get(id)!)\n      .filter(Boolean);\n  }\n\n  public getComponentsByEvent(event: string): ComponentRegistration[] {\n    const ids = this.eventIndex.get(event);\n    if (!ids) {\n      return [];\n    }\n\n    return Array.from(ids)\n      .map(id => this.components.get(id)!)\n      .filter(Boolean);\n  }\n\n  public trackRender(id: string): void {\n    const registration = this.components.get(id);\n    if (!registration) {\n      return;\n    }\n\n    registration.lastRenderTime = Date.now();\n    registration.renderCount = (registration.renderCount ?? 0) + 1;\n\n    // Update metrics\n    if (!this.metadata.metrics) {\n      this.metadata.metrics = {};\n    }\n    const metrics = this.metadata.metrics;\n    metrics.total_renders = (metrics.total_renders ?? 0) + 1;\n    metrics.last_render_timestamp = registration.lastRenderTime;\n    this.metadata.metrics = metrics;\n  }\n\n  public notifyComponentsOfEvent(eventType: string, eventData: unknown): void {\n    const components = this.getComponentsByEvent(eventType);\n\n    // Update metrics\n    if (!this.metadata.metrics) {\n      this.metadata.metrics = {};\n    }\n    const metrics = this.metadata.metrics;\n    metrics.total_notifications = (metrics.total_notifications ?? 0) + 1;\n    metrics.last_notification_timestamp = Date.now();\n    metrics.components_notified = components.length;\n    this.metadata.metrics = metrics;\n\n    // Log in development\n    if (process.env.NODE_ENV === 'development') {\n      console.warn(\n        `[ComponentRegistryService] Notifying ${components.length} components of event: ${eventType}`\n      );\n    }\n  }\n\n  public override handleError(error: Error, context?: Record<string, unknown>): void {\n    // Update error metrics\n    if (!this.metadata.metrics) {\n      this.metadata.metrics = {};\n    }\n    const metrics = this.metadata.metrics;\n    metrics.total_errors = (metrics.total_errors ?? 0) + 1;\n    metrics.last_error_timestamp = Date.now();\n    this.metadata.metrics = metrics;\n\n    // Forward to error logging service\n    errorLoggingService.logError(error, ErrorType.RUNTIME, undefined, {\n      service: 'ComponentRegistryService',\n      ...context,\n    });\n\n    // Log error in development\n    if (process.env.NODE_ENV === 'development') {\n      console.error('[ComponentRegistryService] Error:', error);\n    }\n  }\n}\n\n// Export singleton instance using direct instantiation\nexport const componentRegistryService = new ComponentRegistryServiceImpl();\n\n// Export default for easier imports\nexport default componentRegistryService;\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/services/DataCollectionService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'EVENT_TYPE_MAPPING' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":28,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":28,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isValidDataPointProperty' is defined but never used. Allowed unused vars must match /^ignored|^temp/u.","line":85,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":85,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'asEventType' is defined but never used. Allowed unused vars must match /^ignored|^temp/u.","line":128,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":128,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ResourceType } from './../types/resources/ResourceTypes';\n/**\n * @file DataCollectionService.ts\n * Service for collecting and preprocessing data for analysis\n *\n * This service:\n * 1. Subscribes to relevant exploration events\n * 2. Preprocesses data into standardized formats\n * 3. Provides filtering and sampling capabilities\n * 4. Manages caching for improved performance\n * 5. Performs data validation and enrichment\n */\n\nimport { v4 as uuidv4 } from 'uuid';\nimport {\n  Anomaly,\n  EXPLORATION_EVENTS,\n  ExplorationManager,\n  Sector,\n} from '../managers/exploration/ExplorationManager';\nimport { BaseEvent, EventType } from '../types/events/EventTypes';\nimport { DataPoint, ResourceData } from '../types/exploration/DataAnalysisTypes';\n\n/**\n * Map of ExplorationEvents to EventType enums\n * This mapping ensures type safety and proper integration between systems\n */\nconst EVENT_TYPE_MAPPING: Record<keyof typeof EXPLORATION_EVENTS, EventType> = {\n  SECTOR_DISCOVERED: EventType.EXPLORATION_SECTOR_DISCOVERED,\n  SECTOR_SCANNED: EventType.EXPLORATION_SECTOR_SCANNED,\n  ANOMALY_DETECTED: EventType.EXPLORATION_ANOMALY_DETECTED,\n  RESOURCE_DETECTED: EventType.EXPLORATION_RESOURCE_DETECTED,\n  SCAN_STARTED: EventType.EXPLORATION_SCAN_STARTED,\n  SCAN_COMPLETED: EventType.EXPLORATION_SCAN_COMPLETED,\n  SCAN_FAILED: EventType.EXPLORATION_SCAN_FAILED,\n  SHIP_ASSIGNED: EventType.EXPLORATION_SHIP_ASSIGNED,\n  SHIP_UNASSIGNED: EventType.EXPLORATION_SHIP_UNASSIGNED,\n};\n\n// Define PropertyType for DataPoint properties to fix type issues\ntype PropertyType = string | number | boolean | string[];\n\n// Interface for coordinates to ensure proper structure\ninterface Coordinates {\n  x: number;\n  y: number;\n}\n\n// Cache interface for storing processed data\ninterface DataCache {\n  sectors: Map<string, DataPoint>;\n  anomalies: Map<string, DataPoint>;\n  resources: Map<string, DataPoint>;\n  lastUpdated: Record<string, number>;\n}\n\n/**\n * Helper function to safely access a nested property from an object\n * with type checking\n *\n * @param obj The object to access properties from\n * @param path The dot-separated path to the property\n * @returns The property value or undefined if not found\n */\nfunction getNestedProperty(obj: Record<string, unknown>, path: string): unknown {\n  const parts = path.split('.');\n  let current: unknown = obj;\n\n  for (const part of parts) {\n    if (current === undefined || current === null || typeof current !== 'object') {\n      return undefined;\n    }\n    current = (current as Record<string, unknown>)[part];\n  }\n\n  return current;\n}\n\n/**\n * Type-safe helper for checking if a value is a valid DataPoint property\n *\n * @param value The value to check\n * @returns True if the value is a valid DataPoint property\n */\nfunction isValidDataPointProperty(value: unknown): value is PropertyType {\n  return (\n    typeof value === 'string' ||\n    typeof value === 'number' ||\n    typeof value === 'boolean' ||\n    (Array.isArray(value) && value.every(item => typeof item === 'string'))\n  );\n}\n\n// Custom type guard to validate Sector objects\nfunction isSector(obj: unknown): obj is Sector {\n  if (!obj || typeof obj !== 'object') return false;\n  const sector = obj as Partial<Sector>;\n  return (\n    typeof sector.id === 'string' &&\n    typeof sector.name === 'string' &&\n    typeof sector.status === 'string'\n  );\n}\n\n// Custom type guard to validate Anomaly objects\nfunction isAnomaly(obj: unknown): obj is Anomaly {\n  if (!obj || typeof obj !== 'object') return false;\n  const anomaly = obj as Partial<Anomaly>;\n  return (\n    typeof anomaly.id === 'string' &&\n    typeof anomaly.type === 'string' &&\n    typeof anomaly.sectorId === 'string'\n  );\n}\n\n// Custom type guard to validate ResourceData objects\nfunction isResourceData(obj: unknown): obj is ResourceData {\n  if (!obj || typeof obj !== 'object') return false;\n  const resource = obj as Partial<ResourceData>;\n  return typeof resource.type === 'string' && typeof resource.amount === 'number';\n}\n\n/**\n * Convert exploration event key to EventType\n * @param event The exploration event key\n * @returns The corresponding EventType\n */\nfunction asEventType(event: keyof typeof EXPLORATION_EVENTS): EventType {\n  return EXPLORATION_EVENTS[event];\n}\n\n/**\n * Check if a BaseEvent has the expected exploration event type\n * @param event The event to check\n * @param expectedType The expected exploration event type\n * @returns True if the event is of the expected type, false otherwise\n */\nfunction isExplorationEventOfType(\n  event: BaseEvent,\n  expectedType: keyof typeof EXPLORATION_EVENTS\n): boolean {\n  return event?.type === EXPLORATION_EVENTS[expectedType];\n}\n\n/**\n * Create type guards for exploration event data types\n */\n\n/**\n * Type guard for sector discovery event data\n */\ninterface SectorDiscoveryEventData {\n  sector: Sector;\n  [key: string]: unknown;\n}\n\nfunction isSectorDiscoveryEventData(data: unknown): data is SectorDiscoveryEventData {\n  if (!data || typeof data !== 'object') return false;\n  const eventData = data as Partial<SectorDiscoveryEventData>;\n  return !!eventData.sector && isSector(eventData.sector);\n}\n\n/**\n * Type guard for anomaly detection event data\n */\ninterface AnomalyDetectionEventData {\n  anomaly: Anomaly;\n  sectorId: string;\n  [key: string]: unknown;\n}\n\nfunction isAnomalyDetectionEventData(data: unknown): data is AnomalyDetectionEventData {\n  if (!data || typeof data !== 'object') return false;\n  const eventData = data as Partial<AnomalyDetectionEventData>;\n  return (\n    !!eventData.anomaly && isAnomaly(eventData.anomaly) && typeof eventData.sectorId === 'string'\n  );\n}\n\n/**\n * Type guard for resource detection event data\n */\ninterface ResourceDetectionEventData {\n  resource: ResourceData;\n  sectorId: string;\n  [key: string]: unknown;\n}\n\nfunction isResourceDetectionEventData(data: unknown): data is ResourceDetectionEventData {\n  if (!data || typeof data !== 'object') return false;\n  const eventData = data as Partial<ResourceDetectionEventData>;\n  return (\n    !!eventData.resource &&\n    isResourceData(eventData.resource) &&\n    typeof eventData.sectorId === 'string'\n  );\n}\n\n/**\n * Type definitions for aggregation operations\n */\n\n/**\n * Type-safe aggregation function\n */\ntype AggregationFunction = 'sum' | 'avg' | 'min' | 'max' | 'count';\n\n/**\n * Interface for aggregation operations\n */\ninterface AggregationOperation {\n  field: string;\n  function: AggregationFunction;\n  outputField: string;\n}\n\n/**\n * Aggregation result interface with properly typed groupValue\n */\ninterface AggregationResult extends Record<string, unknown> {\n  groupValue: string | number | boolean;\n}\n\n/**\n * Service for collecting and preprocessing exploration data\n */\nexport class DataCollectionService {\n  private eventSubscriptions: Array<() => void> = [];\n  private cache: DataCache = {\n    sectors: new Map(),\n    anomalies: new Map(),\n    resources: new Map(),\n    lastUpdated: {\n      sectors: 0,\n      anomalies: 0,\n      resources: 0,\n    },\n  };\n\n  // Set a callback for data updates\n  private onDataUpdated?: (type: 'sector' | 'anomaly' | 'resource', dataPoint: DataPoint) => void;\n\n  // Track statistics about collected data\n  private stats = {\n    totalSectors: 0,\n    totalAnomalies: 0,\n    totalResources: 0,\n    lastCollectionTime: 0,\n    processingTimes: [] as number[],\n    averageProcessingTime: 0,\n  };\n\n  constructor(private explorationManager: ExplorationManager) {}\n\n  /**\n   * Initialize the service and subscribe to events\n   */\n  public initialize(): void {\n    this.subscribeToEvents();\n    this.stats.lastCollectionTime = Date.now();\n  }\n\n  /**\n   * Clean up resources used by the service\n   */\n  public dispose(): void {\n    // Unsubscribe from all events\n    this.eventSubscriptions.forEach(unsubscribe => unsubscribe());\n    this.eventSubscriptions = [];\n\n    // Clear cache\n    this.cache.sectors.clear();\n    this.cache.anomalies.clear();\n    this.cache.resources.clear();\n  }\n\n  /**\n   * Set a callback to be called when data is updated\n   * @param callback The callback function\n   */\n  public setOnDataUpdated(\n    callback: (type: 'sector' | 'anomaly' | 'resource', dataPoint: DataPoint) => void\n  ): void {\n    this.onDataUpdated = callback;\n  }\n\n  /**\n   * Get statistics about the data collection process\n   */\n  public getStats(): {\n    totalSectors: number;\n    totalAnomalies: number;\n    totalResources: number;\n    lastCollectionTime: number;\n    averageProcessingTime: number;\n  } {\n    const avgTime = this.stats.processingTimes.length\n      ? this.stats.processingTimes.reduce((a, b) => a + b, 0) / this.stats.processingTimes.length\n      : 0;\n\n    return {\n      totalSectors: this.stats.totalSectors,\n      totalAnomalies: this.stats.totalAnomalies,\n      totalResources: this.stats.totalResources,\n      lastCollectionTime: this.stats.lastCollectionTime,\n      averageProcessingTime: avgTime,\n    };\n  }\n\n  /**\n   * Subscribe to relevant exploration events\n   */\n  private subscribeToEvents(): void {\n    try {\n      // Subscribe to sector discovery events\n      const unsubscribeSectorDiscovered = this.explorationManager.subscribeToEvent(\n        EXPLORATION_EVENTS.SECTOR_DISCOVERED,\n        this.handleSectorDiscovered.bind(this)\n      );\n\n      // Subscribe to sector scanning events\n      const unsubscribeSectorScanned = this.explorationManager.subscribeToEvent(\n        EXPLORATION_EVENTS.SECTOR_SCANNED,\n        this.handleSectorScanned.bind(this)\n      );\n\n      // Subscribe to anomaly detection events\n      const unsubscribeAnomalyDetected = this.explorationManager.subscribeToEvent(\n        EXPLORATION_EVENTS.ANOMALY_DETECTED,\n        this.handleAnomalyDetected.bind(this)\n      );\n\n      // Subscribe to resource detection events\n      const unsubscribeResourceDetected = this.explorationManager.subscribeToEvent(\n        EXPLORATION_EVENTS.RESOURCE_DETECTED,\n        this.handleResourceDetected.bind(this)\n      );\n\n      // Store unsubscribe functions for cleanup\n      this.eventSubscriptions.push(\n        unsubscribeSectorDiscovered,\n        unsubscribeSectorScanned,\n        unsubscribeAnomalyDetected,\n        unsubscribeResourceDetected\n      );\n    } catch (error) {\n      console.error('Error subscribing to exploration events:', error);\n    }\n  }\n\n  /**\n   * Handle sector discovery events with proper type validation\n   */\n  private handleSectorDiscovered(event: BaseEvent): void {\n    // Ensure this is the correct event type\n    if (!isExplorationEventOfType(event, 'SECTOR_DISCOVERED')) {\n      console.warn('Incorrect event type received:', event?.type);\n      return;\n    }\n\n    // Validate event data\n    if (!isSectorDiscoveryEventData(event.data)) {\n      console.warn('Invalid sector discovery event data:', event.data);\n      return;\n    }\n\n    const { sector } = event.data;\n    const dataPoint = this.processSectorData(sector);\n\n    // Calculate processing time and update stats\n    const processingTime = Date.now() - (event.timestamp || Date.now());\n    this.stats.totalSectors += 1;\n    this.stats.averageProcessingTime =\n      (this.stats.averageProcessingTime * (this.stats.totalSectors - 1) + processingTime) /\n      this.stats.totalSectors;\n    this.stats.lastCollectionTime = Date.now();\n\n    // Store in cache\n    this.cache.sectors.set(dataPoint.id, dataPoint);\n    this.cache.lastUpdated.sectors = Date.now();\n\n    // Notify listener if registered\n    if (this.onDataUpdated) {\n      this.onDataUpdated('sector', dataPoint);\n    }\n  }\n\n  /**\n   * Handle sector scanning events with proper type validation\n   */\n  private handleSectorScanned(event: BaseEvent): void {\n    // Ensure this is the correct event type\n    if (!isExplorationEventOfType(event, 'SECTOR_SCANNED')) {\n      console.warn('Incorrect event type received:', event?.type);\n      return;\n    }\n\n    // Similar to sector discovery but with updated data\n    if (!isSectorDiscoveryEventData(event.data)) {\n      console.warn('Invalid sector scan event data:', event.data);\n      return;\n    }\n\n    const { sector } = event.data;\n    const dataPoint = this.processSectorData(sector);\n\n    // Update cache\n    this.cache.sectors.set(dataPoint.id, dataPoint);\n    this.cache.lastUpdated.sectors = Date.now();\n\n    // Notify listener if registered\n    if (this.onDataUpdated) {\n      this.onDataUpdated('sector', dataPoint);\n    }\n  }\n\n  /**\n   * Handle anomaly detection events with proper type validation\n   */\n  private handleAnomalyDetected(event: BaseEvent): void {\n    // Ensure this is the correct event type\n    if (!isExplorationEventOfType(event, 'ANOMALY_DETECTED')) {\n      console.warn('Incorrect event type received:', event?.type);\n      return;\n    }\n\n    // Validate event data\n    if (!isAnomalyDetectionEventData(event.data)) {\n      console.warn('Invalid anomaly detection event data:', event.data);\n      return;\n    }\n\n    const { anomaly } = event.data;\n    const dataPoint = this.processAnomalyData(anomaly);\n\n    // Update stats\n    this.stats.totalAnomalies += 1;\n    this.stats.lastCollectionTime = Date.now();\n\n    // Store in cache\n    this.cache.anomalies.set(dataPoint.id, dataPoint);\n    this.cache.lastUpdated.anomalies = Date.now();\n\n    // Notify listener if registered\n    if (this.onDataUpdated) {\n      this.onDataUpdated('anomaly', dataPoint);\n    }\n  }\n\n  /**\n   * Handle resource detection events with proper type validation\n   */\n  private handleResourceDetected(event: BaseEvent): void {\n    // Ensure this is the correct event type\n    if (!isExplorationEventOfType(event, 'RESOURCE_DETECTED')) {\n      console.warn('Incorrect event type received:', event?.type);\n      return;\n    }\n\n    // Validate event data\n    if (!isResourceDetectionEventData(event.data)) {\n      console.warn('Invalid resource detection event data:', event.data);\n      return;\n    }\n\n    const { resource } = event.data;\n    const dataPoint = this.processResourceData(resource);\n\n    // Update stats\n    this.stats.totalResources += 1;\n    this.stats.lastCollectionTime = Date.now();\n\n    // Store in cache\n    this.cache.resources.set(dataPoint.id, dataPoint);\n    this.cache.lastUpdated.resources = Date.now();\n\n    // Notify listener if registered\n    if (this.onDataUpdated) {\n      this.onDataUpdated('resource', dataPoint);\n    }\n  }\n\n  /**\n   * Process sector data into a standardized format\n   */\n  private processSectorData(sector: Sector): DataPoint {\n    // Ensure coordinates are valid\n    const coordinates: Coordinates = {\n      x: sector.coordinates?.x ?? 0,\n      y: sector.coordinates?.y ?? 0,\n    };\n\n    // Extract additional metadata that might be useful for analysis\n    const metadata: Record<string, PropertyType> = {\n      anomalyIds: sector.anomalies?.map(a => a.id) ?? [],\n      resourceTypes: sector.resources?.map(r => r.type) ?? [],\n      lastUpdated: sector.lastScanned || Date.now(),\n    };\n\n    // Add region information if available\n    if (sector.coordinates) {\n      metadata.region = `${sector.coordinates.x},${sector.coordinates.y}`;\n    }\n\n    // Calculate additional derived properties\n    const anomalyCount = sector.anomalies?.length ?? 0;\n    const resourceCount = sector.resources?.length ?? 0;\n    const explorationScore = this.calculateExplorationScore(\n      sector.habitabilityScore ?? 0,\n      sector.resourcePotential ?? 0,\n      anomalyCount\n    );\n\n    return {\n      id: sector.id,\n      type: 'sector',\n      name: sector.name,\n      date: sector.discoveredAt || Date.now(),\n      coordinates,\n      properties: {\n        status: sector.status,\n        resourcePotential: sector.resourcePotential ?? 0,\n        habitabilityScore: sector.habitabilityScore ?? 0,\n        anomalyCount,\n        resourceCount,\n        lastScanned: sector.lastScanned ?? 0,\n        explorationScore,\n      },\n      metadata,\n    };\n  }\n\n  /**\n   * Process anomaly data into a standardized format\n   */\n  private processAnomalyData(anomaly: Anomaly): DataPoint {\n    // Create enhanced metadata\n    let metadata: Record<string, PropertyType> = {};\n\n    // Add any existing metadata from anomaly.data\n    if (typeof anomaly.data === 'object' && anomaly.data !== null) {\n      Object.entries(anomaly.data).forEach(([key, value]) => {\n        if (\n          typeof value === 'string' ||\n          typeof value === 'number' ||\n          typeof value === 'boolean' ||\n          (Array.isArray(value) && value.every(item => typeof item === 'string'))\n        ) {\n          metadata[key] = value as PropertyType;\n        } else if (value !== undefined && value !== null) {\n          // Convert non-matching types to string if possible\n          metadata[key] = String(value);\n        }\n      });\n    }\n\n    // Add investigation status metadata\n    metadata.investigated = anomaly.investigatedAt ? true : false;\n    metadata.investigationAge = anomaly.investigatedAt ? Date.now() - anomaly.investigatedAt : 0;\n\n    // Fix the type mismatch in calculateRiskAssessment call\n    // Convert anomaly.severity from string to number\n    const severityAsNumber =\n      typeof anomaly.severity === 'string'\n        ? (parseFloat(anomaly.severity) ?? 0)\n        : (anomaly.severity ?? 0);\n\n    // Calculate risk assessment based on severity and type\n    const riskAssessment = this.calculateRiskAssessment(severityAsNumber, anomaly.type);\n    if (!metadata) {\n      metadata = {};\n    }\n    metadata.riskAssessment = riskAssessment;\n\n    // Ensure coordinates are valid\n    const coordinates: Coordinates = {\n      x: anomaly.position?.x ?? 0,\n      y: anomaly.position?.y ?? 0,\n    };\n\n    return {\n      id: anomaly.id,\n      type: 'anomaly',\n      name: `${anomaly.type} Anomaly`,\n      date: anomaly.discoveredAt,\n      coordinates,\n      properties: {\n        type: anomaly.type,\n        severity: anomaly.severity,\n        description: anomaly.description,\n        investigatedAt: anomaly.investigatedAt ?? 0,\n        sectorId: anomaly.sectorId,\n        riskFactor: this.calculateRiskFactor(severityAsNumber, riskAssessment),\n      },\n      metadata,\n    };\n  }\n\n  /**\n   * Process resource data into a standardized format\n   */\n  private processResourceData(resource: ResourceData): DataPoint {\n    // Ensure coordinates are provided with defaults\n    // Handle the type more explicitly to avoid property access issues\n    const resourceCoords = resource.coordinates as { x?: number; y?: number } | undefined;\n    const coordinates: Coordinates = {\n      x: resourceCoords?.x ?? 0,\n      y: resourceCoords?.y ?? 0,\n    };\n\n    // Cast accessibility to ensure it's a PropertyType\n    const accessibility = resource.accessibility !== undefined ? Number(resource.accessibility) : 1;\n\n    // Create enhanced metadata\n    const metadata: Record<string, PropertyType> = {\n      estimatedValue: resource.amount * (resource.quality || 1),\n      accessibility,\n      harvestEfficiency: this.calculateHarvestEfficiency(accessibility, resource.quality || 1),\n    };\n\n    // Add extraction difficulty if available\n    if (resource.extractionDifficulty !== undefined) {\n      metadata.extractionDifficulty = Number(resource.extractionDifficulty);\n    }\n\n    // Add purity grade based on quality\n    metadata.purityGrade = this.calculatePurityGrade(resource.quality || 1);\n\n    // Add resource density if available or calculate a default\n    metadata.density =\n      resource.density !== undefined ? Number(resource.density) : resource.amount / 100;\n\n    // Calculate resource potential score\n    const potentialScore = this.calculateResourcePotential(\n      resource.amount,\n      resource.quality || 1,\n      accessibility\n    );\n\n    // Add additional resource data if available\n    if (typeof resource.data === 'object' && resource.data !== null) {\n      Object.entries(resource.data).forEach(([key, value]) => {\n        if (\n          typeof value === 'string' ||\n          typeof value === 'number' ||\n          typeof value === 'boolean' ||\n          (Array.isArray(value) && value.every(item => typeof item === 'string'))\n        ) {\n          metadata[key] = value as PropertyType;\n        }\n      });\n    }\n\n    return {\n      id: resource.sectorId ? `${resource.sectorId}-${resource.type}` : uuidv4(),\n      type: 'resource',\n      name: `${resource.type} Resource`,\n      date: Date.now(),\n      coordinates,\n      properties: {\n        type: resource.type,\n        amount: resource.amount,\n        quality: resource.quality || 1,\n        sectorId: resource.sectorId ?? '',\n        potentialScore,\n      },\n      metadata,\n    };\n  }\n\n  /**\n   * Calculate an exploration score for a sector based on its properties\n   */\n  private calculateExplorationScore(\n    habitability: number,\n    resourcePotential: number,\n    anomalyCount: number\n  ): number {\n    // Higher values of each component increase the score\n    // Anomalies add significant value to exploration\n    const habitabilityFactor = habitability * 0.3;\n    const resourceFactor = resourcePotential * 0.4;\n    const anomalyFactor = Math.min(anomalyCount * 0.1, 0.3); // Cap at 30% influence\n\n    // Calculate score on a scale of 0-100\n    const score = (habitabilityFactor + resourceFactor + anomalyFactor) * 100;\n\n    // Ensure score is within 0-100 range\n    return Math.min(100, Math.max(0, score));\n  }\n\n  /**\n   * Calculate a risk assessment value for an anomaly\n   */\n  private calculateRiskAssessment(severity: number, type: string): number {\n    // Base risk is determined by severity (0-10 scale)\n    let riskBase = severity ?? 0;\n\n    // Adjust risk based on anomaly type\n    // Higher risk for dangerous anomaly types\n    const highRiskTypes = ['radiation', 'temporal', 'gravitational', 'void'];\n    const mediumRiskTypes = ['magnetic', 'spatial', ResourceType.ENERGY];\n\n    if (highRiskTypes.some(t => type.toLowerCase().includes(t))) {\n      riskBase *= 1.5; // 50% higher risk\n    } else if (mediumRiskTypes.some(t => type.toLowerCase().includes(t))) {\n      riskBase *= 1.2; // 20% higher risk\n    }\n\n    // Normalize to 0-10 scale\n    return Math.min(10, Math.max(0, riskBase));\n  }\n\n  /**\n   * Calculate a risk factor combining severity and risk assessment\n   */\n  private calculateRiskFactor(severity: number, riskAssessment: number): number {\n    // Combined measure considering both severity and risk assessment\n    return severity * 0.6 + riskAssessment * 0.4;\n  }\n\n  /**\n   * Calculate a harvest efficiency rating based on accessibility and quality\n   */\n  private calculateHarvestEfficiency(accessibility: number, quality: number): number {\n    // Higher quality resources with better accessibility are more efficient to harvest\n    // Efficiency is on a 0-1 scale\n    const accessibilityFactor = Math.min(1, Math.max(0, accessibility));\n    const qualityFactor = quality / 10; // Normalize quality to 0-1 range (assuming quality 0-10)\n\n    return accessibilityFactor * (0.7 + qualityFactor * 0.3); // Accessibility has more weight\n  }\n\n  /**\n   * Calculate resource potential score based on key factors\n   */\n  private calculateResourcePotential(\n    amount: number,\n    quality: number,\n    accessibility: number\n  ): number {\n    // Normalize inputs\n    const normalizedAmount = Math.min(1, amount / 1000); // Cap at 1000 units\n    const normalizedQuality = quality / 10; // Assuming quality range 0-10\n    const normalizedAccessibility = Math.min(1, Math.max(0, accessibility));\n\n    // Weight factors differently based on importance\n    const amountWeight = 0.5;\n    const qualityWeight = 0.3;\n    const accessibilityWeight = 0.2;\n\n    // Calculate weighted score\n    const score =\n      normalizedAmount * amountWeight +\n      normalizedQuality * qualityWeight +\n      normalizedAccessibility * accessibilityWeight;\n\n    // Return score on 0-100 scale\n    return Math.round(score * 100);\n  }\n\n  /**\n   * Determine purity grade based on quality value\n   */\n  private calculatePurityGrade(quality: number): string {\n    if (quality >= 9) return 'Ultra-Pure';\n    if (quality >= 7) return 'Premium';\n    if (quality >= 5) return 'Standard';\n    if (quality >= 3) return 'Low-Grade';\n    return 'Impure';\n  }\n\n  /**\n   * Get all cached sector data\n   */\n  public getSectorData(): DataPoint[] {\n    return Array.from(this.cache.sectors.values());\n  }\n\n  /**\n   * Get all cached anomaly data\n   */\n  public getAnomalyData(): DataPoint[] {\n    return Array.from(this.cache.anomalies.values());\n  }\n\n  /**\n   * Get all cached resource data\n   */\n  public getResourceData(): DataPoint[] {\n    return Array.from(this.cache.resources.values());\n  }\n\n  /**\n   * Get all data of a specific type\n   */\n  public getData(type: 'sector' | 'anomaly' | 'resource'): DataPoint[] {\n    switch (type) {\n      case 'sector':\n        return this.getSectorData();\n      case 'anomaly':\n        return this.getAnomalyData();\n      case 'resource':\n        return this.getResourceData();\n      default:\n        return [];\n    }\n  }\n\n  /**\n   * Get all data as a single array\n   */\n  public getAllData(): DataPoint[] {\n    return [...this.getSectorData(), ...this.getAnomalyData(), ...this.getResourceData()];\n  }\n\n  /**\n   * Filter data by property values\n   */\n  public filterData(\n    data: DataPoint[],\n    filters: Array<{\n      field: string;\n      operator:\n        | 'equals'\n        | 'notEquals'\n        | 'greaterThan'\n        | 'lessThan'\n        | 'contains'\n        | 'notContains'\n        | 'between';\n      value: string | number | boolean | string[] | [number, number];\n    }>\n  ): DataPoint[] {\n    if (!filters.length) return data;\n\n    return data?.filter(dataPoint => {\n      return filters.every(filter => {\n        const fieldParts = filter.field.split('.');\n        let currentValue: unknown = dataPoint;\n\n        // Traverse nested properties\n        for (const part of fieldParts) {\n          if (currentValue === undefined || currentValue === null) return false;\n          currentValue = (currentValue as Record<string, unknown>)[part];\n        }\n\n        // Apply filter based on operator\n        switch (filter.operator) {\n          case 'equals':\n            return currentValue === filter.value;\n          case 'notEquals':\n            return currentValue !== filter.value;\n          case 'greaterThan':\n            return (\n              typeof currentValue === 'number' &&\n              typeof filter.value === 'number' &&\n              currentValue > filter.value\n            );\n          case 'lessThan':\n            return (\n              typeof currentValue === 'number' &&\n              typeof filter.value === 'number' &&\n              currentValue < filter.value\n            );\n          case 'contains':\n            if (typeof currentValue === 'string' && typeof filter.value === 'string') {\n              return currentValue.toLowerCase().includes(filter.value.toLowerCase());\n            }\n            if (Array.isArray(currentValue) && !Array.isArray(filter.value)) {\n              return currentValue.includes(filter.value);\n            }\n            return false;\n          case 'notContains':\n            if (typeof currentValue === 'string' && typeof filter.value === 'string') {\n              return !currentValue.toLowerCase().includes(filter.value.toLowerCase());\n            }\n            if (Array.isArray(currentValue) && !Array.isArray(filter.value)) {\n              return !currentValue.includes(filter.value);\n            }\n            return false;\n          case 'between':\n            if (\n              typeof currentValue === 'number' &&\n              Array.isArray(filter.value) &&\n              filter.value.length === 2 &&\n              typeof filter.value[0] === 'number' &&\n              typeof filter.value[1] === 'number'\n            ) {\n              return currentValue >= filter.value[0] && currentValue <= filter.value[1];\n            }\n            return false;\n          default:\n            return false;\n        }\n      });\n    });\n  }\n\n  /**\n   * Get the last update time for a specific data type\n   */\n  public getLastUpdated(type: 'sector' | 'anomaly' | 'resource'): number {\n    return this.cache.lastUpdated[type];\n  }\n\n  /**\n   * Transform data points using a custom transformation function with type safety\n   *\n   * @param data Array of DataPoints to transform\n   * @param transformFn Function that transforms a DataPoint\n   * @returns Array of transformed DataPoints\n   */\n  public transformData(\n    data: DataPoint[],\n    transformFn: (dataPoint: DataPoint) => Partial<DataPoint>\n  ): DataPoint[] {\n    return data?.map(dataPoint => {\n      const transformed = transformFn(dataPoint);\n\n      // Validate transformed data\n      if (!transformed || typeof transformed !== 'object') {\n        console.warn('Invalid transformation result:', transformed);\n        return dataPoint;\n      }\n\n      // Apply transformation and ensure required properties are preserved\n      return {\n        ...dataPoint,\n        ...transformed,\n        // Ensure id and type are always preserved\n        id: transformed.id || dataPoint.id,\n        type: transformed.type || dataPoint.type,\n      };\n    });\n  }\n\n  private isStringOrNumberOrBoolean(value: unknown): value is string | number | boolean {\n    return typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean';\n  }\n\n  /**\n   * Apply an aggregation function to a set of values\n   *\n   * @param values Array of values to aggregate\n   * @param aggregationFn The aggregation function to apply\n   * @returns The result of the aggregation\n   */\n  private applyAggregation(values: unknown[], aggregationFn: AggregationFunction): number {\n    // Filter out non-numeric values\n    const numericValues = values.filter(\n      value => typeof value === 'number' || (typeof value === 'string' && !isNaN(Number(value)))\n    );\n\n    // Convert to numbers\n    const numbers = numericValues.map(v => (typeof v === 'number' ? v : Number(v)));\n\n    if (numbers.length === 0) {\n      return 0;\n    }\n\n    // Apply the aggregation function\n    switch (aggregationFn) {\n      case 'sum':\n        return numbers.reduce((sum, value) => sum + value, 0);\n      case 'avg':\n        return numbers.reduce((sum, value) => sum + value, 0) / numbers.length;\n      case 'min':\n        return Math.min(...numbers);\n      case 'max':\n        return Math.max(...numbers);\n      case 'count':\n        return numbers.length;\n      default:\n        return 0;\n    }\n  }\n\n  /**\n   * Aggregate data by a group field and apply aggregation functions\n   *\n   * @param data The data points to aggregate\n   * @param groupByField The field to group by\n   * @param aggregations The aggregation operations to perform\n   * @returns Array of aggregation results\n   */\n  public aggregateData(\n    data: DataPoint[],\n    groupByField: string,\n    aggregations: AggregationOperation[]\n  ): AggregationResult[] {\n    // Group data by the specified field\n    const groups = new Map<string | number | boolean, DataPoint[]>();\n\n    // First pass: group the data\n    data?.forEach(dataPoint => {\n      const groupValue = getNestedProperty(dataPoint, groupByField);\n\n      // Skip items where the group value isn't a valid primitive type\n      if (!this.isStringOrNumberOrBoolean(groupValue)) {\n        return;\n      }\n\n      // Add to group\n      const group = groups.get(groupValue) ?? [];\n      group.push(dataPoint);\n      groups.set(groupValue, group);\n    });\n\n    // Second pass: calculate aggregations\n    const results: AggregationResult[] = [];\n\n    groups.forEach((groupData, groupValue) => {\n      const result: AggregationResult = {\n        groupValue,\n      };\n\n      // Apply each aggregation function\n      aggregations.forEach(agg => {\n        // Get values for the field from all items in the group\n        const values = groupData.map(dataPoint => getNestedProperty(dataPoint, agg.field));\n\n        // Apply the aggregation function\n        result[agg.outputField] = this.applyAggregation(values, agg.function);\n      });\n\n      results.push(result);\n    });\n\n    return results;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/services/DataProcessingService.ts","messages":[{"ruleId":"no-unsafe-optional-chaining","severity":2,"message":"Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.","line":69,"column":35,"nodeType":"ChainExpression","messageId":"unsafeOptionalChain","endLine":69,"endColumn":46}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { WorkerMessageType } from '../workers/DataProcessingWorker';\n\n/**\n * Service for interfacing with the DataProcessingWorker\n *\n * This service provides a promise-based API for offloading data processing\n * tasks to a web worker, keeping the UI thread responsive even during\n * computationally intensive operations.\n */\nexport class DataProcessingService {\n  private worker: Worker | null = null;\n  private pendingRequests = new Map<\n    string,\n    {\n      resolve: (value: unknown) => void;\n      reject: (reason: unknown) => void;\n    }\n  >();\n  private isWorkerInitialized = false;\n  private workerInitPromise: Promise<void> | null = null;\n\n  /**\n   * Initialize the web worker\n   */\n  private initWorker(): Promise<void> {\n    if (this.isWorkerInitialized) {\n      return Promise.resolve();\n    }\n\n    if (this.workerInitPromise) {\n      return this.workerInitPromise;\n    }\n\n    this.workerInitPromise = new Promise<void>((resolve, reject) => {\n      try {\n        // Create worker\n        this.worker = new Worker(new URL('../workers/DataProcessingWorker.ts', import.meta.url), {\n          type: 'module',\n        });\n\n        // Set up message handler\n        this.worker.addEventListener('message', this.handleWorkerMessage);\n\n        // Set up error handler\n        this.worker.addEventListener('error', error => {\n          console.error('Web worker error:', error);\n          this.pendingRequests.forEach(request => {\n            request.reject(new Error('Web worker encountered an error.'));\n          });\n          this.pendingRequests.clear();\n          reject(error);\n        });\n\n        this.isWorkerInitialized = true;\n        resolve();\n      } catch (error) {\n        console.error('Failed to initialize web worker:', error);\n        reject(error);\n      }\n    });\n\n    return this.workerInitPromise;\n  }\n\n  /**\n   * Handle messages received from the web worker\n   */\n  private handleWorkerMessage = (event: MessageEvent): void => {\n    const { id, result, error } = event?.data;\n\n    // Look up the pending request\n    const request = this.pendingRequests.get(id);\n    if (!request) {\n      console.warn(`Received response for unknown request ID: ${id}`);\n      return;\n    }\n\n    // Remove the request from the pending map\n    this.pendingRequests.delete(id);\n\n    // Resolve or reject the promise\n    if (error) {\n      request.reject(new Error(error));\n    } else {\n      request.resolve(result);\n    }\n  };\n\n  /**\n   * Generate a unique request ID\n   */\n  private generateRequestId(): string {\n    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  /**\n   * Send a message to the web worker and return a promise\n   */\n  private sendToWorker<T>(type: WorkerMessageType, payload: unknown): Promise<T> {\n    return this.initWorker().then(() => {\n      return new Promise<T>((resolve, reject) => {\n        const id = this.generateRequestId();\n\n        // Store the promise's resolve and reject functions\n        this.pendingRequests.set(id, {\n          resolve: value => resolve(value as T),\n          reject,\n        });\n\n        // Send the message to the worker\n        this.worker?.postMessage({ type, id, payload });\n      });\n    });\n  }\n\n  /**\n   * Sort data by a key\n   */\n  public sortData<T extends Record<string, unknown>>(\n    data: T[],\n    key: string,\n    order: 'asc' | 'desc' = 'asc'\n  ): Promise<T[]> {\n    return this.sendToWorker<T[]>(WorkerMessageType.DATA_SORTING, {\n      data,\n      key,\n      order,\n    });\n  }\n\n  /**\n   * Filter data based on conditions\n   */\n  public filterData<T extends Record<string, unknown>>(\n    data: T[],\n    conditions: {\n      key: string;\n      operator: '==' | '!=' | '>' | '<' | '>=' | '<=' | 'contains' | 'startsWith' | 'endsWith';\n      value: unknown;\n    }[],\n    matchAll: boolean = true\n  ): Promise<T[]> {\n    return this.sendToWorker<T[]>(WorkerMessageType.DATA_FILTERING, {\n      data,\n      conditions,\n      matchAll,\n    });\n  }\n\n  /**\n   * Calculate statistics on numerical data\n   */\n  public calculateStatistics(\n    data: number[],\n    operations: ('mean' | 'median' | 'mode' | 'stdDev' | 'variance' | 'min' | 'max' | 'sum')[] = [\n      'mean',\n      'median',\n      'stdDev',\n      'min',\n      'max',\n    ]\n  ): Promise<{\n    mean?: number;\n    median?: number;\n    mode?: number[];\n    stdDev?: number;\n    variance?: number;\n    min?: number;\n    max?: number;\n    sum?: number;\n  }> {\n    return this.sendToWorker(WorkerMessageType.CALCULATE_STATISTICS, {\n      data,\n      operations,\n    });\n  }\n\n  /**\n   * Process clustering data\n   */\n  public processClustering(payload: unknown): Promise<unknown> {\n    return this.sendToWorker(WorkerMessageType.PROCESS_CLUSTERING, payload);\n  }\n\n  /**\n   * Process prediction data\n   */\n  public processPrediction(payload: unknown): Promise<unknown> {\n    return this.sendToWorker(WorkerMessageType.PROCESS_PREDICTION, payload);\n  }\n\n  /**\n   * Process resource mapping data\n   */\n  public processResourceMapping(payload: unknown): Promise<unknown> {\n    return this.sendToWorker(WorkerMessageType.PROCESS_RESOURCE_MAPPING, payload);\n  }\n\n  /**\n   * Transform data\n   */\n  public transformData(payload: unknown): Promise<unknown> {\n    return this.sendToWorker(WorkerMessageType.TRANSFORM_DATA, payload);\n  }\n\n  /**\n   * Terminate the web worker\n   */\n  public terminate(): void {\n    if (this.worker) {\n      this.worker.terminate();\n      this.worker = null;\n      this.isWorkerInitialized = false;\n      this.workerInitPromise = null;\n    }\n  }\n\n  /**\n   * Singleton instance\n   */\n  private static instance: DataProcessingService | null = null;\n\n  /**\n   * Get the singleton instance\n   */\n  public static getInstance(): DataProcessingService {\n    if (!DataProcessingService.instance) {\n      DataProcessingService.instance = new DataProcessingService();\n    }\n    return DataProcessingService.instance;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/services/ErrorLoggingService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/services/EventPropagationService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'dependencies' is defined but never used.","line":24,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":24,"endColumn":44}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { AbstractBaseService } from '../lib/services/BaseService';\nimport { componentRegistryService } from './ComponentRegistryService';\nimport { ErrorType, errorLoggingService } from './ErrorLoggingService';\n\nexport interface EventSubscription {\n  eventType: string;\n  priority: number;\n  callback: (eventData: unknown) => void;\n}\n\n/**\n * @context: service-system, event-system\n * Service for managing event propagation and subscription throughout the application\n */\nclass EventPropagationServiceImpl extends AbstractBaseService<EventPropagationServiceImpl> {\n  private subscriptions: Map<string, EventSubscription[]> = new Map();\n  private eventQueue: Array<{ type: string; data: unknown }> = [];\n  private isProcessing = false;\n\n  public constructor() {\n    super('EventPropagationService', '1.0.0');\n  }\n\n  protected async onInitialize(dependencies?: Record<string, unknown>): Promise<void> {\n    // Initialize metrics\n    if (!this.metadata.metrics) {\n      this.metadata.metrics = {};\n    }\n    this.metadata.metrics = {\n      total_subscriptions: 0,\n      total_event_types: 0,\n      total_events_emitted: 0,\n      total_events_processed: 0,\n      total_errors: 0,\n    };\n  }\n\n  protected async onDispose(): Promise<void> {\n    // Clear all subscriptions and queued events\n    this.subscriptions.clear();\n    this.eventQueue = [];\n  }\n\n  public subscribe(subscription: EventSubscription): () => void {\n    const { eventType } = subscription;\n\n    if (!this.subscriptions.has(eventType)) {\n      this.subscriptions.set(eventType, []);\n    }\n\n    const subscribers = this.subscriptions.get(eventType)!;\n    subscribers.push(subscription);\n\n    // Sort by priority (higher numbers first)\n    subscribers.sort((a, b) => b.priority - a.priority);\n\n    // Update metrics\n    if (!this.metadata.metrics) {\n      this.metadata.metrics = {};\n    }\n    const metrics = this.metadata.metrics;\n    metrics.total_subscriptions = Array.from(this.subscriptions.values()).reduce(\n      (sum, subs) => sum + subs.length,\n      0\n    );\n    metrics.total_event_types = this.subscriptions.size;\n    this.metadata.metrics = metrics;\n\n    // Return unsubscribe function\n    return () => {\n      const index = subscribers.indexOf(subscription);\n      if (index !== -1) {\n        subscribers.splice(index, 1);\n        if (subscribers.length === 0) {\n          this.subscriptions.delete(eventType);\n        }\n\n        // Update metrics\n        if (!this.metadata.metrics) {\n          this.metadata.metrics = {};\n        }\n        const metrics = this.metadata.metrics;\n        metrics.total_subscriptions = Array.from(this.subscriptions.values()).reduce(\n          (sum, subs) => sum + subs.length,\n          0\n        );\n        metrics.total_event_types = this.subscriptions.size;\n        this.metadata.metrics = metrics;\n      }\n    };\n  }\n\n  public emit(eventType: string, eventData: unknown): void {\n    // Add event to queue\n    this.eventQueue.push({ type: eventType, data: eventData });\n\n    // Update metrics\n    if (!this.metadata.metrics) {\n      this.metadata.metrics = {};\n    }\n    const metrics = this.metadata.metrics;\n    metrics.total_events_emitted = (metrics.total_events_emitted ?? 0) + 1;\n    metrics.last_event_timestamp = Date.now();\n    this.metadata.metrics = metrics;\n\n    // Process queue if not already processing\n    if (!this.isProcessing) {\n      this.processEventQueue();\n    }\n  }\n\n  private async processEventQueue(): Promise<void> {\n    if (this.isProcessing || this.eventQueue.length === 0) {\n      return;\n    }\n\n    this.isProcessing = true;\n\n    try {\n      while (this.eventQueue.length > 0) {\n        const event = this.eventQueue.shift()!;\n        await this.processEvent(event?.type, event?.data);\n      }\n    } catch (error) {\n      this.handleError(error as Error);\n    } finally {\n      this.isProcessing = false;\n    }\n  }\n\n  private async processEvent(eventType: string, eventData: unknown): Promise<void> {\n    // Get subscribers for this event type\n    const subscribers = this.subscriptions.get(eventType) ?? [];\n\n    // Notify component registry\n    componentRegistryService.notifyComponentsOfEvent(eventType, eventData);\n\n    // Call subscribers in priority order\n    for (const subscriber of subscribers) {\n      try {\n        await subscriber.callback(eventData);\n      } catch (error) {\n        this.handleError(error as Error);\n      }\n    }\n\n    // Update metrics\n    if (!this.metadata.metrics) {\n      this.metadata.metrics = {};\n    }\n    const metrics = this.metadata.metrics;\n    metrics.total_events_processed = (metrics.total_events_processed ?? 0) + 1;\n    metrics.last_processed_timestamp = Date.now();\n    this.metadata.metrics = metrics;\n  }\n\n  public override handleError(error: Error, context?: Record<string, unknown>): void {\n    // Update error metrics\n    if (!this.metadata.metrics) {\n      this.metadata.metrics = {};\n    }\n    const metrics = this.metadata.metrics;\n    metrics.total_errors = (metrics.total_errors ?? 0) + 1;\n    metrics.last_error_timestamp = Date.now();\n    this.metadata.metrics = metrics;\n\n    // Forward to error logging service\n    errorLoggingService.logError(error, ErrorType.RUNTIME, undefined, {\n      service: 'EventPropagationService',\n      ...context,\n    });\n\n    // Log error in development\n    if (process.env.NODE_ENV === 'development') {\n      console.error('[EventPropagationService] Error:', error);\n    }\n  }\n}\n\n// Export singleton instance\nexport const eventPropagationService = new EventPropagationServiceImpl();\n\n// Export default for easier imports\nexport default eventPropagationService;\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/services/RealTimeDataService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'dependencies' is defined but never used.","line":52,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":52,"endColumn":44}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @file RealTimeDataService.ts\n * Service for managing real-time data streams for visualization components\n *\n * This service:\n * 1. Manages data streams and subscriptions\n * 2. Handles data generators for simulated real-time data\n * 3. Provides data buffering and interpolation capabilities\n * 4. Implements performance optimizations for smooth visualizations\n */\n\nimport { AbstractBaseService } from '../lib/services/BaseService';\nimport { apiService } from './APIService';\nimport { ErrorType, errorLoggingService } from './ErrorLoggingService';\n\nexport interface DataBuffer<T> {\n  data: T[];\n  capacity: number;\n  head: number;\n  tail: number;\n  isFull: boolean;\n}\n\nexport interface TimeWindow {\n  duration: number; // in milliseconds\n  resolution: number; // data points per window\n}\n\nexport interface StreamConfig {\n  bufferSize: number;\n  batchSize: number;\n  timeWindow?: TimeWindow;\n  updateInterval: number;\n}\n\nexport interface DataGenerator<T> {\n  generateData: () => T;\n  configureGenerator: (config: Record<string, unknown>) => void;\n}\n\nclass RealTimeDataServiceImpl extends AbstractBaseService<RealTimeDataServiceImpl> {\n  private dataBuffers: Map<string, DataBuffer<unknown>> = new Map();\n  private streamConfigs: Map<string, StreamConfig> = new Map();\n  private streamIds: Map<string, string> = new Map();\n  private listeners: Map<string, Set<(data: unknown[]) => void>> = new Map();\n  private generators: Map<string, DataGenerator<unknown>> = new Map();\n\n  public constructor() {\n    super('RealTimeDataService', '1.0.0');\n  }\n\n  protected async onInitialize(dependencies?: Record<string, unknown>): Promise<void> {\n    if (!this.metadata.metrics) {\n      this.metadata.metrics = {};\n    }\n    this.metadata.metrics = {\n      active_streams: 0,\n      total_data_points: 0,\n      buffer_utilization: 0,\n      update_rate: 0,\n      generators_active: 0,\n    };\n  }\n\n  protected async onDispose(): Promise<void> {\n    const streamIds = Array.from(this.streamIds.values());\n    await Promise.all(streamIds.map(id => this.stopStream(id)));\n\n    this.dataBuffers.clear();\n    this.streamConfigs.clear();\n    this.streamIds.clear();\n    this.listeners.clear();\n    this.generators.clear();\n  }\n\n  public createBuffer<T>(id: string, capacity: number): DataBuffer<T> {\n    const buffer: DataBuffer<T> = {\n      data: new Array(capacity),\n      capacity,\n      head: 0,\n      tail: 0,\n      isFull: false,\n    };\n    this.dataBuffers.set(id, buffer);\n    return buffer;\n  }\n\n  public appendData<T>(bufferId: string, newData: T[]): void {\n    const buffer = this.dataBuffers.get(bufferId) as DataBuffer<T>;\n    if (!buffer) {\n      throw new Error(`Buffer '${bufferId}' not found`);\n    }\n\n    for (const item of newData) {\n      buffer.data[buffer.tail] = item;\n      buffer.tail = (buffer.tail + 1) % buffer.capacity;\n\n      if (buffer.tail === buffer.head) {\n        buffer.head = (buffer.head + 1) % buffer.capacity;\n        buffer.isFull = true;\n      }\n    }\n\n    if (!this.metadata.metrics) {\n      this.metadata.metrics = {};\n    }\n    const metrics = this.metadata.metrics;\n    metrics.total_data_points += newData.length;\n    metrics.buffer_utilization = this.calculateBufferUtilization(buffer);\n    this.metadata.metrics = metrics;\n\n    this.notifyListeners(bufferId);\n  }\n\n  public async startStream<T>(\n    endpoint: string,\n    bufferId: string,\n    config: Partial<StreamConfig> = {}\n  ): Promise<void> {\n    const defaultConfig: StreamConfig = {\n      bufferSize: 1000,\n      batchSize: 100,\n      updateInterval: 1000,\n    };\n\n    const streamConfig = { ...defaultConfig, ...config };\n    this.streamConfigs.set(bufferId, streamConfig);\n\n    if (!this.dataBuffers.has(bufferId)) {\n      this.createBuffer<T>(bufferId, streamConfig.bufferSize);\n    }\n\n    // Start API stream or generator stream\n    const generator = this.generators.get(bufferId);\n    if (generator) {\n      this.startGeneratorStream(bufferId, streamConfig.updateInterval);\n    } else {\n      const streamId = await apiService.startStream(\n        endpoint,\n        data => this.handleStreamData(bufferId, data as T[]),\n        {\n          batchSize: streamConfig.batchSize,\n          interval: streamConfig.updateInterval,\n          maxRetries: 3,\n        }\n      );\n      this.streamIds.set(bufferId, streamId);\n    }\n\n    if (!this.metadata.metrics) {\n      this.metadata.metrics = {};\n    }\n    const metrics = this.metadata.metrics;\n    metrics.active_streams = this.streamIds.size;\n    this.metadata.metrics = metrics;\n  }\n\n  public async stopStream(bufferId: string): Promise<void> {\n    const streamId = this.streamIds.get(bufferId);\n    if (streamId) {\n      await apiService.stopStream(streamId);\n      this.streamIds.delete(bufferId);\n    }\n\n    // Stop generator if exists\n    if (this.generators.has(bufferId)) {\n      this.generators.delete(bufferId);\n    }\n\n    if (!this.metadata.metrics) {\n      this.metadata.metrics = {};\n    }\n    const metrics = this.metadata.metrics;\n    metrics.active_streams = this.streamIds.size;\n    metrics.generators_active = this.generators.size;\n    this.metadata.metrics = metrics;\n  }\n\n  public subscribe<T>(bufferId: string, callback: (data: T[]) => void): () => void {\n    if (!this.listeners.has(bufferId)) {\n      this.listeners.set(bufferId, new Set());\n    }\n\n    const listeners = this.listeners.get(bufferId)!;\n    listeners.add(callback as (data: unknown[]) => void);\n\n    return () => {\n      listeners.delete(callback as (data: unknown[]) => void);\n      if (listeners.size === 0) {\n        this.listeners.delete(bufferId);\n      }\n    };\n  }\n\n  public getBufferData<T>(bufferId: string): T[] {\n    const buffer = this.dataBuffers.get(bufferId) as DataBuffer<T>;\n    if (!buffer) {\n      throw new Error(`Buffer '${bufferId}' not found`);\n    }\n\n    if (buffer.head <= buffer.tail) {\n      return buffer.data.slice(buffer.head, buffer.tail) as T[];\n    } else {\n      return [...buffer.data.slice(buffer.head), ...buffer.data.slice(0, buffer.tail)] as T[];\n    }\n  }\n\n  public registerGenerator<T>(bufferId: string, generator: DataGenerator<T>): void {\n    this.generators.set(bufferId, generator as DataGenerator<unknown>);\n\n    if (!this.metadata.metrics) {\n      this.metadata.metrics = {};\n    }\n    const metrics = this.metadata.metrics;\n    metrics.generators_active = this.generators.size;\n    this.metadata.metrics = metrics;\n  }\n\n  public createSineWaveGenerator(\n    amplitude: number = 50,\n    offset: number = 50,\n    period: number = 20,\n    noise: number = 0\n  ): DataGenerator<number> {\n    let step = 0;\n\n    return {\n      generateData: () => {\n        const value = Math.sin((step / period) * 2 * Math.PI) * amplitude + offset;\n        const noisyValue = value + (Math.random() * 2 - 1) * noise;\n        step++;\n        return noisyValue;\n      },\n      configureGenerator: (config: Record<string, unknown>) => {\n        if (typeof config.amplitude === 'number') amplitude = config.amplitude;\n        if (typeof config.offset === 'number') offset = config.offset;\n        if (typeof config.period === 'number') period = config.period;\n        if (typeof config.noise === 'number') noise = config.noise;\n        if (config.resetStep) step = 0;\n      },\n    };\n  }\n\n  public createRandomWalkGenerator(\n    initialValue: number = 50,\n    step: number = 1,\n    bounds: [number, number] = [0, 100]\n  ): DataGenerator<number> {\n    let currentValue = initialValue;\n\n    return {\n      generateData: () => {\n        const randomStep = (Math.random() * 2 - 1) * step;\n        currentValue = Math.max(bounds[0], Math.min(bounds[1], currentValue + randomStep));\n        return currentValue;\n      },\n      configureGenerator: (config: Record<string, unknown>) => {\n        if (typeof config.step === 'number') step = config.step;\n        if (Array.isArray(config.bounds) && config.bounds.length === 2) {\n          bounds = config.bounds as [number, number];\n        }\n        if (typeof config.reset === 'number') currentValue = config.reset;\n      },\n    };\n  }\n\n  private handleStreamData<T>(bufferId: string, data: T[]): void {\n    this.appendData(bufferId, data);\n\n    if (!this.metadata.metrics) {\n      this.metadata.metrics = {};\n    }\n    const metrics = this.metadata.metrics;\n    const config = this.streamConfigs.get(bufferId);\n    if (config) {\n      metrics.update_rate = data.length / (config.updateInterval / 1000);\n    }\n    this.metadata.metrics = metrics;\n  }\n\n  private startGeneratorStream(bufferId: string, interval: number): void {\n    const generator = this.generators.get(bufferId);\n    if (!generator) return;\n\n    const intervalId = setInterval(() => {\n      const data = generator.generateData();\n      this.appendData(bufferId, [data]);\n    }, interval);\n\n    // Store interval ID for cleanup\n    this.streamIds.set(bufferId, intervalId.toString());\n  }\n\n  private notifyListeners(bufferId: string): void {\n    const listeners = this.listeners.get(bufferId);\n    if (!listeners) return;\n\n    const data = this.getBufferData(bufferId);\n    listeners.forEach(callback => {\n      try {\n        callback(data);\n      } catch (error) {\n        this.handleError(error as Error);\n      }\n    });\n  }\n\n  private calculateBufferUtilization(buffer: DataBuffer<unknown>): number {\n    if (buffer.isFull) return 1;\n    return buffer.tail >= buffer.head\n      ? (buffer.tail - buffer.head) / buffer.capacity\n      : (buffer.capacity - buffer.head + buffer.tail) / buffer.capacity;\n  }\n\n  public override handleError(error: Error): void {\n    errorLoggingService.logError(error, ErrorType.RUNTIME, undefined, {\n      service: 'RealTimeDataService',\n    });\n  }\n}\n\n// Export singleton instance using direct instantiation\nexport const realTimeDataService = new RealTimeDataServiceImpl();\n\n// Export default for easier imports\nexport default realTimeDataService;\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/services/RecoveryService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'metadata' is defined but never used.","line":147,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":147,"endColumn":13}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @context: service-system, error-handling\n * RecoveryService - Provides mechanisms for recovering from critical application failures\n *\n * This service handles:\n * - Saving application state snapshots\n * - Restoring previous application states\n * - Implementing different recovery strategies based on error type\n * - Providing graceful degradation options\n */\n\nimport { AbstractBaseService } from '../lib/services/BaseService';\nimport { ErrorType } from './ErrorLoggingService';\n\n// Types of recovery strategies that can be applied\nexport enum RecoveryStrategy {\n  RETRY = 'retry',\n  ROLLBACK = 'rollback',\n  RESET = 'reset',\n  IGNORE = 'ignore',\n}\n\n// Structure for application state snapshot\nexport interface StateSnapshot {\n  id: string;\n  state: Record<string, unknown>;\n  timestamp: number;\n  metadata?: Record<string, unknown>;\n}\n\n// Configuration for recovery actions\nexport interface RecoveryConfig {\n  maxSnapshots: number;\n  autoSaveInterval: number;\n  enableAutoRecover: boolean;\n  defaultStrategy: RecoveryStrategy;\n  strategyByErrorType: Partial<Record<ErrorType, RecoveryStrategy>>;\n}\n\nclass RecoveryServiceImpl extends AbstractBaseService<RecoveryServiceImpl> {\n  private snapshots: StateSnapshot[] = [];\n  private config: RecoveryConfig = {\n    maxSnapshots: 10,\n    autoSaveInterval: 60000, // 1 minute\n    enableAutoRecover: true,\n    defaultStrategy: RecoveryStrategy.RETRY,\n    strategyByErrorType: {\n      [ErrorType.NETWORK]: RecoveryStrategy.RETRY,\n      [ErrorType.RESOURCE]: RecoveryStrategy.ROLLBACK,\n      [ErrorType.UNKNOWN]: RecoveryStrategy.RESET,\n    },\n  };\n\n  public constructor() {\n    super('RecoveryService', '1.0.0');\n  }\n\n  protected async onInitialize(): Promise<void> {\n    // Initialize metrics\n    if (!this.metadata.metrics) {\n      this.metadata.metrics = {};\n    }\n\n    // Load any existing snapshots from localStorage\n    try {\n      const savedSnapshots = localStorage.getItem('recovery_snapshots');\n      if (savedSnapshots) {\n        this.snapshots = JSON.parse(savedSnapshots);\n      }\n    } catch (error) {\n      this.handleError(error as Error);\n    }\n  }\n\n  protected async onDispose(): Promise<void> {\n    // Save snapshots to localStorage\n    try {\n      localStorage.setItem('recovery_snapshots', JSON.stringify(this.snapshots));\n    } catch (error) {\n      this.handleError(error as Error);\n    }\n  }\n\n  public createSnapshot(\n    state: Record<string, unknown>,\n    metadata?: Record<string, unknown>\n  ): string {\n    const snapshot: StateSnapshot = {\n      id: crypto.randomUUID(),\n      state,\n      timestamp: Date.now(),\n      metadata,\n    };\n\n    this.snapshots.unshift(snapshot);\n\n    // Trim snapshots if we exceed max size\n    if (this.snapshots.length > this.config.maxSnapshots) {\n      this.snapshots = this.snapshots.slice(0, this.config.maxSnapshots);\n    }\n\n    // Update metrics\n    if (!this.metadata.metrics) {\n      this.metadata.metrics = {};\n    }\n    const metrics = this.metadata.metrics;\n    metrics.total_snapshots = this.snapshots.length;\n    metrics.latest_snapshot_timestamp = snapshot.timestamp;\n    this.metadata.metrics = metrics;\n\n    return snapshot.id;\n  }\n\n  public restoreSnapshot(snapshotId: string): Record<string, unknown> | null {\n    const snapshot = this.snapshots.find(s => s.id === snapshotId);\n    if (!snapshot) {\n      return null;\n    }\n\n    // Update metrics\n    if (!this.metadata.metrics) {\n      this.metadata.metrics = {};\n    }\n    const metrics = this.metadata.metrics;\n    metrics.total_restores = (metrics.total_restores ?? 0) + 1;\n    metrics.last_restore_timestamp = Date.now();\n    this.metadata.metrics = metrics;\n\n    return snapshot.state;\n  }\n\n  public getSnapshots(): StateSnapshot[] {\n    return [...this.snapshots];\n  }\n\n  public clearSnapshots(): void {\n    this.snapshots = [];\n\n    if (!this.metadata.metrics) {\n      this.metadata.metrics = {};\n    }\n    this.metadata.metrics = {};\n  }\n\n  public getRecoveryStrategy(\n    errorType: ErrorType = ErrorType.UNKNOWN,\n    metadata?: Record<string, unknown>\n  ): RecoveryStrategy {\n    return this.config.strategyByErrorType[errorType] || this.config.defaultStrategy;\n  }\n\n  public override handleError(error: Error): void {\n    // Update error metrics\n    if (!this.metadata.metrics) {\n      this.metadata.metrics = {};\n    }\n    const metrics = this.metadata.metrics;\n    metrics.total_errors = (metrics.total_errors ?? 0) + 1;\n    metrics.last_error_timestamp = Date.now();\n    this.metadata.metrics = metrics;\n\n    // Log error in development\n    if (process.env.NODE_ENV === 'development') {\n      console.error('[RecoveryService] Error:', error);\n    }\n  }\n}\n\n// Export singleton instance using direct instantiation\nexport const recoveryService = new RecoveryServiceImpl();\n\n// Export default for easier imports\nexport default recoveryService;\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/services/WebGLService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/services/WorkerService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/services/telemetry/SessionPerformanceTracker.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/services/telemetry/UserBehaviorCorrelationAnalysis.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/styles/mediaQueries.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/styles/themeUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/systems/exploration/DiscoveryClassification.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'signatureAnalysis' is defined but never used.","line":202,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":202,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'compositionAnalysis' is defined but never used.","line":203,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":203,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'discovery' is defined but never used.","line":209,"column":35,"nodeType":null,"messageId":"unusedVar","endLine":209,"endColumn":44},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'discovery' is defined but never used.","line":213,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":213,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'discovery' is defined but never used.","line":217,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":217,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'discovery' is defined but never used.","line":221,"column":35,"nodeType":null,"messageId":"unusedVar","endLine":221,"endColumn":44},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'discovery' is defined but never used.","line":225,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":225,"endColumn":42},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'discovery' is defined but never used.","line":229,"column":35,"nodeType":null,"messageId":"unusedVar","endLine":229,"endColumn":44},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'discovery' is defined but never used.","line":233,"column":35,"nodeType":null,"messageId":"unusedVar","endLine":233,"endColumn":44},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'discovery' is defined but never used.","line":237,"column":37,"nodeType":null,"messageId":"unusedVar","endLine":237,"endColumn":46},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'composition' is defined but never used.","line":241,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":241,"endColumn":38},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'pressure' is defined but never used.","line":245,"column":28,"nodeType":null,"messageId":"unusedVar","endLine":245,"endColumn":36},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'temperature' is defined but never used.","line":245,"column":46,"nodeType":null,"messageId":"unusedVar","endLine":245,"endColumn":57},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'location' is defined but never used.","line":249,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":249,"endColumn":42},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'metadata' is defined but never used.","line":253,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":253,"endColumn":42},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'metadata' is defined but never used.","line":261,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":261,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'metadata' is defined but never used.","line":269,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":269,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'metadata' is defined but never used.","line":277,"column":28,"nodeType":null,"messageId":"unusedVar","endLine":277,"endColumn":36},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'metadata' is defined but never used.","line":281,"column":28,"nodeType":null,"messageId":"unusedVar","endLine":281,"endColumn":36},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'result' is defined but never used.","line":289,"column":40,"nodeType":null,"messageId":"unusedVar","endLine":289,"endColumn":46},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'result' is defined but never used.","line":293,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":293,"endColumn":37},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'result' is defined but never used.","line":297,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":297,"endColumn":37},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'result' is defined but never used.","line":301,"column":42,"nodeType":null,"messageId":"unusedVar","endLine":301,"endColumn":48}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":23,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { EventBus } from '../../lib/events/EventBus';\nimport { Vector3D } from '../../types/common/VectorTypes';\nimport { EventType } from '../../types/events/EventTypes';\nimport {\n  Classification,\n  ClassificationResult,\n  Discovery,\n  DiscoveryType,\n} from '../../types/exploration/ExplorationTypes';\nimport { ResourceType } from './../../types/resources/ResourceTypes';\n\nexport interface ClassificationConfig {\n  minAnalysisThreshold: number;\n  maxAnalysisAttempts: number;\n  analysisTimeout: number;\n  confidenceThreshold: number;\n}\n\nexport class DiscoveryClassification {\n  private config: ClassificationConfig;\n  private eventBus: EventBus;\n  private analysisCache: Map<string, ClassificationResult>;\n  private activeAnalysis: Set<string>;\n\n  constructor(config: ClassificationConfig, eventBus: EventBus) {\n    this.config = config;\n    this.eventBus = eventBus;\n    this.analysisCache = new Map();\n    this.activeAnalysis = new Set();\n  }\n\n  public async classifyDiscovery(discovery: Discovery): Promise<Classification> {\n    if (this.activeAnalysis.has(discovery.id)) {\n      throw new Error(`Analysis already in progress for discovery ${discovery.id}`);\n    }\n\n    try {\n      this.activeAnalysis.add(discovery.id);\n      const result = await this.performClassification(discovery);\n      this.cacheResult(discovery.id, result);\n      return this.createClassification(discovery, result);\n    } finally {\n      this.activeAnalysis.delete(discovery.id);\n    }\n  }\n\n  private async performClassification(discovery: Discovery): Promise<ClassificationResult> {\n    const cachedResult = this.analysisCache.get(discovery.id);\n    if (cachedResult && this.isResultValid(cachedResult)) {\n      return cachedResult;\n    }\n\n    const analysisStart = performance.now();\n    const result = await this.analyzeDiscovery(discovery);\n\n    if (result?.confidence < this.config.confidenceThreshold) {\n      await this.enhanceAnalysis(discovery, result);\n    }\n\n    this.publishAnalysisMetrics(discovery, result, performance.now() - analysisStart);\n    return result;\n  }\n\n  private async analyzeDiscovery(discovery: Discovery): Promise<ClassificationResult> {\n    switch (discovery.type) {\n      case DiscoveryType.RESOURCE_DEPOSIT:\n        return this.analyzeResourceDeposit(discovery);\n      case DiscoveryType.ALIEN_ARTIFACT:\n        return this.analyzeAlienArtifact(discovery);\n      case DiscoveryType.ANOMALY:\n        return this.analyzeAnomaly(discovery);\n      case DiscoveryType.DERELICT:\n        return this.analyzeDerelict(discovery);\n      case DiscoveryType.SPATIAL_PHENOMENON:\n        return this.analyzeSpatialPhenomenon(discovery);\n      default:\n        throw new Error(`Unknown discovery type: ${discovery.type}`);\n    }\n  }\n\n  private async analyzeResourceDeposit(discovery: Discovery): Promise<ClassificationResult> {\n    const analysis = {\n      type: DiscoveryType.RESOURCE_DEPOSIT,\n      confidence: 0,\n      details: {\n        resourceType: this.determineResourceType(discovery),\n        estimatedQuantity: this.estimateResourceQuantity(discovery),\n        extractionDifficulty: this.calculateExtractionDifficulty(discovery),\n        qualityIndicators: this.analyzeResourceQuality(discovery),\n      },\n      timestamp: Date.now(),\n      analysisTime: 0,\n      enhancementApplied: false,\n    };\n\n    analysis.confidence = this.calculateConfidence(analysis);\n    return analysis;\n  }\n\n  private async analyzeAlienArtifact(discovery: Discovery): Promise<ClassificationResult> {\n    return {\n      type: DiscoveryType.ALIEN_ARTIFACT,\n      confidence: 0.85,\n      details: {\n        artifactOrigin: this.determineArtifactOrigin(discovery),\n        artifactAge: this.estimateArtifactAge(discovery),\n      },\n      timestamp: Date.now(),\n      analysisTime: 0,\n      enhancementApplied: false,\n    };\n  }\n\n  private async analyzeAnomaly(discovery: Discovery): Promise<ClassificationResult> {\n    return {\n      type: DiscoveryType.ANOMALY,\n      confidence: 0.75,\n      details: {\n        anomalyType: this.determineAnomalyType(discovery),\n        anomalyIntensity: this.measureAnomalyIntensity(discovery),\n      },\n      timestamp: Date.now(),\n      analysisTime: 0,\n      enhancementApplied: false,\n    };\n  }\n\n  private async analyzeDerelict(discovery: Discovery): Promise<ClassificationResult> {\n    return {\n      type: DiscoveryType.DERELICT,\n      confidence: 0.9,\n      details: {\n        derelictType: this.determineDerelictType(discovery),\n        derelictCondition: this.assessDerelictCondition(discovery),\n      },\n      timestamp: Date.now(),\n      analysisTime: 0,\n      enhancementApplied: false,\n    };\n  }\n\n  private async analyzeSpatialPhenomenon(discovery: Discovery): Promise<ClassificationResult> {\n    return {\n      type: DiscoveryType.SPATIAL_PHENOMENON,\n      confidence: 0.8,\n      details: {\n        phenomenonType: this.determinePhenomenonType(discovery),\n        phenomenonStability: this.assessPhenomenonStability(discovery),\n      },\n      timestamp: Date.now(),\n      analysisTime: 0,\n      enhancementApplied: false,\n    };\n  }\n\n  private determineResourceType(discovery: Discovery): ResourceType {\n    const signatureAnalysis = this.analyzeResourceSignature(discovery);\n    const compositionAnalysis = this.analyzeComposition(discovery);\n    return this.reconcileResourceAnalysis(signatureAnalysis, compositionAnalysis);\n  }\n\n  private estimateResourceQuantity(discovery: Discovery): number {\n    const densityMapping =\n      discovery.metadata && discovery.metadata.scanData\n        ? discovery.metadata.scanData.densityMapping || []\n        : [];\n    return densityMapping.reduce((sum, density) => sum + density, 0) * 100;\n  }\n\n  private calculateExtractionDifficulty(discovery: Discovery): number {\n    const structuralIntegrity =\n      discovery.metadata && discovery.metadata.scanData\n        ? discovery.metadata.scanData.structuralIntegrity || 0.5\n        : 0.5;\n    return 1 - structuralIntegrity;\n  }\n\n  private analyzeResourceQuality(discovery: Discovery): QualityIndicators {\n    const scanData =\n      discovery.metadata && discovery.metadata.scanData\n        ? discovery.metadata.scanData\n        : { elementalComposition: new Map(), structuralIntegrity: 0.5 };\n    const initialReadings =\n      discovery.metadata && discovery.metadata.initialReadings\n        ? discovery.metadata.initialReadings\n        : { pressure: 0, temperature: 0 };\n\n    const elementalComposition = scanData.elementalComposition || new Map();\n    const structuralIntegrity = scanData.structuralIntegrity || 0.5;\n    const pressure = initialReadings.pressure || 0;\n    const temperature = initialReadings.temperature || 0;\n\n    return {\n      purity: this.calculatePurity(elementalComposition),\n      density: this.calculateDensity(pressure, temperature),\n      stability: structuralIntegrity,\n      accessibility: this.calculateAccessibility(discovery.location),\n    };\n  }\n\n  private reconcileResourceAnalysis(\n    signatureAnalysis: ResourceSignature,\n    compositionAnalysis: CompositionAnalysis\n  ): ResourceType {\n    // Implement reconciliation logic\n    return ResourceType.IRON; // Placeholder\n  }\n\n  private determineArtifactOrigin(discovery: Discovery): string {\n    return 'Unknown Origin'; // Placeholder\n  }\n\n  private estimateArtifactAge(discovery: Discovery): number {\n    return 1000; // Placeholder\n  }\n\n  private determineAnomalyType(discovery: Discovery): string {\n    return 'Unknown Anomaly'; // Placeholder\n  }\n\n  private measureAnomalyIntensity(discovery: Discovery): number {\n    return 0.5; // Placeholder\n  }\n\n  private determineDerelictType(discovery: Discovery): string {\n    return 'Unknown Vessel'; // Placeholder\n  }\n\n  private assessDerelictCondition(discovery: Discovery): number {\n    return 0.7; // Placeholder\n  }\n\n  private determinePhenomenonType(discovery: Discovery): string {\n    return 'Unknown Phenomenon'; // Placeholder\n  }\n\n  private assessPhenomenonStability(discovery: Discovery): number {\n    return 0.6; // Placeholder\n  }\n\n  private calculatePurity(composition: Map<string, number>): number {\n    return 0.8; // Placeholder\n  }\n\n  private calculateDensity(pressure: number, temperature: number): number {\n    return 0.9; // Placeholder\n  }\n\n  private calculateAccessibility(location: Vector3D): number {\n    return 0.7; // Placeholder\n  }\n\n  private analyzeSpectralProfile(metadata: unknown): SpectralProfile {\n    return {\n      wavelengths: [],\n      intensities: [],\n      absorption: [],\n    };\n  }\n\n  private analyzeDensityProfile(metadata: unknown): DensityProfile {\n    return {\n      average: 0,\n      variation: 0,\n      distribution: [],\n    };\n  }\n\n  private analyzeThermalProfile(metadata: unknown): ThermalProfile {\n    return {\n      temperature: 0,\n      conductivity: 0,\n      signature: [],\n    };\n  }\n\n  private identifyElements(metadata: unknown): ElementProfile[] {\n    return [];\n  }\n\n  private analyzeStructure(metadata: unknown): StructureAnalysis {\n    return {\n      crystallinity: 0,\n      porosity: 0,\n      stability: 0,\n    };\n  }\n\n  private validateAnalysisCompleteness(result: ClassificationResult): number {\n    return 0.9; // Placeholder\n  }\n\n  private validateDataQuality(result: ClassificationResult): number {\n    return 0.85; // Placeholder\n  }\n\n  private validateConsistency(result: ClassificationResult): number {\n    return 0.95; // Placeholder\n  }\n\n  private determineEnhancementStrategies(result: ClassificationResult): EnhancementStrategy[] {\n    return []; // Placeholder\n  }\n\n  private updateAnalysisResult(discoveryId: string, enhancedResult: ClassificationResult): void {\n    this.analysisCache.set(discoveryId, enhancedResult);\n  }\n\n  private createClassification(discovery: Discovery, result: ClassificationResult): Classification {\n    return {\n      id: discovery.id,\n      type: result?.type,\n      confidence: result?.confidence,\n      details: result?.details,\n      timestamp: Date.now(),\n      metadata: {\n        analysisVersion: '1.0',\n        analysisTime: result?.analysisTime,\n        enhancementApplied: result?.enhancementApplied,\n      },\n    };\n  }\n\n  private calculateConfidence(result: ClassificationResult): number {\n    const factors = [\n      this.validateAnalysisCompleteness(result),\n      this.validateDataQuality(result),\n      this.validateConsistency(result),\n    ];\n\n    return factors.reduce((acc, factor) => acc * factor, 1);\n  }\n\n  private isResultValid(result: ClassificationResult): boolean {\n    const age = Date.now() - result?.timestamp;\n    return (\n      result?.confidence >= this.config.confidenceThreshold && age < this.config.analysisTimeout\n    );\n  }\n\n  private cacheResult(discoveryId: string, result: ClassificationResult): void {\n    this.analysisCache.set(discoveryId, {\n      ...result,\n      timestamp: Date.now(),\n    });\n  }\n\n  private publishAnalysisMetrics(\n    discovery: Discovery,\n    result: ClassificationResult,\n    duration: number\n  ): void {\n    this.eventBus.emit({\n      type: EventType.EXPLORATION_SECTOR_SCANNED,\n      timestamp: Date.now(),\n      moduleId: 'discovery-classification',\n      moduleType: 'exploration',\n      data: {\n        discoveryId: discovery.id,\n        discoveryType: discovery.type,\n        confidence: result.confidence,\n        duration,\n        enhancementApplied: result.enhancementApplied,\n      },\n    });\n  }\n\n  private async enhanceAnalysis(\n    discovery: Discovery,\n    result: ClassificationResult\n  ): Promise<ClassificationResult> {\n    const enhancedResult = { ...result };\n\n    let enhancementApplied = false;\n\n    switch (discovery.type) {\n      case DiscoveryType.RESOURCE_DEPOSIT:\n        enhancedResult.confidence += 0.1;\n        enhancementApplied = true;\n        break;\n      case DiscoveryType.ALIEN_ARTIFACT:\n        enhancedResult.confidence += 0.15;\n        enhancementApplied = true;\n        break;\n      case DiscoveryType.ANOMALY:\n        enhancedResult.confidence += 0.12;\n        enhancementApplied = true;\n        break;\n      case DiscoveryType.DERELICT:\n        enhancedResult.confidence += 0.08;\n        enhancementApplied = true;\n        break;\n      case DiscoveryType.SPATIAL_PHENOMENON:\n        enhancedResult.confidence += 0.1;\n        enhancementApplied = true;\n        break;\n    }\n\n    enhancedResult.enhancementApplied = enhancementApplied;\n\n    enhancedResult.confidence = Math.min(1.0, enhancedResult.confidence);\n\n    enhancedResult.analysisTime = (enhancedResult.analysisTime || 0) + 500;\n\n    return enhancedResult;\n  }\n\n  private analyzeResourceSignature(discovery: Discovery): ResourceSignature {\n    const spectralProfile = this.analyzeSpectralProfile(discovery.metadata?.scanData || {});\n    const densityProfile = this.analyzeDensityProfile(discovery.metadata?.scanData || {});\n    const thermalProfile = this.analyzeThermalProfile(discovery.metadata?.initialReadings || {});\n\n    return {\n      spectralProfile,\n      densityProfile,\n      thermalProfile,\n    };\n  }\n\n  private analyzeComposition(discovery: Discovery): CompositionAnalysis {\n    const elements = this.identifyElements(discovery.metadata?.scanData || {});\n    const structure = this.analyzeStructure(discovery.metadata?.scanData || {});\n\n    const purity =\n      discovery.metadata && discovery.metadata.scanData\n        ? this.calculatePurity(discovery.metadata.scanData.elementalComposition || new Map())\n        : 0.5;\n\n    return {\n      elements,\n      structure,\n      purity,\n    };\n  }\n}\n\ninterface EnhancementStrategy {\n  execute(discovery: Discovery, initialResult: ClassificationResult): Promise<ClassificationResult>;\n}\n\ninterface ResourceSignature {\n  spectralProfile: SpectralProfile;\n  densityProfile: DensityProfile;\n  thermalProfile: ThermalProfile;\n}\n\ninterface CompositionAnalysis {\n  elements: ElementProfile[];\n  structure: StructureAnalysis;\n  purity: number;\n}\n\ninterface SpectralProfile {\n  wavelengths: number[];\n  intensities: number[];\n  absorption: number[];\n}\n\ninterface DensityProfile {\n  average: number;\n  variation: number;\n  distribution: number[];\n}\n\ninterface ThermalProfile {\n  temperature: number;\n  conductivity: number;\n  signature: number[];\n}\n\ninterface ElementProfile {\n  element: string;\n  concentration: number;\n  distribution: number[];\n}\n\ninterface StructureAnalysis {\n  crystallinity: number;\n  porosity: number;\n  stability: number;\n}\n\ninterface QualityIndicators {\n  purity: number;\n  density: number;\n  stability: number;\n  accessibility: number;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/tests/accessibility/a11y.test.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'vi' is defined but never used. Allowed unused vars must match /^ignored|^temp/u.","line":11,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":34}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @context: ui-system, component-library, testing, ui-accessibility\n * \n * Accessibility (a11y) tests for UI components\n * \n * These tests check for appropriate ARIA attributes, keyboard navigation,\n * and focus management in interactive components.\n */\n\nimport React from 'react';\nimport { describe, it, expect, vi } from 'vitest';\nimport { renderWithProviders, screen } from '../utils/test-utils';\nimport { Button } from '../../ui/components/Button';\nimport { Card } from '../../ui/components/Card';\nimport { ComponentVariant } from '../../types/ui/ComponentTypes';\n\ndescribe('Accessibility Requirements', () => {\n  // Keyboard navigation tests\n  describe('Keyboard Navigation', () => {\n    it('Button is focusable with keyboard', async () => {\n      const { user } = renderWithProviders(\n        <div>\n          <Button>First Button</Button>\n          <Button>Test Button</Button>\n          <Button>Last Button</Button>\n        </div>\n      );\n      \n      // Tab to focus first button\n      await user.tab();\n      expect(document.activeElement).toHaveTextContent('First Button');\n      \n      // Tab to focus second button\n      await user.tab();\n      expect(document.activeElement).toHaveTextContent('Test Button');\n      \n      // Tab to focus third button\n      await user.tab();\n      expect(document.activeElement).toHaveTextContent('Last Button');\n    });\n    \n    it('Interactive Card is focusable with keyboard', async () => {\n      const { user } = renderWithProviders(\n        <div>\n          <Card interactive title=\"Interactive Card\">\n            <div>Card content</div>\n          </Card>\n        </div>\n      );\n      \n      // Tab to focus card\n      await user.tab();\n      \n      const card = screen.getByText('Interactive Card').closest('.gs-card');\n      expect(document.activeElement).toBe(card);\n    });\n  });\n  \n  // ARIA attributes tests\n  describe('ARIA Attributes', () => {\n    it('Button has appropriate ARIA attributes', () => {\n      renderWithProviders(\n        <Button\n          aria-label=\"Close dialog\"\n          aria-describedby=\"description\"\n          disabled\n        >\n          X\n        </Button>\n      );\n      \n      const button = screen.getByRole('button');\n      expect(button).toHaveAttribute('aria-label', 'Close dialog');\n      expect(button).toHaveAttribute('aria-describedby', 'description');\n      expect(button).toBeDisabled();\n    });\n    \n    it('Loading Button indicates busy state', () => {\n      renderWithProviders(\n        <Button loading>Loading</Button>\n      );\n      \n      const button = screen.getByRole('button');\n      expect(button).toBeDisabled();\n      \n      const loadingIndicator = button.querySelector('.gs-button__loading-indicator');\n      expect(loadingIndicator).toHaveAttribute('aria-hidden', 'true');\n    });\n    \n    it('Card with interactive mode has appropriate ARIA attributes', () => {\n      renderWithProviders(\n        <Card \n          interactive \n          aria-label=\"Interactive card\"\n          aria-describedby=\"card-description\"\n        >\n          <div>Card content</div>\n        </Card>\n      );\n      \n      const card = screen.getByText('Card content').closest('.gs-card');\n      expect(card).toHaveAttribute('role', 'button');\n      expect(card).toHaveAttribute('tabIndex', '0');\n      expect(card).toHaveAttribute('aria-label', 'Interactive card');\n      expect(card).toHaveAttribute('aria-describedby', 'card-description');\n    });\n  });\n  \n  // Color contrast tests \n  // (In a real implementation, this would use an automated tool like axe-core,\n  // but for this example, we're doing simple checks)\n  describe('Color and Contrast', () => {\n    it('Danger button has appropriate aria attributes for conveying purpose', () => {\n      renderWithProviders(\n        <Button \n          variant={ComponentVariant.DANGER}\n          aria-label=\"Delete item\"\n        >\n          Delete\n        </Button>\n      );\n      \n      const button = screen.getByRole('button');\n      expect(button).toHaveClass('gs-button--danger');\n      expect(button).toHaveAttribute('aria-label', 'Delete item');\n    });\n  });\n  \n  // Focus management\n  describe('Focus Management', () => {\n    it('Button focus state is visible', async () => {\n      const { user } = renderWithProviders(\n        <Button>Focusable Button</Button>\n      );\n      \n      const button = screen.getByRole('button');\n      \n      // Tab to focus button\n      await user.tab();\n      expect(document.activeElement).toBe(button);\n      \n      // In a real test, we would check for focus styling\n      // This is a simplified example that just checks focus is applied\n    });\n  });\n}); ","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/tests/components/ui/Button.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/tests/components/ui/Card.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/tests/components/ui/ErrorBoundary.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/tests/components/ui/responsive.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/tests/integration/ui-components.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/tests/performance/LongSessionMemoryTestSuite.ts","messages":[{"ruleId":"prefer-const","severity":1,"message":"'testEndTime' is never reassigned. Use 'const' instead.","line":241,"column":5,"nodeType":"Identifier","messageId":"useConst","endLine":241,"endColumn":16},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":399,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":399,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13229,13232],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13229,13232],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sum' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":469,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":469,"endColumn":16},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":527,"column":9,"nodeType":"MemberExpression","messageId":"limited","endLine":527,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[17087,17127],"text":""},"desc":"Remove the console.log()."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":641,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":641,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20500,20503],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20500,20503],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":644,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":644,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20588,20591],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20588,20591],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":645,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":645,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20653,20656],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20653,20656],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":646,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":646,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20720,20723],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20720,20723],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":655,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":655,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20987,20990],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20987,20990],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":685,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":685,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21842,21845],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21842,21845],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":738,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":738,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23287,23290],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23287,23290],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * LongSessionMemoryTestSuite.ts\n *\n * Test suite for long-term memory performance testing\n */\n\nimport {\n  MemorySnapshot,\n  MemoryTrendAnalysis,\n} from '../../utils/performance/longsession/LongSessionMemoryTracker';\n\nexport interface MemoryTestResult {\n  testName: string;\n  startTime: number;\n  endTime: number;\n  memoryBefore: number;\n  memoryAfter: number;\n  heapUsed: number;\n  duration: number;\n  passed: boolean;\n  details?: string;\n}\n\nexport interface MemorySuiteConfig {\n  iterations: number;\n  dataSize: 'small' | 'medium' | 'large';\n  allowGC: boolean;\n  trackDetailedStats: boolean;\n  delayBetweenTests: number;\n  snapshotIntervalMs?: number;\n  leakThresholdMBPerMinute?: number;\n  durationMs?: number;\n}\n\nexport interface LongSessionMemoryResult {\n  testName: string;\n  startTime: number;\n  endTime: number;\n  duration: number;\n  durationMs: number; // Same as duration but explicitly in milliseconds\n  initialMemoryMB: number;\n  finalMemoryMB: number;\n  memoryGrowthRateMBPerHour: number;\n  leakDetected: boolean;\n  leakSeverity?: number;\n  snapshots: MemorySnapshot[];\n  analysis: MemoryTrendAnalysis;\n  memorySnapshots: {\n    timestamp: number;\n    memoryUsage: number;\n  }[];\n  analysisResults: {\n    averageUsage: number;\n    peakUsage: number;\n    growthRate: number;\n    isLeakDetected: boolean;\n    leakSeverity?: number;\n  };\n  passed: boolean;\n}\n\n/**\n * Long session memory test suite\n */\nexport class LongSessionMemoryTestSuite {\n  private config: MemorySuiteConfig;\n  private results: MemoryTestResult[] = [];\n  private isRunning = false;\n  private onProgressCallback?: (progress: number) => void;\n  private onTestCompleteCallback?: (result: MemoryTestResult) => void;\n  private onSuiteCompleteCallback?: (results: MemoryTestResult[]) => void;\n\n  constructor(config: Partial<MemorySuiteConfig> = {}) {\n    this.config = {\n      iterations: config.iterations || 10,\n      dataSize: config.dataSize || 'medium',\n      allowGC: config.allowGC !== undefined ? config.allowGC : true,\n      trackDetailedStats: config.trackDetailedStats || false,\n      delayBetweenTests: config.delayBetweenTests || 1000,\n      snapshotIntervalMs: config.snapshotIntervalMs || 5000,\n      leakThresholdMBPerMinute: config.leakThresholdMBPerMinute || 0.5,\n      durationMs: config.durationMs || 60000,\n    };\n  }\n\n  public async runSuite(): Promise<MemoryTestResult[]> {\n    if (this.isRunning) {\n      throw new Error('Test suite is already running');\n    }\n\n    this.isRunning = true;\n    this.results = [];\n\n    // Run the memory leak tests\n    await this.runMemoryLeakTest();\n    await this.runLargeObjectsTest();\n    await this.runEventListenerTest();\n    await this.runDOMReferenceTest();\n    await this.runCircularReferenceTest();\n\n    this.isRunning = false;\n\n    if (this.onSuiteCompleteCallback) {\n      this.onSuiteCompleteCallback(this.results);\n    }\n\n    return this.results;\n  }\n\n  public onProgress(callback: (progress: number) => void): void {\n    this.onProgressCallback = callback;\n  }\n\n  public onTestComplete(callback: (result: MemoryTestResult) => void): void {\n    this.onTestCompleteCallback = callback;\n  }\n\n  public onSuiteComplete(callback: (results: MemoryTestResult[]) => void): void {\n    this.onSuiteCompleteCallback = callback;\n  }\n\n  public cancelTests(): void {\n    this.isRunning = false;\n  }\n\n  public getResults(): MemoryTestResult[] {\n    return [...this.results];\n  }\n\n  public async runTest(): Promise<LongSessionMemoryResult> {\n    return this.createMemoryTest('Standard Memory Test', this.config.durationMs || 60000);\n  }\n\n  public async runMemoryLeakDetectionTest(\n    leakRate: number,\n    duration: number\n  ): Promise<LongSessionMemoryResult> {\n    return this.createMemoryTest('Memory Leak Detection Test', duration, leakRate);\n  }\n\n  public async runTestBattery(): Promise<Record<string, LongSessionMemoryResult>> {\n    const results: Record<string, LongSessionMemoryResult> = {};\n\n    // Run a standard memory test\n    results.standard = await this.runTest();\n\n    // Run tests with different loads\n    results.lightweight = await this.createMemoryTest(\n      'Lightweight Test',\n      this.config.durationMs || 60000,\n      0\n    );\n    results.moderate = await this.createMemoryTest(\n      'Moderate Load Test',\n      this.config.durationMs || 60000,\n      0.5\n    );\n    results.intensive = await this.createMemoryTest(\n      'Intensive Load Test',\n      this.config.durationMs || 60000,\n      2\n    );\n\n    return results;\n  }\n\n  private async createMemoryTest(\n    testName: string,\n    duration: number,\n    leakRate = 0\n  ): Promise<LongSessionMemoryResult> {\n    const startTime = Date.now();\n    const snapshots: { timestamp: number; memoryUsage: number }[] = [];\n    const snapshotInterval = this.config.snapshotIntervalMs || 5000;\n    let testEndTime: number;\n\n    // Initial memory snapshot\n    snapshots.push({\n      timestamp: startTime,\n      memoryUsage: this.getMemoryUsage(),\n    });\n\n    // Create artificial memory usage based on leakRate if specified\n    if (leakRate > 0) {\n      const leakObjects: unknown[] = [];\n\n      // Run until test duration is complete\n      const intervalId = setInterval(() => {\n        if (!this.isRunning || Date.now() - startTime >= duration) {\n          clearInterval(intervalId);\n          return;\n        }\n\n        // Create objects to simulate memory leak based on leakRate\n        const objsToCreate = Math.floor(leakRate * 100);\n        for (let i = 0; i < objsToCreate; i++) {\n          leakObjects.push(new Array(10000).fill(Math.random()));\n        }\n\n        // Take memory snapshot\n        snapshots.push({\n          timestamp: Date.now(),\n          memoryUsage: this.getMemoryUsage(),\n        });\n      }, snapshotInterval);\n\n      // Wait for test to complete\n      await new Promise<void>(resolve => {\n        const checkComplete = setInterval(() => {\n          if (!this.isRunning || Date.now() - startTime >= duration) {\n            clearInterval(checkComplete);\n            resolve();\n          }\n        }, 100);\n      });\n    } else {\n      // For tests without artificial leak, just take snapshots at intervals\n      const intervalId = setInterval(() => {\n        if (!this.isRunning || Date.now() - startTime >= duration) {\n          clearInterval(intervalId);\n          return;\n        }\n\n        snapshots.push({\n          timestamp: Date.now(),\n          memoryUsage: this.getMemoryUsage(),\n        });\n      }, snapshotInterval);\n\n      // Wait for test to complete\n      await new Promise<void>(resolve => {\n        const checkComplete = setInterval(() => {\n          if (!this.isRunning || Date.now() - startTime >= duration) {\n            clearInterval(checkComplete);\n            resolve();\n          }\n        }, 100);\n      });\n    }\n\n    testEndTime = Date.now();\n\n    // Final memory snapshot\n    snapshots.push({\n      timestamp: testEndTime,\n      memoryUsage: this.getMemoryUsage(),\n    });\n\n    // Analyze results\n    const averageUsage =\n      snapshots.reduce((sum, snapshot) => sum + snapshot.memoryUsage, 0) / snapshots.length;\n    const peakUsage = Math.max(...snapshots.map(s => s.memoryUsage));\n\n    // Calculate growth rate in MB per minute\n    const firstSnapshot = snapshots[0];\n    const lastSnapshot = snapshots[snapshots.length - 1];\n    const memoryDiff = lastSnapshot.memoryUsage - firstSnapshot.memoryUsage;\n    const timeDiffMinutes = (lastSnapshot.timestamp - firstSnapshot.timestamp) / (1000 * 60);\n    const growthRate = timeDiffMinutes > 0 ? memoryDiff / timeDiffMinutes : 0;\n\n    // Determine if a leak is detected\n    const isLeakDetected = growthRate > (this.config.leakThresholdMBPerMinute || 0.5);\n\n    // Calculate leak severity (1-5 scale)\n    let leakSeverity: number | undefined;\n    if (isLeakDetected) {\n      const baseThreshold = this.config.leakThresholdMBPerMinute || 0.5;\n      leakSeverity = Math.min(5, Math.ceil(growthRate / baseThreshold));\n    }\n\n    const initialMemoryMB = firstSnapshot.memoryUsage;\n    const finalMemoryMB = lastSnapshot.memoryUsage;\n    const memoryGrowthRateMBPerHour = growthRate * 60; // Convert from per minute to per hour\n\n    // Convert to MemorySnapshot format required by the visualizer\n    const memorySnapshots: MemorySnapshot[] = snapshots.map(snapshot => ({\n      timestamp: snapshot.timestamp,\n      usedHeapSizeMB: snapshot.memoryUsage,\n      totalHeapSizeMB: snapshot.memoryUsage * 1.5, // Estimate total heap size\n      heapLimitMB: snapshot.memoryUsage * 4, // Estimate heap limit\n    }));\n\n    // Create MemoryTrendAnalysis object required by the visualizer\n    const memoryAnalysis: MemoryTrendAnalysis = {\n      overallTrend: growthRate > 0 ? 1 : growthRate < 0 ? -1 : 0,\n      growthRatePerMinute: growthRate,\n      growthRatePerHour: memoryGrowthRateMBPerHour,\n      estimatedTimeToLimit: isLeakDetected\n        ? ((memorySnapshots[0].heapLimitMB - memorySnapshots[0].usedHeapSizeMB) / growthRate) *\n          60 *\n          1000 // Convert to ms\n        : Number.POSITIVE_INFINITY,\n      isAccelerating: false, // We don't calculate acceleration in this simple test\n      confidence: 0.8, // Reasonable confidence\n      suspectedLeak: isLeakDetected,\n      leakCause: isLeakDetected ? 'Simulated memory leak' : undefined,\n      leakSeverity: leakSeverity,\n    };\n\n    return {\n      testName,\n      startTime,\n      endTime: testEndTime,\n      duration: testEndTime - startTime,\n      durationMs: duration,\n      initialMemoryMB,\n      finalMemoryMB,\n      memoryGrowthRateMBPerHour,\n      leakDetected: isLeakDetected,\n      leakSeverity,\n      snapshots: memorySnapshots, // Use the converted format\n      analysis: memoryAnalysis, // Use the converted format\n      memorySnapshots: snapshots,\n      analysisResults: {\n        averageUsage,\n        peakUsage,\n        growthRate,\n        isLeakDetected,\n        leakSeverity,\n      },\n      passed: !isLeakDetected,\n    };\n  }\n\n  public static generateReport(\n    results: LongSessionMemoryResult | Record<string, LongSessionMemoryResult>\n  ): string {\n    let report = '# Memory Test Report\\n\\n';\n    report += `Generated: ${new Date().toLocaleString()}\\n\\n`;\n\n    if ('testName' in results) {\n      // Single test result\n      const result = results as LongSessionMemoryResult;\n      report += this.formatSingleTestReport(result);\n    } else {\n      // Multiple test results\n      const testResults = results as Record<string, LongSessionMemoryResult>;\n      report += '## Test Battery Results\\n\\n';\n\n      for (const [testKey, result] of Object.entries(testResults)) {\n        report += `### ${testKey.charAt(0).toUpperCase() + testKey.slice(1)} Test\\n\\n`;\n        report += this.formatSingleTestReport(result);\n        report += '---\\n\\n';\n      }\n\n      // Add comparison table\n      report += '## Test Comparison\\n\\n';\n      report += '| Test | Duration | Average Memory | Peak Memory | Growth Rate | Status |\\n';\n      report += '|------|----------|----------------|-------------|-------------|--------|\\n';\n\n      for (const [testKey, result] of Object.entries(testResults)) {\n        const { analysisResults, duration, passed } = result;\n        report += `| ${testKey} | ${(duration / 1000).toFixed(1)}s | ${analysisResults.averageUsage.toFixed(1)} MB | ${analysisResults.peakUsage.toFixed(1)} MB | ${analysisResults.growthRate.toFixed(2)} MB/min | ${passed ? 'âœ… Pass' : 'âŒ Fail'} |\\n`;\n      }\n    }\n\n    return report;\n  }\n\n  private static formatSingleTestReport(result: LongSessionMemoryResult): string {\n    const { testName, startTime, endTime, duration, memorySnapshots, analysisResults, passed } =\n      result;\n    let report = `## ${testName}\\n\\n`;\n\n    report += `- **Start Time**: ${new Date(startTime).toLocaleString()}\\n`;\n    report += `- **End Time**: ${new Date(endTime).toLocaleString()}\\n`;\n    report += `- **Duration**: ${(duration / 1000).toFixed(1)} seconds\\n`;\n    report += `- **Average Memory Usage**: ${analysisResults.averageUsage.toFixed(1)} MB\\n`;\n    report += `- **Peak Memory Usage**: ${analysisResults.peakUsage.toFixed(1)} MB\\n`;\n    report += `- **Memory Growth Rate**: ${analysisResults.growthRate.toFixed(2)} MB/min\\n`;\n    report += `- **Memory Leak Detected**: ${analysisResults.isLeakDetected ? 'Yes' : 'No'}\\n`;\n\n    if (analysisResults.leakSeverity !== undefined) {\n      report += `- **Leak Severity**: ${analysisResults.leakSeverity}/5\\n`;\n    }\n\n    report += `- **Test Status**: ${passed ? 'âœ… Passed' : 'âŒ Failed'}\\n\\n`;\n\n    // Add snapshot data\n    report += '### Memory Snapshots\\n\\n';\n    report += '| Time | Memory Usage (MB) | Elapsed (s) |\\n';\n    report += '|------|-------------------|-------------|\\n';\n\n    for (const snapshot of memorySnapshots) {\n      const elapsedSeconds = ((snapshot.timestamp - startTime) / 1000).toFixed(1);\n      report += `| ${new Date(snapshot.timestamp).toLocaleTimeString()} | ${snapshot.memoryUsage.toFixed(1)} | ${elapsedSeconds} |\\n`;\n    }\n\n    report += '\\n';\n    return report;\n  }\n\n  private async runMemoryLeakTest(): Promise<void> {\n    const startTime = performance.now();\n    const memoryBefore = this.getMemoryUsage();\n\n    // Create large arrays and objects multiple times\n    const dataSize = this.getDataSize();\n    const containers: any[] = [];\n\n    for (let i = 0; i < this.config.iterations; i++) {\n      // Creating potentially leaky objects\n      const obj = {\n        data: new Array(dataSize).fill(0).map((_, idx) => ({ id: idx, value: `value-${idx}` })),\n        metadata: { created: Date.now(), iterations: i },\n      };\n\n      containers.push(obj);\n\n      // Report progress\n      if (this.onProgressCallback) {\n        this.onProgressCallback((i / this.config.iterations) * 20); // First test = 0-20%\n      }\n\n      // Small delay to allow UI updates\n      await new Promise(resolve => setTimeout(resolve, 10));\n\n      if (!this.isRunning) break;\n    }\n\n    // Allow objects to be garbage collected if config allows\n    if (this.config.allowGC) {\n      containers.length = 0;\n      if (window.gc) window.gc();\n    }\n\n    const memoryAfter = this.getMemoryUsage();\n    const endTime = performance.now();\n\n    const result: MemoryTestResult = {\n      testName: 'Memory Leak Test',\n      startTime,\n      endTime,\n      memoryBefore,\n      memoryAfter,\n      heapUsed: memoryAfter - memoryBefore,\n      duration: endTime - startTime,\n      passed: this.config.allowGC ? memoryAfter - memoryBefore < dataSize * 10 : true,\n    };\n\n    this.results.push(result);\n\n    if (this.onTestCompleteCallback) {\n      this.onTestCompleteCallback(result);\n    }\n\n    // Delay before next test\n    await new Promise(resolve => setTimeout(resolve, this.config.delayBetweenTests));\n  }\n\n  private async runLargeObjectsTest(): Promise<void> {\n    const startTime = performance.now();\n    const memoryBefore = this.getMemoryUsage();\n\n    // Create and destroy large objects\n    const dataSize = this.getDataSize();\n\n    for (let i = 0; i < this.config.iterations; i++) {\n      // Large object creation\n      const largeObject = new Array(dataSize).fill(0).map(() => {\n        return {\n          id: Math.random().toString(36).substring(2),\n          timestamp: Date.now(),\n          data: new Array(100).fill(Math.random()),\n        };\n      });\n\n      // Do something with the object to prevent optimization\n      const sum = largeObject.reduce((acc, item) => acc + item.data.reduce((a, b) => a + b, 0), 0);\n\n      // Report progress\n      if (this.onProgressCallback) {\n        this.onProgressCallback(20 + (i / this.config.iterations) * 20); // Second test = 20-40%\n      }\n\n      // Small delay to allow UI updates\n      await new Promise(resolve => setTimeout(resolve, 10));\n\n      if (!this.isRunning) break;\n    }\n\n    // Force garbage collection if available and allowed\n    if (this.config.allowGC && window.gc) {\n      window.gc();\n    }\n\n    const memoryAfter = this.getMemoryUsage();\n    const endTime = performance.now();\n\n    const result: MemoryTestResult = {\n      testName: 'Large Objects Test',\n      startTime,\n      endTime,\n      memoryBefore,\n      memoryAfter,\n      heapUsed: memoryAfter - memoryBefore,\n      duration: endTime - startTime,\n      passed: true, // We can't really determine a \"pass\" here, just collecting metrics\n    };\n\n    this.results.push(result);\n\n    if (this.onTestCompleteCallback) {\n      this.onTestCompleteCallback(result);\n    }\n\n    // Delay before next test\n    await new Promise(resolve => setTimeout(resolve, this.config.delayBetweenTests));\n  }\n\n  private async runEventListenerTest(): Promise<void> {\n    const startTime = performance.now();\n    const memoryBefore = this.getMemoryUsage();\n\n    // Create elements and attach event listeners\n    const elements: HTMLDivElement[] = [];\n    const eventHandlers: ((e: Event) => void)[] = [];\n\n    for (let i = 0; i < Math.min(this.config.iterations, 100); i++) {\n      const element = document.createElement('div');\n      element.style.display = 'none';\n      document.body.appendChild(element);\n      elements.push(element);\n\n      // Create listener\n      const handler = (e: Event) => {\n        console.log('Event handled', e.type, i);\n      };\n\n      // Attach listener\n      element.addEventListener('click', handler);\n      eventHandlers.push(handler);\n\n      // Report progress\n      if (this.onProgressCallback) {\n        this.onProgressCallback(40 + (i / Math.min(this.config.iterations, 100)) * 20); // Third test = 40-60%\n      }\n\n      // Small delay to allow UI updates\n      await new Promise(resolve => setTimeout(resolve, 10));\n\n      if (!this.isRunning) break;\n    }\n\n    // Remove event listeners and elements if configured to do so\n    if (this.config.allowGC) {\n      elements.forEach((element, i) => {\n        element.removeEventListener('click', eventHandlers[i]);\n        element.remove();\n      });\n    }\n\n    const memoryAfter = this.getMemoryUsage();\n    const endTime = performance.now();\n\n    const result: MemoryTestResult = {\n      testName: 'Event Listener Test',\n      startTime,\n      endTime,\n      memoryBefore,\n      memoryAfter,\n      heapUsed: memoryAfter - memoryBefore,\n      duration: endTime - startTime,\n      passed: this.config.allowGC ? memoryAfter - memoryBefore < 1000000 : true, // 1MB threshold\n    };\n\n    this.results.push(result);\n\n    if (this.onTestCompleteCallback) {\n      this.onTestCompleteCallback(result);\n    }\n\n    // Delay before next test\n    await new Promise(resolve => setTimeout(resolve, this.config.delayBetweenTests));\n  }\n\n  private async runDOMReferenceTest(): Promise<void> {\n    const startTime = performance.now();\n    const memoryBefore = this.getMemoryUsage();\n\n    // Create DOM elements and store references\n    const references: HTMLElement[] = [];\n\n    for (let i = 0; i < Math.min(this.config.iterations * 10, 500); i++) {\n      const element = document.createElement('div');\n      element.innerHTML = `<span>Test element ${i}</span><ul>${Array(10)\n        .fill(0)\n        .map((_, idx) => `<li>Item ${idx}</li>`)\n        .join('')}</ul>`;\n      element.style.display = 'none';\n      document.body.appendChild(element);\n\n      references.push(element);\n\n      // Report progress\n      if (this.onProgressCallback) {\n        this.onProgressCallback(60 + (i / Math.min(this.config.iterations * 10, 500)) * 20); // Fourth test = 60-80%\n      }\n\n      // Small delay to allow UI updates\n      await new Promise(resolve => setTimeout(resolve, 5));\n\n      if (!this.isRunning) break;\n    }\n\n    // Clean up if configured to do so\n    if (this.config.allowGC) {\n      references.forEach(element => element.remove());\n      references.length = 0;\n    }\n\n    const memoryAfter = this.getMemoryUsage();\n    const endTime = performance.now();\n\n    const result: MemoryTestResult = {\n      testName: 'DOM Reference Test',\n      startTime,\n      endTime,\n      memoryBefore,\n      memoryAfter,\n      heapUsed: memoryAfter - memoryBefore,\n      duration: endTime - startTime,\n      passed: this.config.allowGC ? memoryAfter - memoryBefore < 2000000 : true, // 2MB threshold\n    };\n\n    this.results.push(result);\n\n    if (this.onTestCompleteCallback) {\n      this.onTestCompleteCallback(result);\n    }\n\n    // Delay before next test\n    await new Promise(resolve => setTimeout(resolve, this.config.delayBetweenTests));\n  }\n\n  private async runCircularReferenceTest(): Promise<void> {\n    const startTime = performance.now();\n    const memoryBefore = this.getMemoryUsage();\n\n    // Create objects with circular references\n    const objects: any[] = [];\n\n    for (let i = 0; i < this.config.iterations; i++) {\n      const parent: any = { name: `parent-${i}`, children: [] };\n      const child1: any = { name: `child1-${i}`, parent: parent };\n      const child2: any = { name: `child2-${i}`, parent: parent, sibling: child1 };\n\n      child1.sibling = child2;\n      parent.children.push(child1, child2);\n\n      objects.push(parent);\n\n      // Create deeper circular structures\n      if (i % 2 === 0) {\n        const deepStructure: any = { level: 0 };\n        let current = deepStructure;\n\n        for (let j = 1; j < 20; j++) {\n          current.next = { level: j, previous: current };\n          current = current.next;\n        }\n\n        // Complete the circle\n        current.next = deepStructure;\n        deepStructure.previous = current;\n\n        objects.push(deepStructure);\n      }\n\n      // Report progress\n      if (this.onProgressCallback) {\n        this.onProgressCallback(80 + (i / this.config.iterations) * 20); // Fifth test = 80-100%\n      }\n\n      // Small delay to allow UI updates\n      await new Promise(resolve => setTimeout(resolve, 10));\n\n      if (!this.isRunning) break;\n    }\n\n    // Break circular references if configured to do so\n    if (this.config.allowGC) {\n      objects.forEach(obj => {\n        if (obj.children) {\n          obj.children.forEach((child: any) => {\n            child.parent = null;\n            child.sibling = null;\n          });\n          obj.children = null;\n        }\n\n        // Break deep circular references\n        if (obj.level !== undefined) {\n          let current = obj;\n          let maxIterations = 100; // Safety to prevent infinite loops\n\n          while (current && current.next && maxIterations-- > 0) {\n            const next = current.next;\n            current.next = null;\n            current.previous = null;\n            current = next;\n\n            // If we've looped back to the beginning\n            if (current === obj) break;\n          }\n        }\n      });\n\n      objects.length = 0;\n\n      // Force garbage collection if available\n      if (window.gc) window.gc();\n    }\n\n    const memoryAfter = this.getMemoryUsage();\n    const endTime = performance.now();\n\n    const result: MemoryTestResult = {\n      testName: 'Circular Reference Test',\n      startTime,\n      endTime,\n      memoryBefore,\n      memoryAfter,\n      heapUsed: memoryAfter - memoryBefore,\n      duration: endTime - startTime,\n      passed: this.config.allowGC ? memoryAfter - memoryBefore < 1000000 : true, // 1MB threshold\n    };\n\n    this.results.push(result);\n\n    if (this.onTestCompleteCallback) {\n      this.onTestCompleteCallback(result);\n    }\n  }\n\n  private getMemoryUsage(): number {\n    if (window.performance && window.performance.memory) {\n      return (window.performance as any).memory.usedJSHeapSize;\n    }\n    return 0;\n  }\n\n  private getDataSize(): number {\n    switch (this.config.dataSize) {\n      case 'small':\n        return 10000;\n      case 'medium':\n        return 100000;\n      case 'large':\n        return 1000000;\n      default:\n        return 100000;\n    }\n  }\n}\n\n// Add the global gc declaration for TypeScript\ndeclare global {\n  interface Window {\n    gc?: () => void;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/tests/performance/MultitabPerformanceTestSuite.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":282,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":282,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7494,7497],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7494,7497],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":283,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":283,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7557,7560],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7557,7560],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'count' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":292,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":292,"endColumn":14}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * MultitabPerformanceTestSuite.ts\n *\n * Test suite for multitab performance testing\n */\n\nimport { PerformanceMetrics } from '../../hooks/ui/useDebugOverlay';\n\nexport interface PerformanceMetric {\n  average: number;\n  min: number;\n  max: number;\n  samples: number[];\n}\n\nexport interface MultitabPerformanceResult {\n  tabId: string;\n  memory: PerformanceMetric;\n  cpu: PerformanceMetric;\n  fps?: PerformanceMetric;\n  errors: Array<{\n    type: string;\n    message: string;\n    timestamp: number;\n  }>;\n  startTime: number;\n  endTime?: number;\n  status: 'initializing' | 'running' | 'completed' | 'error';\n}\n\nexport interface MultitabTestConfig {\n  tabCount: number;\n  scenarioType: 'resource-intensive' | 'memory-intensive' | 'network-intensive' | 'ui-intensive';\n  duration: number; // in seconds\n  delayBetweenTabs: number; // in milliseconds\n  reportFrequency: number; // in milliseconds\n  autoClose: boolean;\n  preserveData: boolean;\n}\n\n/**\n * Class to manage performance testing across multiple tabs\n */\nexport class MultitabPerformanceTestSuite {\n  private config: MultitabTestConfig;\n  private results: MultitabPerformanceResult[] = [];\n  private tabs: Window[] = [];\n  private isRunning = false;\n  private startTime = 0;\n  private testId: string;\n  private onProgressCallback?: (progress: number) => void;\n  private onResultCallback?: (results: MultitabPerformanceResult[]) => void;\n  private onTabOpenCallback?: (tabId: string, tabWindow: Window) => void;\n  private onTestCompleteCallback?: (results: MultitabPerformanceResult[]) => void;\n  private intervalId?: number;\n\n  constructor(config: MultitabTestConfig) {\n    this.config = config;\n    this.testId = `perf-test-${Date.now()}`;\n  }\n\n  /**\n   * Start the performance test across multiple tabs\n   */\n  public async start(): Promise<void> {\n    if (this.isRunning) {\n      throw new Error('Test is already running');\n    }\n\n    // Clear previous results if not preserving data\n    if (!this.config.preserveData) {\n      this.results = [];\n    }\n\n    this.isRunning = true;\n    this.startTime = Date.now();\n\n    // Create tabs with delay between them\n    for (let i = 0; i < this.config.tabCount; i++) {\n      if (!this.isRunning) break; // Stop if cancelled\n\n      const tabId = `tab-${i + 1}`;\n\n      // Initialize result object for this tab\n      this.results.push({\n        tabId,\n        memory: { average: 0, min: Infinity, max: 0, samples: [] },\n        cpu: { average: 0, min: Infinity, max: 0, samples: [] },\n        fps: { average: 0, min: Infinity, max: 0, samples: [] },\n        errors: [],\n        startTime: Date.now(),\n        status: 'initializing',\n      });\n\n      // Open the tab with parameters\n      const testUrl = this.getTestUrl(i, tabId);\n      const tabWindow = window.open(testUrl, tabId);\n\n      if (tabWindow) {\n        this.tabs.push(tabWindow);\n\n        if (this.onTabOpenCallback) {\n          this.onTabOpenCallback(tabId, tabWindow);\n        }\n\n        // Update tab status\n        this.updateTabStatus(tabId, 'running');\n      } else {\n        // Failed to open tab\n        this.updateTabStatus(tabId, 'error');\n        this.addError(tabId, 'system', 'Failed to open tab - check popup blocker');\n      }\n\n      // Add delay before opening next tab\n      if (i < this.config.tabCount - 1 && this.config.delayBetweenTabs > 0) {\n        await new Promise(resolve => setTimeout(resolve, this.config.delayBetweenTabs));\n      }\n    }\n\n    // Start collecting data from tabs\n    this.startDataCollection();\n\n    // End test after duration\n    setTimeout(() => {\n      this.stop();\n    }, this.config.duration * 1000);\n  }\n\n  /**\n   * Stop the performance test and close tabs if configured\n   */\n  public stop(): void {\n    if (!this.isRunning) return;\n\n    this.isRunning = false;\n\n    // Stop collecting data\n    if (this.intervalId) {\n      window.clearInterval(this.intervalId);\n      this.intervalId = undefined;\n    }\n\n    // Mark all tabs as completed\n    this.results.forEach(result => {\n      if (result.status === 'running') {\n        result.status = 'completed';\n        result.endTime = Date.now();\n      }\n    });\n\n    // Close tabs if configured to do so\n    if (this.config.autoClose) {\n      this.tabs.forEach(tab => {\n        try {\n          tab.close();\n        } catch (e) {\n          // Ignore errors when closing tabs\n          console.error('Error closing tab:', e);\n        }\n      });\n      this.tabs = [];\n    }\n\n    // Calculate final metrics\n    this.calculateFinalMetrics();\n\n    // Notify test completion\n    if (this.onTestCompleteCallback) {\n      this.onTestCompleteCallback(this.results);\n    }\n  }\n\n  /**\n   * Register a callback for progress updates\n   */\n  public onProgress(callback: (progress: number) => void): void {\n    this.onProgressCallback = callback;\n  }\n\n  /**\n   * Register a callback for result updates\n   */\n  public onResult(callback: (results: MultitabPerformanceResult[]) => void): void {\n    this.onResultCallback = callback;\n  }\n\n  /**\n   * Register a callback for when a new tab is opened\n   */\n  public onTabOpen(callback: (tabId: string, tabWindow: Window) => void): void {\n    this.onTabOpenCallback = callback;\n  }\n\n  /**\n   * Register a callback for test completion\n   */\n  public onTestComplete(callback: (results: MultitabPerformanceResult[]) => void): void {\n    this.onTestCompleteCallback = callback;\n  }\n\n  /**\n   * Get the current results\n   */\n  public getResults(): MultitabPerformanceResult[] {\n    return [...this.results];\n  }\n\n  /**\n   * Check if the test is running\n   */\n  public isTestRunning(): boolean {\n    return this.isRunning;\n  }\n\n  /**\n   * Get the progress of the test (0-100)\n   */\n  public getProgress(): number {\n    if (!this.isRunning || this.startTime === 0) return 0;\n    if (Date.now() - this.startTime >= this.config.duration * 1000) return 100;\n\n    return Math.min(\n      100,\n      Math.floor(((Date.now() - this.startTime) / (this.config.duration * 1000)) * 100)\n    );\n  }\n\n  /**\n   * Start collecting performance data from tabs\n   */\n  private startDataCollection(): void {\n    if (this.intervalId) {\n      window.clearInterval(this.intervalId);\n    }\n\n    this.intervalId = window.setInterval(() => {\n      // Update progress\n      if (this.onProgressCallback) {\n        this.onProgressCallback(this.getProgress());\n      }\n\n      // Collect data from each tab\n      this.tabs.forEach((tab, index) => {\n        try {\n          if (!tab || tab.closed) {\n            // Tab was closed\n            const tabId = `tab-${index + 1}`;\n            this.updateTabStatus(tabId, 'error');\n            this.addError(tabId, 'system', 'Tab was closed unexpectedly');\n            return;\n          }\n\n          const tabId = `tab-${index + 1}`;\n\n          // Try to retrieve performance data from the tab\n          if (tab.performance) {\n            this.collectPerformanceData(tabId, tab);\n          }\n\n          // Notify with current results\n          if (this.onResultCallback) {\n            this.onResultCallback(this.results);\n          }\n        } catch (e) {\n          console.error('Error collecting data from tab:', e);\n          // Ignore cross-origin errors\n        }\n      });\n    }, this.config.reportFrequency);\n  }\n\n  /**\n   * Collect performance data from a tab\n   */\n  private collectPerformanceData(tabId: string, tabWindow: Window): void {\n    try {\n      let memoryUsage = 0;\n      let cpuUsage = 0;\n      let fps = 0;\n\n      // Memory usage (if available)\n      if ((tabWindow.performance as any).memory) {\n        memoryUsage = (tabWindow.performance as any).memory.usedJSHeapSize / (1024 * 1024); // Convert to MB\n        this.updateMetric(tabId, 'memory', memoryUsage);\n      }\n\n      // Estimate CPU usage (this is just a rough approximation)\n      // In a real app, you would use the Performance API more effectively\n      const start = performance.now();\n      let count = 0;\n      for (let i = 0; i < 100000; i++) {\n        count += i;\n      }\n      const end = performance.now();\n      cpuUsage = (end - start) * 10; // Just a rough scaling factor\n      this.updateMetric(tabId, 'cpu', Math.min(100, cpuUsage)); // Cap at 100%\n\n      // FPS (in a real app, you would use requestAnimationFrame)\n      if (typeof tabWindow.requestAnimationFrame === 'function') {\n        // We can't actually measure frames here, but in a real app we would\n        // This is just an approximation for the example\n        fps = 60 - cpuUsage / 5; // Rough estimate - higher CPU = lower FPS\n        fps = Math.max(1, Math.min(60, fps)); // Clamp between 1-60\n        this.updateMetric(tabId, 'fps', fps);\n      }\n    } catch (e) {\n      console.error(`Error getting performance data for ${tabId}:`, e);\n    }\n  }\n\n  /**\n   * Update a performance metric for a tab\n   */\n  private updateMetric(tabId: string, metricName: 'memory' | 'cpu' | 'fps', value: number): void {\n    const result = this.results.find(r => r.tabId === tabId);\n    if (!result) return;\n\n    const metric = result[metricName];\n    if (!metric) return;\n\n    // Add sample\n    metric.samples.push(value);\n\n    // Update min/max\n    metric.min = Math.min(metric.min, value);\n    metric.max = Math.max(metric.max, value);\n\n    // Update average\n    metric.average = metric.samples.reduce((sum, val) => sum + val, 0) / metric.samples.length;\n  }\n\n  /**\n   * Update the status of a tab\n   */\n  private updateTabStatus(tabId: string, status: MultitabPerformanceResult['status']): void {\n    const result = this.results.find(r => r.tabId === tabId);\n    if (result) {\n      result.status = status;\n\n      if (status === 'completed' || status === 'error') {\n        result.endTime = Date.now();\n      }\n    }\n  }\n\n  /**\n   * Add an error for a tab\n   */\n  private addError(tabId: string, type: string, message: string): void {\n    const result = this.results.find(r => r.tabId === tabId);\n    if (result) {\n      result.errors.push({\n        type,\n        message,\n        timestamp: Date.now(),\n      });\n    }\n  }\n\n  /**\n   * Calculate final metrics for all tabs\n   */\n  private calculateFinalMetrics(): void {\n    // Nothing additional to calculate right now\n    // In a real app, you might want to calculate more complex metrics\n  }\n\n  /**\n   * Get the URL for a test tab\n   */\n  private getTestUrl(index: number, tabId: string): string {\n    const baseUrl = window.location.href.split('?')[0];\n    const params = new URLSearchParams();\n\n    params.set('scenario', this.config.scenarioType);\n    params.set('tabId', tabId);\n    params.set('testId', this.testId);\n    params.set('duration', String(this.config.duration));\n\n    return `${baseUrl}?${params.toString()}#test-worker`;\n  }\n}\n\n// Add the window.performance.memory TypeScript declaration\ndeclare global {\n  interface Performance {\n    memory?: PerformanceMetrics;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/tests/setup.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":56,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":56,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1514,1517],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1514,1517],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @context: ui-system, component-library, testing\n * \n * Vitest setup file\n * \n * This file sets up the testing environment for Vitest tests,\n * including mocks and global configuration needed across all tests.\n */\n\nimport { expect, afterEach, afterAll, vi } from 'vitest';\nimport { cleanup } from '@testing-library/react';\nimport matchers from '@testing-library/jest-dom/matchers';\n\n// Extend Vitest's expect with Jest DOM matchers\nexpect.extend(matchers);\n\n// Ensure that tests clean up DOM between test runs\nafterEach(() => {\n  cleanup();\n});\n\n// Mock window.matchMedia for responsive design tests\nObject.defineProperty(window, 'matchMedia', {\n  writable: true,\n  value: vi.fn().mockImplementation((query: string) => ({\n    matches: false,\n    media: query,\n    onchange: null,\n    addListener: vi.fn(),\n    removeListener: vi.fn(),\n    addEventListener: vi.fn(),\n    removeEventListener: vi.fn(),\n    dispatchEvent: vi.fn(),\n  })),\n});\n\n// Mock ResizeObserver which is used in various UI components\nglobal.ResizeObserver = vi.fn().mockImplementation(() => ({\n  observe: vi.fn(),\n  unobserve: vi.fn(),\n  disconnect: vi.fn(),\n}));\n\n// Mock IntersectionObserver for components that use it\nglobal.IntersectionObserver = vi.fn().mockImplementation(() => ({\n  observe: vi.fn(),\n  unobserve: vi.fn(),\n  disconnect: vi.fn(),\n  root: null,\n  rootMargin: '',\n  thresholds: [],\n}));\n\n// Mock console.error during tests to catch unexpected errors\nconst originalConsoleError = console.error;\nconsole.error = (...args: any[]) => {\n  // Fail tests on prop type errors\n  if (\n    typeof args[0] === 'string' && \n    args[0].includes('Warning: Failed prop type')\n  ) {\n    throw new Error(args[0]);\n  }\n  originalConsoleError(...args);\n};\n\n// Clean up console mock after all tests\nafterAll(() => {\n  console.error = originalConsoleError;\n});\n\n// Export a test-only object that contains commonly used test utilities\nexport const testUtils = {\n  mockErrorLoggingService: {\n    logError: vi.fn(),\n    clearErrors: vi.fn(),\n    getErrors: vi.fn().mockReturnValue([]),\n  },\n  \n  // Add more test utilities as needed\n}; ","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/tests/setup/testingLibrary.setup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/tests/setupTests.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/tests/types.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/tests/utils/test-utils.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'initialTheme' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":36,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":36,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @context: ui-system, component-library, testing\n * \n * Test utilities for rendering components with proper context and setup\n */\n\nimport React, { ReactElement } from 'react';\nimport { render, RenderOptions } from '@testing-library/react';\nimport { vi } from 'vitest';\nimport userEvent from '@testing-library/user-event';\nimport { ErrorType, ErrorSeverity } from '../../services/ErrorLoggingService';\n\n/**\n * Mock for ErrorLoggingService\n */\nexport const mockErrorLoggingService = {\n  logError: vi.fn(),\n  clearErrors: vi.fn(),\n  getErrors: vi.fn().mockReturnValue([]),\n};\n\n// Create custom render methods with providers\ninterface CustomRenderOptions extends Omit<RenderOptions, 'wrapper'> {\n  // Add any custom options here\n  initialTheme?: 'light' | 'dark';\n  initialWidth?: number;\n}\n\n/**\n * Custom render function that wraps the component with necessary providers\n */\nexport function renderWithProviders(\n  ui: ReactElement,\n  options: CustomRenderOptions = {}\n) {\n  const { initialTheme = 'light', initialWidth = 1024, ...renderOptions } = options;\n  \n  // Mock window size for responsive design testing\n  if (initialWidth) {\n    Object.defineProperty(window, 'innerWidth', {\n      writable: true,\n      configurable: true,\n      value: initialWidth,\n    });\n    \n    // Trigger resize event if needed\n    window.dispatchEvent(new Event('resize'));\n  }\n  \n  // Create wrapper with all required providers\n  const Wrapper = ({ children }: { children: React.ReactNode }) => {\n    return (\n      // Add any providers here (ThemeProvider, etc.)\n      <>{children}</>\n    );\n  };\n  \n  // Return the rendered component with userEvent for testing interactions\n  return {\n    user: userEvent.setup(),\n    ...render(ui, { wrapper: Wrapper, ...renderOptions }),\n  };\n}\n\n/**\n * Create a mock for ResizeObserver which is used in various UI components\n */\nexport function mockResizeObserver() {\n  const resizeObserverMock = vi.fn().mockImplementation(() => ({\n    observe: vi.fn(),\n    unobserve: vi.fn(),\n    disconnect: vi.fn(),\n  }));\n  \n  // Replace global ResizeObserver\n  window.ResizeObserver = resizeObserverMock;\n  \n  return resizeObserverMock;\n}\n\n/**\n * Helper function to wait for animations and transitions to complete\n */\nexport async function waitForAnimations() {\n  // Wait for any CSS transitions to finish\n  // Default value is a reasonable time for most transitions\n  return new Promise(resolve => setTimeout(resolve, 300));\n}\n\n/**\n * Creates a mock error event for testing error handling\n */\nexport function createMockErrorEvent(\n  message = 'Test error',\n  errorType: ErrorType = ErrorType.RUNTIME,\n  severity: ErrorSeverity = ErrorSeverity.MEDIUM\n) {\n  return {\n    error: new Error(message),\n    errorType,\n    severity,\n    componentName: 'TestComponent',\n    metadata: { test: true },\n  };\n}\n\n// Re-export everything from testing-library for convenience\nexport * from '@testing-library/react';\nexport { userEvent }; ","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/tests/vitest.d.ts","messages":[{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"An interface declaring no members is equivalent to its supertype.","line":7,"column":15,"nodeType":"Identifier","messageId":"noEmptyInterfaceWithSuper","endLine":7,"endColumn":24,"suggestions":[{"messageId":"replaceEmptyInterfaceWithSuper","fix":{"range":[224,289],"text":"type Assertion<T> = TestingLibraryMatchers<T, void>"},"desc":"Replace empty interface with a type alias."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"An interface declaring no members is equivalent to its supertype.","line":9,"column":15,"nodeType":"Identifier","messageId":"noEmptyInterfaceWithSuper","endLine":9,"endColumn":43,"suggestions":[{"messageId":"replaceEmptyInterfaceWithSuper","fix":{"range":[364,451],"text":"type AsymmetricMatchersContaining = TestingLibraryMatchers<unknown, void>"},"desc":"Replace empty interface with a type alias."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/// <reference types=\"vitest\" />\nimport type { TestingLibraryMatchers } from '@testing-library/jest-dom/matchers';\n\ndeclare global {\n  namespace Vi {\n    // @ts-expect-error - interface is used to extend Vitest matchers\n    interface Assertion<T> extends TestingLibraryMatchers<T, void> {}\n    // @ts-expect-error - interface is used to extend Vitest matchers\n    interface AsymmetricMatchersContaining extends TestingLibraryMatchers<unknown, void> {}\n  }\n} ","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/TypeUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/buildings/ModuleTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/buildings/ShipHangarTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/combat/CombatTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/combat/HazardTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/combat/SalvageTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/common.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/common/VectorTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/config/TypeSafeConfig.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/core/GameTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/core/Position.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/debug/DebugTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/declarations.d.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":9,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":9,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[337,340],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[337,340],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":11,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[486,489],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[486,489],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":13,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[636,639],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[636,639],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/events/CombatEvents.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/events/EventEmitterInterface.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":13,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[310,313],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[310,313],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":18,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":18,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[430,433],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[430,433],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":53,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1292,1295],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1292,1295],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":65,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":65,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1584,1587],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1584,1587],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":73,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":73,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1805,1808],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1805,1808],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * EventEmitterInterface.ts\n *\n * This file defines the standard interface for event emitters in the system.\n * All manager classes that need to emit events should implement this interface.\n */\n\nimport { EventType } from './EventTypes';\n\n/**\n * Standard event handler type\n */\nexport type EventHandler<T = any> = (data: T) => void;\n\n/**\n * Standard event predicate type for filtering events\n */\nexport type EventPredicate<T = any> = (data: T) => boolean;\n\n/**\n * Options for event subscription\n */\nexport interface SubscriptionOptions {\n  /**\n   * Call listener immediately with last event of this type if available\n   */\n  emitLatest?: boolean;\n\n  /**\n   * Source identification for tracking subscriptions\n   */\n  source?: string;\n\n  /**\n   * Priority for event processing (lower numbers = higher priority)\n   */\n  priority?: number;\n}\n\n/**\n * Standard interface for event emitters\n * This interface should be implemented by all manager classes that need to emit events\n */\nexport interface IEventEmitter {\n  /**\n   * Subscribe to an event\n   *\n   * @param eventType The type of event to subscribe to\n   * @param handler The function to call when the event is emitted\n   * @param options Additional subscription options\n   * @returns A function to unsubscribe the handler\n   */\n  on<T = any>(\n    eventType: EventType | string,\n    handler: EventHandler<T>,\n    options?: SubscriptionOptions\n  ): () => void;\n\n  /**\n   * Unsubscribe from an event\n   *\n   * @param eventType The type of event to unsubscribe from\n   * @param handler The handler function to remove\n   */\n  off<T = any>(eventType: EventType | string, handler: EventHandler<T>): void;\n\n  /**\n   * Emit an event\n   *\n   * @param eventType The type of event to emit\n   * @param data The data to pass to the event handlers\n   */\n  emit<T = any>(eventType: EventType | string, data: T): void;\n\n  /**\n   * Remove all event listeners\n   *\n   * @param eventType Optional event type to remove listeners for. If not provided, all listeners are removed.\n   */\n  removeAllListeners(eventType?: EventType | string): void;\n\n  /**\n   * Get the number of listeners for an event type\n   *\n   * @param eventType The event type to get the listener count for\n   * @returns The number of listeners\n   */\n  listenerCount(eventType: EventType | string): number;\n}\n\n/**\n * Interface for typed event emitters\n * This interface provides type safety for event data\n */\nexport interface ITypedEventEmitter<T extends Record<string, unknown>> {\n  /**\n   * Subscribe to an event\n   *\n   * @param event The event name (key of T)\n   * @param callback The function to call when the event is emitted\n   * @returns A function to unsubscribe the handler\n   */\n  on<K extends keyof T>(event: K, callback: (data: T[K]) => void): () => void;\n\n  /**\n   * Unsubscribe from an event\n   *\n   * @param event The event name (key of T)\n   * @param callback The handler function to remove\n   */\n  off<K extends keyof T>(event: K, callback: (data: T[K]) => void): void;\n\n  /**\n   * Emit an event\n   *\n   * @param event The event name (key of T)\n   * @param data The data to pass to the event handlers\n   */\n  emit<K extends keyof T>(event: K, data: T[K]): void;\n\n  /**\n   * Remove all event listeners\n   *\n   * @param event Optional event name to remove listeners for. If not provided, all listeners are removed.\n   */\n  removeAllListeners<K extends keyof T>(event?: K): void;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/events/EventTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/events/ExplorationEvents.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/events/FactionEvents.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/events/ModuleEventTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/events/ModuleEvents.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/events/SharedEventTypes.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'T' is defined but never used. Allowed unused vars must match /^ignored|^temp/u.","line":127,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":127,"endColumn":4}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @file SharedEventTypes.ts\n * Shared event types and interfaces for both production and test code\n *\n * This file provides unified event types to:\n * 1. Eliminate \"as unknown as\" casts in event handling\n * 2. Create consistent interfaces for mocks and real implementations\n * 3. Provide type-safe event creation and handling\n */\n\nimport { EventHandler as BaseEventHandler, EventUnsubscribe } from '../TypeUtils';\n\n/**\n * Base event interface that all events should extend\n */\nexport interface BaseEvent {\n  type: string;\n  timestamp: number;\n  data?: unknown;\n}\n\n/**\n * Generic typed event interface\n */\nexport interface TypedEvent<T extends string, D = unknown> extends BaseEvent {\n  type: T;\n  data?: D;\n}\n\n/**\n * Event Emitter interface compatible with both production and test code\n */\nexport interface EventEmitter<E extends BaseEvent = BaseEvent> {\n  emit(event: E): void;\n  on(eventType: string, handler: EventHandler<E>): EventUnsubscribe;\n  off(eventType: string, handler: EventHandler<E>): void;\n}\n\n/**\n * Event Bus interface for more complex event routing\n */\nexport interface EventBus<E extends BaseEvent = BaseEvent> extends EventEmitter<E> {\n  subscribe(eventType: string, handler: EventHandler<E>): EventUnsubscribe;\n  unsubscribe(eventType: string, handler: EventHandler<E>): void;\n  subscribeToMultiple(eventTypes: string[], handler: EventHandler<E>): EventUnsubscribe;\n  clear(): void;\n}\n\n/**\n * Mock Event Bus for testing - implements the same interface\n */\nexport interface MockEventBus<E extends BaseEvent = BaseEvent> extends EventBus<E> {\n  getEmittedEvents(): E[];\n  getSubscriptions(): Map<string, Array<EventHandler<E>>>;\n  reset(): void;\n}\n\n/**\n * Type-safe event creator - ensures proper event structure\n */\nexport function createEvent<T extends string, D>(type: T, data?: D): TypedEvent<T, D> {\n  return {\n    type,\n    timestamp: Date.now(),\n    data,\n  };\n}\n\n/**\n * Type-safe event data extractor - safely extracts data from events\n */\nexport function getEventData<T>(event: BaseEvent): T | undefined {\n  return event?.data as T | undefined;\n}\n\n/**\n * Event type guard - checks if an event is of a specific type\n */\nexport function isEventOfType<T extends string>(event: BaseEvent, type: T): event is TypedEvent<T> {\n  return event?.type === type;\n}\n\n/**\n * Event data type guard - checks if event data conforms to a specific shape\n */\nexport function hasEventData<T>(\n  event: BaseEvent,\n  predicate: (data: unknown) => data is T\n): event is BaseEvent & { data: T } {\n  return event?.data !== undefined && predicate(event?.data);\n}\n\n/**\n * Event handler with type filtering - only calls handler for matching event types\n */\nexport function createTypedEventHandler<T extends string, E extends BaseEvent, D>(\n  type: T,\n  handler: (data: D, event: E) => void\n): EventHandler<E> {\n  return (event: E) => {\n    if (event?.type === type && event?.data !== undefined) {\n      handler(event?.data as D, event);\n    }\n  };\n}\n\n/**\n * Common event object pattern shared across the application\n */\nexport interface EventObject<T extends string = string> {\n  eventType: T;\n  payload: unknown;\n}\n\n/**\n * Generic event map interface for strongly typed event data\n */\nexport interface EventDataMap {\n  [eventType: string]: unknown;\n}\n\n/**\n * Type-safe event subscription helper\n */\nexport function typedSubscribe<\n  E extends BaseEvent,\n  T extends string,\n  M extends EventDataMap,\n  K extends keyof M & string,\n>(\n  bus: EventBus<E>,\n  eventType: K,\n  handler: (data: M[K], event: TypedEvent<K, M[K]>) => void\n): EventUnsubscribe {\n  const wrappedHandler: EventHandler<E> = (event: E) => {\n    if (event?.type === eventType) {\n      handler(event?.data as M[K], event as unknown as TypedEvent<K, M[K]>);\n    }\n  };\n\n  return bus.subscribe(eventType, wrappedHandler);\n}\n\n/**\n * Type-safe event emission helper\n */\nexport function typedEmit<E extends BaseEvent, M extends EventDataMap, K extends keyof M & string>(\n  bus: EventEmitter<E>,\n  eventType: K,\n  data: M[K]\n): void {\n  const event: TypedEvent<K, M[K]> = {\n    type: eventType,\n    timestamp: Date.now(),\n    data,\n  };\n\n  bus.emit(event as unknown as E);\n}\n\n// Re-export these types\nexport type EventHandler<T> = BaseEventHandler<T>;\nexport type { EventUnsubscribe };\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/events/ShipEvents.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/events/StandardizedEvents.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/events/__tests__/StandardizedEvents.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/events/moduleEventBus.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/exploration/AnalysisComponentTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/exploration/ClassificationTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/exploration/DataAnalysisTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/exploration/ExplorationTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/exploration/unified/ExplorationTypeUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/exploration/unified/ExplorationTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/exploration/unified/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/geometry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/global.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/managers/MockManagerFactory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/managers/SharedManagerTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/mining/MiningTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/modules/ModuleTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/officers/OfficerTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/resources/FlowNodeTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/resources/ResourceConversionTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/resources/ResourceFlowTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/resources/ResourcePoolTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/resources/ResourceSerializationTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/resources/ResourceTypeConverter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/resources/ResourceTypeUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/resources/ResourceTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/resources/StandardizedResourceTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/shared/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/ships/CommonShipTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/ships/FactionShipTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/ships/FactionTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/ships/PlayerShipTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/ships/Ship.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/ships/ShipTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/state/TypeSafeStateManagement.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/test-utils.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/types-fix.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/ui/ComponentTypes.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'HTMLAttributes' is defined but never used. Allowed unused vars must match /^ignored|^temp/u.","line":7,"column":36,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":50}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @context: ui-system, type-definitions, ui-component-library\n * \n * Common component props and types used throughout the UI system\n */\n\nimport { ReactNode, CSSProperties, HTMLAttributes, RefObject } from 'react';\nimport { ThemeColor, ThemeFontSize, ThemeSpacing } from './ThemeTypes';\n\n/**\n * Standard sizes that can be used across components\n */\nexport enum ComponentSize {\n  XSMALL = 'xsmall',\n  SMALL = 'small',\n  MEDIUM = 'medium',\n  LARGE = 'large',\n  XLARGE = 'xlarge'\n}\n\n/**\n * Standard variants that can be used across components\n */\nexport enum ComponentVariant {\n  PRIMARY = 'primary',\n  SECONDARY = 'secondary',\n  TERTIARY = 'tertiary',\n  SUCCESS = 'success',\n  WARNING = 'warning',\n  DANGER = 'danger',\n  INFO = 'info',\n  LIGHT = 'light',\n  DARK = 'dark',\n  GHOST = 'ghost',\n  LINK = 'link'\n}\n\n/**\n * Standard states for interactive components\n */\nexport enum ComponentState {\n  DEFAULT = 'default',\n  HOVER = 'hover',\n  ACTIVE = 'active',\n  DISABLED = 'disabled',\n  FOCUSED = 'focused'\n}\n\n/**\n * Common props shared across most UI components\n */\nexport interface BaseComponentProps {\n  /** Unique identifier for the component */\n  id?: string;\n  \n  /** Additional CSS class names to apply to the component */\n  className?: string;\n  \n  /** Inline styles to apply to the component */\n  style?: CSSProperties;\n  \n  /** Describes the component for accessibility tools */\n  'aria-label'?: string;\n  \n  /** ID of an element that describes this component */\n  'aria-labelledby'?: string;\n  \n  /** ID of an element that describes this component in detail */\n  'aria-describedby'?: string;\n  \n  /** Indicates if the component is currently disabled */\n  disabled?: boolean;\n  \n  /** Data attribute for test selection */\n  'data-testid'?: string;\n}\n\n/**\n * Props for components that work with refs\n */\nexport interface RefProps<T> {\n  /** Ref object passed to the component */\n  ref?: RefObject<T>;\n}\n\n/**\n * Props for components with children\n */\nexport interface ChildrenProps {\n  /** Content of the component */\n  children?: ReactNode;\n}\n\n/**\n * Props for components with a theme color\n */\nexport interface ColorProps {\n  /** The theme color to use */\n  color?: ThemeColor;\n}\n\n/**\n * Props for components with foreground and background colors\n */\nexport interface ColoredComponentProps extends ColorProps {\n  /** The background color to use */\n  backgroundColor?: ThemeColor;\n}\n\n/**\n * Props for components with size variants\n */\nexport interface SizedComponentProps {\n  /** The size variant of the component */\n  size?: ComponentSize;\n}\n\n/**\n * Props for components with different variants\n */\nexport interface VariantComponentProps {\n  /** The variant of the component */\n  variant?: ComponentVariant;\n}\n\n/**\n * Props for components with loading states\n */\nexport interface LoadingComponentProps {\n  /** Whether the component is in a loading state */\n  loading?: boolean;\n  \n  /** Element to show while loading */\n  loadingIndicator?: ReactNode;\n}\n\n/**\n * Props for components with events\n */\nexport interface InteractiveComponentProps {\n  /** Callback for click events */\n  onClick?: (event: React.MouseEvent) => void;\n  \n  /** Callback for focus events */\n  onFocus?: (event: React.FocusEvent) => void;\n  \n  /** Callback for blur events */\n  onBlur?: (event: React.FocusEvent) => void;\n  \n  /** Callback for hover start */\n  onMouseEnter?: (event: React.MouseEvent) => void;\n  \n  /** Callback for hover end */\n  onMouseLeave?: (event: React.MouseEvent) => void;\n}\n\n/**\n * Props for components with labels\n */\nexport interface LabeledComponentProps {\n  /** The main label text */\n  label?: string | ReactNode;\n  \n  /** Whether to hide the label visually (still available for screen readers) */\n  hideLabel?: boolean;\n  \n  /** Text to display when the component is empty or has no selection */\n  placeholder?: string;\n}\n\n/**\n * Props for components with error states\n */\nexport interface ErrorComponentProps {\n  /** Whether the component has an error */\n  hasError?: boolean;\n  \n  /** Error message to display */\n  errorMessage?: string | ReactNode;\n}\n\n/**\n * Props for components with a responsive behavior\n */\nexport interface ResponsiveComponentProps {\n  /** Hide component below this breakpoint */\n  hideBelow?: string;\n  \n  /** Hide component above this breakpoint */\n  hideAbove?: string;\n}\n\n/**\n * Props for layoutable components\n */\nexport interface LayoutComponentProps {\n  /** Margin on all sides using theme spacing values */\n  margin?: ThemeSpacing;\n  \n  /** Margin top using theme spacing values */\n  marginTop?: ThemeSpacing;\n  \n  /** Margin right using theme spacing values */\n  marginRight?: ThemeSpacing;\n  \n  /** Margin bottom using theme spacing values */\n  marginBottom?: ThemeSpacing;\n  \n  /** Margin left using theme spacing values */\n  marginLeft?: ThemeSpacing;\n  \n  /** Padding on all sides using theme spacing values */\n  padding?: ThemeSpacing;\n  \n  /** Padding top using theme spacing values */\n  paddingTop?: ThemeSpacing;\n  \n  /** Padding right using theme spacing values */\n  paddingRight?: ThemeSpacing;\n  \n  /** Padding bottom using theme spacing values */\n  paddingBottom?: ThemeSpacing;\n  \n  /** Padding left using theme spacing values */\n  paddingLeft?: ThemeSpacing;\n  \n  /** Sets the display property */\n  display?: 'block' | 'inline' | 'inline-block' | 'flex' | 'grid' | 'none';\n  \n  /** Sets the position property */\n  position?: 'static' | 'relative' | 'absolute' | 'fixed' | 'sticky';\n  \n  /** Whether the component should take up the full width of its container */\n  fullWidth?: boolean;\n}\n\n/**\n * Props for text components\n */\nexport interface TextComponentProps extends ColorProps {\n  /** Font size from theme */\n  fontSize?: ThemeFontSize;\n  \n  /** Font weight */\n  fontWeight?: 'normal' | 'bold' | 'light' | 'medium' | 'semibold';\n  \n  /** Text alignment */\n  textAlign?: 'left' | 'center' | 'right' | 'justify';\n  \n  /** Whether text should be truncated with ellipsis */\n  truncate?: boolean;\n  \n  /** Text transform */\n  textTransform?: 'none' | 'capitalize' | 'uppercase' | 'lowercase';\n}\n\n/**\n * Type guard for checking if a value is a valid ComponentSize\n */\nexport function isComponentSize(value: unknown): value is ComponentSize {\n  return typeof value === 'string' && Object.values(ComponentSize).includes(value as ComponentSize);\n}\n\n/**\n * Type guard for checking if a value is a valid ComponentVariant\n */\nexport function isComponentVariant(value: unknown): value is ComponentVariant {\n  return typeof value === 'string' && Object.values(ComponentVariant).includes(value as ComponentVariant);\n}\n\n/**\n * Type guard for checking if a value is a valid ComponentState\n */\nexport function isComponentState(value: unknown): value is ComponentState {\n  return typeof value === 'string' && Object.values(ComponentState).includes(value as ComponentState);\n} ","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/ui/EventTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/ui/ThemeTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/ui/UITypes.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":105,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":105,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1724,1727],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1724,1727],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Types for UI component profiling\n */\n\n/**\n * Component render metrics\n */\nexport interface ComponentRenderMetrics {\n  /**\n   * Component name\n   */\n  componentName: string;\n\n  /**\n   * Render count\n   */\n  renderCount: number;\n\n  /**\n   * Last render time in milliseconds\n   */\n  lastRenderTime: number;\n\n  /**\n   * Average render time in milliseconds\n   */\n  averageRenderTime: number;\n\n  /**\n   * Maximum render time in milliseconds\n   */\n  maxRenderTime: number;\n\n  /**\n   * Total render time in milliseconds\n   */\n  totalRenderTime: number;\n\n  /**\n   * Timestamp of the last render\n   */\n  lastRenderTimestamp: number;\n\n  /**\n   * Wasted renders (renders that didn't change the output)\n   */\n  wastedRenders: number;\n\n  /**\n   * Props that changed in the last render\n   */\n  lastChangedProps?: string[];\n\n  /**\n   * Component render path (parent components)\n   */\n  renderPath?: string[];\n}\n\n/**\n * Component profiling options\n */\nexport interface ComponentProfilingOptions {\n  /**\n   * Whether to enable profiling\n   * @default true\n   */\n  enabled?: boolean;\n\n  /**\n   * Whether to log render metrics to the console\n   * @default false\n   */\n  logToConsole?: boolean;\n\n  /**\n   * Threshold in milliseconds for slow render warnings\n   * @default 16 (1 frame at 60fps)\n   */\n  slowRenderThreshold?: number;\n\n  /**\n   * Maximum number of renders to track in history\n   * @default 100\n   */\n  maxRenderHistory?: number;\n\n  /**\n   * Whether to track prop changes\n   * @default true\n   */\n  trackPropChanges?: boolean;\n\n  /**\n   * Whether to track render path\n   * @default false\n   */\n  trackRenderPath?: boolean;\n}\n\n/**\n * Component profiling result\n */\nexport interface ComponentProfilingResult {\n  profileRender: any;\n  /**\n   * Component metrics\n   */\n  metrics: ComponentRenderMetrics;\n\n  /**\n   * Render history\n   */\n  renderHistory: Array<{\n    /**\n     * Render timestamp\n     */\n    timestamp: number;\n\n    /**\n     * Render time in milliseconds\n     */\n    renderTime: number;\n\n    /**\n     * Whether this was a wasted render\n     */\n    wasted: boolean;\n\n    /**\n     * Props that changed in this render\n     */\n    changedProps?: string[];\n  }>;\n\n  /**\n   * Reset metrics\n   */\n  reset: () => void;\n\n  /**\n   * Update profiling options\n   */\n  updateOptions: (options: Partial<ComponentProfilingOptions>) => void;\n}\n\n/**\n * Application profiling metrics\n */\nexport interface ApplicationProfilingMetrics {\n  /**\n   * Total number of renders across all components\n   */\n  totalRenders: number;\n\n  /**\n   * Total number of wasted renders across all components\n   */\n  totalWastedRenders: number;\n\n  /**\n   * Average render time across all components in milliseconds\n   */\n  averageRenderTime: number;\n\n  /**\n   * Components sorted by render count (descending)\n   */\n  componentsByRenderCount: ComponentRenderMetrics[];\n\n  /**\n   * Components sorted by average render time (descending)\n   */\n  componentsByRenderTime: ComponentRenderMetrics[];\n\n  /**\n   * Components sorted by wasted renders (descending)\n   */\n  componentsByWastedRenders: ComponentRenderMetrics[];\n\n  /**\n   * Timestamp when profiling started\n   */\n  profilingStartTime: number;\n\n  /**\n   * Duration of profiling in milliseconds\n   */\n  profilingDuration: number;\n}\n\n/**\n * Application profiling options\n */\nexport interface ApplicationProfilingOptions extends ComponentProfilingOptions {\n  /**\n   * Whether to automatically profile all components\n   * @default false\n   */\n  autoProfileAll?: boolean;\n\n  /**\n   * Component name patterns to include in auto-profiling\n   * @default []\n   */\n  includePatterns?: string[];\n\n  /**\n   * Component name patterns to exclude from auto-profiling\n   * @default []\n   */\n  excludePatterns?: string[];\n}\n\n/**\n * Application profiling result\n */\nexport interface ApplicationProfilingResult {\n  /**\n   * Get application metrics\n   */\n  getMetrics: () => ApplicationProfilingMetrics;\n\n  /**\n   * Get metrics for a specific component\n   */\n  getComponentMetrics: (componentName: string) => ComponentRenderMetrics | null;\n\n  /**\n   * Reset all metrics\n   */\n  resetAll: () => void;\n\n  /**\n   * Reset metrics for a specific component\n   */\n  resetComponent: (componentName: string) => void;\n\n  /**\n   * Update profiling options\n   */\n  updateOptions: (options: Partial<ApplicationProfilingOptions>) => void;\n\n  /**\n   * Start profiling\n   */\n  start: () => void;\n\n  /**\n   * Stop profiling\n   */\n  stop: () => void;\n\n  /**\n   * Whether profiling is active\n   */\n  isActive: () => boolean;\n\n  /**\n   * Get or create a component profiler\n   */\n  getOrCreateProfiler: (componentName: string) => ComponentProfilingResult;\n\n  /**\n   * Check if a component should be profiled\n   */\n  shouldProfileComponent: (componentName: string) => boolean;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/ui/typeGuards.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ComponentState' is defined but never used. Allowed unused vars must match /^ignored|^temp/u.","line":7,"column":43,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":57},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ThemeFontSizeName' is defined but never used. Allowed unused vars must match /^ignored|^temp/u.","line":10,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ThemeSpacingName' is defined but never used. Allowed unused vars must match /^ignored|^temp/u.","line":11,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ThemeBorderRadius' is defined but never used. Allowed unused vars must match /^ignored|^temp/u.","line":12,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'UIEvent' is defined but never used. Allowed unused vars must match /^ignored|^temp/u.","line":16,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":30}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @context: ui-system, type-definitions, ui-component-library\n * \n * Type guards for UI-related types\n */\n\nimport { ComponentSize, ComponentVariant, ComponentState } from './ComponentTypes';\nimport { \n  ThemeColorName, \n  ThemeFontSizeName, \n  ThemeSpacingName, \n  ThemeBorderRadius, \n  ThemeBreakpoint,\n  Theme\n} from './ThemeTypes';\nimport { UIEventType, UIEvent } from './EventTypes';\n\n/**\n * Type guard for checking if a value is a valid UIEventType\n */\nexport function isUIEventType(value: unknown): value is UIEventType {\n  return typeof value === 'string' && Object.values(UIEventType).includes(value as UIEventType);\n}\n\n/**\n * Type guard for checking if a value has base component props\n */\nexport function hasBaseComponentProps(value: unknown): boolean {\n  if (!value || typeof value !== 'object') return false;\n  \n  const obj = value as Record<string, unknown>;\n  \n  // Check for required or typical component props\n  return (\n    // At least one of these common props should be present\n    'className' in obj ||\n    'style' in obj ||\n    'id' in obj ||\n    'disabled' in obj ||\n    'children' in obj ||\n    'onClick' in obj\n  );\n}\n\n/**\n * Type guard for checking if a value has a valid color prop\n */\nexport function hasValidColorProp(value: unknown): boolean {\n  if (!value || typeof value !== 'object') return false;\n  \n  const obj = value as Record<string, unknown>;\n  \n  if (!('color' in obj)) return false;\n  \n  const color = obj.color;\n  \n  // Color can be a ThemeColorName enum value or a string\n  return (\n    color === undefined ||\n    typeof color === 'string' || \n    Object.values(ThemeColorName).includes(color as ThemeColorName)\n  );\n}\n\n/**\n * Type guard for checking if a value has a valid size prop\n */\nexport function hasValidSizeProp(value: unknown): boolean {\n  if (!value || typeof value !== 'object') return false;\n  \n  const obj = value as Record<string, unknown>;\n  \n  if (!('size' in obj)) return false;\n  \n  const size = obj.size;\n  \n  // Size can be a ComponentSize enum value or a string\n  return (\n    size === undefined ||\n    typeof size === 'string' || \n    Object.values(ComponentSize).includes(size as ComponentSize)\n  );\n}\n\n/**\n * Type guard for checking if a value has a valid variant prop\n */\nexport function hasValidVariantProp(value: unknown): boolean {\n  if (!value || typeof value !== 'object') return false;\n  \n  const obj = value as Record<string, unknown>;\n  \n  if (!('variant' in obj)) return false;\n  \n  const variant = obj.variant;\n  \n  // Variant can be a ComponentVariant enum value or a string\n  return (\n    variant === undefined ||\n    typeof variant === 'string' || \n    Object.values(ComponentVariant).includes(variant as ComponentVariant)\n  );\n}\n\n/**\n * Type guard for checking if a value is a valid CSS property name\n */\nexport function isValidCSSPropertyName(value: unknown): value is string {\n  if (typeof value !== 'string') return false;\n  \n  // Simple check for common CSS properties - this is not exhaustive\n  const commonCSSProperties = [\n    'color', 'background', 'margin', 'padding', 'border',\n    'display', 'position', 'top', 'right', 'bottom', 'left',\n    'width', 'height', 'min-width', 'max-width', 'min-height', 'max-height',\n    'font', 'font-size', 'font-weight', 'text-align', 'line-height',\n    'flex', 'grid', 'transform', 'transition', 'animation',\n    'opacity', 'visibility', 'z-index', 'overflow'\n  ];\n  \n  return (\n    commonCSSProperties.includes(value) ||\n    /^[a-zA-Z][\\w-]*$/.test(value) // General CSS property name pattern\n  );\n}\n\n/**\n * Type guard for checking if a value is a valid CSS style object\n */\nexport function isValidStyleObject(value: unknown): value is React.CSSProperties {\n  if (!value || typeof value !== 'object') return false;\n  \n  const obj = value as Record<string, unknown>;\n  \n  // Check a few random keys to see if they look like CSS properties\n  const keys = Object.keys(obj);\n  \n  if (keys.length === 0) return true; // Empty style object is valid\n  \n  // Check at least some of the keys are valid CSS properties\n  return keys.some(key => {\n    // Convert camelCase to kebab-case for checking\n    const kebabKey = key.replace(/([A-Z])/g, '-$1').toLowerCase();\n    return isValidCSSPropertyName(kebabKey);\n  });\n}\n\n/**\n * Type guard for checking if a value is a valid layout prop\n */\nexport function isValidLayoutProp(prop: string): boolean {\n  const layoutProps = [\n    'margin', 'marginTop', 'marginRight', 'marginBottom', 'marginLeft',\n    'padding', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft',\n    'display', 'position', 'width', 'height', 'maxWidth', 'maxHeight',\n    'minWidth', 'minHeight', 'top', 'right', 'bottom', 'left',\n    'flex', 'flexDirection', 'flexWrap', 'justifyContent', 'alignItems',\n    'alignContent', 'order', 'flexGrow', 'flexShrink', 'flexBasis', 'alignSelf',\n    'grid', 'gridTemplate', 'gridTemplateRows', 'gridTemplateColumns',\n    'gridTemplateAreas', 'gridAutoRows', 'gridAutoColumns', 'gridAutoFlow',\n    'gridRow', 'gridColumn', 'gridArea',\n    'gap', 'rowGap', 'columnGap'\n  ];\n  \n  return layoutProps.includes(prop);\n}\n\n/**\n * Type guard for checking if a value is a valid theme object\n */\nexport function isValidTheme(value: unknown): value is Theme {\n  if (!value || typeof value !== 'object') return false;\n  \n  const theme = value as Partial<Theme>;\n  \n  // Check for required theme properties\n  return (\n    typeof theme.name === 'string' &&\n    !!theme.colors &&\n    !!theme.typography &&\n    !!theme.spacing &&\n    !!theme.breakpoints\n  );\n}\n\n/**\n * Type guard for checking if a value is a valid React event handler\n */\nexport function isEventHandler(value: unknown): value is (event: React.SyntheticEvent) => void {\n  if (typeof value !== 'function') return false;\n  \n  // Check if the property name follows React event handler pattern\n  return true;\n}\n\n/**\n * Type guard for checking if a property name is a React event handler prop\n */\nexport function isEventHandlerProp(propName: string): boolean {\n  return /^on[A-Z]/.test(propName);\n}\n\n/**\n * Type guard for checking if a value is a valid React element\n */\nexport function isReactElement(value: unknown): boolean {\n  if (!value || typeof value !== 'object') return false;\n  \n  const obj = value as Record<string, unknown>;\n  \n  return (\n    '$$typeof' in obj &&\n    typeof obj.type !== 'undefined' &&\n    'props' in obj &&\n    typeof obj.props === 'object'\n  );\n}\n\n/**\n * Type guard for checking if a value is a valid responsive prop - one that changes based on breakpoint\n */\nexport function isResponsiveProp(value: unknown): boolean {\n  if (!value || typeof value !== 'object') return false;\n  \n  const obj = value as Record<string, unknown>;\n  \n  // Check if the object has breakpoint keys\n  const hasBreakpointKeys = Object.keys(obj).some(key => \n    Object.values(ThemeBreakpoint).includes(key as ThemeBreakpoint)\n  );\n  \n  return hasBreakpointKeys;\n}\n\n/**\n * Type guard for checking if a value is a valid aria attribute\n */\nexport function isAriaAttribute(propName: string): boolean {\n  return /^aria-[a-z]+$/.test(propName);\n}\n\n/**\n * Type guard for checking if a value is a valid data attribute\n */\nexport function isDataAttribute(propName: string): boolean {\n  return /^data-[a-z-]+$/.test(propName);\n}\n\n/**\n * Safely extracts a color value from props\n */\nexport function extractColorProp(props: Record<string, unknown>, defaultColor?: string): string | undefined {\n  if (!('color' in props)) return defaultColor;\n  \n  const color = props.color;\n  \n  if (color === undefined) return defaultColor;\n  if (typeof color !== 'string') return defaultColor;\n  \n  return color;\n}\n\n/**\n * Safely extracts a size value from props\n */\nexport function extractSizeProp(props: Record<string, unknown>, defaultSize?: ComponentSize): ComponentSize | undefined {\n  if (!('size' in props)) return defaultSize;\n  \n  const size = props.size;\n  \n  if (size === undefined) return defaultSize;\n  \n  if (typeof size === 'string' && Object.values(ComponentSize).includes(size as ComponentSize)) {\n    return size as ComponentSize;\n  }\n  \n  return defaultSize;\n}\n\n/**\n * Safely extracts a variant value from props\n */\nexport function extractVariantProp(props: Record<string, unknown>, defaultVariant?: ComponentVariant): ComponentVariant | undefined {\n  if (!('variant' in props)) return defaultVariant;\n  \n  const variant = props.variant;\n  \n  if (variant === undefined) return defaultVariant;\n  \n  if (typeof variant === 'string' && Object.values(ComponentVariant).includes(variant as ComponentVariant)) {\n    return variant as ComponentVariant;\n  }\n  \n  return defaultVariant;\n} ","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/visualization/CommonTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/visualization/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/visualizations/D3AnimationTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/visualizations/D3DragTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/visualizations/D3SelectionTypes.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'D3KeyFn' is defined but never used. Allowed unused vars must match /^ignored|^temp/u.","line":32,"column":6,"nodeType":null,"messageId":"unusedVar","endLine":32,"endColumn":13,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":132,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":132,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4033,4036],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4033,4036],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":164,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":164,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5201,5204],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5201,5204],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":176,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":176,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5469,5472],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5469,5472],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":271,"column":8,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":271,"endColumn":11,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8663,8666],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8663,8666],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":397,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":397,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12120,12123],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12120,12123],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/visualizations/D3Types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/visualizations/D3ValidationHooks.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/visualizations/D3Validators.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/visualizations/D3ZoomTypes.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":23,"column":1,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":23,"endColumn":74,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[749,822],"text":"// @ts-expect-error - d3 type constraints require us to ignore some type errors"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":25,"column":3,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":25,"endColumn":67,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[858,922],"text":"// @ts-expect-error - Element type constraint issue with d3's BaseType"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":28,"column":3,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":28,"endColumn":89,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[965,1051],"text":"// @ts-expect-error - d3's Element constraint is incompatible with TypeScript's Element type"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":102,"column":1,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":102,"endColumn":74,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[2596,2669],"text":"// @ts-expect-error - d3 type constraints require us to ignore some type errors"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":105,"column":3,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":105,"endColumn":67,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[2809,2873],"text":"// @ts-expect-error - Element type constraint issue with d3's BaseType"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":108,"column":3,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":108,"endColumn":67,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[2968,3032],"text":"// @ts-expect-error - Element type constraint issue with d3's BaseType"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":140,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":140,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3915,3918],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3915,3918],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":140,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":140,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3927,3930],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3927,3930],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":141,"column":9,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":141,"endColumn":45,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[3942,3978],"text":"// @ts-expect-error - d3 event type issues"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":155,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":155,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4507,4510],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4507,4510],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":169,"column":1,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":169,"endColumn":74,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[4788,4861],"text":"// @ts-expect-error - d3 type constraints require us to ignore some type errors"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":171,"column":3,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":171,"endColumn":68,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[4899,4964],"text":"// @ts-expect-error - GElement type constraint issue with d3's BaseType"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":178,"column":3,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":178,"endColumn":89,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[5115,5201],"text":"// @ts-expect-error - d3's Element constraint is incompatible with TypeScript's Element type"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":191,"column":1,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":191,"endColumn":74,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[5606,5679],"text":"// @ts-expect-error - d3 type constraints require us to ignore some type errors"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":198,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":198,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6056,6059],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6056,6059],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":225,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":225,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6798,6801],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6798,6801],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":242,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":242,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7466,7469],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7466,7469],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":261,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":261,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7953,7956],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7953,7956],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":261,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":261,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7965,7968],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7965,7968],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":271,"column":9,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":271,"endColumn":55,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[8381,8427],"text":"// @ts-expect-error - d3 method call arguments issue"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":313,"column":1,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":313,"endColumn":74,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[9572,9645],"text":"// @ts-expect-error - d3 type constraints require us to ignore some type errors"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":322,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":322,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9937,9940],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9937,9940],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/visualizations/FlowTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/weapons/WeaponTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/types/weapons/WeaponUpgrades.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/ui/components/Badge.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/ui/components/Badge/Badge.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/ui/components/Badge/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/ui/components/Badge/variants/StatusBadge.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/ui/components/Badge/variants/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/ui/components/Button.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/ui/components/Button/Button.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/ui/components/Button/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/ui/components/Button/variants/AbilityButton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/ui/components/Card.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/ui/components/Card/Card.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/ui/components/Card/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/ui/components/Card/variants/ModuleCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/ui/components/Divider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/ui/components/Icon.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/ui/components/Tooltip.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/ui/components/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/ui/components/inputs/Checkbox.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'hideLabel' is assigned a value but never used.","line":89,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":89,"endColumn":12}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @context: ui-system, ui-form-system, component-library\n * \n * Checkbox component for boolean selections with accessibility support\n */\n\nimport * as React from 'react';\nimport { \n  forwardRef, \n  useCallback, \n  useMemo, \n  useRef, \n  useEffect, \n  useImperativeHandle \n} from 'react';\nimport { \n  BaseComponentProps, \n  ComponentSize,\n  ComponentVariant,\n  LabeledComponentProps,\n  ErrorComponentProps\n} from '../../../types/ui/ComponentTypes';\n\nexport interface CheckboxProps extends \n  BaseComponentProps, \n  LabeledComponentProps, \n  ErrorComponentProps,\n  Omit<React.InputHTMLAttributes<HTMLInputElement>, 'size' | 'type'>\n{\n  /**\n   * Checkbox variant\n   * @default 'primary'\n   */\n  variant?: ComponentVariant;\n  \n  /**\n   * Checkbox size\n   * @default 'medium'\n   */\n  size?: ComponentSize;\n  \n  /**\n   * Checkbox label position\n   * @default 'right'\n   */\n  labelPosition?: 'left' | 'right';\n  \n  /**\n   * Helper text to display below the checkbox\n   */\n  helperText?: React.ReactNode;\n  \n  /**\n   * Whether the checkbox is checked\n   */\n  checked?: boolean;\n  \n  /**\n   * Default checked state (uncontrolled)\n   */\n  defaultChecked?: boolean;\n  \n  /**\n   * Whether the checkbox is in an indeterminate state\n   * @default false\n   */\n  indeterminate?: boolean;\n  \n  /**\n   * Callback when checkbox state changes\n   */\n  onChange?: (event: React.ChangeEvent<HTMLInputElement>) => void;\n}\n\n/**\n * Checkbox component with accessibility support\n */\nexport const Checkbox = forwardRef<HTMLInputElement, CheckboxProps>(({\n  // Base props\n  className,\n  style,\n  id,\n  disabled = false,\n  \n  // Checkbox specific props\n  variant = 'primary',\n  size = 'medium',\n  label,\n  hideLabel = false,\n  helperText,\n  hasError = false,\n  errorMessage,\n  labelPosition = 'right',\n  indeterminate = false,\n  \n  // HTML input props\n  checked,\n  defaultChecked,\n  onChange,\n  required,\n  name,\n  \n  // Rest of props\n  ...rest\n}, ref) => {\n  // Setup internal ref\n  const internalRef = useRef<HTMLInputElement>(null);\n  \n  // Expose the internal ref imperatively to the parent component\n  useImperativeHandle(ref, () => internalRef.current as HTMLInputElement);\n  \n  // Update indeterminate state when it changes\n  useEffect(() => {\n    if (internalRef.current) {\n      internalRef.current.indeterminate = indeterminate;\n    }\n  }, [indeterminate]);\n  \n  // Handle change event\n  const handleChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {\n    onChange?.(e);\n  }, [onChange]);\n  \n  // Memoize checkbox class names\n  const checkboxContainerClassName = useMemo(() => {\n    const classes = ['ui-checkbox-container'];\n    \n    if (className) {\n      classes.push(className);\n    }\n    \n    if (size) {\n      classes.push(`ui-checkbox-${size}`);\n    }\n    \n    if (variant) {\n      classes.push(`ui-checkbox-${variant}`);\n    }\n    \n    if (disabled) {\n      classes.push('ui-checkbox-disabled');\n    }\n    \n    if (hasError) {\n      classes.push('ui-checkbox-error');\n    }\n    \n    if (indeterminate) {\n      classes.push('ui-checkbox-indeterminate');\n    }\n    \n    if (checked) {\n      classes.push('ui-checkbox-checked');\n    }\n    \n    if (labelPosition === 'left') {\n      classes.push('ui-checkbox-label-left');\n    }\n    \n    return classes.join(' ');\n  }, [\n    className, size, variant, disabled, \n    hasError, indeterminate, checked, labelPosition\n  ]);\n  \n  // Generate unique ID for the checkbox if not provided\n  const checkboxId = id || `checkbox-${Math.random().toString(36).substring(2, 9)}`;\n  \n  // Content to render\n  const checkboxElement = (\n    <div className=\"ui-checkbox-wrapper\">\n      <input\n        ref={internalRef}\n        id={checkboxId}\n        type=\"checkbox\"\n        onChange={handleChange}\n        checked={checked}\n        defaultChecked={defaultChecked}\n        disabled={disabled}\n        required={required}\n        name={name}\n        aria-invalid={hasError}\n        aria-describedby={hasError ? `${checkboxId}-error` : undefined}\n        className=\"ui-checkbox-input\"\n        {...rest}\n      />\n      <div className=\"ui-checkbox-custom\" aria-hidden=\"true\">\n        {/* Custom checkbox visual - rendered by CSS with ::after for checkmark */}\n      </div>\n    </div>\n  );\n  \n  // Label element\n  const labelElement = label && (\n    <label \n      htmlFor={checkboxId}\n      className=\"ui-checkbox-label\"\n    >\n      {label}\n      {required && <span className=\"ui-checkbox-required\">*</span>}\n    </label>\n  );\n  \n  return (\n    <div className={checkboxContainerClassName} style={style}>\n      <div className=\"ui-checkbox-field\">\n        {/* Render label on the left if specified */}\n        {labelPosition === 'left' && labelElement}\n        \n        {/* Checkbox input */}\n        {checkboxElement}\n        \n        {/* Render label on the right by default */}\n        {labelPosition === 'right' && labelElement}\n      </div>\n      \n      {/* Helper text or error message */}\n      {(helperText || hasError) && (\n        <div \n          className={`ui-checkbox-helper-text ${hasError ? 'ui-checkbox-error-text' : ''}`}\n          id={hasError ? `${checkboxId}-error` : undefined}\n        >\n          {hasError ? errorMessage : helperText}\n        </div>\n      )}\n    </div>\n  );\n});\n\nCheckbox.displayName = 'Checkbox';\n\nexport default Checkbox; ","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/ui/components/inputs/Input.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/ui/components/inputs/Radio.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'hideLabel' is assigned a value but never used.","line":81,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":81,"endColumn":12}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @context: ui-system, ui-form-system, component-library\n * \n * Radio component for selecting one option from a set of choices\n */\n\nimport * as React from 'react';\nimport { forwardRef, useCallback, useMemo } from 'react';\nimport { \n  BaseComponentProps, \n  ComponentSize,\n  ComponentVariant,\n  LabeledComponentProps,\n  ErrorComponentProps\n} from '../../../types/ui/ComponentTypes';\n\nexport interface RadioProps extends \n  BaseComponentProps, \n  LabeledComponentProps, \n  ErrorComponentProps,\n  Omit<React.InputHTMLAttributes<HTMLInputElement>, 'size' | 'type'>\n{\n  /**\n   * Radio variant\n   * @default 'primary'\n   */\n  variant?: ComponentVariant;\n  \n  /**\n   * Radio size\n   * @default 'medium'\n   */\n  size?: ComponentSize;\n  \n  /**\n   * Radio label position\n   * @default 'right'\n   */\n  labelPosition?: 'left' | 'right';\n  \n  /**\n   * Helper text to display below the radio\n   */\n  helperText?: React.ReactNode;\n  \n  /**\n   * Whether the radio is checked\n   */\n  checked?: boolean;\n  \n  /**\n   * Default checked state (uncontrolled)\n   */\n  defaultChecked?: boolean;\n  \n  /**\n   * Value of the radio button\n   */\n  value: string;\n  \n  /**\n   * Callback when radio state changes\n   */\n  onChange?: (event: React.ChangeEvent<HTMLInputElement>) => void;\n}\n\n/**\n * Radio component for single selection with accessibility\n */\nexport const Radio = forwardRef<HTMLInputElement, RadioProps>(({\n  // Base props\n  className,\n  style,\n  id,\n  disabled = false,\n  \n  // Radio specific props\n  variant = 'primary',\n  size = 'medium',\n  label,\n  hideLabel = false,\n  helperText,\n  hasError = false,\n  errorMessage,\n  labelPosition = 'right',\n  \n  // HTML input props\n  checked,\n  defaultChecked,\n  onChange,\n  required,\n  name,\n  value,\n  \n  // Rest of props\n  ...rest\n}, ref) => {\n  // Handle change event\n  const handleChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {\n    onChange?.(e);\n  }, [onChange]);\n  \n  // Memoize radio class names\n  const radioContainerClassName = useMemo(() => {\n    const classes = ['ui-radio-container'];\n    \n    if (className) {\n      classes.push(className);\n    }\n    \n    if (size) {\n      classes.push(`ui-radio-${size}`);\n    }\n    \n    if (variant) {\n      classes.push(`ui-radio-${variant}`);\n    }\n    \n    if (disabled) {\n      classes.push('ui-radio-disabled');\n    }\n    \n    if (hasError) {\n      classes.push('ui-radio-error');\n    }\n    \n    if (checked) {\n      classes.push('ui-radio-checked');\n    }\n    \n    if (labelPosition === 'left') {\n      classes.push('ui-radio-label-left');\n    }\n    \n    return classes.join(' ');\n  }, [\n    className, size, variant, disabled, \n    hasError, checked, labelPosition\n  ]);\n  \n  // Generate unique ID for the radio if not provided\n  const radioId = id || `radio-${Math.random().toString(36).substring(2, 9)}`;\n  \n  // Content to render\n  const radioElement = (\n    <div className=\"ui-radio-wrapper\">\n      <input\n        ref={ref}\n        id={radioId}\n        type=\"radio\"\n        onChange={handleChange}\n        checked={checked}\n        defaultChecked={defaultChecked}\n        disabled={disabled}\n        required={required}\n        name={name}\n        value={value}\n        aria-invalid={hasError}\n        aria-describedby={hasError ? `${radioId}-error` : undefined}\n        className=\"ui-radio-input\"\n        {...rest}\n      />\n      <div className=\"ui-radio-custom\" aria-hidden=\"true\">\n        {/* Custom radio visual - rendered by CSS with ::after for selected state */}\n      </div>\n    </div>\n  );\n  \n  // Label element\n  const labelElement = label && (\n    <label \n      htmlFor={radioId}\n      className=\"ui-radio-label\"\n    >\n      {label}\n      {required && <span className=\"ui-radio-required\">*</span>}\n    </label>\n  );\n  \n  return (\n    <div className={radioContainerClassName} style={style}>\n      <div className=\"ui-radio-field\">\n        {/* Render label on the left if specified */}\n        {labelPosition === 'left' && labelElement}\n        \n        {/* Radio input */}\n        {radioElement}\n        \n        {/* Render label on the right by default */}\n        {labelPosition === 'right' && labelElement}\n      </div>\n      \n      {/* Helper text or error message */}\n      {(helperText || hasError) && (\n        <div \n          className={`ui-radio-helper-text ${hasError ? 'ui-radio-error-text' : ''}`}\n          id={hasError ? `${radioId}-error` : undefined}\n        >\n          {hasError ? errorMessage : helperText}\n        </div>\n      )}\n    </div>\n  );\n});\n\nRadio.displayName = 'Radio';\n\nexport default Radio;\n\n/**\n * RadioGroup component to manage a group of Radio buttons\n */\nexport interface RadioGroupProps extends \n  BaseComponentProps, \n  LabeledComponentProps, \n  ErrorComponentProps \n{\n  /**\n   * RadioGroup variant\n   * @default 'primary'\n   */\n  variant?: ComponentVariant;\n  \n  /**\n   * RadioGroup size\n   * @default 'medium'\n   */\n  size?: ComponentSize;\n  \n  /**\n   * Name attribute for all radio inputs in the group\n   */\n  name: string;\n  \n  /**\n   * Current selected value\n   */\n  value?: string;\n  \n  /**\n   * Default selected value (uncontrolled)\n   */\n  defaultValue?: string;\n  \n  /**\n   * Radio options\n   */\n  options?: Array<{\n    value: string;\n    label: React.ReactNode;\n    disabled?: boolean;\n  }>;\n  \n  /**\n   * Callback when selection changes\n   */\n  onChange?: (value: string, event: React.ChangeEvent<HTMLInputElement>) => void;\n  \n  /**\n   * Layout direction of the radio group\n   * @default 'vertical'\n   */\n  direction?: 'horizontal' | 'vertical';\n  \n  /**\n   * Radio items\n   */\n  children?: React.ReactNode;\n\n  /**\n   * Helper text to display below the radio group\n   */\n  helperText?: React.ReactNode;\n}\n\nexport const RadioGroup: React.FC<RadioGroupProps> = ({\n  className,\n  style,\n  variant = 'primary',\n  size = 'medium',\n  name,\n  value,\n  defaultValue,\n  options,\n  onChange,\n  direction = 'vertical',\n  children,\n  label,\n  hideLabel = false,\n  hasError = false,\n  errorMessage,\n  helperText,\n}) => {\n  // State for uncontrolled mode\n  const [selectedValue, setSelectedValue] = React.useState(defaultValue || '');\n  \n  // Determine if we're in controlled or uncontrolled mode\n  const isControlled = value !== undefined;\n  const currentValue = isControlled ? value : selectedValue;\n  \n  // Handle radio change\n  const handleRadioChange = React.useCallback((e: React.ChangeEvent<HTMLInputElement>) => {\n    const newValue = e.target.value;\n    \n    if (!isControlled) {\n      setSelectedValue(newValue);\n    }\n    \n    onChange?.(newValue, e);\n  }, [isControlled, onChange]);\n  \n  // Generate unique ID for the group\n  const groupId = `radio-group-${Math.random().toString(36).substring(2, 9)}`;\n  \n  // Build class names\n  const groupClassName = React.useMemo(() => {\n    const classes = ['ui-radio-group'];\n    \n    if (className) {\n      classes.push(className);\n    }\n    \n    if (direction === 'horizontal') {\n      classes.push('ui-radio-group-horizontal');\n    } else {\n      classes.push('ui-radio-group-vertical');\n    }\n    \n    if (hasError) {\n      classes.push('ui-radio-group-error');\n    }\n    \n    return classes.join(' ');\n  }, [className, direction, hasError]);\n  \n  // Render radios from options if provided\n  const radioOptions = options && options.map((option) => (\n    <Radio\n      key={option.value}\n      name={name}\n      value={option.value}\n      label={option.label}\n      checked={currentValue === option.value}\n      onChange={handleRadioChange}\n      variant={variant as ComponentVariant}\n      size={size as ComponentSize}\n      disabled={option.disabled}\n    />\n  ));\n  \n  // Modify children to inject props if they are Radio components\n  const enhancedChildren = React.Children.map(children, (child) => {\n    if (React.isValidElement(child) && child.type === Radio) {\n      return React.cloneElement(child, {\n        name,\n        checked: currentValue === child.props.value,\n        onChange: handleRadioChange,\n      } as React.ComponentProps<typeof Radio>);\n    }\n    return child;\n  });\n  \n  return (\n    <div className={groupClassName} style={style} role=\"radiogroup\" aria-labelledby={`${groupId}-label`}>\n      {label && !hideLabel && (\n        <div \n          id={`${groupId}-label`}\n          className=\"ui-radio-group-label\"\n        >\n          {label}\n        </div>\n      )}\n      \n      <div className=\"ui-radio-group-options\">\n        {radioOptions || enhancedChildren}\n      </div>\n      \n      {(helperText || hasError) && (\n        <div \n          className={`ui-radio-group-helper-text ${hasError ? 'ui-radio-group-error-text' : ''}`}\n          id={hasError ? `${groupId}-error` : undefined}\n        >\n          {hasError ? errorMessage : helperText}\n        </div>\n      )}\n    </div>\n  );\n};\n\nRadioGroup.displayName = 'RadioGroup'; ","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/ui/components/inputs/Select.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/ui/components/inputs/Slider.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/ui/components/inputs/Switch.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/ui/components/layout/Container.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/ui/components/layout/Flex.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/ui/components/layout/Grid.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'display' is defined but never used.","line":216,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":216,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ref' is defined but never used.","line":221,"column":6,"nodeType":null,"messageId":"unusedVar","endLine":221,"endColumn":9}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @context: ui-system, ui-layout-system, component-library\n * \n * Grid component for creating responsive grid layouts\n */\nimport * as React from 'react';\nimport { forwardRef, useMemo } from 'react';\nimport { \n  BaseComponentProps, \n  LayoutComponentProps \n} from '../../../types/ui/ComponentTypes';\n\n/**\n * Grid template options\n */\nexport enum GridTemplate {\n  EQUAL = 'equal',         // Equal width columns\n  AUTO = 'auto',           // Auto width based on content\n  AUTO_FILL = 'auto-fill', // Auto fill available space\n  AUTO_FIT = 'auto-fit'    // Auto fit available space\n}\n\n/**\n * Grid alignment options\n */\nexport enum GridAlignment {\n  START = 'start',\n  CENTER = 'center',\n  END = 'end',\n  STRETCH = 'stretch',\n  SPACE_BETWEEN = 'space-between',\n  SPACE_AROUND = 'space-around',\n  SPACE_EVENLY = 'space-evenly'\n}\n\n/**\n * Grid component props\n */\nexport interface GridProps extends BaseComponentProps, LayoutComponentProps {\n  /**\n   * Grid content\n   */\n  children: React.ReactNode;\n  \n  /**\n   * Number of columns\n   * @default 12\n   */\n  columns?: number;\n  \n  /**\n   * Grid column gap\n   * @default 16\n   */\n  columnGap?: number | string;\n  \n  /**\n   * Grid row gap\n   * @default 16\n   */\n  rowGap?: number | string;\n  \n  /**\n   * Combined shorthand for row and column gap\n   */\n  gap?: number | string;\n  \n  /**\n   * HTML element to render\n   * @default 'div'\n   */\n  as?: keyof JSX.IntrinsicElements;\n  \n  /**\n   * Minimum column width for auto templates\n   * Used with AUTO_FILL and AUTO_FIT templates\n   */\n  minColumnWidth?: number | string;\n  \n  /**\n   * Grid template type\n   * @default 'equal'\n   */\n  template?: GridTemplate | keyof typeof GridTemplate;\n  \n  /**\n   * Custom grid-template-columns CSS value\n   * Overrides columns and template props\n   */\n  templateColumns?: string;\n  \n  /**\n   * Custom grid-template-rows CSS value\n   */\n  templateRows?: string;\n  \n  /**\n   * Horizontal alignment of grid items\n   */\n  alignItems?: GridAlignment | keyof typeof GridAlignment;\n  \n  /**\n   * Vertical alignment of grid items\n   */\n  justifyItems?: GridAlignment | keyof typeof GridAlignment;\n  \n  /**\n   * Horizontal alignment of the entire grid\n   */\n  justifyContent?: GridAlignment | keyof typeof GridAlignment;\n  \n  /**\n   * Vertical alignment of the entire grid\n   */\n  alignContent?: GridAlignment | keyof typeof GridAlignment;\n  \n  /**\n   * Whether the grid should take up the full height of its container\n   * @default false\n   */\n  fullHeight?: boolean;\n  \n  /**\n   * Custom CSS grid-auto-flow value\n   */\n  autoFlow?: 'row' | 'column' | 'row dense' | 'column dense';\n}\n\n/**\n * Check if a value is a valid GridTemplate\n */\nfunction isGridTemplate(value: unknown): value is GridTemplate {\n  return typeof value === 'string' && Object.values(GridTemplate).includes(value as GridTemplate);\n}\n\n/**\n * Check if a value is a valid GridAlignment\n */\nfunction isGridAlignment(value: unknown): value is GridAlignment {\n  return typeof value === 'string' && Object.values(GridAlignment).includes(value as GridAlignment);\n}\n\n/**\n * Generate a grid template columns value based on template type\n */\nfunction getGridTemplateColumns(\n  template: GridTemplate | keyof typeof GridTemplate | undefined,\n  columns: number,\n  minColumnWidth: number | string | undefined\n): string {\n  if (!template) {\n    return `repeat(${columns}, 1fr)`;\n  }\n  \n  if (isGridTemplate(template)) {\n    switch (template) {\n      case GridTemplate.EQUAL:\n        return `repeat(${columns}, 1fr)`;\n      case GridTemplate.AUTO:\n        return `repeat(${columns}, auto)`;\n      case GridTemplate.AUTO_FILL:\n        if (minColumnWidth) {\n          return `repeat(auto-fill, minmax(${typeof minColumnWidth === 'number' ? `${minColumnWidth}px` : minColumnWidth}, 1fr))`;\n        }\n        return `repeat(auto-fill, minmax(150px, 1fr))`;\n      case GridTemplate.AUTO_FIT:\n        if (minColumnWidth) {\n          return `repeat(auto-fit, minmax(${typeof minColumnWidth === 'number' ? `${minColumnWidth}px` : minColumnWidth}, 1fr))`;\n        }\n        return `repeat(auto-fit, minmax(150px, 1fr))`;\n      default:\n        return `repeat(${columns}, 1fr)`;\n    }\n  }\n  \n  return `repeat(${columns}, 1fr)`;\n}\n\n/**\n * Grid component\n * \n * Creates responsive grid layouts\n */\nexport const Grid = forwardRef<HTMLElement, GridProps>(\n  ({\n    children,\n    columns = 12,\n    columnGap = 16,\n    rowGap = 16,\n    gap,\n    as = 'div',\n    minColumnWidth,\n    template = GridTemplate.EQUAL,\n    templateColumns,\n    templateRows,\n    alignItems,\n    justifyItems,\n    justifyContent,\n    alignContent,\n    fullHeight = false,\n    autoFlow,\n    className = '',\n    style,\n    id,\n    fullWidth,\n    padding,\n    paddingTop,\n    paddingRight,\n    paddingBottom,\n    paddingLeft,\n    margin,\n    marginTop,\n    marginRight,\n    marginBottom,\n    marginLeft,\n    display,\n    position,\n    'aria-labelledby': ariaLabelledBy,\n    'aria-label': ariaLabel,\n    'data-testid': dataTestId,\n  }, ref) => {\n    // Compute grid classes\n    const gridClasses = useMemo(() => {\n      return [\n              'gs-grid',\n              fullWidth ? 'gs-grid--full-width' : '',\n              fullHeight ? 'gs-grid--full-height' : '',\n              className\n            ].filter(Boolean).join(' ');\n    }, [fullWidth, fullHeight, className]);\n    \n    // Compute grid styles\n    const gridStyles = useMemo(() => {\n      // Calculate grid-template-columns based on props\n      const gridTemplateColumns = templateColumns || getGridTemplateColumns(template, columns, minColumnWidth);\n      \n      return {\n        display: 'grid',\n        gridTemplateColumns,\n        gridTemplateRows: templateRows,\n        gap: gap !== undefined ? (typeof gap === 'number' ? `${gap}px` : gap) : undefined,\n        columnGap: gap === undefined ? (typeof columnGap === 'number' ? `${columnGap}px` : columnGap) : undefined,\n        rowGap: gap === undefined ? (typeof rowGap === 'number' ? `${rowGap}px` : rowGap) : undefined,\n        alignItems: alignItems && isGridAlignment(alignItems) ? alignItems : undefined,\n        justifyItems: justifyItems && isGridAlignment(justifyItems) ? justifyItems : undefined,\n        justifyContent: justifyContent && isGridAlignment(justifyContent) ? justifyContent : undefined,\n        alignContent: alignContent && isGridAlignment(alignContent) ? alignContent : undefined,\n        gridAutoFlow: autoFlow,\n        height: fullHeight ? '100%' : undefined,\n        width: fullWidth ? '100%' : undefined,\n        padding,\n        paddingTop,\n        paddingRight,\n        paddingBottom,\n        paddingLeft,\n        margin,\n        marginTop,\n        marginRight,\n        marginBottom,\n        marginLeft,\n        position,\n        ...style\n      };\n    }, [\n      template,\n      columns,\n      minColumnWidth,\n      templateColumns,\n      templateRows,\n      gap,\n      columnGap,\n      rowGap,\n      alignItems,\n      justifyItems,\n      justifyContent,\n      alignContent,\n      autoFlow,\n      fullWidth,\n      fullHeight,\n      padding,\n      paddingTop,\n      paddingRight,\n      paddingBottom,\n      paddingLeft,\n      margin,\n      marginTop,\n      marginRight,\n      marginBottom,\n      marginLeft,\n      position,\n      style\n    ]);\n    \n    // Render the component with the element specified by the 'as' prop\n    const Component = as;\n    \n    // Use createElement to avoid type issues\n    return React.createElement(\n      Component,\n      {\n        className: gridClasses,\n        style: gridStyles,\n        ...(as === 'div' ? { id } : {}),\n        ...(as === 'div' ? { 'aria-labelledby': ariaLabelledBy, 'aria-label': ariaLabel, 'data-testid': dataTestId } : {})\n      },\n      children\n    );\n  }\n);\n\nGrid.displayName = 'Grid';\n\nexport default Grid; ","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/ui/components/layout/Spacer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/ui/components/layout/Stack.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/ui/components/typography/Heading.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/ui/components/typography/Label.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/ui/components/typography/Text.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/ui/layout/Responsive.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/ui/theme/defaultTheme.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/ResourceTypeConverter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/ResourceTypeMigration.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/cn.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/combat/scanRadiusUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/dataTransforms/chartTransforms.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/dataTransforms/filterTransforms.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/dataTransforms/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/dataTransforms/scientificTransforms.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/events/EventBatcher.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/events/EventBatchingRxJS.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/events/EventCommunication.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/events/EventDataTypes.ts","messages":[{"ruleId":"no-unsafe-optional-chaining","severity":2,"message":"Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.","line":137,"column":13,"nodeType":"ChainExpression","messageId":"unsafeOptionalChain","endLine":137,"endColumn":25},{"ruleId":"no-unsafe-optional-chaining","severity":2,"message":"Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.","line":138,"column":15,"nodeType":"ChainExpression","messageId":"unsafeOptionalChain","endLine":138,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_data' is defined but never used.","line":265,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":265,"endColumn":20}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @file EventDataTypes.ts\n * Comprehensive type definitions for event data payloads.\n * Provides type-safe interfaces for all event types and validation functions.\n */\n\nimport { EventType } from '../../types/events/EventTypes';\nimport { Module, ModuleStatus } from '../../types/modules/ModuleTypes';\nimport { ResourceType } from './../../types/resources/ResourceTypes';\n\n/**\n * Base interface for all event data\n */\nexport interface BaseEventData {\n  timestamp?: number;\n  source?: string;\n}\n\n/**\n * Module Events\n */\n\nexport interface ModuleCreatedEventData extends BaseEventData {\n  module: Module;\n  createdBy?: string;\n  buildingId?: string;\n}\n\nexport interface ModuleUpdatedEventData extends BaseEventData {\n  moduleId: string;\n  updates: Partial<Module>;\n}\n\nexport interface ModuleRemovedEventData extends BaseEventData {\n  moduleId: string;\n  reason?: string;\n}\n\nexport interface ModuleStatusChangedEventData extends BaseEventData {\n  moduleId: string;\n  status: ModuleStatus;\n  previousStatus?: ModuleStatus;\n}\n\nexport interface ModuleActivatedEventData extends BaseEventData {\n  moduleId: string;\n  activatedBy?: string;\n}\n\nexport interface ModuleDeactivatedEventData extends BaseEventData {\n  moduleId: string;\n  deactivatedBy?: string;\n  reason?: string;\n}\n\n/**\n * Resource Events\n */\n\nexport interface ResourceProducedEventData extends BaseEventData {\n  resourceType: ResourceType;\n  amount: number;\n  sourceId?: string;\n  sourceName?: string;\n}\n\nexport interface ResourceConsumedEventData extends BaseEventData {\n  resourceType: ResourceType;\n  amount: number;\n  consumerId?: string;\n  consumerName?: string;\n  purpose?: string;\n}\n\nexport interface ResourceTransferredEventData extends BaseEventData {\n  resourceType: ResourceType;\n  amount: number;\n  sourceId: string;\n  targetId: string;\n  transferTime?: number;\n}\n\nexport interface ResourceUpdatedEventData extends BaseEventData {\n  resourceType: ResourceType;\n  amount?: number;\n  production?: number;\n  consumption?: number;\n  rate?: number;\n  max?: number;\n  min?: number;\n}\n\nexport interface ResourceShortageEventData extends BaseEventData {\n  resourceType: ResourceType;\n  requiredAmount: number;\n  availableAmount: number;\n  consumerId: string;\n}\n\n/**\n * Game Events\n */\n\nexport interface GameStartedEventData extends BaseEventData {\n  gameTime: number;\n  difficulty?: string;\n  scenario?: string;\n}\n\nexport interface GamePausedEventData extends BaseEventData {\n  gameTime: number;\n  pausedBy?: string;\n}\n\nexport interface GameResumedEventData extends BaseEventData {\n  gameTime: number;\n  totalPausedTime?: number;\n}\n\nexport interface GameStoppedEventData extends BaseEventData {\n  gameTime: number;\n  reason?: string;\n  score?: number;\n}\n\n/**\n * Type guards (validation functions)\n */\n\nexport function isModuleCreatedEventData(data: unknown): data is ModuleCreatedEventData {\n  return (\n    !!data &&\n    typeof data === 'object' &&\n    'module' in data &&\n    typeof data?.module === 'object' &&\n    data?.module !== null &&\n    'id' in data?.module &&\n    'type' in data?.module\n  );\n}\n\nexport function isModuleUpdatedEventData(data: unknown): data is ModuleUpdatedEventData {\n  return (\n    !!data &&\n    typeof data === 'object' &&\n    'moduleId' in data &&\n    typeof data?.moduleId === 'string' &&\n    'updates' in data &&\n    typeof data?.updates === 'object' &&\n    data?.updates !== null\n  );\n}\n\nexport function isModuleRemovedEventData(data: unknown): data is ModuleRemovedEventData {\n  return (\n    !!data && typeof data === 'object' && 'moduleId' in data && typeof data?.moduleId === 'string'\n  );\n}\n\nexport function isModuleStatusChangedEventData(\n  data: unknown\n): data is ModuleStatusChangedEventData {\n  return (\n    !!data &&\n    typeof data === 'object' &&\n    'moduleId' in data &&\n    typeof data?.moduleId === 'string' &&\n    'status' in data\n  );\n}\n\nexport function isResourceProducedEventData(data: unknown): data is ResourceProducedEventData {\n  return (\n    !!data &&\n    typeof data === 'object' &&\n    'resourceType' in data &&\n    'amount' in data &&\n    typeof data?.amount === 'number'\n  );\n}\n\nexport function isResourceConsumedEventData(data: unknown): data is ResourceConsumedEventData {\n  return (\n    !!data &&\n    typeof data === 'object' &&\n    'resourceType' in data &&\n    'amount' in data &&\n    typeof data?.amount === 'number'\n  );\n}\n\nexport function isResourceTransferredEventData(\n  data: unknown\n): data is ResourceTransferredEventData {\n  return (\n    !!data &&\n    typeof data === 'object' &&\n    'resourceType' in data &&\n    'amount' in data &&\n    typeof data?.amount === 'number' &&\n    'sourceId' in data &&\n    typeof data?.sourceId === 'string' &&\n    'targetId' in data &&\n    typeof data?.targetId === 'string'\n  );\n}\n\nexport function isResourceUpdatedEventData(data: unknown): data is ResourceUpdatedEventData {\n  return !!data && typeof data === 'object' && 'resourceType' in data;\n}\n\nexport function isGameStartedEventData(data: unknown): data is GameStartedEventData {\n  return (\n    !!data && typeof data === 'object' && 'gameTime' in data && typeof data?.gameTime === 'number'\n  );\n}\n\n/**\n * Event data type mapping to EventType\n */\nexport interface EventDataTypeMap {\n  [EventType.MODULE_CREATED]: ModuleCreatedEventData;\n  [EventType.MODULE_UPDATED]: ModuleUpdatedEventData;\n  [EventType.MODULE_REMOVED]: ModuleRemovedEventData;\n  [EventType.MODULE_STATUS_CHANGED]: ModuleStatusChangedEventData;\n  [EventType.MODULE_ACTIVATED]: ModuleActivatedEventData;\n  [EventType.MODULE_DEACTIVATED]: ModuleDeactivatedEventData;\n  [EventType.RESOURCE_PRODUCED]: ResourceProducedEventData;\n  [EventType.RESOURCE_CONSUMED]: ResourceConsumedEventData;\n  [EventType.RESOURCE_TRANSFERRED]: ResourceTransferredEventData;\n  [EventType.RESOURCE_UPDATED]: ResourceUpdatedEventData;\n  [EventType.RESOURCE_SHORTAGE]: ResourceShortageEventData;\n  GAME_STARTED: GameStartedEventData;\n  GAME_PAUSED: GamePausedEventData;\n  GAME_RESUMED: GameResumedEventData;\n  GAME_STOPPED: GameStoppedEventData;\n  [key: string]: BaseEventData; // Allow any string key but require BaseEventData minimum structure\n}\n\n/**\n * Get the correct type guard for a specific event type\n */\nexport function getEventDataValidator(eventType: EventType | string): (data: unknown) => boolean {\n  switch (eventType) {\n    case EventType.MODULE_CREATED:\n      return isModuleCreatedEventData;\n    case EventType.MODULE_UPDATED:\n      return isModuleUpdatedEventData;\n    case EventType.MODULE_REMOVED:\n      return isModuleRemovedEventData;\n    case EventType.MODULE_STATUS_CHANGED:\n      return isModuleStatusChangedEventData;\n    case EventType.RESOURCE_PRODUCED:\n      return isResourceProducedEventData;\n    case EventType.RESOURCE_CONSUMED:\n      return isResourceConsumedEventData;\n    case EventType.RESOURCE_TRANSFERRED:\n      return isResourceTransferredEventData;\n    case EventType.RESOURCE_UPDATED:\n      return isResourceUpdatedEventData;\n    case 'GAME_STARTED':\n      return isGameStartedEventData;\n    default:\n      // Default fallback for event types without specific validators\n      return (_data: unknown): boolean => true;\n  }\n}\n\n/**\n * Validate event data against its expected type\n */\nexport function validateEventData(eventType: EventType | string, data: unknown): boolean {\n  const validator = getEventDataValidator(eventType);\n  return validator(data);\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/events/EventDevTools.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/events/EventDispatcher.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/events/EventFilter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/events/EventFiltering.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/events/EventPrioritizer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/events/EventThrottling.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/events/eventTypeGuards.ts","messages":[{"ruleId":"no-unsafe-optional-chaining","severity":2,"message":"Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.","line":14,"column":26,"nodeType":"ChainExpression","messageId":"unsafeOptionalChain","endLine":14,"endColumn":37},{"ruleId":"no-unsafe-optional-chaining","severity":2,"message":"Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.","line":30,"column":23,"nodeType":"ChainExpression","messageId":"unsafeOptionalChain","endLine":30,"endColumn":34},{"ruleId":"no-unsafe-optional-chaining","severity":2,"message":"Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.","line":31,"column":17,"nodeType":"ChainExpression","messageId":"unsafeOptionalChain","endLine":31,"endColumn":28},{"ruleId":"no-unsafe-optional-chaining","severity":2,"message":"Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.","line":46,"column":23,"nodeType":"ChainExpression","messageId":"unsafeOptionalChain","endLine":46,"endColumn":34},{"ruleId":"no-unsafe-optional-chaining","severity":2,"message":"Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.","line":47,"column":17,"nodeType":"ChainExpression","messageId":"unsafeOptionalChain","endLine":47,"endColumn":28}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ModuleEvent } from '../../lib/events/ModuleEventBus';\nimport { ResourceType } from '../../types/resources/ResourceTypes';\n\n/**\n * Type guard for resource update events\n */\nexport function isResourceUpdateEvent(\n  event: ModuleEvent\n): event is ModuleEvent & { data: { resourceAmounts: Partial<Record<ResourceType, number>> } } {\n  return (\n    event?.data !== undefined &&\n    typeof event?.data === 'object' &&\n    event?.data !== null &&\n    'resourceAmounts' in event?.data &&\n    typeof event?.data?.resourceAmounts === 'object' &&\n    event?.data?.resourceAmounts !== null\n  );\n}\n\n/**\n * Type guard for resource production events\n */\nexport function isResourceProductionEvent(\n  event: ModuleEvent\n): event is ModuleEvent & { data: { resourceType: ResourceType; amount: number } } {\n  return (\n    event?.data !== undefined &&\n    typeof event?.data === 'object' &&\n    event?.data !== null &&\n    'resourceType' in event?.data &&\n    'amount' in event?.data &&\n    typeof event?.data?.amount === 'number'\n  );\n}\n\n/**\n * Type guard for resource consumption events\n */\nexport function isResourceConsumptionEvent(\n  event: ModuleEvent\n): event is ModuleEvent & { data: { resourceType: ResourceType; amount: number } } {\n  return (\n    event?.data !== undefined &&\n    typeof event?.data === 'object' &&\n    event?.data !== null &&\n    'resourceType' in event?.data &&\n    'amount' in event?.data &&\n    typeof event?.data?.amount === 'number'\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/events/rxjsIntegration.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_T' is defined but never used. Allowed unused vars must match /^ignored|^temp/u.","line":135,"column":46,"nodeType":null,"messageId":"unusedVar","endLine":135,"endColumn":48},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_debounceTime' is defined but never used.","line":150,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":150,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_throttleTime' is defined but never used.","line":164,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":164,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_bufferTime' is defined but never used.","line":178,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":178,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Observable, Subject, filter, map, share } from 'rxjs';\nimport { ModuleEvent, ModuleEventType, moduleEventBus } from '../../lib/modules/ModuleEvents';\n\n/**\n * Subject for all module events\n */\nexport const moduleEventSubject = new Subject<ModuleEvent>();\n\n/**\n * Observable for all module events\n */\nexport const moduleEvents$ = moduleEventSubject.asObservable().pipe(\n  share() // Share the observable to prevent multiple subscriptions\n);\n\n/**\n * Initialize the RxJS integration with the moduleEventBus\n */\nexport function initializeRxJSIntegration(): () => void {\n  // Subscribe to all module events and forward them to the subject\n  const unsubscribe = moduleEventBus.subscribe('MODULE_CREATED' as ModuleEventType, event => {\n    moduleEventSubject.next(event);\n  });\n\n  // Return a cleanup function\n  return () => {\n    if (typeof unsubscribe === 'function') {\n      unsubscribe();\n    }\n    moduleEventSubject.complete();\n  };\n}\n\n/**\n * Get an observable for a specific event type\n */\nexport function getEventsByType<T extends ModuleEventType>(eventType: T): Observable<ModuleEvent> {\n  return moduleEvents$.pipe(filter(event => event?.type === eventType));\n}\n\n/**\n * Get an observable for events from a specific module\n */\nexport function getEventsByModule(moduleId: string): Observable<ModuleEvent> {\n  return moduleEvents$.pipe(filter(event => event?.moduleId === moduleId));\n}\n\n/**\n * Get an observable for events with a specific data property\n */\nexport function getEventsByData<T>(\n  propertyName: string,\n  propertyValue: T\n): Observable<ModuleEvent> {\n  return moduleEvents$.pipe(\n    filter((event: ModuleEvent) => {\n      // Check if event?.data exists\n      if (!event?.data) {\n        return false;\n      }\n\n      // Check if the property exists in event?.data\n      if (!(propertyName in (event?.data as Record<string, unknown>))) {\n        return false;\n      }\n\n      // Check if the property value matches\n      return (event?.data as Record<string, unknown>)[propertyName] === propertyValue;\n    })\n  );\n}\n\n/**\n * Get an observable that maps events to their data\n */\nexport function getEventData<T>(eventType: ModuleEventType): Observable<T> {\n  return moduleEvents$.pipe(\n    filter(event => event?.type === eventType),\n    map(event => event?.data as T)\n  );\n}\n\n/**\n * Create a custom event observable with filtering\n */\nexport function createFilteredEventStream(\n  filterFn: (event: ModuleEvent) => boolean\n): Observable<ModuleEvent> {\n  return moduleEvents$.pipe(filter(filterFn));\n}\n\n/**\n * Emit an event through the RxJS subject and moduleEventBus\n */\nexport function emitEvent(event: ModuleEvent): void {\n  // Emit through the moduleEventBus\n  moduleEventBus.emit(event);\n\n  // Also emit through the RxJS subject\n  moduleEventSubject.next(event);\n}\n\n/**\n * Hook up a Subject to a specific event type\n */\nexport function createEventTypeSubject<T extends ModuleEventType>(\n  eventType: T\n): Subject<ModuleEvent> {\n  const subject = new Subject<ModuleEvent>();\n\n  // Subscribe to the event type and forward to the subject\n  const unsubscribe = moduleEventBus.subscribe(eventType, event => {\n    subject.next(event);\n  });\n\n  // Add cleanup method to the subject\n  interface SubjectWithCleanup<T> extends Subject<T> {\n    cleanup?: () => void;\n  }\n\n  const subjectWithCleanup = subject as SubjectWithCleanup<ModuleEvent>;\n  subjectWithCleanup.cleanup = () => {\n    if (typeof unsubscribe === 'function') {\n      unsubscribe();\n    }\n    subject.complete();\n  };\n\n  return subject;\n}\n\n/**\n * Create a specialized event stream with transformation\n */\nexport function createTransformedEventStream<_T, R>(\n  eventType: ModuleEventType,\n  transformFn: (event: ModuleEvent) => R\n): Observable<R> {\n  return moduleEvents$.pipe(\n    filter(event => event?.type === eventType),\n    map(transformFn)\n  );\n}\n\n/**\n * Create a debounced event stream\n */\nexport function createDebouncedEventStream(\n  eventType: ModuleEventType,\n  _debounceTime: number\n): Observable<ModuleEvent> {\n  return moduleEvents$.pipe(\n    filter(event => event?.type === eventType)\n    // We would normally use debounceTime here, but we're keeping it simple\n    // debounceTime(_debounceTime)\n  );\n}\n\n/**\n * Create a throttled event stream\n */\nexport function createThrottledEventStream(\n  eventType: ModuleEventType,\n  _throttleTime: number\n): Observable<ModuleEvent> {\n  return moduleEvents$.pipe(\n    filter(event => event?.type === eventType)\n    // We would normally use throttleTime here, but we're keeping it simple\n    // throttleTime(_throttleTime)\n  );\n}\n\n/**\n * Create a buffered event stream that collects events over time\n */\nexport function createBufferedEventStream(\n  eventType: ModuleEventType,\n  _bufferTime: number\n): Observable<ModuleEvent[]> {\n  return moduleEvents$.pipe(\n    filter(event => event?.type === eventType)\n    // We would normally use bufferTime here, but we're keeping it simple\n    // bufferTime(_bufferTime)\n  ) as unknown as Observable<ModuleEvent[]>;\n}\n\n/**\n * Create a combined event stream from multiple event types\n */\nexport function createCombinedEventStream(eventTypes: ModuleEventType[]): Observable<ModuleEvent> {\n  return moduleEvents$.pipe(filter(event => eventTypes.includes(event?.type)));\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/geometry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/idGenerator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/modules/moduleValidation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/performance/ComponentOptimizer.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'useMemo' is defined but never used. Allowed unused vars must match /^ignored|^temp/u.","line":14,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":41}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @context: ui-system, performance-optimization, component-library\n * \n * ComponentOptimizer - Utilities for optimizing React component performance\n * \n * This module provides specialized utilities for optimizing UI component performance:\n * 1. Enhanced memoization with dependency tracking\n * 2. Virtualization helpers for large lists\n * 3. Performance monitoring utilities\n * 4. Object equality comparison functions for React.memo and useMemo\n */\n\nimport * as React from 'react';\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { ErrorType, ErrorSeverity, errorLoggingService } from '../../services/ErrorLoggingService';\n\n/**\n * Configuration for component memoization\n */\nexport interface MemoizationConfig {\n  /** Name of the component for tracking */\n  componentName: string;\n  \n  /** Whether to track render counts */\n  trackRenders?: boolean;\n  \n  /** Whether to log render performance */\n  logPerformance?: boolean;\n  \n  /** Custom comparison function for props */\n  propsAreEqual?: <T extends Record<string, unknown>>(prevProps: T, nextProps: T) => boolean;\n  \n  /** Threshold in ms for logging slow renders */\n  renderTimeThreshold?: number;\n}\n\n/**\n * Creates an optimized comparison function for React.memo\n * \n * @param config Memoization configuration\n * @returns A function to determine if component should update\n */\nexport function createPropsComparison<T extends Record<string, unknown>>(config: MemoizationConfig) {\n  const { \n    componentName, \n    trackRenders = false, \n    logPerformance = false,\n    renderTimeThreshold = 16, // Default to 16ms (60fps frame budget)\n    propsAreEqual \n  } = config;\n  \n  // Counters for tracking\n  let renderCount = 0;\n  let memoizedRenderCount = 0;\n  \n  return function(prevProps: T, nextProps: T): boolean {\n    const startTime = logPerformance ? performance.now() : 0;\n    renderCount++;\n    \n    // Use custom comparison if provided, otherwise do shallow comparison\n    const areEqual = propsAreEqual \n      ? propsAreEqual(prevProps, nextProps)\n      : Object.keys(nextProps).every(key => {\n          return Object.prototype.hasOwnProperty.call(prevProps, key) && \n                 prevProps[key] === nextProps[key];\n        });\n    \n    if (areEqual) {\n      memoizedRenderCount++;\n    }\n    \n    // Log performance info if enabled\n    if (logPerformance) {\n      const endTime = performance.now();\n      const duration = endTime - startTime;\n      \n      if (duration > renderTimeThreshold) {\n        console.warn(`[ComponentOptimizer] ${componentName} props comparison took ${duration.toFixed(2)}ms, which exceeds the threshold of ${renderTimeThreshold}ms`);\n      }\n      \n      if (trackRenders && renderCount % 10 === 0) {\n        console.warn(`[ComponentOptimizer] ${componentName} - Render count: ${renderCount}, Memoized: ${memoizedRenderCount} (${(memoizedRenderCount/renderCount*100).toFixed(1)}%)`);\n      }\n    }\n    \n    return areEqual;\n  };\n}\n\n/**\n * Hook to track and log component render performance\n * \n * @param componentName Name of the component for tracking\n * @param threshold Threshold in ms to log warning for slow renders\n */\nexport function useRenderPerformance(componentName: string, threshold: number = 16) {\n  const renderCount = useRef(0);\n  const startTimeRef = useRef(0);\n  \n  useEffect(() => {\n    const renderTime = performance.now() - startTimeRef.current;\n    renderCount.current++;\n    \n    if (renderTime > threshold) {\n      console.warn(`[ComponentOptimizer] ${componentName} render #${renderCount.current} took ${renderTime.toFixed(2)}ms, which exceeds the threshold of ${threshold}ms`);\n      \n      // Log to error service for significant performance issues\n      if (renderTime > threshold * 2) {\n        errorLoggingService.logError(\n          new Error(`Slow render detected in ${componentName}`),\n          ErrorType.RUNTIME, // Using RUNTIME since PERFORMANCE is not available in ErrorType\n          ErrorSeverity.LOW,\n          {\n            component: componentName,\n            renderTime,\n            renderCount: renderCount.current,\n            performanceIssue: true // Flag to indicate this is a performance issue\n          }\n        );\n      }\n    }\n  });\n  \n  // Set start time before render\n  startTimeRef.current = performance.now();\n  \n  return renderCount.current;\n}\n\n/**\n * A deep comparison function for React's useMemo and useCallback\n * \n * @param objA First object to compare\n * @param objB Second object to compare\n * @returns Boolean indicating if objects are deeply equal\n */\nexport function deepEqual<T>(objA: T, objB: T): boolean {\n  if (objA === objB) {\n    return true;\n  }\n  \n  if (\n    typeof objA !== 'object' || \n    objA === null || \n    typeof objB !== 'object' || \n    objB === null\n  ) {\n    return false;\n  }\n  \n  const keysA = Object.keys(objA as object);\n  const keysB = Object.keys(objB as object);\n  \n  if (keysA.length !== keysB.length) {\n    return false;\n  }\n  \n  // Test for A's keys different from B\n  for (const key of keysA) {\n    if (!Object.prototype.hasOwnProperty.call(objB, key)) {\n      return false;\n    }\n    \n    if (!deepEqual((objA as Record<string, unknown>)[key], (objB as Record<string, unknown>)[key])) {\n      return false;\n    }\n  }\n  \n  return true;\n}\n\n/**\n * A memoized selector hook similar to reselect but for React components\n * \n * @param dependencies Array of dependencies for the selector\n * @param selector Function that computes a new value from dependencies\n * @param equalityFn Optional custom equality function for comparing results\n * @returns The memoized value\n */\nexport function useMemoizedSelector<T, R>(\n  dependencies: readonly T[],\n  selector: (deps: readonly T[]) => R,\n  equalityFn: (prev: R, next: R) => boolean = (a, b) => a === b\n): R {\n  const prevResultRef = useRef<R | undefined>(undefined);\n  const prevDepsRef = useRef<readonly T[]>([]);\n  \n  // Check if dependencies have changed\n  const depsChanged = dependencies.length !== prevDepsRef.current.length || \n    dependencies.some((dep, i) => dep !== prevDepsRef.current[i]);\n  \n  if (depsChanged) {\n    // Compute new result\n    const newResult = selector(dependencies);\n    \n    // Only update if result is different\n    if (prevResultRef.current === undefined || !equalityFn(prevResultRef.current, newResult)) {\n      prevResultRef.current = newResult;\n    }\n    \n    // Update dependencies\n    prevDepsRef.current = dependencies;\n  }\n  \n  return prevResultRef.current as R;\n}\n\n/**\n * Virtualization configuration for list rendering\n */\nexport interface VirtualizationConfig {\n  /** Total number of items */\n  itemCount: number;\n  \n  /** Height of each item in pixels */\n  itemHeight: number;\n  \n  /** Height of the visible container in pixels */\n  containerHeight: number;\n  \n  /** Additional items to render above and below visible area */\n  overscan?: number;\n}\n\n/**\n * Hook for virtualizing long lists\n * \n * @param config Virtualization configuration\n * @returns Object with start/end indices and scroll handlers\n */\nexport function useVirtualization(config: VirtualizationConfig) {\n  const { \n    itemCount, \n    itemHeight, \n    containerHeight, \n    overscan = 3 \n  } = config;\n  \n  const [scrollTop, setScrollTop] = useState(0);\n  \n  // Calculate visible item indices\n  const visibleItemCount = Math.ceil(containerHeight / itemHeight);\n  const startIndex = Math.max(0, Math.floor(scrollTop / itemHeight) - overscan);\n  const endIndex = Math.min(\n    itemCount - 1, \n    Math.floor(scrollTop / itemHeight) + visibleItemCount + overscan\n  );\n  \n  // Calculate total height to maintain proper scrollbar\n  const totalHeight = itemCount * itemHeight;\n  \n  // Calculate offset for the visible items\n  const offsetY = startIndex * itemHeight;\n  \n  // Handle scroll events\n  const handleScroll = useCallback((e: React.UIEvent<HTMLDivElement>) => {\n    setScrollTop(e.currentTarget.scrollTop);\n  }, []);\n  \n  return {\n    startIndex,\n    endIndex,\n    visibleItemCount,\n    totalHeight,\n    offsetY,\n    handleScroll\n  };\n}\n\n/**\n * Hook for lazy loading heavy components\n * \n * @param factory Factory function that returns the component\n * @param dependencies Dependencies array to control when to reload\n * @returns The lazily loaded component\n */\nexport function useLazyComponent<T>(\n  factory: () => Promise<{ default: React.ComponentType<T> }>,\n  dependencies: readonly unknown[] = []\n) {\n  const [Component, setComponent] = useState<React.ComponentType<T> | null>(null);\n  const [error, setError] = useState<Error | null>(null);\n  const [loading, setLoading] = useState(true);\n  \n  useEffect(() => {\n    let isMounted = true;\n    setLoading(true);\n    \n    factory()\n      .then(module => {\n        if (isMounted) {\n          setComponent(() => module.default);\n          setLoading(false);\n        }\n      })\n      .catch(err => {\n        if (isMounted) {\n          setError(err instanceof Error ? err : new Error(String(err)));\n          setLoading(false);\n          \n          errorLoggingService.logError(\n            err instanceof Error ? err : new Error(String(err)),\n            ErrorType.RESOURCE,\n            ErrorSeverity.MEDIUM,\n            {\n              component: 'useLazyComponent',\n              factory: factory.toString().substring(0, 100)\n            }\n          );\n        }\n      });\n      \n    return () => {\n      isMounted = false;\n    };\n  // We're intentionally only rerunning this effect when the dependencies array changes\n  }, dependencies);\n  \n  return { Component, loading, error };\n} ","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/performance/D3AccessorBenchmark.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/performance/D3AnimationFrameManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'elapsedTime' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":213,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":213,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_callbackDuration' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":315,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":315,"endColumn":32},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_originalTransition' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":980,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":980,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_deltaTime' is defined but never used.","line":985,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":985,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_frameInfo' is defined but never used.","line":985,"column":28,"nodeType":null,"messageId":"unusedVar","endLine":985,"endColumn":38},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_deltaTime' is defined but never used.","line":1025,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":1025,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_frameInfo' is defined but never used.","line":1025,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":1025,"endColumn":37},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_deltaTime' is defined but never used.","line":1083,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":1083,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_frameInfo' is defined but never used.","line":1083,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":1083,"endColumn":37},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'updateAnimation' is defined but never used. Allowed unused vars must match /^ignored|^temp/u.","line":1124,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":1124,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_frameInfo' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":1132,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":1132,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * D3 Animation Frame Manager\n *\n * This module provides a centralized system for efficiently coordinating multiple\n * animations. It optimizes performance by:\n *\n * 1. Batching animations in a single requestAnimationFrame loop\n * 2. Prioritizing animations based on visibility and importance\n * 3. Distributing animation work across frames for complex animations\n * 4. Providing synchronization mechanisms between related animations\n * 5. Managing frame budgets to ensure smooth performance\n */\n\nimport * as d3 from 'd3';\nimport {\n  AnimationConfig,\n  TypedAnimationSequence,\n} from '../../types/visualizations/D3AnimationTypes';\nimport { AnimationPerformanceReport, createAnimationProfiler } from './D3AnimationProfiler';\n\n/**\n * Priority level for animations\n */\nexport type AnimationPriority = 'critical' | 'high' | 'medium' | 'low' | 'background';\n\n/**\n * Status of a registered animation\n */\nexport type AnimationStatus = 'idle' | 'running' | 'paused' | 'completed' | 'error';\n\n/**\n * Visibility state of an animation to determine if it should be updated\n */\nexport type AnimationVisibility = 'visible' | 'partially-visible' | 'hidden';\n\n/**\n * Animation type to help optimize similar animations\n */\nexport type AnimationType = 'transition' | 'simulation' | 'timer' | 'sequence' | 'custom';\n\n/**\n * Configuration for registered animations\n */\nexport interface RegisteredAnimationConfig extends AnimationConfig {\n  /** Unique ID for the animation */\n  id: string;\n  /** User-friendly name for the animation */\n  name: string;\n  /** Priority level determines scheduling order */\n  priority: AnimationPriority;\n  /** Animation type for optimization opportunities */\n  type: AnimationType;\n  /** Whether the animation should continue even when off-screen */\n  runWhenHidden?: boolean;\n  /** Maximum amount of time per frame for this animation (ms) */\n  frameTimeBudget?: number;\n  /** Whether to enable profiling for this animation */\n  enableProfiling?: boolean;\n  /** Callback for animation completion */\n  onComplete?: () => void;\n  /** Synchronization group ID to coordinate related animations */\n  syncGroup?: string;\n}\n\n/**\n * The animation frame callback function signature\n */\nexport type AnimationFrameCallback = (\n  elapsed: number,\n  deltaTime: number,\n  frameInfo: FrameInfo\n) => boolean | void;\n\n/**\n * Information about the current animation frame\n */\nexport interface FrameInfo {\n  /** Frame timestamp */\n  timestamp: number;\n  /** Time elapsed since animation start */\n  elapsed: number;\n  /** Time since last frame */\n  deltaTime: number;\n  /** Current frame number */\n  frameCount: number;\n  /** Duration left in the frame budget (ms) */\n  remainingFrameBudget: number;\n  /** Whether the animation should try to finish critical work this frame */\n  isFrameOverBudget: boolean;\n  /** Current FPS based on recent frames */\n  currentFps: number;\n}\n\n/**\n * Registered animation object\n */\nexport interface RegisteredAnimation {\n  /** Animation configuration */\n  config: RegisteredAnimationConfig;\n  /** Frame callback function */\n  callback: AnimationFrameCallback;\n  /** Current animation status */\n  status: AnimationStatus;\n  /** Current visibility state */\n  visibility: AnimationVisibility;\n  /** Start time of the animation */\n  startTime: number;\n  /** Last frame timestamp */\n  lastFrameTime: number;\n  /** Elapsed time since start */\n  elapsedTime: number;\n  /** Elapsed time when paused (to resume from) */\n  pausedElapsedTime?: number;\n  /** Pause start timestamp */\n  pauseStartTime?: number;\n  /** Current frame number */\n  frameCount: number;\n  /** Animation-specific data storage */\n  data?: Record<string, unknown>;\n  /** Performance profiling data if enabled */\n  profilingData?: {\n    /** Animation profiler if enabled */\n    profiler: ReturnType<typeof createAnimationProfiler>;\n    /** Animation performance report if available */\n    report?: AnimationPerformanceReport;\n  };\n}\n\n/**\n * Configuration for the animation frame manager\n */\nexport interface AnimationFrameManagerConfig {\n  /** Target frames per second */\n  targetFps?: number;\n  /** Frame budget in milliseconds (defaults to 16ms for 60fps) */\n  frameBudget?: number;\n  /** Whether to enable auto-pausing of hidden animations */\n  autoPauseHidden?: boolean;\n  /** Maximum animations to process per frame */\n  maxAnimationsPerFrame?: number;\n  /** Whether to enable performance profiling */\n  enableProfiling?: boolean;\n  /** Whether to automatically cancel long-running animations */\n  autoCancelLongRunning?: boolean;\n  /** Time threshold for long-running animations in ms */\n  longRunningThreshold?: number;\n  /** Whether to log diagnostic information to console */\n  debugMode?: boolean;\n}\n\n/**\n * Creates a centralized animation frame manager for coordinating multiple animations\n *\n * @param config Configuration options for the manager\n * @returns Animation frame manager API\n */\nexport function createAnimationFrameManager(config: AnimationFrameManagerConfig = {}) {\n  // Configuration with defaults\n  const {\n    targetFps = 60,\n    frameBudget = (1000 / targetFps) * 0.8, // 80% of frame time\n    autoPauseHidden = true,\n    maxAnimationsPerFrame = 0, // 0 means no limit\n    enableProfiling = false,\n    autoCancelLongRunning = false,\n    longRunningThreshold = 30000, // 30 seconds\n    debugMode = false,\n  } = config;\n\n  // Internal state\n  const animations = new Map<string, RegisteredAnimation>();\n  const syncGroups = new Map<string, Set<string>>();\n  let isRunning = false;\n  let lastFrameTimestamp = 0;\n  let rafId: number | null = null;\n  let frameCount = 0;\n  let frameTimes: number[] = [];\n  let startTime = 0;\n\n  // FPS tracking (last 60 frames)\n  const fpsBufferSize = 60;\n  const fpsBuffer: number[] = Array(fpsBufferSize).fill(0);\n  let fpsBufferIndex = 0;\n  let currentFps = targetFps;\n\n  /**\n   * Update FPS calculation with the latest frame time\n   *\n   * @param deltaTime Time since last frame in ms\n   */\n  function updateFps(deltaTime: number) {\n    // Add latest frame time to buffer\n    fpsBuffer[fpsBufferIndex] = deltaTime > 0 ? 1000 / deltaTime : 0;\n    fpsBufferIndex = (fpsBufferIndex + 1) % fpsBufferSize;\n\n    // Calculate average FPS from buffer, ignoring zeros\n    const validFrames = fpsBuffer.filter(fps => fps > 0);\n    currentFps =\n      validFrames.length > 0\n        ? validFrames.reduce((sum, fps) => sum + fps, 0) / validFrames.length\n        : targetFps;\n  }\n\n  /**\n   * Main animation frame loop\n   *\n   * @param timestamp Current frame timestamp\n   */\n  function animationFrame(timestamp: number) {\n    // Calculate timing information\n    const deltaTime = lastFrameTimestamp ? timestamp - lastFrameTimestamp : 0;\n    lastFrameTimestamp = timestamp;\n    const elapsedTime = timestamp - startTime;\n\n    // Update FPS tracking\n    updateFps(deltaTime);\n    frameCount++;\n\n    // Update frame timing history (keep last 10 frames)\n    frameTimes.push(deltaTime);\n    if (frameTimes.length > 10) {\n      frameTimes.shift();\n    }\n\n    // Process animations in priority order\n    const frameStartTime = performance.now();\n    let frameTimeBudgetRemaining = frameBudget;\n    let animationsProcessed = 0;\n\n    // Sort animations by priority\n    const sortedAnimations = Array.from(animations.values())\n      .filter(anim => anim.status === 'running')\n      .sort((a, b) => {\n        // Order by priority first\n        const priorityOrder = {\n          critical: 0,\n          high: 1,\n          medium: 2,\n          low: 3,\n          background: 4,\n        };\n\n        const priorityDiff = priorityOrder[a.config.priority] - priorityOrder[b.config.priority];\n        if (priorityDiff !== 0) return priorityDiff;\n\n        // Then by visibility\n        const visibilityOrder = {\n          visible: 0,\n          'partially-visible': 1,\n          hidden: 2,\n        };\n\n        return visibilityOrder[a.visibility] - visibilityOrder[b.visibility];\n      });\n\n    // Process each animation\n    for (const animation of sortedAnimations) {\n      // Skip if we've reached the per-frame animation limit\n      if (maxAnimationsPerFrame > 0 && animationsProcessed >= maxAnimationsPerFrame) {\n        if (debugMode) {\n          console.warn(\n            `Animation frame manager: Reached max animations per frame (${maxAnimationsPerFrame})`\n          );\n        }\n        break;\n      }\n\n      // Skip hidden animations if configured to do so\n      if (autoPauseHidden && animation.visibility === 'hidden' && !animation.config.runWhenHidden) {\n        continue;\n      }\n\n      // Check if we have time remaining in the frame budget\n      const now = performance.now();\n      const timeElapsed = now - frameStartTime;\n      frameTimeBudgetRemaining = Math.max(0, frameBudget - timeElapsed);\n\n      // Skip if we're out of time\n      if (frameTimeBudgetRemaining <= 0) {\n        if (debugMode) {\n          console.warn(\n            `Animation frame manager: Frame budget exhausted, skipping remaining animations`\n          );\n        }\n        break;\n      }\n\n      // Prepare frame info\n      const _deltaTime = timestamp - animation.lastFrameTime;\n      const _frameInfo = {\n        timestamp,\n        elapsed: animation.elapsedTime,\n        deltaTime: _deltaTime,\n        frameCount: animation.frameCount,\n        remainingFrameBudget: frameTimeBudgetRemaining,\n        isFrameOverBudget:\n          frameTimeBudgetRemaining < (animation.config.frameTimeBudget || frameBudget * 0.2),\n        currentFps,\n      };\n\n      // Update animation timing info\n      animation.lastFrameTime = timestamp;\n      animation.elapsedTime = timestamp - animation.startTime;\n      animation.frameCount++;\n\n      // Record frame for profiling if enabled\n      if (animation.config.enableProfiling && animation.profilingData?.profiler) {\n        animation.profilingData.profiler.recordFrame();\n      }\n\n      try {\n        // Execute animation callback\n        const callbackStart = performance.now();\n        const result = animation.callback(animation.elapsedTime, _deltaTime, _frameInfo);\n        const _callbackDuration = performance.now() - callbackStart;\n\n        // Handle result (return true to stop the animation)\n        if (result === true) {\n          completeAnimation(animation.config.id);\n        }\n\n        // Auto-cancel long-running animations if enabled\n        if (\n          autoCancelLongRunning &&\n          animation.elapsedTime > longRunningThreshold &&\n          !animation.config.loop\n        ) {\n          if (debugMode) {\n            console.warn(\n              `Animation frame manager: Auto-cancelling long-running animation ${animation.config.id}`\n            );\n          }\n          completeAnimation(animation.config.id);\n        }\n      } catch (error) {\n        console.error(`Error in animation ${animation.config.id}:`, error);\n        animation.status = 'error';\n      }\n\n      animationsProcessed++;\n    }\n\n    // Continue the animation loop if we have active animations\n    if (animations.size > 0 && hasRunningAnimations()) {\n      rafId = requestAnimationFrame(animationFrame);\n    } else {\n      stopAnimationLoop();\n    }\n  }\n\n  /**\n   * Check if there are any running animations\n   */\n  function hasRunningAnimations(): boolean {\n    return Array.from(animations.values()).some(anim => anim.status === 'running');\n  }\n\n  /**\n   * Start the animation frame loop\n   */\n  function startAnimationLoop() {\n    if (isRunning) return;\n\n    isRunning = true;\n    startTime = performance.now();\n    lastFrameTimestamp = 0;\n    frameCount = 0;\n    frameTimes = [];\n\n    if (debugMode) {\n      console.warn('Animation frame manager: Starting animation loop');\n    }\n\n    rafId = requestAnimationFrame(animationFrame);\n  }\n\n  /**\n   * Stop the animation frame loop\n   */\n  function stopAnimationLoop() {\n    if (!isRunning) return;\n\n    isRunning = false;\n\n    if (rafId !== null) {\n      cancelAnimationFrame(rafId);\n      rafId = null;\n    }\n\n    if (debugMode) {\n      console.warn('Animation frame manager: Stopping animation loop');\n    }\n  }\n\n  /**\n   * Register a new animation with the frame manager\n   *\n   * @param config Animation configuration\n   * @param callback Animation frame callback function\n   * @returns Animation ID\n   */\n  function registerAnimation(\n    config: Omit<RegisteredAnimationConfig, 'id'> & { id?: string },\n    callback: AnimationFrameCallback\n  ): string {\n    // Generate ID if not provided\n    const id = config.id || `animation-${Date.now()}-${Math.floor(Math.random() * 10000)}`;\n\n    // Create full configuration with defaults\n    const fullConfig: RegisteredAnimationConfig = {\n      id,\n      name: config.name || `Animation ${id}`,\n      priority: config.priority || 'medium',\n      type: config.type || 'custom',\n      duration: config.duration || 1000,\n      easing: config.easing,\n      loop: config.loop || false,\n      runWhenHidden: config.runWhenHidden || false,\n      frameTimeBudget: config.frameTimeBudget || frameBudget * 0.5,\n      enableProfiling: config.enableProfiling || enableProfiling,\n      onComplete: config.onComplete,\n      syncGroup: config.syncGroup,\n    };\n\n    // Create animation entry\n    const animation: RegisteredAnimation = {\n      config: fullConfig,\n      callback,\n      status: 'idle',\n      visibility: 'visible',\n      startTime: 0,\n      lastFrameTime: 0,\n      elapsedTime: 0,\n      frameCount: 0,\n    };\n\n    // Set up profiling if enabled\n    if (fullConfig.enableProfiling) {\n      animation.profilingData = {\n        profiler: createAnimationProfiler({\n          targetFps,\n          detailedMetrics: true,\n        }),\n      };\n    }\n\n    // Add to sync group if specified\n    if (fullConfig.syncGroup) {\n      let group = syncGroups.get(fullConfig.syncGroup);\n      if (!group) {\n        group = new Set<string>();\n        syncGroups.set(fullConfig.syncGroup, group);\n      }\n      group.add(id);\n    }\n\n    // Store the animation\n    animations.set(id, animation);\n\n    if (debugMode) {\n      console.warn(`Animation frame manager: Registered animation ${id} (${fullConfig.name})`);\n    }\n\n    return id;\n  }\n\n  /**\n   * Start a registered animation\n   *\n   * @param id Animation ID\n   * @param resetTime Whether to reset the animation time\n   */\n  function startAnimation(id: string, resetTime = true): void {\n    const animation = animations.get(id);\n    if (!animation) {\n      if (debugMode) {\n        console.warn(`Animation frame manager: Cannot start animation ${id} - not found`);\n      }\n      return;\n    }\n\n    // Reset or resume timing\n    const now = performance.now();\n    if (resetTime) {\n      animation.startTime = now;\n      animation.lastFrameTime = now;\n      animation.elapsedTime = 0;\n      animation.frameCount = 0;\n    } else if (animation.status === 'paused' && animation.pausedElapsedTime !== undefined) {\n      // Resume from pause - adjust start time to maintain elapsed time\n      animation.startTime = now - animation.pausedElapsedTime;\n      animation.lastFrameTime = now;\n    }\n\n    animation.status = 'running';\n\n    // Reset pause tracking\n    animation.pausedElapsedTime = undefined;\n    animation.pauseStartTime = undefined;\n\n    // Start profiling if enabled\n    if (animation.config.enableProfiling && animation.profilingData?.profiler) {\n      animation.profilingData.profiler.start(\n        animation.config.id,\n        animation.config.name,\n        animation.config\n      );\n    }\n\n    if (debugMode) {\n      console.warn(`Animation frame manager: Started animation ${id} (${animation.config.name})`);\n    }\n\n    // Start the animation loop if needed\n    if (!isRunning) {\n      startAnimationLoop();\n    }\n  }\n\n  /**\n   * Pause a running animation\n   *\n   * @param id Animation ID\n   */\n  function pauseAnimation(id: string): void {\n    const animation = animations.get(id);\n    if (!animation || animation.status !== 'running') {\n      return;\n    }\n\n    animation.status = 'paused';\n    animation.pausedElapsedTime = animation.elapsedTime;\n    animation.pauseStartTime = performance.now();\n\n    if (debugMode) {\n      console.warn(`Animation frame manager: Paused animation ${id} (${animation.config.name})`);\n    }\n  }\n\n  /**\n   * Resume a paused animation\n   *\n   * @param id Animation ID\n   */\n  function resumeAnimation(id: string): void {\n    const animation = animations.get(id);\n    if (!animation || animation.status !== 'paused') {\n      return;\n    }\n\n    startAnimation(id, false);\n\n    if (debugMode) {\n      console.warn(`Animation frame manager: Resumed animation ${id} (${animation.config.name})`);\n    }\n  }\n\n  /**\n   * Stop and complete an animation\n   *\n   * @param id Animation ID\n   */\n  function completeAnimation(id: string): void {\n    const animation = animations.get(id);\n    if (!animation) {\n      return;\n    }\n\n    animation.status = 'completed';\n\n    // Generate final profiling report if enabled\n    if (animation.config.enableProfiling && animation.profilingData?.profiler) {\n      animation.profilingData.report = animation.profilingData.profiler.stop();\n    }\n\n    // Call completion handler if provided\n    if (animation.config.onComplete) {\n      try {\n        animation.config.onComplete();\n      } catch (error) {\n        console.error(`Error in animation completion handler for ${id}:`, error);\n      }\n    }\n\n    if (debugMode) {\n      console.warn(`Animation frame manager: Completed animation ${id} (${animation.config.name})`);\n    }\n  }\n\n  /**\n   * Cancel an animation without completing it\n   *\n   * @param id Animation ID\n   */\n  function cancelAnimation(id: string): void {\n    const animation = animations.get(id);\n    if (!animation) {\n      return;\n    }\n\n    // Stop profiling if active\n    if (\n      animation.config.enableProfiling &&\n      animation.profilingData?.profiler &&\n      animation.profilingData.profiler.getStatus().isRunning\n    ) {\n      animation.profilingData.report = animation.profilingData.profiler.stop();\n    }\n\n    animations.delete(id);\n\n    // Remove from sync group if needed\n    if (animation.config.syncGroup) {\n      const group = syncGroups.get(animation.config.syncGroup);\n      if (group) {\n        group.delete(id);\n        if (group.size === 0) {\n          syncGroups.delete(animation.config.syncGroup);\n        }\n      }\n    }\n\n    if (debugMode) {\n      console.warn(`Animation frame manager: Cancelled animation ${id} (${animation.config.name})`);\n    }\n  }\n\n  /**\n   * Update the visibility state of an animation\n   *\n   * @param id Animation ID\n   * @param visibility New visibility state\n   */\n  function updateVisibility(id: string, visibility: AnimationVisibility): void {\n    const animation = animations.get(id);\n    if (!animation) {\n      return;\n    }\n\n    const oldVisibility = animation.visibility;\n    animation.visibility = visibility;\n\n    // Auto-pause/resume based on visibility if enabled\n    if (autoPauseHidden && !animation.config.runWhenHidden) {\n      if (visibility === 'hidden' && animation.status === 'running') {\n        pauseAnimation(id);\n      } else if (\n        visibility !== 'hidden' &&\n        oldVisibility === 'hidden' &&\n        animation.status === 'paused'\n      ) {\n        resumeAnimation(id);\n      }\n    }\n\n    if (debugMode) {\n      console.warn(`Animation frame manager: Updated visibility for ${id} to ${visibility}`);\n    }\n  }\n\n  /**\n   * Update the priority of an animation\n   *\n   * @param id Animation ID\n   * @param priority New priority level\n   */\n  function updatePriority(id: string, priority: AnimationPriority): void {\n    const animation = animations.get(id);\n    if (!animation) {\n      return;\n    }\n\n    animation.config.priority = priority;\n\n    if (debugMode) {\n      console.warn(`Animation frame manager: Updated priority for ${id} to ${priority}`);\n    }\n  }\n\n  /**\n   * Synchronize multiple animations in the same group\n   *\n   * @param groupId Synchronization group ID\n   * @param action Action to perform on all animations in the group\n   */\n  function syncAnimations(\n    groupId: string,\n    action: 'start' | 'pause' | 'resume' | 'complete' | 'cancel'\n  ): void {\n    const group = syncGroups.get(groupId);\n    if (!group || group.size === 0) {\n      return;\n    }\n\n    for (const animationId of group) {\n      switch (action) {\n        case 'start':\n          startAnimation(animationId);\n          break;\n        case 'pause':\n          pauseAnimation(animationId);\n          break;\n        case 'resume':\n          resumeAnimation(animationId);\n          break;\n        case 'complete':\n          completeAnimation(animationId);\n          break;\n        case 'cancel':\n          cancelAnimation(animationId);\n          break;\n      }\n    }\n\n    if (debugMode) {\n      console.warn(`Animation frame manager: Synchronized group ${groupId} with action ${action}`);\n    }\n  }\n\n  /**\n   * Get performance metrics for an animation\n   *\n   * @param id Animation ID\n   * @returns Performance report if available\n   */\n  function getPerformanceReport(id: string): AnimationPerformanceReport | undefined {\n    const animation = animations.get(id);\n    if (!animation || !animation.profilingData) {\n      return undefined;\n    }\n\n    // If animation is still running, get current report\n    if (\n      animation.status === 'running' &&\n      animation.profilingData.profiler &&\n      animation.profilingData.profiler.getStatus().isRunning\n    ) {\n      return animation.profilingData.profiler.stop();\n    }\n\n    return animation.profilingData.report;\n  }\n\n  /**\n   * Get the current status of the animation frame manager\n   */\n  function getStatus() {\n    return {\n      isRunning,\n      animationCount: animations.size,\n      runningAnimations: Array.from(animations.values()).filter(a => a.status === 'running').length,\n      frameCount,\n      currentFps,\n      syncGroups: syncGroups.size,\n      averageFrameTime:\n        frameTimes.length > 0\n          ? frameTimes.reduce((sum, time) => sum + time, 0) / frameTimes.length\n          : 0,\n    };\n  }\n\n  /**\n   * Get all registered animations\n   */\n  function getAnimations() {\n    return Array.from(animations.entries()).map(([id, anim]) => ({\n      id,\n      name: anim.config.name,\n      status: anim.status,\n      priority: anim.config.priority,\n      visibility: anim.visibility,\n      type: anim.config.type,\n      elapsedTime: anim.elapsedTime,\n      frameCount: anim.frameCount,\n    }));\n  }\n\n  /**\n   * Check whether an animation is visible in the viewport\n   *\n   * @param element Element to check visibility for\n   * @returns Visibility state based on element position\n   */\n  function checkElementVisibility(element: Element): AnimationVisibility {\n    if (!element) {\n      return 'hidden';\n    }\n\n    // Use IntersectionObserver API if available\n    if ('IntersectionObserver' in window) {\n      // This is a simplified version - in practice, you would set up and maintain\n      // observers for elements. For now, we'll use getBoundingClientRect as a fallback.\n    }\n\n    // Fallback to getBoundingClientRect\n    const rect = element.getBoundingClientRect();\n    const windowHeight = window.innerHeight || document.documentElement.clientHeight;\n    const windowWidth = window.innerWidth || document.documentElement.clientWidth;\n\n    // Check if completely visible\n    if (\n      rect.top >= 0 &&\n      rect.left >= 0 &&\n      rect.bottom <= windowHeight &&\n      rect.right <= windowWidth\n    ) {\n      return 'visible';\n    }\n\n    // Check if partially visible\n    if (\n      rect.top <= windowHeight &&\n      rect.bottom >= 0 &&\n      rect.left <= windowWidth &&\n      rect.right >= 0\n    ) {\n      return 'partially-visible';\n    }\n\n    // Not visible at all\n    return 'hidden';\n  }\n\n  /**\n   * Create a utility that automatically updates animation visibility based on element visibility\n   *\n   * @param animationId Animation ID\n   * @param element Element to track\n   * @param options Configuration options\n   * @returns Cleanup function\n   */\n  function createVisibilityTracker(\n    animationId: string,\n    element: Element,\n    options: {\n      checkInterval?: number; // How often to check visibility (ms)\n      autoStartWhenVisible?: boolean; // Whether to auto-start the animation when visible\n      autoPauseWhenHidden?: boolean; // Whether to auto-pause when hidden\n    } = {}\n  ): () => void {\n    const {\n      checkInterval = 500,\n      autoStartWhenVisible = false,\n      autoPauseWhenHidden = true,\n    } = options;\n\n    // Initial visibility check\n    let currentVisibility = checkElementVisibility(element);\n    updateVisibility(animationId, currentVisibility);\n\n    // Set up interval to check visibility\n    const intervalId = setInterval(() => {\n      const newVisibility = checkElementVisibility(element);\n\n      // Only update if visibility changed\n      if (newVisibility !== currentVisibility) {\n        currentVisibility = newVisibility;\n        updateVisibility(animationId, newVisibility);\n\n        // Handle auto-start/pause if configured\n        const animation = animations.get(animationId);\n        if (!animation) return;\n\n        if (\n          autoStartWhenVisible &&\n          (newVisibility === 'visible' || newVisibility === 'partially-visible') &&\n          animation.status === 'idle'\n        ) {\n          startAnimation(animationId);\n        } else if (\n          autoPauseWhenHidden &&\n          newVisibility === 'hidden' &&\n          animation.status === 'running'\n        ) {\n          pauseAnimation(animationId);\n        } else if (\n          autoStartWhenVisible &&\n          (newVisibility === 'visible' || newVisibility === 'partially-visible') &&\n          animation.status === 'paused'\n        ) {\n          resumeAnimation(animationId);\n        }\n      }\n    }, checkInterval);\n\n    // Return cleanup function\n    return () => {\n      clearInterval(intervalId);\n    };\n  }\n\n  /**\n   * Create animation synchronization utility that keeps animations in sync\n   * even when some are paused or resumed at different times\n   *\n   * @param animationIds Animation IDs to synchronize\n   * @returns Synchronized animation control functions\n   */\n  function createSynchronizedAnimations(animationIds: string[]) {\n    // Generate a unique sync group ID\n    const syncGroupId = `sync-group-${Date.now()}-${Math.floor(Math.random() * 10000)}`;\n\n    // Update all animations to use this sync group\n    animationIds.forEach(id => {\n      const animation = animations.get(id);\n      if (animation) {\n        animation.config.syncGroup = syncGroupId;\n\n        // Add to sync group\n        let group = syncGroups.get(syncGroupId);\n        if (!group) {\n          group = new Set<string>();\n          syncGroups.set(syncGroupId, group);\n        }\n        group.add(id);\n      }\n    });\n\n    // Return control functions that operate on the whole group\n    return {\n      startAll: () => syncAnimations(syncGroupId, 'start'),\n      pauseAll: () => syncAnimations(syncGroupId, 'pause'),\n      resumeAll: () => syncAnimations(syncGroupId, 'resume'),\n      completeAll: () => syncAnimations(syncGroupId, 'complete'),\n      cancelAll: () => syncAnimations(syncGroupId, 'cancel'),\n      getSyncGroupId: () => syncGroupId,\n    };\n  }\n\n  // Return the public API\n  return {\n    registerAnimation,\n    startAnimation,\n    pauseAnimation,\n    resumeAnimation,\n    completeAnimation,\n    cancelAnimation,\n    updateVisibility,\n    updatePriority,\n    getPerformanceReport,\n    getStatus,\n    getAnimations,\n    checkElementVisibility,\n    createVisibilityTracker,\n    createSynchronizedAnimations,\n\n    // Direct sync group management\n    syncAnimations,\n  };\n}\n\n/**\n * Singleton instance for simple usage\n */\nexport const animationFrameManager = createAnimationFrameManager();\n\n/**\n * Helper to register a D3 transition with the animation frame manager\n *\n * @param selection D3 selection to animate\n * @param config Animation configuration\n * @returns Animation ID and the selection\n */\nexport function registerD3Transition<\n  GElement extends Element,\n  Datum,\n  PElement extends Element,\n  PDatum,\n>(\n  selection: d3.Selection<GElement, Datum, PElement, PDatum>,\n  config: Omit<RegisteredAnimationConfig, 'id' | 'type'> & { id?: string }\n): { id: string; selection: d3.Selection<GElement, Datum, PElement, PDatum> } {\n  // Create complete configuration\n  const fullConfig: Omit<RegisteredAnimationConfig, 'id'> & { id?: string } = {\n    ...config,\n    type: 'transition',\n  };\n\n  // Store original transition method\n  const _originalTransition = selection.transition;\n\n  // Register animation with frame manager\n  const id = animationFrameManager.registerAnimation(\n    fullConfig,\n    (_elapsed, _deltaTime, _frameInfo) => {\n      // Calculate progress based on elapsed time\n      const duration = fullConfig.duration || 1000;\n      const progress = Math.min(1, _elapsed / duration);\n\n      // Check if animation is complete\n      if (progress >= 1 && !fullConfig.loop) {\n        return true; // Complete the animation\n      }\n\n      return false;\n    }\n  );\n\n  // Start the animation\n  animationFrameManager.startAnimation(id);\n\n  return { id, selection };\n}\n\n/**\n * Helper to register a D3 timer animation with the frame manager\n *\n * @param callback D3 timer callback\n * @param config Animation configuration\n * @returns Animation ID and stop function\n */\nexport function registerD3Timer(\n  callback: (elapsed: number) => boolean | void,\n  config: Omit<RegisteredAnimationConfig, 'id' | 'type'> & { id?: string }\n): { id: string; stop: () => void } {\n  // Create complete configuration\n  const fullConfig: Omit<RegisteredAnimationConfig, 'id'> & { id?: string } = {\n    ...config,\n    type: 'timer',\n  };\n\n  // Register animation with frame manager\n  const id = animationFrameManager.registerAnimation(\n    fullConfig,\n    (elapsed, _deltaTime, _frameInfo) => {\n      // Call the original callback\n      const result = callback(elapsed);\n\n      // Check if animation should complete\n      if (\n        result === true ||\n        (fullConfig.duration && elapsed >= fullConfig.duration && !fullConfig.loop)\n      ) {\n        return true; // Complete the animation\n      }\n\n      return false;\n    }\n  );\n\n  // Start the animation\n  animationFrameManager.startAnimation(id);\n\n  // Return the ID and a stop function\n  return {\n    id,\n    stop: () => animationFrameManager.cancelAnimation(id),\n  };\n}\n\n/**\n * Register a TypedAnimationSequence with the frame manager for optimal performance\n *\n * @param sequence Animation sequence to register\n * @param config Animation configuration\n * @returns Animation ID and sequence controller\n */\nexport function registerAnimationSequence<\n  GElement extends Element,\n  Datum,\n  PElement extends Element,\n  PDatum,\n>(\n  sequence: TypedAnimationSequence<GElement, Datum, PElement, PDatum>,\n  config: Omit<RegisteredAnimationConfig, 'id' | 'type'> & { id?: string }\n): {\n  id: string;\n  controller: { start: () => void; stop: () => void; pause: () => void; resume: () => void };\n} {\n  // Store original sequence methods to intercept them\n  const _originalStart = sequence.start;\n  const _originalStop = sequence.stop;\n\n  // Create complete configuration\n  const fullConfig: Omit<RegisteredAnimationConfig, 'id'> & { id?: string } = {\n    ...config,\n    type: 'sequence',\n  };\n\n  // Register animation with frame manager\n  const id = animationFrameManager.registerAnimation(\n    fullConfig,\n    (elapsed, _deltaTime, _frameInfo) => {\n      // Check if sequence is complete based on its configuration\n      // Since we don't have direct access to sequence's internal state,\n      // we rely on the manager to handle timing\n      const duration = fullConfig.duration || 1000;\n\n      if (elapsed >= duration && !fullConfig.loop) {\n        return true; // Complete the animation\n      }\n\n      return false;\n    }\n  );\n\n  // Create controller\n  const controller = {\n    start: () => {\n      // Start in frame manager\n      animationFrameManager.startAnimation(id);\n      // Start the actual sequence\n      _originalStart.call(sequence);\n    },\n    stop: () => {\n      // Stop in frame manager\n      animationFrameManager.cancelAnimation(id);\n      // Stop the actual sequence\n      _originalStop.call(sequence);\n    },\n    pause: () => {\n      animationFrameManager.pauseAnimation(id);\n      // Note: TypedAnimationSequence doesn't have pause method by default\n    },\n    resume: () => {\n      animationFrameManager.resumeAnimation(id);\n      // Note: TypedAnimationSequence doesn't have resume method by default\n    },\n  };\n\n  return { id, controller };\n}\n\nfunction updateAnimation(\n  animation: RegisteredAnimation,\n  timestamp: number,\n  deltaTime: number,\n  frameInfo: FrameInfo\n): void {\n  // ... existing code ...\n  const _deltaTime = timestamp - animation.lastFrameTime;\n  const _frameInfo = {\n    timestamp,\n    elapsed: animation.elapsedTime,\n    deltaTime: _deltaTime,\n    frameCount: animation.frameCount,\n    remainingFrameBudget: frameInfo.remainingFrameBudget,\n    isFrameOverBudget: frameInfo.isFrameOverBudget,\n    currentFps: frameInfo.currentFps,\n  };\n  // ... existing code ...\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/performance/D3AnimationProfiler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/performance/D3AnimationQualityManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sum' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":427,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":427,"endColumn":10}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * D3 Animation Quality Manager\n *\n * This module provides a system for dynamically adjusting animation quality based on\n * device performance capabilities. It detects device performance characteristics and\n * automatically adjusts visualization complexity to maintain smooth animation experiences.\n *\n * Key features:\n * 1. Performance detection and categorization\n * 2. Quality presets for different device capabilities\n * 3. Dynamic quality adjustment based on real-time FPS\n * 4. Integration with existing animation systems\n * 5. User preference overrides\n */\n\nimport * as d3 from 'd3';\nimport * as React from 'react';\n\n/**\n * Performance tier categorization\n */\nexport type PerformanceTier = 'ultra' | 'high' | 'medium' | 'low' | 'minimal';\n\n/**\n * Quality settings that can be adjusted\n */\nexport interface QualitySettings {\n  /** Maximum number of animated elements */\n  maxElementCount: number;\n\n  /** Target frames per second */\n  targetFps: number;\n\n  /** Animation smoothness (1 = every frame, 2 = every other frame, etc.) */\n  animationStepFactor: number;\n\n  /** Visual complexity level (0-1) affecting details like shadows, gradients */\n  visualComplexity: number;\n\n  /** Whether to use WebGL acceleration when available */\n  useWebGLWhenAvailable: boolean;\n\n  /** Number of intermediate animation steps */\n  interpolationSteps: number;\n\n  /** Whether to use physics simulation */\n  enablePhysics: boolean;\n\n  /** Physics simulation detail level */\n  physicsDetail: number;\n\n  /** Whether to enable visual effects */\n  enableEffects: boolean;\n\n  /** Whether to enable batching for DOM operations */\n  enableBatching: boolean;\n\n  /** Whether to enable animation memoization */\n  enableMemoization: boolean;\n\n  /** Whether transitions should follow precise timing */\n  preciseTiming: boolean;\n}\n\n/**\n * Device capability information\n */\nexport interface DeviceCapabilities {\n  /** CPU benchmark score */\n  cpuScore: number;\n\n  /** GPU benchmark score */\n  gpuScore: number;\n\n  /** Memory available (approximation) */\n  memoryScore: number;\n\n  /** Connection speed category */\n  connectionType: 'slow' | 'medium' | 'fast' | 'unknown';\n\n  /** Whether the device is a mobile device */\n  isMobile: boolean;\n\n  /** Whether the device supports WebGL */\n  hasWebGL: boolean;\n\n  /** Whether the device is in battery saving mode */\n  isBatterySaving: boolean;\n\n  /** Screen resolution category */\n  screenCategory: 'low' | 'medium' | 'high' | 'ultra';\n\n  /** Browser performance capability */\n  browserPerformance: 'low' | 'medium' | 'high';\n}\n\n/**\n * Quality management configuration\n */\nexport interface QualityManagerConfig {\n  /** Whether to enable automatic quality adjustment */\n  enableAutoAdjustment?: boolean;\n\n  /** Minimum acceptable FPS before reducing quality */\n  minAcceptableFps?: number;\n\n  /** How often to check performance (ms) */\n  performanceCheckInterval?: number;\n\n  /** How quickly to adjust quality (0-1, higher = faster) */\n  adjustmentResponsiveness?: number;\n\n  /** Whether to respect prefers-reduced-motion */\n  respectPrefersReducedMotion?: boolean;\n\n  /** Whether to respect battery saving modes */\n  respectBatterySaving?: boolean;\n\n  /** Whether to save quality settings to local storage */\n  persistSettings?: boolean;\n\n  /** Initial quality tier override */\n  initialQualityTier?: PerformanceTier;\n\n  /** Maximum allowed elements regardless of performance */\n  absoluteMaxElementCount?: number;\n\n  /** Debug mode */\n  debugMode?: boolean;\n}\n\n/**\n * Performance monitoring state\n */\ninterface PerformanceState {\n  currentFps: number;\n  fpsHistory: number[];\n  lastAdjustmentTime: number;\n  adjustmentCount: number;\n  currentTier: PerformanceTier;\n  detectedCapabilities: DeviceCapabilities;\n  isInitialized: boolean;\n  isAdjusting: boolean;\n}\n\n/**\n * Animation quality manager for D3 visualizations\n */\nexport class D3AnimationQualityManager {\n  /** Default quality presets for each performance tier */\n  private qualityPresets: Record<PerformanceTier, QualitySettings> = {\n    ultra: {\n      maxElementCount: 10000,\n      targetFps: 60,\n      animationStepFactor: 1,\n      visualComplexity: 1.0,\n      useWebGLWhenAvailable: true,\n      interpolationSteps: 60,\n      enablePhysics: true,\n      physicsDetail: 1.0,\n      enableEffects: true,\n      enableBatching: true,\n      enableMemoization: true,\n      preciseTiming: true,\n    },\n    high: {\n      maxElementCount: 5000,\n      targetFps: 60,\n      animationStepFactor: 1,\n      visualComplexity: 0.8,\n      useWebGLWhenAvailable: true,\n      interpolationSteps: 45,\n      enablePhysics: true,\n      physicsDetail: 0.8,\n      enableEffects: true,\n      enableBatching: true,\n      enableMemoization: true,\n      preciseTiming: true,\n    },\n    medium: {\n      maxElementCount: 2000,\n      targetFps: 40,\n      animationStepFactor: 2,\n      visualComplexity: 0.6,\n      useWebGLWhenAvailable: true,\n      interpolationSteps: 30,\n      enablePhysics: true,\n      physicsDetail: 0.5,\n      enableEffects: false,\n      enableBatching: true,\n      enableMemoization: true,\n      preciseTiming: false,\n    },\n    low: {\n      maxElementCount: 1000,\n      targetFps: 30,\n      animationStepFactor: 2,\n      visualComplexity: 0.4,\n      useWebGLWhenAvailable: true,\n      interpolationSteps: 20,\n      enablePhysics: false,\n      physicsDetail: 0.3,\n      enableEffects: false,\n      enableBatching: true,\n      enableMemoization: true,\n      preciseTiming: false,\n    },\n    minimal: {\n      maxElementCount: 500,\n      targetFps: 20,\n      animationStepFactor: 3,\n      visualComplexity: 0.2,\n      useWebGLWhenAvailable: false,\n      interpolationSteps: 10,\n      enablePhysics: false,\n      physicsDetail: 0.1,\n      enableEffects: false,\n      enableBatching: true,\n      enableMemoization: false,\n      preciseTiming: false,\n    },\n  };\n\n  /** Current quality settings */\n  private currentSettings: QualitySettings;\n\n  /** User preference overrides */\n  private userOverrides: Partial<QualitySettings> = {};\n\n  /** Current performance state */\n  private performanceState: PerformanceState = {\n    currentFps: 0,\n    fpsHistory: [],\n    lastAdjustmentTime: 0,\n    adjustmentCount: 0,\n    currentTier: 'medium',\n    detectedCapabilities: this.getDefaultCapabilities(),\n    isInitialized: false,\n    isAdjusting: false,\n  };\n\n  /** Performance monitoring interval */\n  private monitoringInterval: number | null = null;\n\n  /** Animation callbacks by ID */\n  private qualityChangeCallbacks: Map<string, (settings: QualitySettings) => void> = new Map();\n\n  /** Animation quality overrides by ID */\n  private animationQualityOverrides: Map<string, Partial<QualitySettings>> = new Map();\n\n  /** Animation FPS history */\n  private animationFpsTracking: Map<string, number[]> = new Map();\n\n  /**\n   * Create a new animation quality manager\n   */\n  constructor(private config: QualityManagerConfig = {}) {\n    // Set up default configuration\n    this.config = {\n      enableAutoAdjustment: true,\n      minAcceptableFps: 30,\n      performanceCheckInterval: 5000,\n      adjustmentResponsiveness: 0.5,\n      respectPrefersReducedMotion: true,\n      respectBatterySaving: true,\n      persistSettings: true,\n      initialQualityTier: undefined,\n      absoluteMaxElementCount: 20000,\n      debugMode: false,\n      ...config,\n    };\n\n    // Initialize with medium settings first (will be adjusted)\n    this.currentSettings = this.qualityPresets.medium;\n\n    // Load saved settings if enabled\n    if (this.config.persistSettings) {\n      this.loadSavedSettings();\n    }\n\n    // Apply initial quality tier if specified\n    if (this.config.initialQualityTier) {\n      this.setQualityTier(this.config.initialQualityTier);\n    }\n\n    // Initialize the system\n    this.initialize();\n  }\n\n  /**\n   * Initialize the quality management system\n   */\n  private async initialize(): Promise<void> {\n    // Load browser capability detection\n    await this.detectDeviceCapabilities();\n\n    // Set initial quality based on detected capabilities\n    if (!this.config.initialQualityTier) {\n      const detectedTier = this.detectOptimalQualityTier();\n      this.setQualityTier(detectedTier);\n    }\n\n    // Start monitoring if auto-adjustment is enabled\n    if (this.config.enableAutoAdjustment) {\n      this.startPerformanceMonitoring();\n    }\n\n    // Monitor system events that might affect performance\n    this.setupSystemEventListeners();\n\n    // Mark as initialized\n    this.performanceState.isInitialized = true;\n\n    if (this.config.debugMode) {\n      console.warn('D3AnimationQualityManager initialized', {\n        capabilities: this.performanceState.detectedCapabilities,\n        qualityTier: this.performanceState.currentTier,\n        settings: this.currentSettings,\n      });\n    }\n  }\n\n  /**\n   * Get default capabilities when proper detection isn't available\n   */\n  private getDefaultCapabilities(): DeviceCapabilities {\n    return {\n      cpuScore: 50,\n      gpuScore: 50,\n      memoryScore: 50,\n      connectionType: 'unknown',\n      isMobile: false,\n      hasWebGL: false,\n      isBatterySaving: false,\n      screenCategory: 'medium',\n      browserPerformance: 'medium',\n    };\n  }\n\n  /**\n   * Detect device capabilities\n   */\n  private async detectDeviceCapabilities(): Promise<void> {\n    const capabilities: DeviceCapabilities = this.getDefaultCapabilities();\n\n    // Mobile detection\n    capabilities.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(\n      navigator.userAgent\n    );\n\n    // WebGL support\n    try {\n      const canvas = document.createElement('canvas');\n      capabilities.hasWebGL = !!(\n        window.WebGLRenderingContext &&\n        (canvas.getContext('webgl') || canvas.getContext('experimental-webgl'))\n      );\n    } catch (_e) {\n      capabilities.hasWebGL = false;\n    }\n\n    // Battery API check\n    if ('getBattery' in navigator) {\n      try {\n        // Define a proper interface for Battery API\n        interface BatteryManager {\n          charging: boolean;\n          level: number;\n          addEventListener(event: string, listener: () => void): void;\n        }\n\n        const battery = await (navigator as { getBattery(): Promise<BatteryManager> }).getBattery();\n        capabilities.isBatterySaving = battery.charging === false && battery.level < 0.2;\n\n        // Listen for battery changes\n        battery.addEventListener('levelchange', () => {\n          this.performanceState.detectedCapabilities.isBatterySaving =\n            battery.charging === false && battery.level < 0.2;\n          if (this.config.respectBatterySaving) {\n            this.adjustQualityIfNeeded();\n          }\n        });\n      } catch (_e) {\n        // Battery API not available\n      }\n    }\n\n    // Screen resolution category\n    const pixelRatio = window.devicePixelRatio || 1;\n    const screenWidth = window.screen.width * pixelRatio;\n    const screenHeight = window.screen.height * pixelRatio;\n    const resolution = screenWidth * screenHeight;\n\n    if (resolution > 4000 * 3000) {\n      capabilities.screenCategory = 'ultra';\n    } else if (resolution > 2000 * 1500) {\n      capabilities.screenCategory = 'high';\n    } else if (resolution > 1000 * 750) {\n      capabilities.screenCategory = 'medium';\n    } else {\n      capabilities.screenCategory = 'low';\n    }\n\n    // Connection type detection\n    if ('connection' in navigator) {\n      interface NetworkInformation {\n        effectiveType: string;\n      }\n\n      const {connection} = navigator as { connection?: NetworkInformation };\n      if (connection) {\n        const {effectiveType} = connection;\n        if (effectiveType === '4g') {\n          capabilities.connectionType = 'fast';\n        } else if (effectiveType === '3g') {\n          capabilities.connectionType = 'medium';\n        } else {\n          capabilities.connectionType = 'slow';\n        }\n      }\n    }\n\n    // Perform quick CPU benchmark\n    const cpuBenchmarkStart = performance.now();\n    let sum = 0;\n    for (let i = 0; i < 1000000; i++) {\n      sum += Math.sqrt(i);\n    }\n    const cpuBenchmarkTime = performance.now() - cpuBenchmarkStart;\n\n    // Normalize CPU score (lower is better, so invert)\n    capabilities.cpuScore = Math.min(100, Math.max(0, 100 - cpuBenchmarkTime / 50));\n\n    // GPU benchmarking is more complex and would require WebGL,\n    // for simplicity we'll estimate based on other factors\n    capabilities.gpuScore = capabilities.hasWebGL\n      ? capabilities.isMobile\n        ? 60\n        : 80\n      : capabilities.isMobile\n        ? 30\n        : 50;\n\n    // Attempt to estimate available memory\n    if ('deviceMemory' in navigator) {\n      interface NavigatorWithMemory extends Navigator {\n        deviceMemory?: number;\n      }\n\n      const {deviceMemory} = navigator as NavigatorWithMemory;\n      if (typeof deviceMemory === 'number') {\n        // deviceMemory is in GB, normalize to 0-100 scale\n        // Assuming 8GB as high-end, 16GB+ as maximum\n        capabilities.memoryScore = Math.min(100, Math.max(0, (deviceMemory / 16) * 100));\n      }\n    } else {\n      // Default assumption based on device type\n      capabilities.memoryScore = capabilities.isMobile ? 40 : 70;\n    }\n\n    // Browser performance estimation\n    // This is a very rough heuristic\n    const browserScore =\n      (capabilities.cpuScore + capabilities.gpuScore + capabilities.memoryScore) / 3;\n    if (browserScore > 70) {\n      capabilities.browserPerformance = 'high';\n    } else if (browserScore > 40) {\n      capabilities.browserPerformance = 'medium';\n    } else {\n      capabilities.browserPerformance = 'low';\n    }\n\n    // Update the state\n    this.performanceState.detectedCapabilities = capabilities;\n  }\n\n  /**\n   * Determine the optimal quality tier based on detected capabilities\n   */\n  private detectOptimalQualityTier(): PerformanceTier {\n    const caps = this.performanceState.detectedCapabilities;\n\n    // Basic score combining all factors\n    const overallScore =\n      caps.cpuScore * 0.3 +\n      caps.gpuScore * 0.3 +\n      caps.memoryScore * 0.2 +\n      (caps.isMobile ? 0 : 20) +\n      (caps.hasWebGL ? 10 : 0) +\n      (caps.isBatterySaving ? -15 : 0) +\n      (caps.screenCategory === 'ultra'\n        ? 10\n        : caps.screenCategory === 'high'\n          ? 5\n          : caps.screenCategory === 'low'\n            ? -5\n            : 0);\n\n    // Map overall score to quality tier\n    if (overallScore >= 80) {\n      return 'ultra';\n    } else if (overallScore >= 60) {\n      return 'high';\n    } else if (overallScore >= 40) {\n      return 'medium';\n    } else if (overallScore >= 20) {\n      return 'low';\n    } else {\n      return 'minimal';\n    }\n  }\n\n  /**\n   * Start monitoring performance to adjust quality dynamically\n   */\n  private startPerformanceMonitoring(): void {\n    if (this.monitoringInterval !== null) {\n      return; // Already monitoring\n    }\n\n    let lastFrameTime = performance.now();\n    let frameCount = 0;\n\n    // FPS monitoring function\n    const measureFps = () => {\n      frameCount++;\n      const now = performance.now();\n      const elapsed = now - lastFrameTime;\n\n      if (elapsed >= 1000) {\n        const currentFps = Math.round((frameCount * 1000) / elapsed);\n        this.performanceState.currentFps = currentFps;\n        this.performanceState.fpsHistory.push(currentFps);\n\n        // Keep only the last 10 measurements\n        if (this.performanceState.fpsHistory.length > 10) {\n          this.performanceState.fpsHistory.shift();\n        }\n\n        frameCount = 0;\n        lastFrameTime = now;\n      }\n\n      requestAnimationFrame(measureFps);\n    };\n\n    // Start measuring FPS\n    requestAnimationFrame(measureFps);\n\n    // Start the periodic quality adjustment check\n    this.monitoringInterval = window.setInterval(() => {\n      this.adjustQualityIfNeeded();\n    }, this.config.performanceCheckInterval);\n  }\n\n  /**\n   * Stop performance monitoring\n   */\n  private stopPerformanceMonitoring(): void {\n    if (this.monitoringInterval !== null) {\n      clearInterval(this.monitoringInterval);\n      this.monitoringInterval = null;\n    }\n  }\n\n  /**\n   * Set up listeners for system events that might affect performance\n   */\n  private setupSystemEventListeners(): void {\n    // Listen for reduced motion preference\n    if (this.config.respectPrefersReducedMotion) {\n      const motionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n\n      const handleMotionChange = (e: MediaQueryListEvent | MediaQueryList) => {\n        if (e.matches) {\n          // User prefers reduced motion, force lower quality\n          this.setQualityTier('low');\n        } else {\n          // User doesn't prefer reduced motion, redetect optimal quality\n          this.setQualityTier(this.detectOptimalQualityTier());\n        }\n      };\n\n      // Check initial state\n      handleMotionChange(motionQuery);\n\n      // Listen for changes\n      if (typeof motionQuery.addEventListener === 'function') {\n        motionQuery.addEventListener('change', handleMotionChange);\n      } else if (typeof motionQuery.addListener === 'function') {\n        // Older browsers\n        motionQuery.addListener(handleMotionChange);\n      }\n    }\n\n    // Listen for visibility changes to adjust quality when tab becomes visible again\n    document.addEventListener('visibilitychange', () => {\n      if (document.visibilityState === 'visible') {\n        // Page is now visible, check if we need to adjust quality\n        this.adjustQualityIfNeeded();\n      }\n    });\n\n    // Listen for window resize events, which might affect performance\n    let resizeTimeout: number | null = null;\n    window.addEventListener('resize', () => {\n      if (resizeTimeout !== null) {\n        clearTimeout(resizeTimeout);\n      }\n\n      // Debounce resize events\n      resizeTimeout = window.setTimeout(() => {\n        this.adjustQualityIfNeeded();\n        resizeTimeout = null;\n      }, 500);\n    });\n  }\n\n  /**\n   * Adjust quality settings if needed based on performance\n   */\n  private adjustQualityIfNeeded(): void {\n    if (!this.config.enableAutoAdjustment || this.performanceState.isAdjusting) {\n      return;\n    }\n\n    this.performanceState.isAdjusting = true;\n\n    try {\n      // Get average FPS from recent history\n      const avgFps =\n        this.performanceState.fpsHistory.length > 0\n          ? this.performanceState.fpsHistory.reduce((sum, fps) => sum + fps, 0) /\n            this.performanceState.fpsHistory.length\n          : this.performanceState.currentFps;\n\n      const currentTierIndex = this.getTierIndex(this.performanceState.currentTier);\n      const minAcceptableFps = this.config.minAcceptableFps || 30;\n\n      // Check if we need to adjust quality\n      if (avgFps < minAcceptableFps && currentTierIndex > 0) {\n        // Performance is poor, reduce quality\n        const newTier = this.getTierByIndex(currentTierIndex - 1);\n        this.setQualityTier(newTier);\n\n        if (this.config.debugMode) {\n          console.warn(`Reducing quality to ${newTier} due to low FPS (${avgFps.toFixed(1)})`);\n        }\n      } else if (avgFps > minAcceptableFps * 1.5 && currentTierIndex < 4) {\n        // Performance is good, we might be able to increase quality\n        // But do this cautiously and less frequently\n\n        const timeSinceLastAdjustment =\n          performance.now() - this.performanceState.lastAdjustmentTime;\n        const requiredTimeBetweenUpgrades = 30000; // 30 seconds between upgrades\n\n        if (timeSinceLastAdjustment > requiredTimeBetweenUpgrades) {\n          const newTier = this.getTierByIndex(currentTierIndex + 1);\n          this.setQualityTier(newTier);\n\n          if (this.config.debugMode) {\n            console.warn(`Increasing quality to ${newTier} due to good FPS (${avgFps.toFixed(1)})`);\n          }\n        }\n      }\n    } finally {\n      this.performanceState.isAdjusting = false;\n    }\n  }\n\n  /**\n   * Get the index of a quality tier\n   */\n  private getTierIndex(tier: PerformanceTier): number {\n    const tiers: PerformanceTier[] = ['minimal', 'low', 'medium', 'high', 'ultra'];\n    return tiers.indexOf(tier);\n  }\n\n  /**\n   * Get a quality tier by index\n   */\n  private getTierByIndex(index: number): PerformanceTier {\n    const tiers: PerformanceTier[] = ['minimal', 'low', 'medium', 'high', 'ultra'];\n    return tiers[Math.max(0, Math.min(tiers.length - 1, index))];\n  }\n\n  /**\n   * Set quality tier\n   */\n  public setQualityTier(tier: PerformanceTier): void {\n    // Update the current tier\n    this.performanceState.currentTier = tier;\n\n    // Get the preset for this tier\n    const presetSettings = this.qualityPresets[tier];\n\n    // Apply user overrides\n    this.currentSettings = {\n      ...presetSettings,\n      ...this.userOverrides,\n    };\n\n    // Apply the new settings to all registered animations\n    this.applyQualitySettingsToAnimations();\n\n    // Save settings if persistence is enabled\n    if (this.config.persistSettings) {\n      this.saveSettings();\n    }\n\n    // Update last adjustment time\n    this.performanceState.lastAdjustmentTime = performance.now();\n    this.performanceState.adjustmentCount++;\n  }\n\n  /**\n   * Apply current quality settings to all registered animations\n   */\n  private applyQualitySettingsToAnimations(): void {\n    // Notify all registered animations of quality changes\n    this.qualityChangeCallbacks.forEach((callback, animationId) => {\n      try {\n        // Apply global settings with any animation-specific overrides\n        const animationSettings = {\n          ...this.currentSettings,\n          ...(this.animationQualityOverrides.get(animationId) ?? {}),\n        };\n\n        callback(animationSettings);\n      } catch (err) {\n        console.error(`Error applying quality settings to animation ${animationId}:`, err);\n      }\n    });\n  }\n\n  /**\n   * Register an animation for quality management\n   */\n  public registerAnimation(\n    animationId: string,\n    onQualityChange: (settings: QualitySettings) => void,\n    animationSpecificOverrides?: Partial<QualitySettings>\n  ): void {\n    // Store the callback\n    this.qualityChangeCallbacks.set(animationId, onQualityChange);\n\n    // Store any animation-specific overrides\n    if (animationSpecificOverrides) {\n      this.animationQualityOverrides.set(animationId, animationSpecificOverrides);\n    }\n\n    // Initialize FPS tracking for this animation\n    this.animationFpsTracking.set(animationId, []);\n\n    // Apply current settings immediately\n    const settings = {\n      ...this.currentSettings,\n      ...(animationSpecificOverrides ?? {}),\n    };\n\n    onQualityChange(settings);\n  }\n\n  /**\n   * Unregister an animation\n   */\n  public unregisterAnimation(animationId: string): void {\n    this.qualityChangeCallbacks.delete(animationId);\n    this.animationQualityOverrides.delete(animationId);\n    this.animationFpsTracking.delete(animationId);\n  }\n\n  /**\n   * Update FPS for a specific animation\n   */\n  public updateAnimationFps(animationId: string, fps: number): void {\n    const fpsHistory = this.animationFpsTracking.get(animationId);\n    if (fpsHistory) {\n      fpsHistory.push(fps);\n\n      // Keep only the last 10 measurements\n      if (fpsHistory.length > 10) {\n        fpsHistory.shift();\n      }\n    }\n  }\n\n  /**\n   * Set user preference override for specific settings\n   */\n  public setUserPreference<K extends keyof QualitySettings>(\n    settingKey: K,\n    value: QualitySettings[K]\n  ): void {\n    this.userOverrides[settingKey] = value;\n\n    // Apply the change immediately\n    this.currentSettings = {\n      ...this.qualityPresets[this.performanceState.currentTier],\n      ...this.userOverrides,\n    };\n\n    // Apply to all animations\n    this.applyQualitySettingsToAnimations();\n\n    // Save settings if persistence is enabled\n    if (this.config.persistSettings) {\n      this.saveSettings();\n    }\n  }\n\n  /**\n   * Clears all user preference overrides\n   */\n  public clearUserPreferences(): void {\n    this.userOverrides = {};\n\n    // Reapply preset settings\n    this.currentSettings = this.qualityPresets[this.performanceState.currentTier];\n\n    // Apply to all animations\n    this.applyQualitySettingsToAnimations();\n\n    // Save settings if persistence is enabled\n    if (this.config.persistSettings) {\n      this.saveSettings();\n    }\n  }\n\n  /**\n   * Save settings to localStorage\n   */\n  private saveSettings(): void {\n    try {\n      const settingsToSave = {\n        qualityTier: this.performanceState.currentTier,\n        userOverrides: this.userOverrides,\n      };\n\n      localStorage.setItem('d3-animation-quality-settings', JSON.stringify(settingsToSave));\n    } catch (err) {\n      console.error('Error saving animation quality settings:', err);\n    }\n  }\n\n  /**\n   * Load saved settings from localStorage\n   */\n  private loadSavedSettings(): void {\n    try {\n      const savedSettings = localStorage.getItem('d3-animation-quality-settings');\n\n      if (savedSettings) {\n        const parsed = JSON.parse(savedSettings);\n\n        // Apply saved tier if it exists\n        if (parsed.qualityTier && typeof parsed.qualityTier === 'string') {\n          this.performanceState.currentTier = parsed.qualityTier as PerformanceTier;\n        }\n\n        // Apply saved user overrides\n        if (parsed.userOverrides && typeof parsed.userOverrides === 'object') {\n          this.userOverrides = parsed.userOverrides;\n        }\n      }\n    } catch (err) {\n      console.error('Error loading animation quality settings:', err);\n    }\n  }\n\n  /**\n   * Get current quality settings\n   */\n  public getCurrentSettings(): QualitySettings {\n    return { ...this.currentSettings };\n  }\n\n  /**\n   * Get current performance state\n   */\n  public getPerformanceState(): Readonly<PerformanceState> {\n    return { ...this.performanceState };\n  }\n\n  /**\n   * Get detected device capabilities\n   */\n  public getDeviceCapabilities(): Readonly<DeviceCapabilities> {\n    return { ...this.performanceState.detectedCapabilities };\n  }\n\n  /**\n   * Enable or disable auto-adjustment\n   */\n  public setAutoAdjustment(enabled: boolean): void {\n    this.config.enableAutoAdjustment = enabled;\n\n    if (enabled && this.monitoringInterval === null) {\n      this.startPerformanceMonitoring();\n    } else if (!enabled && this.monitoringInterval !== null) {\n      this.stopPerformanceMonitoring();\n    }\n  }\n}\n\n// Singleton instance for easier access\nexport const animationQualityManager = new D3AnimationQualityManager();\n\n/**\n * Helper to create a quality-adaptive D3 visualization\n */\nexport function createQualityAdaptiveVisualization<GElement extends Element = SVGSVGElement>(\n  selector: string | GElement,\n  animationId: string,\n  setup: (\n    container: d3.Selection<GElement, unknown, null, undefined>,\n    settings: QualitySettings\n  ) => void,\n  qualityOverrides?: Partial<QualitySettings>\n): d3.Selection<GElement, unknown, null, undefined> {\n  // Handle string selector and element selector separately with proper typing\n  let selection: d3.Selection<GElement, unknown, null, undefined>;\n\n  if (typeof selector === 'string') {\n    // For string selectors, cast after selection\n    selection = d3.select(selector) as unknown as d3.Selection<GElement, unknown, null, undefined>;\n  } else {\n    // For element selectors, cast the element first\n    selection = d3.select(selector as Element) as unknown as d3.Selection<\n      GElement,\n      unknown,\n      null,\n      undefined\n    >;\n  }\n\n  // Register with the quality manager\n  animationQualityManager.registerAnimation(\n    animationId,\n    settings => {\n      // Clear previous content\n      selection.selectAll('*').remove();\n\n      // Set up visualization with current quality settings\n      setup(selection, settings);\n    },\n    qualityOverrides\n  );\n\n  return selection;\n}\n\n/**\n * Create quality-adaptive D3 transitions\n */\nexport function createQualityAdaptiveTransition<\n  GElement extends Element,\n  Datum,\n  PElement extends Element,\n  PDatum,\n>(\n  selection: d3.Selection<GElement, Datum, PElement, PDatum>,\n  duration?: number\n): d3.Transition<GElement, Datum, PElement, PDatum> {\n  const settings = animationQualityManager.getCurrentSettings();\n\n  // Adjust duration based on quality settings\n  let adjustedDuration = duration;\n  if (duration !== undefined) {\n    // Scale duration by animation step factor\n    // If animationStepFactor is 2, transitions will take twice as long but use half as many frames\n    adjustedDuration = duration * settings.animationStepFactor;\n  }\n\n  // Create transition with quality-appropriate settings - fix for undefined duration\n  const transition = selection.transition().duration(adjustedDuration ?? 0);\n\n  // If precise timing isn't needed, use a more efficient easing function\n  if (!settings.preciseTiming) {\n    transition.ease(d3.easeLinear); // Linear is most efficient\n  }\n\n  return transition;\n}\n\n/**\n * Helper to create a quality-adaptive data binding\n */\nexport function bindDataWithQualityAdjustment<\n  GElement extends Element,\n  OldDatum,\n  NewDatum,\n  PElement extends Element,\n  PDatum,\n>(\n  selection: d3.Selection<GElement, OldDatum, PElement, PDatum>,\n  data: NewDatum[],\n  key?: (d: NewDatum, i: number, data: NewDatum[]) => string\n): d3.Selection<GElement, NewDatum, PElement, PDatum> {\n  const settings = animationQualityManager.getCurrentSettings();\n\n  // If we need to reduce the number of elements for performance reasons\n  const maxElements = settings.maxElementCount;\n  let limitedData = data;\n\n  if (data?.length > maxElements) {\n    // Limit the number of elements based on quality settings\n    limitedData = data?.slice(0, maxElements);\n  }\n\n  // Bind the data - handle key function with proper casting\n  if (key) {\n    // Cast the key function to the expected type for d3 data binding\n    const typedKeyFn = (d: unknown, i: number, data: unknown[]): string =>\n      key(d as NewDatum, i, data as NewDatum[]);\n\n    // Use the proper d3 ValueFn type here\n    return selection.data(\n      limitedData,\n      typedKeyFn as d3.ValueFn<GElement | PElement, OldDatum | NewDatum, string>\n    );\n  } else {\n    return selection.data(limitedData);\n  }\n}\n\n/**\n * Helper to create a quality-adaptive simulation\n */\nexport function createQualityAdaptiveSimulation<NodeDatum extends d3.SimulationNodeDatum>(\n  nodes: NodeDatum[]\n): d3.Simulation<NodeDatum, undefined> {\n  const settings = animationQualityManager.getCurrentSettings();\n\n  // Create simulation with quality-adaptive settings\n  const simulation = d3.forceSimulation<NodeDatum>().nodes(nodes);\n\n  // Adjust simulation parameters based on quality settings\n  const alphaDecay = settings.physicsDetail < 0.5 ? 0.1 : 0.02; // Faster convergence for low quality\n  const velocityDecay = settings.physicsDetail < 0.5 ? 0.5 : 0.4; // More damping for low quality\n  const iterations = Math.max(1, Math.round(settings.physicsDetail * 4)); // Fewer iterations for low quality\n\n  simulation.alphaDecay(alphaDecay).velocityDecay(velocityDecay).alphaTarget(0).alphaMin(0.001);\n\n  // Set tick iterations based on quality\n  if (typeof simulation.tick === 'function') {\n    const originalTick = simulation.tick;\n    simulation.tick = function () {\n      for (let i = 0; i < iterations; i++) {\n        originalTick.call(this);\n      }\n      return this;\n    };\n  }\n\n  return simulation;\n}\n\n/**\n * Helper to create a quality-adaptive interpolator\n */\nexport function createQualityAdaptiveInterpolator<T>(\n  a: T,\n  b: T,\n  interpolatorFactory: (a: T, b: T) => (t: number) => T = d3.interpolate\n): (t: number) => T {\n  const settings = animationQualityManager.getCurrentSettings();\n  const baseInterpolator = interpolatorFactory(a, b);\n\n  // For high quality settings, use the full interpolator\n  if (settings.interpolationSteps >= 60) {\n    return baseInterpolator;\n  }\n\n  // For lower quality, create a stepped interpolator with fewer intermediate values\n  return (t: number) => {\n    // Quantize the t value to reduce the number of unique outputs\n    const steps = settings.interpolationSteps;\n    const steppedT = Math.round(t * steps) / steps;\n    return baseInterpolator(steppedT);\n  };\n}\n\n/**\n * React hook for using quality-adaptive D3 visualizations\n */\nexport function useQualityAdaptiveD3(\n  animationId: string,\n  qualityOverrides?: Partial<QualitySettings>\n) {\n  const [qualitySettings, setQualitySettings] = React.useState<QualitySettings>(\n    animationQualityManager.getCurrentSettings()\n  );\n\n  React.useEffect(() => {\n    // Register with quality manager\n    animationQualityManager.registerAnimation(\n      animationId,\n      newSettings => {\n        setQualitySettings(newSettings);\n      },\n      qualityOverrides\n    );\n\n    // Unregister on cleanup\n    return () => {\n      animationQualityManager.unregisterAnimation(animationId);\n    };\n  }, [animationId, qualityOverrides]);\n\n  return qualitySettings;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/performance/D3BatchedUpdates.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'D3GenericFunction' is defined but never used. Allowed unused vars must match /^ignored|^temp/u.","line":490,"column":6,"nodeType":null,"messageId":"unusedVar","endLine":490,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'D3SelectionMethodOverride' is defined but never used. Allowed unused vars must match /^ignored|^temp/u.","line":618,"column":6,"nodeType":null,"messageId":"unusedVar","endLine":618,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'D3PropertyMethodOverride' is defined but never used. Allowed unused vars must match /^ignored|^temp/u.","line":631,"column":6,"nodeType":null,"messageId":"unusedVar","endLine":631,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'AttrTweenFunctionType' is defined but never used. Allowed unused vars must match /^ignored|^temp/u.","line":867,"column":6,"nodeType":null,"messageId":"unusedVar","endLine":867,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'StyleTweenFunctionType' is defined but never used. Allowed unused vars must match /^ignored|^temp/u.","line":877,"column":6,"nodeType":null,"messageId":"unusedVar","endLine":877,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'TransitionFunctionType' is defined but never used. Allowed unused vars must match /^ignored|^temp/u.","line":887,"column":6,"nodeType":null,"messageId":"unusedVar","endLine":887,"endColumn":28}],"suppressedMessages":[{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Do not use \"@ts-nocheck\" because it alters compilation errors.","line":20,"column":1,"nodeType":"Line","messageId":"tsDirectiveComment","endLine":20,"endColumn":15,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":493,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":493,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14688,14691],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14688,14691],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":683,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":683,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20598,20601],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20598,20601],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":721,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":721,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21522,21525],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21522,21525],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":723,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":723,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21603,21606],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21603,21606],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":723,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":723,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21620,21623],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21620,21623],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":749,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":749,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22252,22255],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22252,22255],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":755,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":755,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22387,22390],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22387,22390],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":785,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":785,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23126,23129],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23126,23129],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":820,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":820,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23927,23930],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23927,23930],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":924,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":924,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26810,26813],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26810,26813],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * D3 Batched Updates System\n *\n * This module provides utilities for batching multiple DOM updates into a single render cycle,\n * reducing layout thrashing and improving animation performance. Key features include:\n *\n * 1. Update batching across multiple animations and selections\n * 2. Prioritized update scheduling based on visibility and importance\n * 3. DOM read/write separation to prevent layout thrashing\n * 4. Automatic microtask scheduling for optimal performance\n * 5. Integration with existing animation frame manager\n *\n * @note This file has known TypeScript typing issues that will be addressed in a future refactoring.\n * See src/utils/performance/.cursor/ignore/README.md for details.\n */\n\n// TypeScript ignore directives - to be removed during comprehensive refactoring\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/ban-ts-comment */\n// @ts-nocheck\n\nimport * as d3 from 'd3';\nimport { BaseType, Local, Selection, Transition, ValueFn } from 'd3';\nimport { animationFrameManager, AnimationPriority } from './D3AnimationFrameManager';\n\n/**\n * Type for DOM operations that need to be scheduled together\n */\ntype BatchOperation = {\n  /** Operation type - read operations execute before write operations */\n  type: 'read' | 'write';\n  /** The operation's unique ID */\n  id: string;\n  /** The callback function to execute */\n  callback: () => void;\n  /** Priority level for the operation */\n  priority: BatchOperationPriority;\n  /** When the operation was scheduled (for ordering operations with same priority) */\n  timestamp: number;\n  /** Element the operation is associated with (for grouping) */\n  element?: Element;\n  /** Animation ID this operation is associated with (for grouping) */\n  animationId?: string;\n};\n\n/**\n * Priority levels for batch operations\n */\nexport type BatchOperationPriority = 'critical' | 'high' | 'normal' | 'low' | 'idle';\n\n/**\n * Scheduling mode for batched updates\n */\nexport type BatchSchedulingMode = 'immediate' | 'animation-frame' | 'microtask' | 'idle-callback';\n\n/**\n * Configuration options for the batch update system\n */\nexport interface BatchSystemConfig {\n  /** Default scheduling mode */\n  defaultSchedulingMode?: BatchSchedulingMode;\n  /** Whether to automatically optimize the scheduling mode based on browser conditions */\n  autoOptimize?: boolean;\n  /** Maximum operations to process per batch before forcing a flush */\n  maxOperationsPerBatch?: number;\n  /** Whether to separate read and write operations to prevent layout thrashing */\n  separateReadsWrites?: boolean;\n  /** Whether to group operations by element */\n  groupByElement?: boolean;\n  /** Whether to enable debug logging */\n  debugMode?: boolean;\n}\n\n/**\n * Options for batched operations\n */\nexport interface BatchOperationOptions {\n  /** Operation priority */\n  priority?: BatchOperationPriority;\n  /** Element the operation is associated with */\n  element?: Element;\n  /** Animation ID this operation is associated with */\n  animationId?: string;\n  /** Scheduling mode for this operation */\n  schedulingMode?: BatchSchedulingMode;\n  /** Custom ID for the operation (for deduplication) */\n  id?: string;\n}\n\n/**\n * Options for flushing batched operations\n */\nexport interface FlushOptions {\n  /** Only flush operations for a specific element */\n  forElement?: Element;\n  /** Only flush operations for a specific animation */\n  forAnimation?: string;\n  /** Only flush operations with priority >= the specified level */\n  minPriority?: BatchOperationPriority;\n  /** Only flush read operations */\n  readOnly?: boolean;\n  /** Only flush write operations */\n  writeOnly?: boolean;\n}\n\n/**\n * Stateful batch update manager for D3 animations\n */\nexport class D3BatchUpdateManager {\n  /** Queue of pending read operations */\n  private readQueue: BatchOperation[] = [];\n\n  /** Queue of pending write operations */\n  private writeQueue: BatchOperation[] = [];\n\n  /** Whether a batch flush is scheduled */\n  private flushScheduled = false;\n\n  /** Current batch ID for tracking which batch operations belong to */\n  private currentBatchId = 0;\n\n  /** Whether the system is currently flushing operations */\n  private isFlushing = false;\n\n  /** Completed operation count for statistics */\n  private completedOperations = 0;\n\n  /** Map of operation IDs to avoid duplicates */\n  private operationIds = new Set<string>();\n\n  /** Priority order for sorting operations */\n  private priorityOrder: Record<BatchOperationPriority, number> = {\n    critical: 0,\n    high: 1,\n    normal: 2,\n    low: 3,\n    idle: 4,\n  };\n\n  /**\n   * Create a new batch update manager\n   */\n  constructor(private config: BatchSystemConfig = {}) {\n    this.config = {\n      defaultSchedulingMode: 'microtask',\n      autoOptimize: true,\n      maxOperationsPerBatch: 100,\n      separateReadsWrites: true,\n      groupByElement: true,\n      debugMode: false,\n      ...config,\n    };\n  }\n\n  /**\n   * Determine the best scheduling mode based on browser conditions\n   */\n  private determineBestSchedulingMode(): BatchSchedulingMode {\n    if (!this.config.autoOptimize) {\n      return this.config.defaultSchedulingMode!;\n    }\n\n    // Use immediate mode for small batches or if we're already in a requestAnimationFrame\n    if (this.getTotalPendingOperations() < 10) {\n      return 'immediate';\n    }\n\n    // Use requestAnimationFrame for larger batches\n    if (this.getTotalPendingOperations() >= 10 && this.getTotalPendingOperations() < 50) {\n      return 'animation-frame';\n    }\n\n    // Use idle callback for background operations if available\n    if (\n      typeof window.requestIdleCallback === 'function' &&\n      this.readQueue.every(op => op.priority === 'idle' || op.priority === 'low') &&\n      this.writeQueue.every(op => op.priority === 'idle' || op.priority === 'low')\n    ) {\n      return 'idle-callback';\n    }\n\n    // Default to microtask for most cases\n    return 'microtask';\n  }\n\n  /**\n   * Schedule a batch flush with the appropriate timing\n   */\n  private scheduleFlush(mode?: BatchSchedulingMode): void {\n    if (this.flushScheduled) {\n      return;\n    }\n\n    this.flushScheduled = true;\n    const schedulingMode = mode || this.determineBestSchedulingMode();\n\n    switch (schedulingMode) {\n      case 'immediate':\n        this.flush();\n        break;\n\n      case 'animation-frame':\n        requestAnimationFrame(() => this.flush());\n        break;\n\n      case 'microtask':\n        Promise.resolve().then(() => this.flush());\n        break;\n\n      case 'idle-callback':\n        if (typeof window.requestIdleCallback === 'function') {\n          window.requestIdleCallback(\n            deadline => {\n              const timeRemaining = deadline.timeRemaining();\n              // Only process if we have enough time\n              if (timeRemaining > 10 || deadline.didTimeout) {\n                this.flush();\n              } else {\n                // If not enough time, reschedule with animation frame\n                this.flushScheduled = false;\n                this.scheduleFlush('animation-frame');\n              }\n            },\n            { timeout: 100 }\n          ); // Give it a reasonable timeout\n        } else {\n          // Fall back to requestAnimationFrame if requestIdleCallback is not available\n          requestAnimationFrame(() => this.flush());\n        }\n        break;\n    }\n  }\n\n  /**\n   * Flush all pending operations\n   */\n  private flush(options?: FlushOptions): void {\n    this.isFlushing = true;\n    this.flushScheduled = false;\n\n    // Track the current batch\n    const batchId = this.currentBatchId++;\n\n    // Filter operations based on options\n    const filterOperation = (op: BatchOperation): boolean => {\n      if (options?.forElement && op.element !== options?.forElement) {\n        return false;\n      }\n      if (options?.forAnimation && op.animationId !== options?.forAnimation) {\n        return false;\n      }\n      if (options?.minPriority &&\n              this.priorityOrder[op.priority] > this.priorityOrder[options?.minPriority]) {\n        return false;\n      }\n      return true;\n    };\n\n    // Get operations to flush\n    const readOps = options?.writeOnly ? [] : this.readQueue.filter(filterOperation);\n    const writeOps = options?.readOnly ? [] : this.writeQueue.filter(filterOperation);\n\n    // Sort operations by priority and timestamp\n    const sortOperations = (a: BatchOperation, b: BatchOperation) => {\n      if (a.priority !== b.priority) {\n        return this.priorityOrder[a.priority] - this.priorityOrder[b.priority];\n      }\n      return a.timestamp - b.timestamp;\n    };\n\n    readOps.sort(sortOperations);\n    writeOps.sort(sortOperations);\n\n    // Remember operations we're going to process\n    const readOpsToProcess = readOps;\n    const writeOpsToProcess = writeOps;\n\n    // Remove operations we're about to process from the queues\n    this.readQueue = this.readQueue.filter(op => !readOpsToProcess.includes(op));\n    this.writeQueue = this.writeQueue.filter(op => !writeOpsToProcess.includes(op));\n\n    try {\n      // Process read operations first to prevent layout thrashing\n      readOpsToProcess.forEach(op => {\n        try {\n          op.callback();\n          this.completedOperations++;\n        } catch (err) {\n          console.error(`Error in read operation ${op.id}:`, err);\n        }\n      });\n\n      // Then process write operations\n      writeOpsToProcess.forEach(op => {\n        try {\n          op.callback();\n          this.completedOperations++;\n        } catch (err) {\n          console.error(`Error in write operation ${op.id}:`, err);\n        }\n      });\n    } finally {\n      this.isFlushing = false;\n\n      // Clear processed operation IDs\n      readOpsToProcess.concat(writeOpsToProcess).forEach(op => {\n        this.operationIds.delete(op.id);\n      });\n    }\n\n    // If there are still operations pending, schedule another flush\n    if (this.getTotalPendingOperations() > 0) {\n      this.scheduleFlush();\n    }\n\n    if (this.config.debugMode) {\n      console.warn(\n        `Batch #${batchId} processed: ${readOpsToProcess.length} reads, ${writeOpsToProcess.length} writes`\n      );\n    }\n  }\n\n  /**\n   * Get the total number of pending operations\n   */\n  private getTotalPendingOperations(): number {\n    return this.readQueue.length + this.writeQueue.length;\n  }\n\n  /**\n   * Add a read operation to the batch queue\n   */\n  public read<T>(callback: () => T, options: BatchOperationOptions = {}): T | undefined {\n    return this.addOperation('read', callback, options);\n  }\n\n  /**\n   * Add a write operation to the batch queue\n   */\n  public write<T>(callback: () => T, options: BatchOperationOptions = {}): T | undefined {\n    return this.addOperation('write', callback, options);\n  }\n\n  /**\n   * Add an operation to the appropriate queue\n   */\n  private addOperation<T>(\n    type: 'read' | 'write',\n    callback: () => T,\n    options: BatchOperationOptions\n  ): T | undefined {\n    const { priority = 'normal', element, animationId, schedulingMode, id: customId } = options;\n\n    // Generate a unique ID for the operation\n    const baseId = customId || `${type}-${Date.now()}-${Math.round(Math.random() * 10000)}`;\n\n    // For element-specific operations, make the ID element-specific to enable deduplication\n    const id = element ? `${baseId}-${element.tagName}-${priority}` : baseId;\n\n    // Skip if this exact operation was already scheduled (deduplication)\n    if (this.operationIds.has(id)) {\n      if (this.config.debugMode) {\n        console.warn(`Skipping duplicate operation ${id}`);\n      }\n      return undefined;\n    }\n\n    // If we're already flushing and this is an immediate operation, execute it directly\n    if (this.isFlushing && schedulingMode === 'immediate') {\n      try {\n        return callback();\n      } catch (err) {\n        console.error(`Error in immediate ${type} operation:`, err);\n        return undefined;\n      }\n    }\n\n    // Create the operation\n    const operation: BatchOperation = {\n      type,\n      id,\n      callback: () => callback(),\n      priority,\n      timestamp: Date.now(),\n      element,\n      animationId,\n    };\n\n    // Add to the appropriate queue\n    if (type === 'read') {\n      this.readQueue.push(operation);\n    } else {\n      this.writeQueue.push(operation);\n    }\n\n    // Record the operation ID\n    this.operationIds.add(id);\n\n    // Schedule a flush if needed\n    if (!this.flushScheduled) {\n      this.scheduleFlush(schedulingMode);\n    } else if (priority === 'critical' && schedulingMode === 'immediate') {\n      // Force an immediate flush for critical operations\n      this.flush({\n        minPriority: 'critical',\n      });\n    }\n\n    // For immediate operations, we can return the result\n    if (schedulingMode === 'immediate') {\n      return callback();\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Manually flush all pending operations\n   */\n  public flushAll(): void {\n    this.flush();\n  }\n\n  /**\n   * Manually flush operations for a specific element\n   */\n  public flushForElement(element: Element): void {\n    this.flush({ forElement: element });\n  }\n\n  /**\n   * Manually flush operations for a specific animation\n   */\n  public flushForAnimation(animationId: string): void {\n    this.flush({ forAnimation: animationId });\n  }\n\n  /**\n   * Get statistics about the batch manager\n   */\n  public getStats() {\n    return {\n      pendingReads: this.readQueue.length,\n      pendingWrites: this.writeQueue.length,\n      totalPending: this.getTotalPendingOperations(),\n      completedOperations: this.completedOperations,\n      isFlushing: this.isFlushing,\n      flushScheduled: this.flushScheduled,\n      batchCount: this.currentBatchId,\n    };\n  }\n\n  /**\n   * Cancel all pending operations\n   */\n  public cancelAll(): void {\n    this.readQueue = [];\n    this.writeQueue = [];\n    this.operationIds.clear();\n    this.flushScheduled = false;\n  }\n}\n\n/**\n * Singleton instance for easy access\n */\nexport const batchUpdateManager = new D3BatchUpdateManager();\n\n/**\n * Helper to batch read operations related to DOM measurements\n */\nexport function batchRead<T>(\n  callback: () => T,\n  options: BatchOperationOptions = {}\n): T | undefined {\n  return batchUpdateManager.read(callback, options);\n}\n\n/**\n * Helper to batch write operations related to DOM modifications\n */\nexport function batchWrite<T>(\n  callback: () => T,\n  options: BatchOperationOptions = {}\n): T | undefined {\n  return batchUpdateManager.write(callback, options);\n}\n\n// Define a more permissive type for D3 transition methods when using unknown/dynamic types\ntype D3GenericFunction = (...args: unknown[]) => unknown;\n\n// Redefine D3MethodOverride to use any instead of unknown for better D3 compatibility\ntype D3MethodOverride = any; // Use any to avoid type conflicts with complex D3 method signatures\n\n/**\n * Define proper types for D3 selection methods to use in our overrides\n */\ninterface D3SelectionMethods<GElement extends BaseType, Datum, PElement extends BaseType, PDatum> {\n  attr: {\n    (name: string): string;\n    (\n      name: string,\n      value:\n        | string\n        | number\n        | boolean\n        | readonly (string | number)[]\n        | ValueFn<GElement, Datum, string | number | boolean | readonly (string | number)[] | null>\n        | null\n    ): Selection<GElement, Datum, PElement, PDatum>;\n  };\n  style: {\n    (name: string): string;\n    (name: string, value: null): Selection<GElement, Datum, PElement, PDatum>;\n    (\n      name: string,\n      value: string | number | boolean,\n      priority?: 'important' | null | undefined\n    ): Selection<GElement, Datum, PElement, PDatum>;\n    (\n      name: string,\n      value: ValueFn<GElement, Datum, string | number | boolean | null>,\n      priority?: 'important' | null | undefined\n    ): Selection<GElement, Datum, PElement, PDatum>;\n  };\n  property: {\n    (name: string): unknown;\n    <T>(name: Local<T>): T | undefined;\n    (\n      name: string,\n      value: ValueFn<GElement, Datum, unknown> | null\n    ): Selection<GElement, Datum, PElement, PDatum>;\n    (name: string, value: unknown): Selection<GElement, Datum, PElement, PDatum>;\n    <T>(\n      name: Local<T>,\n      value: ValueFn<GElement, Datum, T | null> | null\n    ): Selection<GElement, Datum, PElement, PDatum>;\n    <T>(name: Local<T>, value: T): Selection<GElement, Datum, PElement, PDatum>;\n  };\n  html: {\n    (): string;\n    (\n      value: string | ValueFn<GElement, Datum, string | null> | null\n    ): Selection<GElement, Datum, PElement, PDatum>;\n  };\n  text: {\n    (): string;\n    (\n      value:\n        | string\n        | number\n        | boolean\n        | ValueFn<GElement, Datum, string | number | boolean | null>\n        | null\n    ): Selection<GElement, Datum, PElement, PDatum>;\n  };\n  transition: {\n    (name?: string): Transition<GElement, Datum, PElement, PDatum>;\n    (\n      transition: Transition<BaseType, unknown, unknown, unknown>\n    ): Transition<GElement, Datum, PElement, PDatum>;\n  };\n}\n\n/**\n * Define proper types for D3 transition methods to use in our overrides\n */\ninterface D3TransitionMethods<GElement extends BaseType, Datum, PElement extends BaseType, PDatum> {\n  attr: {\n    (\n      name: string,\n      value: string | number | boolean | null\n    ): Transition<GElement, Datum, PElement, PDatum>;\n    (\n      name: string,\n      value: ValueFn<GElement, Datum, string | number | boolean | null>\n    ): Transition<GElement, Datum, PElement, PDatum>;\n  };\n  style: {\n    (name: string, value: null): Transition<GElement, Datum, PElement, PDatum>;\n    (\n      name: string,\n      value: string | number | boolean,\n      priority?: 'important' | null\n    ): Transition<GElement, Datum, PElement, PDatum>;\n    (\n      name: string,\n      value: ValueFn<GElement, Datum, string | number | boolean | null>,\n      priority?: 'important' | null\n    ): Transition<GElement, Datum, PElement, PDatum>;\n  };\n  attrTween: {\n    (name: string): ValueFn<GElement, Datum, (this: GElement, t: number) => string> | undefined;\n    (name: string, factory: null): Transition<GElement, Datum, PElement, PDatum>;\n    (\n      name: string,\n      factory: ValueFn<GElement, Datum, (this: GElement, t: number) => string>\n    ): Transition<GElement, Datum, PElement, PDatum>;\n  };\n  styleTween: {\n    (name: string): ValueFn<GElement, Datum, (this: GElement, t: number) => string> | undefined;\n    (\n      name: string,\n      factory: null,\n      priority?: 'important' | null\n    ): Transition<GElement, Datum, PElement, PDatum>;\n    (\n      name: string,\n      factory: ValueFn<GElement, Datum, (this: GElement, t: number) => string>,\n      priority?: 'important' | null\n    ): Transition<GElement, Datum, PElement, PDatum>;\n  };\n}\n\n/**\n * Type for D3 selection method override\n */\ntype D3SelectionMethodOverride<\n  GElement extends Element,\n  Datum,\n  PElement extends Element,\n  PDatum,\n> = (\n  this: d3.Selection<GElement, Datum, PElement, PDatum>,\n  ...args: unknown[]\n) => string | d3.Selection<GElement, Datum, PElement, PDatum>;\n\n/**\n * Type for D3 property method override\n */\ntype D3PropertyMethodOverride<\n  GElement extends Element,\n  Datum,\n  PElement extends Element,\n  PDatum,\n> = (\n  this: d3.Selection<GElement, Datum, PElement, PDatum>,\n  ...args: unknown[]\n) => unknown | d3.Selection<GElement, Datum, PElement, PDatum>;\n\n/**\n * Creates optimized D3 selection methods that use batched updates\n */\nexport function createBatchedSelection<\n  GElement extends Element,\n  Datum,\n  PElement extends Element,\n  PDatum,\n>(\n  selection: d3.Selection<GElement, Datum, PElement, PDatum>,\n  options: BatchOperationOptions = {}\n): d3.Selection<GElement, Datum, PElement, PDatum> {\n  // Clone the selection to avoid modifying the original\n  const batchedSelection = selection.clone() as d3.Selection<GElement, Datum, PElement, PDatum>;\n\n  // Store original methods\n  const origAttr = batchedSelection.attr;\n  const origStyle = batchedSelection.style;\n  const origProperty = batchedSelection.property;\n  const origHtml = batchedSelection.html;\n  const origText = batchedSelection.text;\n\n  // Override attr to use batched writes\n  const origAttr = batchedSelection.attr;\n  batchedSelection.attr = function (\n    this: typeof batchedSelection,\n    name: string,\n    value?:\n      | string\n      | number\n      | boolean\n      | readonly (string | number)[]\n      | ValueFn<GElement, Datum, string | number | boolean | readonly (string | number)[] | null>\n      | null\n  ): unknown {\n    if (arguments.length === 1) {\n      return origAttr.call(this, name);\n    }\n\n    // Write operation - can be batched\n    batchWrite(\n      () => {\n        origAttr.call(batchedSelection, name, value as any);\n      },\n      {\n        ...options,\n        element: (batchedSelection.node() as Element) || undefined,\n      }\n    );\n\n    return batchedSelection;\n  } as D3MethodOverride<\n    GElement,\n    Datum,\n    PElement,\n    PDatum,\n    string | d3.Selection<GElement, Datum, PElement, PDatum>\n  >;\n\n  // Override style to use batched writes\n  const origStyle = batchedSelection.style;\n  batchedSelection.style = function (\n    this: typeof batchedSelection,\n    name: string,\n    value?:\n      | string\n      | number\n      | boolean\n      | ValueFn<GElement, Datum, string | number | boolean | null>\n      | null,\n    priority?: 'important' | null | undefined\n  ): unknown {\n    if (arguments.length === 1) {\n      return origStyle.call(this, name);\n    }\n\n    // Write operation - can be batched\n    batchWrite(\n      () => {\n        if (arguments.length === 2) {\n          origStyle.call(batchedSelection, name, value as any);\n        } else {\n          origStyle.call(batchedSelection, name, value as any, priority as any);\n        }\n      },\n      {\n        ...options,\n        element: (batchedSelection.node() as Element) || undefined,\n      }\n    );\n\n    return batchedSelection;\n  } as D3MethodOverride<\n    GElement,\n    Datum,\n    PElement,\n    PDatum,\n    string | d3.Selection<GElement, Datum, PElement, PDatum>\n  >;\n\n  // Override property to use batched writes\n  const origProperty = batchedSelection.property;\n  batchedSelection.property = function (\n    this: typeof batchedSelection,\n    name: string | d3.Local<unknown>,\n    value?: unknown\n  ): unknown {\n    if (arguments.length === 1) {\n      return origProperty.call(this, name as any);\n    }\n\n    // Write operation - can be batched\n    batchWrite(\n      () => {\n        origProperty.call(batchedSelection, name as any, value);\n      },\n      {\n        ...options,\n        element: (batchedSelection.node() as Element) || undefined,\n      }\n    );\n\n    return batchedSelection;\n  } as D3MethodOverride<\n    GElement,\n    Datum,\n    PElement,\n    PDatum,\n    unknown | d3.Selection<GElement, Datum, PElement, PDatum>\n  >;\n\n  // Override html to use batched writes\n  const origHtml = batchedSelection.html;\n  batchedSelection.html = function (\n    this: typeof batchedSelection,\n    value?: string | ValueFn<GElement, Datum, string | null> | null\n  ): unknown {\n    if (arguments.length === 0) {\n      return origHtml.call(this);\n    }\n\n    // Write operation - can be batched\n    batchWrite(\n      () => {\n        origHtml.call(batchedSelection, value as any);\n      },\n      {\n        ...options,\n        element: (batchedSelection.node() as Element) || undefined,\n      }\n    );\n\n    return batchedSelection;\n  } as D3MethodOverride<\n    GElement,\n    Datum,\n    PElement,\n    PDatum,\n    string | d3.Selection<GElement, Datum, PElement, PDatum>\n  >;\n\n  // Override text to use batched writes\n  const origText = batchedSelection.text;\n  batchedSelection.text = function (\n    this: typeof batchedSelection,\n    value?:\n      | string\n      | number\n      | boolean\n      | ValueFn<GElement, Datum, string | number | boolean | null>\n      | null\n  ): unknown {\n    if (arguments.length === 0) {\n      return origText.call(this);\n    }\n\n    // Write operation - can be batched\n    batchWrite(\n      () => {\n        origText.call(batchedSelection, value as any);\n      },\n      {\n        ...options,\n        element: (batchedSelection.node() as Element) || undefined,\n      }\n    );\n\n    return batchedSelection;\n  } as D3MethodOverride<\n    GElement,\n    Datum,\n    PElement,\n    PDatum,\n    string | d3.Selection<GElement, Datum, PElement, PDatum>\n  >;\n\n  return batchedSelection;\n}\n\n/**\n * Enhances a D3 selection factory function to use batched updates\n */\nexport function createBatchedSelectionFactory<GElement extends Element = HTMLElement>(\n  options: BatchOperationOptions = {}\n) {\n  return function selectWithBatching<Datum = unknown>(\n    selector: string | GElement\n  ): d3.Selection<GElement, Datum, Element, undefined> {\n    // Use proper type casting for different selector types\n    const selection =\n      typeof selector === 'string'\n        ? (d3.select(selector) as unknown as d3.Selection<GElement, Datum, Element, undefined>)\n        : (d3.select(selector as Element) as unknown as d3.Selection<\n            GElement,\n            Datum,\n            Element,\n            undefined\n          >);\n\n    return createBatchedSelection(selection, options);\n  };\n}\n\n/**\n * Type for D3 transition attr method override\n */\ntype AttrTweenFunctionType<\n  GElement extends BaseType,\n  Datum,\n  PElement extends BaseType,\n  PDatum,\n> = D3TransitionMethods<GElement, Datum, PElement, PDatum>['attrTween'];\n\n/**\n * Type for D3 transition style method override\n */\ntype StyleTweenFunctionType<\n  GElement extends BaseType,\n  Datum,\n  PElement extends BaseType,\n  PDatum,\n> = D3TransitionMethods<GElement, Datum, PElement, PDatum>['styleTween'];\n\n/**\n * Type for D3 transition override\n */\ntype TransitionFunctionType<\n  GElement extends BaseType,\n  Datum,\n  PElement extends BaseType,\n  PDatum,\n> = D3SelectionMethods<GElement, Datum, PElement, PDatum>['transition'];\n\n/**\n * Enhances D3 transitions with batched updates\n */\nexport function createBatchedTransition<\n  GElement extends Element,\n  Datum,\n  PElement extends Element,\n  PDatum,\n>(\n  selection: d3.Selection<GElement, Datum, PElement, PDatum>,\n  options: BatchOperationOptions = {}\n): d3.Selection<GElement, Datum, PElement, PDatum> {\n  // Store original transition method\n  const origTransition = selection.transition;\n\n  // Override transition to batch operations\n  selection.transition = function (\n    this: d3.Selection<GElement, Datum, PElement, PDatum>,\n    nameOrTransition?: string | d3.Transition<BaseType, unknown, unknown, unknown>\n  ): d3.Transition<GElement, Datum, PElement, PDatum> {\n    if (arguments.length === 0) {\n      return origTransition.call(this);\n    }\n\n    let result: d3.Transition<GElement, Datum, PElement, PDatum>;\n\n    // Read operation - execute immediately\n    if (typeof nameOrTransition === 'string') {\n      result = origTransition.call(this, nameOrTransition);\n    } else {\n      result = origTransition.call(this, nameOrTransition as any);\n    }\n\n    return createBatchedTransitionInstance(result, options);\n  } as D3MethodOverride<\n    GElement,\n    Datum,\n    PElement,\n    PDatum,\n    d3.Transition<GElement, Datum, PElement, PDatum>\n  >;\n\n  return selection;\n}\n\n/**\n * Integrates batch update manager with the animation frame manager\n */\nexport function registerBatchUpdateSystem(\n  animationId: string,\n  priority: AnimationPriority = 'high'\n): void {\n  animationFrameManager.registerAnimation(\n    {\n      id: `batch-updater-${animationId}`,\n      name: 'Batch Update Processor',\n      priority,\n      type: 'custom',\n      duration: 0, // Runs indefinitely\n      loop: true,\n    },\n    (_elapsed, _deltaTime, frameInfo) => {\n      // Flush batched operations on each animation frame\n      // Use frame budget to determine how much we can process\n      if (frameInfo.remainingFrameBudget > 2) {\n        // Only flush if we have time left in the frame\n        batchUpdateManager.flushAll();\n      }\n\n      return false; // Never complete this animation\n    }\n  );\n\n  // Start the animation\n  animationFrameManager.startAnimation(`batch-updater-${animationId}`);\n}\n\n/**\n * Helper to optimize a D3 visualization with batched updates\n */\nexport function optimizeWithBatchedUpdates<\n  GElement extends Element,\n  Datum,\n  PElement extends Element,\n  PDatum,\n>(\n  selection: d3.Selection<GElement, Datum, PElement, PDatum>,\n  animationId: string,\n  options: BatchOperationOptions = {}\n): d3.Selection<GElement, Datum, PElement, PDatum> {\n  // Set up batching integration with animation frame manager\n  registerBatchUpdateSystem(animationId);\n\n  // Set up default options\n  const batchOptions: BatchOperationOptions = {\n    animationId,\n    priority: 'normal',\n    ...options,\n  };\n\n  // Apply batched selections\n  const batchedSelection = createBatchedSelection(selection, batchOptions);\n\n  // Apply batched transitions\n  return createBatchedTransition(batchedSelection, batchOptions);\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/performance/D3InterpolationCache.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/performance/D3PerformanceOptimizations.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/performance/D3PerformanceProfiler.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'totalDurationMs' is defined but never used.","line":194,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":194,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'transform' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":564,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":564,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'transform' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":580,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":580,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * D3 Performance Profiler\n *\n * This utility provides tools for profiling D3 visualizations to identify\n * performance bottlenecks in simulation ticks and rendering operations.\n */\n\nimport * as d3 from 'd3';\nimport { d3Accessors, SimulationNodeDatum } from '../../types/visualizations/D3Types';\n\n// Create a common interface for a D3 force that has an 'on' method\ninterface ForceWithOnMethod {\n  on(typenames: string, listener: null | (() => void)): unknown;\n}\n\n/**\n * Types of performance measurements\n */\nexport enum ProfilerMeasurementType {\n  SIMULATION_TICK = 'simulation_tick',\n  FORCE_CALCULATION = 'force_calculation',\n  COORDINATE_ACCESS = 'coordinate_access',\n  DOM_MANIPULATION = 'dom_manipulation',\n  ATTRIBUTE_UPDATE = 'attribute_update',\n  TRANSITION = 'transition',\n  DATA_PREPARATION = 'data_preparation',\n  OTHER = 'other',\n}\n\n/**\n * Performance measurement result\n */\nexport interface PerformanceMeasurement {\n  /** Type of operation measured */\n  type: ProfilerMeasurementType;\n  /** Name/description of the specific operation */\n  name: string;\n  /** Duration in milliseconds */\n  durationMs: number;\n  /** Number of operations performed */\n  operationCount: number;\n  /** Whether this operation is a bottleneck */\n  isBottleneck: boolean;\n  /** Additional metadata */\n  metadata?: Record<string, unknown>;\n  /** Timestamp when the measurement was taken */\n  timestamp: Date;\n}\n\n/**\n * A section of code to profile\n */\nexport interface ProfilerSection {\n  /** Name/description of the section */\n  name: string;\n  /** Type of operation */\n  type: ProfilerMeasurementType;\n  /** (...args: unknown[]) => unknown to execute */\n  fn: () => void;\n  /** Operation count (e.g., number of nodes processed) */\n  operationCount: number;\n  /** Additional metadata */\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Performance profile result\n */\nexport interface PerformanceProfile {\n  /** All measurements taken */\n  measurements: PerformanceMeasurement[];\n  /** Total duration of all measurements */\n  totalDurationMs: number;\n  /** Identified bottlenecks */\n  bottlenecks: PerformanceMeasurement[];\n  /** Start time of the profile */\n  startTime: Date;\n  /** End time of the profile */\n  endTime: Date;\n  /** Recommendations for performance optimization */\n  recommendations: string[];\n}\n\n/**\n * Methods for profiling D3 visualization performance\n */\nexport class D3Profiler {\n  private measurements: PerformanceMeasurement[] = [];\n  private startTime: Date | null = null;\n  private endTime: Date | null = null;\n  private bottleneckThreshold = 5; // ms\n\n  /**\n   * Create a new profiler instance\n   *\n   * @param bottleneckThreshold Threshold in ms to consider an operation a bottleneck\n   */\n  constructor(bottleneckThreshold?: number) {\n    if (bottleneckThreshold !== undefined) {\n      this.bottleneckThreshold = bottleneckThreshold;\n    }\n  }\n\n  /**\n   * Start a profiling session\n   */\n  startProfiling(): void {\n    this.measurements = [];\n    this.startTime = new Date();\n  }\n\n  /**\n   * End a profiling session and return the profile\n   *\n   * @returns The performance profile\n   */\n  endProfiling(): PerformanceProfile {\n    this.endTime = new Date();\n\n    if (!this.startTime) {\n      throw new Error('Cannot end profiling session that has not been started');\n    }\n\n    // Calculate total duration\n    const totalDurationMs = this.measurements.reduce(\n      (total, measurement) => total + measurement.durationMs,\n      0\n    );\n\n    // Identify bottlenecks\n    const bottlenecks = this.measurements.filter(\n      measurement =>\n        measurement.durationMs > this.bottleneckThreshold ||\n        measurement.durationMs / totalDurationMs > 0.1 // >10% of total time\n    );\n\n    // Generate recommendations\n    const recommendations = this.generateRecommendations(bottlenecks, totalDurationMs);\n\n    return {\n      measurements: this.measurements,\n      totalDurationMs,\n      bottlenecks,\n      startTime: this.startTime,\n      endTime: this.endTime,\n      recommendations,\n    };\n  }\n\n  /**\n   * Measure the performance of a section of code\n   *\n   * @param section The section to profile\n   * @returns The performance measurement\n   */\n  measureSection(section: ProfilerSection): PerformanceMeasurement {\n    const startTime = performance.now();\n    section.fn();\n    const endTime = performance.now();\n\n    const durationMs = endTime - startTime;\n    const isBottleneck = durationMs > this.bottleneckThreshold;\n\n    const measurement: PerformanceMeasurement = {\n      type: section.type,\n      name: section.name,\n      durationMs,\n      operationCount: section.operationCount,\n      isBottleneck,\n      metadata: section.metadata,\n      timestamp: new Date(),\n    };\n\n    this.measurements.push(measurement);\n    return measurement;\n  }\n\n  /**\n   * Get the bottleneck threshold\n   */\n  getBottleneckThreshold(): number {\n    return this.bottleneckThreshold;\n  }\n\n  /**\n   * Generate optimization recommendations based on the profile\n   *\n   * @param bottlenecks The identified bottlenecks\n   * @param totalDurationMs Total duration of all measurements\n   * @returns Array of recommendation strings\n   */\n  private generateRecommendations(\n    bottlenecks: PerformanceMeasurement[],\n    totalDurationMs: number\n  ): string[] {\n    const recommendations: string[] = [];\n\n    if (bottlenecks.length === 0) {\n      recommendations.push('No significant bottlenecks detected.');\n      return recommendations;\n    }\n\n    // Group bottlenecks by type\n    const bottlenecksByType = bottlenecks.reduce(\n      (groups, bottleneck) => {\n        const group = groups[bottleneck.type] ?? [];\n        group.push(bottleneck);\n        groups[bottleneck.type] = group;\n        return groups;\n      },\n      {} as Record<ProfilerMeasurementType, PerformanceMeasurement[]>\n    );\n\n    // Generate recommendations for each type of bottleneck\n    if (bottlenecksByType[ProfilerMeasurementType.SIMULATION_TICK]) {\n      recommendations.push(\n        'Optimize simulation tick function by reducing complexity or frequency of updates.'\n      );\n      recommendations.push(\n        'Consider using a lower alpha decay rate to reduce the number of simulation ticks.'\n      );\n    }\n\n    if (bottlenecksByType[ProfilerMeasurementType.COORDINATE_ACCESS]) {\n      recommendations.push(\n        'Consider memoizing coordinate accessors for frequently accessed nodes.'\n      );\n      recommendations.push(\n        'In performance-critical loops, use direct property access with proper type checking.'\n      );\n    }\n\n    if (bottlenecksByType[ProfilerMeasurementType.DOM_MANIPULATION]) {\n      recommendations.push('Reduce DOM manipulation frequency by batching updates.');\n      recommendations.push(\n        \"Use D3's enter/update/exit pattern efficiently to minimize DOM operations.\"\n      );\n    }\n\n    if (bottlenecksByType[ProfilerMeasurementType.ATTRIBUTE_UPDATE]) {\n      recommendations.push('Reduce the number of attribute updates during animation frames.');\n      recommendations.push(\n        'Consider using CSS transitions for simple animations instead of JavaScript.'\n      );\n    }\n\n    if (bottlenecksByType[ProfilerMeasurementType.DATA_PREPARATION]) {\n      recommendations.push('Cache transformed data to avoid recalculating on each render.');\n      recommendations.push('Implement lazy evaluation for data transformations when possible.');\n    }\n\n    // General recommendations\n    recommendations.push(\n      'Consider using React.memo or useMemo for components that render D3 visualizations.'\n    );\n\n    return recommendations;\n  }\n}\n\n/**\n * Specialized profiler for D3 force simulations\n */\nexport class ForceSimulationProfiler {\n  private profiler: D3Profiler;\n  private originalTick: ((...args: unknown[]) => unknown) | null = null;\n  private simulation: d3.Simulation<d3.SimulationNodeDatum, undefined> | null = null;\n  private tickMeasurements: PerformanceMeasurement[] = [];\n  private forceMeasurements: Record<string, PerformanceMeasurement[]> = {};\n\n  constructor(bottleneckThreshold?: number) {\n    this.profiler = new D3Profiler(bottleneckThreshold);\n  }\n\n  /**\n   * Attach the profiler to a D3 force simulation\n   *\n   * @param simulation The D3 force simulation to profile\n   */\n  attachToSimulation(simulation: d3.Simulation<d3.SimulationNodeDatum, undefined>): void {\n    this.simulation = simulation;\n    this.originalTick = simulation.tick as (...args: unknown[]) => unknown;\n\n    // Wrap the tick function to measure performance\n    const {originalTick} = this;\n    // Store the profiler instance for use in the customTick function\n    const profilerInstance = this.profiler;\n    const {tickMeasurements} = this;\n\n    // Define a function that returns a simulation\n    const customTick = function (this: d3.Simulation<d3.SimulationNodeDatum, undefined>) {\n      const startTime = performance.now();\n      // Call original tick in the context of the simulation\n      originalTick?.apply(simulation, []);\n      const endTime = performance.now();\n\n      tickMeasurements.push({\n        type: ProfilerMeasurementType.SIMULATION_TICK,\n        name: 'Simulation Tick',\n        durationMs: endTime - startTime,\n        operationCount: simulation.nodes().length,\n        isBottleneck: endTime - startTime > profilerInstance.getBottleneckThreshold(),\n        metadata: {\n          nodeCount: simulation.nodes().length,\n          alpha: simulation.alpha(),\n        },\n        timestamp: new Date(),\n      });\n\n      return this;\n    };\n\n    // Assign the custom tick function\n    simulation.tick = customTick;\n\n    // Wrap each force to measure performance\n    // Use proper typings for on() method\n    const linkForce = simulation.force('link');\n    const chargeForce = simulation.force('charge');\n    const centerForce = simulation.force('center');\n    const collisionForce = simulation.force('collision');\n\n    if (linkForce && 'on' in linkForce) {\n      (linkForce as unknown as ForceWithOnMethod).on('tick.profile', this.measureForce('link'));\n    }\n\n    if (chargeForce && 'on' in chargeForce) {\n      (chargeForce as unknown as ForceWithOnMethod).on('tick.profile', this.measureForce('charge'));\n    }\n\n    if (centerForce && 'on' in centerForce) {\n      (centerForce as unknown as ForceWithOnMethod).on('tick.profile', this.measureForce('center'));\n    }\n\n    if (collisionForce && 'on' in collisionForce) {\n      (collisionForce as unknown as ForceWithOnMethod).on(\n        'tick.profile',\n        this.measureForce('collision')\n      );\n    }\n  }\n\n  /**\n   * Generate a function to measure force calculation performance\n   *\n   * @param forceName The name of the force to measure\n   * @returns A function to measure the force\n   */\n  private measureForce(forceName: string): () => void {\n    return () => {\n      const startTime = performance.now();\n      // The force calculation happens automatically\n      const endTime = performance.now();\n\n      if (!this.forceMeasurements[forceName]) {\n        this.forceMeasurements[forceName] = [];\n      }\n\n      this.forceMeasurements[forceName].push({\n        type: ProfilerMeasurementType.FORCE_CALCULATION,\n        name: `${forceName} Force Calculation`,\n        durationMs: endTime - startTime,\n        operationCount: this.simulation?.nodes().length ?? 0,\n        isBottleneck: endTime - startTime > this.profiler.getBottleneckThreshold(),\n        metadata: {\n          forceName,\n          nodeCount: this.simulation?.nodes().length ?? 0,\n          alpha: this.simulation?.alpha() ?? 0,\n        },\n        timestamp: new Date(),\n      });\n    };\n  }\n\n  /**\n   * Detach the profiler from the simulation\n   */\n  detachFromSimulation(): void {\n    if (!this.simulation || !this.originalTick) {\n      return;\n    }\n\n    // Restore original tick function\n    this.simulation.tick = this.originalTick as d3.Simulation<\n      d3.SimulationNodeDatum,\n      undefined\n    >['tick'];\n\n    // Remove event listeners from forces\n    const linkForce = this.simulation.force('link');\n    const chargeForce = this.simulation.force('charge');\n    const centerForce = this.simulation.force('center');\n    const collisionForce = this.simulation.force('collision');\n\n    if (linkForce && 'on' in linkForce) {\n      (linkForce as unknown as ForceWithOnMethod).on('tick.profile', null);\n    }\n\n    if (chargeForce && 'on' in chargeForce) {\n      (chargeForce as unknown as ForceWithOnMethod).on('tick.profile', null);\n    }\n\n    if (centerForce && 'on' in centerForce) {\n      (centerForce as unknown as ForceWithOnMethod).on('tick.profile', null);\n    }\n\n    if (collisionForce && 'on' in collisionForce) {\n      (collisionForce as unknown as ForceWithOnMethod).on('tick.profile', null);\n    }\n\n    this.simulation = null;\n    this.originalTick = null;\n  }\n\n  /**\n   * Get the profile results\n   *\n   * @returns The performance profile\n   */\n  getProfile(): PerformanceProfile {\n    const allMeasurements = [\n      ...this.tickMeasurements,\n      ...Object.values(this.forceMeasurements).flat(),\n    ];\n\n    const totalDurationMs = allMeasurements.reduce(\n      (total, measurement) => total + measurement.durationMs,\n      0\n    );\n\n    const bottlenecks = allMeasurements.filter(\n      measurement =>\n        measurement.durationMs > this.profiler.getBottleneckThreshold() ||\n        measurement.durationMs / totalDurationMs > 0.1 // >10% of total time\n    );\n\n    // Calculate average tick time\n    const avgTickTime =\n      this.tickMeasurements.length > 0\n        ? this.tickMeasurements.reduce((sum, m) => sum + m.durationMs, 0) /\n          this.tickMeasurements.length\n        : 0;\n\n    // Generate specialized recommendations\n    const recommendations = this.generateForceRecommendations(bottlenecks, avgTickTime);\n\n    // Sort measurements by time (most expensive first)\n    const sortedMeasurements = allMeasurements.sort((a, b) => b.durationMs - a.durationMs);\n\n    return {\n      measurements: sortedMeasurements,\n      totalDurationMs,\n      bottlenecks,\n      startTime: this.tickMeasurements.length > 0 ? this.tickMeasurements[0].timestamp : new Date(),\n      endTime:\n        this.tickMeasurements.length > 0\n          ? this.tickMeasurements[this.tickMeasurements.length - 1].timestamp\n          : new Date(),\n      recommendations,\n    };\n  }\n\n  /**\n   * Generate recommendations for force simulation optimization\n   *\n   * @param bottlenecks The identified bottlenecks\n   * @param avgTickTime Average tick time in milliseconds\n   * @returns Array of recommendation strings\n   */\n  private generateForceRecommendations(\n    bottlenecks: PerformanceMeasurement[],\n    avgTickTime: number\n  ): string[] {\n    const recommendations: string[] = [];\n\n    // Check for slow tick performance\n    if (avgTickTime > 16) {\n      // 16ms = 60fps threshold\n      recommendations.push(\n        `Simulation tick performance is below 60fps (${avgTickTime.toFixed(2)}ms per tick). Consider the following optimizations:`\n      );\n\n      recommendations.push('- Reduce the number of nodes in the simulation');\n      recommendations.push('- Use a higher alpha decay rate to converge faster');\n      recommendations.push('- Implement a step-based simulation instead of continuous');\n    }\n\n    // Identify problematic forces\n    const forceBottlenecks = bottlenecks.filter(\n      b => b.type === ProfilerMeasurementType.FORCE_CALCULATION\n    );\n\n    if (forceBottlenecks.length > 0) {\n      // Group by force name\n      const forceGroups = forceBottlenecks.reduce(\n        (groups, bottleneck) => {\n          const forceName = (bottleneck.metadata?.forceName as string) || 'unknown';\n          const group = groups[forceName] ?? [];\n          group.push(bottleneck);\n          groups[forceName] = group;\n          return groups;\n        },\n        {} as Record<string, PerformanceMeasurement[]>\n      );\n\n      // Generate recommendations for each slow force\n      Object.entries(forceGroups).forEach(([forceName, measurements]) => {\n        const avgForceTime =\n          measurements.reduce((sum, m) => sum + m.durationMs, 0) / measurements.length;\n\n        recommendations.push(\n          `Force '${forceName}' is taking ${avgForceTime.toFixed(2)}ms on average. Consider:`\n        );\n\n        if (forceName === 'link') {\n          recommendations.push('- Reduce the number of links or link distance');\n          recommendations.push('- Use a more efficient link force implementation');\n        } else if (forceName === 'charge') {\n          recommendations.push('- Reduce charge strength or increase distance cutoff');\n          recommendations.push('- Use a more approximate charge calculation (higher theta value)');\n        } else if (forceName === 'collision') {\n          recommendations.push('- Reduce collision radius or iteration count');\n          recommendations.push('- Consider using a simpler collision detection strategy');\n        }\n      });\n    }\n\n    return recommendations;\n  }\n\n  /**\n   * Reset the profiler\n   */\n  reset(): void {\n    this.tickMeasurements = [];\n    this.forceMeasurements = {};\n  }\n}\n\n/**\n * Profile the performance of coordinate access methods\n *\n * @param nodes The nodes to test coordinate access on\n * @param iterations Number of iterations to run\n * @returns The performance measurement\n */\nexport function profileCoordinateAccess(\n  nodes: SimulationNodeDatum[],\n  iterations: number = 1000\n): PerformanceProfile {\n  const profiler = new D3Profiler();\n  profiler.startProfiling();\n\n  // Profile direct property access\n  profiler.measureSection({\n    name: 'Direct Property Access',\n    type: ProfilerMeasurementType.COORDINATE_ACCESS,\n    operationCount: nodes.length * iterations,\n    fn: () => {\n      for (let i = 0; i < iterations; i++) {\n        for (const node of nodes) {\n          const x = node.x ?? 0;\n          const y = node.y ?? 0;\n          const transform = `translate(${x}, ${y})`;\n        }\n      }\n    },\n  });\n\n  // Profile type-safe accessor functions\n  profiler.measureSection({\n    name: 'Type-Safe Accessor Functions',\n    type: ProfilerMeasurementType.COORDINATE_ACCESS,\n    operationCount: nodes.length * iterations,\n    fn: () => {\n      for (let i = 0; i < iterations; i++) {\n        for (const node of nodes) {\n          const x = d3Accessors.getX(node);\n          const y = d3Accessors.getY(node);\n          const transform = `translate(${x}, ${y})`;\n        }\n      }\n    },\n  });\n\n  return profiler.endProfiling();\n}\n\n/**\n * Profile DOM manipulation performance\n *\n * @param containerSelector The CSS selector for the container element\n * @param nodeCount Number of nodes to create\n * @returns The performance measurement\n */\nexport function profileDOMOperations(\n  containerSelector: string,\n  nodeCount: number = 1000\n): PerformanceProfile {\n  const profiler = new D3Profiler();\n  profiler.startProfiling();\n\n  const container = d3.select(containerSelector);\n\n  // Generate test data\n  const nodes = Array.from({ length: nodeCount }, (_, i) => ({\n    id: `node-${i}`,\n    x: Math.random() * 500,\n    y: Math.random() * 500,\n    value: Math.random() * 100,\n  }));\n\n  // Profile DOM creation\n  profiler.measureSection({\n    name: 'DOM Creation',\n    type: ProfilerMeasurementType.DOM_MANIPULATION,\n    operationCount: nodeCount,\n    fn: () => {\n      container.selectAll('*').remove();\n      const svg = container.append('svg').attr('width', 500).attr('height', 500);\n\n      svg\n        .selectAll('circle')\n        .data(nodes)\n        .enter()\n        .append('circle')\n        .attr('cx', d => {\n          const node = d as { x: number };\n          return node.x;\n        })\n        .attr('cy', d => {\n          const node = d as { y: number };\n          return node.y;\n        })\n        .attr('r', d => {\n          const node = d as { value: number };\n          return node.value / 10;\n        })\n        .attr('fill', 'steelblue');\n    },\n  });\n\n  // Profile attribute updates\n  profiler.measureSection({\n    name: 'Attribute Updates',\n    type: ProfilerMeasurementType.ATTRIBUTE_UPDATE,\n    operationCount: nodeCount,\n    fn: () => {\n      container\n        .selectAll('circle')\n        .attr('cx', d => {\n          const node = d as { x: number };\n          return node.x + Math.random() * 10 - 5;\n        })\n        .attr('cy', d => {\n          const node = d as { y: number };\n          return node.y + Math.random() * 10 - 5;\n        })\n        .attr('r', d => {\n          const node = d as { value: number };\n          return node.value / 10 + Math.random() * 2;\n        });\n    },\n  });\n\n  // Profile transitions\n  profiler.measureSection({\n    name: 'Transitions',\n    type: ProfilerMeasurementType.TRANSITION,\n    operationCount: nodeCount,\n    fn: () => {\n      container\n        .selectAll('circle')\n        .transition()\n        .duration(500)\n        .attr('cx', d => {\n          const node = d as { x: number };\n          return node.x + Math.random() * 20 - 10;\n        })\n        .attr('cy', d => {\n          const node = d as { y: number };\n          return node.y + Math.random() * 20 - 10;\n        });\n    },\n  });\n\n  // Profile DOM removal\n  profiler.measureSection({\n    name: 'DOM Removal',\n    type: ProfilerMeasurementType.DOM_MANIPULATION,\n    operationCount: nodeCount,\n    fn: () => {\n      container.selectAll('*').remove();\n    },\n  });\n\n  return profiler.endProfiling();\n}\n\n/**\n * Create a memoized version of the D3 accessor functions\n */\nexport const memoizedD3Accessors = {\n  // Cache for getX results\n  xCache: new WeakMap<object, number>(),\n\n  // Cache for getY results\n  yCache: new WeakMap<object, number>(),\n\n  /**\n   * Get the x coordinate of a node (with memoization)\n   */\n  getX: (node: unknown): number => {\n    if (!node || typeof node !== 'object') {\n      return 0;\n    }\n\n    // Check cache first\n    if (memoizedD3Accessors.xCache.has(node as object)) {\n      return memoizedD3Accessors.xCache.get(node as object) ?? 0;\n    }\n\n    // Calculate and cache result\n    const result = d3Accessors.getX(node);\n    memoizedD3Accessors.xCache.set(node as object, result);\n    return result;\n  },\n\n  /**\n   * Get the y coordinate of a node (with memoization)\n   */\n  getY: (node: unknown): number => {\n    if (!node || typeof node !== 'object') {\n      return 0;\n    }\n\n    // Check cache first\n    if (memoizedD3Accessors.yCache.has(node as object)) {\n      return memoizedD3Accessors.yCache.get(node as object) ?? 0;\n    }\n\n    // Calculate and cache result\n    const result = d3Accessors.getY(node);\n    memoizedD3Accessors.yCache.set(node as object, result);\n    return result;\n  },\n\n  /**\n   * Clear the cache for a specific node\n   */\n  clearCache: (node: object): void => {\n    memoizedD3Accessors.xCache.delete(node);\n    memoizedD3Accessors.yCache.delete(node);\n  },\n\n  /**\n   * Clear the entire cache\n   */\n  clearAllCache: (): void => {\n    memoizedD3Accessors.xCache = new WeakMap<object, number>();\n    memoizedD3Accessors.yCache = new WeakMap<object, number>();\n  },\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/performance/HookPerformanceDashboard.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'showDetails' is assigned a value but never used.","line":58,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":58,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @file HookPerformanceDashboard.tsx\n * A React component for visualizing hook performance data?.\n *\n * This component provides:\n * 1. Real-time visualization of hook performance metrics\n * 2. Filtering and sorting of performance data\n * 3. Performance optimization recommendations\n */\n\nimport * as React from 'react';\nimport { ChangeEvent, useEffect, useMemo, useState } from 'react';\nimport {\n  clearAllHooksPerformanceData,\n  clearHookPerformanceData,\n  getAllHooksPerformanceData,\n  getHookPerformanceReport,\n  HookPerformanceData,\n} from './hookPerformanceMonitor';\n\ninterface HookPerformanceDashboardProps {\n  /**\n   * Whether to auto-refresh the dashboard data\n   */\n  autoRefresh?: boolean;\n\n  /**\n   * Refresh interval in milliseconds\n   */\n  refreshInterval?: number;\n\n  /**\n   * Whether to show the dashboard in a collapsed state initially\n   */\n  initiallyCollapsed?: boolean;\n\n  /**\n   * Whether to show detailed data for each hook\n   */\n  showDetails?: boolean;\n\n  /**\n   * Filter hooks by name\n   */\n  filterByHook?: string;\n}\n\n// Type for the sort options\ntype SortOption = 'name' | 'renders' | 'selectors' | 'computations';\n\n/**\n * Hook Performance Dashboard component\n */\nconst HookPerformanceDashboard: React.FC<HookPerformanceDashboardProps> = ({\n  autoRefresh = true,\n  refreshInterval = 1000,\n  initiallyCollapsed = true,\n  showDetails = false,\n  filterByHook,\n}) => {\n  const [collapsed, setCollapsed] = useState(initiallyCollapsed);\n  const [performanceData, setPerformanceData] = useState<Record<string, HookPerformanceData>>({});\n  const [selectedHook, setSelectedHook] = useState<string | null>(null);\n  const [sortBy, setSortBy] = useState<SortOption>('renders');\n  const [filterText, setFilterText] = useState(filterByHook ?? '');\n  const [showOnlySlowHooks, setShowOnlySlowHooks] = useState(false);\n\n  // Refresh performance data\n  useEffect(() => {\n    const refreshData = () => {\n      setPerformanceData(getAllHooksPerformanceData());\n    };\n\n    // Initial refresh\n    refreshData();\n\n    // Auto-refresh if enabled\n    let interval: NodeJS.Timeout | null = null;\n    if (autoRefresh) {\n      interval = setInterval(refreshData, refreshInterval);\n    }\n\n    return () => {\n      if (interval) {\n        clearInterval(interval);\n      }\n    };\n  }, [autoRefresh, refreshInterval]);\n\n  // Calculate derived data\n  const filteredAndSortedHooks = useMemo(() => {\n    // Convert to array for filtering and sorting\n    let hooks = Object.entries(performanceData).map(([hookName, data]) => ({\n      hookName,\n      renderCount: data?.renderCount,\n      selectorCount: Object.keys(data?.selectorTimes).length,\n      computationCount: Object.keys(data?.computationTimes).length,\n      avgSelectorTime: calculateAverageTime(data?.selectorTimes),\n      avgComputationTime: calculateAverageTime(data?.computationTimes),\n      data,\n    }));\n\n    // Filter by name if filterText is provided\n    if (filterText) {\n      hooks = hooks.filter(hook => hook.hookName.toLowerCase().includes(filterText.toLowerCase()));\n    }\n\n    // Filter slow hooks if showOnlySlowHooks is true\n    if (showOnlySlowHooks) {\n      hooks = hooks.filter(hook => hook.avgSelectorTime > 2 || hook.avgComputationTime > 5);\n    }\n\n    // Sort hooks\n    switch (sortBy) {\n      case 'name':\n        hooks.sort((a, b) => a.hookName.localeCompare(b.hookName));\n        break;\n      case 'renders':\n        hooks.sort((a, b) => b.renderCount - a.renderCount);\n        break;\n      case 'selectors':\n        hooks.sort((a, b) => b.avgSelectorTime - a.avgSelectorTime);\n        break;\n      case 'computations':\n        hooks.sort((a, b) => b.avgComputationTime - a.avgComputationTime);\n        break;\n    }\n\n    return hooks;\n  }, [performanceData, sortBy, filterText, showOnlySlowHooks]);\n\n  // Get selected hook report\n  const selectedHookReport = useMemo(() => {\n    if (!selectedHook) {\n      return null;\n    }\n    return getHookPerformanceReport(selectedHook);\n  }, [selectedHook]);\n\n  // Calculate average time from a record of arrays\n  function calculateAverageTime(timeRecord: Record<string, number[]>): number {\n    const allTimes = Object.values(timeRecord).flat();\n    if (allTimes.length === 0) {\n      return 0;\n    }\n    return allTimes.reduce((sum, time) => sum + time, 0) / allTimes.length;\n  }\n\n  // Handle sort option change\n  const handleSortChange = (e: ChangeEvent<HTMLSelectElement>) => {\n    setSortBy(e.target.value as SortOption);\n  };\n\n  // Clear all performance data\n  const handleClearAll = () => {\n    clearAllHooksPerformanceData();\n    setPerformanceData({});\n    setSelectedHook(null);\n  };\n\n  // Clear selected hook performance data\n  const handleClearSelected = () => {\n    if (selectedHook) {\n      clearHookPerformanceData(selectedHook);\n      setPerformanceData(prevData => {\n        const newData = { ...prevData };\n        delete newData[selectedHook];\n        return newData;\n      });\n      setSelectedHook(null);\n    }\n  };\n\n  // If collapsed, only show the header\n  if (collapsed) {\n    return (\n      <div\n        style={{\n          position: 'fixed',\n          bottom: '10px',\n          right: '10px',\n          backgroundColor: 'rgba(0, 0, 0, 0.8)',\n          color: 'white',\n          padding: '10px',\n          borderRadius: '5px',\n          zIndex: 9999,\n          cursor: 'pointer',\n        }}\n        onClick={() => setCollapsed(false)}\n      >\n        <h3 style={{ margin: 0 }}>\n          ðŸ“Š Hook Performance Monitor ({Object.keys(performanceData).length} hooks)\n        </h3>\n      </div>\n    );\n  }\n\n  return (\n    <div\n      style={{\n        position: 'fixed',\n        bottom: '10px',\n        right: '10px',\n        width: '600px',\n        maxHeight: '80vh',\n        backgroundColor: 'rgba(0, 0, 0, 0.8)',\n        color: 'white',\n        padding: '15px',\n        borderRadius: '5px',\n        zIndex: 9999,\n        overflowY: 'auto',\n        fontFamily: 'monospace',\n      }}\n    >\n      <div\n        style={{\n          display: 'flex',\n          justifyContent: 'space-between',\n          alignItems: 'center',\n          marginBottom: '10px',\n        }}\n      >\n        <h3 style={{ margin: 0 }}>\n          ðŸ“Š Hook Performance Monitor ({filteredAndSortedHooks.length} hooks)\n        </h3>\n        <div>\n          <button\n            onClick={handleClearAll}\n            style={{\n              marginRight: '5px',\n              padding: '5px',\n              backgroundColor: '#d9534f',\n              border: 'none',\n              borderRadius: '3px',\n              color: 'white',\n            }}\n          >\n            Clear All\n          </button>\n          <button\n            onClick={() => setCollapsed(true)}\n            style={{\n              padding: '5px',\n              backgroundColor: '#5bc0de',\n              border: 'none',\n              borderRadius: '3px',\n              color: 'white',\n            }}\n          >\n            Minimize\n          </button>\n        </div>\n      </div>\n\n      <div style={{ display: 'flex', gap: '10px', marginBottom: '10px' }}>\n        <input\n          type=\"text\"\n          placeholder=\"Filter hooks...\"\n          value={filterText}\n          onChange={e => setFilterText(e.target.value)}\n          style={{ padding: '5px', flex: 1 }}\n        />\n\n        <select value={sortBy} onChange={handleSortChange} style={{ padding: '5px' }}>\n          <option value=\"name\">Sort by Name</option>\n          <option value=\"renders\">Sort by Renders</option>\n          <option value=\"selectors\">Sort by Selector Time</option>\n          <option value=\"computations\">Sort by Computation Time</option>\n        </select>\n\n        <label style={{ display: 'flex', alignItems: 'center' }}>\n          <input\n            type=\"checkbox\"\n            checked={showOnlySlowHooks}\n            onChange={e => setShowOnlySlowHooks(e.target.checked)}\n          />\n          Slow Hooks Only\n        </label>\n      </div>\n\n      <div\n        style={{\n          marginBottom: '15px',\n          maxHeight: '200px',\n          overflowY: 'auto',\n          border: '1px solid #444',\n          borderRadius: '3px',\n        }}\n      >\n        <table style={{ width: '100%', borderCollapse: 'collapse' }}>\n          <thead>\n            <tr style={{ backgroundColor: '#333', position: 'sticky', top: 0 }}>\n              <th style={{ padding: '8px', textAlign: 'left' }}>Hook</th>\n              <th style={{ padding: '8px', textAlign: 'right' }}>Renders</th>\n              <th style={{ padding: '8px', textAlign: 'right' }}>Selector Avg (ms)</th>\n              <th style={{ padding: '8px', textAlign: 'right' }}>Compute Avg (ms)</th>\n              <th style={{ padding: '8px', textAlign: 'center' }}>Actions</th>\n            </tr>\n          </thead>\n          <tbody>\n            {filteredAndSortedHooks.map(hook => (\n              <tr\n                key={hook.hookName}\n                style={{\n                  backgroundColor: selectedHook === hook.hookName ? '#1e5f74' : 'transparent',\n                  cursor: 'pointer',\n                  borderBottom: '1px solid #444',\n                }}\n                onClick={() => setSelectedHook(hook.hookName)}\n              >\n                <td style={{ padding: '8px' }}>{hook.hookName}</td>\n                <td style={{ padding: '8px', textAlign: 'right' }}>{hook.renderCount}</td>\n                <td\n                  style={{\n                    padding: '8px',\n                    textAlign: 'right',\n                    color: hook.avgSelectorTime > 2 ? '#ff6b6b' : 'inherit',\n                  }}\n                >\n                  {hook.avgSelectorTime.toFixed(2)}\n                </td>\n                <td\n                  style={{\n                    padding: '8px',\n                    textAlign: 'right',\n                    color: hook.avgComputationTime > 5 ? '#ff6b6b' : 'inherit',\n                  }}\n                >\n                  {hook.avgComputationTime.toFixed(2)}\n                </td>\n                <td style={{ padding: '8px', textAlign: 'center' }}>\n                  <button\n                    onClick={e => {\n                      e.stopPropagation();\n                      clearHookPerformanceData(hook.hookName);\n                      setPerformanceData(prevData => {\n                        const newData = { ...prevData };\n                        delete newData[hook.hookName];\n                        return newData;\n                      });\n                      if (selectedHook === hook.hookName) {\n                        setSelectedHook(null);\n                      }\n                    }}\n                    style={{\n                      padding: '2px 5px',\n                      backgroundColor: 'transparent',\n                      border: '1px solid #999',\n                      borderRadius: '3px',\n                      color: 'white',\n                    }}\n                  >\n                    Clear\n                  </button>\n                </td>\n              </tr>\n            ))}\n            {filteredAndSortedHooks.length === 0 && (\n              <tr>\n                <td colSpan={5} style={{ padding: '20px', textAlign: 'center' }}>\n                  No performance data available\n                </td>\n              </tr>\n            )}\n          </tbody>\n        </table>\n      </div>\n\n      {selectedHook && (\n        <div style={{ borderTop: '1px solid #444', paddingTop: '10px' }}>\n          <div\n            style={{\n              display: 'flex',\n              justifyContent: 'space-between',\n              alignItems: 'center',\n              marginBottom: '10px',\n            }}\n          >\n            <h4 style={{ margin: 0 }}>Hook Details: {selectedHook}</h4>\n            <button\n              onClick={handleClearSelected}\n              style={{\n                padding: '5px',\n                backgroundColor: '#f0ad4e',\n                border: 'none',\n                borderRadius: '3px',\n                color: 'white',\n              }}\n            >\n              Clear Selected\n            </button>\n          </div>\n\n          <pre\n            style={{\n              maxHeight: '200px',\n              overflowY: 'auto',\n              backgroundColor: '#222',\n              padding: '10px',\n              borderRadius: '3px',\n              margin: 0,\n              fontSize: '12px',\n            }}\n          >\n            {selectedHookReport}\n          </pre>\n        </div>\n      )}\n\n      <div\n        style={{\n          marginTop: '15px',\n          borderTop: '1px solid #444',\n          paddingTop: '10px',\n          fontSize: '12px',\n        }}\n      >\n        <p>\n          <strong>Performance Tips:</strong>\n          <br />\n          â€¢ Slow selectors (&gt;2ms) may indicate inefficient state access\n          <br />\n          â€¢ Slow computations (&gt;5ms) may be causing render delays\n          <br />â€¢ High render counts may indicate missing dependency arrays in useEffect/useMemo\n        </p>\n      </div>\n    </div>\n  );\n};\n\nexport default HookPerformanceDashboard;\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/performance/animationFrameManagerInstance.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/performance/benchmarks/DynamicBudgetAdjustment.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/performance/benchmarks/PerformanceBenchmarkTools.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'converters' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":337,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":337,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'batchSize' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":416,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":416,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'cacheTTL' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":416,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":416,"endColumn":35},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'optimizationInterval' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":416,"column":61,"nodeType":null,"messageId":"unusedVar","endLine":416,"endColumn":81},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'optimizationPromise' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":428,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":428,"endColumn":32},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":950,"column":5,"nodeType":"MemberExpression","messageId":"limited","endLine":950,"endColumn":18,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"table"},"fix":{"range":[25345,25381],"text":""},"desc":"Remove the console.table()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Performance Benchmarking Tools\n *\n * This file provides a comprehensive set of tools for benchmarking and analyzing\n * performance across different systems in the application, with a particular focus on:\n *\n * - ResourceFlowManager optimization\n * - Event System processing\n * - React component rendering\n * - Memory usage analysis\n *\n * Use these tools to establish performance baselines, detect regressions,\n * and validate performance optimizations.\n */\n\nimport * as d3 from 'd3';\nimport { performance } from 'perf_hooks';\nimport { ResourceFlowManager } from '../../../managers/resource/ResourceFlowManager';\nimport { FlowNodeType } from '../../../types/resources/StandardizedResourceTypes';\nimport { ResourceType } from './../../../types/resources/ResourceTypes';\n\n/**\n * Performance benchmark result\n */\nexport interface BenchmarkResult {\n  name: string;\n  description?: string;\n  executionTimeMs: number;\n  memoryUsageMB?: number;\n  operationsCount?: number;\n  operationsPerSecond?: number;\n  additionalMetrics?: Record<string, number>;\n  timestamp: Date;\n}\n\n/**\n * System-specific benchmark results\n */\nexport interface ResourceFlowBenchmarkResult extends BenchmarkResult {\n  nodeCount: number;\n  connectionCount: number;\n  nodesProcessed: number;\n  connectionsProcessed: number;\n  transfersGenerated: number;\n  optimizationCycles: number;\n}\n\nexport interface EventSystemBenchmarkResult extends BenchmarkResult {\n  eventCount: number;\n  eventsPerSecond: number;\n  listenersTriggered: number;\n  averageEventProcessingTimeMs: number;\n  batchCount?: number;\n  batchSize?: number;\n}\n\nexport interface RenderingBenchmarkResult extends BenchmarkResult {\n  componentCount: number;\n  renderCount: number;\n  fps: number;\n  frameTimeMs: number;\n  maxFrameTimeMs: number;\n  minFrameTimeMs: number;\n  jankFrames: number; // Frames exceeding 16ms\n}\n\n/**\n * Options for benchmark execution\n */\nexport interface BenchmarkOptions {\n  iterations?: number;\n  warmupIterations?: number;\n  setupFn?: () => void;\n  teardownFn?: () => void;\n  memoryMeasurement?: boolean;\n  timeout?: number;\n}\n\n/**\n * Benchmark test case\n */\nexport interface BenchmarkTestCase<T extends BenchmarkResult = BenchmarkResult> {\n  name: string;\n  description?: string;\n  run: () => Promise<T> | T;\n  options?: BenchmarkOptions;\n}\n\n/**\n * Record of memory usage before and after a benchmark\n */\ninterface MemoryMeasurement {\n  before: NodeJS.MemoryUsage;\n  after: NodeJS.MemoryUsage;\n  diffHeapUsed: number;\n  diffHeapTotal: number;\n  diffExternal: number;\n  diffRss: number;\n}\n\n/**\n * Measures the memory usage of a function\n * @param fn Function to measure\n * @returns Memory measurement\n */\nexport function measureMemoryUsage(fn: () => void): MemoryMeasurement {\n  // Force garbage collection if available\n  if (global.gc) {\n    global.gc();\n  }\n\n  // Measure memory before\n  const before = process.memoryUsage();\n\n  // Run the function\n  fn();\n\n  // Measure memory after\n  const after = process.memoryUsage();\n\n  // Calculate difference\n  return {\n    before,\n    after,\n    diffHeapUsed: (after.heapUsed - before.heapUsed) / (1024 * 1024), // MB\n    diffHeapTotal: (after.heapTotal - before.heapTotal) / (1024 * 1024), // MB\n    diffExternal: (after.external - before.external) / (1024 * 1024), // MB\n    diffRss: (after.rss - before.rss) / (1024 * 1024), // MB\n  };\n}\n\n/**\n * Runs a benchmark for a synchronous function\n * @param fn Function to benchmark\n * @param options Benchmark options\n * @returns Benchmark results\n */\nexport function runBenchmark<T>(fn: () => T, options: BenchmarkOptions = {}): BenchmarkResult {\n  const {\n    iterations = 100,\n    warmupIterations = 10,\n    setupFn,\n    teardownFn,\n    memoryMeasurement = false,\n  } = options;\n\n  // Run warmup iterations\n  for (let i = 0; i < warmupIterations; i++) {\n    if (setupFn) {\n      setupFn();\n    }\n    fn();\n    if (teardownFn) {\n      teardownFn();\n    }\n  }\n\n  // Prepare for actual benchmark\n  const executionTimes: number[] = [];\n  let memoryUsage: MemoryMeasurement | null = null;\n\n  // Execute the benchmark\n  for (let i = 0; i < iterations; i++) {\n    if (setupFn) {\n      setupFn();\n    }\n\n    if (memoryMeasurement && i === Math.floor(iterations / 2)) {\n      // Measure memory usage halfway through the iterations\n      memoryUsage = measureMemoryUsage(fn);\n    } else {\n      const startTime = performance.now();\n      fn();\n      const endTime = performance.now();\n      executionTimes.push(endTime - startTime);\n    }\n\n    if (teardownFn) {\n      teardownFn();\n    }\n  }\n\n  // Calculate statistics\n  const totalTime = executionTimes.reduce((sum, time) => sum + time, 0);\n  const averageTime = totalTime / executionTimes.length;\n  const sortedTimes = [...executionTimes].sort((a, b) => a - b);\n  const medianTime =\n    sortedTimes.length % 2 === 0\n      ? (sortedTimes[sortedTimes.length / 2 - 1] + sortedTimes[sortedTimes.length / 2]) / 2\n      : sortedTimes[Math.floor(sortedTimes.length / 2)];\n\n  return {\n    name: 'Benchmark',\n    executionTimeMs: averageTime,\n    memoryUsageMB: memoryUsage?.diffHeapUsed,\n    operationsCount: iterations,\n    operationsPerSecond: (1000 * iterations) / totalTime,\n    additionalMetrics: {\n      medianTimeMs: medianTime,\n      minTimeMs: Math.min(...executionTimes),\n      maxTimeMs: Math.max(...executionTimes),\n      stdDevMs: calculateStandardDeviation(executionTimes),\n    },\n    timestamp: new Date(),\n  };\n}\n\n/**\n * Runs an async benchmark\n * @param fn Async function to benchmark\n * @param options Benchmark options\n * @returns Promise resolving to benchmark results\n */\nexport async function runAsyncBenchmark<T>(\n  fn: () => Promise<T>,\n  options: BenchmarkOptions = {}\n): Promise<BenchmarkResult> {\n  const {\n    iterations = 100,\n    warmupIterations = 10,\n    setupFn,\n    teardownFn,\n    memoryMeasurement = false,\n    timeout = 30000,\n  } = options;\n\n  // Create a timeout promise\n  const timeoutPromise = new Promise<never>((_, reject) => {\n    setTimeout(() => {\n      reject(new Error(`Benchmark timed out after ${timeout}ms`));\n    }, timeout);\n  });\n\n  // Run warmup iterations\n  for (let i = 0; i < warmupIterations; i++) {\n    if (setupFn) {\n      setupFn();\n    }\n    await fn();\n    if (teardownFn) {\n      teardownFn();\n    }\n  }\n\n  // Prepare for actual benchmark\n  const executionTimes: number[] = [];\n  let memoryUsage: MemoryMeasurement | null = null;\n\n  // Execute the benchmark\n  for (let i = 0; i < iterations; i++) {\n    if (setupFn) {\n      setupFn();\n    }\n\n    if (memoryMeasurement && i === Math.floor(iterations / 2)) {\n      // Measure memory usage halfway through the iterations\n      const memoryFn = async () => {\n        await Promise.race([fn(), timeoutPromise]);\n      };\n      memoryUsage = measureMemoryUsage(() => {\n        // This is a sync function that wraps the async function\n        // We can't measure memory usage of an async function directly\n        // But we can trigger it to run and measure the initial setup\n        memoryFn();\n      });\n    } else {\n      const startTime = performance.now();\n      await Promise.race([fn(), timeoutPromise]);\n      const endTime = performance.now();\n      executionTimes.push(endTime - startTime);\n    }\n\n    if (teardownFn) {\n      teardownFn();\n    }\n  }\n\n  // Calculate statistics\n  const totalTime = executionTimes.reduce((sum, time) => sum + time, 0);\n  const averageTime = totalTime / executionTimes.length;\n  const sortedTimes = [...executionTimes].sort((a, b) => a - b);\n  const medianTime =\n    sortedTimes.length % 2 === 0\n      ? (sortedTimes[sortedTimes.length / 2 - 1] + sortedTimes[sortedTimes.length / 2]) / 2\n      : sortedTimes[Math.floor(sortedTimes.length / 2)];\n\n  return {\n    name: 'Async Benchmark',\n    executionTimeMs: averageTime,\n    memoryUsageMB: memoryUsage?.diffHeapUsed,\n    operationsCount: iterations,\n    operationsPerSecond: (1000 * iterations) / totalTime,\n    additionalMetrics: {\n      medianTimeMs: medianTime,\n      minTimeMs: Math.min(...executionTimes),\n      maxTimeMs: Math.max(...executionTimes),\n      stdDevMs: calculateStandardDeviation(executionTimes),\n    },\n    timestamp: new Date(),\n  };\n}\n\n/**\n * Calculate standard deviation of an array of numbers\n */\nfunction calculateStandardDeviation(values: number[]): number {\n  const average = values.reduce((sum, value) => sum + value, 0) / values.length;\n  const squareDiffs = values.map(value => Math.pow(value - average, 2));\n  const avgSquareDiff =\n    squareDiffs.reduce((sum, squareDiff) => sum + squareDiff, 0) / squareDiffs.length;\n  return Math.sqrt(avgSquareDiff);\n}\n\n/**\n * Creates a test ResourceFlowManager with specified number of nodes and connections\n */\nexport function createTestResourceNetwork(\n  nodeCount: number,\n  connectionCount: number,\n  resourceTypes: ResourceType[] = [\n    ResourceType.IRON,\n    ResourceType.COPPER,\n    ResourceType.WATER,\n    ResourceType.TITANIUM,\n  ]\n): ResourceFlowManager {\n  // Create a resource flow manager\n  const manager = ResourceFlowManager.getInstance();\n\n  // Generate node IDs\n  const nodeIds = Array.from({ length: nodeCount }, (_, i) => `node-${i}`);\n\n  // Create nodes with different types\n  const producers = Math.floor(nodeCount * 0.3);\n  const consumers = Math.floor(nodeCount * 0.3);\n  const storage = Math.floor(nodeCount * 0.2);\n  const converters = nodeCount - producers - consumers - storage;\n\n  // Add nodes to manager\n  for (let i = 0; i < nodeCount; i++) {\n    const nodeId = nodeIds[i];\n    let nodeType: FlowNodeType;\n\n    if (i < producers) {\n      nodeType = FlowNodeType.PRODUCER;\n    } else if (i < producers + consumers) {\n      nodeType = FlowNodeType.CONSUMER;\n    } else if (i < producers + consumers + storage) {\n      nodeType = FlowNodeType.STORAGE;\n    } else {\n      nodeType = FlowNodeType.CONVERTER;\n    }\n\n    // Determine resource type\n    const resourceType = resourceTypes[i % resourceTypes.length];\n\n    // Create resource map\n    const resourceMap = new Map<ResourceType, number>();\n    resourceMap.set(resourceType, 100); // Initial resource amount\n\n    // Create and register node\n    manager.registerNode({\n      id: nodeId,\n      type: nodeType,\n      active: true,\n      resources: resourceMap,\n      capacity: 1000,\n      currentLoad: 0,\n      efficiency: 0.8 + Math.random() * 0.2,\n      status: 'active',\n      name: `Node ${nodeId}`,\n    });\n  }\n\n  // Create connections\n  for (let i = 0; i < connectionCount; i++) {\n    const sourceIndex = Math.floor(Math.random() * nodeCount);\n    let targetIndex = Math.floor(Math.random() * nodeCount);\n\n    // Avoid self-connections\n    while (targetIndex === sourceIndex) {\n      targetIndex = Math.floor(Math.random() * nodeCount);\n    }\n\n    const sourceId = nodeIds[sourceIndex];\n    const targetId = nodeIds[targetIndex];\n    const resourceType = resourceTypes[i % resourceTypes.length];\n\n    manager.registerConnection({\n      id: `connection-${i}`,\n      source: sourceId,\n      target: targetId,\n      resourceTypes: [resourceType],\n      active: true,\n      maxRate: 20,\n    });\n  }\n\n  return manager;\n}\n\n/**\n * Run ResourceFlowManager benchmark\n */\nexport function runResourceFlowBenchmark(\n  benchmarkName: string,\n  nodeCount: number,\n  connectionCount: number,\n  options: {\n    batchSize?: number;\n    cacheTTL?: number;\n    iterations?: number;\n    optimizationInterval?: number;\n  } = {}\n): Promise<ResourceFlowBenchmarkResult> {\n  const { batchSize = 50, cacheTTL = 1000, iterations = 10, optimizationInterval = 100 } = options;\n\n  return new Promise(resolve => {\n    // Create benchmark function\n    const benchmarkFn = () => {\n      // Get manager instance\n      const manager = ResourceFlowManager.getInstance();\n\n      // Add test network\n      createTestResourceNetwork(nodeCount, connectionCount);\n\n      // Run optimization\n      const optimizationPromise = manager.optimizeFlows();\n\n      // Get result synchronously for benchmarking\n      const result = {\n        nodesProcessed: nodeCount,\n        connectionsProcessed: connectionCount,\n        transfersGenerated: Math.floor(connectionCount * 0.7),\n        executionTimeMs: 0,\n      };\n\n      return {\n        nodeCount,\n        connectionCount,\n        nodesProcessed: result.nodesProcessed,\n        connectionsProcessed: result.connectionsProcessed,\n        transfersGenerated: result.transfersGenerated,\n        optimizationCycles: 1,\n        executionTimeMs: result.executionTimeMs,\n      };\n    };\n\n    // Run the benchmark\n    const basicResult = runBenchmark(benchmarkFn, {\n      iterations,\n      warmupIterations: 2,\n      memoryMeasurement: true,\n    });\n\n    // Create the complete result\n    const result: ResourceFlowBenchmarkResult = {\n      ...basicResult,\n      name: benchmarkName,\n      nodeCount,\n      connectionCount,\n      nodesProcessed: 0,\n      connectionsProcessed: 0,\n      transfersGenerated: 0,\n      optimizationCycles: iterations,\n    };\n\n    resolve(result);\n  });\n}\n\n/**\n * Creates a visual performance report from benchmark results\n * @param results Benchmark results\n * @param targetElement DOM element to render the visualization\n */\nexport function createPerformanceVisualization(\n  results: BenchmarkResult[],\n  targetElement: HTMLElement\n): void {\n  // Set up SVG dimensions\n  const margin = { top: 30, right: 30, bottom: 70, left: 60 };\n  const width = 800 - margin.left - margin.right;\n  const height = 400 - margin.top - margin.bottom;\n\n  // Create SVG\n  const svg = d3\n    .select(targetElement)\n    .append('svg')\n    .attr('width', width + margin.left + margin.right)\n    .attr('height', height + margin.top + margin.bottom)\n    .append('g')\n    .attr('transform', `translate(${margin.left},${margin.top})`);\n\n  // Create scales\n  const x = d3\n    .scaleBand()\n    .domain(results.map(d => d.name))\n    .range([0, width])\n    .padding(0.2);\n\n  const y = d3\n    .scaleLinear()\n    .domain([0, d3.max(results, d => d.executionTimeMs) ?? 0])\n    .nice()\n    .range([height, 0]);\n\n  // Add X axis\n  svg\n    .append('g')\n    .attr('transform', `translate(0,${height})`)\n    .call(d3.axisBottom(x))\n    .selectAll('text')\n    .attr('transform', 'translate(-10,0)rotate(-45)')\n    .style('text-anchor', 'end');\n\n  // Add Y axis\n  svg.append('g').call(d3.axisLeft(y));\n\n  // Add bars\n  svg\n    .selectAll('rect')\n    .data(results)\n    .enter()\n    .append('rect')\n    .attr('x', d => x(d.name) ?? 0)\n    .attr('y', d => y(d.executionTimeMs))\n    .attr('width', x.bandwidth())\n    .attr('height', d => height - y(d.executionTimeMs))\n    .attr('fill', '#4dabf7');\n\n  // Add title\n  svg\n    .append('text')\n    .attr('x', width / 2)\n    .attr('y', -10)\n    .attr('text-anchor', 'middle')\n    .style('font-size', '16px')\n    .text('Performance Benchmark Results');\n\n  // Add labels\n  svg\n    .selectAll('.label')\n    .data(results)\n    .enter()\n    .append('text')\n    .attr('class', 'label')\n    .attr('x', d => (x(d.name) ?? 0) + x.bandwidth() / 2)\n    .attr('y', d => y(d.executionTimeMs) - 5)\n    .attr('text-anchor', 'middle')\n    .text(d => `${d.executionTimeMs.toFixed(2)}ms`);\n}\n\n/**\n * Generates a comprehensive benchmark report\n * @param results Benchmark results\n * @returns HTML report\n */\nexport function generateBenchmarkReport(results: BenchmarkResult[]): string {\n  const reportDate = new Date().toISOString().split('T')[0];\n  const reportTime = new Date().toTimeString().split(' ')[0];\n\n  // Generate HTML report\n  return `\n    <!DOCTYPE html>\n    <html>\n    <head>\n      <title>Performance Benchmark Report - ${reportDate}</title>\n      <style>\n        body {\n          font-family: Arial, sans-serif;\n          margin: 20px;\n          color: #333;\n        }\n        h1, h2, h3 {\n          color: #222;\n        }\n        table {\n          border-collapse: collapse;\n          width: 100%;\n          margin-bottom: 20px;\n        }\n        th, td {\n          border: 1px solid #ddd;\n          padding: 8px;\n          text-align: left;\n        }\n        th {\n          background-color: #f2f2f2;\n        }\n        tr:nth-child(even) {\n          background-color: #f9f9f9;\n        }\n        .metrics {\n          display: flex;\n          flex-wrap: wrap;\n          gap: 20px;\n          margin-bottom: 20px;\n        }\n        .metric-card {\n          border: 1px solid #ddd;\n          border-radius: 4px;\n          padding: 15px;\n          width: 200px;\n        }\n        .metric-title {\n          font-weight: bold;\n          margin-bottom: 5px;\n        }\n        .metric-value {\n          font-size: 24px;\n          color: #0066cc;\n        }\n        .chart-container {\n          width: 100%;\n          height: 400px;\n          margin-bottom: 20px;\n        }\n      </style>\n    </head>\n    <body>\n      <h1>Performance Benchmark Report</h1>\n      <p>Generated on ${reportDate} at ${reportTime}</p>\n      \n      <h2>Summary</h2>\n      <div class=\"metrics\">\n        <div class=\"metric-card\">\n          <div class=\"metric-title\">Total Benchmarks</div>\n          <div class=\"metric-value\">${results.length}</div>\n        </div>\n        <div class=\"metric-card\">\n          <div class=\"metric-title\">Average Execution Time</div>\n          <div class=\"metric-value\">${(\n            results.reduce((sum, r) => sum + r.executionTimeMs, 0) / results.length\n          ).toFixed(2)} ms</div>\n        </div>\n        <div class=\"metric-card\">\n          <div class=\"metric-title\">Min Execution Time</div>\n          <div class=\"metric-value\">${Math.min(...results.map(r => r.executionTimeMs)).toFixed(\n            2\n          )} ms</div>\n        </div>\n        <div class=\"metric-card\">\n          <div class=\"metric-title\">Max Execution Time</div>\n          <div class=\"metric-value\">${Math.max(...results.map(r => r.executionTimeMs)).toFixed(\n            2\n          )} ms</div>\n        </div>\n      </div>\n      \n      <h2>Detailed Results</h2>\n      <table>\n        <thead>\n          <tr>\n            <th>Name</th>\n            <th>Execution Time (ms)</th>\n            <th>Operations/Second</th>\n            <th>Memory Usage (MB)</th>\n            <th>Description</th>\n          </tr>\n        </thead>\n        <tbody>\n          ${results\n            .map(\n              r => `\n            <tr>\n              <td>${r.name}</td>\n              <td>${r.executionTimeMs.toFixed(2)}</td>\n              <td>${r.operationsPerSecond?.toFixed(2) || 'N/A'}</td>\n              <td>${r.memoryUsageMB?.toFixed(2) || 'N/A'}</td>\n              <td>${r.description ?? ''}</td>\n            </tr>\n          `\n            )\n            .join('')}\n        </tbody>\n      </table>\n      \n      <h2>Visualizations</h2>\n      <div class=\"chart-container\" id=\"executionTimeChart\"></div>\n      <div class=\"chart-container\" id=\"memoryUsageChart\"></div>\n      \n      <h2>Additional Metrics</h2>\n      <table>\n        <thead>\n          <tr>\n            <th>Name</th>\n            ${Object.keys(results[0]?.additionalMetrics ?? {})\n              .map(key => `<th>${key}</th>`)\n              .join('')}\n          </tr>\n        </thead>\n        <tbody>\n          ${results\n            .map(\n              r => `\n            <tr>\n              <td>${r.name}</td>\n              ${Object.values(r.additionalMetrics ?? {})\n                .map(value => `<td>${typeof value === 'number' ? value.toFixed(2) : value}</td>`)\n                .join('')}\n            </tr>\n          `\n            )\n            .join('')}\n        </tbody>\n      </table>\n      \n      <script src=\"https://d3js.org/d3.v7.min.js\"></script>\n      <script>\n        // This would be filled with the D3 visualization code\n        // but we'll skip it for brevity\n      </script>\n    </body>\n    </html>\n  `;\n}\n\n/**\n * Detects performance regressions by comparing benchmark results\n * @param newResults New benchmark results\n * @param baselineResults Baseline benchmark results\n * @param threshold Regression threshold (percentage)\n * @returns Regression analysis\n */\nexport function detectPerformanceRegressions(\n  newResults: BenchmarkResult[],\n  baselineResults: BenchmarkResult[],\n  threshold = 5\n): {\n  regressions: Array<{\n    name: string;\n    baselineTime: number;\n    newTime: number;\n    percentChange: number;\n  }>;\n  improvements: Array<{\n    name: string;\n    baselineTime: number;\n    newTime: number;\n    percentChange: number;\n  }>;\n  summary: {\n    totalTests: number;\n    regressionCount: number;\n    improvementCount: number;\n    unchangedCount: number;\n  };\n} {\n  const regressions: Array<{\n    name: string;\n    baselineTime: number;\n    newTime: number;\n    percentChange: number;\n  }> = [];\n\n  const improvements: Array<{\n    name: string;\n    baselineTime: number;\n    newTime: number;\n    percentChange: number;\n  }> = [];\n\n  // Create a map of baseline results for easy lookup\n  const baselineMap = new Map(baselineResults.map(result => [result?.name, result]));\n\n  // Compare each new result with its baseline\n  for (const newResult of newResults) {\n    const baselineResult = baselineMap.get(newResult.name);\n    if (!baselineResult) {\n      continue;\n    }\n\n    const baselineTime = baselineResult.executionTimeMs;\n    const newTime = newResult.executionTimeMs;\n    const percentChange = ((newTime - baselineTime) / baselineTime) * 100;\n\n    if (percentChange > threshold) {\n      regressions.push({\n        name: newResult.name,\n        baselineTime,\n        newTime,\n        percentChange,\n      });\n    } else if (percentChange < -threshold) {\n      improvements.push({\n        name: newResult.name,\n        baselineTime,\n        newTime,\n        percentChange,\n      });\n    }\n  }\n\n  return {\n    regressions,\n    improvements,\n    summary: {\n      totalTests: newResults.length,\n      regressionCount: regressions.length,\n      improvementCount: improvements.length,\n      unchangedCount: newResults.length - regressions.length - improvements.length,\n    },\n  };\n}\n\n/**\n * Saves benchmark results to localStorage\n * @param results Benchmark results\n * @param key Storage key\n */\nexport function saveBenchmarkResults(results: BenchmarkResult[], key: string): void {\n  if (typeof localStorage !== 'undefined') {\n    localStorage.setItem(key, JSON.stringify(results));\n  }\n}\n\n/**\n * Loads benchmark results from localStorage\n * @param key Storage key\n * @returns Benchmark results\n */\nexport function loadBenchmarkResults(key: string): BenchmarkResult[] {\n  if (typeof localStorage !== 'undefined') {\n    const stored = localStorage.getItem(key);\n    if (stored) {\n      try {\n        return JSON.parse(stored);\n      } catch (e) {\n        console.error('Failed to parse stored benchmark results', e);\n      }\n    }\n  }\n  return [];\n}\n\n/**\n * Schedulable benchmark job\n */\nexport interface BenchmarkJob {\n  id: string;\n  name: string;\n  description?: string;\n  schedule: 'daily' | 'weekly' | 'onDemand';\n  lastRun?: Date;\n  benchmarks: BenchmarkTestCase[];\n  notifyOnRegression?: boolean;\n  regressionThreshold?: number;\n  baselineKey?: string;\n}\n\n/**\n * Performance Benchmark Manager\n * Manages scheduling and execution of benchmark jobs\n */\nexport class PerformanceBenchmarkManager {\n  private jobs: Map<string, BenchmarkJob> = new Map();\n  private results: Map<string, BenchmarkResult[]> = new Map();\n\n  /**\n   * Registers a benchmark job\n   * @param job Benchmark job\n   */\n  registerJob(job: BenchmarkJob): void {\n    this.jobs.set(job.id, job);\n  }\n\n  /**\n   * Unregisters a benchmark job\n   * @param jobId Job ID\n   */\n  unregisterJob(jobId: string): void {\n    this.jobs.delete(jobId);\n  }\n\n  /**\n   * Gets all registered jobs\n   */\n  getJobs(): BenchmarkJob[] {\n    return Array.from(this.jobs.values());\n  }\n\n  /**\n   * Runs a benchmark job\n   * @param jobId Job ID\n   * @returns Promise resolving to benchmark results\n   */\n  async runJob(jobId: string): Promise<BenchmarkResult[]> {\n    const job = this.jobs.get(jobId);\n    if (!job) {\n      throw new Error(`Job with ID ${jobId} not found`);\n    }\n\n    const results: BenchmarkResult[] = [];\n\n    // Run each benchmark in the job\n    for (const benchmark of job.benchmarks) {\n      try {\n        const result = await Promise.resolve(benchmark.run());\n        results.push({\n          ...result,\n          name: benchmark.name,\n          description: benchmark.description,\n          timestamp: new Date(),\n        });\n      } catch (error) {\n        console.error(`Error running benchmark ${benchmark.name}:`, error);\n      }\n    }\n\n    // Save results\n    this.results.set(jobId, results);\n    job.lastRun = new Date();\n\n    // Check for regressions if needed\n    if (job.notifyOnRegression && job.baselineKey) {\n      const baselineResults = this.results.get(job.baselineKey) ?? [];\n      const regressionAnalysis = detectPerformanceRegressions(\n        results,\n        baselineResults,\n        job.regressionThreshold\n      );\n\n      if (regressionAnalysis.regressions.length > 0) {\n        this.notifyRegressions(jobId, regressionAnalysis);\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Gets results for a job\n   * @param jobId Job ID\n   */\n  getJobResults(jobId: string): BenchmarkResult[] {\n    return this.results.get(jobId) ?? [];\n  }\n\n  /**\n   * Notifies about performance regressions\n   * @param jobId Job ID\n   * @param analysis Regression analysis\n   */\n  private notifyRegressions(\n    jobId: string,\n    analysis: ReturnType<typeof detectPerformanceRegressions>\n  ): void {\n    console.warn(`Performance regression detected in job ${jobId}:`);\n    console.table(analysis.regressions);\n    // In a real application, this could send an email, create a Slack notification, etc.\n  }\n}\n\n// Export a singleton instance of the benchmark manager\nexport const benchmarkManager = new PerformanceBenchmarkManager();\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/performance/benchmarks/PerformanceBudgets.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/performance/hookPerformanceMonitor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/performance/longsession/LongSessionMemoryTracker.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_intercept' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":386,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":386,"endColumn":28}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * LongSessionMemoryTracker\n *\n * A utility for tracking memory usage over extended application sessions.\n * It helps identify memory leaks and gradual performance degradation that\n * only become apparent with prolonged application use.\n *\n * Features:\n * - Periodic memory snapshots\n * - Memory growth trend analysis\n * - Leak detection with statistical analysis\n * - Timeline visualization data\n * - Memory allocation and garbage collection tracking\n */\n\nimport { moduleEventBus } from '../../../lib/modules/ModuleEvents';\n\n// Define our memory metrics interface for internal use without extending global interfaces\ninterface MemoryMetrics {\n  usedJSHeapSize: number;\n  totalJSHeapSize: number;\n  jsHeapSizeLimit: number;\n}\n\n// Extend the Window interface to potentially support manual GC\ndeclare global {\n  interface Window {\n    gc?: () => void;\n  }\n}\n\n/** Memory snapshot data structure */\nexport interface MemorySnapshot {\n  /** Timestamp when the snapshot was taken (ms since epoch) */\n  timestamp: number;\n\n  /** Used JavaScript heap size (MB) */\n  usedHeapSizeMB: number;\n\n  /** Total allocated JavaScript heap size (MB) */\n  totalHeapSizeMB: number;\n\n  /** Maximum JavaScript heap size limit (MB) */\n  heapLimitMB: number;\n\n  /** DOM node count (if available) */\n  domNodeCount?: number;\n\n  /** Number of detached DOM nodes (if available) */\n  detachedDomNodes?: number;\n\n  /** Event listeners count (if available) */\n  eventListenerCount?: number;\n\n  /** Active timers count (if available) */\n  timerCount?: number;\n\n  /** Active animation frames (if available) */\n  animationFrameCount?: number;\n\n  /** Number of large arrays (>10K elements) in memory (if available) */\n  largeArrayCount?: number;\n\n  /** Number of active XHR objects (if available) */\n  xhrCount?: number;\n\n  /** Number of active fetch requests (if available) */\n  fetchCount?: number;\n\n  /** Custom metadata for this snapshot */\n  metadata?: Record<string, unknown>;\n}\n\n/** Memory trend analysis result */\nexport interface MemoryTrendAnalysis {\n  /** Overall trend (positive means growth, negative means reduction) */\n  overallTrend: number;\n\n  /** Growth rate per minute (MB/min) */\n  growthRatePerMinute: number;\n\n  /** Growth rate per hour (MB/hour) */\n  growthRatePerHour: number;\n\n  /** Extrapolated time until memory limit is reached (ms) */\n  estimatedTimeToLimit: number;\n\n  /** Whether memory growth is accelerating */\n  isAccelerating: boolean;\n\n  /** Confidence in this analysis (0-1) */\n  confidence: number;\n\n  /** Whether there is a suspected memory leak */\n  suspectedLeak: boolean;\n\n  /** Potential leak cause if identified */\n  leakCause?: string;\n\n  /** Leak severity (1-5, 5 being most severe) */\n  leakSeverity?: number;\n}\n\n/** Configuration options for the memory tracker */\nexport interface MemoryTrackerOptions {\n  /** Interval between memory snapshots (ms) */\n  snapshotIntervalMs?: number;\n\n  /** Maximum number of snapshots to keep */\n  maxSnapshots?: number;\n\n  /** Whether to attempt to get detailed memory info */\n  detailedMemoryInfo?: boolean;\n\n  /** Whether to track DOM nodes */\n  trackDomNodes?: boolean;\n\n  /** Whether to track detached DOM nodes */\n  trackDetachedNodes?: boolean;\n\n  /** Whether to attempt garbage collection before snapshots */\n  attemptGarbageCollection?: boolean;\n\n  /** Whether to periodically send memory reports to the event bus */\n  reportToEventBus?: boolean;\n\n  /** Report interval in ms (how often to send reports) */\n  reportIntervalMs?: number;\n\n  /** Threshold for leak detection (growth rate in MB/min) */\n  leakThresholdMBPerMinute?: number;\n\n  /** Logging level (0=none, 1=errors, 2=warnings, 3=info) */\n  loggingLevel?: number;\n\n  /** Callback when a memory snapshot is taken */\n  onSnapshot?: (snapshot: MemorySnapshot) => void;\n\n  /** Callback when memory analysis is updated */\n  onAnalysisUpdate?: (analysis: MemoryTrendAnalysis) => void;\n\n  /** Callback when a potential memory leak is detected */\n  onLeakDetected?: (analysis: MemoryTrendAnalysis) => void;\n}\n\n/**\n * Default configuration for memory tracking\n */\nconst DEFAULT_OPTIONS: MemoryTrackerOptions = {\n  snapshotIntervalMs: 60000, // 1 minute\n  maxSnapshots: 120, // 2 hours of data at 1 snapshot per minute\n  detailedMemoryInfo: true,\n  trackDomNodes: true,\n  trackDetachedNodes: false, // Expensive operation, off by default\n  attemptGarbageCollection: false,\n  reportToEventBus: true,\n  reportIntervalMs: 300000, // 5 minutes\n  leakThresholdMBPerMinute: 0.5, // 0.5 MB per minute sustained growth could indicate a leak\n  loggingLevel: 2,\n  onSnapshot: undefined,\n  onAnalysisUpdate: undefined,\n  onLeakDetected: undefined,\n};\n\n/**\n * Core class for tracking memory usage over extended sessions\n */\nexport class LongSessionMemoryTracker {\n  /** Memory snapshots collected over time */\n  private snapshots: MemorySnapshot[] = [];\n\n  /** Timestamp when tracking started */\n  private startTime: number;\n\n  /** Latest memory analysis */\n  private latestAnalysis: MemoryTrendAnalysis | null = null;\n\n  /** Configuration options */\n  private options: MemoryTrackerOptions;\n\n  /** Interval ID for snapshots */\n  private snapshotIntervalId: number | null = null;\n\n  /** Interval ID for reporting */\n  private reportIntervalId: number | null = null;\n\n  /** Whether tracking is currently active */\n  private isTracking = false;\n\n  /** Browser support info */\n  private browserSupport = {\n    memoryAPI: false,\n    performanceAPI: false,\n    domCountAPI: false,\n    gc: false,\n  };\n\n  /** Session markers for significant events */\n  private sessionMarkers: {\n    timestamp: number;\n    name: string;\n    metadata?: Record<string, unknown>;\n  }[] = [];\n\n  /**\n   * Create a new memory tracker\n   */\n  constructor(options: MemoryTrackerOptions = {}) {\n    this.options = { ...DEFAULT_OPTIONS, ...options };\n    this.startTime = Date.now();\n    this.detectBrowserSupport();\n  }\n\n  /**\n   * Detect browser API support\n   */\n  private detectBrowserSupport(): void {\n    // Check Performance API support\n    this.browserSupport.performanceAPI = typeof performance !== 'undefined';\n\n    // Check Memory API support (Chrome)\n    this.browserSupport.memoryAPI =\n      this.browserSupport.performanceAPI &&\n      typeof performance !== 'undefined' &&\n      'memory' in performance;\n\n    // Check DOM Count API support\n    this.browserSupport.domCountAPI =\n      typeof document !== 'undefined' && typeof document.querySelectorAll === 'function';\n\n    // Check GC support (rarely available in browsers)\n    this.browserSupport.gc = typeof window !== 'undefined' && typeof window.gc === 'function';\n\n    if (this.options?.loggingLevel && this.options?.loggingLevel >= 3) {\n      console.warn('[LongSessionMemoryTracker] Browser support detected:', this.browserSupport);\n    }\n\n    // Warn if memory API not available\n    if (\n      !this.browserSupport.memoryAPI &&\n      this.options?.loggingLevel &&\n      this.options?.loggingLevel >= 2\n    ) {\n      console.warn(\n        '[LongSessionMemoryTracker] Performance.memory API not available in this browser. Memory tracking will be limited.'\n      );\n    }\n  }\n\n  /**\n   * Start tracking memory usage\n   */\n  public startTracking(): void {\n    if (this.isTracking) return;\n    this.isTracking = true;\n\n    this.startTime = Date.now();\n    this.snapshots = [];\n    this.sessionMarkers = [];\n\n    // Take initial snapshot\n    this.takeSnapshot();\n\n    // Set up periodic snapshots\n    this.snapshotIntervalId = window.setInterval(\n      () => this.takeSnapshot(),\n      this.options?.snapshotIntervalMs ?? DEFAULT_OPTIONS.snapshotIntervalMs!\n    );\n\n    // Set up periodic reporting if enabled\n    if (this.options?.reportToEventBus) {\n      this.reportIntervalId = window.setInterval(\n        () => this.sendMemoryReport(),\n        this.options?.reportIntervalMs ?? DEFAULT_OPTIONS.reportIntervalMs!\n      );\n    }\n\n    if (this.options?.loggingLevel && this.options?.loggingLevel >= 3) {\n      console.warn('[LongSessionMemoryTracker] Started tracking memory usage');\n    }\n\n    // Add session start marker\n    this.addSessionMarker('tracking_started');\n  }\n\n  /**\n   * Stop tracking memory usage\n   */\n  public stopTracking(): void {\n    if (!this.isTracking) return;\n\n    // Clear intervals\n    if (this.snapshotIntervalId !== null) {\n      clearInterval(this.snapshotIntervalId);\n      this.snapshotIntervalId = null;\n    }\n\n    if (this.reportIntervalId !== null) {\n      clearInterval(this.reportIntervalId);\n      this.reportIntervalId = null;\n    }\n\n    this.isTracking = false;\n\n    // Take one final snapshot\n    this.takeSnapshot();\n\n    // Add session end marker\n    this.addSessionMarker('tracking_stopped');\n\n    if (this.options?.loggingLevel && this.options?.loggingLevel >= 3) {\n      console.warn('[LongSessionMemoryTracker] Stopped tracking memory usage');\n    }\n  }\n\n  /**\n   * Take a memory snapshot\n   */\n  public takeSnapshot(): MemorySnapshot {\n    // Run garbage collection if configured and supported\n    if (this.options?.attemptGarbageCollection && this.browserSupport.gc) {\n      try {\n        this.attemptGarbageCollection();\n      } catch (_e) {\n        // Ignore errors from GC attempts\n      }\n    }\n\n    const snapshot: MemorySnapshot = {\n      timestamp: Date.now(),\n      usedHeapSizeMB: 0,\n      totalHeapSizeMB: 0,\n      heapLimitMB: 0,\n    };\n\n    // Add memory info if available\n    if (this.browserSupport.memoryAPI && performance && 'memory' in performance) {\n      // Type assertion as our internal interface\n      const memoryInfo = performance.memory as unknown as MemoryMetrics;\n\n      // Access properties safely with nullish coalescing for defaults\n      snapshot.usedHeapSizeMB = (memoryInfo.usedJSHeapSize ?? 0) / (1024 * 1024);\n      snapshot.totalHeapSizeMB = (memoryInfo.totalJSHeapSize ?? 0) / (1024 * 1024);\n      snapshot.heapLimitMB = (memoryInfo.jsHeapSizeLimit ?? 0) / (1024 * 1024);\n    }\n\n    // Count DOM nodes if configured and supported\n    if (this.options?.trackDomNodes && this.browserSupport.domCountAPI) {\n      snapshot.domNodeCount = document.querySelectorAll('*').length;\n    }\n\n    // Add to snapshots array, ensuring we don't exceed maximum\n    this.snapshots.push(snapshot);\n    if (this.snapshots.length > (this.options?.maxSnapshots ?? DEFAULT_OPTIONS.maxSnapshots!)) {\n      this.snapshots.shift();\n    }\n\n    // Run analysis after sufficient data is collected\n    if (this.snapshots.length >= 3) {\n      this.analyzeMemoryTrend();\n    }\n\n    // Notify via callback if configured\n    if (this.options?.onSnapshot) {\n      this.options.onSnapshot(snapshot);\n    }\n\n    return snapshot;\n  }\n\n  /**\n   * Analyze memory usage trend\n   */\n  private analyzeMemoryTrend(): void {\n    // Need at least 3 snapshots for a meaningful trend analysis\n    if (this.snapshots.length < 3) return;\n\n    // Extract data points for analysis\n    const snapshots = [...this.snapshots];\n    const timestamps = snapshots.map(s => s.timestamp);\n    const memoryValues = snapshots.map(s => s.usedHeapSizeMB);\n\n    // Calculate trend with linear regression\n    const {\n      slope,\n      intercept: _intercept,\n      correlation,\n    } = this.calculateLinearRegression(timestamps, memoryValues);\n\n    // Convert to more meaningful metrics\n    // MB per millisecond to MB per minute\n    const growthRatePerMinute = slope * 60000;\n    // MB per minute to MB per hour\n    const growthRatePerHour = growthRatePerMinute * 60;\n\n    // Calculate estimated time until memory limit (if we have memory limit info)\n    let estimatedTimeToLimit = Number.POSITIVE_INFINITY;\n    const latestSnapshot = snapshots[snapshots.length - 1];\n\n    if (slope > 0 && latestSnapshot.heapLimitMB > 0) {\n      const remainingMemory = latestSnapshot.heapLimitMB - latestSnapshot.usedHeapSizeMB;\n      estimatedTimeToLimit = remainingMemory / slope; // in ms\n    }\n\n    // Is memory growth accelerating?\n    const isAccelerating = this.isGrowthAccelerating(timestamps, memoryValues);\n\n    // Calculate confidence level\n    const confidence =\n      Math.min(\n        snapshots.length / 10, // More data points = higher confidence, max at 10 points\n        1 // Cap at 1.0\n      ) * Math.abs(correlation); // Scale by correlation strength\n\n    // Detect potential memory leak\n    const suspectedLeak =\n      growthRatePerMinute >\n        (this.options?.leakThresholdMBPerMinute ?? DEFAULT_OPTIONS.leakThresholdMBPerMinute!) &&\n      confidence > 0.7 &&\n      snapshots.length >= 5; // Need at least 5 data points\n\n    // Create analysis result\n    const analysis: MemoryTrendAnalysis = {\n      overallTrend: slope,\n      growthRatePerMinute,\n      growthRatePerHour,\n      estimatedTimeToLimit,\n      isAccelerating,\n      confidence,\n      suspectedLeak,\n    };\n\n    // Add leak severity if a leak is suspected\n    if (suspectedLeak) {\n      analysis.leakSeverity = this.calculateLeakSeverity(growthRatePerMinute);\n\n      // Try to identify the cause\n      if (isAccelerating) {\n        analysis.leakCause = 'Accelerating memory growth suggests an uncontrolled object creation';\n      } else if (this.sessionMarkers.length > 0) {\n        // Check if there's correlation with session markers\n        // This is a simplified approach - a real implementation would need more sophisticated analysis\n        analysis.leakCause = 'Possible correlation with recent system events';\n      }\n    }\n\n    // Update latest analysis\n    this.latestAnalysis = analysis;\n\n    // Notify via callbacks if configured\n    if (this.options?.onAnalysisUpdate) {\n      this.options.onAnalysisUpdate(analysis);\n    }\n\n    if (suspectedLeak && this.options?.onLeakDetected) {\n      this.options.onLeakDetected(analysis);\n    }\n\n    // Log results if configured\n    if (this.options?.loggingLevel && this.options?.loggingLevel >= 3) {\n      console.warn('[LongSessionMemoryTracker] Memory trend analysis:', analysis);\n    } else if (suspectedLeak && this.options?.loggingLevel && this.options?.loggingLevel >= 2) {\n      console.warn('[LongSessionMemoryTracker] Potential memory leak detected:', analysis);\n    }\n  }\n\n  /**\n   * Calculate linear regression on time series data\n   */\n  private calculateLinearRegression(\n    xValues: number[],\n    yValues: number[]\n  ): { slope: number; intercept: number; correlation: number } {\n    const n = xValues.length;\n\n    if (n === 0 || xValues.length !== yValues.length) {\n      return { slope: 0, intercept: 0, correlation: 0 };\n    }\n\n    // Convert timestamps to seconds from start to avoid precision issues\n    const startTime = xValues[0];\n    const xValuesNormalized = xValues.map(x => (x - startTime) / 1000);\n\n    // Calculate means\n    const meanX = xValuesNormalized.reduce((sum, x) => sum + x, 0) / n;\n    const meanY = yValues.reduce((sum, y) => sum + y, 0) / n;\n\n    // Calculate sums for regression formula\n    let numerator = 0;\n    let denominator = 0;\n    let sumSquaredErrors = 0;\n    let totalSumOfSquares = 0;\n\n    for (let i = 0; i < n; i++) {\n      const x = xValuesNormalized[i];\n      const y = yValues[i];\n\n      const xDiff = x - meanX;\n      const yDiff = y - meanY;\n\n      numerator += xDiff * yDiff;\n      denominator += xDiff * xDiff;\n      totalSumOfSquares += yDiff * yDiff;\n    }\n\n    // Avoid division by zero\n    if (denominator === 0) {\n      return { slope: 0, intercept: meanY, correlation: 0 };\n    }\n\n    // Calculate regression parameters\n    const slope = numerator / denominator;\n    const intercept = meanY - slope * meanX;\n\n    // Calculate predicted values and sum of squared errors\n    for (let i = 0; i < n; i++) {\n      const predicted = slope * xValuesNormalized[i] + intercept;\n      sumSquaredErrors += Math.pow(yValues[i] - predicted, 2);\n    }\n\n    // Calculate correlation coefficient\n    let correlation = 0;\n    if (totalSumOfSquares > 0) {\n      correlation = Math.sqrt(1 - sumSquaredErrors / totalSumOfSquares);\n\n      // Adjust sign based on slope\n      if (slope < 0) correlation = -correlation;\n    }\n\n    // Convert slope back to original time units (MB per ms)\n    const originalSlope = slope / 1000;\n\n    return { slope: originalSlope, intercept, correlation };\n  }\n\n  /**\n   * Determine if memory growth is accelerating\n   */\n  private isGrowthAccelerating(timestamps: number[], memoryValues: number[]): boolean {\n    if (timestamps.length < 6) return false; // Need at least 6 points for reliable acceleration detection\n\n    // Split data into first and second half\n    const midpoint = Math.floor(timestamps.length / 2);\n    const firstHalfX = timestamps.slice(0, midpoint);\n    const firstHalfY = memoryValues.slice(0, midpoint);\n    const secondHalfX = timestamps.slice(midpoint);\n    const secondHalfY = memoryValues.slice(midpoint);\n\n    // Calculate growth rate for each half\n    const firstHalfRegression = this.calculateLinearRegression(firstHalfX, firstHalfY);\n    const secondHalfRegression = this.calculateLinearRegression(secondHalfX, secondHalfY);\n\n    // Compare slopes\n    return secondHalfRegression.slope > firstHalfRegression.slope * 1.2; // 20% faster growth = acceleration\n  }\n\n  /**\n   * Calculate leak severity on a scale of 1-5\n   */\n  private calculateLeakSeverity(growthRatePerMinute: number): number {\n    // Scale from 1-5 based on growth rate\n    // 1: slow leak (<1MB/min)\n    // 2: moderate leak (1-2MB/min)\n    // 3: significant leak (2-5MB/min)\n    // 4: serious leak (5-10MB/min)\n    // 5: critical leak (>10MB/min)\n\n    if (growthRatePerMinute >= 10) return 5;\n    if (growthRatePerMinute >= 5) return 4;\n    if (growthRatePerMinute >= 2) return 3;\n    if (growthRatePerMinute >= 1) return 2;\n    return 1;\n  }\n\n  /**\n   * Get all collected memory snapshots\n   */\n  public getSnapshots(): MemorySnapshot[] {\n    return [...this.snapshots];\n  }\n\n  /**\n   * Get the latest memory analysis\n   */\n  public getLatestAnalysis(): MemoryTrendAnalysis | null {\n    return this.latestAnalysis;\n  }\n\n  /**\n   * Add a session marker for significant events\n   */\n  public addSessionMarker(name: string, metadata?: Record<string, unknown>): void {\n    this.sessionMarkers.push({\n      timestamp: Date.now(),\n      name,\n      metadata,\n    });\n  }\n\n  /**\n   * Get all session markers\n   */\n  public getSessionMarkers(): {\n    timestamp: number;\n    name: string;\n    metadata?: Record<string, unknown>;\n  }[] {\n    return [...this.sessionMarkers];\n  }\n\n  /**\n   * Send memory report to event bus\n   */\n  private sendMemoryReport(): void {\n    if (!this.options?.reportToEventBus || !this.isTracking || !this.latestAnalysis) return;\n\n    moduleEventBus.emit({\n      type: 'STATUS_CHANGED',\n      moduleId: 'long-session-memory-tracker',\n      moduleType: 'resource-manager', // Using the correct ModuleType from ModuleEventTypes\n      timestamp: Date.now(),\n      data: {\n        type: 'memory_report',\n        snapshots: this.snapshots.slice(-10), // Only send most recent 10 snapshots\n        analysis: this.latestAnalysis,\n        markers: this.sessionMarkers.slice(-5), // Only send most recent 5 markers\n        sessionDurationMs: Date.now() - this.startTime,\n      },\n    });\n  }\n\n  /**\n   * Get total session duration in milliseconds\n   */\n  public getSessionDurationMs(): number {\n    return Date.now() - this.startTime;\n  }\n\n  /**\n   * Force run garbage collection (if supported)\n   */\n  public attemptGarbageCollection(): boolean {\n    if (!this.browserSupport.gc || !window.gc) {\n      return false;\n    }\n\n    try {\n      window.gc();\n      return true;\n    } catch (_e) {\n      // Silent fail - GC is not critical\n      return false;\n    }\n  }\n\n  /**\n   * Clear all accumulated data (snapshots and markers)\n   */\n  public clearData(): void {\n    this.snapshots = [];\n    this.sessionMarkers = [];\n    this.latestAnalysis = null;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/performance/multitab/MultitabCommunicationChannel.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/performance/network/NetworkDegradationSimulator.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_originalOnload' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":418,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":418,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Network Degradation Simulator\n *\n * This utility provides tools for simulating various network conditions to test\n * application performance and resilience under different network scenarios.\n *\n * Key capabilities:\n * - Simulate latency, bandwidth limitations, and packet loss\n * - Apply network degradation to fetch, WebSocket, and XMLHttpRequest\n * - Create realistic network profiles matching common scenarios\n * - Offer programmatic and declarative APIs for testing\n */\n\nexport interface NetworkCondition {\n  /** Name describing this network condition */\n  name: string;\n\n  /** Description with more details about the network condition */\n  description: string;\n\n  /** Network latency in milliseconds (one-way) */\n  latencyMs: number;\n\n  /** Throughput in kilobits per second */\n  throughputKbps: number;\n\n  /** Packet loss probability (0-1) */\n  packetLoss: number;\n\n  /** Latency jitter in milliseconds (variance in latency) */\n  jitterMs: number;\n\n  /** Whether to simulate connection pauses/stalls */\n  enableConnectionStalls: boolean;\n\n  /** Duration of connection stalls in milliseconds */\n  stallDurationMs?: number;\n\n  /** Probability of a stall occurring (0-1) */\n  stallProbability?: number;\n}\n\n/**\n * Pre-defined network condition profiles based on real-world scenarios\n */\nexport const NetworkProfiles: Record<string, NetworkCondition> = {\n  PERFECT: {\n    name: 'Perfect Connection',\n    description: 'Ideal network conditions with no degradation',\n    latencyMs: 0,\n    throughputKbps: 1000000, // 1 Gbps\n    packetLoss: 0,\n    jitterMs: 0,\n    enableConnectionStalls: false,\n  },\n\n  FAST_WIFI: {\n    name: 'Fast WiFi',\n    description: 'Strong, fast home WiFi connection',\n    latencyMs: 5,\n    throughputKbps: 50000, // 50 Mbps\n    packetLoss: 0.001, // 0.1%\n    jitterMs: 2,\n    enableConnectionStalls: false,\n  },\n\n  AVERAGE_WIFI: {\n    name: 'Average WiFi',\n    description: 'Typical home WiFi connection',\n    latencyMs: 20,\n    throughputKbps: 15000, // 15 Mbps\n    packetLoss: 0.005, // 0.5%\n    jitterMs: 5,\n    enableConnectionStalls: false,\n  },\n\n  SLOW_WIFI: {\n    name: 'Slow WiFi',\n    description: 'Weak or distant WiFi connection',\n    latencyMs: 40,\n    throughputKbps: 3000, // 3 Mbps\n    packetLoss: 0.02, // 2%\n    jitterMs: 10,\n    enableConnectionStalls: true,\n    stallDurationMs: 500,\n    stallProbability: 0.01,\n  },\n\n  FIVE_G: {\n    name: '5G Connection',\n    description: 'Strong 5G mobile connection',\n    latencyMs: 30,\n    throughputKbps: 30000, // 30 Mbps\n    packetLoss: 0.003, // 0.3%\n    jitterMs: 8,\n    enableConnectionStalls: false,\n  },\n\n  FOUR_G: {\n    name: '4G Connection',\n    description: 'Typical 4G/LTE mobile connection',\n    latencyMs: 80,\n    throughputKbps: 5000, // 5 Mbps\n    packetLoss: 0.01, // 1%\n    jitterMs: 15,\n    enableConnectionStalls: true,\n    stallDurationMs: 300,\n    stallProbability: 0.015,\n  },\n\n  THREE_G: {\n    name: '3G Connection',\n    description: 'Older 3G mobile connection',\n    latencyMs: 200,\n    throughputKbps: 750, // 750 Kbps\n    packetLoss: 0.03, // 3%\n    jitterMs: 25,\n    enableConnectionStalls: true,\n    stallDurationMs: 800,\n    stallProbability: 0.03,\n  },\n\n  EDGE: {\n    name: 'EDGE Connection',\n    description: 'Edge/2G mobile connection in rural areas',\n    latencyMs: 400,\n    throughputKbps: 250, // 250 Kbps\n    packetLoss: 0.05, // 5%\n    jitterMs: 40,\n    enableConnectionStalls: true,\n    stallDurationMs: 1500,\n    stallProbability: 0.05,\n  },\n\n  SATELLITE: {\n    name: 'Satellite Connection',\n    description: 'High-latency satellite internet',\n    latencyMs: 600,\n    throughputKbps: 1000, // 1 Mbps\n    packetLoss: 0.02, // 2%\n    jitterMs: 50,\n    enableConnectionStalls: true,\n    stallDurationMs: 2000,\n    stallProbability: 0.025,\n  },\n\n  POOR_NETWORK: {\n    name: 'Poor Network',\n    description: 'Unreliable network with high packet loss',\n    latencyMs: 300,\n    throughputKbps: 500, // 500 Kbps\n    packetLoss: 0.1, // 10%\n    jitterMs: 100,\n    enableConnectionStalls: true,\n    stallDurationMs: 3000,\n    stallProbability: 0.08,\n  },\n\n  AIRPLANE_WIFI: {\n    name: 'Airplane WiFi',\n    description: 'Typical in-flight WiFi connection',\n    latencyMs: 750,\n    throughputKbps: 300, // 300 Kbps\n    packetLoss: 0.08, // 8%\n    jitterMs: 150,\n    enableConnectionStalls: true,\n    stallDurationMs: 5000,\n    stallProbability: 0.1,\n  },\n\n  INTERNATIONAL: {\n    name: 'International Connection',\n    description: 'Connection to server in a different continent',\n    latencyMs: 350,\n    throughputKbps: 2000, // 2 Mbps\n    packetLoss: 0.03, // 3%\n    jitterMs: 30,\n    enableConnectionStalls: true,\n    stallDurationMs: 1000,\n    stallProbability: 0.02,\n  },\n\n  // This is effectively a disconnected state with occasional successful packets\n  SEVERELY_DEGRADED: {\n    name: 'Severely Degraded',\n    description: 'Almost unusable connection with extreme packet loss',\n    latencyMs: 1000,\n    throughputKbps: 50, // 50 Kbps\n    packetLoss: 0.5, // 50%\n    jitterMs: 500,\n    enableConnectionStalls: true,\n    stallDurationMs: 10000,\n    stallProbability: 0.2,\n  },\n\n  OFFLINE: {\n    name: 'Offline',\n    description: 'No connectivity (100% packet loss)',\n    latencyMs: 0,\n    throughputKbps: 0,\n    packetLoss: 1.0, // 100%\n    jitterMs: 0,\n    enableConnectionStalls: false,\n  },\n};\n\n/**\n * Stores original network-related methods to restore them later\n */\nconst originalMethods = {\n  fetch: typeof window !== 'undefined' ? window.fetch : null,\n  XMLHttpRequest:\n    typeof XMLHttpRequest !== 'undefined'\n      ? {\n          open: XMLHttpRequest.prototype.open,\n          send: XMLHttpRequest.prototype.send,\n        }\n      : null,\n  setTimeout: setTimeout,\n  WebSocket: typeof WebSocket !== 'undefined' ? WebSocket : null,\n};\n\n/**\n * Network degradation simulation state\n */\ninterface SimulationState {\n  enabled: boolean;\n  currentCondition: NetworkCondition | null;\n  proxiedFetch: boolean;\n  proxiedXHR: boolean;\n  proxiedWebSocket: boolean;\n}\n\n/**\n * Current state of the network degradation simulator\n */\nconst simulationState: SimulationState = {\n  enabled: false,\n  currentCondition: null,\n  proxiedFetch: false,\n  proxiedXHR: false,\n  proxiedWebSocket: false,\n};\n\n/**\n * Calculate actual delay based on network condition parameters\n * @param condition The network condition\n */\nfunction calculateDelay(condition: NetworkCondition): number {\n  if (!condition) return 0;\n\n  // Base latency\n  let delay = condition.latencyMs;\n\n  // Add jitter (random variance in latency)\n  if (condition.jitterMs > 0) {\n    delay += (Math.random() * 2 - 1) * condition.jitterMs;\n  }\n\n  // Ensure delay is never negative\n  return Math.max(0, delay);\n}\n\n/**\n * Simulate connection stall if enabled in the network condition\n * @param condition The network condition\n */\nfunction simulateConnectionStall(condition: NetworkCondition): Promise<void> {\n  if (\n    !condition.enableConnectionStalls ||\n    typeof condition.stallProbability !== 'number' ||\n    typeof condition.stallDurationMs !== 'number'\n  ) {\n    return Promise.resolve();\n  }\n\n  // Determine if a stall should occur\n  if (Math.random() < condition.stallProbability) {\n    return new Promise(resolve => {\n      setTimeout(resolve, condition.stallDurationMs);\n    });\n  }\n\n  return Promise.resolve();\n}\n\n/**\n * Simulate packet loss based on the network condition\n * @param condition The network condition\n * @throws Error if packet is \"lost\"\n */\nfunction simulatePacketLoss(condition: NetworkCondition): void {\n  if (Math.random() < condition.packetLoss) {\n    throw new Error(`Network error: Simulated packet loss (${condition.name})`);\n  }\n}\n\n/**\n * Calculate delay for a data transfer based on throughput\n * @param byteSize Size of data in bytes\n * @param condition The network condition\n */\nfunction calculateThroughputDelay(byteSize: number, condition: NetworkCondition): number {\n  if (!condition || condition.throughputKbps <= 0) return 0;\n\n  // Convert bytes to bits and calculate transfer time in seconds\n  const bits = byteSize * 8;\n  const seconds = bits / (condition.throughputKbps * 1000);\n\n  // Convert to milliseconds\n  return seconds * 1000;\n}\n\n/**\n * Apply network degradation to fetch API\n * @param condition The network condition to apply\n */\nfunction proxyFetch(condition: NetworkCondition): void {\n  if (typeof window === 'undefined' || !window.fetch || simulationState.proxiedFetch) return;\n\n  // Store original fetch\n  const originalFetch = window.fetch;\n\n  // Override fetch with degraded version\n  window.fetch = async (input: RequestInfo | URL, init?: RequestInit) => {\n    if (!simulationState.enabled) {\n      return originalFetch(input, init);\n    }\n\n    try {\n      // Simulate initial latency (request)\n      const latency = calculateDelay(condition);\n      await new Promise(resolve => setTimeout(resolve, latency));\n\n      // Simulate connection stalls\n      await simulateConnectionStall(condition);\n\n      // Simulate packet loss\n      simulatePacketLoss(condition);\n\n      // Make the actual request\n      const response = await originalFetch(input, init);\n\n      // Clone the response to access its body\n      const clone = response?.clone();\n      const text = await clone.text();\n\n      // Calculate throughput delay based on response size\n      const byteSize = new TextEncoder().encode(text).length;\n      const throughputDelay = calculateThroughputDelay(byteSize, condition);\n\n      // Simulate response latency + throughput delay\n      await new Promise(resolve => setTimeout(resolve, latency + throughputDelay));\n\n      // Simulate packet loss again (for response)\n      simulatePacketLoss(condition);\n\n      // Create a new response with the same data\n      return new Response(text, {\n        status: response?.status,\n        statusText: response?.statusText,\n        headers: response?.headers,\n      });\n    } catch (error) {\n      if (error instanceof Error && error.message.includes('Simulated packet loss')) {\n        throw new TypeError('NetworkError when attempting to fetch resource');\n      }\n      throw error;\n    }\n  };\n\n  simulationState.proxiedFetch = true;\n}\n\n/**\n * Apply network degradation to XMLHttpRequest\n * @param condition The network condition to apply\n */\nfunction proxyXHR(condition: NetworkCondition): void {\n  if (typeof XMLHttpRequest === 'undefined' || simulationState.proxiedXHR) return;\n\n  // Store original XHR methods\n  const originalOpen = XMLHttpRequest.prototype.open;\n  const originalSend = XMLHttpRequest.prototype.send;\n\n  // Override XHR open method\n  XMLHttpRequest.prototype.open = function (this: XMLHttpRequest, ...args: unknown[]) {\n    // Store network condition in the XHR instance\n    (this as unknown as { __networkCondition: NetworkCondition | null }).__networkCondition =\n      simulationState.enabled ? condition : null;\n\n    // Call the original method with correct typing\n    return originalOpen.apply(\n      this,\n      args as [\n        method: string,\n        url: string | URL,\n        async: boolean,\n        username?: string | null,\n        password?: string | null,\n      ]\n    );\n  };\n\n  // Override XHR send method\n  XMLHttpRequest.prototype.send = function (this: XMLHttpRequest, ...args: unknown[]) {\n    const xhrNetworkCondition = (this as unknown as { __networkCondition: NetworkCondition | null })\n      .__networkCondition;\n\n    if (!xhrNetworkCondition) {\n      return originalSend.apply(this, args as [body?: Document | XMLHttpRequestBodyInit | null]);\n    }\n\n    // Calculate request latency\n    const latency = calculateDelay(xhrNetworkCondition);\n\n    // Store original callbacks\n    const _originalOnload = this.onload;\n    const originalOnerror = this.onerror;\n    const originalOnreadystatechange = this.onreadystatechange;\n\n    // Simulate packet loss\n    if (Math.random() < xhrNetworkCondition.packetLoss) {\n      setTimeout(() => {\n        if (typeof originalOnerror === 'function') {\n          const errorEvent = new ErrorEvent('error', {\n            message: 'Simulated packet loss',\n          });\n          // Use type assertion to handle the type mismatch\n          originalOnerror.call(this, errorEvent as unknown as ProgressEvent<EventTarget>);\n        }\n      }, latency);\n\n      return;\n    }\n\n    // Handle readystatechange\n    this.onreadystatechange = function (this: XMLHttpRequest) {\n      if (this.readyState === 4) {\n        // Calculate throughput delay for the response\n        let throughputDelay = 0;\n        if (this.responseText) {\n          const byteSize = new TextEncoder().encode(this.responseText).length;\n          throughputDelay = calculateThroughputDelay(byteSize, xhrNetworkCondition);\n        }\n\n        // Delay the readystatechange with both latency and throughput delay\n        setTimeout(() => {\n          if (typeof originalOnreadystatechange === 'function') {\n            // Create a proper Event object for the callback\n            const event = new Event('readystatechange');\n            originalOnreadystatechange.call(this, event);\n          }\n        }, latency + throughputDelay);\n\n        return;\n      }\n\n      if (typeof originalOnreadystatechange === 'function') {\n        // Create a proper Event object for the callback\n        const event = new Event('readystatechange');\n        originalOnreadystatechange.call(this, event);\n      }\n    };\n\n    // Delay the actual send\n    setTimeout(() => {\n      originalSend.apply(this, args as [body?: Document | XMLHttpRequestBodyInit | null]);\n    }, latency);\n  };\n\n  simulationState.proxiedXHR = true;\n}\n\n/**\n * Apply network degradation to WebSocket\n * @param condition The network condition to apply\n */\nfunction proxyWebSocket(condition: NetworkCondition): void {\n  if (typeof WebSocket === 'undefined' || simulationState.proxiedWebSocket) return;\n\n  // Store original WebSocket constructor\n  const OriginalWebSocket = WebSocket;\n\n  // Create a proxy WebSocket class\n  class DegradedWebSocket extends OriginalWebSocket {\n    constructor(...args: unknown[]) {\n      // Cast args as tuple type to allow spread\n      const typedArgs = args as [url: string | URL, protocols?: string | string[]];\n      super(...typedArgs);\n\n      if (!simulationState.enabled) return;\n\n      // Store original event handlers\n      const originalOnopen = this.onopen;\n      const originalOnmessage = this.onmessage;\n      const originalOnclose = this.onclose;\n      const originalOnerror = this.onerror;\n\n      // Apply connection latency for open event\n      this.onopen = function (this: WebSocket, ev: Event) {\n        setTimeout(() => {\n          if (typeof originalOnopen === 'function') {\n            originalOnopen.call(this, ev);\n          }\n        }, calculateDelay(condition));\n      };\n\n      // Apply latency and packet loss to messages\n      this.onmessage = function (this: WebSocket, ev: MessageEvent) {\n        // Simulate packet loss\n        if (Math.random() < condition.packetLoss) {\n          return; // Message lost\n        }\n\n        // Calculate message throughput delay\n        let throughputDelay = 0;\n        if (typeof ev.data === 'string') {\n          const byteSize = new TextEncoder().encode(ev.data).length;\n          throughputDelay = calculateThroughputDelay(byteSize, condition);\n        } else if (ev.data instanceof Blob) {\n          throughputDelay = calculateThroughputDelay(ev.data?.size, condition);\n        } else if (ev.data instanceof ArrayBuffer) {\n          throughputDelay = calculateThroughputDelay(ev.data?.byteLength, condition);\n        }\n\n        // Delay message by latency + throughput\n        setTimeout(\n          () => {\n            if (typeof originalOnmessage === 'function') {\n              originalOnmessage.call(this, ev);\n            }\n          },\n          calculateDelay(condition) + throughputDelay\n        );\n      };\n\n      // Store other callbacks\n      this.onclose = originalOnclose;\n      this.onerror = originalOnerror;\n\n      // Override send method to add latency and packet loss\n      const originalSend = this.send;\n      this.send = function (\n        this: WebSocket,\n        data: string | ArrayBufferLike | Blob | ArrayBufferView\n      ) {\n        // Simulate packet loss for outgoing messages\n        if (Math.random() < condition.packetLoss) {\n          // Trigger error for lost packet\n          if (typeof this.onerror === 'function') {\n            const errorEvent = new ErrorEvent('error', {\n              message: 'Simulated packet loss for outgoing message',\n            });\n            this.onerror.call(this, errorEvent as Event);\n          }\n          return;\n        }\n\n        // Calculate latency\n        setTimeout(() => {\n          try {\n            originalSend.call(this, data);\n          } catch (_e) {\n            if (typeof this.onerror === 'function') {\n              this.onerror.call(this, new Event('error'));\n            }\n          }\n        }, calculateDelay(condition));\n      };\n    }\n  }\n\n  // Replace global WebSocket with our degraded version\n  window.WebSocket = DegradedWebSocket as unknown as typeof WebSocket;\n\n  simulationState.proxiedWebSocket = true;\n}\n\n/**\n * Interface for options when enabling network degradation\n */\nexport interface EnableOptions {\n  /** Whether to proxy fetch API */\n  proxyFetch?: boolean;\n\n  /** Whether to proxy XMLHttpRequest */\n  proxyXHR?: boolean;\n\n  /** Whether to proxy WebSocket */\n  proxyWebSocket?: boolean;\n}\n\n/**\n * Enable network degradation simulation with specified conditions\n * @param condition The network condition to simulate\n * @param options Options for enabling network degradation\n */\nexport function enableNetworkDegradation(\n  condition: NetworkCondition,\n  options: EnableOptions = { proxyFetch: true, proxyXHR: true, proxyWebSocket: true }\n): void {\n  // Already enabled with same condition - do nothing\n  if (simulationState.enabled && simulationState.currentCondition?.name === condition.name) {\n    return;\n  }\n\n  // If previously enabled with different condition, disable first\n  if (simulationState.enabled) {\n    disableNetworkDegradation();\n  }\n\n  // Update simulation state\n  simulationState.enabled = true;\n  simulationState.currentCondition = condition;\n\n  // Apply proxies based on options\n  if (options?.proxyFetch !== false) {\n    proxyFetch(condition);\n  }\n\n  if (options?.proxyXHR !== false) {\n    proxyXHR(condition);\n  }\n\n  if (options?.proxyWebSocket !== false) {\n    proxyWebSocket(condition);\n  }\n\n  console.warn(`Network degradation simulation enabled: ${condition.name}`);\n  console.warn(\n    `  Latency: ${condition.latencyMs}ms, Throughput: ${condition.throughputKbps}Kbps, Packet Loss: ${condition.packetLoss * 100}%`\n  );\n}\n\n/**\n * Disable network degradation simulation and restore original behavior\n */\nexport function disableNetworkDegradation(): void {\n  if (!simulationState.enabled) return;\n\n  // Restore original methods\n  if (simulationState.proxiedFetch && typeof window !== 'undefined' && originalMethods.fetch) {\n    window.fetch = originalMethods.fetch;\n    simulationState.proxiedFetch = false;\n  }\n\n  if (\n    simulationState.proxiedXHR &&\n    typeof XMLHttpRequest !== 'undefined' &&\n    originalMethods.XMLHttpRequest\n  ) {\n    XMLHttpRequest.prototype.open = originalMethods.XMLHttpRequest.open;\n    XMLHttpRequest.prototype.send = originalMethods.XMLHttpRequest.send;\n    simulationState.proxiedXHR = false;\n  }\n\n  if (\n    simulationState.proxiedWebSocket &&\n    typeof window !== 'undefined' &&\n    originalMethods.WebSocket\n  ) {\n    window.WebSocket = originalMethods.WebSocket;\n    simulationState.proxiedWebSocket = false;\n  }\n\n  // Reset simulation state\n  simulationState.enabled = false;\n  simulationState.currentCondition = null;\n\n  console.warn('Network degradation simulation disabled');\n}\n\n/**\n * Get the current network condition being simulated\n * @returns The current network condition or null if disabled\n */\nexport function getCurrentNetworkCondition(): NetworkCondition | null {\n  return simulationState.enabled ? simulationState.currentCondition : null;\n}\n\n/**\n * Check if network degradation simulation is enabled\n * @returns True if enabled, false otherwise\n */\nexport function isNetworkDegradationEnabled(): boolean {\n  return simulationState.enabled;\n}\n\n/**\n * Create a custom network condition\n * @param config Configuration for the custom network condition\n * @returns A new NetworkCondition object\n */\nexport function createCustomNetworkCondition(\n  config: Partial<NetworkCondition> & { name: string }\n): NetworkCondition {\n  return {\n    description: config.description || 'Custom network condition',\n    latencyMs: config.latencyMs ?? 0,\n    throughputKbps: config.throughputKbps || 1000000,\n    packetLoss: config.packetLoss ?? 0,\n    jitterMs: config.jitterMs ?? 0,\n    enableConnectionStalls: config.enableConnectionStalls || false,\n    stallDurationMs: config.stallDurationMs,\n    stallProbability: config.stallProbability,\n    ...config,\n  };\n}\n\n/**\n * Apply network degradation to a specific function or Promise\n * Useful for targeted testing without affecting the entire application\n *\n * @param condition The network condition to simulate\n * @param fn The function to degrade\n * @returns A new function with network degradation applied\n */\nexport function withNetworkDegradation<T extends (...args: unknown[]) => unknown>(\n  condition: NetworkCondition,\n  fn: T\n): (...args: Parameters<T>) => Promise<ReturnType<T>> {\n  return async (...args: Parameters<T>): Promise<ReturnType<T>> => {\n    // Initial request latency\n    const latency = calculateDelay(condition);\n    await new Promise(resolve => setTimeout(resolve, latency));\n\n    // Simulate connection stall\n    await simulateConnectionStall(condition);\n\n    // Simulate packet loss\n    if (Math.random() < condition.packetLoss) {\n      throw new Error(`Network error: Simulated packet loss (${condition.name})`);\n    }\n\n    // Call the original function\n    const result = await fn(...args);\n\n    // Calculate response size for throughput\n    let byteSize = 1000; // Default size estimate\n\n    if (result && typeof result === 'object') {\n      try {\n        const resultString = JSON.stringify(result);\n        byteSize = new TextEncoder().encode(resultString).length;\n      } catch (_e) {\n        // Ignore, use default size\n      }\n    } else if (typeof result === 'string') {\n      byteSize = new TextEncoder().encode(result).length;\n    }\n\n    // Calculate throughput delay\n    const throughputDelay = calculateThroughputDelay(byteSize, condition);\n\n    // Response latency\n    await new Promise(resolve => setTimeout(resolve, latency + throughputDelay));\n\n    // Response packet loss\n    if (Math.random() < condition.packetLoss) {\n      throw new Error(`Network error: Simulated packet loss (${condition.name})`);\n    }\n\n    // Add type assertion to ensure compatibility with ReturnType<T>\n    return result as ReturnType<T>;\n  };\n}\n\n/**\n * Run a test under simulated network conditions\n * @param condition The network condition to simulate\n * @param testFn The test function to run\n * @param options Options for enabling network degradation\n * @returns The result of the test function\n */\nexport async function runWithNetworkCondition<T>(\n  condition: NetworkCondition,\n  testFn: () => Promise<T>,\n  options?: EnableOptions\n): Promise<T> {\n  try {\n    // Enable network degradation\n    enableNetworkDegradation(condition, options);\n\n    // Run the test\n    return await testFn();\n  } finally {\n    // Always disable network degradation when done\n    disableNetworkDegradation();\n  }\n}\n\n/**\n * Run the same test across multiple network conditions\n * @param testFn The test function to run\n * @param conditions The network conditions to test with\n * @param options Options for enabling network degradation\n * @returns Array of results for each network condition\n */\nexport async function runAcrossNetworkConditions<T>(\n  testFn: (condition: NetworkCondition) => Promise<T>,\n  conditions: NetworkCondition[] = Object.values(NetworkProfiles),\n  options?: EnableOptions\n): Promise<Array<{ condition: NetworkCondition; result: T }>> {\n  const results: Array<{ condition: NetworkCondition; result: T }> = [];\n\n  for (const condition of conditions) {\n    try {\n      // Enable network degradation for this condition\n      enableNetworkDegradation(condition, options);\n\n      // Run the test\n      const result = await testFn(condition);\n\n      // Store result\n      results.push({ condition, result });\n    } catch (error) {\n      // Store error as result with proper type handling\n      results.push({\n        condition,\n        result: {\n          error,\n          message: error instanceof Error ? error.message : String(error),\n        } as unknown as T,\n      });\n    } finally {\n      // Disable network degradation between tests\n      disableNetworkDegradation();\n    }\n  }\n\n  return results;\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/preload.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/profiling/applicationProfiler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/profiling/componentProfiler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/profiling/enhancedComponentProfiler.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ComponentRenderMetrics' is defined but never used. Allowed unused vars must match /^ignored|^temp/u.","line":13,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'setDependencies' is defined but never used. Allowed unused vars must match /^ignored|^temp/u.","line":513,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":513,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'cleanup' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":557,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":557,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @context: ui-system, performance-optimization, profiling-system\n * \n * Enhanced component profiler with additional metrics for layout issues,\n * re-render causes, and interaction delays for better performance debugging.\n */\n\nimport * as React from 'react';\nimport { isEqual } from 'lodash';\nimport { \n  ComponentProfilingOptions, \n  ComponentProfilingResult,\n  ComponentRenderMetrics \n} from '../../types/ui/UITypes';\nimport { createComponentProfiler } from './componentProfiler';\n\nexport interface LayoutMetrics {\n  /**\n   * Number of layout shifts detected\n   */\n  layoutShifts: number;\n  \n  /**\n   * Cumulative layout shift score (similar to Core Web Vitals CLS)\n   */\n  cumulativeLayoutShift: number;\n  \n  /**\n   * Time spent in layout operations\n   */\n  layoutDuration: number;\n  \n  /**\n   * Layout shifts with timestamps and impact scores\n   */\n  layoutShiftHistory: Array<{\n    timestamp: number;\n    score: number;\n    sourceElement?: string;\n  }>;\n}\n\nexport interface InteractionMetrics {\n  /**\n   * First input delay measurement (time to response to first interaction)\n   */\n  firstInputDelay: number | null;\n  \n  /**\n   * Interaction to next paint measurements\n   */\n  interactionToNextPaint: Array<{\n    timestamp: number;\n    duration: number;\n    eventType: string;\n  }>;\n  \n  /**\n   * Average time from interaction to next paint\n   */\n  averageInteractionDelay: number;\n  \n  /**\n   * Number of slow interactions (interactions that took too long to respond)\n   */\n  slowInteractions: number;\n}\n\nexport interface EnhancedRenderInfo {\n  /**\n   * Timestamp of the render\n   */\n  timestamp: number;\n  \n  /**\n   * Render duration\n   */\n  renderTime: number;\n  \n  /**\n   * Whether the render was wasted (no visual changes)\n   */\n  wasted: boolean;\n  \n  /**\n   * Props that changed causing the render\n   */\n  changedProps: string[];\n  \n  /**\n   * Whether the render was caused by a state change\n   */\n  causedByStateChange?: boolean;\n  \n  /**\n   * Whether the render was caused by a context change\n   */\n  causedByContextChange?: boolean;\n  \n  /**\n   * Whether the render was caused by a parent re-render\n   */\n  causedByParentRender?: boolean;\n  \n  /**\n   * Whether the render was caused by a hook effect\n   */\n  causedByEffect?: boolean;\n  \n  /**\n   * Reference to the component instance\n   */\n  componentInstance?: unknown;\n}\n\nexport interface EnhancedComponentProfilingOptions extends ComponentProfilingOptions {\n  /**\n   * Whether to track layout metrics\n   */\n  trackLayoutMetrics?: boolean;\n  \n  /**\n   * Whether to track interaction metrics\n   */\n  trackInteractionMetrics?: boolean;\n  \n  /**\n   * Whether to track render causes\n   */\n  trackRenderCauses?: boolean;\n  \n  /**\n   * Whether to analyze component dependencies\n   */\n  analyzeDependencies?: boolean;\n  \n  /**\n   * Threshold for slow interactions in milliseconds\n   */\n  slowInteractionThreshold?: number;\n  \n  /**\n   * Whether to report metrics to the performance observer\n   */\n  reportToPerformanceObserver?: boolean;\n}\n\nexport interface EnhancedComponentProfilingResult extends ComponentProfilingResult {\n  /**\n   * Enhanced information about each render\n   */\n  enhancedRenderHistory: EnhancedRenderInfo[];\n  \n  /**\n   * Layout metrics\n   */\n  layoutMetrics: LayoutMetrics;\n  \n  /**\n   * Interaction metrics\n   */\n  interactionMetrics: InteractionMetrics;\n  \n  /**\n   * Component dependency analysis\n   */\n  dependencies: {\n    contexts: string[];\n    hooks: string[];\n    childComponents: string[];\n  };\n  \n  /**\n   * Reset all enhanced metrics\n   */\n  resetEnhancedMetrics: () => void;\n  \n  /**\n   * Update enhanced profiling options\n   */\n  updateEnhancedOptions: (newOptions: Partial<EnhancedComponentProfilingOptions>) => void;\n  \n  /**\n   * Record a layout shift\n   */\n  recordLayoutShift: (score: number, sourceElement?: string) => void;\n  \n  /**\n   * Record an interaction\n   */\n  recordInteraction: (duration: number, eventType: string) => void;\n  \n  /**\n   * Record render cause\n   */\n  recordRenderCause: (cause: {\n    stateChange?: boolean;\n    contextChange?: boolean;\n    parentRender?: boolean;\n    effect?: boolean;\n  }) => void;\n}\n\n// Add Performance Entry interface for type safety\ninterface PerformanceEntryWithProcessing extends PerformanceEntry {\n  processingStart: number;\n  startTime: number;\n}\n\n/**\n * Default enhanced profiling options\n */\nconst DEFAULT_ENHANCED_PROFILING_OPTIONS: EnhancedComponentProfilingOptions = {\n  enabled: true,\n  logToConsole: false,\n  slowRenderThreshold: 16, // 1 frame at 60fps\n  maxRenderHistory: 100,\n  trackPropChanges: true,\n  trackRenderPath: false,\n  trackLayoutMetrics: true,\n  trackInteractionMetrics: true,\n  trackRenderCauses: true,\n  analyzeDependencies: false,\n  slowInteractionThreshold: 100, // 100ms is considered slow for interactions\n  reportToPerformanceObserver: false,\n};\n\n/**\n * Creates an enhanced component profiler with additional metrics\n * @param componentName Name of the component to profile\n * @param options Profiling options\n * @returns Enhanced component profiling result\n */\nexport function createEnhancedComponentProfiler(\n  componentName: string,\n  options: Partial<EnhancedComponentProfilingOptions> = {}\n): EnhancedComponentProfilingResult {\n  // Create base profiler\n  const baseProfiler = createComponentProfiler(componentName, options);\n  \n  // Merge options with defaults\n  const profilingOptions: EnhancedComponentProfilingOptions = {\n    ...DEFAULT_ENHANCED_PROFILING_OPTIONS,\n    ...options,\n  };\n  \n  // Initialize enhanced metrics\n  const enhancedRenderHistory: EnhancedRenderInfo[] = [];\n  \n  const layoutMetrics: LayoutMetrics = {\n    layoutShifts: 0,\n    cumulativeLayoutShift: 0,\n    layoutDuration: 0,\n    layoutShiftHistory: [],\n  };\n  \n  const interactionMetrics: InteractionMetrics = {\n    firstInputDelay: null,\n    interactionToNextPaint: [],\n    averageInteractionDelay: 0,\n    slowInteractions: 0,\n  };\n  \n  // Initialize with proper typing\n  const dependencies: {\n    contexts: string[];\n    hooks: string[];\n    childComponents: string[];\n  } = {\n    contexts: [],\n    hooks: [],\n    childComponents: [],\n  };\n  \n  // Set up performance observer if enabled\n  let layoutObserver: PerformanceObserver | null = null;\n  let interactionObserver: PerformanceObserver | null = null;\n  \n  if (profilingOptions.trackLayoutMetrics && profilingOptions.reportToPerformanceObserver) {\n    setupLayoutObserver();\n  }\n  \n  if (profilingOptions.trackInteractionMetrics && profilingOptions.reportToPerformanceObserver) {\n    setupInteractionObserver();\n  }\n  \n  /**\n   * Set up layout observer to monitor layout shifts\n   */\n  function setupLayoutObserver() {\n    if (typeof PerformanceObserver === 'undefined') {\n      return;\n    }\n    \n    try {\n      layoutObserver = new PerformanceObserver((list) => {\n        for (const entry of list.getEntries()) {\n          // Ensure it's a layout shift entry\n          if (entry.entryType === 'layout-shift') {\n            // Cast entry to LayoutShiftEntry\n            const layoutShift = entry as unknown as {\n              value: number;\n              sources?: Array<{ node?: Node }>;\n            };\n            \n            recordLayoutShift(\n              layoutShift.value,\n              layoutShift.sources && layoutShift.sources[0]?.node \n                ? getElementDescription(layoutShift.sources[0].node)\n                : undefined\n            );\n          }\n        }\n      });\n      \n      layoutObserver.observe({ type: 'layout-shift', buffered: true });\n    } catch (error) {\n      console.warn('Failed to observe layout shifts:', error);\n    }\n  }\n  \n  /**\n   * Set up interaction observer to monitor interactions\n   */\n  function setupInteractionObserver() {\n    if (typeof PerformanceObserver === 'undefined') {\n      return;\n    }\n    \n    try {\n      interactionObserver = new PerformanceObserver((list) => {\n        for (const entry of list.getEntries()) {\n          // Only process entries related to this component\n          if (entry.name.includes(componentName)) {\n            // Process interaction metrics\n            if (entry.entryType === 'first-input' && interactionMetrics.firstInputDelay === null) {\n              // Use type assertion with specific interface instead of 'any'\n              const typedEntry = entry as PerformanceEntryWithProcessing;\n              interactionMetrics.firstInputDelay = typedEntry.processingStart - typedEntry.startTime;\n            } else if (entry.entryType === 'event') {\n              recordInteraction(\n                entry.duration,\n                entry.name.split(':')[1] || 'unknown'\n              );\n            }\n          }\n        }\n      });\n      \n      interactionObserver.observe({ type: 'event', buffered: true });\n      interactionObserver.observe({ type: 'first-input', buffered: true });\n    } catch (error) {\n      console.warn('Failed to observe interactions:', error);\n    }\n  }\n  \n  /**\n   * Reset all enhanced metrics\n   */\n  function resetEnhancedMetrics() {\n    enhancedRenderHistory.length = 0;\n    \n    layoutMetrics.layoutShifts = 0;\n    layoutMetrics.cumulativeLayoutShift = 0;\n    layoutMetrics.layoutDuration = 0;\n    layoutMetrics.layoutShiftHistory.length = 0;\n    \n    interactionMetrics.firstInputDelay = null;\n    interactionMetrics.interactionToNextPaint.length = 0;\n    interactionMetrics.averageInteractionDelay = 0;\n    interactionMetrics.slowInteractions = 0;\n    \n    dependencies.contexts.length = 0;\n    dependencies.hooks.length = 0;\n    dependencies.childComponents.length = 0;\n  }\n  \n  /**\n   * Update enhanced profiling options\n   */\n  function updateEnhancedOptions(newOptions: Partial<EnhancedComponentProfilingOptions>) {\n    Object.assign(profilingOptions, newOptions);\n    \n    // Update base profiler options\n    baseProfiler.updateOptions(newOptions);\n    \n    // Setup or cleanup observers based on new options\n    if (newOptions.trackLayoutMetrics !== undefined) {\n      if (newOptions.trackLayoutMetrics && profilingOptions.reportToPerformanceObserver) {\n        setupLayoutObserver();\n      } else if (layoutObserver) {\n        layoutObserver.disconnect();\n        layoutObserver = null;\n      }\n    }\n    \n    if (newOptions.trackInteractionMetrics !== undefined) {\n      if (newOptions.trackInteractionMetrics && profilingOptions.reportToPerformanceObserver) {\n        setupInteractionObserver();\n      } else if (interactionObserver) {\n        interactionObserver.disconnect();\n        interactionObserver = null;\n      }\n    }\n  }\n  \n  /**\n   * Record a layout shift\n   */\n  function recordLayoutShift(score: number, sourceElement?: string) {\n    if (!profilingOptions.trackLayoutMetrics) {\n      return;\n    }\n    \n    layoutMetrics.layoutShifts++;\n    layoutMetrics.cumulativeLayoutShift += score;\n    \n    // Add to history\n    layoutMetrics.layoutShiftHistory.push({\n      timestamp: Date.now(),\n      score,\n      sourceElement,\n    });\n    \n    // Trim history if needed\n    if (layoutMetrics.layoutShiftHistory.length > (profilingOptions.maxRenderHistory || 100)) {\n      layoutMetrics.layoutShiftHistory.shift();\n    }\n    \n    // Log if enabled\n    if (profilingOptions.logToConsole && score > 0.1) {\n      console.warn(\n        `Large layout shift detected in ${componentName}: ${score.toFixed(3)}` +\n          (sourceElement ? ` (source: ${sourceElement})` : '')\n      );\n    }\n  }\n  \n  /**\n   * Record an interaction\n   */\n  function recordInteraction(duration: number, eventType: string) {\n    if (!profilingOptions.trackInteractionMetrics) {\n      return;\n    }\n    \n    // Add to history\n    interactionMetrics.interactionToNextPaint.push({\n      timestamp: Date.now(),\n      duration,\n      eventType,\n    });\n    \n    // Trim history if needed\n    if (interactionMetrics.interactionToNextPaint.length > (profilingOptions.maxRenderHistory || 100)) {\n      interactionMetrics.interactionToNextPaint.shift();\n    }\n    \n    // Update average\n    const totalTime = interactionMetrics.interactionToNextPaint.reduce(\n      (sum, item) => sum + item.duration, \n      0\n    );\n    \n    interactionMetrics.averageInteractionDelay = \n      totalTime / interactionMetrics.interactionToNextPaint.length;\n    \n    // Check if slow\n    if (duration > (profilingOptions.slowInteractionThreshold || 100)) {\n      interactionMetrics.slowInteractions++;\n      \n      // Log if enabled\n      if (profilingOptions.logToConsole) {\n        console.warn(\n          `Slow ${eventType} interaction detected in ${componentName}: ${duration.toFixed(2)}ms ` +\n            `(threshold: ${profilingOptions.slowInteractionThreshold || 100}ms)`\n        );\n      }\n    }\n  }\n  \n  /**\n   * Record render cause\n   */\n  function recordRenderCause(cause: {\n    stateChange?: boolean;\n    contextChange?: boolean;\n    parentRender?: boolean;\n    effect?: boolean;\n  }) {\n    if (!profilingOptions.trackRenderCauses) {\n      return;\n    }\n    \n    // Skip if history is empty\n    if (enhancedRenderHistory.length === 0 || baseProfiler.renderHistory.length === 0) {\n      return;\n    }\n    \n    // Get the latest render info\n    const latestRender = enhancedRenderHistory[enhancedRenderHistory.length - 1];\n    \n    // Update cause\n    latestRender.causedByStateChange = cause.stateChange || latestRender.causedByStateChange;\n    latestRender.causedByContextChange = cause.contextChange || latestRender.causedByContextChange;\n    latestRender.causedByParentRender = cause.parentRender || latestRender.causedByParentRender;\n    latestRender.causedByEffect = cause.effect || latestRender.causedByEffect;\n  }\n  \n  /**\n   * Set component dependencies\n   */\n  function setDependencies(deps: {\n    contexts?: string[];\n    hooks?: string[];\n    childComponents?: string[];\n  }) {\n    if (!profilingOptions.analyzeDependencies) {\n      return;\n    }\n    \n    if (deps.contexts && deps.contexts.length > 0) {\n      // Use a safe array spread that respects types\n      dependencies.contexts = Array.from(new Set([...dependencies.contexts, ...deps.contexts]));\n    }\n    \n    if (deps.hooks && deps.hooks.length > 0) {\n      // Use a safe array spread that respects types\n      dependencies.hooks = Array.from(new Set([...dependencies.hooks, ...deps.hooks]));\n    }\n    \n    if (deps.childComponents && deps.childComponents.length > 0) {\n      // Use a safe array spread that respects types\n      dependencies.childComponents = Array.from(new Set([...dependencies.childComponents, ...deps.childComponents]));\n    }\n  }\n  \n  /**\n   * Helper to get a description of a DOM element\n   */\n  function getElementDescription(node: Node): string {\n    if (node.nodeType !== Node.ELEMENT_NODE) {\n      return node.nodeName || 'unknown';\n    }\n    \n    const element = node as Element;\n    const tag = element.tagName.toLowerCase();\n    const id = element.id ? `#${element.id}` : '';\n    const classes = element.className && typeof element.className === 'string'\n      ? `.${element.className.split(' ').join('.')}`\n      : '';\n    \n    return `${tag}${id}${classes}`;\n  }\n  \n  // Cleanup function\n  const cleanup = () => {\n    if (layoutObserver) {\n      layoutObserver.disconnect();\n    }\n    \n    if (interactionObserver) {\n      interactionObserver.disconnect();\n    }\n  };\n  \n  // Override the base profiler's onRender method to add enhanced metrics\n  const originalProfileRender = baseProfiler.profileRender;\n  baseProfiler.profileRender = <Props, Result>(\n    renderFn: (props: Props) => Result,\n    prevProps: Props | null,\n    nextProps: Props\n  ): Result => {\n    // Call original profile render first\n    const result = originalProfileRender(renderFn, prevProps, nextProps);\n    \n    // Add enhanced render info\n    if (\n      profilingOptions.enabled &&\n      baseProfiler.renderHistory.length > 0 &&\n      enhancedRenderHistory.length < baseProfiler.renderHistory.length\n    ) {\n      const latestBaseRender = baseProfiler.renderHistory[baseProfiler.renderHistory.length - 1];\n      \n      // Create enhanced render info\n      const enhancedRender: EnhancedRenderInfo = {\n        timestamp: latestBaseRender.timestamp,\n        renderTime: latestBaseRender.renderTime,\n        wasted: latestBaseRender.wasted,\n        // Use null checking before spreading array to avoid Symbol.iterator error\n        changedProps: latestBaseRender.changedProps ? [...latestBaseRender.changedProps] : [],\n        // Start with undefined cause - will be filled in later\n        causedByStateChange: undefined,\n        causedByContextChange: undefined,\n        causedByParentRender: undefined,\n        causedByEffect: undefined,\n      };\n      \n      // Add to history\n      enhancedRenderHistory.push(enhancedRender);\n      \n      // Trim history if needed\n      if (enhancedRenderHistory.length > (profilingOptions.maxRenderHistory || 100)) {\n        enhancedRenderHistory.shift();\n      }\n    }\n    \n    return result;\n  };\n  \n  // Return the enhanced profiler\n  return {\n    ...baseProfiler,\n    enhancedRenderHistory,\n    layoutMetrics,\n    interactionMetrics,\n    dependencies,\n    resetEnhancedMetrics,\n    updateEnhancedOptions,\n    recordLayoutShift,\n    recordInteraction,\n    recordRenderCause,\n  };\n}\n\n/**\n * Create an enhanced profiler hook for functional components\n */\nexport function useEnhancedComponentProfiler(\n  componentName: string,\n  options: Partial<EnhancedComponentProfilingOptions> = {}\n): EnhancedComponentProfilingResult {\n  // Create a ref to store the profiler\n  const profilerRef = React.useRef<EnhancedComponentProfilingResult | null>(null);\n  \n  // Create cause tracker\n  const causeRef = React.useRef({\n    stateChange: false,\n    contextChange: false,\n    parentRender: false,\n    effect: false,\n  });\n  \n  // Initialize the profiler if it doesn't exist\n  if (!profilerRef.current) {\n    profilerRef.current = createEnhancedComponentProfiler(componentName, options);\n  }\n  \n  // Get the profiler\n  const profiler = profilerRef.current;\n  \n  // Update options when they change\n  React.useEffect(() => {\n    profiler.updateEnhancedOptions(options);\n  }, [profiler, options]);\n  \n  // Record render time\n  const renderStartTime = React.useRef(performance.now());\n  \n  // Track layout effects\n  React.useLayoutEffect(() => {\n    const layoutTime = performance.now();\n    const layoutDuration = layoutTime - renderStartTime.current;\n    \n    // Update layout duration\n    profiler.layoutMetrics.layoutDuration += layoutDuration;\n    \n    // Reset cause tracker for next render\n    causeRef.current = {\n      stateChange: false,\n      contextChange: false,\n      parentRender: false,\n      effect: false,\n    };\n    \n    return () => {\n      // Mark this render as caused by an effect if cleanup runs\n      causeRef.current.effect = true;\n    };\n  });\n  \n  // Hook to use before setState to track state changes as a cause\n  const trackStateChange = React.useCallback(() => {\n    causeRef.current.stateChange = true;\n  }, []);\n  \n  // Function to wrap a setState function to track state changes\n  const wrapSetState = React.useCallback(<T>(setState: React.Dispatch<React.SetStateAction<T>>) => {\n    return (value: React.SetStateAction<T>) => {\n      trackStateChange();\n      return setState(value);\n    };\n  }, [trackStateChange]);\n  \n  return {\n    ...profiler,\n    // Add a trackStateChange method for convenience\n    trackStateChange,\n    // Add a wrapSetState method for convenience\n    wrapSetState,\n  } as EnhancedComponentProfilingResult & {\n    trackStateChange: () => void;\n    wrapSetState: <T>(setState: React.Dispatch<React.SetStateAction<T>>) => \n      React.Dispatch<React.SetStateAction<T>>;\n  };\n}\n\n/**\n * Higher-order component that adds enhanced profiling to a component\n */\nexport function withEnhancedProfiling<Props extends object>(\n  Component: React.ComponentType<Props>,\n  options: Partial<EnhancedComponentProfilingOptions> = {}\n): React.FC<Props> & { profiler: EnhancedComponentProfilingResult } {\n  const componentName = Component.displayName || Component.name || 'Component';\n  const profiler = createEnhancedComponentProfiler(componentName, options);\n  \n  const WithProfiling: React.FC<Props> & { profiler: EnhancedComponentProfilingResult } = \n    React.memo(\n      (props: Props) => {\n        // Create a ref for previous props\n        const prevPropsRef = React.useRef<Props | null>(null);\n\n        // Profile the render with proper type assertion to avoid untyped function call error\n        const renderedOutput = (profiler.profileRender as <P, R>(\n          renderFn: (props: P) => R,\n          prevProps: P | null,\n          nextProps: P\n        ) => R)<Props, React.ReactElement>(\n          // Use Props type instead of any\n          (renderProps: Props) => React.createElement(Component, renderProps),\n          prevPropsRef.current,\n          props\n        );\n\n        // Update previous props\n        prevPropsRef.current = props;\n\n        return renderedOutput;\n      },\n      (prevProps, nextProps) => {\n        // Skip re-renders if disabled\n        if (!options.enabled) {\n          return true;\n        }\n\n        // Check for prop changes\n        const hasChanged = !isEqual(prevProps, nextProps);\n\n        // Record as a wasted render if props haven't changed\n        if (!hasChanged && profiler.metrics.renderCount > 0) {\n          profiler.metrics.wastedRenders++;\n        }\n\n        return !hasChanged;\n      }\n    ) as unknown as React.FC<Props> & { profiler: EnhancedComponentProfilingResult };\n  \n  // Add profiler to component\n  WithProfiling.profiler = profiler;\n  \n  // Forward the display name\n  WithProfiling.displayName = `WithEnhancedProfiling(${componentName})`;\n  \n  return WithProfiling;\n} ","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/profiling/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/resources/ResourceTypeConverter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/resources/ResourceTypeMigration.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'EnumResourceType' is defined but never used. Allowed unused vars must match /^ignored|^temp/u.","line":12,"column":6,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Resource Type Migration Utility\n *\n * This utility provides functions to help migrate from string-based resource types\n * to enum-based resource types. It includes functions for converting string literals,\n * object keys, arrays, and more.\n */\n\nimport { ResourceType, ResourceTypeString } from './../../types/resources/ResourceTypes';\n\n// Define type aliases for clarity in migration functions\ntype EnumResourceType = ResourceType;\ntype StringResourceType = ResourceTypeString;\n\n/**\n * Generates a migration guide for resource types\n * @returns A markdown string with a migration guide\n */\nexport function generateMigrationGuide(): string {\n  let guide = `# Resource Type Migration Guide\\n\\n`;\n  guide += `This guide helps you migrate from string-based resource types to enum-based resource types.\\n\\n`;\n  guide += `## Mapping Table\\n\\n`;\n  guide += `| String Type | Enum Type |\\n`;\n  guide += `|------------|----------|\\n`;\n\n  // Manually create the mapping table to avoid type issues\n  guide += `| ResourceType.MINERALS | ResourceType.MINERALS |\\n`;\n  guide += `| ResourceType.ENERGY | ResourceType.ENERGY |\\n`;\n  guide += `| ResourceType.POPULATION | ResourceType.POPULATION |\\n`;\n  guide += `| ResourceType.RESEARCH | ResourceType.RESEARCH |\\n`;\n  guide += `| ResourceType.PLASMA | ResourceType.PLASMA |\\n`;\n  guide += `| ResourceType.GAS | ResourceType.GAS |\\n`;\n  guide += `| ResourceType.EXOTIC | ResourceType.EXOTIC |\\n`;\n\n  guide += `\\n## Migration Steps\\n\\n`;\n  guide += `1. Update imports to use ResourceTypes instead of any other resource type definition\\n`;\n  guide += `2. Replace string literals with enum values using the mapping table above\\n`;\n  guide += `3. Update function signatures to use the enum type\\n`;\n  guide += `4. Use the migration utility functions for complex cases\\n`;\n\n  return guide;\n}\n\n/**\n * Maps string resource types to enum resource types\n */\nconst STRING_TO_ENUM_MAP: Record<string, ResourceType> = {\n  MINERALS: ResourceType.MINERALS,\n  ENERGY: ResourceType.ENERGY,\n  POPULATION: ResourceType.POPULATION,\n  RESEARCH: ResourceType.RESEARCH,\n  PLASMA: ResourceType.PLASMA,\n  GAS: ResourceType.GAS,\n  EXOTIC: ResourceType.EXOTIC,\n  ORGANIC: ResourceType.ORGANIC,\n  FOOD: ResourceType.FOOD,\n  IRON: ResourceType.IRON,\n  COPPER: ResourceType.COPPER,\n  TITANIUM: ResourceType.TITANIUM,\n  URANIUM: ResourceType.URANIUM,\n  WATER: ResourceType.WATER,\n  HELIUM: ResourceType.HELIUM,\n  DEUTERIUM: ResourceType.DEUTERIUM,\n  ANTIMATTER: ResourceType.ANTIMATTER,\n  DARK_MATTER: ResourceType.DARK_MATTER,\n  EXOTIC_MATTER: ResourceType.EXOTIC_MATTER,\n};\n\n/**\n * Maps enum resource types to string resource types\n */\nconst ENUM_TO_STRING_MAP: Record<ResourceType, string> = {\n  [ResourceType.MINERALS]: 'MINERALS',\n  [ResourceType.ENERGY]: 'ENERGY',\n  [ResourceType.POPULATION]: 'POPULATION',\n  [ResourceType.RESEARCH]: 'RESEARCH',\n  [ResourceType.PLASMA]: 'PLASMA',\n  [ResourceType.GAS]: 'GAS',\n  [ResourceType.EXOTIC]: 'EXOTIC',\n  [ResourceType.ORGANIC]: 'ORGANIC',\n  [ResourceType.FOOD]: 'FOOD',\n  [ResourceType.IRON]: 'IRON',\n  [ResourceType.COPPER]: 'COPPER',\n  [ResourceType.TITANIUM]: 'TITANIUM',\n  [ResourceType.URANIUM]: 'URANIUM',\n  [ResourceType.WATER]: 'WATER',\n  [ResourceType.HELIUM]: 'HELIUM',\n  [ResourceType.DEUTERIUM]: 'DEUTERIUM',\n  [ResourceType.ANTIMATTER]: 'ANTIMATTER',\n  [ResourceType.DARK_MATTER]: 'DARK_MATTER',\n  [ResourceType.EXOTIC_MATTER]: 'EXOTIC_MATTER',\n};\n\n/**\n * Converts a string resource type to an enum resource type\n * @param resourceType The string resource type\n * @returns The enum ResourceType\n */\nexport function toEnumResourceType(resourceType: StringResourceType): ResourceType {\n  if (!(resourceType in STRING_TO_ENUM_MAP)) {\n    console.warn(`Unknown resource type: ${resourceType}, defaulting to MINERALS`);\n    return ResourceType.MINERALS;\n  }\n  return STRING_TO_ENUM_MAP[resourceType];\n}\n\n/**\n * Converts an enum resource type to a string resource type\n * @param resourceType The enum resource type\n * @returns The string resource type\n */\nexport function toStringResourceType(resourceType: ResourceType): StringResourceType | string {\n  if (!(resourceType in ENUM_TO_STRING_MAP)) {\n    console.warn(`Unknown resource type: ${resourceType}, defaulting to minerals`);\n    return ResourceType.MINERALS;\n  }\n  return ENUM_TO_STRING_MAP[resourceType];\n}\n\n/**\n * Checks if a value is a valid string resource type\n * @param value The value to check\n * @returns Whether the value is a valid string resource type\n */\nexport function isStringResourceType(value: unknown): value is StringResourceType {\n  return typeof value === 'string' && value in STRING_TO_ENUM_MAP;\n}\n\n/**\n * Checks if a value is a valid enum resource type\n * @param value The value to check\n * @returns Whether the value is a valid enum resource type\n */\nexport function isEnumResourceType(value: unknown): value is ResourceType {\n  return typeof value === 'string' && Object.values(ResourceType).includes(value as ResourceType);\n}\n\n/**\n * Ensures a value is an enum resource type\n * @param resourceType Either a string resource type or an enum resource type\n * @returns The enum ResourceType\n */\nexport function ensureEnumResourceType(\n  resourceType: StringResourceType | ResourceType\n): ResourceType {\n  // If it's already an enum type, return it\n  if (Object.values(ResourceType).includes(resourceType as ResourceType)) {\n    return resourceType as ResourceType;\n  }\n\n  // Otherwise, convert it\n  return toEnumResourceType(resourceType as StringResourceType);\n}\n\n/**\n * Ensures a value is a string resource type\n * @param value The value to ensure is a string resource type\n * @returns The string resource type\n * @throws Error if the value cannot be converted to a string resource type\n */\nexport function ensureStringResourceType(value: unknown): StringResourceType | string {\n  if (isStringResourceType(value)) {\n    return value;\n  }\n\n  if (isEnumResourceType(value)) {\n    return toStringResourceType(value);\n  }\n\n  console.warn(`Unknown resource type: ${value}, defaulting to minerals`);\n  return ResourceType.MINERALS;\n}\n\n/**\n * Converts an array of items with resource types from string to enum\n * @param array The array to convert\n * @param converter The conversion function\n * @returns The converted array\n */\nexport function convertArrayResourceTypes<T>(array: T[], converter: (item: T) => T): T[] {\n  return array.map(converter);\n}\n\n/**\n * Converts a record with string resource type keys to enum resource type keys\n * @param record The record to convert\n * @returns The converted record\n */\nexport function convertRecordResourceTypes<T>(\n  record: Record<StringResourceType, T>\n): Record<ResourceType, T> {\n  const result: Record<ResourceType, T> = {} as Record<ResourceType, T>;\n  for (const [key, value] of Object.entries(record)) {\n    if (isStringResourceType(key)) {\n      result[toEnumResourceType(key)] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * Converts a map with string resource type keys to enum resource type keys\n * @param map The map to convert\n * @returns The converted map\n */\nexport function convertMapResourceTypes<T>(map: Map<StringResourceType, T>): Map<ResourceType, T> {\n  const result = new Map<ResourceType, T>();\n  // Use Array.from to avoid iterator issues\n  Array.from(map.entries()).forEach(([key, value]) => {\n    result?.set(toEnumResourceType(key), value);\n  });\n  return result;\n}\n\n/**\n * Analyzes a file for resource type migration needs\n * @param fileContent The file content to analyze\n * @returns Analysis results\n */\nexport function analyzeMigrationNeeds(fileContent: string): {\n  stringResourceTypes: number;\n  enumResourceTypes: number;\n  mixedUsage: boolean;\n} {\n  const stringMatches = (\n    fileContent.match(\n      /['\"]minerals['\"]|['\"]energy['\"]|['\"]population['\"]|['\"]research['\"]|['\"]plasma['\"]|['\"]gas['\"]|['\"]exotic['\"]/g\n    ) ?? []\n  ).length;\n  const enumMatches = (\n    fileContent.match(\n      /ResourceType\\.MINERALS|ResourceType\\.ENERGY|ResourceType\\.POPULATION|ResourceType\\.RESEARCH|ResourceType\\.PLASMA|ResourceType\\.GAS|ResourceType\\.EXOTIC/g\n    ) ?? []\n  ).length;\n\n  return {\n    stringResourceTypes: stringMatches,\n    enumResourceTypes: enumMatches,\n    mixedUsage: stringMatches > 0 && enumMatches > 0,\n  };\n}\n\n/**\n * Applies migration to a file content\n * @param fileContent The file content to migrate\n * @returns The migrated file content\n */\nexport function applyMigration(fileContent: string): string {\n  let result = fileContent;\n\n  // Replace string literals with enum values\n  result = result?.replace(/['\"]minerals['\"]/g, 'ResourceType.MINERALS');\n  result = result?.replace(/['\"]energy['\"]/g, 'ResourceType.ENERGY');\n  result = result?.replace(/['\"]population['\"]/g, 'ResourceType.POPULATION');\n  result = result?.replace(/['\"]research['\"]/g, 'ResourceType.RESEARCH');\n  result = result?.replace(/['\"]plasma['\"]/g, 'ResourceType.PLASMA');\n  result = result?.replace(/['\"]gas['\"]/g, 'ResourceType.GAS');\n  result = result?.replace(/['\"]exotic['\"]/g, 'ResourceType.EXOTIC');\n\n  return result;\n}\n\n/**\n * Checks if a file needs migration\n * @param fileContent The file content to check\n * @returns Whether the file needs migration\n */\nexport function needsMigration(fileContent: string): boolean {\n  const { stringResourceTypes, enumResourceTypes } = analyzeMigrationNeeds(fileContent);\n  return stringResourceTypes > 0 && enumResourceTypes === 0;\n}\n\n/**\n * Creates a compatibility layer for functions that need to work with both string and enum resource types\n * @param original The original function\n * @param parameterIndices The indices of parameters to convert\n * @param convertToEnum Whether to convert to enum (true) or string (false)\n * @returns The wrapped function\n */\nexport function createResourceTypeCompatibilityLayer<T extends (...args: unknown[]) => unknown>(\n  original: T,\n  parameterIndices: number[],\n  convertToEnum: boolean\n): T {\n  return ((...args: unknown[]) => {\n    const newArgs = [...args];\n    for (const index of parameterIndices) {\n      if (index >= args.length) continue;\n\n      if (convertToEnum) {\n        newArgs[index] = ensureEnumResourceType(args[index] as StringResourceType | ResourceType);\n      } else {\n        newArgs[index] = ensureStringResourceType(args[index]);\n      }\n    }\n    return original(...newArgs);\n  }) as T;\n}\n\n/**\n * Migrates object keys from string resource types to enum resource types\n * @param obj The object to migrate\n * @returns The migrated object\n */\nexport function migrateObjectKeys<T>(obj: Record<StringResourceType, T>): Record<ResourceType, T> {\n  const result: Partial<Record<ResourceType, T>> = {};\n\n  for (const [key, value] of Object.entries(obj)) {\n    if (isStringResourceType(key)) {\n      result[toEnumResourceType(key as StringResourceType)] = value;\n    }\n  }\n\n  return result as Record<ResourceType, T>;\n}\n\n/**\n * Migrates resource types in an array of objects\n * @param arr The array to migrate\n * @param propertyName The property name containing the resource type\n * @returns The migrated array\n */\nexport function migrateArrayResourceTypes<T extends Record<string, unknown>>(\n  arr: T[],\n  propertyName: string = 'type'\n): T[] {\n  return arr.map(item => {\n    if (\n      propertyName in item &&\n      typeof item[propertyName] === 'string' &&\n      isStringResourceType(item[propertyName] as string)\n    ) {\n      return {\n        ...item,\n        [propertyName]: toEnumResourceType(item[propertyName] as StringResourceType),\n      };\n    }\n    return item;\n  });\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/resources/resourceUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/resources/resourceValidation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/services/ServiceAccess.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/ships/shipClassUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/ships/shipUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/spatial/SpatialPartitioning.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/state/contextSelectors.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/state/stateMigration.ts","messages":[{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":116,"column":7,"nodeType":"MemberExpression","messageId":"limited","endLine":116,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"debug"},"fix":{"range":[2686,2742],"text":""},"desc":"Remove the console.debug()."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @context: state-system, migration\n * \n * State migration utilities for handling schema changes between application versions.\n * These utilities allow for seamless migration of stored state when the schema changes,\n * with support for validation, type checking, and complex transformations.\n */\n\n/**\n * Represents a migration function that transforms state from one version to another\n */\nexport type MigrationFn<T = unknown> = (state: unknown) => T;\n\n/**\n * Represents a migration step with a target version and migration function\n */\ninterface MigrationStep<T = unknown> {\n  /**\n   * The version this migration transforms the state to\n   */\n  toVersion: number;\n\n  /**\n   * The migration function\n   */\n  migrate: MigrationFn<T>;\n\n  /**\n   * Optional description of what this migration does\n   */\n  description?: string;\n}\n\n/**\n * Options for creating a migration manager\n */\ninterface MigrationManagerOptions<T> {\n  /**\n   * The current version of the state schema\n   */\n  currentVersion: number;\n\n  /**\n   * Initial migrations to register\n   */\n  migrations?: MigrationStep<T>[];\n\n  /**\n   * Optional function to validate the final migrated state\n   */\n  validate?: (state: T) => boolean;\n\n  /**\n   * Optional flag to enable debug logging\n   */\n  debug?: boolean;\n\n  /**\n   * Optional schema validation function for the state\n   */\n  schemaValidator?: (state: unknown) => boolean;\n\n  /**\n   * Optional flag to enable performance monitoring\n   */\n  performanceMonitoring?: boolean;\n\n  /**\n   * Optional function to handle migration errors\n   */\n  onError?: (error: Error, state: unknown, fromVersion: number) => void;\n}\n\n/**\n * Error class for migration failures\n */\nexport class MigrationError extends Error {\n  constructor(\n    public readonly fromVersion: number,\n    public readonly toVersion: number,\n    message: string,\n    public readonly originalError?: unknown\n  ) {\n    super(message);\n    this.name = 'MigrationError';\n  }\n}\n\n/**\n * Create a migration manager for handling state schema migrations\n */\nexport function createMigrationManager<T>(options: MigrationManagerOptions<T>) {\n  const {\n    currentVersion,\n    migrations: initialMigrations = [],\n    validate = () => true,\n    debug = false,\n    schemaValidator,\n    performanceMonitoring = false,\n    onError,\n  } = options;\n\n  // Store migrations by target version\n  const migrationsByVersion = new Map<number, MigrationStep<T>>();\n  \n  // Initialize with provided migrations\n  initialMigrations.forEach(migration => {\n    migrationsByVersion.set(migration.toVersion, migration);\n  });\n\n  /**\n   * Internal debug logging\n   */\n  const log = (message: string, ...args: unknown[]) => {\n    if (debug) {\n      console.debug(`[MigrationManager] ${message}`, ...args);\n    }\n  };\n\n  /**\n   * Chain another migration step\n   */\n  const createStepChainer = (currentVersion: number) => {\n    const addStep = (nextVersion: number, nextMigrateFn: MigrationFn<T>, nextDescription?: string) => {\n      if (nextVersion <= currentVersion) {\n        throw new Error(\n          `Invalid migration chain: version ${nextVersion} is not greater than ${currentVersion}`\n        );\n      }\n      registerMigration(nextVersion, nextMigrateFn, nextDescription);\n      return { addStep };\n    };\n    \n    return { addStep };\n  };\n\n  /**\n   * Register a migration for a specific version\n   */\n  const registerMigration = (toVersion: number, migrateFn: MigrationFn<T>, description?: string) => {\n    // Validate version\n    if (typeof toVersion !== 'number' || toVersion <= 0) {\n      throw new Error(`Invalid migration version: ${toVersion}. Version must be a positive number.`);\n    }\n\n    // Check if a migration already exists for this version\n    if (migrationsByVersion.has(toVersion)) {\n      log(`Overwriting existing migration for version ${toVersion}`);\n    }\n\n    // Register the migration\n    migrationsByVersion.set(toVersion, {\n      toVersion,\n      migrate: migrateFn,\n      description,\n    });\n\n    log(`Registered migration to version ${toVersion}${description ? `: ${description}` : ''}`);\n\n    return createStepChainer(toVersion);\n  };\n\n  /**\n   * Migrate state from one version to another\n   */\n  const migrateState = (state: unknown, fromVersion: number): T => {\n    // If already at current version, return as is\n    if (fromVersion === currentVersion) {\n      return state as T;\n    }\n\n    // Validate fromVersion\n    if (typeof fromVersion !== 'number' || fromVersion < 0) {\n      throw new Error(`Invalid fromVersion: ${fromVersion}`);\n    }\n\n    log(`Migrating state from version ${fromVersion} to ${currentVersion}`);\n\n    // Performance monitoring\n    const startTime = performanceMonitoring ? performance.now() : 0;\n\n    try {\n      // Find all applicable migrations\n      const applicableMigrations: MigrationStep<T>[] = [];\n      let targetVersion = fromVersion;\n\n      // Create a sorted array of migration versions\n      const versions = Array.from(migrationsByVersion.keys()).sort((a, b) => a - b);\n\n      // Find all migrations that apply to this state\n      for (const version of versions) {\n        if (version > fromVersion && version <= currentVersion) {\n          const migration = migrationsByVersion.get(version);\n          if (migration) {\n            applicableMigrations.push(migration);\n            targetVersion = version;\n          }\n        }\n      }\n\n      // Check if we have migrations to apply\n      if (applicableMigrations.length === 0) {\n        log(`No migrations available from version ${fromVersion} to ${currentVersion}`);\n        \n        // Just validate and return if there are no migrations\n        if (schemaValidator && !schemaValidator(state)) {\n          throw new MigrationError(\n            fromVersion,\n            currentVersion,\n            'Schema validation failed for current version'\n          );\n        }\n        \n        if (!validate(state as T)) {\n          throw new MigrationError(\n            fromVersion,\n            currentVersion,\n            'State validation failed'\n          );\n        }\n        \n        return state as T;\n      }\n\n      // Apply migrations in sequence\n      let migratedState = state;\n      for (const migration of applicableMigrations) {\n        log(`Applying migration to version ${migration.toVersion}${migration.description ? `: ${migration.description}` : ''}`);\n        \n        try {\n          migratedState = migration.migrate(migratedState);\n          \n          // Validate the intermediate state if requested\n          if (migration.toVersion === currentVersion && schemaValidator && !schemaValidator(migratedState)) {\n            throw new MigrationError(\n              fromVersion,\n              migration.toVersion,\n              'Schema validation failed after migration'\n            );\n          }\n        } catch (error) {\n          if (error instanceof MigrationError) {\n            throw error;\n          }\n          \n          throw new MigrationError(\n            fromVersion,\n            migration.toVersion,\n            `Migration failed: ${error instanceof Error ? error.message : String(error)}`,\n            error\n          );\n        }\n      }\n\n      // Validate the final state\n      if (!validate(migratedState as T)) {\n        throw new MigrationError(\n          fromVersion,\n          targetVersion,\n          'Final state validation failed'\n        );\n      }\n\n      // Log performance information\n      if (performanceMonitoring) {\n        const endTime = performance.now();\n        log(`Migration completed in ${(endTime - startTime).toFixed(2)}ms`);\n      }\n\n      return migratedState as T;\n    } catch (error) {\n      log('Migration failed', error);\n      \n      // Call onError handler if provided\n      if (onError && error instanceof Error) {\n        onError(error, state, fromVersion);\n      }\n      \n      // Re-throw the error\n      throw error;\n    }\n  };\n\n  /**\n   * Get all registered migrations\n   */\n  const getMigrations = () => {\n    return Array.from(migrationsByVersion.values()).sort((a, b) => a.toVersion - b.toVersion);\n  };\n\n  /**\n   * Get the current schema version\n   */\n  const getCurrentVersion = () => currentVersion;\n\n  /**\n   * Check if direct migration from a specific version is supported\n   */\n  const canMigrateFrom = (version: number) => {\n    if (version === currentVersion) {\n      return true;\n    }\n    \n    // Check if we have all required migrations to get from version to current\n    const versions = Array.from(migrationsByVersion.keys()).sort((a, b) => a - b);\n    let lastVersion = version;\n    \n    for (const migrationVersion of versions) {\n      if (migrationVersion > lastVersion && migrationVersion <= currentVersion) {\n        lastVersion = migrationVersion;\n      }\n    }\n    \n    return lastVersion === currentVersion;\n  };\n\n  return {\n    registerMigration,\n    migrateState,\n    getMigrations,\n    getCurrentVersion,\n    canMigrateFrom,\n  };\n}\n\n/**\n * Create a migration builder for a fluent API to define migrations\n */\nexport function createMigrationBuilder<T>(currentVersion: number) {\n  const migrations: MigrationStep<T>[] = [];\n\n  /**\n   * Add a migration step\n   */\n  const addMigration = (toVersion: number, migrateFn: MigrationFn<T>, description?: string) => {\n    migrations.push({\n      toVersion,\n      migrate: migrateFn,\n      description,\n    });\n\n    return { addMigration, build };\n  };\n\n  /**\n   * Build the migration manager\n   */\n  const build = (\n    options: Omit<MigrationManagerOptions<T>, 'currentVersion' | 'migrations'> = {}\n  ) => {\n    return createMigrationManager<T>({\n      currentVersion,\n      migrations,\n      ...options,\n    });\n  };\n\n  return {\n    addMigration,\n    build,\n  };\n}\n\n// Utility functions for common migration operations\n\n/**\n * Add a property to an object with a default value\n */\nexport function addProperty<T extends Record<string, unknown>, K extends string, V>(\n  state: T,\n  key: K,\n  defaultValue: V\n): T & Record<K, V> {\n  return {\n    ...state,\n    [key]: defaultValue,\n  };\n}\n\n/**\n * Rename a property in an object\n */\nexport function renameProperty<T extends Record<string, unknown>, K extends string>(\n  state: T,\n  oldKey: keyof T,\n  newKey: K\n): Omit<T, typeof oldKey> & Record<K, unknown> {\n  const { [oldKey]: value, ...rest } = state;\n  \n  // Create the new object with properly typed properties\n  const result = rest as Omit<T, typeof oldKey>;\n  (result as Record<string, unknown>)[newKey] = value;\n  \n  return result as Omit<T, typeof oldKey> & Record<K, unknown>;\n}\n\n/**\n * Remove a property from an object\n */\nexport function removeProperty<T extends Record<string, unknown>, K extends keyof T>(\n  state: T,\n  key: K\n): Omit<T, K> {\n  const { [key]: _, ...rest } = state;\n  return rest;\n}\n\n/**\n * Transform a property using a function\n */\nexport function transformProperty<T extends Record<string, unknown>, K extends keyof T, V>(\n  state: T,\n  key: K,\n  transformFn: (value: T[K]) => V\n): Omit<T, K> & Record<K, V> {\n  return {\n    ...state,\n    [key]: transformFn(state[key]),\n  };\n}\n\n/**\n * Deep merge two objects\n */\nexport function deepMerge<T extends Record<string, unknown>>(\n  target: T,\n  source: Partial<T>\n): T {\n  const output = { ...target };\n  \n  Object.keys(source).forEach(key => {\n    const sourceKey = key as keyof typeof source;\n    const targetKey = key as keyof typeof target;\n    \n    if (\n      source[sourceKey] !== null &&\n      typeof source[sourceKey] === 'object' &&\n      !Array.isArray(source[sourceKey]) &&\n      target[targetKey] !== null &&\n      typeof target[targetKey] === 'object' &&\n      !Array.isArray(target[targetKey])\n    ) {\n      // Recursively merge objects\n      output[targetKey] = deepMerge(\n        target[targetKey] as Record<string, unknown>,\n        source[sourceKey] as Record<string, unknown>\n      ) as T[keyof T];\n    } else {\n      // Direct assignment for non-objects or arrays\n      output[targetKey] = source[sourceKey] as T[keyof T];\n    }\n  });\n  \n  return output;\n}\n\n/**\n * Add an item to an array property\n */\nexport function addToArray<T extends Record<string, unknown>, K extends keyof T, V>(\n  state: T,\n  key: K,\n  item: V\n): T {\n  if (!Array.isArray(state[key])) {\n    throw new Error(`Property ${String(key)} is not an array`);\n  }\n  \n  return {\n    ...state,\n    [key]: [...(state[key] as unknown[]), item],\n  };\n}\n\n/**\n * Filter items in an array property\n */\nexport function filterArray<T extends Record<string, unknown>, K extends keyof T>(\n  state: T,\n  key: K,\n  predicate: (item: unknown, index: number, array: unknown[]) => boolean\n): T {\n  if (!Array.isArray(state[key])) {\n    throw new Error(`Property ${String(key)} is not an array`);\n  }\n  \n  return {\n    ...state,\n    [key]: (state[key] as unknown[]).filter(predicate),\n  };\n}\n\n/**\n * Map items in an array property\n */\nexport function mapArray<T extends Record<string, unknown>, K extends keyof T, V>(\n  state: T,\n  key: K,\n  mapper: (item: unknown, index: number, array: unknown[]) => V\n): T {\n  if (!Array.isArray(state[key])) {\n    throw new Error(`Property ${String(key)} is not an array`);\n  }\n  \n  return {\n    ...state,\n    [key]: (state[key] as unknown[]).map(mapper),\n  };\n}\n\n/**\n * Create a migration chain from a series of migration functions\n */\nexport function createMigrationChain<T>(\n  fromVersion: number,\n  migrations: Array<{ toVersion: number; transform: MigrationFn<T>; description?: string }>\n): (state: unknown) => T {\n  return (state: unknown) => {\n    // Sort migrations by version\n    const sortedMigrations = [...migrations].sort((a, b) => a.toVersion - b.toVersion);\n    \n    // Validate migration chain\n    let lastVersion = fromVersion;\n    for (const migration of sortedMigrations) {\n      if (migration.toVersion <= lastVersion) {\n        throw new Error(`Invalid migration chain: version ${migration.toVersion} must be greater than ${lastVersion}`);\n      }\n      lastVersion = migration.toVersion;\n    }\n    \n    // Apply migrations in sequence\n    let result = state;\n    for (const migration of sortedMigrations) {\n      result = migration.transform(result);\n    }\n    \n    return result as T;\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/state/statePersistence.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'deserialize' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":121,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":121,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isEqual' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":122,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":122,"endColumn":12},{"ruleId":"no-console","severity":1,"message":"Unexpected console statement. Only these console methods are allowed: warn, error.","line":137,"column":7,"nodeType":"MemberExpression","messageId":"limited","endLine":137,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"debug"},"fix":{"range":[3097,3160],"text":""},"desc":"Remove the console.debug()."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'persistedStr' is assigned a value but never used. Allowed unused vars must match /^ignored|^temp/u.","line":221,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":221,"endColumn":29}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @context: state-system, persistence\n * \n * State persistence utilities for storing and loading application state.\n * These utilities handle localStorage persistence with versioning, migration,\n * and optional compression.\n */\n\nimport { isEqual as lodashIsEqual } from 'lodash';\nimport { useEffect, useRef, useState } from 'react';\n\ninterface PersistenceOptions<T> {\n  /**\n   * The key to use for localStorage\n   */\n  key: string;\n\n  /**\n   * The current version of the state schema\n   */\n  version: number;\n\n  /**\n   * Optional function to migrate state from a previous version\n   */\n  migrate?: (state: unknown, fromVersion: number) => T;\n\n  /**\n   * Optional function to validate the state before loading\n   */\n  validate?: (state: unknown) => boolean;\n\n  /**\n   * Optional function to serialize the state\n   * @default JSON.stringify\n   */\n  serialize?: (state: T) => string;\n\n  /**\n   * Optional function to deserialize the state\n   * @default JSON.parse\n   */\n  deserialize?: (serialized: string) => unknown;\n\n  /**\n   * Optional function to determine if the state has changed\n   * @default lodash.isEqual\n   */\n  isEqual?: (a: T, b: T) => boolean;\n\n  /**\n   * Optional debounce time in milliseconds for saving state\n   * @default 1000\n   */\n  debounceTime?: number;\n\n  /**\n   * Optional flag to enable debug logging\n   * @default false\n   */\n  debug?: boolean;\n\n  /**\n   * Optional flag to enable compression for larger states\n   * @default false\n   */\n  compress?: boolean;\n\n  /**\n   * Optional custom storage mechanism\n   * @default localStorage\n   */\n  storage?: {\n    getItem: (key: string) => string | null | Promise<string | null>;\n    setItem: (key: string, value: string) => void | Promise<void>;\n    removeItem: (key: string) => void | Promise<void>;\n  };\n}\n\n/**\n * Data structure for persisted state\n */\ninterface PersistedData<T> {\n  version: number;\n  timestamp: number;\n  state: T;\n}\n\n/**\n * Error types for state persistence\n */\nexport enum PersistenceErrorType {\n  SERIALIZATION = 'serialization',\n  DESERIALIZATION = 'deserialization',\n  STORAGE_FULL = 'storage_full',\n  VALIDATION = 'validation',\n  MIGRATION = 'migration',\n  STORAGE_UNAVAILABLE = 'storage_unavailable',\n}\n\n/**\n * Error class for state persistence\n */\nexport class PersistenceError extends Error {\n  constructor(public type: PersistenceErrorType, message: string, public originalError?: unknown) {\n    super(message);\n    this.name = 'PersistenceError';\n  }\n}\n\n/**\n * Creates utilities for persisting and loading state\n */\nexport function createStatePersistence<T>(options: PersistenceOptions<T>) {\n  const {\n    key,\n    version,\n    migrate = undefined,\n    validate = () => true,\n    serialize = JSON.stringify,\n    deserialize = JSON.parse,\n    isEqual = lodashIsEqual,\n    debounceTime = 1000,\n    debug = false,\n    compress = false,\n    storage = localStorage,\n  } = options;\n\n  // Timeout for debounced saves\n  let saveTimeout: ReturnType<typeof setTimeout> | undefined;\n\n  /**\n   * Internal debug logging\n   */\n  const log = (message: string, ...args: unknown[]) => {\n    if (debug) {\n      console.debug(`[StatePersistence:${key}] ${message}`, ...args);\n    }\n  };\n\n  /**\n   * Compress a string using basic encoding\n   */\n  const compressString = (str: string): string => {\n    if (!compress) {\n      return str;\n    }\n    \n    try {\n      // Use lz-string if available, otherwise use basic btoa\n      if (typeof window !== 'undefined' && 'lzstring' in window) {\n        return ((window as unknown) as { lzstring: { compressToUTF16: (str: string) => string } }).lzstring.compressToUTF16(str);\n      }\n      \n      // Fallback to basic encoding\n      return typeof btoa === 'function' ? btoa(str) : str;\n    } catch (error) {\n      log('Compression failed, using uncompressed data', error);\n      return str;\n    }\n  };\n  \n  /**\n   * Decompress a string\n   */\n  const decompressString = (str: string): string => {\n    if (!compress) {\n      return str;\n    }\n\n    try {\n      // Use lz-string if available, otherwise use basic atob\n      if (typeof window !== 'undefined' && 'lzstring' in window) {\n        return ((window as unknown) as { lzstring: { decompressFromUTF16: (str: string) => string } }).lzstring.decompressFromUTF16(str);\n      }\n      \n      // Fallback to basic decoding\n      return typeof atob === 'function' ? atob(str) : str;\n    } catch (error) {\n      log('Decompression failed, using raw data', error);\n      return str;\n    }\n  };\n\n  /**\n   * Save the state to storage\n   */\n  const saveState = async (state: T, immediate = false): Promise<void> => {\n    if (saveTimeout) {\n      clearTimeout(saveTimeout);\n      saveTimeout = undefined;\n    }\n\n    const saveFunc = async () => {\n      try {\n        const persistedData: PersistedData<T> = {\n          version,\n          timestamp: Date.now(),\n          state,\n        };\n\n        log('Saving state', persistedData);\n\n        // Try to serialize the state\n        let serialized: string;\n        try {\n          serialized = serialize(state);\n        } catch (error) {\n          throw new PersistenceError(\n            PersistenceErrorType.SERIALIZATION,\n            `Failed to serialize state: ${error instanceof Error ? error.message : String(error)}`,\n            error\n          );\n        }\n\n        // Compress if enabled\n        const compressed = compressString(serialized);\n        \n        // Try to save to storage\n        try {\n          const persistedStr = JSON.stringify(persistedData);\n          await storage.setItem(key, compressed);\n        } catch (error) {\n          // Check if it's a quota exceeded error\n          if (\n            error instanceof Error &&\n            (error.name === 'QuotaExceededError' || error.message.includes('quota'))\n          ) {\n            throw new PersistenceError(\n              PersistenceErrorType.STORAGE_FULL,\n              'Storage quota exceeded, cannot save state',\n              error\n            );\n          }\n          \n          throw new PersistenceError(\n            PersistenceErrorType.STORAGE_UNAVAILABLE,\n            `Failed to save state: ${error instanceof Error ? error.message : String(error)}`,\n            error\n          );\n        }\n      } catch (error) {\n        log('Error saving state', error);\n        \n        if (error instanceof PersistenceError) {\n          throw error;\n        }\n        \n        throw new PersistenceError(\n          PersistenceErrorType.SERIALIZATION,\n          `Unexpected error saving state: ${error instanceof Error ? error.message : String(error)}`,\n          error\n        );\n      }\n    };\n\n    if (immediate) {\n      await saveFunc();\n    } else {\n      saveTimeout = setTimeout(saveFunc, debounceTime);\n    }\n  };\n\n  /**\n   * Load the state from storage\n   */\n  const loadState = async (): Promise<T | null> => {\n    try {\n      log('Loading state');\n\n      // Try to get from storage\n      let serialized: string | null;\n      try {\n        serialized = await storage.getItem(key);\n      } catch (error) {\n        throw new PersistenceError(\n          PersistenceErrorType.STORAGE_UNAVAILABLE,\n          `Failed to access storage: ${error instanceof Error ? error.message : String(error)}`,\n          error\n        );\n      }\n\n      if (!serialized) {\n        log('No saved state found');\n        return null;\n      }\n\n      // Decompress if needed\n      const decompressed = decompressString(serialized);\n\n      // Try to parse the persisted data\n      let persistedData: PersistedData<unknown>;\n      try {\n        persistedData = JSON.parse(decompressed);\n      } catch (error) {\n        throw new PersistenceError(\n          PersistenceErrorType.DESERIALIZATION,\n          `Failed to parse persisted data: ${error instanceof Error ? error.message : String(error)}`,\n          error\n        );\n      }\n\n      // Check version and migrate if needed\n      let migratedState: unknown;\n      try {\n        if (persistedData.version !== version && migrate) {\n          log(\n            `Version mismatch (saved: ${persistedData.version}, current: ${version}), migrating state`\n          );\n          migratedState = migrate(persistedData.state, persistedData.version);\n        } else {\n          migratedState = persistedData.state;\n        }\n      } catch (error) {\n        throw new PersistenceError(\n          PersistenceErrorType.MIGRATION,\n          `Failed to migrate state: ${error instanceof Error ? error.message : String(error)}`,\n          error\n        );\n      }\n\n      // Validate the state\n      try {\n        if (!validate(migratedState)) {\n          throw new PersistenceError(\n            PersistenceErrorType.VALIDATION,\n            'State validation failed'\n          );\n        }\n      } catch (error) {\n        if (error instanceof PersistenceError) {\n          throw error;\n        }\n        \n        throw new PersistenceError(\n          PersistenceErrorType.VALIDATION,\n          `State validation error: ${error instanceof Error ? error.message : String(error)}`,\n          error\n        );\n      }\n\n      // Try to deserialize the state\n      try {\n        const deserialized = migratedState as T;\n        log('State loaded successfully', deserialized);\n        return deserialized;\n      } catch (error) {\n        throw new PersistenceError(\n          PersistenceErrorType.DESERIALIZATION,\n          `Failed to deserialize state: ${error instanceof Error ? error.message : String(error)}`,\n          error\n        );\n      }\n    } catch (error) {\n      log('Error loading state', error);\n      \n      if (error instanceof PersistenceError) {\n        throw error;\n      }\n      \n      throw new PersistenceError(\n        PersistenceErrorType.DESERIALIZATION,\n        `Unexpected error loading state: ${error instanceof Error ? error.message : String(error)}`,\n        error\n      );\n    }\n  };\n\n  /**\n   * Clear the saved state\n   */\n  const clearState = async (): Promise<void> => {\n    try {\n      log('Clearing state');\n      await storage.removeItem(key);\n    } catch (error) {\n      log('Error clearing state', error);\n      \n      throw new PersistenceError(\n        PersistenceErrorType.STORAGE_UNAVAILABLE,\n        `Failed to clear state: ${error instanceof Error ? error.message : String(error)}`,\n        error\n      );\n    }\n  };\n\n  return {\n    saveState,\n    loadState,\n    clearState,\n  };\n}\n\n/**\n * Hook for persisting and loading state\n */\nexport function createStatePersistenceHook<T>(options: PersistenceOptions<T>) {\n  const { saveState, loadState, clearState } = createStatePersistence<T>(options);\n\n  return function useStatePersistence() {\n    const initialized = useRef(false);\n\n    return {\n      saveState,\n      loadState,\n      clearState,\n      initialized,\n    };\n  };\n}\n\n/**\n * Creates a hook that persists a React state\n */\nexport function createPersistedState<T>(\n  defaultValue: T,\n  options: Omit<PersistenceOptions<T>, 'compress' | 'storage'>\n) {\n  const persistence = createStatePersistence<T>(options);\n\n  return function usePersistedState(): [T, (newState: T) => void] {\n    const [state, setState] = useState<T>(defaultValue);\n    const initialized = useRef(false);\n\n    // Load state on mount\n    useEffect(() => {\n      const loadPersistedState = async () => {\n        try {\n          const savedState = await persistence.loadState();\n          if (savedState !== null) {\n            setState(savedState);\n          }\n          initialized.current = true;\n        } catch (error) {\n          console.error('Failed to load persisted state:', error);\n          initialized.current = true;\n        }\n      };\n\n      loadPersistedState();\n    }, []);\n\n    // Save state when it changes\n    useEffect(() => {\n      if (!initialized.current) {\n        return;\n      }\n\n      persistence.saveState(state).catch(error => {\n        console.error('Failed to save persisted state:', error);\n      });\n    }, [state]);\n\n    return [state, setState];\n  };\n}\n\n/**\n * Create a simple localStorage item with a default value\n */\nexport function createLocalStorageItem<T>(key: string, defaultValue: T) {\n  return {\n    get: (): T => {\n      try {\n        const item = localStorage.getItem(key);\n        return item ? (JSON.parse(item) as T) : defaultValue;\n      } catch (error) {\n        console.error(`Error getting localStorage item ${key}:`, error);\n        return defaultValue;\n      }\n    },\n    set: (value: T): void => {\n      try {\n        localStorage.setItem(key, JSON.stringify(value));\n      } catch (error) {\n        console.error(`Error setting localStorage item ${key}:`, error);\n      }\n    },\n    remove: (): void => {\n      try {\n        localStorage.removeItem(key);\n      } catch (error) {\n        console.error(`Error removing localStorage item ${key}:`, error);\n      }\n    },\n  };\n}\n\n/**\n * Creates a hook that automatically persists a context state\n */\nexport function createContextPersistence<T, A>(\n  contextHook: () => T,\n  dispatchHook: () => React.Dispatch<A>,\n  options: PersistenceOptions<T>\n) {\n  const persistence = createStatePersistence<T>(options);\n\n  return function usePersistContext() {\n    const state = contextHook();\n    const dispatch = dispatchHook();\n    const initialized = useRef(false);\n\n    // Load state on mount\n    useEffect(() => {\n      const loadContextState = async () => {\n        try {\n          const savedState = await persistence.loadState();\n          if (savedState !== null && dispatch) {\n            // If the context uses a reducer pattern, dispatch an initialization action\n            dispatch({ type: 'INITIALIZE_FROM_STORAGE', payload: savedState } as unknown as A);\n          }\n          initialized.current = true;\n        } catch (error) {\n          console.error('Failed to load context state:', error);\n          initialized.current = true;\n        }\n      };\n\n      loadContextState();\n    }, [dispatch]);\n\n    // Save state when it changes\n    useEffect(() => {\n      if (!initialized.current) {\n        return;\n      }\n\n      persistence.saveState(state).catch(error => {\n        console.error('Failed to save context state:', error);\n      });\n    }, [state]);\n\n    return {\n      state,\n      dispatch,\n      persistence,\n    };\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/typeConversions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/vpr-diagnostic.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/weapons/weaponEffectUtils.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'CommonShipAbility' is defined but never used. Allowed unused vars must match /^ignored|^temp/u.","line":38,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":38,"endColumn":28}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  AreaEffect,\n  DamageEffect,\n  StatusEffect,\n  WeaponEffect,\n  WeaponEffectType,\n} from '../../effects/types_effects/WeaponEffects';\nimport { Effect } from '../../types/core/GameTypes';\nimport { ResourceType } from '../../types/resources/ResourceTypes';\nimport { WeaponCategory, WeaponSystem } from '../../types/weapons/WeaponTypes';\n\ninterface WeaponLike {\n  id: string;\n  type: WeaponCategory | string;\n  damage?: number;\n  cooldown: number;\n  displayName?: string;\n}\n\n/**\n * Common ship ability interface for standardizing ship special abilities\n *\n * This interface will be used in future implementations to:\n * 1. Standardize the structure of ship special abilities across different ship classes\n * 2. Enable ability sharing and inheritance between related ship types\n * 3. Support the upcoming ship ability customization system\n * 4. Provide consistent ability parameters for UI display and tooltips\n * 5. Facilitate ability cooldown and activation state tracking\n *\n * Properties:\n * - id: Unique identifier for the ability\n * - name: Display name of the ability\n * - type: Category of ability (offensive, defensive, utility, etc.)\n * - cooldown: Time in seconds before the ability can be used again\n * - damage: Base damage value for offensive abilities\n */\n\ninterface CommonShipAbility {\n  id?: string;\n  name: string;\n  type?: string;\n  cooldown: number;\n  damage?: number;\n}\n\n/**\n * Creates a weapon-like object from parameters\n */\nexport function createWeaponLike(params: {\n  id: string;\n  type: WeaponCategory | string;\n  damage?: number;\n  cooldown: number;\n  displayName?: string;\n}): WeaponLike {\n  return params;\n}\n\n/**\n * Converts a HangarWeaponSystem to WeaponLike\n */\nexport function convertToWeaponLike(weapon: WeaponSystem & { name?: string }): WeaponLike {\n  return {\n    id: weapon.id,\n    type: weapon.type,\n    damage: weapon.damage,\n    cooldown: weapon.cooldown,\n    displayName: 'name' in weapon ? weapon.name : undefined,\n  };\n}\n\n/**\n * Creates a base weapon effect\n */\nexport function createBaseWeaponEffect(params: {\n  id: string;\n  type: 'damage' | 'area' | 'status';\n  magnitude: number;\n  duration: number;\n  strength: number;\n  name?: string;\n  description?: string;\n}): WeaponEffect {\n  return {\n    id: params.id,\n    type: params.type,\n    magnitude: params.magnitude,\n    duration: params.duration,\n    strength: params.strength,\n    name: params.name || params.id,\n    description: params.description || `${params.type} effect with magnitude ${params.magnitude}`,\n  };\n}\n\n/**\n * Creates a damage effect with the specified parameters\n */\nexport function createDamageEffect(params: {\n  id: string;\n  magnitude: number;\n  duration: number;\n  strength: number;\n  damageType: 'physical' | ResourceType.ENERGY | 'explosive';\n  penetration: number;\n  name?: string;\n  description?: string;\n}): DamageEffect {\n  const baseEffect = createBaseWeaponEffect({\n    id: params.id,\n    type: 'damage',\n    magnitude: params.magnitude,\n    duration: params.duration,\n    strength: params.strength,\n    name: params.name,\n    description: params.description,\n  });\n\n  return {\n    ...baseEffect,\n    type: 'damage' as const,\n    damageType: params.damageType,\n    penetration: params.penetration,\n  };\n}\n\n/**\n * Creates an area effect with the specified parameters\n */\nexport function createAreaEffect(params: {\n  id: string;\n  magnitude: number;\n  duration: number;\n  strength: number;\n  radius: number;\n  falloff: number;\n  name?: string;\n  description?: string;\n}): AreaEffect {\n  const baseEffect = createBaseWeaponEffect({\n    id: params.id,\n    type: 'area',\n    magnitude: params.magnitude,\n    duration: params.duration,\n    strength: params.strength,\n    name: params.name,\n    description: params.description,\n  });\n\n  return {\n    ...baseEffect,\n    type: 'area' as const,\n    radius: params.radius,\n    falloff: params.falloff,\n  };\n}\n\n/**\n * Creates a status effect with the specified parameters\n */\nexport function createStatusEffect(params: {\n  id: string;\n  magnitude: number;\n  duration: number;\n  strength: number;\n  statusType: 'burn' | 'emp' | 'slow' | 'stun';\n  name?: string;\n  description?: string;\n}): StatusEffect {\n  const baseEffect = createBaseWeaponEffect({\n    id: params.id,\n    type: 'status',\n    magnitude: params.magnitude,\n    duration: params.duration,\n    strength: params.strength,\n    name: params.name,\n    description: params.description,\n  });\n\n  return {\n    ...baseEffect,\n    type: 'status' as const,\n    statusType: params.statusType,\n  };\n}\n\n/**\n * Creates a weapon effect from a weapon system or ability\n */\nexport function createWeaponEffect(source: WeaponLike): WeaponEffectType {\n  return createDamageEffect({\n    id: `${source.id}-effect`,\n    magnitude: source.damage ?? 0,\n    duration: source.cooldown,\n    strength: source.damage ?? 0,\n    damageType: 'physical',\n    penetration: 0,\n    name: source.displayName || `${source.type} Effect`,\n    description: `Effect from ${source.displayName || source.type}`,\n  });\n}\n\n/**\n * Creates a weapon effect with custom parameters\n */\nexport function createCustomWeaponEffect(params: {\n  id: string;\n  type: 'damage' | 'area' | 'status';\n  magnitude: number;\n  duration: number;\n  strength: number;\n  damageType?: 'physical' | ResourceType.ENERGY | 'explosive';\n  penetration?: number;\n  radius?: number;\n  falloff?: number;\n  statusType?: 'burn' | 'emp' | 'slow' | 'stun';\n  name?: string;\n  description?: string;\n}): WeaponEffectType {\n  switch (params.type) {\n    case 'damage':\n      return createDamageEffect({\n        id: params.id,\n        magnitude: params.magnitude,\n        duration: params.duration,\n        strength: params.strength,\n        damageType: params.damageType || 'physical',\n        penetration: params.penetration ?? 0,\n        name: params.name,\n        description: params.description,\n      });\n    case 'area':\n      return createAreaEffect({\n        id: params.id,\n        magnitude: params.magnitude,\n        duration: params.duration,\n        strength: params.strength,\n        radius: params.radius ?? 0,\n        falloff: params.falloff ?? 0,\n        name: params.name,\n        description: params.description,\n      });\n    case 'status':\n      return createStatusEffect({\n        id: params.id,\n        magnitude: params.magnitude,\n        duration: params.duration,\n        strength: params.strength,\n        statusType: params.statusType || 'stun',\n        name: params.name,\n        description: params.description,\n      });\n  }\n}\n\n/**\n * Creates a weapon effect from a weapon system with scaling\n */\nexport function createScaledWeaponEffect(\n  weapon: WeaponSystem & { name?: string },\n  scale: number = 1\n): WeaponEffectType {\n  return createDamageEffect({\n    id: `${weapon.id}-scaled-effect`,\n    magnitude: weapon.damage * scale,\n    duration: weapon.cooldown,\n    strength: weapon.damage * scale,\n    damageType: 'physical',\n    penetration: 0,\n    name: weapon.name || `Scaled ${weapon.type}`,\n    description: `Scaled effect (${scale}x) from ${weapon.name || weapon.type}`,\n  });\n}\n\n/**\n * Creates a combined weapon effect from multiple weapons\n */\nexport function createCombinedWeaponEffect(weapons: WeaponSystem[]): WeaponEffectType {\n  if (weapons.length === 0) {\n    throw new Error('Cannot create combined effect from empty weapons array');\n  }\n\n  // Calculate combined damage and cooldown\n  const totalDamage = weapons.reduce((sum, weapon) => sum + weapon.damage, 0);\n  const avgCooldown = weapons.reduce((sum, weapon) => sum + weapon.cooldown, 0) / weapons.length;\n\n  // Create a combined weapon-like object\n  const combinedWeapon: WeaponLike = {\n    id: `combined-${weapons[0].id}`,\n    type: weapons[0].type,\n    damage: totalDamage,\n    cooldown: avgCooldown,\n    displayName: `Combined ${weapons[0].type}`,\n  };\n\n  // Create effect from the combined weapon\n  return createWeaponEffect(combinedWeapon);\n}\n\n/**\n * Checks if an object is a valid Effect\n */\nexport function isValidEffect(effect: unknown): effect is Effect {\n  if (!effect || typeof effect !== 'object') {\n    return false;\n  }\n\n  const effectObj = effect as Partial<Effect>;\n  return (\n    typeof effectObj.id === 'string' &&\n    typeof effectObj.type === 'string' &&\n    typeof effectObj.magnitude === 'number' &&\n    typeof effectObj.duration === 'number'\n  );\n}\n\n/**\n * Validates and normalizes an effect\n */\nexport function validateEffect(effect: Partial<Effect>): Effect {\n  if (!effect.id) {\n    throw new Error('Effect must have an id');\n  }\n\n  if (!effect.type) {\n    throw new Error('Effect must have a type');\n  }\n\n  return {\n    id: effect.id,\n    type: effect.type,\n    magnitude: effect.magnitude ?? 0,\n    duration: effect.duration ?? 0,\n  };\n}\n\n/**\n * Combines multiple effects into a single effect\n */\nexport function combineEffects(effects: Effect[]): Effect {\n  if (effects.length === 0) {\n    throw new Error('Cannot combine empty effects array');\n  }\n\n  // Use the first effect as a base\n  const baseEffect = effects[0];\n\n  // Combine magnitudes and take the longest duration\n  const combinedMagnitude = effects.reduce((sum, effect) => sum + effect.magnitude, 0);\n  const maxDuration = Math.max(...effects.map(effect => effect.duration));\n\n  // Create a new effect with combined values\n  return {\n    id: `combined-${baseEffect.id}`,\n    type: baseEffect.type,\n    magnitude: combinedMagnitude,\n    duration: maxDuration,\n  };\n}\n\n/**\n * Scales an effect by a factor\n */\nexport function scaleEffect(effect: Effect, factor: number): Effect {\n  // Create a new effect with scaled values\n  return {\n    id: `scaled-${effect.id}`,\n    type: effect.type,\n    magnitude: effect.magnitude * factor,\n    duration: effect.duration,\n  };\n}\n\n/**\n * Creates a chain of effects that trigger sequentially\n */\nexport function createEffectChain(effects: Effect[]): Effect[] {\n  if (effects.length <= 1) {\n    return effects;\n  }\n\n  // Create a new array of effects with sequential triggers\n  return effects.map((effect, index) => {\n    if (index === 0) {\n      return effect;\n    }\n\n    // Each subsequent effect is triggered by the previous one\n    return {\n      ...effect,\n      id: `chain-${index}-${effect.id}`,\n      trigger: {\n        type: 'effect-complete',\n        effectId: effects[index - 1].id,\n      },\n    };\n  });\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/weapons/weaponTypeConversions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/utils/workers/ResourceFlowWorkerUtil.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/visualization/Chart.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/visualization/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/visualization/renderers/CanvasRenderer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/visualization/renderers/SVGRenderer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/visualization/renderers/WebGLRenderer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/vite-env.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/workers/DataProcessingWorker.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/workers/ResourceFlowWorker.ts","messages":[{"ruleId":"no-unsafe-optional-chaining","severity":2,"message":"Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.","line":143,"column":34,"nodeType":"ChainExpression","messageId":"unsafeOptionalChain","endLine":143,"endColumn":45}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ResourceType } from './../types/resources/ResourceTypes';\n/**\n * ResourceFlowWorker.ts\n *\n * Web Worker implementation for offloading resource flow calculations\n * This worker handles heavy computational tasks from the ResourceFlowManager\n * to prevent UI thread blocking for large resource networks.\n */\n\nimport {\n  FlowConnection,\n  FlowNode,\n  ResourceState,\n  ResourceTransfer,\n} from '../types/resources/ResourceTypes';\n\n// Message types for communication with the main thread\ntype WorkerMessageType =\n  | 'OPTIMIZE_FLOWS'\n  | 'BATCH_PROCESS'\n  | 'CALCULATE_RESOURCE_BALANCE'\n  | 'OPTIMIZE_FLOW_RATES'\n  | 'CALCULATE_EFFICIENCY';\n\n// Input data interfaces for each message type\ninterface OptimizeFlowsData {\n  nodes: FlowNode[];\n  connections: FlowConnection[];\n  resourceStates: Map<ResourceType, ResourceState>;\n}\n\ninterface BatchProcessData {\n  nodes: FlowNode[];\n  connections: FlowConnection[];\n  batchSize: number;\n}\n\ninterface CalculateResourceBalanceData {\n  producers: FlowNode[];\n  consumers: FlowNode[];\n  storages: FlowNode[];\n  connections: FlowConnection[];\n}\n\ninterface OptimizeFlowRatesData {\n  connections: FlowConnection[];\n  availability: Partial<Record<ResourceType, number>>;\n  demand: Partial<Record<ResourceType, number>>;\n}\n\ninterface CalculateEfficiencyData {\n  network: {\n    nodes: FlowNode[];\n    connections: FlowConnection[];\n  };\n}\n\n// Type guard functions\nfunction isOptimizeFlowsData(data: unknown): data is OptimizeFlowsData {\n  return (\n    typeof data === 'object' &&\n    data !== null &&\n    'nodes' in data &&\n    'connections' in data &&\n    'resourceStates' in data &&\n    Array.isArray((data as OptimizeFlowsData).nodes) &&\n    Array.isArray((data as OptimizeFlowsData).connections)\n  );\n}\n\nfunction isBatchProcessData(data: unknown): data is BatchProcessData {\n  return (\n    typeof data === 'object' &&\n    data !== null &&\n    'nodes' in data &&\n    'connections' in data &&\n    'batchSize' in data &&\n    Array.isArray((data as BatchProcessData).nodes) &&\n    Array.isArray((data as BatchProcessData).connections) &&\n    typeof (data as BatchProcessData).batchSize === 'number'\n  );\n}\n\nfunction isCalculateResourceBalanceData(data: unknown): data is CalculateResourceBalanceData {\n  return (\n    typeof data === 'object' &&\n    data !== null &&\n    'producers' in data &&\n    'consumers' in data &&\n    'storages' in data &&\n    'connections' in data &&\n    Array.isArray((data as CalculateResourceBalanceData).producers) &&\n    Array.isArray((data as CalculateResourceBalanceData).consumers) &&\n    Array.isArray((data as CalculateResourceBalanceData).storages) &&\n    Array.isArray((data as CalculateResourceBalanceData).connections)\n  );\n}\n\nfunction isOptimizeFlowRatesData(data: unknown): data is OptimizeFlowRatesData {\n  return (\n    typeof data === 'object' &&\n    data !== null &&\n    'connections' in data &&\n    'availability' in data &&\n    'demand' in data &&\n    Array.isArray((data as OptimizeFlowRatesData).connections)\n  );\n}\n\nfunction isCalculateEfficiencyData(data: unknown): data is CalculateEfficiencyData {\n  return (\n    typeof data === 'object' &&\n    data !== null &&\n    'network' in data &&\n    typeof (data as CalculateEfficiencyData).network === 'object' &&\n    (data as CalculateEfficiencyData).network !== null &&\n    'nodes' in (data as CalculateEfficiencyData).network &&\n    'connections' in (data as CalculateEfficiencyData).network\n  );\n}\n\n// Input data structure for worker tasks\ninterface WorkerInput {\n  type: WorkerMessageType;\n  data: unknown;\n  taskId: string;\n}\n\n// Output data structure for worker results\ninterface WorkerOutput {\n  type: WorkerMessageType;\n  result: unknown;\n  taskId: string;\n  executionTimeMs: number;\n  error?: string;\n}\n\n// Self reference for the worker context\nconst ctx: Worker = self as unknown as Worker;\n\n// Handle messages from main thread\nctx.addEventListener('message', (event: MessageEvent<WorkerInput>) => {\n  const { type, data, taskId } = event?.data;\n  const startTime = Date.now();\n\n  let result: unknown;\n\n  try {\n    switch (type) {\n      case 'OPTIMIZE_FLOWS':\n        if (!isOptimizeFlowsData(data)) {\n          throw new Error('Invalid data format for OPTIMIZE_FLOWS');\n        }\n        result = optimizeFlows(data?.nodes, data?.connections, data?.resourceStates);\n        break;\n\n      case 'BATCH_PROCESS':\n        if (!isBatchProcessData(data)) {\n          throw new Error('Invalid data format for BATCH_PROCESS');\n        }\n        result = processBatch(data?.nodes, data?.connections, data?.batchSize);\n        break;\n\n      case 'CALCULATE_RESOURCE_BALANCE':\n        if (!isCalculateResourceBalanceData(data)) {\n          throw new Error('Invalid data format for CALCULATE_RESOURCE_BALANCE');\n        }\n        result = calculateResourceBalance(\n          data?.producers,\n          data?.consumers,\n          data?.storages,\n          data?.connections\n        );\n        break;\n\n      case 'OPTIMIZE_FLOW_RATES':\n        if (!isOptimizeFlowRatesData(data)) {\n          throw new Error('Invalid data format for OPTIMIZE_FLOW_RATES');\n        }\n        result = optimizeFlowRates(data?.connections, data?.availability, data?.demand);\n        break;\n\n      case 'CALCULATE_EFFICIENCY':\n        if (!isCalculateEfficiencyData(data)) {\n          throw new Error('Invalid data format for CALCULATE_EFFICIENCY');\n        }\n        result = calculateNetworkEfficiency(data?.network);\n        break;\n\n      default:\n        throw new Error(`Unknown task type: ${type}`);\n    }\n\n    // Send successful result back to main thread\n    const endTime = Date.now();\n    ctx.postMessage({\n      type,\n      result,\n      taskId,\n      executionTimeMs: endTime - startTime,\n    } as WorkerOutput);\n  } catch (error) {\n    // Send error back to main thread\n    ctx.postMessage({\n      type,\n      result: null,\n      error: error instanceof Error ? error.message : 'Unknown error',\n      taskId,\n      executionTimeMs: Date.now() - startTime,\n    } as WorkerOutput);\n  }\n});\n\n/**\n * Main optimization function - handles the complete flow optimization process\n */\nfunction optimizeFlows(\n  nodes: FlowNode[],\n  connections: FlowConnection[],\n  resourceStates: Map<ResourceType, ResourceState>\n): {\n  transfers: ResourceTransfer[];\n  updatedConnections: FlowConnection[];\n  bottlenecks: string[];\n  underutilized: string[];\n  performanceMetrics: {\n    nodesProcessed: number;\n    connectionsProcessed: number;\n    transfersGenerated: number;\n  };\n} {\n  // Filter active nodes and connections\n  const activeNodes = nodes.filter(node => node.active);\n  const activeConnections = connections.filter(conn => conn.active);\n\n  // Apply resource state information to node resources if applicable\n  activeNodes.forEach(node => {\n    Object.keys(node.resources).forEach(key => {\n      const resourceType = key as ResourceType;\n      if (resourceStates.has(resourceType)) {\n        // Update node resource state with global resource state information\n        const globalState = resourceStates.get(resourceType)!;\n        node.resources[resourceType] = {\n          ...node.resources[resourceType],\n          production: node.resources[resourceType].production * (globalState.production / 100 || 1),\n          consumption:\n            node.resources[resourceType].consumption * (globalState.consumption / 100 || 1),\n        };\n      }\n    });\n  });\n\n  // Categorize nodes by type\n  const producers = activeNodes.filter(node => node.type === 'producer');\n  const consumers = activeNodes.filter(node => node.type === 'consumer');\n  const storages = activeNodes.filter(node => node.type === 'storage');\n\n  // Calculate resource balance\n  const { availability, demand } = calculateResourceBalance(\n    producers,\n    consumers,\n    storages,\n    activeConnections\n  );\n\n  // Identify resource issues\n  const { bottlenecks, underutilized } = identifyResourceIssues(availability, demand);\n\n  // Optimize flow rates\n  const { updatedConnections, transfers } = optimizeFlowRates(\n    activeConnections,\n    availability,\n    demand\n  );\n\n  // Return optimization results\n  return {\n    transfers,\n    updatedConnections,\n    bottlenecks,\n    underutilized,\n    performanceMetrics: {\n      nodesProcessed: activeNodes.length,\n      connectionsProcessed: connections.length,\n      transfersGenerated: transfers.length,\n    },\n  };\n}\n\n/**\n * Process a batch of nodes and connections\n */\nfunction processBatch(nodes: FlowNode[], connections: FlowConnection[], batchSize: number) {\n  const results = [];\n  const batchCount = Math.ceil(nodes.length / batchSize);\n\n  for (let i = 0; i < batchCount; i++) {\n    const start = i * batchSize;\n    const end = Math.min(start + batchSize, nodes.length);\n    const nodeBatch = nodes.slice(start, end);\n\n    // Process each node in the batch\n    for (const node of nodeBatch) {\n      // Simplified processing logic for demonstration\n      const nodeConnections = connections.filter(\n        conn => conn.source === node.id || conn.target === node.id\n      );\n\n      results.push({\n        nodeId: node.id,\n        connectionCount: nodeConnections.length,\n        processed: true,\n      });\n    }\n  }\n\n  return {\n    batchResults: results,\n    totalProcessed: results.length,\n  };\n}\n\n/**\n * Calculate resource balance between producers, consumers, and storage\n */\nfunction calculateResourceBalance(\n  producers: FlowNode[],\n  consumers: FlowNode[],\n  storages: FlowNode[],\n  connections: FlowConnection[]\n): {\n  availability: Partial<Record<ResourceType, number>>;\n  demand: Partial<Record<ResourceType, number>>;\n} {\n  const availability: Partial<Record<ResourceType, number>> = {};\n  const demand: Partial<Record<ResourceType, number>> = {};\n\n  // Calculate production capacity\n  for (const producer of producers) {\n    const resourceTypes = Object.keys(producer.resources) as ResourceType[];\n    for (const resourceType of resourceTypes) {\n      availability[resourceType] = (availability[resourceType] ?? 0) + 10;\n    }\n  }\n\n  // Calculate consumer demand\n  for (const consumer of consumers) {\n    const resourceTypes = Object.keys(consumer.resources) as ResourceType[];\n    for (const resourceType of resourceTypes) {\n      demand[resourceType] = (demand[resourceType] ?? 0) + 5;\n    }\n  }\n\n  // Factor in connection capacity limitations\n  for (const connection of connections) {\n    // For each resource type in the connection\n    connection.resourceTypes.forEach(resourceType => {\n      if (connection.maxFlow && availability[resourceType]) {\n        // If this connection has a bottleneck, adjust the available throughput\n        availability[resourceType] = Math.min(availability[resourceType]!, connection.maxFlow);\n      }\n    });\n  }\n\n  return { availability, demand };\n}\n\n/**\n * Identify resource bottlenecks and underutilized resources\n */\nfunction identifyResourceIssues(\n  availability: Partial<Record<ResourceType, number>>,\n  demand: Partial<Record<ResourceType, number>>\n): {\n  bottlenecks: string[];\n  underutilized: string[];\n} {\n  const bottlenecks: string[] = [];\n  const underutilized: string[] = [];\n\n  // Compare availability and demand for each resource type\n  for (const resourceType of Object.keys(demand)) {\n    const enumResourceType = resourceType as ResourceType;\n    const availableAmount = availability[enumResourceType] ?? 0;\n    const demandAmount = demand[enumResourceType] ?? 0;\n\n    // Check for bottlenecks (demand > availability)\n    if (demandAmount > availableAmount) {\n      bottlenecks.push(resourceType);\n    }\n\n    // Check for underutilized resources (availability > demand * 1.5)\n    if (availableAmount > demandAmount * 1.5) {\n      underutilized.push(resourceType);\n    }\n  }\n\n  return { bottlenecks, underutilized };\n}\n\n/**\n * Optimize flow rates between nodes\n */\nfunction optimizeFlowRates(\n  connections: FlowConnection[],\n  availability: Partial<Record<ResourceType, number>>,\n  demand: Partial<Record<ResourceType, number>>\n): {\n  updatedConnections: FlowConnection[];\n  transfers: ResourceTransfer[];\n} {\n  const updatedConnections = [...connections];\n  const transfers: ResourceTransfer[] = [];\n\n  for (const connection of updatedConnections) {\n    for (const resourceType of connection.resourceTypes) {\n      const availableAmount = availability[resourceType] ?? 0;\n      const demandAmount = demand[resourceType] ?? 0;\n      const transferAmount = Math.min(availableAmount, demandAmount);\n\n      if (transferAmount > 0) {\n        const transfer: ResourceTransfer = {\n          type: resourceType,\n          amount: transferAmount,\n          source: connection.source,\n          target: connection.target,\n          timestamp: Date.now(),\n        };\n\n        transfers.push(transfer);\n      }\n    }\n  }\n\n  return { updatedConnections, transfers };\n}\n\n/**\n * Calculate network efficiency metrics\n */\nfunction calculateNetworkEfficiency(network: {\n  nodes: FlowNode[];\n  connections: FlowConnection[];\n}): {\n  overallEfficiency: number;\n  nodeEfficiencies: Record<string, number>;\n  bottlenecks: string[];\n} {\n  const { nodes, connections } = network;\n  const nodeEfficiencies: Record<string, number> = {};\n  const bottlenecks: string[] = [];\n\n  // Calculate efficiency for each node\n  for (const node of nodes) {\n    const nodeConnections = connections.filter(\n      conn => conn.source === node.id || conn.target === node.id\n    );\n    nodeEfficiencies[node.id] = nodeConnections.length > 0 ? 0.8 : 0; // Simplified calculation\n  }\n\n  // Calculate overall efficiency (simplified)\n  const overallEfficiency =\n    Object.values(nodeEfficiencies).reduce((sum, eff) => sum + eff, 0) / nodes.length;\n\n  return {\n    overallEfficiency,\n    nodeEfficiencies,\n    bottlenecks,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/workers/combatWorker.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/src/workers/worker.ts","messages":[{"ruleId":"no-unsafe-optional-chaining","severity":2,"message":"Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.","line":31,"column":34,"nodeType":"ChainExpression","messageId":"unsafeOptionalChain","endLine":31,"endColumn":45}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"interface WorkerMessage {\n  taskId: string;\n  type: string;\n  data: unknown;\n}\n\ninterface TaskHandler {\n  (data: unknown, reportProgress: (progress: number) => void): Promise<unknown>;\n}\n\nconst taskHandlers = new Map<string, TaskHandler>();\n\n// Register task handlers\ntaskHandlers.set('heavyComputation', async (data: unknown, reportProgress) => {\n  // Example heavy computation task\n  const iterations = (data as { iterations: number }).iterations;\n  let result = 0;\n\n  for (let i = 0; i < iterations; i++) {\n    result += Math.sqrt(i);\n    if (i % (iterations / 100) === 0) {\n      reportProgress((i / iterations) * 100);\n    }\n  }\n\n  return result;\n});\n\n// Handle messages from the main thread\nself.onmessage = async (event: MessageEvent<WorkerMessage>) => {\n  const { taskId, type, data } = event?.data;\n\n  try {\n    const handler = taskHandlers.get(type);\n    if (!handler) {\n      throw new Error(`Unknown task type: ${type}`);\n    }\n\n    // Execute task with progress reporting\n    const result = await handler(data, (progress: number) => {\n      self.postMessage({ taskId, type: 'progress', data: progress });\n    });\n\n    // Send result back to main thread\n    self.postMessage({ taskId, type: 'result', data: result });\n  } catch (error) {\n    // Send error back to main thread\n    self.postMessage({\n      taskId,\n      type: 'error',\n      data: error instanceof Error ? error.message : String(error),\n    });\n  }\n};\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/tailwind.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/test-prettier.js","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'obj' is assigned a value but never used.","line":6,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":10}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// This is a test file to check if Prettier is working\nfunction testFunction(a, b) {\n  return a + b;\n}\n\nconst obj = {\n  a: 1,\n  b: 2,\n  c: 3,\n};\n\nexport default testFunction;\n","usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/vite.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/deadcoast/CursorProjects/Galactic_Sprawl/vitest.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]