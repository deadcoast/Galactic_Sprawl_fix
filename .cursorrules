# Instructions

During your interaction with the user, if you find anything reusable in this project (e.g. version of a library, model name), especially about a fix to a mistake you made or a correction you received, you should take note in the `Lessons` section in the `.cursorrules` file so you will not make the same mistake again.

You should also use the `.cursorrules` file as a Scratchpad to organize your thoughts. Especially when you receive a new task, you should first review the content of the Scratchpad, clear old different task if necessary, first explain the task, and plan the steps you need to take to complete the task. You can use todo markers to indicate the progress, e.g.
[X] Task 1
[ ] Task 2

Also update the progress of the task in the Scratchpad when you finish a subtask.
Especially when you finished a milestone, it will help to improve your depth of task accomplishment to use the Scratchpad to reflect and plan.
The goal is to help you maintain a big picture as well as the progress of the task. Always refer to the Scratchpad when you plan the next step.

## Tools

Note all the tools are in python. So in the case you need to do batch processing, you can always consult the python files and write your own script.

## Screenshot Verification

The screenshot verification workflow allows you to capture screenshots of web pages and verify their appearance using LLMs. The following tools are available:

- Screenshot Capture:

```bash
venv/bin/python tools/screenshot_utils.py URL [--output OUTPUT] [--width WIDTH] [--height HEIGHT]
```

- LLM Verification with Images:

```bash
venv/bin/python tools/llm_api.py --prompt "Your verification question" --provider {openai|anthropic} --image path/to/screenshot.png
```

Example workflow:

```python
from screenshot_utils import take_screenshot_sync
from llm_api import query_llm

# Take a screenshot

screenshot_path = take_screenshot_sync('https://example.com', 'screenshot.png')

# Verify with LLM

response = query_llm(
    "What is the background color and title of this webpage?",
    provider="openai",  # or "anthropic"
    image_path=screenshot_path
)
print(response)
```

## LLM

You always have an LLM at your side to help you with the task. For simple tasks, you could invoke the LLM by running the following command:

```bash
venv/bin/python ./tools/llm_api.py --prompt "What is the capital of France?" --provider "anthropic"
```

The LLM API supports multiple providers:

- OpenAI (default, model: gpt-4o)
- Azure OpenAI (model: configured via AZURE_OPENAI_MODEL_DEPLOYMENT in .env file, defaults to gpt-4o-ms)
- DeepSeek (model: deepseek-chat)
- Anthropic (model: claude-3-sonnet-20240229)
- Gemini (model: gemini-pro)
- Local LLM (model: Qwen/Qwen2.5-32B-Instruct-AWQ)

But usually it's a better idea to check the content of the file and use the APIs in the `tools/llm_api.py` file to invoke the LLM if needed.

## Web browser

You could use the `tools/web_scraper.py` file to scrape the web.

```bash
venv/bin/python ./tools/web_scraper.py --max-concurrent 3 URL1 URL2 URL3
```

This will output the content of the web pages.

## Search engine

You could use the `tools/search_engine.py` file to search the web.

```bash
venv/bin/python ./tools/search_engine.py "your search keywords"
```

This will output the search results in the following format:

```plaintext
URL: https://example.com
Title: This is the title of the search result
Snippet: This is a snippet of the search result
```

If needed, you can further use the `web_scraper.py` file to scrape the web page content.

## Lessons

## User Specified Lessons

- You have a Knowledge on the Project. Use it before you start the task.
  - KNOWLEDGE_BASE_PATH="/Users/deadcoast/CursorProjects/Galactic_Sprawl/GalaxySprawlDocs"
- Include info useful for debugging in the program output.
- When correcting errors, do NOT delete unused code. Instead generate its implementation.
- Read the file before you try to edit it.

## Cursor learned

- CRITICAL: ALWAYS SEARCH FOR EXISTING IMPLEMENTATIONS BEFORE CREATING NEW CODE
  1. Use file_search and codebase_search BEFORE writing any new component
  2. Check all similar file names and paths thoroughly
  3. Review existing implementations completely
  4. NEVER create new files without verifying duplicates
  5. If duplicate work is discovered, IMMEDIATELY fix it yourself - don't leave it for others
  6. Take responsibility for your own mistakes and fix them immediately
  7. Don't just identify problems - SOLVE them

- CRITICAL: Type System Organization
  1. Found duplicate weapon type definitions:
     - src/types/ships/WeaponTypes.ts
     - src/types/weapons/WeaponTypes.ts
  2. These have incompatible structures:
     - ships/WeaponTypes uses Position from core/GameTypes
     - weapons/WeaponTypes uses WeaponMountPosition enum
  3. Need to consolidate these into a single source of truth
  4. Current fix: Use the types from weapons/WeaponTypes.ts as it has more specific weapon positioning

- For search results, ensure proper handling of different character encodings (UTF-8) for international queries
- Add debug information to stderr while keeping the main output clean in stdout for better pipeline integration
- When using seaborn styles in matplotlib, use 'seaborn-v0_8' instead of 'seaborn' as the style name due to recent seaborn version changes
- Use 'gpt-4o' as the model name for OpenAI's GPT-4 with vision capabilities
- When implementing threshold-based systems, use proper TypeScript types and React Context for global state management
- Handle lexical declarations in switch-case blocks by using block scoping with curly braces
- Remove unused imports to avoid TypeScript linter warnings
- Use 'as const' assertions to properly type string literals in TypeScript
- Properly handle cleanup in useEffect to prevent memory leaks with intervals
- When organizing TypeScript types in a game project:
  1. Keep core/base types in a central location (e.g., GameTypes.ts)
  2. Use inheritance for shared properties (e.g., extending BaseStats)
  3. Maintain clear type hierarchies (base -> specific -> component props)
  4. Group related types together with clear section comments
  5. Re-export types that are commonly used together

# Scratchpad

### Current Task: Testing Setup
1. [X] Add testing dependencies (Vitest, Testing Library)
2. [X] Create test setup file
3. [X] Create Vitest configuration
4. [X] Create weapon system test file
5. [X] Fix linter errors in test files
6. [X] Run initial tests
7. [X] Add test cases for weapon effects
8. [ ] Add test cases for weapon upgrades
9. [ ] Add test cases for UI components

### Next Steps

1. **Test Coverage**
   - [X] Test weapon mounting functionality
   - [X] Test weapon effects system
   - [ ] Test weapon upgrade system
   - [ ] Test UI component interactions

2. **Documentation**
   - [ ] Update component documentation
   - [ ] Document breaking changes
   - [ ] Update examples
   - [ ] Add migration guide

### Implementation Progress

1. **Component Cleanup**
   - [X] Remove duplicate WeaponMount component
   - [X] Move weapon mount functionality to WeaponSystem
   - [X] Update BaseShip to use consolidated weapon system
   - [X] Update faction ships to use new weapon system

2. **Update Dependencies**
   - [X] Fix imports in BaseShip.tsx
   - [X] Update weapon mount references
   - [X] Verify type compatibility
   - [X] Set up testing environment

3. **Integration Testing**
   - [X] Create test setup and configuration
   - [X] Create weapon system test file
   - [X] Test weapon mounting
   - [X] Test weapon effects
   - [ ] Test weapon upgrades
   - [ ] Test UI components

4. **Update Faction Ships**
   - [X] Update SpaceRatShip
   - [X] Update LostNovaShip
   - [X] Update EquatorHorizonShip
   - [X] Test all variants

### Current Focus
We have successfully set up the testing environment and implemented tests for weapon mounting and effects. Next, we need to:
1. Add tests for the weapon upgrade system
2. Add tests for UI component interactions
3. Update documentation to reflect the changes
4. Create a migration guide for the consolidated weapon system

### Lessons Learned
1. When testing React components that use context providers, make sure to:
   - Create a test wrapper component that provides necessary context
   - Use async/await with userEvent for handling user interactions
   - Handle multiple instances of elements with the same text by using more specific queries
2. For components with multiple instances of the same button (e.g., in status effects and action buttons):
   - Use `getAllByRole` instead of `getByText` to find all instances
   - Select the last instance (in action buttons) for interaction testing
3. When using Testing Library with React:
   - Prefer `userEvent` over `fireEvent` for better simulation of real user interactions
   - Use async/await with `userEvent` to ensure events are properly handled
We have successfully set up the testing environment and created initial test cases. Now we need to:
1. Run the initial tests to verify our setup
2. Add more comprehensive test cases for weapon effects and upgrades
3. Test UI component interactions
4. Document the changes and update examples

### Weapon System Consolidation Plan

1. **Component Cleanup**
   - [X] Remove duplicate WeaponMount component
   - [X] Move weapon mount functionality to WeaponSystem
   - [X] Update BaseShip to use consolidated weapon system
   - [X] Update faction ships to use new weapon system

2. **Update Dependencies**
   - [X] Fix imports in BaseShip.tsx
   - [X] Update weapon mount references
   - [X] Verify type compatibility
   - [X] Set up testing environment

3. **Integration Testing**
   - [X] Create test setup and configuration
   - [X] Create weapon system test file
   - [ ] Test weapon mounting
   - [ ] Test weapon effects
   - [ ] Test weapon upgrades
   - [ ] Test UI components

### Next Steps

1. **Update Faction Ships**
   - [X] Update SpaceRatShip
   - [X] Update LostNovaShip
   - [X] Update EquatorHorizonShip
   - [ ] Test all variants

2. **Documentation**
   - [ ] Update component documentation
   - [ ] Document breaking changes
   - [ ] Update examples
   - [ ] Add migration guide

### Current Task: Testing Setup
1. [X] Add testing dependencies (Vitest, Testing Library)
2. [X] Create test setup file
3. [X] Create Vitest configuration
4. [X] Create weapon system test file
5. [ ] Fix linter errors in test files
6. [ ] Run initial tests

We've completed updating all the faction ship components to use the consolidated weapon system. Would you like to proceed with testing the components to ensure everything works correctly?

### Implementation Steps

1. **Consolidate Weapon Types**
   - [ ] Move all types to `WeaponTypes.ts`
   - [ ] Merge overlapping interfaces
   - [ ] Keep advanced features
   - [ ] Add proper type exports

2. **Update References**
   - [ ] Update all import statements
   - [ ] Fix any type mismatches
   - [ ] Verify type compatibility
   - [ ] Test all components

3. **Documentation**
   - [ ] Add clear type hierarchy docs
   - [ ] Document breaking changes
   - [ ] Update examples
   - [ ] Add migration guide

3. **Ship Types (`types/ships/`)**
   - [ ] `ShipTypes.ts` - Base ship interfaces
   - [ ] `FactionTypes.ts` - Faction-specific types
   - [ ] `PlayerTypes.ts` - Player ship types

### Config System Reorganization

1. **Core Config (`config/core/`)**
   - [ ] `gameConfig.ts` - Core game settings
   - [ ] `balanceConfig.ts` - Game balance parameters

2. **Ship Config (`config/ships/`)**
   - [ ] `shipStats.ts` - Single source for ship stats
   - [ ] `weaponStats.ts` - Weapon configurations
   - [ ] `factionConfig.ts` - Faction configurations

3. **Combat Config (`config/combat/`)**
   - [ ] `combatConfig.ts` - Combat system settings
   - [ ] `effectConfig.ts` - Effect configurations

### Library Reorganization

1. **Core Services (`lib/core/`)**
   - [ ] `GameManager.ts` - Core game state
   - [ ] `EventManager.ts` - Event system
   - [ ] `AssetManager.ts` - Resource management

2. **Combat Services (`lib/combat/`)**
   - [ ] `CombatManager.ts` - Combat system
   - [ ] `WeaponManager.ts` - Weapon handling
   - [ ] `EffectManager.ts` - Effect system

3. **Faction Services (`lib/factions/`)**
   - [ ] `FactionManager.ts` - Faction management
   - [ ] `AIManager.ts` - AI behavior system
   - [ ] `FleetManager.ts` - Fleet management

### Next Steps

1. **Type System**
   - [ ] Audit all type definitions
   - [ ] Create type migration plan
   - [ ] Update component type imports
   - [ ] Document type hierarchy

2. **Config System**
   - [ ] Audit all config files
   - [ ] Create config migration plan
   - [ ] Update component configs
   - [ ] Document config structure