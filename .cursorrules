# CodeBase Document Index (`CDI`)

`CodeBase_Docs/CodeBase_Architecture.md` - For Specifics on the code base structure, methods, and architecture.
`CodeBase_Docs/CodeBase_Mapping` - A Living directory that is to be ONLY updated with specific files, their locations, and purpose to keep track of the code base.
`CodeBase_Docs/CodeBase_Error_Log.md` - A File to log common issues while debugging, to AVOID them later in development.
`CodeBase_Docs/CodeBase_Linting_Progress.md` - A Linter Log to document best practises, do's and donts to avoid future linting errors.

---

# Workflow & Instructions(`WFI`)

1. During your interaction with the user, if you find anything reusable in this project (e.g. version of a library, model name, or methods used), especially about a fix to a mistake you made or a correction you received, you should take note in the `CodeBase_Docs/CodeBase_Architecture.md` file so you will not make the same mistake again.

2. You must update the `CodeBase_Docs/CodeBase_Mapping` file as a navigation guide to easily navigate the codebase and its assets to circumvent duplication and codebase conflicts. a `CodeBase_Docs/CodeBase_Mapping` file should be ADDITIVE, not destructive. The point is to maintain a complete map of the entire code base. Do not remove entries or information from the file.

3. You will operate on a sctrict workflow called `Rule of Seven` or `RO7`.

   1. Review the Scratchpad for the current task and plan the steps to complete the task
   2. Search `CodeBase_Docs/CodeBase_Mapping` for existing implementations, if none found search the codebase and adjust the plan if necessary
   3. Take action to complete the task
   4. Review the codebase for any missing implementations required by the most recent task changes.
   5. Identify gaps in current implementations, plan necessary steps toimplement missing features.
   6. Update the `Scratchpad` section.
   7. Finally, update the `CodeBase_Docs/CodeBase_Architecture.md` and `CodeBase_Docs/CodeBase_Mapping` files for code base consistency.

4. Use the `.cursorrules` file as a `Scratchpad` to organize your thoughts. Especially when you receive a new task, you should first review the content of the Scratchpad, clear old different task if necessary, first explain the task, and plan the steps you need to take to complete the task. You can use todo markers to indicate the progress, e.g.

```
[X] Task 1
[ ] Task 2
```

Also update the progress of the task in the Scratchpad when you finish a subtask.
Especially when you finished a milestone, it will help to improve your depth of task accomplishment to use the Scratchpad to reflect and plan. You should add only small and essential notes with the `Scratchpad` plan.
The goal is to help you maintain a big picture as well as the progress of the task. Always refer to the Scratchpad when you plan the next step.

---

# Scratchpad

1. **ADDING `\_` TO VARIABLES IS NOT AN ACCEPTABLE FIX FOR TYPESRIPT ERRORS**
2. **DELETING IMPLEMENTATIONS OR SILENCING METHODS IS NOT AN ACCEPTABLE FIX FOR TYPESCRIPT ERRORS**
3. **THE DEFINITION OF FIXING ERRORS IS IMPLEMENTING THEM PROPERLY, WITH THE REST OF THE CODE BASE**

## Tasklist

### `PRIMARY TASKLIST` [HIGH-PRIORITY]

- [x] **Mothership**
  - [x] Animated superstructure expansion
  - [x] Resource flow visualizations
- [x] **Colony System**
  - [x] Population growth mechanics
  - [x] Automated population increase
  - [x] Trade route visualization
  - [x] Growth rate modifiers
  - [x] Colony map visualization
  - [x] Resource dashboard
  - [x] Satisfaction meter
  - [x] Population projection
- [x] **Combat System Module**
  - [x] Object detection system
  - [x] Scan radius calculation
  - [x] Threat assessment logic
  - [x] Animated radar sweep
  - [x] Detection visualization
  - [x] Range indicators
  - [x] Alert system UI
  - [x] Combat mechanics core system
- [ ] **Exploration System**
  - [ ] Create the AutomatedSectorScanner.tsx component for automated sector scanning
  - [ ] Real-time map updates
  - [ ] Advanced filtering system
  - [ ] Detailed anomaly analysis
  - [ ] Resource potential visualization
  - [ ] Galaxy mapping system
  - [ ] Resource discovery
  - [ ] Exploration data management
  - [ ] Automated sector scanning
  - [ ] Discovery classification
  - [ ] Recon ship coordination
  - [ ] Data analysis system
- [ ] **Mining System**
  - [ ] Enhanced visualization of operations
- [x] **Tech Tree System**
  - [x] Enhanced visual feedback
  - [ ] Real-time progress tracking
  - [ ] Advanced synergy visualization
  - [ ] Detailed tech path planning

### III. Technical Implementation

- [ ] **Visual Systems**
  - [ ] Multi-layer parallax background
  - [ ] Depth effect implementation
  - [ ] Scroll speed variation
  - [ ] Evolution animations
  - [ ] Upgrade transitions
  - [ ] Interactive elements
  - [ ] Cosmic weather effects
  - [ ] Day/night cycle
  - [ ] Aurora animations
  - [ ] Solar wind effects
- [ ] **User Experience Improvements**
  - [ ] Add animations for state transitions
  - [ ] Improve error messages
  - [ ] Create better loading indicators
  - [ ] Implement touch-friendly controls
  - [ ] Add keyboard navigation
  - [ ] Implement screen reader support
  - [ ] Enhance color contrast

1. **Technical Debt Reduction** [MEDIUM PRIORITY]

   - [x] Enhance state management
     - [x] Refactor to use context selectors
     - [x] Implement state persistence
     - [x] Add state migration utilities

2. **Performance Monitoring** [LOW PRIORITY]

   - [x] Implement performance tracking
     - [x] Add metrics for critical operations
     - [x] Create performance dashboards
     - [x] Set up alerts for performance regressions
   - [ ] Optimize resource usage
     - [ ] Implement memory profiling
     - [ ] Add CPU usage monitoring
     - [ ] Optimize GPU utilization for effects
   - [ ] Enhance debugging tools
     - [ ] Create visual debuggers for complex systems
     - [ ] Add time-travel debugging for state
     - [ ] Implement conditional breakpoints for events

3. **User Experience Improvements** [LOW PRIORITY]

   - [ ] Enhance visual feedback
     - [ ] Add animations for state transitions
     - [ ] Improve error messages
     - [ ] Create better loading indicators
   - [ ] Optimize mobile experience
     - [ ] Implement responsive designs
     - [ ] Add touch-friendly controls
     - [ ] Optimize for different screen sizes
   - [ ] Improve accessibility
     - [ ] Add keyboard navigation
     - [ ] Implement screen reader support
     - [ ] Enhance color contrast

4. **Documentation Enhancements** [LOW PRIORITY]

   - [x] Update system documentation
     - [x] Create user guides for game mechanics
     - [x] Document API interfaces for module integration
     - [x] Add troubleshooting guides for common issues
   - [ ] Enhance developer documentation
     - [ ] Create onboarding guide for new developers
     - [ ] Document best practices for each subsystem
     - [ ] Add examples for common implementation patterns

### Next Steps

1. **Feature Implementation**:

   - [x] Implement State Management - refactor to use context selectors
   - [x] Implement State Management - implement state persistence
   - [x] Implement State Management - add state migration utilities
   - [x] Implement UI Framework - additional component profiling
   - [ ] Implement UI Framework - optimize for mobile responsiveness

2. **Technical Debt Reduction**:

   - [x] Refactor state management to use context selectors
   - [ ] Optimize component rendering with memoization

3. **Documentation Enhancements**:
   - [x] Add troubleshooting guides for common issues in the state management system
   - [x] Document component profiling system
   - [ ] Create onboarding guide for new developers
