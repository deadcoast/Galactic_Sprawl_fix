# Instructions

During your interaction with the user, if you find anything reusable in this project (e.g. version of a library, model name), especially about a fix to a mistake you made or a correction you received, you should take note in the `Lessons` section in the `.cursorrules` file so you will not make the same mistake again.

You should also use the `.cursorrules` file as a Scratchpad to organize your thoughts. Especially when you receive a new task, you should first review the content of the Scratchpad, clear old different task if necessary, first explain the task, and plan the steps you need to take to complete the task. You can use todo markers to indicate the progress, e.g.
[X] Task 1
[ ] Task 2

Also update the progress of the task in the Scratchpad when you finish a subtask.
Especially when you finished a milestone, it will help to improve your depth of task accomplishment to use the Scratchpad to reflect and plan.
The goal is to help you maintain a big picture as well as the progress of the task. Always refer to the Scratchpad when you plan the next step.

Your `.cursorrules` workflow is **MANDATORY** as follows.

1. Review the Scratchpad
2. Review the task
3. Plan the steps
4. Search codebase for existing implementations
5. Take action
6. Update the `Scratchpad` and `Lessons` sections

**YOU MUST ALWAYS SEARCH THE CODE BASE TO AVOID CREATING DUPLICATE IMPLEMENTATIONS.**

## Lessons

- Include info useful for debugging in the program output.
- When correcting errors, do NOT delete unused code. Instead generate its implementation.
- Read the file before you try to edit it.
- Always check the exact type names in the codebase - e.g. "minerals" vs "mineral" in ResourceType.
- When implementing automation systems, ensure proper integration with existing event systems and contexts.
- Pay attention to module types - use the correct ModuleType from ModuleTypes.ts.
- When working with resource types, use the proper ResourceType from ResourceTypes.ts.
- Maintain type safety across the entire system - don't use string literals when proper types exist.
- Ensure event emissions are consistent with the module event bus system.
- When implementing managers, ensure proper cleanup in unregister/complete methods.
- Use proper event typing with generic EventEmitter for type safety.
- Implement proper cleanup in training and squad systems.
- Calculate bonuses and multipliers based on traits and specializations.
- Keep state updates and event emissions consistent.

## Cursor Learned

### CRITICAL: Code Organization and Development

1. **ALWAYS SEARCH FOR EXISTING IMPLEMENTATIONS BEFORE CREATING NEW CODE**
   - Use file_search and codebase_search BEFORE writing any new component
   - Check all similar file names and paths thoroughly
   - Review existing implementations completely
   - NEVER create new files without verifying duplicates
   - If duplicate work is discovered, IMMEDIATELY fix it yourself
   - Take responsibility for your own mistakes and fix them immediately
   - Don't just identify problems - SOLVE them

2. **Type System Organization**
   - Keep core/base types in a central location (e.g., GameTypes.ts)
   - Use inheritance for shared properties (e.g., extending BaseStats)
   - Maintain clear type hierarchies (base -> specific -> component props)
   - Group related types together with clear section comments
   - Re-export types that are commonly used together
   - Use proper type imports from their source files
   - Pay attention to exact type names and values

3. **Similar Interface Management**
   - Keep interfaces separate if they truly serve different purposes
   - Use specific naming to indicate purpose (e.g., FactionWeaponEffect vs DebugWeaponEffect)
   - Document the purpose and differences between similar interfaces
   - Each interface should:
     - Have a clear, specific purpose
     - Live in the appropriate module
     - Use types relevant to its purpose
     - Be imported from a single source of truth

### Development Best Practices

- Add debug information to stderr while keeping stdout clean
- Handle lexical declarations in switch-case blocks using block scoping
- Remove unused imports to avoid TypeScript linter warnings
- Use 'as const' assertions to properly type string literals
- Properly handle cleanup in useEffect to prevent memory leaks
- When implementing threshold-based systems, use proper TypeScript types and React Context
- For search results, ensure proper handling of different character encodings (UTF-8)
- Ensure proper event emission and handling across the system
- Maintain consistent type usage across related components

### API and Tool Usage

- Use 'seaborn-v0_8' instead of 'seaborn' for matplotlib styles
- Use 'gpt-4o' as the model name for OpenAI's GPT-4 with vision capabilities

### Testing (Last Step)

1. **React Component Testing Setup**
   - Create test wrapper component for context providers
   - Use async/await with userEvent for interactions
   - Handle multiple instances with specific queries

2. **Button and UI Element Testing**
   - Use `getAllByRole` instead of `getByText` for multiple instances
   - Select last instance for action buttons
   - Use role-based queries for accessibility
   - Check attributes like 'disabled' instead of toBeDisabled()

3. **Data Display Testing**
   - Look for actual displayed format (e.g., '+15' vs '15')
   - Consider context of value display
   - Use regex for flexible text matching

# Scratchpad

### Current Task: Ship Hangar Integration

1. **Analysis of Requirements**
   [X] Review UI menu documentation
   [X] Identify integration points
   [X] Map out component structure
   [X] Review existing ship type implementations

2. **Ship Hangar Core**
   [X] Ship Production System
     [X] Build queue management
     [X] Resource cost calculation
     [X] Build time tracking
     [X] Tier-based unlocks
   [X] Docking Bay System
     [X] Bay capacity management
     [X] Expansion tracking
     [X] Ship storage/retrieval

3. **Integration Points**
   [X] Resource System
     [X] Cost verification
     [X] Resource consumption
     [X] Refund handling
   [X] Tech Tree Integration
     [X] Tier unlocks
     [X] Upgrade paths
     [X] Prerequisite checking
   [X] Officer System
     [X] Captain assignment
     [X] Skill bonuses
     [X] Training integration

4. **UI Components**
   [ ] Ship Category Navigation
     [ ] War ships tab
     [ ] Recon ships tab
     [ ] Mining ships tab
   [ ] Ship Build Interface
     [ ] Ship cards/grid
     [ ] Resource cost display
     [ ] Build time estimation
     [ ] Tier requirements
   [ ] Build Queue Management
     [ ] Queue display
     [ ] Progress tracking
     [ ] Cancel/modify options
   [ ] Docking Bay Visualization
     [ ] Bay layout
     [ ] Expansion animations
     [ ] Ship placement

### Implementation Steps
1. [X] Create Ship Hangar Manager
   - [X] Define core interfaces
   - [X] Implement queue system
   - [X] Handle resource management
   - [X] Track build progress

2. [ ] Implement UI Components
   - [ ] Build ship category navigation
   - [ ] Create ship cards with stats
   - [ ] Design build queue interface
   - [ ] Develop docking bay visualization

3. [ ] Integrate Systems
   - [X] Connect to resource system
   - [X] Link with tech tree
   - [X] Integrate officer assignments
   - [ ] Add visual progression

### Notes
- Need to maintain consistent UI theme with Officers Academy
- Use same animation system as other modules
- Ensure proper cleanup on queue changes
- Handle edge cases (resource shortages, cancellations)
- Consider performance with multiple ships in production
- Plan for future expansion (new ship types, upgrades)

### Next Actions
1. [X] Search for existing ship production code
2. [X] Review ship type definitions
3. [X] Start Ship Hangar Manager implementation
4. [ ] Update Ship Hangar UI component
5. [ ] Implement visual progression system
