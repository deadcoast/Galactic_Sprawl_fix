# [GALACTIC_SPRAWL] CODEBASE DOCUMENTATION

This documentation uses hashtag identifiers (#system_name) to mark major system sections.
When searching for information about a specific system, use these hashtags to locate
relevant sections. For example, to find information about the resource system, search for
"#resource_system" to locate the complete documentation for that system.

## .cursorrules USAGE INSTRUCTIONS

1. When presented with this template, analyze the provided codebase to extract the structural information requested in each section.
2. For each section, replace the comment placeholder with actual content derived from the codebase analysis.
3. Focus on extracting concrete implementation details, patterns, interfaces, and code examples rather than providing abstract explanations.
4. Maintain the ASCII directory tree diagram format for hierarchical relationships.
5. Include representative code snippets that show actual implementation patterns.
6. Remove any sections that don't apply to the codebase being analyzed.
7. Add additional system-specific sections as needed.
8. Keep explanations minimal - the code and structure should speak for themselves.
9. Preserve the hashtag section identifiers (#system_name) as they serve as quick reference points.
10. Focus on information that would be most relevant for understanding the codebase architecture and implementing new features.

## SYSTEM ARCHITECTURE

BaseManager
├── AbstractBaseManager
├── ResourceManager
│ ├── ResourceFlowManager
│ ├── ResourceConversionManager
│ ├── ResourceThresholdManager
│ └── ResourceStorageManager
├── ModuleManager
│ ├── ModuleStatusManager
│ ├── ModuleUpgradeManager
│ └── SubModuleManager
├── ExplorationManager
│ └── ReconShipManagerImpl
├── CombatManager
│ ├── CombatMechanicsSystem
│ ├── ThreatAssessmentManager
│ └── WarShipManagerImpl
├── ShipHangarManager
│ └── StandardShipHangarManager
├── FactionManager
│ ├── FactionBehaviorManager
│ └── FactionRelationshipManager
├── GameManager
├── AnimationManager
├── AssetManager
└── GameLoopManager

## COMPONENT ARCHITECTURE

ContextProviders
├── GameContext
├── ResourceRatesContext
├── ThresholdContext
├── ModuleContext
├── ExplorationContext
├── ClassificationContext
└── ShipContext

EventSystems
├── EventSystem
├── EventBus
├── ModuleEventBus
└── UnifiedEventSystem

## LOCAL IMPORT DIRECTORY (#local_imports)

```typescript
// Resource system imports - observed patterns
// MODULE: `src/types/resources/ResourceTypes.ts`
// IMPORTED BY:
// Resource Managers (most common):

import { ResourceType } from '../../types/resources/ResourceTypes';

import { ResourceState, ResourceType } from '../../types/resources/ResourceTypes';

// UI Components:
import { ResourceType } from '../../../types/resources/ResourceTypes';

// System Files:
import { ResourceType } from './../types/resources/ResourceTypes';

// MODULE: `src/types/resources/ResourceConversionTypes.ts`
// IMPORTED BY:
// Resource Conversion Manager:

import { ResourceConversionRecipe as ExtendedResourceConversionRecipe } from '../../types/resources/ResourceConversionTypes';

// Resource Exchange Manager:
import { ResourceExchangeRate } from '../../types/resources/ResourceConversionTypes';

// MODULE: `src/types/modules/ModuleTypes.ts`
// IMPORTED BY:
// Core Components:
import { Module } from '../../types/modules/ModuleTypes';

// Contexts:
import {
  Module,
  ModuleStatus,
  ModuleEventType,
  IModuleManager,
} from '../types/modules/ModuleTypes';

// App Root:
import { ModuleStatus } from './types/modules/ModuleTypes';

// Ship system imports
// MODULE: `src/types/ships/FactionShipTypes.ts`
// IMPORTED BY:
// Faction UIs:
import { FactionShip, FactionShipProps } from '../../../types/ships/FactionShipTypes';
// Ship Components:
import { FactionShipClass } from '../../types/ships/FactionShipTypes';

// Type Validation Imports
// MODULE: `src/utils/resources/resourceValidation.ts`
// IMPORTED BY:
// Resource Components:
import { isResourceType, validateResourceState } from '../../utils/resources/resourceValidation';

// Resource Managers:
import { validateResourceThreshold } from '../../utils/resources/resourceValidation';
```

## Import Patterns Summary

1. Relative imports are used consistently throughout the codebase
2. Paths use './' for same directory, '../' for parent, and '../../' for grandparent
3. Types are imported directly from their source modules, not through barrel files
4. Multiple imports from the same file are grouped in a single import statement
5. Type-only imports are uncommon but do appear:

```typescript
import type { ResourceState } from '../types/resources/ResourceTypes';

// Import Issues
// 1. Duplicate imports sometimes occur within the same file

import { ResourceType } from './../../types/resources/ResourceTypes';
import { ResourceType } from './../../types/resources/ResourceTypes';

// 2. Path inconsistencies with './' vs no prefix:

import { ResourceType } from './../../types/resources/ResourceTypes'; // with ./ prefix
import { ResourceType } from '../../types/resources/ResourceTypes'; // without ./ prefix

// 3. No consistent use of absolute imports (e.g., '@/types/...') across the codebase
```

## EVENT SYSTEM (#event_system)

```typescript
/**
 * EventCategory enum organizes event types into logical groups
 * Use enum instead of string literals for type safety
 */
export enum EventCategory {
  LIFECYCLE = 'lifecycle',
  RESOURCE = 'resource',
  ATTACHMENT = 'attachment',
  AUTOMATION = 'automation',
  STATUS = 'status',
  MISSION = 'mission',
  SUB_MODULE = 'sub-module',
  COMBAT = 'combat',
  TECH = 'tech',
  SYSTEM = 'system',
  THRESHOLD = 'threshold',
  EXPLORATION = 'exploration',
}

/**
 * EventType enum defines all possible event types in the system
 * Replaces string literal event types for type safety
 */
export enum EventType {
  // Lifecycle events
  MODULE_CREATED = 'MODULE_CREATED',
  MODULE_ATTACHED = 'MODULE_ATTACHED',
  MODULE_DETACHED = 'MODULE_DETACHED',
  MODULE_UPGRADED = 'MODULE_UPGRADED',
  MODULE_ACTIVATED = 'MODULE_ACTIVATED',
  MODULE_DEACTIVATED = 'MODULE_DEACTIVATED',
  MODULE_UPDATED = 'MODULE_UPDATED',
  MODULE_STATUS_CHANGED = 'MODULE_STATUS_CHANGED',
  MODULE_ALERT_ADDED = 'MODULE_ALERT_ADDED',
  MODULE_REMOVED = 'MODULE_REMOVED',

  // Resource events
  RESOURCE_PRODUCED = 'RESOURCE_PRODUCED',
  RESOURCE_CONSUMED = 'RESOURCE_CONSUMED',
  RESOURCE_TRANSFERRED = 'RESOURCE_TRANSFERRED',
  RESOURCE_PRODUCTION_REGISTERED = 'RESOURCE_PRODUCTION_REGISTERED',
  RESOURCE_PRODUCTION_UNREGISTERED = 'RESOURCE_PRODUCTION_UNREGISTERED',
  RESOURCE_CONSUMPTION_REGISTERED = 'RESOURCE_CONSUMPTION_REGISTERED',
  RESOURCE_CONSUMPTION_UNREGISTERED = 'RESOURCE_CONSUMPTION_UNREGISTERED',
  RESOURCE_FLOW_REGISTERED = 'RESOURCE_FLOW_REGISTERED',
  RESOURCE_FLOW_UNREGISTERED = 'RESOURCE_FLOW_UNREGISTERED',
  RESOURCE_SHORTAGE = 'RESOURCE_SHORTAGE',
  RESOURCE_UPDATED = 'RESOURCE_UPDATED',
  RESOURCE_DISCOVERED = 'RESOURCE_DISCOVERED',

  // Threshold events
  RESOURCE_THRESHOLD_CHANGED = 'RESOURCE_THRESHOLD_CHANGED',
  RESOURCE_THRESHOLD_TRIGGERED = 'RESOURCE_THRESHOLD_TRIGGERED',

  // Combat events
  COMBAT_UPDATED = 'COMBAT_UPDATED',

  // Game events
  GAME_STARTED = 'GAME_STARTED',
  GAME_PAUSED = 'GAME_PAUSED',
  GAME_RESUMED = 'GAME_RESUMED',
  GAME_STOPPED = 'GAME_STOPPED',

  // Exploration events
  EXPLORATION_SECTOR_DISCOVERED = 'EXPLORATION_SECTOR_DISCOVERED',
  EXPLORATION_SECTOR_SCANNED = 'EXPLORATION_SECTOR_SCANNED',
  EXPLORATION_ANOMALY_DETECTED = 'EXPLORATION_ANOMALY_DETECTED',
  EXPLORATION_RESOURCE_DETECTED = 'EXPLORATION_RESOURCE_DETECTED',
}

/**
 * Maps event types to their categories for organization and filtering
 * Always use enum values, not string literals
 */
export const EVENT_CATEGORY_MAP: Record<EventType, EventCategory> = {
  // Lifecycle events
  [EventType.MODULE_CREATED]: EventCategory.LIFECYCLE,
  [EventType.MODULE_ATTACHED]: EventCategory.LIFECYCLE,
  [EventType.MODULE_DETACHED]: EventCategory.LIFECYCLE,
  [EventType.MODULE_UPGRADED]: EventCategory.LIFECYCLE,
  [EventType.MODULE_ACTIVATED]: EventCategory.LIFECYCLE,
  [EventType.MODULE_DEACTIVATED]: EventCategory.LIFECYCLE,
  [EventType.MODULE_UPDATED]: EventCategory.LIFECYCLE,
  [EventType.MODULE_STATUS_CHANGED]: EventCategory.LIFECYCLE,
  [EventType.MODULE_ALERT_ADDED]: EventCategory.LIFECYCLE,
  [EventType.MODULE_REMOVED]: EventCategory.LIFECYCLE,

  // Resource events
  [EventType.RESOURCE_PRODUCED]: EventCategory.RESOURCE,
  [EventType.RESOURCE_CONSUMED]: EventCategory.RESOURCE,
  [EventType.RESOURCE_TRANSFERRED]: EventCategory.RESOURCE,
  [EventType.RESOURCE_PRODUCTION_REGISTERED]: EventCategory.RESOURCE,
  [EventType.RESOURCE_PRODUCTION_UNREGISTERED]: EventCategory.RESOURCE,
  [EventType.RESOURCE_CONSUMPTION_REGISTERED]: EventCategory.RESOURCE,
  [EventType.RESOURCE_CONSUMPTION_UNREGISTERED]: EventCategory.RESOURCE,
  [EventType.RESOURCE_FLOW_REGISTERED]: EventCategory.RESOURCE,
  [EventType.RESOURCE_FLOW_UNREGISTERED]: EventCategory.RESOURCE,
  [EventType.RESOURCE_SHORTAGE]: EventCategory.RESOURCE,
  [EventType.RESOURCE_UPDATED]: EventCategory.RESOURCE,
  [EventType.RESOURCE_DISCOVERED]: EventCategory.RESOURCE,

  // Threshold events
  [EventType.RESOURCE_THRESHOLD_CHANGED]: EventCategory.THRESHOLD,
  [EventType.RESOURCE_THRESHOLD_TRIGGERED]: EventCategory.THRESHOLD,

  // Combat events
  [EventType.COMBAT_UPDATED]: EventCategory.COMBAT,

  // Game events
  [EventType.GAME_STARTED]: EventCategory.SYSTEM,
  [EventType.GAME_PAUSED]: EventCategory.SYSTEM,
  [EventType.GAME_RESUMED]: EventCategory.SYSTEM,
  [EventType.GAME_STOPPED]: EventCategory.SYSTEM,

  // Exploration events
  [EventType.EXPLORATION_SECTOR_DISCOVERED]: EventCategory.EXPLORATION,
  [EventType.EXPLORATION_SECTOR_SCANNED]: EventCategory.EXPLORATION,
  [EventType.EXPLORATION_ANOMALY_DETECTED]: EventCategory.EXPLORATION,
  [EventType.EXPLORATION_RESOURCE_DETECTED]: EventCategory.EXPLORATION,
};

/**
 * Base event interface that all events must implement
 */
export interface BaseEvent {
  type: EventType; // Must use enum, not string
  timestamp: number;
  moduleId: string;
  moduleType: ModuleType; // Must use enum, not string
  data?: Record<string, unknown>;
  [key: string]: unknown; // Add index signature for compatibility
}

/**
 * Resource production event data interface
 */
export interface ResourceProductionEventData {
  resourceType: ResourceType; // Must use enum, not string
  amount: number;
  source?: string;
  target?: string;
  production?: number;
  oldAmount?: number;
  newAmount?: number;
  delta?: number;
}

/**
 * Resource consumption event data interface
 */
export interface ResourceConsumptionEventData {
  resourceType: ResourceType; // Must use enum, not string
  amount: number;
  consumer?: string;
  consumption?: number;
  oldAmount?: number;
  newAmount?: number;
  delta?: number;
}

/**
 * Resource transfer event data interface
 */
export interface ResourceTransferEventData {
  resourceType: ResourceType; // Must use enum, not string
  amount: number;
  sourceId: string;
  targetId: string;
  transferTime?: number;
}

/**
 * Threshold triggered event data interface
 */
export interface ThresholdTriggeredEventData {
  resourceType: ResourceType; // Must use enum, not string
  resourceId: ResourceType; // Must use enum, not string
  thresholdType: 'critical' | 'low' | 'normal' | 'high' | 'maximum';
  currentValue: number;
  thresholdValue: number;
  direction: 'increasing' | 'decreasing';
}

/**
 * Type guard functions for event data validation
 */

/**
 * Type guard for resource update events
 */
export function isResourceUpdateEvent(
  event: ModuleEvent
): event is ModuleEvent & { data: { resourceAmounts: Partial<Record<ResourceType, number>> } } {
  return (
    event?.data !== undefined &&
    typeof event?.data === 'object' &&
    event?.data !== null &&
    'resourceAmounts' in event?.data &&
    typeof event?.data?.resourceAmounts === 'object' &&
    event?.data?.resourceAmounts !== null
  );
}

/**
 * Type guard for resource production events
 */
export function isResourceProductionEvent(
  event: ModuleEvent
): event is ModuleEvent & { data: { resourceType: ResourceType; amount: number } } {
  return (
    event?.data !== undefined &&
    typeof event?.data === 'object' &&
    event?.data !== null &&
    'resourceType' in event?.data &&
    'amount' in event?.data &&
    typeof event?.data?.amount === 'number'
  );
}

/**
 * Type guard for resource consumption events
 */
export function isResourceConsumptionEvent(
  event: ModuleEvent
): event is ModuleEvent & { data: { resourceType: ResourceType; amount: number } } {
  return (
    event?.data !== undefined &&
    typeof event?.data === 'object' &&
    event?.data !== null &&
    'resourceType' in event?.data &&
    'amount' in event?.data &&
    typeof event?.data?.amount === 'number'
  );
}

/**
 * Type guard for threshold triggered events
 */
export function isThresholdTriggeredEventData(data: unknown): data is ThresholdTriggeredEventData {
  if (!data || typeof data !== 'object') return false;

  const d = data as ThresholdTriggeredEventData;
  return (
    'resourceType' in d &&
    'thresholdType' in d &&
    'currentValue' in d &&
    'thresholdValue' in d &&
    'direction' in d &&
    typeof d.currentValue === 'number' &&
    typeof d.thresholdValue === 'number' &&
    (d.direction === 'increasing' || d.direction === 'decreasing')
  );
}

/**
 * Event utility functions
 */

/**
 * Get all event types for a specific category
 */
export function getEventTypesByCategory(category: EventCategory): EventType[] {
  return Object.entries(EVENT_CATEGORY_MAP)
    .filter(([_, eventCategory]) => eventCategory === category)
    .map(([eventType, _]) => eventType as EventType);
}

/**
 * Convert a string to an EventType enum value
 */
export function stringToEventType(eventTypeString: string): EventType | undefined {
  return Object.values(EventType).find(eventType => eventType === eventTypeString) as
    | EventType
    | undefined;
}

/**
 * Create a new event with the required properties
 */
export function createEvent<T extends Record<string, unknown>>(
  type: EventType | string, // Prefer EventType enum over string
  moduleId: string,
  moduleType: ModuleType, // Must use ModuleType enum, not string
  data?: T
): BaseEvent {
  return {
    type: typeof type === 'string' ? type : type.toString(),
    moduleId,
    moduleType,
    timestamp: Date.now(),
    data,
  };
}

/**
 * Combat System Events
 *
 * The combat system uses standardized events with enum-based event types
 */

/**
 * Combat event data interface
 */
export interface CombatEventData {
  units: CombatUnit[];
  timestamp: number;
  position?: { x: number; y: number };
  state?: 'active' | 'paused' | 'completed';
}

/**
 * Combat unit status interface
 */
export interface CombatUnitStatus {
  main: 'active' | 'disabled' | 'destroyed'; // Use string unions instead of raw strings
  secondary?: 'charging' | 'cooling' | 'repairing' | 'boosting'; // Use string unions
  effects: string[];
}

/**
 * Fleet formation interface
 *
 * Note: Two different interfaces exist in the codebase with swapped properties
 */
export interface FleetFormation {
  type: 'offensive' | 'defensive' | 'balanced'; // Use string unions
  pattern: 'spearhead' | 'shield' | 'diamond' | 'arrow' | 'circle' | 'wedge' | 'line' | 'scattered'; // Use string unions
  spacing: number;
  facing: number;
  adaptiveSpacing: boolean;
  transitionSpeed: number;
}

/**
 * Fleet AI Result interface for visualization
 */
export interface FleetAIResult {
  formationPatterns: string[];
  adaptiveAI: boolean;
  factionBehavior: string;
  visualFeedback?: {
    formationLines: {
      points: [number, number][];
      style: 'solid' | 'dashed'; // Use string union
      color: string;
      opacity: number;
    }[];
  };
}

/**
 * Event subscription hook
 */
export function useEventSubscription<T extends BaseEvent>(
  eventType: EventType,
  handler: (event: T) => void,
  options: {
    priority?: number;
    once?: boolean;
  } = {}
): void {
  useEffect(() => {
    const unsubscribe = eventSystem.subscribe(eventType.toString(), handler, options);
    return () => {
      unsubscribe();
    };
  }, [eventType, handler, options]);
}

/**
 * Event publishing function
 */
export function publishEvent<T extends BaseEvent>(event: T): void {
  eventSystem.publish(event);
}

/**
 * Best Practices for Event System
 *
 * 1. Always use EventType enum instead of string literals
 * 2. Use type guards for runtime validation of event data
 * 3. Use proper type annotations for event data interfaces
 * 4. Be consistent with event property names (e.g., resourceType vs resource)
 * 5. Use meaningful event type names (VERB_NOUN format)
 * 6. Organize events by categories using EventCategory enum
 * 7. Use typed event handlers with proper event interfaces
 * 8. Follow naming conventions for event type guards (is[EventType])
 * 9. Explicitly handle unknown event types with fallbacks
 * 10. For resource-related events, always use ResourceType enum
 */
```

## RESOURCE SYSTEM (#resource_system)

```typescript
/**
 * ResourceType as an enum for better type safety and intellisense support
 * IMPORTANT: Always use enum values instead of string literals for resource types
 */
export enum ResourceType {
  MINERALS = 'MINERALS',
  ENERGY = 'ENERGY',
  POPULATION = 'POPULATION',
  RESEARCH = 'RESEARCH',
  PLASMA = 'PLASMA',
  GAS = 'GAS',
  EXOTIC = 'EXOTIC',
  ORGANIC = 'ORGANIC',
  FOOD = 'FOOD',
  IRON = 'IRON',
  COPPER = 'COPPER',
  TITANIUM = 'TITANIUM',
  URANIUM = 'URANIUM',
  WATER = 'WATER',
  HELIUM = 'HELIUM',
  DEUTERIUM = 'DEUTERIUM',
  ANTIMATTER = 'ANTIMATTER',
  DARK_MATTER = 'DARK_MATTER',
  EXOTIC_MATTER = 'EXOTIC_MATTER',
}

/**
 * For backward compatibility with string-based resource types
 * @deprecated Use ResourceType enum instead for better type safety and intellisense support
 */
export type ResourceTypeString = keyof typeof ResourceType;

/**
 * Resource categories
 */
export enum ResourceCategory {
  BASIC = 'basic',
  ADVANCED = 'advanced',
  SPECIAL = 'special',
}

/**
 * Resource rarity levels
 */
export enum ResourceRarity {
  COMMON = 'common',
  UNCOMMON = 'uncommon',
  RARE = 'rare',
  VERY_RARE = 'very_rare',
  EXOTIC = ResourceType.EXOTIC,
}

/**
 * Resource priority configuration
 */
export interface ResourcePriorityConfig {
  type: ResourceType; // Must use enum, not string
  priority: number;
  consumers: string[];
}

/**
 * Metadata for resource types
 */
export interface ResourceTypeMetadata {
  id: ResourceType; // Must use enum, not string
  displayName: string;
  description: string;
  icon: string;
  category: ResourceCategory; // Must use enum, not string
  defaultMax: number;
}

/**
 * Resource state representing current values and limits
 */
export interface ResourceState {
  current: number;
  max: number;
  min: number;
  production: number;
  consumption: number;
  rate?: number;
  value?: number;
}

/**
 * Resource conversion recipe definition
 */
export interface ResourceConversionRecipe {
  id: string;
  name: string;
  description: string;
  inputs: Array<{
    type: ResourceType; // Must use enum, not string
    amount: number;
  }>;
  outputs: Array<{
    type: ResourceType; // Must use enum, not string
    amount: number;
  }>;
  duration: number;
  energyCost: number;
  requiredLevel: number;
}

/**
 * Resource threshold for triggering events or actions
 */
export interface ResourceThreshold {
  resourceId: ResourceType; // Must use enum, not string
  min?: number;
  max?: number;
  target?: number;
  critical?: number;
  low?: number;
  high?: number;
  maximum?: number;
}

/**
 * Resource flow node type - strong enum typing
 */
export enum FlowNodeType {
  PRODUCER = 'producer',
  CONSUMER = 'consumer',
  STORAGE = 'storage',
  CONVERTER = 'converter',
  SOURCE = 'source',
  SINK = 'sink',
}

/**
 * Flow node in a resource network
 */
export interface FlowNode {
  id: string;
  type: FlowNodeType; // Must use enum, not string
  name: string;
  description?: string;
  capacity: number;
  currentLoad: number;
  efficiency: number;
  status: 'active' | 'inactive' | 'maintenance' | 'error';
  resources?: Map<ResourceType, number>; // Use ResourceType enum as keys
  active?: boolean;
  inputs?: Array<{
    type: ResourceType; // Must use enum, not string
    rate: number;
    maxCapacity: number;
  }>;
  outputs?: Array<{
    type: ResourceType; // Must use enum, not string
    rate: number;
    maxCapacity: number;
  }>;
}

/**
 * Flow connection between nodes
 */
export interface FlowConnection {
  id: string;
  source: string;
  target: string;
  resourceTypes: ResourceType[]; // Must use enum, not string
  maxFlow?: number;
  metadata?: Record<string, unknown>;
  maxRate?: number;
  currentRate?: number;
  priority?: ResourcePriorityConfig;
  active?: boolean;
}

/**
 * Resource priority enum for prioritizing resource allocation
 */
export enum ResourcePriority {
  CRITICAL = 'critical',
  HIGH = 'high',
  MEDIUM = 'medium',
  LOW = 'low',
  OPTIONAL = 'optional',
}

/**
 * Resource container for storage
 */
export interface ResourceContainer {
  id: string;
  name: string;
  description?: string;
  capacity: number;
  resources: Record<ResourceType, ResourceState>; // Use ResourceType enum as keys
  maxResourceTypes?: number;
  allowedResourceTypes?: ResourceType[]; // Must use enum, not string
  efficiency?: number;
  lastUpdated: number;
}

/**
 * Resource pool for aggregating resources
 */
export interface ResourcePool {
  id: string;
  name: string;
  description?: string;
  resources: Record<ResourceType, number>; // Use ResourceType enum as keys
  containers: string[];
  maxCapacity?: number;
  lastUpdated: number;
}

// Type conversion utilities
export function toEnumResourceType(type: ResourceTypeString): ResourceType {
  return ResourceType[type as keyof typeof ResourceType];
}

export function toStringResourceType(type: ResourceType): ResourceTypeString {
  return ResourceType[type] as ResourceTypeString;
}

// Type guard for resource type validation
export function isEnumResourceType(value: unknown): value is ResourceType {
  return typeof value === 'string' && Object.values(ResourceType).includes(value as ResourceType);
}

/**
 * Utility functions for working with resource types
 */
export const ResourceTypeHelpers = {
  /**
   * Convert a string resource type to enum resource type
   */
  stringToEnum(type: ResourceTypeString): ResourceType {
    return ResourceType[type];
  },

  /**
   * Convert an enum resource type to string resource type
   */
  enumToString(type: ResourceType): ResourceTypeString {
    return ResourceType[type] as ResourceTypeString;
  },

  /**
   * Get metadata for a resource type
   */
  getMetadata(type: ResourceType | ResourceTypeString): ResourceTypeMetadata {
    const enumType =
      typeof type === 'string' ? this.stringToEnum(type as ResourceTypeString) : type;
    return ResourceTypeInfo[enumType];
  },

  /**
   * Get display name for a resource type
   */
  getDisplayName(type: ResourceType | ResourceTypeString): string {
    return this.getMetadata(type).displayName;
  },
};

/**
 * Common resource type utility functions for data visualization
 */

/**
 * Gets a color for a resource type (for visualization)
 */
export function getResourceTypeColor(resourceType: ResourceType): string {
  const colorMap: Record<ResourceType, string> = {
    [ResourceType.MINERALS]: '#8B4513', // SaddleBrown
    [ResourceType.ENERGY]: '#FFD700', // Gold
    [ResourceType.POPULATION]: '#32CD32', // LimeGreen
    // additional mappings...
  };

  return colorMap[resourceType] || '#808080'; // Default to gray if not found
}

/**
 * Formats a resource amount for display
 */
export function formatResourceAmount(amount: number, resourceType?: ResourceType): string {
  if (amount >= 1_000_000) {
    return `${(amount / 1_000_000).toFixed(1)}M`;
  } else if (amount >= 1_000) {
    return `${(amount / 1_000).toFixed(1)}K`;
  } else if (Number.isInteger(amount)) {
    return amount.toString();
  } else {
    return amount.toFixed(1);
  }
}

/**
 * ResourceStateClass for managing resource state with built-in validation
 */
export class ResourceStateClass {
  private _current: number;
  private _max: number;
  private _min: number;
  private _production: number;
  private _consumption: number;
  private _type: ResourceType;

  constructor(data: {
    type: ResourceType | ResourceTypeString;
    current?: number;
    max?: number;
    min?: number;
    production?: number;
    consumption?: number;
  }) {
    // Ensure we're using the enum type
    this._type =
      typeof data.type === 'string'
        ? toEnumResourceType(data.type as ResourceTypeString)
        : data.type;

    // Initialize with defaults or provided values
    this._current = data.current ?? 0;
    this._max = data.max ?? 100;
    this._min = data.min ?? 0;
    this._production = data.production ?? 0;
    this._consumption = data.consumption ?? 0;
  }

  // Getters and setters with validation
  get current(): number {
    return this._current;
  }

  set current(value: number) {
    this._current = Math.max(this._min, Math.min(this._max, value));
  }

  // Other getters and setters...

  /**
   * Convert to a plain ResourceState object
   */
  public asObject(): ResourceState {
    return {
      current: this._current,
      max: this._max,
      min: this._min,
      production: this._production,
      consumption: this._consumption,
      rate: this.rate,
      value: this.value,
    };
  }

  /**
   * Create a ResourceStateClass from a ResourceState object
   */
  public static fromResourceState(state: ResourceState, type: ResourceType): ResourceStateClass {
    return new ResourceStateClass({
      type,
      current: state.current,
      max: state.max,
      min: state.min,
      production: state.production,
      consumption: state.consumption,
    });
  }

  /**
   * Calculate the net rate (production - consumption)
   */
  get rate(): number {
    return this._production - this._consumption;
  }

  /**
   * Get the estimated value
   */
  get value(): number {
    return this._current * ResourceTypeInfo[this._type].valueMultiplier || 1;
  }
}

/**
 * Resource System Architecture
 *
 * The resource system consists of these key components:
 */

/**
 * ResourceSystem
 * Singleton that manages all resource-related functionality
 * Uses StandardizedResourceType with compatibility layer
 * Coordinates between specialized subsystems
 */

/**
 * ResourceFlowSubsystem
 * Manages resource flow between entities
 * Accepts both string and enum resource types
 * Handles resource transfers and rate calculations
 */

/**
 * ResourceTransferSubsystem
 * Manages one-time resource transfers
 * Validates transfers against resource capacities
 * Emits events for successful and failed transfers
 */

/**
 * ResourceStorageSubsystem
 * Manages resource storage capacities
 * Handles resource capacity upgrades
 * Provides storage-related queries and validations
 */

/**
 * ResourceThresholdSubsystem
 * Manages resource thresholds (critical, low, high)
 * Emits events when thresholds are crossed
 * Provides threshold-related queries
 */

/**
 * Resource Type Deprecation Plan
 * The deprecation process is divided into four phases:
 */

/**
 * Phase 1: Warnings
 * Console warnings are emitted when string-based resource types are used
 * Low impact - Developers are informed but code continues to work
 * Purpose: Raise awareness and encourage voluntary migration
 */

/**
 * Phase 2: Development Errors
 * Console errors in development mode, warnings in production
 * Medium impact - More visible in development, but doesn't break production
 * Purpose: Increase urgency for developers to update their code
 */

/**
 * Phase 3: Development Exceptions
 * Throws errors in development mode, logs errors in production
 * High impact - Breaks development builds, strongly visible in production logs
 * Purpose: Force migration in development while maintaining production stability
 */

/**
 * Phase 4: Full Removal
 * Always throws errors (string-based types no longer supported)
 * Critical impact - Breaks any code still using string-based resource types
 * Purpose: Complete the transition to enum-based resource types
 */

/**
 * Common Resource Type Error Patterns and Fixes
 */

/**
 * Pattern 1: String Literals in Function Parameters
 *
 * Error:
 * function processResource(resourceType: string, amount: number) {
 *   if (resourceType === 'minerals') {
 *     // Process minerals
 *   }
 * }
 *
 * Fix:
 * function processResource(resourceType: ResourceType, amount: number) {
 *   if (resourceType === ResourceType.MINERALS) {
 *     // Process minerals
 *   }
 * }
 */

/**
 * Pattern 2: String Literals in Object Properties
 *
 * Error:
 * const resources = [
 *   { type: 'minerals', amount: 100 },
 *   { type: 'energy', amount: 50 },
 * ];
 *
 * Fix:
 * const resources = [
 *   { type: ResourceType.MINERALS, amount: 100 },
 *   { type: ResourceType.ENERGY, amount: 50 },
 * ];
 */

/**
 * Pattern 3: String Literals in Component Props
 *
 * Error:
 * <ResourceDisplay resourceType="minerals" amount={100} />
 *
 * Fix:
 * <ResourceDisplay resourceType={ResourceType.MINERALS} amount={100} />
 */

/**
 * Best Practices for Resource Types
 *
 * 1. Always use enum values directly: Prefer ResourceType.MINERALS over string literals
 * 2. Use ResourceTypeInfo for display: Get user-facing text from ResourceTypeInfo metadata
 * 3. Use computed property names for objects: Use [ResourceType.MINERALS] syntax for object keys
 * 4. Leverage type guards: Use isEnumResourceType and isStringResourceType for type safety
 * 5. Centralize conversion logic: Use the converter utilities instead of manual conversion
 * 6. Provide meaningful error messages: When handling invalid resource types, include context
 * 7. Use null coalescence for safety: When accessing resources, handle potential undefined values
 * 8. Use type annotations: Explicitly type variables and parameters for better IDE support
 * 9. Use color-related utilities for visualization: Maintain consistent visual representation
 * 10. Leverage ResourceStateClass for encapsulated state management with validation
 */

/**
 * Resource type visualization helpers
 */
export const ResourceVisualizationHelpers = {
  /**
   * Get a lighter color variant for highlights
   */
  getHighlightColor(resourceType: ResourceType): string {
    const baseColor = getResourceTypeColor(resourceType);
    // Implementation to create a lighter variant
    return baseColor;
  },

  /**
   * Get a darker color variant for shadows
   */
  getDarkColor(resourceType: ResourceType): string {
    const baseColor = getResourceTypeColor(resourceType);
    // Implementation to create a darker variant
    return baseColor;
  },

  /**
   * Format resource amount with the appropriate unit
   */
  formatAmount(amount: number, resourceType: ResourceType): string {
    // Resource-specific formatting logic
    return formatResourceAmount(amount);
  },

  /**
   * Generate CSS variables for a specific resource type
   */
  generateCssVars(resourceType: ResourceType): Record<string, string> {
    return {
      '--resource-color': getResourceTypeColor(resourceType),
      '--resource-highlight-color': this.getHighlightColor(resourceType),
      '--resource-dark-color': this.getDarkColor(resourceType),
    };
  },
};

### Trade Route System

The Trade System includes a comprehensive trade route management framework for establishing and visualizing resource flow between locations.

/**
 * Visualization effect props pattern
 */
export interface ParticleTransitionVisualizationProps {
  data: DataPoint[];
  width: number;
  height: number;
  startState: VisualizationState;
  endState: VisualizationState;
  duration?: number;
  easingFunction?: (t: number) => number;
  colorScale?: (value: number) => string;
  particleCount?: number;
  particleSize?: number;
  showTrails?: boolean;
  trailLength?: number;
  onTransitionEnd?: () => void;
}

/**
 * Example implementation of a ship hangar manager
 */
export class StandardShipHangarManager extends BaseTypedEventEmitter<ShipEvents> {
  /**
   * The map of ships in the hangar
   */
  private ships: Map<string, Ship> = new Map();

  /**
   * The capacity of the hangar
   */
  private capacity: number;

  /**
   * The ID of the hangar
   */
  private hangarId: string;

  /**
   * Constructor
   * @param hangarId The ID of the hangar
   * @param capacity The capacity of the hangar
   */
  constructor(hangarId: string, capacity: number = 10) {
    super();
    this.hangarId = hangarId;
    this.capacity = capacity;
  }

  /**
   * Get all ships in the hangar
   * @returns An array of all ships
   */
  public getAllShips(): Ship[] {
    return Array.from(this.ships.values());
  }

  /**
   * Get a ship by ID
   * @param shipId The ID of the ship to get
   * @returns The ship, or undefined if not found
   */
  public getShip(shipId: string): Ship | undefined {
    return this.ships.get(shipId);
  }

  /**
   * Add a ship to the hangar
   * @param ship The ship to add
   * @returns True if the ship was added, false if the hangar is full
   */
  public addShip(ship: Ship): boolean {
    if (this.ships.size >= this.capacity) {
      return false;
    }

    this.ships.set(ship.id, ship);
    this.emit('ship:added', { ship, hangarId: this.hangarId });
    return true;
  }

  /**
   * Remove a ship from the hangar
   * @param shipId The ID of the ship to remove
   * @returns True if the ship was removed, false if not found
   */
  public removeShip(shipId: string): boolean {
    if (!this.ships.has(shipId)) {
      return false;
    }

    this.ships.delete(shipId);
    this.emit('ship:removed', { shipId, hangarId: this.hangarId });
    return true;
  }

  /**
   * Change a ship's status
   * @param shipId The ID of the ship
   * @param newStatus The new status
   * @returns True if the status was changed, false if not found
   */
  public changeShipStatus(shipId: string, newStatus: ShipStatus): boolean {
    const ship = this.ships.get(shipId);
    if (!ship) {
      return false;
    }

    const oldStatus = ship.status;
    ship.status = newStatus;
    this.ships.set(shipId, ship);
    this.emit('ship:status-changed', { shipId, newStatus, oldStatus });
    return true;
  }

  /**
   * Load cargo onto a ship
   * @param shipId The ID of the ship to load cargo onto
   * @param resourceType The type of resource to load
   * @param amount The amount of resource to load
   * @returns True if the cargo was loaded, false if not found or not enough capacity
   */
  public loadCargo(shipId: string, resourceType: ResourceType, amount: number): boolean {
    const ship = this.ships.get(shipId);
    if (!ship || !ship.cargo) {
      return false;
    }

    // Calculate current cargo usage
    let currentUsage = 0;
    for (const [_, value] of ship.cargo.resources) {
      currentUsage += value;
    }

    // Check if there's enough capacity
    if (currentUsage + amount > ship.cargo.capacity) {
      return false;
    }

    // Add the resource
    const currentAmount = ship.cargo.resources.get(resourceType) ?? 0;
    ship.cargo.resources.set(resourceType, currentAmount + amount);
    this.ships.set(shipId, ship);
    this.emit('cargo:loaded', { shipId, resourceType, amount });
    return true;
  }
}

/**
 * Resource Manager System Implementation
 *
 * Core components from Resource Management References
 */

/**
 * Resource Manager
 * Central manager for all resource operations
 * Dependencies: ResourceTypes, ResourceThresholdManager, ResourceFlowManager
 */
export class ResourceManager implements IBaseManager {
  private resources: Map<ResourceType, ResourceState> = new Map();
  private thresholdManager: ResourceThresholdManager;
  private flowManager: ResourceFlowManager;

  // Implementation methods for resource management

  /**
   * Fix for Map iteration TypeScript issues
   * Use Array.from() to convert Map entries to an array before iteration
   *
   * EXAMPLE:
   * // Instead of:
   * for (const [type, resource] of this.resources) { ... }
   *
   * // Use:
   * for (const [type, resource] of Array.from(this.resources.entries())) { ... }
   */

  /**
   * Calculate transfer rate between resources
   */
  public calculateTransferRate(sourceType: ResourceType, targetType: ResourceType): number {
    // Implementation
    return 0;
  }

  /**
   * Remove a resource and return success status
   */
  public removeResource(type: ResourceType, amount: number): boolean {
    // Implementation
    return true;
  }
}

/**
 * Resource Threshold Manager
 * Monitors resource thresholds and triggers actions
 * Dependencies: ResourceTypes, ModuleEvents
 *
 * Notes:
 * - Uses Array.from() to convert Map entries to an array before iteration to avoid MapIterator errors
 * - Includes severity information in the data object of ModuleEvents
 */
export class ResourceThresholdManager {
  private thresholds: Map<ResourceType, ResourceThreshold[]> = new Map();

  /**
   * Check a resource against its thresholds
   */
  public checkThreshold(type: ResourceType, amount: number): boolean {
    // Implementation
    return true;
  }
}

/**
 * Resource Flow Manager
 * Optimizes resource flows between systems
 * Dependencies: ResourceTypes, ResourceValidation
 *
 * Notes:
 * - Uses ResourcePriority interface for priority management
 * - Requires complete objects rather than primitive values
 * - Uses Array.from() to convert Map entries to an array before iteration
 * - Implements converter efficiency calculations
 * - Uses interval-based flow control
 * - Uses console.warn instead of console.log for logging (ESLint compliance)
 */
export class ResourceFlowManager {
  private flowNodes: Map<string, FlowNode> = new Map();
  private flowConnections: Map<string, FlowConnection> = new Map();

  /**
   * Process flows for a given time step
   */
  public processFlows(deltaTime: number): void {
    // For each connection in the flow network
    for (const [id, connection] of Array.from(this.flowConnections.entries())) {
      if (!connection.active) continue;

      // Process resource transfers based on rates, capacities and priorities
      this.processConnection(connection, deltaTime);
    }
  }

  /**
   * Process a single connection
   */
  private processConnection(connection: FlowConnection, deltaTime: number): void {
    // Implementation details
  }
}

/**
 * Resource Storage Manager
 * Manages resource storage containers
 * Dependencies: ResourceTypes, ResourceValidation
 *
 * Notes:
 * - Uses Array.from() to convert Map entries to an array before iteration
 */
export class ResourceStorageManager {
  private containers: Map<string, ResourceContainer> = new Map();

  /**
   * Get all storage containers
   */
  public getStorageContainers(): ResourceContainer[] {
    return Array.from(this.containers.values());
  }
}

/**
 * Resource Pool Manager
 * Manages resource pools, distribution, and allocation
 * Dependencies: ResourceTypes, ResourcePoolTypes, ResourceValidation
 *
 * Notes:
 * - Uses Array.from() to convert Map entries to an array before iteration
 * - Uses Map.get() and Map.set() methods for type-safe access
 */
export class ResourcePoolManager {
  private pools: Map<string, ResourcePool> = new Map();

  /**
   * Distribute resources from a pool according to rules
   */
  public distributePool(poolId: string, rules: PoolDistributionRule[]): boolean {
    const pool = this.pools.get(poolId);
    if (!pool) return false;

    // Use Array.from() to avoid MapIterator issues
    for (const rule of Array.from(rules)) {
      // Distribution logic
    }

    return true;
  }

  /**
   * Allocate resources based on options
   */
  public allocateResources(
    poolId: string,
    resourceType: ResourceType,
    amount: number,
    options?: PoolAllocationOptions
  ): PoolAllocationResult {
    // Implementation
    return { success: false, amount: 0 };
  }
}

// Anomaly classification enum
// Categorizes unusual space phenomena - always use enum, not string literals
export enum AnomalyType {
  TEMPORAL_RIFT = 'TEMPORAL_RIFT', // Time distortion
  GRAVITATIONAL_ANOMALY = 'GRAVITATIONAL_ANOMALY', // Gravity distortion
  RADIATION_POCKET = 'RADIATION_POCKET', // Unusual radiation
  QUANTUM_INSTABILITY = 'QUANTUM_INSTABILITY', // Quantum physics anomaly
  ENERGY_PHENOMENON = 'ENERGY_PHENOMENON', // Unusual energy readings
  SPATIAL_DISTORTION = 'SPATIAL_DISTORTION', // Space fabric distortion
  DIMENSIONAL_PORTAL = 'DIMENSIONAL_PORTAL', // Potential gateway
  UNKNOWN = 'UNKNOWN', // Not yet classified
}

// Exploration event definition for specialized exploration events
export interface ExplorationEvent {
  id: string;
  type: ExplorationEventType; // Must use enum, not string
  location: Coordinates; // Where the event occurred
  timestamp: number;
  objectId?: string; // Related celestial object if any
  data?: unknown; // Event-specific data
}

// Exploration event type enum
// Standardizes event types for the exploration system - always use enum, not string literals
export enum ExplorationEventType {
  SYSTEM_DISCOVERED = 'SYSTEM_DISCOVERED',
  PLANET_DISCOVERED = 'PLANET_DISCOVERED',
  ANOMALY_DETECTED = 'ANOMALY_DETECTED',
  RESOURCE_DETECTED = 'RESOURCE_DETECTED',
  SCAN_COMPLETED = 'SCAN_COMPLETED',
  ANALYSIS_COMPLETED = 'ANALYSIS_COMPLETED',
  EXPLORATION_COMPLETED = 'EXPLORATION_COMPLETED',
  SIGNAL_DETECTED = 'SIGNAL_DETECTED',
  CONTACT_ESTABLISHED = 'CONTACT_ESTABLISHED',
  HAZARD_DETECTED = 'HAZARD_DETECTED',
}

// Exploration scan result interface
export interface ScanResult {
  targetId: string;
  targetType: CelestialObjectType; // Must use enum, not string
  scanType: ScanType; // Must use enum, not string
  timestamp: number;
  duration: number; // How long the scan took in ms
  success: boolean; // Whether the scan completed successfully
  coverage: number; // 0-100 percentage of target covered
  newData: boolean; // Whether new information was discovered
  discoveredResources: Array<{
    type: ResourceType; // Must use enum, not string
    amount: number; // Estimated amount
    accessibility: number; // 0-100 ease of extraction
  }>;
  discoveredAnomalies: Array<{
    type: AnomalyType; // Must use enum, not string
    intensity: number; // 0-100 strength/significance
    coordinates: Coordinates; // Location relative to target
  }>;
}

// Scan type enum
// Defines different types of scans that can be performed - always use enum, not string literals
export enum ScanType {
  QUICK_SCAN = 'QUICK_SCAN', // Basic, fast scan
  DETAILED_SCAN = 'DETAILED_SCAN', // More thorough scan
  RESOURCE_SCAN = 'RESOURCE_SCAN', // Focused on resources
  ANOMALY_SCAN = 'ANOMALY_SCAN', // Focused on anomalies
  LIFEFORM_SCAN = 'LIFEFORM_SCAN', // Focused on detecting life
  PLANETARY_SURVEY = 'PLANETARY_SURVEY', // Complete planetary mapping
  DEEP_ANALYSIS = 'DEEP_ANALYSIS', // Intensive scientific analysis
}

// Type guards for exploration data structures

// Type guard for celestial object type validation
export function isCelestialObjectType(value: unknown): value is CelestialObjectType {
  return (
    typeof value === 'string' &&
    Object.values(CelestialObjectType).includes(value as CelestialObjectType)
  );
}

// Type guard for star classification validation
export function isStarClassification(value: unknown): value is StarClassification {
  return (
    typeof value === 'string' &&
    Object.values(StarClassification).includes(value as StarClassification)
  );
}

// Type guard for planet classification validation
export function isPlanetClassification(value: unknown): value is PlanetClassification {
  return (
    typeof value === 'string' &&
    Object.values(PlanetClassification).includes(value as PlanetClassification)
  );
}

// Type guard for scan result validation
export function isScanResult(value: unknown): value is ScanResult {
  if (!value || typeof value !== 'object') return false;
  const scanResult = value as Partial<ScanResult>;
  return (
    typeof scanResult.targetId === 'string' &&
    isCelestialObjectType(scanResult.targetType) &&
    typeof scanResult.timestamp === 'number' &&
    typeof scanResult.duration === 'number' &&
    typeof scanResult.success === 'boolean' &&
    typeof scanResult.coverage === 'number' &&
    typeof scanResult.newData === 'boolean'
  );
}

// Type guard for exploration event validation
export function isExplorationEvent(value: unknown): value is ExplorationEvent {
  if (!value || typeof value !== 'object') return false;
  const event = value as Partial<ExplorationEvent>;
  return (
    typeof event.id === 'string' &&
    typeof event.type === 'string' &&
    Object.values(ExplorationEventType).includes(event.type as ExplorationEventType) &&
    typeof event.timestamp === 'number' &&
    event.location !== undefined &&
    typeof event.location === 'object' &&
    'x' in event.location &&
    'y' in event.location
  );
}

// Best Practices for Exploration System Types
// 1. Always use enum values instead of string literals
// 2. Use type guards for runtime validation of exploration data
// 3. Include coordinates for all spatial objects
// 4. Store timestamps for all events and discoveries
// 5. Maintain consistent exploration status tracking
// 6. Use resource type enums for discovered resources
// 7. Include success/failure states for all operations
// 8. Document all enum values with clear descriptions
// 9. Use percentage values (0-100) for quantitative measurements
// 10. Implement proper inheritance for related object types

/**
 * Extended ship stats interface
 */
export interface ShipStats extends BaseStats {
  health: number;
  maxHealth: number;
  shield: number;
  maxShield: number;
  speed: number;
  maneuverability: number;
  cargo: number;
  weapons?: {
    primary: WeaponInstance;
    secondary?: WeaponInstance[];
    stats: CombatWeaponStats;
  };
}

/**
 * All possible ship status states - must use enum, not string literals
 */
export type ShipStatus =
  | 'idle'
  | 'ready'
  | 'engaging'
  | 'patrolling'
  | 'retreating'
  | 'disabled'
  | 'damaged';

/**
 * Ship loadout configuration
 */
export interface ShipLoadout {
  weapons: WeaponMount[];
  upgrades: string[];
  weaponTypes?: WeaponType[];
}

/**
 * Faction Ship Types - Used to strongly type faction ships
 */
export type SpaceRatsShipClass =
  | 'ratKing'
  | 'asteroidMarauder'
  | 'rogueNebula'
  | 'ratsRevenge'
  | 'darkSectorCorsair'
  | 'wailingWreck'
  | 'galacticScourge'
  | 'plasmaFang'
  | 'verminVanguard'
  | 'blackVoidBuccaneer';

export type LostNovaShipClass =
  | 'eclipseScythe'
  | 'nullsRevenge'
  | 'darkMatterReaper'
  | 'quantumPariah'
  | 'entropyScale'
  | 'voidRevenant'
  | 'scytheOfAndromeda'
  | 'nebularPersistence'
  | 'oblivionsWake'
  | 'forbiddenVanguard';

export type EquatorHorizonShipClass =
  | 'celestialArbiter'
  | 'etherealGalleon'
  | 'stellarEquinox'
  | 'chronosSentinel'
  | 'nebulasJudgement'
  | 'aetherialHorizon'
  | 'cosmicCrusader'
  | 'balancekeepersWrath'
  | 'eclipticWatcher'
  | 'harmonysVanguard';

export type FactionShipClass = SpaceRatsShipClass | LostNovaShipClass | EquatorHorizonShipClass;

/**
 * Faction configurations - Uses typesafe enum values
 */
export interface FactionConfig {
  id: FactionId;
  name: string;
  banner: {
    primaryColor: string;
    secondaryColor: string;
    sigil: string;
  };
  defaultBehavior: FactionBehaviorType;
  spawnConditions: {
    minThreatLevel: number;
    maxShipsPerFleet: number;
    territoryPreference: string[];
  };
}

/**
 * Faction Ship Interface - Extends the common ship with faction-specific properties
 */
export interface FactionShip extends CommonShip {
  id: string;
  faction: FactionId; // Must use FactionId type, not string
  class: FactionShipClass; // Must use FactionShipClass type, not string
  health: number;
  maxHealth: number;
  shield: number;
  maxShield: number;
  position: { x: number; y: number };
  rotation: number;
  target?: string;
  tactics: FactionBehaviorConfig;
  specialAbility?: {
    name: string;
    description: string;
    cooldown: number;
    active: boolean;
  };
}

/**
 * Type-safe configuration manager class
 */
export class TypeSafeConfigManager {
  private configItems: Map<string, ConfigItem> = new Map();
  private featureFlags: Map<string, FeatureFlag> = new Map();
  private configValues: Map<string, unknown> = new Map();
  private categories: Map<string, ConfigCategory> = new Map();
  private options: ConfigManagerOptions;
  private userContext: Record<string, unknown> = {};

  constructor(options: ConfigManagerOptions = {}) {
    this.options = {
      validateOnAccess: true,
      strictMode: false,
      logErrors: true,
      ...options,
    };
  }

  /**
   * Register a configuration item with type-safe schema
   */
  registerConfig<T extends z.ZodType>(config: ConfigItem<T>): void {
    if (this.configItems.has(config.key)) {
      throw new Error(`Config with key "${config.key}" is already registered`);
    }

    this.configItems.set(config.key, config);
    this.configValues.set(config.key, config.defaultValue);

    // Add to category if specified
    if (config.category && this.categories.has(config.category)) {
      const category = this.categories.get(config.category);
      if (category) {
        category.items.push(config);
      }
    }
  }

  /**
   * Get the value of a configuration item with type safety
   */
  get<T extends z.ZodType>(key: string): z.infer<T> | undefined {
    const config = this.configItems.get(key) as ConfigItem<T> | undefined;
    if (!config) {
      if (this.options?.strictMode) {
        throw new Error(`Config with key "${key}" is not registered`);
      }
      return undefined;
    }

    const value = this.configValues.get(key);

    // Validate on access if enabled
    if (this.options?.validateOnAccess) {
      const validation = config.schema.safeParse(value);
      if (!validation.success) {
        const errors = this.formatZodErrors(key, validation.error);

        if (this.options?.logErrors) {
          console.error(`Config validation error for "${key}":`, errors);
        }

        if (this.options?.onValidationError) {
          this.options?.onValidationError(errors);
        }

        if (this.options?.strictMode) {
          throw new Error(`Config validation failed for "${key}": ${errors[0]?.message}`);
        }

        return config.defaultValue;
      }
    }

    return value as z.infer<T>;
  }

  /**
   * Check if a feature flag is enabled
   */
  isFeatureEnabled(key: string): boolean {
    const feature = this.featureFlags.get(key);
    if (!feature) {
      return false;
    }

    // If the feature is disabled, always return false
    if (feature.status === FeatureStatus.DISABLED) {
      return false;
    }

    // If targeting is not specified, use the default value
    if (!feature.targeting) {
      return feature.defaultValue;
    }

    // Check user roles if specified
    if (feature.targeting.userRoles && feature.targeting.userRoles.length > 0) {
      const userRole = this.userContext.role as string;
      if (!userRole || !feature.targeting.userRoles.includes(userRole)) {
        return false;
      }
    }

    // Check environments if specified
    if (feature.targeting.environments && feature.targeting.environments.length > 0) {
      const env = this.userContext.environment as string;
      if (!env || !feature.targeting.environments.includes(env)) {
        return false;
      }
    }

    // Check percentage rollout if specified
    if (feature.targeting.percentageRollout !== undefined) {
      const userId = this.userContext.userId as string;
      if (!userId) {
        return feature.defaultValue;
      }

      // Get a hash of the user ID and feature key
      const hash = this.simpleHash(`${userId}:${key}`);
      const percentage = Math.abs(hash % 100);

      if (percentage >= feature.targeting.percentageRollout) {
        return false;
      }
    }

    return true;
  }
}

/**
 * Helper to create a typed config item
 */
export function createConfigItem<T extends z.ZodType>(
  key: string,
  schema: T,
  defaultValue: z.infer<T>,
  options: Omit<ConfigItem<T>, 'key' | 'schema' | 'defaultValue'> = { name: '', description: '' }
): ConfigItem<T> {
  return {
    key,
    schema,
    defaultValue,
    name: options?.name || key,
    description: options?.description ?? '',
    category: options?.category,
    tags: options?.tags ?? [],
    metadata: options?.metadata ?? {},
    isSecret: options?.isSecret || false,
    isRequired: options?.isRequired || false,
    source: options?.source,
  };
}

/**
 * React hook for type-safe configuration
 */
export function useTypedConfig<T extends z.ZodType>(
  configManager: TypeSafeConfigManager,
  key: string,
  defaultValue?: z.infer<T>
): z.infer<T> {
  const value = configManager.get<T>(key);
  return value !== undefined ? value : (defaultValue as z.infer<T>);
}

/**
 * React hook for feature flags
 */
export function useFeatureFlag(
  configManager: TypeSafeConfigManager,
  key: string,
  defaultValue = false
): boolean {
  return configManager.isFeatureEnabled(key) || defaultValue;
}

/**
 * Factory function to create type-safe API endpoints
 */
export function createConfigManager(options?: ConfigManagerOptions): TypeSafeConfigManager {
  return new TypeSafeConfigManager(options);
}

/**
 * Helper to create a type-safe config item
 */
export function createConfigItem<T extends z.ZodType>(
  key: string,
  schema: T,
  defaultValue: z.infer<T>,
  options: Omit<ConfigItem<T>, 'key' | 'schema' | 'defaultValue'> = { name: '', description: '' }
): ConfigItem<T> {
  return {
    key,
    schema,
    defaultValue,
    name: options?.name || key,
    description: options?.description ?? '',
    category: options?.category,
    tags: options?.tags ?? [],
    metadata: options?.metadata ?? {},
    isSecret: options?.isSecret || false,
    isRequired: options?.isRequired || false,
    source: options?.source,
  };
}

/**
 * React hook for type-safe configuration
 */
export function useTypedConfig<T extends z.ZodType>(
  configManager: TypeSafeConfigManager,
  key: string,
  defaultValue?: z.infer<T>
): z.infer<T> {
  const value = configManager.get<T>(key);
  return value !== undefined ? value : (defaultValue as z.infer<T>);
}

/**
 * React hook for feature flags
 */
export function useFeatureFlag(
  configManager: TypeSafeConfigManager,
  key: string,
  defaultValue = false
): boolean {
  return configManager.isFeatureEnabled(key) || defaultValue;
}

// Process incoming messages
self.addEventListener('message', async event => {
  const { taskId, type, data } = event.data;

  try {
    let result;

    switch (type) {
      case WorkerMessageType.PROCESS_CLUSTERING:
        result = processClusteringAlgorithm(data);
        break;
      case WorkerMessageType.PROCESS_PREDICTION:
        result = processPredictionModel(data);
        break;
      case WorkerMessageType.PROCESS_RESOURCE_MAPPING:
        result = processResourceMapping(data);
        break;
      case WorkerMessageType.TRANSFORM_DATA:
        result = transformData(data);
        break;
      case WorkerMessageType.DATA_SORTING:
        result = sortData(data);
        break;
      case WorkerMessageType.DATA_FILTERING:
        result = filterData(data);
        break;
      case WorkerMessageType.CALCULATE_STATISTICS:
        result = calculateStatistics(data);
        break;
      default:
        throw new Error(`Unknown task type: ${type}`);
    }

    // Return successful result
    self.postMessage({
      taskId,
      status: 'completed',
      result,
    });
  } catch (error) {
    // Return error information
    self.postMessage({
      taskId,
      status: 'error',
      error: {
        message: error.message,
        stack: error.stack,
      },
    });
  }
});

/**
 * Best Practices for Resource Types
 *
 * 1. Always use enum values directly: Prefer ResourceType.MINERALS over string literals
 * 2. Use ResourceTypeInfo for display: Get user-facing text from ResourceTypeInfo metadata
 * 3. Use computed property names for objects: Use [ResourceType.MINERALS] syntax for object keys
 * 4. Leverage type guards: Use isEnumResourceType and isStringResourceType for type safety
 * 5. Centralize conversion logic: Use the converter utilities instead of manual conversion
 * 6. Provide meaningful error messages: When handling invalid resource types, include context
 * 7. Use null coalescence for safety: When accessing resources, handle potential undefined values
 * 8. Use type annotations: Explicitly type variables and parameters for better IDE support
 * 9. Use color-related utilities for visualization: Maintain consistent visual representation
 * 10. Leverage ResourceStateClass for encapsulated state management with validation
 */

/**
 * Resource type visualization helpers
 */
export const ResourceVisualizationHelpers = {
  /**
   * Get a lighter color variant for highlights
   */
  getHighlightColor(resourceType: ResourceType): string {
    const baseColor = getResourceTypeColor(resourceType);
    // Implementation to create a lighter variant
    return baseColor;
  },

  /**
   * Get a darker color variant for shadows
   */
  getDarkColor(resourceType: ResourceType): string {
    const baseColor = getResourceTypeColor(resourceType);
    // Implementation to create a darker variant
    return baseColor;
  },

  /**
   * Format resource amount with the appropriate unit
   */
  formatAmount(amount: number, resourceType: ResourceType): string {
    // Resource-specific formatting logic
    return formatResourceAmount(amount);
  },

  /**
   * Generate CSS variables for a specific resource type
   */
  generateCssVars(resourceType: ResourceType): Record<string, string> {
    return {
      '--resource-color': getResourceTypeColor(resourceType),
      '--resource-highlight-color': this.getHighlightColor(resourceType),
      '--resource-dark-color': this.getDarkColor(resourceType),
    };
  },
};
```

## RECORD OF SHARED USER CONTEXT DATA

```typescript
/**
 * Record of shared user context data
 */
export interface SharedUserContext {
```

// ... remaining code ...

## API TYPE SAFETY (#api_type_safety)

```typescript
/**
 * Type-safe API client pattern with Zod schema validation
 */

/**
 * API endpoint definition with generic type parameters for request and response
 */
export interface ApiEndpoint<
  RequestType,
  ResponseType,
  RequestSchema extends z.ZodType<RequestType>,
  ResponseSchema extends z.ZodType<ResponseType>,
> {
  /** The API endpoint path */
  path: string;
  /** The HTTP method for this endpoint */
  method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';
  /** The Zod schema for validating request data */
  requestSchema: RequestSchema;
  /** The Zod schema for validating response data */
  responseSchema: ResponseSchema;
  /** Optional request headers */
  headers?: Record<string, string>;
  /** Optional query parameters */
  queryParams?: Record<string, string | number | boolean | undefined>;
  /** Whether to include credentials in the request */
  withCredentials?: boolean;
}

/**
 * API client options for configuration
 */
export interface ApiClientOptions {
  /** Base URL for all API requests */
  baseUrl: string;
  /** Default headers for all requests */
  defaultHeaders?: Record<string, string>;
  /** Default timeout in milliseconds */
  timeout?: number;
  /** Whether to include credentials in all requests by default */
  withCredentials?: boolean;
  /** Whether to throw errors on validation failures */
  throwOnValidationError?: boolean;
  /** Callback for handling request errors */
  onError?: (error: ApiError) => void;
}

/**
 * Typed error enum for different API error scenarios
 */
export enum ApiErrorType {
  NETWORK_ERROR = 'NETWORK_ERROR',
  TIMEOUT_ERROR = 'TIMEOUT_ERROR',
  REQUEST_VALIDATION_ERROR = 'REQUEST_VALIDATION_ERROR',
  RESPONSE_VALIDATION_ERROR = 'RESPONSE_VALIDATION_ERROR',
  SERVER_ERROR = 'SERVER_ERROR',
  NOT_FOUND_ERROR = 'NOT_FOUND_ERROR',
  UNAUTHORIZED_ERROR = 'UNAUTHORIZED_ERROR',
  FORBIDDEN_ERROR = 'FORBIDDEN_ERROR',
  BAD_REQUEST_ERROR = 'BAD_REQUEST_ERROR',
  UNKNOWN_ERROR = 'UNKNOWN_ERROR',
}

/**
 * Type-safe API error class
 */
export class ApiError extends Error {
  type: ApiErrorType;
  status?: number;
  endpoint: string;
  validationErrors?: z.ZodError;
  originalError?: Error;

  constructor(
    type: ApiErrorType,
    message: string,
    endpoint: string,
    status?: number,
    validationErrors?: z.ZodError,
    originalError?: Error
  ) {
    super(message);
    this.name = 'ApiError';
    this.type = type;
    this.status = status;
    this.endpoint = endpoint;
    this.validationErrors = validationErrors;
    this.originalError = originalError;
  }
}

/**
 * Type-safe API response with validation result
 */
export interface ApiResponse<T> {
  data: T;
  status: number;
  headers: Record<string, string>;
  validationResult: z.SafeParseReturnType<unknown, T>;
  isValid: boolean;
}

/**
 * Type-safe API client implementation
 */
export class TypeSafeApiClient {
  private baseUrl: string;
  private defaultHeaders: Record<string, string>;
  private timeout: number;
  private withCredentials: boolean;
  private throwOnValidationError: boolean;
  private onError?: (error: ApiError) => void;

  /**
   * Execute a type-safe API request with validation
   */
  async request<
    RequestType,
    ResponseType,
    RequestSchema extends z.ZodType<RequestType>,
    ResponseSchema extends z.ZodType<ResponseType>,
  >(
    endpoint: ApiEndpoint<RequestType, ResponseType, RequestSchema, ResponseSchema>,
    requestData?: RequestType
  ): Promise<ApiResponse<ResponseType>> {
    // Implementation details...
  }

  /**
   * Type-safe GET request
   */
  async get<ResponseType, ResponseSchema extends z.ZodType<ResponseType>>(
    path: string,
    responseSchema: ResponseSchema,
    options?: {
      queryParams?: Record<string, string | number | boolean | undefined>;
      headers?: Record<string, string>;
      withCredentials?: boolean;
    }
  ): Promise<ResponseType> {
    // Implementation details...
  }

  /**
   * Type-safe POST request
   */
  async post<
    RequestType,
    ResponseType,
    RequestSchema extends z.ZodType<RequestType>,
    ResponseSchema extends z.ZodType<ResponseType>,
  >(
    path: string,
    requestData: RequestType,
    requestSchema: RequestSchema,
    responseSchema: ResponseSchema,
    options?: {
      queryParams?: Record<string, string | number | boolean | undefined>;
      headers?: Record<string, string>;
      withCredentials?: boolean;
    }
  ): Promise<ResponseType> {
    // Implementation details...
  }
}

/**
 * Factory function to create type-safe API endpoints
 */
export function createApiEndpoint<
  RequestType,
  ResponseType,
  RequestSchema extends z.ZodType<RequestType>,
  ResponseSchema extends z.ZodType<ResponseType>,
>(config: ApiEndpoint<RequestType, ResponseType, RequestSchema, ResponseSchema>) {
  return config;
}

/**
 * Factory function to create a type-safe API client
 */
export function createApiClient(options: ApiClientOptions): TypeSafeApiClient {
  return new TypeSafeApiClient(options);
}

/**
 * Example usage: Creating a type-safe API endpoint with Zod validation
 */
// Define schemas
const userSchema = z.object({
  id: z.string(),
  name: z.string(),
  email: z.string().email(),
  age: z.number().min(0).optional(),
});

// Create endpoint definition
const getUserEndpoint = createApiEndpoint({
  path: '/api/users/:id',
  method: 'GET',
  requestSchema: z.object({ id: z.string() }),
  responseSchema: userSchema,
});

// Create client
const apiClient = createApiClient({ baseUrl: 'https://api.example.com' });

// Make type-safe request
async function getUser(id: string) {
  return apiClient.request(getUserEndpoint, { id });
}
```

## EVENT SYSTEM TYPE STANDARDS (#event_system)

```typescript
/**
 * EventCategory enum organizes event types into logical groups
 * Use enum instead of string literals for type safety
 */
export enum EventCategory {
  LIFECYCLE = 'lifecycle',
  RESOURCE = 'resource',
  ATTACHMENT = 'attachment',
  AUTOMATION = 'automation',
  STATUS = 'status',
  MISSION = 'mission',
  SUB_MODULE = 'sub-module',
  COMBAT = 'combat',
  TECH = 'tech',
  SYSTEM = 'system',
  THRESHOLD = 'threshold',
  EXPLORATION = 'exploration',
}

/**
 * EventType enum defines all possible event types in the system
 * Replaces string literal event types for type safety
 */
export enum EventType {
  // Lifecycle events
  MODULE_CREATED = 'MODULE_CREATED',
  MODULE_ATTACHED = 'MODULE_ATTACHED',
  MODULE_DETACHED = 'MODULE_DETACHED',
  MODULE_UPGRADED = 'MODULE_UPGRADED',
  MODULE_ACTIVATED = 'MODULE_ACTIVATED',
  MODULE_DEACTIVATED = 'MODULE_DEACTIVATED',
  MODULE_UPDATED = 'MODULE_UPDATED',
  MODULE_STATUS_CHANGED = 'MODULE_STATUS_CHANGED',
  MODULE_ALERT_ADDED = 'MODULE_ALERT_ADDED',
  MODULE_REMOVED = 'MODULE_REMOVED',

  // Resource events
  RESOURCE_PRODUCED = 'RESOURCE_PRODUCED',
  RESOURCE_CONSUMED = 'RESOURCE_CONSUMED',
  RESOURCE_TRANSFERRED = 'RESOURCE_TRANSFERRED',
  RESOURCE_PRODUCTION_REGISTERED = 'RESOURCE_PRODUCTION_REGISTERED',
  RESOURCE_PRODUCTION_UNREGISTERED = 'RESOURCE_PRODUCTION_UNREGISTERED',
  RESOURCE_CONSUMPTION_REGISTERED = 'RESOURCE_CONSUMPTION_REGISTERED',
  RESOURCE_CONSUMPTION_UNREGISTERED = 'RESOURCE_CONSUMPTION_UNREGISTERED',
  RESOURCE_FLOW_REGISTERED = 'RESOURCE_FLOW_REGISTERED',
  RESOURCE_FLOW_UNREGISTERED = 'RESOURCE_FLOW_UNREGISTERED',
  RESOURCE_SHORTAGE = 'RESOURCE_SHORTAGE',
  RESOURCE_UPDATED = 'RESOURCE_UPDATED',
  RESOURCE_DISCOVERED = 'RESOURCE_DISCOVERED',

  // Threshold events
  RESOURCE_THRESHOLD_CHANGED = 'RESOURCE_THRESHOLD_CHANGED',
  RESOURCE_THRESHOLD_TRIGGERED = 'RESOURCE_THRESHOLD_TRIGGERED',

  // Combat events
  COMBAT_UPDATED = 'COMBAT_UPDATED',

  // Game events
  GAME_STARTED = 'GAME_STARTED',
  GAME_PAUSED = 'GAME_PAUSED',
  GAME_RESUMED = 'GAME_RESUMED',
  GAME_STOPPED = 'GAME_STOPPED',

  // Exploration events
  EXPLORATION_SECTOR_DISCOVERED = 'EXPLORATION_SECTOR_DISCOVERED',
  EXPLORATION_SECTOR_SCANNED = 'EXPLORATION_SECTOR_SCANNED',
  EXPLORATION_ANOMALY_DETECTED = 'EXPLORATION_ANOMALY_DETECTED',
  EXPLORATION_RESOURCE_DETECTED = 'EXPLORATION_RESOURCE_DETECTED',

  // ... additional event types ...
}

/**
 * Maps event types to their categories for organization and filtering
 * Always use enum values, not string literals
 */
export const EVENT_CATEGORY_MAP: Record<EventType, EventCategory> = {
  // Lifecycle events
  [EventType.MODULE_CREATED]: EventCategory.LIFECYCLE,
  [EventType.MODULE_ATTACHED]: EventCategory.LIFECYCLE,
  [EventType.MODULE_DETACHED]: EventCategory.LIFECYCLE,
  [EventType.MODULE_UPGRADED]: EventCategory.LIFECYCLE,
  [EventType.MODULE_ACTIVATED]: EventCategory.LIFECYCLE,
  [EventType.MODULE_DEACTIVATED]: EventCategory.LIFECYCLE,
  [EventType.MODULE_UPDATED]: EventCategory.LIFECYCLE,
  [EventType.MODULE_STATUS_CHANGED]: EventCategory.LIFECYCLE,
  [EventType.MODULE_ALERT_ADDED]: EventCategory.LIFECYCLE,
  [EventType.MODULE_REMOVED]: EventCategory.LIFECYCLE,

  // Resource events
  [EventType.RESOURCE_PRODUCED]: EventCategory.RESOURCE,
  [EventType.RESOURCE_CONSUMED]: EventCategory.RESOURCE,
  [EventType.RESOURCE_TRANSFERRED]: EventCategory.RESOURCE,
  [EventType.RESOURCE_PRODUCTION_REGISTERED]: EventCategory.RESOURCE,
  [EventType.RESOURCE_PRODUCTION_UNREGISTERED]: EventCategory.RESOURCE,
  [EventType.RESOURCE_CONSUMPTION_REGISTERED]: EventCategory.RESOURCE,
  [EventType.RESOURCE_CONSUMPTION_UNREGISTERED]: EventCategory.RESOURCE,
  [EventType.RESOURCE_FLOW_REGISTERED]: EventCategory.RESOURCE,
  [EventType.RESOURCE_FLOW_UNREGISTERED]: EventCategory.RESOURCE,
  [EventType.RESOURCE_SHORTAGE]: EventCategory.RESOURCE,
  [EventType.RESOURCE_UPDATED]: EventCategory.RESOURCE,
  [EventType.RESOURCE_DISCOVERED]: EventCategory.RESOURCE,

  // Threshold events
  [EventType.RESOURCE_THRESHOLD_CHANGED]: EventCategory.THRESHOLD,
  [EventType.RESOURCE_THRESHOLD_TRIGGERED]: EventCategory.THRESHOLD,

  // Combat events
  [EventType.COMBAT_UPDATED]: EventCategory.COMBAT,

  // Game events
  [EventType.GAME_STARTED]: EventCategory.SYSTEM,
  [EventType.GAME_PAUSED]: EventCategory.SYSTEM,
  [EventType.GAME_RESUMED]: EventCategory.SYSTEM,
  [EventType.GAME_STOPPED]: EventCategory.SYSTEM,

  // Exploration events
  [EventType.EXPLORATION_SECTOR_DISCOVERED]: EventCategory.EXPLORATION,
  [EventType.EXPLORATION_SECTOR_SCANNED]: EventCategory.EXPLORATION,
  [EventType.EXPLORATION_ANOMALY_DETECTED]: EventCategory.EXPLORATION,
  [EventType.EXPLORATION_RESOURCE_DETECTED]: EventCategory.EXPLORATION,

  // ... additional mappings ...
};

/**
 * Base event interface that all events must implement
 */
export interface BaseEvent {
  type: EventType; // Must use enum, not string
  timestamp: number;
  moduleId: string;
  moduleType: ModuleType; // Must use enum, not string
  data?: Record<string, unknown>;
  [key: string]: unknown; // Add index signature for compatibility
}

/**
 * Resource production event data interface
 */
export interface ResourceProductionEventData {
  resourceType: ResourceType; // Must use enum, not string
  amount: number;
  source?: string;
  target?: string;
  production?: number;
  oldAmount?: number;
  newAmount?: number;
  delta?: number;
}

/**
 * Resource consumption event data interface
 */
export interface ResourceConsumptionEventData {
  resourceType: ResourceType; // Must use enum, not string
  amount: number;
  consumer?: string;
  consumption?: number;
  oldAmount?: number;
  newAmount?: number;
  delta?: number;
}

/**
 * Resource transfer event data interface
 */
export interface ResourceTransferEventData {
  resourceType: ResourceType; // Must use enum, not string
  amount: number;
  sourceId: string;
  targetId: string;
  transferTime?: number;
}

/**
 * Threshold triggered event data interface
 */
export interface ThresholdTriggeredEventData {
  resourceType: ResourceType; // Must use enum, not string
  resourceId: ResourceType; // Must use enum, not string
  thresholdType: 'critical' | 'low' | 'normal' | 'high' | 'maximum';
  currentValue: number;
  thresholdValue: number;
  direction: 'increasing' | 'decreasing';
}

/**
 * Type guard functions for event data validation
 */

/**
 * Type guard for resource update events
 */
export function isResourceUpdateEvent(
  event: ModuleEvent
): event is ModuleEvent & { data: { resourceAmounts: Partial<Record<ResourceType, number>> } } {
  return (
    event?.data !== undefined &&
    typeof event?.data === 'object' &&
    event?.data !== null &&
    'resourceAmounts' in event?.data &&
    typeof event?.data?.resourceAmounts === 'object' &&
    event?.data?.resourceAmounts !== null
  );
}

// Create schema definitions for our config items
const themeSchema = z.enum(['light', 'dark', 'system']);
const pageSizeSchema = z.number().int().min(5).max(100);
const apiEndpointSchema = z.string().url();

// Define our config items with schemas
const configItems = [
  createConfigItem('theme', themeSchema, 'system', {
    name: 'Theme',
    description: 'Application color theme',
    category: 'appearance',
    tags: ['ui', 'appearance'],
  }),
  createConfigItem('pageSize', pageSizeSchema, 20, {
    name: 'Page Size',
    description: 'Number of items to display per page',
    category: 'appearance',
    tags: ['ui', 'pagination'],
  }),
];

// Define feature flags
const featureFlags = [
  createFeatureFlag('newDashboard', false, {
    name: 'New Dashboard',
    description: 'Enable the new dashboard interface',
    status: FeatureStatus.PREVIEW,
    targeting: {
      userRoles: ['admin', 'beta-tester'],
      percentageRollout: 20,
    },
  }),
];

// Create a shared config manager instance
const configManager = createConfigManager({
  validateOnAccess: true,
  logErrors: true,
  onValidationError: errors => {
    console.warn('Config validation errors:', errors);
  },
});

// Initialize the config manager
categories.forEach(category => configManager.registerCategory(category));
configManager.registerConfigs(configItems);
featureFlags.forEach(flag => configManager.registerFeature(flag));

// In React components:
function MyComponent() {
  // Type-safe access to configuration with proper typing based on schema
  const theme = useTypedConfig(configManager, 'theme');

  // Feature flag checking
  const showNewDashboard = useFeatureFlag(configManager, 'newDashboard');

  return (
        <div className={`theme-${theme}`}>
      {showNewDashboard ? <NewDashboard /> : <ClassicDashboard />}
    </div>
  );
}

/**
 * Type guard for resource production events
 */
  export function isResourceProductionEvent(
  event: ModuleEvent
  ): event is ModuleEvent & { data: { resourceType: ResourceType; amount: number } } {
  return (
  event?.data !== undefined &&
  typeof event?.data === 'object' &&
  event?.data !== null &&
  'resourceType' in event?.data &&
  'amount' in event?.data &&
  typeof event?.data?.amount === 'number'
  );
  }

/**
* Type guard for resource consumption events
*/
  export function isResourceConsumptionEvent(
  event: ModuleEvent
  ): event is ModuleEvent & { data: { resourceType: ResourceType; amount: number } } {
  return (
  event?.data !== undefined &&
  typeof event?.data === 'object' &&
  event?.data !== null &&
  'resourceType' in event?.data &&
  'amount' in event?.data &&
  typeof event?.data?.amount === 'number'
  );
  }

/**
*Type guard for threshold triggered events
*/
  export function isThresholdTriggeredEventData(data: unknown): data is ThresholdTriggeredEventData {
  if (!data || typeof data !== 'object') return false;

const d = data as ThresholdTriggeredEventData;
return (
'resourceType' in d &&
'thresholdType' in d &&
'currentValue' in d &&
'thresholdValue' in d &&
'direction' in d &&
typeof d.currentValue === 'number' &&
typeof d.thresholdValue === 'number' &&
(d.direction === 'increasing' || d.direction === 'decreasing')
);
}

/**
* Event utility functions
* Get all event types for a specific category
*/
  export function getEventTypesByCategory(category: EventCategory): EventType[] {
  return Object.entries(EVENT*CATEGORY_MAP)
  .filter(([*, eventCategory]) => eventCategory === category)
  .map(([eventType, _]) => eventType as EventType);
  }

/**
* Convert a string to an EventType enum value
*/
  export function stringToEventType(eventTypeString: string): EventType | undefined {
  return Object.values(EventType).find(eventType => eventType === eventTypeString) as
  | EventType
  | undefined;
  }

/**
* Create a new event with the required properties
*/
  export function createEvent<T extends Record<string, unknown>>(
  type: EventType | string, // Prefer EventType enum over string
  moduleId: string,
  moduleType: ModuleType, // Must use ModuleType enum, not string
  data?: T
  ): BaseEvent {
  return {
  type: typeof type === 'string' ? type : type.toString(),
  moduleId,
  moduleType,
  timestamp: Date.now(),
  data,
  };
  }

/**
* Combat System Events
* The combat system uses standardized events with enum-based event types
*Combat event data interface
*/
  export interface CombatEventData {
  units: CombatUnit[];
  timestamp: number;
  position?: { x: number; y: number };
  state?: 'active' | 'paused' | 'completed';
  }

/**
*Combat unit status interface
*/
  export interface CombatUnitStatus {
  main: 'active' | 'disabled' | 'destroyed'; // Use string unions instead of raw strings
  secondary?: 'charging' | 'cooling' | 'repairing' | 'boosting'; // Use string unions
  effects: string[];
  }

/**
* Fleet formation interface
* Note: Two different interfaces exist in the codebase with swapped properties
*/
  export interface FleetFormation {
  type: 'offensive' | 'defensive' | 'balanced'; // Use string unions
  pattern: 'spearhead' | 'shield' | 'diamond' | 'arrow' | 'circle' | 'wedge' | 'line' | 'scattered'; // Use string unions
  spacing: number;
  facing: number;
  adaptiveSpacing: boolean;
  transitionSpeed: number;
  }

/**
* Fleet AI Result interface for visualization
*/
  export interface FleetAIResult {
  formationPatterns: string[];
  adaptiveAI: boolean;
  factionBehavior: string;
  visualFeedback?: {
  formationLines: {
  points: [number, number][];
  style: 'solid' | 'dashed'; // Use string union
  color: string;
  opacity: number;
  }[];
  };
  }

/**
 * Event subscription hook
 */
  export function useEventSubscription<T extends BaseEvent>(
  eventType: EventType,
  handler: (event: T) => void,
  options: {
  priority?: number;
  once?: boolean;
  } = {}
  ): void {
  useEffect(() => {
  const unsubscribe = eventSystem.subscribe(eventType.toString(), handler, options);
  return () => {
  unsubscribe();
  };
  }, [eventType, handler, options]);
  }

/**
 * Event publishing function
 */
  export function publishEvent<T extends BaseEvent>(event: T): void {
  eventSystem.publish(event);
  }

/**
 * Best Practices for Event System
 * 1.  Always use EventType enum instead of string literals
 * 2.  Use type guards for runtime validation of event data
 * 3.  Use proper type annotations for event data interfaces
 * 4.  Be consistent with event property names (e.g., resourceType vs resource)
 * 5.  Use meaningful event type names (VERB_NOUN format)
 * 6.  Organize events by categories using EventCategory enum
 * 7.  Use typed event handlers with proper event interfaces
 * 8.  Follow naming conventions for event type guards (is[EventType])
 * 9.  Explicitly handle unknown event types with fallbacks
 * 10. For resource-related events, always use ResourceType enum
 */
```

## VISUALIZATION AND UI TYPE STANDARDS (#ui_type_system)

```typescript
/**
 * D3 Visualization Type Safety
 * The codebase uses a structured approach to type safety in D3 visualizations
 */

/**
 * Generic Node type for D3 force simulations with proper typing
 */
export interface SimulationNodeDatum<T = unknown> extends d3.SimulationNodeDatum {
  id: string;
  x?: number;
  y?: number;
  fx?: number | null;
  fy?: number | null;
  // Store original data for type safety
  data?: T;
}

/**
 * Generic Link type for D3 force simulations with proper typing
 */
export interface SimulationLinkDatum<N extends d3.SimulationNodeDatum>
  extends d3.SimulationLinkDatum<N> {
  source: string | N;
  target: string | N;
  value?: number;
  // Additional fields can be added here
}

/**
 * Runtime node interface for D3 simulations
 * Used for type guards when accessing node coordinates
 */
export interface RuntimeSimulationNode {
  x: number;
  y: number;
  [key: string]: unknown;
}

/**
 * Safe accessor functions for D3 data to prevent type errors
 */
export const d3Accessors = {
  /**
   * Safely access the x coordinate with runtime validation
   */
  getX: (node: unknown): number => {
    if (
      node &&
      typeof node === 'object' &&
      'x' in node &&
      typeof (node as RuntimeSimulationNode).x === 'number'
    ) {
      return (node as RuntimeSimulationNode).x;
    }
    return 0; // Safe default
  },

  /**
   * Safely access the y coordinate with runtime validation
   */
  getY: (node: unknown): number => {
    if (
      node &&
      typeof node === 'object' &&
      'y' in node &&
      typeof (node as RuntimeSimulationNode).y === 'number'
    ) {
      return (node as RuntimeSimulationNode).y;
    }
    return 0; // Safe default
  },
};

/**
 * Type-safe data conversion utilities for D3
 */
export const d3Converters = {
  /**
   * Convert application data to D3-compatible format
   */
  dataPointsToD3Format: <T extends Record<string, unknown>>(dataPoints: DataPoint[]): T[] => {
    return dataPoints.map(point => {
      // Flatten the structure for D3
      const result = {
        id: point.id,
        type: point.type,
        name: point.name,
        x: point.coordinates.x,
        y: point.coordinates.y,
        ...point.properties,
      } as unknown as T;

      // Add metadata if it exists
      if (point.metadata) {
        Object.entries(point.metadata).forEach(([key, value]) => {
          if (!(key in result)) {
            (result as Record<string, unknown>)[`meta_${key}`] = value;
          }
        });
      }

      return result;
    });
  },
};

/**
 * UI Component Props Pattern
 * The codebase follows consistent patterns for component props
 */

/**
 * Example of resource display component props
 */
interface ResourceDisplayProps {
  /**
   * Type of resource to display - uses enum, not string
   */
  resourceType: ResourceType;

  /**
   * Initial resource amount
   */
  initialAmount?: number;

  /**
   * Class name for styling
   */
  className?: string;
}

/**
 * Event data interfaces follow the same pattern
 */
interface ResourceEventData {
  resourceType: ResourceType; // Must use enum, not string
  amount: number;
  source?: string;
  target?: string;
}

/**
 * Type guards for event data in UI components
 */
function isResourceEvent(event: ModuleEvent): event is ModuleEvent & { data: ResourceEventData } {
  return Boolean(
    event?.data &&
      typeof event?.data === 'object' &&
      'resourceType' in event?.data &&
      'amount' in event?.data
  );
}

/**
 * Component lifecycle hook for UI components to handle events
 */
useComponentLifecycle({
  eventSubscriptions: [
    {
      eventType: EventType.RESOURCE_PRODUCED, // Must use enum, not string
      handler: (event: ModuleEvent) => {
        if (isResourceEvent(event) && event?.data?.resourceType === resourceType) {
          setAmount(prev => prev + event?.data?.amount);
          setProductionRate(prev => prev + event?.data?.amount);
        }
      },
    },
    // Additional event subscriptions
  ],
});

/**
 * Visualization component props follow consistent patterns
 */
interface ScatterPlotProps {
  /**
   * Data for the visualization
   */
  data: DataPoint[] | Record<string, unknown>[];

  /**
   * Key to use for the x-axis
   */
  xAxisKey: string;

  /**
   * Key to use for the y-axis
   */
  yAxisKey: string;

  /**
   * Optional width of the chart
   */
  width?: number;

  /**
   * Optional height of the chart
   */
  height?: number;

  /**
   * Optional margin for the chart
   */
  margin?: { top: number; right: number; bottom: number; left: number };
}

/**
 * Best Practices for Visualization and UI Type Safety
 *
 * 1. Use Accessors for Coordinates: Always use d3Accessors.getX() and d3Accessors.getY() to safely access coordinates
 * 2. Convert Data with Utilities: Use d3Converters.dataPointsToD3Format<T>() to convert application data to D3 format
 * 3. Extend Base D3 Types: Extend the base D3 interfaces like SimulationNodeDatum instead of creating completely new ones
 * 4. Add Type Constraints: Use generic constraints (e.g., <T extends Record<string, unknown>>) to ensure type compatibility
 * 5. Test Edge Cases: Ensure accessor functions handle undefined, null, and malformed inputs gracefully
 * 6. Document Props Interfaces: Always create and document explicit interfaces for component props
 * 7. Use Enum Types for Events: Use EventType enum instead of string literals for event types
 * 8. Create Type Guards: Implement type guards for runtime validation of complex data structures
 * 9. Use Component Lifecycle Hooks: Use hooks like useComponentLifecycle for standardized event handling
 * 10. Prefer Strict Prop Types: Use required props instead of optional ones when a prop is essential for the component
 */

export function createLifecycleHook<TProps = Record<string, unknown>>(
  options: LifecycleOptions<TProps>
) {
  return (props: TProps): LifecycleResult => {
    // Current lifecycle phase
    const [phase, setPhase] = useState<LifecyclePhase>(LifecyclePhase.MOUNT);
    const [error, setError] = useState<Error | null>(null);

    // Performance tracking
    const performanceRef = useRef({
      mountTime: null as number | null,
      updateTime: null as number | null,
      lastRenderTime: null as number | null,
      averageRenderTime: null as number | null,
      renderCount: 0,
      renderStart: 0,
      totalRenderTime: 0,
    });

    // Previous props for comparison in onUpdate
    const prevPropsRef = useRef<TProps>(props);

    // Track component mounting
    const isMountedRef = useRef(false);

    // Helper to track performance if enabled
    const trackRenderPerformance = useCallback(() => {
      if (!options?.trackPerformance) return;

      const now = performance.now();
      const perf = performanceRef.current;

      // If renderStart is set, this is the end of a render
      if (perf.renderStart > 0) {
        const renderTime = now - perf.renderStart;
        perf.lastRenderTime = renderTime;
        perf.renderCount++;
        perf.totalRenderTime += renderTime;
        perf.averageRenderTime = perf.totalRenderTime / perf.renderCount;

        // Report slow renders
        if (options?.performanceThreshold && renderTime > options?.performanceThreshold) {
          console.warn(
            `Slow render detected: ${renderTime.toFixed(2)}ms in component using lifecycle hook`
          );
        }

        // Reset render start
        perf.renderStart = 0;
      } else {
        // Start of render
        perf.renderStart = now;
      }
    }, [options?.trackPerformance, options?.performanceThreshold]);

    // Error reporting function
    const reportError = useCallback(
      (err: Error) => {
        setError(err);
        setPhase(LifecyclePhase.ERROR);

        // Log to error service
        errorLoggingService.logError(err, ErrorType.RUNTIME, undefined, {
          componentHook: 'lifecycle',
          phase,
        });

        // Call onError handler if provided
        if (options?.onError) {
          try {
            options?.onError(err, phase, props);
          } catch (handlerError) {
            console.error('Error in onError handler:', handlerError);
          }
        }
      },
      [phase, props]
    );

    // Helper to safely execute lifecycle methods
    const safeExecute = useCallback(
      async (
        fn:
          | ((props: TProps) => void | Promise<void>)
          | ((prevProps: TProps, nextProps: TProps) => void | Promise<void>)
          | undefined,
        phase: LifecyclePhase,
        ...args: TProps[]
      ) => {
        if (!fn) return;

        const startTime = options?.trackPerformance ? performance.now() : 0;

        try {
          await (fn as (...params: TProps[]) => void | Promise<void>)(...args);

          // Track performance for specific phases
          if (options?.trackPerformance) {
            const elapsedTime = performance.now() - startTime;
            if (phase === LifecyclePhase.MOUNT) {
              performanceRef.current.mountTime = elapsedTime;
            } else if (phase === LifecyclePhase.UPDATE) {
              performanceRef.current.updateTime = elapsedTime;
            }
          }
        } catch (err) {
          // Report error
          reportError(err instanceof Error ? err : new Error(String(err)));
        }
      },
      [options?.trackPerformance, reportError]
    );

    // Handle mount
    useEffect(() => {
      trackRenderPerformance();

      // Set as mounted
      isMountedRef.current = true;

      // Execute mount lifecycle
      safeExecute(options?.onMount, LifecyclePhase.MOUNT, props);

      // Set phase to idle after mount
      setPhase(LifecyclePhase.IDLE);

      // Handle unmount
      return () => {
        isMountedRef.current = false;
        setPhase(LifecyclePhase.UNMOUNT);

        // Execute unmount lifecycle
        safeExecute(options?.onUnmount, LifecyclePhase.UNMOUNT, props);
      };
    }, []);

    // Handle updates based on dependencies
    useEffect(
      () => {
        // Skip first run (mount)
        if (!isMountedRef.current) return;

        trackRenderPerformance();

        // Skip if no update handler
        if (!options?.onUpdate) return;

        // Set phase to update
        setPhase(LifecyclePhase.UPDATE);

        // Execute update lifecycle
        safeExecute(
          options?.onUpdate as (prevProps: TProps, nextProps: TProps) => void | Promise<void>,
          LifecyclePhase.UPDATE,
          prevPropsRef.current,
          props
        );

        // Set phase back to idle after update
        setPhase(LifecyclePhase.IDLE);

        // Store current props as previous for next update
        prevPropsRef.current = props;
      },
      options?.updateDependencies ? options?.updateDependencies(props) : [props]
    );

    // Record render end
    useEffect(() => {
      trackRenderPerformance();
    });

    return {
      phase,
      error,
      performance: {
        mountTime: performanceRef.current.mountTime,
        updateTime: performanceRef.current.updateTime,
        lastRenderTime: performanceRef.current.lastRenderTime,
        averageRenderTime: performanceRef.current.averageRenderTime,
        renderCount: performanceRef.current.renderCount,
      },
      reportError,
    };
  };
}

/**
 * Specialized error boundary for data fetching components
 *
 * This error boundary is designed specifically for components that fetch data,
 * with specialized handling for network errors, API errors, etc.
 */
export const DataFetchingErrorBoundary: React.FC<DataFetchingErrorBoundaryProps> = ({
  children,
  fallback,
  retryOnError = false,
  fetchData,
  maxRetries = 3,
  dataSource,
  fetchMetadata,
  onError,
  suppressErrorLogging,
  metadata,
  ...props
}) => {
  // Track retry attempts
  const retryAttemptsRef = React.useRef(0);

  // Combine data-fetching-specific metadata with general metadata
  const combinedMetadata = {
    ...(dataSource && { dataSource }),
    retryAttempts: retryAttemptsRef.current,
    ...fetchMetadata,
    ...metadata,
  };

  // Custom error handler that can trigger retry
  const handleError = (error: Error, errorInfo: React.ErrorInfo) => {
    // Update retry information
    combinedMetadata.retryAttempts = retryAttemptsRef.current;

    // Call the original onError callback if provided
    if (onError) {
      onError(error, errorInfo);
    }

    // Automatically retry fetching if option is enabled
    if (retryOnError && fetchData && retryAttemptsRef.current < maxRetries) {
      retryAttemptsRef.current += 1;

      // Add exponential backoff
      const backoffDelay = Math.min(1000 * Math.pow(2, retryAttemptsRef.current), 30000);

      setTimeout(() => {
        fetchData().catch(e => {
          console.error('Error retrying data fetch:', e);
        });
      }, backoffDelay);
    }
  };

  // Reset retry counter when boundary resets
  const handleReset = () => {
    retryAttemptsRef.current = 0;

    // Immediately refetch if function is provided
    if (fetchData) {
      fetchData().catch(e => {
        console.error('Error fetching data after reset:', e);
      });
    }
  };

  // Custom fallback UI specific to data fetching
  const dataFetchingFallback = (error: Error, reset: () => void) => {
    // If a custom fallback is provided, use that
    if (fallback) {
      if (typeof fallback === 'function') {
        return fallback(error, reset);
      }
      return fallback;
    }

    // Determine if this is a network error
    const isNetworkError =
      error.message.includes('network') ||
      error.message.includes('fetch') ||
      error.message.includes('Failed to fetch') ||
      error.message.includes('Network request failed');

    // Determine if this is an API error (4xx/5xx)
    const isApiError =
      error.message.includes('API') ||
      error.message.includes('status code') ||
      /[45]\d\d/.test(error.message);

    // Create a more specific error title based on the error type
    let errorTitle = 'Data Loading Error';
    if (isNetworkError) {
      errorTitle = 'Network Error';
    } else if (isApiError) {
      errorTitle = 'API Error';
    }

    // Create action text for the retry button
    const actionText =
      retryAttemptsRef.current > 0
        ? `Retry Again (${retryAttemptsRef.current}/${maxRetries})`
        : 'Retry';

    return (
      <ErrorFallback
        error={error}
        resetErrorBoundary={() => {
          handleReset();
          reset();
        }}
        title={errorTitle}
        showDetails={process.env.NODE_ENV !== 'production'}
        actionText={fetchData ? actionText : undefined}
        onAction={
          fetchData
            ? () => {
                fetchData().catch(e => {
                  console.error('Error fetching data from action button:', e);
                });
              }
            : undefined
        }
      />
    );
  };

  return (
    <ErrorBoundary
      fallback={dataFetchingFallback}
      context="DataFetching"
      onError={handleError}
      suppressErrorLogging={suppressErrorLogging}
      metadata={combinedMetadata}
      {...props}
    >
      {children}
    </ErrorBoundary>
  );
};
```

## Error Boundary Usage Patterns

```typescript
// Basic usage with default fallback
<ErrorBoundary>
  <ComponentThatMightError />
</ErrorBoundary>

// Custom fallback component
<ErrorBoundary
  fallback={<CustomErrorDisplay message="Something went wrong with this component." />}
>
  <ComponentThatMightError />
</ErrorBoundary>

// Custom fallback with render function for more control
<ErrorBoundary
  fallback={(error, reset) => (
    <div>
      <h2>Error: {error.message}</h2>
      <button onClick={reset}>Try Again</button>
    </div>
  )}
>
  <ComponentThatMightError />
</ErrorBoundary>

// With error callback for logging/monitoring
<ErrorBoundary
  onError={(error, errorInfo) => {
    // Send to your error monitoring service
    errorMonitoringService.captureException(error, { extra: errorInfo });
  }}
>
  <ComponentThatMightError />
</ErrorBoundary>

// With resetKeys to automatically reset the error boundary when props change
<ErrorBoundary resetKeys={[resourceId, viewMode]}>
  <ResourceViewer resourceId={resourceId} viewMode={viewMode} />
</ErrorBoundary>

// Global error boundary at application root
<GlobalErrorBoundary isRoot={true}>
  <App />
</GlobalErrorBoundary>

// Specialized data fetching error boundary with retry
<DataFetchingErrorBoundary
  retryOnError={true}
  fetchData={fetchResourceData}
  maxRetries={3}
  dataSource="/api/resources"
>
  <ResourceDisplay />
</DataFetchingErrorBoundary>
```

## MINING SYSTEM (#mining_system)

### Core Architecture

The Mining System provides a comprehensive framework for resource extraction operations, including ship management, resource handling, and integration with the resource flow system.

```typescript
// src/managers/mining/MiningShipManagerImpl.ts

export class MiningShipManagerImpl extends TypedEventEmitter<MiningEvents> {
  private ships: Map<string, MiningShip> = new Map();
  private tasks: Map<string, MiningTask> = new Map();
  private nodeAssignments: Map<string, string> = new Map(); // nodeId -> shipId

  public registerShip(ship: MiningShip): void {
    // Implementation...
  }

  public unregisterShip(shipId: string): void {
    // Implementation...
  }

  private dispatchShipToResource(shipId: string, resourceId: string): void {
    // Implementation...
  }

  private recallShip(shipId: string): void {
    // Implementation...
  }

  public getResourceNodes(): Array<{
    id: string;
    type: ResourceType;
    position: Position;
    thresholds: { min: number; max: number };
  }> {
    // Implementation...
  }

  update(deltaTime: number): void {
    // Implementation...
  }
}
```

### Type Definitions

The Mining System includes comprehensive type definitions for mining operations.

```typescript
// src/types/mining/MiningTypes.ts

export interface MiningShip {
  id: string;
  name: string;
  type: 'rockBreaker' | 'voidDredger';
  status: 'idle' | 'mining' | 'returning' | 'maintenance';
  capacity: number;
  currentLoad: number;
  targetNode?: string;
  efficiency: number;
}

export interface MiningResource {
  id: string;
  name: string;
  type: ResourceType;
  abundance: number;
  distance: number;
  extractionRate: number;
  depletion: number;
  priority: number;
  thresholds: {
    min: number;
    max: number;
  };
}

export interface MiningExperience {
  baseAmount: number;
  bonusFactors: {
    resourceRarity: number; // Exotic > Gas > Mineral
    extractionEfficiency: number;
    resourceQuality: number; // Based on abundance
    distanceModifier: number; // Further = more XP
    techBonus: number; // Bonus from tech tree upgrades
  };
  totalXP: number;
  unlockedTech: string[];
}

export interface MiningTechBonuses {
  extractionRate: number;
  efficiency: number;
  storageCapacity?: number;
}
```

### Resource Integration

The Mining System integrates with the resource system to manage resource flow between mining operations and storage.

```typescript
// src/managers/mining/MiningResourceIntegration.ts

export class MiningResourceIntegration {
  private miningManager: MiningShipManagerImpl & EventEmitter<MiningEvents>;
  private thresholdManager: ResourceThresholdManager;
  private flowManager: ResourceFlowManager;
  private initialized: boolean = false;
  private miningNodes: Map<
    string,
    {
      id: string;
      type: ResourceType;
      position: Position;
      efficiency: number;
    }
  > = new Map();
  private transferHistory: ResourceTransfer[] = [];

  public initialize(): void {
    // Implementation...
  }

  public registerMiningNode(
    id: string,
    type: ResourceType,
    position: Position,
    efficiency: number = 1.0
  ): void {
    // Implementation...
  }

  private subscribeToMiningEvents(): void {
    // Implementation...
  }

  private createMiningThresholds(): void {
    // Implementation...
  }
}

interface ResourceTransfer {
  type: ResourceType;
  source: string;
  target: string;
  amount: number;
  timestamp: number;
}
```

### Event System

The Mining System uses a typed event system for communication with other systems.

```typescript
// src/managers/mining/MiningShipManagerImpl.ts

interface MiningEventMap {
  shipRegistered: { ship: MiningShip };
  shipUnregistered: { shipId: string };
  taskAssigned: { task: MiningTask };
  taskCompleted: { task: MiningTask };
  taskFailed: { task: MiningTask; reason: string };
  shipStatusChanged: { shipId: string; oldStatus: ShipStatus; newStatus: ShipStatus };
  resourceCollected: { shipId: string; resourceType: ResourceType; amount: number };
}

type MiningEvents = {
  [K in keyof MiningEventMap]: MiningEventMap[K];
};
```

### Task Management

The Mining System includes a task management system for assigning and tracking mining operations.

```typescript
// src/managers/mining/MiningShipManagerImpl.ts

enum TaskStatus {
  QUEUED = 'queued',
  IN_PROGRESS = 'in-progress',
  COMPLETED = 'completed',
  FAILED = 'failed',
}

interface MiningTask {
  id: string;
  shipId: string;
  nodeId: string;
  resourceType: ResourceType;
  priority: number;
  status: TaskStatus;
  startTime?: number;
  endTime?: number;
}
```

### Integration Patterns

The Mining System integrates with several other systems:

1. **Resource System**: Mining operations feed resources into the resource flow system
2. **Threshold System**: Mining operations are triggered by resource threshold violations
3. **Ship Behavior System**: Mining ships use behavior trees for movement and task execution
4. **Experience System**: Mining operations generate experience that unlocks tech upgrades
5. **Event System**: Mining operations emit events that other systems can respond to

Key integration patterns include:

- Flow node registration for connecting mining operations to the resource flow system
- Threshold-based automation for triggering mining operations when resources are low
- Task-based assignment for managing mining ship operations
- Event-based communication for notifying other systems of mining activities

## OFFICER SYSTEM (#officer_system)

### Core Architecture

The Officer System provides a comprehensive framework for managing ship officers, including recruitment, training, assignment, and progression with specialized skills.

```typescript
// src/managers/module/OfficerManager.ts

export class OfficerManager extends TypedEventEmitter<OfficerEvents> implements IOfficerManager {
  private officers: Map<string, Officer> = new Map();
  private squads: Map<string, Squad> = new Map();
  private trainingPrograms: Map<string, TrainingProgram> = new Map();
  private currentTier: OfficerTier = 1;
  private moduleId: string = 'academy'; // Default module ID for academy

  public hireOfficer(role: OfficerRole, specialization: OfficerSpecialization): Officer {
    // Implementation...
  }

  public startTraining(officerId: string, specialization: OfficerSpecialization): void {
    // Implementation...
  }

  public assignOfficer(officerId: string, assignmentId: string): void {
    // Implementation...
  }

  public createSquad(name: string, specialization: OfficerSpecialization): Squad {
    // Implementation...
  }

  public assignToSquad(officerId: string, squadId: string): void {
    // Implementation...
  }

  public addExperience(officerId: string, amount: number, activity?: string): void {
    // Implementation...
  }

  public update(deltaTime: number): void {
    // Implementation...
  }
}
```

### Type Definitions

The Officer System includes comprehensive type definitions for officer management.

```typescript
// src/types/officers/OfficerTypes.ts

export type OfficerRole = 'Squad Leader' | 'Captain';

export type OfficerSpecialization = 'War' | 'Recon' | 'Mining';

export type OfficerStatus = 'available' | 'training' | 'assigned';

export type OfficerTier = 1 | 2 | 3;

export interface OfficerSkills {
  combat: number;
  leadership: number;
  technical: number;
}

export interface Officer {
  id: string;
  name: string;
  portrait: string;
  level: number;
  xp: number;
  nextLevelXp: number;
  role: OfficerRole;
  status: OfficerStatus;
  specialization: OfficerSpecialization;
  skills: OfficerSkills;
  assignedTo?: string;
  trainingProgress?: number;
  traits: string[];
  stats: OfficerSkills;
}

export interface Squad {
  id: string;
  name: string;
  leader?: Officer;
  members: Officer[];
  specialization: OfficerSpecialization;
  bonuses: {
    combat: number;
    efficiency: number;
    survival: number;
  };
}

export interface TrainingProgram {
  id: string;
  officerId: string;
  specialization: OfficerSpecialization;
  progress: number;
  startTime: number;
  duration: number;
  bonuses: {
    xpMultiplier: number;
    skillGainRate: number;
  };
}
```

### Configuration

The Officer System includes configuration files for defining officer traits, training parameters, and squad behavior.

```typescript
// src/config/OfficerConfig.ts

export const OFFICER_TRAITS: OfficerTrait[] = [
  {
    id: 'natural_leader',
    name: 'Natural Leader',
    description: 'Born with exceptional leadership qualities',
    effects: {
      skills: {
        leadership: 2,
      },
      bonuses: {
        squadBonus: 0.1,
      },
    },
  },
  {
    id: 'combat_expert',
    name: 'Combat Expert',
    description: 'Highly skilled in combat tactics',
    effects: {
      skills: {
        combat: 2,
      },
      bonuses: {
        xpGain: 0.1,
      },
    },
  },
  // More traits...
];

export const TRAINING_CONFIG: TrainingConfig = {
  baseTime: 300000, // 5 minutes
  levelModifier: 0.1, // 10% faster per level
  specializationModifier: 0.2, // 20% faster for matching specialization
  xpMultiplier: 1.0,
  skillGainRate: 1.0,
};

export const SQUAD_CONFIG: SquadConfig = {
  maxSize: 5,
  bonusMultipliers: {
    combat: 0.05, // 5% per point
    efficiency: 0.05,
    survival: 0.025,
  },
  leadershipBonus: 0.1, // 10% per leadership point
};
```

### Progression System

The Officer System includes a sophisticated progression system that allows officers to develop over time.

```typescript
// src/managers/module/OfficerManager.ts

private calculateNextLevelXp(currentLevel: number): number {
  return Math.floor(100 * Math.pow(1.5, currentLevel - 1));
}

private improveSkills(officer: Officer): void {
  // Base skill improvements
  const improvements: OfficerSkills = {
    combat: 0,
    leadership: 0,
    technical: 0,
  };

  // Specialization-based improvements
  switch (officer.specialization) {
    case 'War':
      improvements.combat += 2;
      improvements.leadership += 1;
      break;
    case 'Recon':
      improvements.technical += 1;
      improvements.combat += 1;
      improvements.leadership += 1;
      break;
    case 'Mining':
      improvements.technical += 2;
      improvements.leadership += 1;
      break;
  }

  // Role-based improvements
  if (officer.role === 'Squad Leader') {
    improvements.leadership += 1;
  }

  // Apply improvements
  Object.entries(improvements).forEach(([skill, value]) => {
    officer.skills[skill as keyof OfficerSkills] += value;
  });

  // Update stats to match skills
  officer.stats = { ...officer.skills };
}
```

### Squad Management

The Officer System includes squad management functionality for organizing officers into effective teams.

```typescript
// src/managers/module/OfficerManager.ts

private updateSquadBonuses(squad: Squad): void {
  // Reset bonuses
  squad.bonuses = {
    combat: 0,
    efficiency: 0,
    survival: 0,
  };

  // Apply leader bonuses
  if (squad.leader) {
    const leaderBonus = this.calculateLeaderBonus(squad.leader);

    // Apply leader bonus to all categories
    squad.bonuses.combat += leaderBonus;
    squad.bonuses.efficiency += leaderBonus;
    squad.bonuses.survival += leaderBonus;
  }

  // Apply member bonuses
  squad.members.forEach(member => {
    const memberBonus = this.calculateMemberBonus(member);

    // Apply based on specialization
    switch (member.specialization) {
      case 'War':
        squad.bonuses.combat += memberBonus * 2; // Double bonus for matching specialization
        squad.bonuses.survival += memberBonus * 0.5;
        break;
      case 'Recon':
        squad.bonuses.combat += memberBonus * 0.5;
        squad.bonuses.efficiency += memberBonus * 2;
        break;
      case 'Mining':
        squad.bonuses.efficiency += memberBonus * 2;
        squad.bonuses.survival += memberBonus;
        break;
    }
  });
}
```

### Tech Tree Integration

The Officer System integrates with the tech tree to unlock advanced officer capabilities.

```typescript
// src/managers/module/OfficerManager.ts

private setupEventListeners(): void {
  techTreeManager.on('nodeUnlocked', ((event: TechNodeUnlockedEvent) => {
    if (event?.node.type === 'academy') {
      this.handleAcademyUpgrade(event?.node.tier as OfficerTier);
    }
  }) as (data: unknown) => void);

  moduleEventBus.subscribe('MODULE_ACTIVATED', (event: ModuleEvent) => {
    if (event?.moduleType === 'academy') {
      this.moduleId = event?.moduleId;
      this.emit('academyActivated', { moduleId: event?.moduleId });
    }
  });
}

private handleAcademyUpgrade(tier: OfficerTier): void {
  if (tier > this.currentTier) {
    this.currentTier = tier;
    this.emit('tierUpgraded', { tier });
    moduleEventBus.emit({
      type: 'MODULE_UPGRADED',
      moduleId: this.moduleId,
      moduleType: 'academy' as ModuleType,
      timestamp: Date.now(),
      data: { tier },
    });
  }
}
```

### Integration Patterns

The Officer System integrates with several other systems:

1. **Ship System**: Officers can be assigned to ships to provide stat bonuses
2. **Combat System**: Officers enhance combat capabilities of ships and squads
3. **Mining System**: Specialized officers improve mining efficiency
4. **Tech Tree System**: Academy upgrades unlock new officer capabilities
5. **Module System**: Officers are managed through the Academy module

Key integration patterns include:

- Event-based communication for officer progression and assignment
- Tech tree integration for tier and capability unlocks
- Modular academy implementation allowing installation in various structures
- Skill-based bonuses that modify ship and squad performance
- Typed events for consistent communication with other systems

## INITIALIZATION SYSTEM (#initialization_system)

### Core Architecture

The Initialization System provides a comprehensive framework for the application startup sequence, system registration, and integration between various game systems.

```typescript
// src/initialization/eventSystemInit.ts

export function initializeEventSystem(): () => void {
  console.warn('Initializing Event System...');

  // Initialize RxJS integration
  const rxjsCleanup = initializeRxJSIntegration();

  // Initialize system communications
  const eventSystemComm = getSystemCommunication('event-system');
  const _resourceSystemComm = getSystemCommunication('resource-system');
  const _moduleSystemComm = getSystemCommunication('module-system');

  // Register basic event handlers
  const unregisterSystemStartup = eventSystemComm.registerHandler('system-startup', message => {
    const payload = message.payload as { systemName: string };
    console.warn(`System startup message received: ${payload.systemName}`);
  });

  // Register game loop updates
  gameLoopManager.registerUpdate(
    'event-system-critical',
    (_deltaTime: number, _elapsedTime: number) => {
      // Process critical events
    },
    UpdatePriority.CRITICAL
  );

  // Return cleanup function
  return () => {
    console.warn('Cleaning up Event System...');

    // Unregister game loop updates
    gameLoopManager.unregisterUpdate('event-system-critical');
    gameLoopManager.unregisterUpdate('event-system-normal');

    // Unregister event handlers
    unregisterSystemStartup();
    unregisterResourceEvents();
    unregisterModuleEvents();

    // Stop the game loop
    gameLoopManager.stop();

    // Clean up RxJS integration
    rxjsCleanup();
  };
}
```

### Service Registration

The Initialization System includes a centralized service registration mechanism for type-safe service access throughout the application.

```typescript
// src/initialization/serviceRegistration.ts

export const REQUIRED_SERVICES = [
  'resourceManager',
  'thresholdManager',
  'flowManager',
  'storageManager',
  'costManager',
  'exchangeManager',
  'poolManager',
  'miningManager',
  'combatManager',
] as const;

export type ServiceName = (typeof REQUIRED_SERVICES)[number];

export function registerResourceManager(manager: ResourceManager): void {
  registerService('resourceManager', manager);
}

export function registerThresholdManager(manager: ResourceThresholdManager): void {
  registerService('thresholdManager', manager);
}

export function registerFlowManager(manager: ResourceFlowManager): void {
  registerService('flowManager', manager);
}

export function checkAllServicesAvailability(): Record<ServiceName, boolean> {
  const result = checkServicesAvailability(
    REQUIRED_SERVICES as unknown as Array<keyof Window & string>
  );
  return result as Record<ServiceName, boolean>;
}

export function getMissingServices(): ServiceName[] {
  const availability = checkAllServicesAvailability();
  return Object.entries(availability)
    .filter(([_, isAvailable]) => !isAvailable)
    .map(([name]) => name as ServiceName);
}

export function areAllServicesAvailable(): boolean {
  return getMissingServices().length === 0;
}
```

### System Integration

The Initialization System includes functionality to integrate various game systems with each other, facilitating cross-system communication.

```typescript
// src/initialization/gameSystemsIntegration.ts

export function integrateWithGameSystems(): () => void {
  console.warn('Integrating Event System with Game Systems...');

  // Get system communications
  const resourceSystemComm = getSystemCommunication('resource-system');
  const miningSystemComm = getSystemCommunication('mining-system');
  const combatSystemComm = getSystemCommunication('combat-system');
  const techSystemComm = getSystemCommunication('tech-system');

  // Initialize cleanup functions array
  const cleanupFunctions: Array<() => void> = [];

  // ===== Resource System Integration =====
  const resourceManager = getService<ResourceManager>('resourceManager');
  const thresholdManager = getService<ResourceThresholdManager>('thresholdManager');
  const flowManager = getService<ResourceFlowManager>('flowManager');
  const storageManager = getService<ResourceStorageManager>('storageManager');
  const costManager = getService<ResourceCostManager>('costManager');
  const exchangeManager = getService<ResourceExchangeManager>('exchangeManager');
  const poolManager = getService<ResourcePoolManager>('poolManager');

  if (resourceManager) {
    // Make sure all required managers are available
    if (
      thresholdManager &&
      flowManager &&
      storageManager &&
      costManager &&
      exchangeManager &&
      poolManager
    ) {
      // Create resource integration
      const resourceIntegration = new ResourceIntegration(
        resourceManager,
        thresholdManager,
        flowManager,
        storageManager,
        costManager,
        exchangeManager,
        poolManager
      );

      // Initialize resource integration
      resourceIntegration.initialize();

      // Register event handlers...
    }
  }

  // ===== Mining System Integration =====
  // Similar pattern for mining system...

  // ===== Combat System Integration =====
  // Similar pattern for combat system...

  // ===== Tech System Integration =====
  // Similar pattern for tech system...

  // Return cleanup function that calls all individual cleanup functions
  return () => {
    console.warn('Cleaning up Game Systems Integration...');
    cleanupFunctions.forEach(cleanup => cleanup());
  };
}
```

### Event Handling

The Initialization System provides a priority-based event handling system to manage event propagation during application startup and runtime.

```typescript
// src/initialization/eventSystemInit.ts

export function initializeGlobalEventHandlers(): () => void {
  console.warn('Initializing Global Event Handlers...');

  // Create a priority queue for processing events
  const eventQueue = new EventPriorityQueue<PriorityQueueEvent>(event => {
    console.warn(`Processing event: ${event?.type}`);
    // Process the event based on its type
    return Promise.resolve();
  });

  // Subscribe to all module events
  const unsubscribe = subscribeToAllEvents(event => {
    // Enqueue the event for processing
    eventQueue.enqueue({
      type: event?.type,
      priority: getPriorityForEventType(event?.type),
      data: event,
    });
  });

  // Return cleanup function
  return () => {
    console.warn('Cleaning up Global Event Handlers...');

    // Unsubscribe from all events
    unsubscribe();

    // Clear the event queue
    eventQueue.clear();
  };
}

function getPriorityForEventType(type: string): number {
  // Define priorities for different event types
  switch (type) {
    case 'ERROR_OCCURRED':
      return 0; // CRITICAL

    case 'RESOURCE_SHORTAGE':
    case 'MODULE_DETACHED':
      return 1; // HIGH

    case 'MODULE_CREATED':
    case 'MODULE_ATTACHED':
    case 'RESOURCE_PRODUCED':
    case 'RESOURCE_CONSUMED':
      return 2; // NORMAL

    case 'STATUS_CHANGED':
    case 'AUTOMATION_CYCLE_COMPLETE':
      return 3; // LOW

    case 'MISSION_PROGRESS_UPDATED':
      return 4; // BACKGROUND

    default:
      return 2; // Default to NORMAL priority
  }
}
```

### Complete Initialization

The Initialization System includes a master initialization function that orchestrates the entire application startup sequence.

```typescript
// src/initialization/eventSystemInit.ts

export function initializeCompleteEventSystem(): () => void {
  // Initialize all components
  const eventSystemCleanup = initializeEventSystem();
  const globalHandlersCleanup = initializeGlobalEventHandlers();
  const automationSystemCleanup = initializeAutomationSystem();
  const gameSystemsIntegrationCleanup = integrateWithGameSystems();

  // Return combined cleanup function
  return () => {
    gameSystemsIntegrationCleanup();
    automationSystemCleanup();
    globalHandlersCleanup();
    eventSystemCleanup();
  };
}
```

### Type-Safe Message Passing

The Initialization System provides type-safe message passing between systems through strongly-typed interfaces.

```typescript
// src/initialization/gameSystemsIntegration.ts

interface ResourceUpdatePayload {
  resourceType: ResourceType;
  [key: string]: unknown;
}

interface MiningUpdatePayload {
  shipId: string;
  [key: string]: unknown;
}

interface CombatUpdatePayload {
  type: string;
  [key: string]: unknown;
}

interface TechUpdatePayload {
  nodeId: string;
  node?: {
    category: string;
    [key: string]: unknown;
  };
  [key: string]: unknown;
}
```

### Integration Patterns

The Initialization System integrates with several other systems:

1. **Event System**: Provides event handlers and event propagation during startup
2. **Service Registry**: Manages the registration and availability of core services
3. **Game Loop**: Integrates with the game loop for regular updates during runtime
4. **Resource System**: Ensures resource managers are properly initialized and connected
5. **Module System**: Facilitates communication between modules and other systems

Key integration patterns include:

- Cleanup function return pattern for proper resource disposal
- Type-safe service registration and access
- Priority-based event handling for critical startup events
- Systematic integration between interdependent systems
- Centralized initialization orchestration for predictable startup sequence

## PAGES & NAVIGATION SYSTEM (#pages_system)

### Core Architecture

The Pages & Navigation System provides a robust framework for managing application routing, page layouts, and inter-page navigation with optimized component loading strategies.

```typescript
// src/App.tsx

// Lazy load components that aren't needed on initial render
const GameLayout = lazy(() =>
  import('./components/ui/GameLayout').then(module => ({ default: module.GameLayout }))
);

// Loading component
const LoadingComponent = () => (
  <div className="flex h-screen w-full flex-col items-center justify-center bg-gray-900 text-white">
    <div className="mb-4 h-12 w-12 animate-spin rounded-full border-4 border-blue-500 border-t-transparent"></div>
    <h2 className="mb-2 text-xl font-medium">Loading Game Components...</h2>
    <p className="text-gray-400">Preparing your galactic adventure</p>
  </div>
);

// Game initialization component implementing core layout and error handling
export default function App() {
  // Global error handling setup
  const handleGlobalError = (error: Error, errorInfo: React.ErrorInfo) => {
    errorLoggingService.logError({
      type: ErrorType.RUNTIME,
      severity: ErrorSeverity.HIGH,
      message: error.message,
      stack: error.stack,
      componentStack: errorInfo.componentStack,
    });
  };

  return (
    <GlobalErrorBoundary onError={handleGlobalError} fallback={<SystemRecoveryUI />}>
      <ThresholdProvider>
        <ResourceRatesProvider>
          <GameProvider>
            <ModuleProvider>
              <TooltipProvider>
                <GameInitializer>
                  <Suspense fallback={<LoadingComponent />}>
                    <GameLayoutWrapper />
                  </Suspense>
                </GameInitializer>
              </TooltipProvider>
            </ModuleProvider>
          </GameProvider>
        </ResourceRatesProvider>
      </ThresholdProvider>
    </GlobalErrorBoundary>
  );
}
```

### Page Structure

The Pages system follows a consistent structure for all game pages, with standardized layouts and component patterns.

```typescript
// src/pages/CombatSystemPage.tsx

export default function CombatSystemPage() {
  return (
    <div className="container mx-auto px-4 py-8">
      <header className="mb-8">
        <h1 className="mb-2 text-3xl font-bold text-white">Combat System</h1>
        <p className="text-gray-300">
          Advanced detection, tracking, and alert system for monitoring space objects and threats.
        </p>
      </header>

      <div className="mb-8">
        <CombatSystemDemo />
      </div>

      {/* Content sections */}
      <div className="mb-8 grid grid-cols-1 gap-6 md:grid-cols-2">
        {/* Feature section */}
        <div className="rounded-lg bg-gray-800 p-6">
          <h2 className="mb-4 text-xl font-bold text-white">System Features</h2>
          <ul className="space-y-2 text-gray-300">
            {/* Feature items */}
          </ul>
        </div>

        {/* Instructions section */}
        <div className="rounded-lg bg-gray-800 p-6">
          <h2 className="mb-4 text-xl font-bold text-white">Usage Instructions</h2>
          <div className="space-y-4 text-gray-300">
            {/* Instruction items */}
          </div>
        </div>
      </div>

      {/* Standard page footer */}
      <footer className="text-center text-sm text-gray-500">
        <p>Combat System v1.0 - Galactic Sprawl Project</p>
      </footer>
    </div>
  );
}
```

### Performance Optimizations

The Pages system implements several performance optimizations to ensure fast load times and smooth navigation.

```typescript
// src/App.tsx

// Code-splitting with lazy loading for improved initial load time
const GameLayout = lazy(() =>
  import('./components/ui/GameLayout').then(module => ({ default: module.GameLayout }))
);

// Performance tracking for page transitions and component rendering
const GameLayoutWrapper = () => {
  // Track component rendering performance
  useComponentProfiler('GameLayoutWrapper');

  // Enable performance profiling overlay in development mode
  useProfilingOverlay({ enabled: process.env.NODE_ENV === 'development' });

  return <GameLayout />;
};
```

### Integration Patterns

The Pages system seamlessly integrates with several key systems:

1. **Context System**: Pages access global state through React Context providers
2. **Error Handling**: Global error boundaries catch and process page-level errors
3. **Module System**: Pages interact with modules through context-based hooks
4. **Performance Monitoring**: Performance tracking is built into page components

Key integration patterns include:

```typescript
// src/pages/ResourceManagementPage.tsx

export default function ResourceManagementPage() {
  // Integration with context system
  const { resources } = useGameState();
  const moduleDispatch = useModuleDispatch();

  // Integration with performance monitoring
  useComponentProfiler('ResourceManagementPage');

  // Integration with module system
  const handleModuleActivation = (moduleId: string) => {
    moduleDispatch({
      type: ModuleActionType.SET_MODULE_STATUS,
      payload: {
        moduleId,
        status: ModuleStatus.ACTIVE,
      },
    });
  };

  return (
    // Page content
  );
}
```

### Page Types

The application implements several specialized page types:

1. **Management Pages**: For resource, colony, and converter management
   - Example: `ResourceManagementPage.tsx`, `ColonyManagementPage.tsx`
2. **System Pages**: For core gameplay systems
   - Example: `CombatSystemPage.tsx`
3. **Dashboard Pages**: For analytics and performance monitoring
   - Example: `PerformanceAnalysisDashboard.tsx`
4. **Demo Pages**: For showcasing specific components or features
   - Example: `ResourceRegistryDemo.tsx`

### Dashboard Organization

```typescript
// src/pages/PerformanceAnalysisDashboard.tsx

export default function PerformanceAnalysisDashboard() {
  return (
    <div className="container mx-auto grid grid-cols-12 gap-4 p-4">
      {/* Header spanning full width */}
      <div className="col-span-12 mb-4">
        <h1 className="text-2xl font-bold">Performance Analysis Dashboard</h1>
        <p className="text-sm text-gray-500">
          Comprehensive metrics and visualization of system performance
        </p>
      </div>

      {/* Main metrics panel - 8 columns */}
      <div className="col-span-8 rounded bg-gray-800 p-4">
        <h2 className="mb-2 text-xl">Real-time Metrics</h2>
        <PerformanceMetricsPanel />
      </div>

      {/* Side controls panel - 4 columns */}
      <div className="col-span-4 rounded bg-gray-800 p-4">
        <h2 className="mb-2 text-xl">Controls</h2>
        <PerformanceControlPanel />
      </div>

      {/* Bottom visualization panel - full width */}
      <div className="col-span-12 mt-4 rounded bg-gray-800 p-4">
        <h2 className="mb-2 text-xl">Performance Visualization</h2>
        <PerformanceVisualizer />
      </div>
    </div>
  );
}
```

### Navigation Flow

The application uses a consistent navigation pattern to move between pages:

1. **Main Navigation**: Core navigation menu with links to primary pages
2. **Sub-Navigation**: Context-specific navigation within system pages
3. **Module Navigation**: Navigation to module-specific pages through module interface
4. **Breadcrumb Navigation**: Hierarchical path tracking for nested pages

### Styling Patterns

The pages system uses consistent styling patterns throughout the application:

1. **TailwindCSS**: Utility classes for responsive layouts
2. **CSS Modules**: Component-specific styling with scoped selectors
3. **Theme Variables**: Consistent color scheme and typography
4. **Responsive Design**: Mobile-first approach with breakpoints

### Best Practices

The pages system follows several best practices:

1. **Code Splitting**: Lazy loading components to reduce initial bundle size
2. **Error Boundaries**: Each page wrapped in error boundary for graceful failure
3. **Performance Monitoring**: Built-in performance tracking for all pages
4. **Accessibility**: ARIA attributes and keyboard navigation support
5. **Type Safety**: TypeScript interfaces for all props and state

## INITIALIZATION SYSTEM (#initialization_system)

### Core Architecture

The Initialization System provides a structured framework for application startup, ensuring proper sequence of system registration, service availability, and component integration.

```typescript
// src/initialization/eventSystemInit.ts

/**
 * Initialize the complete event system with all sub-systems
 */
export function initializeCompleteEventSystem(): () => void {
  console.warn('Initializing Complete Event System...');

  // Initialize core event system
  const eventSystemCleanup = initializeEventSystem();

  // Initialize global event handlers
  const globalEventHandlersCleanup = initializeGlobalEventHandlers();

  // Initialize automation system
  const automationSystemCleanup = initializeAutomationSystem();

  // Integrate with game systems
  const gameSystemsCleanup = integrateWithGameSystems();

  // Return a combined cleanup function
  return () => {
    console.warn('Cleaning up Complete Event System...');

    // Clean up in reverse order of initialization
    gameSystemsCleanup();
    automationSystemCleanup();
    globalEventHandlersCleanup();
    eventSystemCleanup();
  };
}
```

### Startup Sequence

The initialization system follows a precise startup sequence to ensure dependencies are properly established before they are needed.

```typescript
// src/App.tsx (GameInitializer component)

const initializeGame = async () => {
  if (!isInitialized) {
    console.warn('Starting game initialization...');

    try {
      // Initialize resource manager
      console.warn('Initializing resource manager...');
      // ResourceManager is already initialized via useState

      // Register module configurations
      console.warn('Registering module configurations...');
      if (defaultModuleConfigs) {
        Object.values(defaultModuleConfigs).forEach(config => {
          if (config) {
            console.warn(`Registering module config: ${config.type}`);
            moduleManager.registerModuleConfig(config);
          }
        });
      } else {
        console.warn('defaultModuleConfigs is null or undefined');
      }

      // Register default buildings
      console.warn('Registering default buildings...');
      if (defaultMothership) {
        console.warn(`Registering mothership: ${defaultMothership.id}`);
        moduleManager.registerBuilding(defaultMothership);
        // Also register with ModuleContext...
      }

      // Initialize asset manager
      console.warn('Initializing asset manager...');
      await assetManager.initialize();

      // Register initial technologies
      console.warn('Registering initial technologies...');
      if (initialTechs) {
        initialTechs.forEach(tech => {
          if (tech) {
            console.warn(`Registering tech: ${tech.id}`);
            techTreeManager.registerNode(tech);
          }
        });
      }

      // Initialize event propagation service
      console.warn('Initializing event propagation service...');
      // Service registration and manager initialization...
    } catch (error) {
      console.error('Error during game initialization:', error);
      errorLoggingService.logError({
        type: ErrorType.INITIALIZATION,
        severity: ErrorSeverity.CRITICAL,
        message: `Game initialization failed: ${error instanceof Error ? error.message : String(error)}`,
        stack: error instanceof Error ? error.stack : undefined,
      });
    }
  }
};
```

### Service Registration

The Initialization System includes a robust service registration mechanism to make core services available throughout the application.

```typescript
// src/initialization/serviceRegistration.ts

/**
 * Services that are expected to be available to the application
 */
export const REQUIRED_SERVICES = [
  'resourceManager',
  'thresholdManager',
  'flowManager',
  'storageManager',
  'costManager',
  'exchangeManager',
  'poolManager',
  'miningManager',
  'combatManager',
] as const;

/**
 * Type for the names of required services
 */
export type ServiceName = (typeof REQUIRED_SERVICES)[number];

/**
 * Register the ResourceManager service
 *
 * @param manager The ResourceManager instance
 */
export function registerResourceManager(manager: ResourceManager): void {
  registerService('resourceManager', manager);
}

/**
 * Check the availability of all required services
 *
 * @returns Object with service availability status
 */
export function checkAllServicesAvailability(): Record<ServiceName, boolean> {
  const result = checkServicesAvailability(
    REQUIRED_SERVICES as unknown as Array<keyof Window & string>
  );
  return result as Record<ServiceName, boolean>;
}

/**
 * Get a list of missing required services
 *
 * @returns Array of missing service names
 */
export function getMissingServices(): ServiceName[] {
  const availability = checkAllServicesAvailability();
  return Object.entries(availability)
    .filter(([_, isAvailable]) => !isAvailable)
    .map(([name]) => name as ServiceName);
}
```

### System Integration

The Initialization System connects disparate systems via a comprehensive integration mechanism.

```typescript
// src/initialization/gameSystemsIntegration.ts

/**
 * Integrates the event system with existing game systems
 */
export function integrateWithGameSystems(): () => void {
  console.warn('Integrating Event System with Game Systems...');

  // Get system communications
  const resourceSystemComm = getSystemCommunication('resource-system');
  const miningSystemComm = getSystemCommunication('mining-system');
  const combatSystemComm = getSystemCommunication('combat-system');
  const techSystemComm = getSystemCommunication('tech-system');

  // Initialize cleanup functions array
  const cleanupFunctions: Array<() => void> = [];

  // ===== Resource System Integration =====

  // Get resource system instances using type-safe access pattern
  const resourceManager = getService<ResourceManager>('resourceManager');
  const thresholdManager = getService<ResourceThresholdManager>('thresholdManager');
  const flowManager = getService<ResourceFlowManager>('flowManager');
  const storageManager = getService<ResourceStorageManager>('storageManager');
  const costManager = getService<ResourceCostManager>('costManager');
  const exchangeManager = getService<ResourceExchangeManager>('exchangeManager');
  const poolManager = getService<ResourcePoolManager>('poolManager');

  if (resourceManager) {
    // Make sure all required managers are available
    if (
      thresholdManager &&
      flowManager &&
      storageManager &&
      costManager &&
      exchangeManager &&
      poolManager
    ) {
      // Create resource integration
      const resourceIntegration = new ResourceIntegration(
        resourceManager,
        thresholdManager,
        flowManager,
        storageManager,
        costManager,
        exchangeManager,
        poolManager
      );

      // Initialize resource integration
      resourceIntegration.initialize();

      // Register resource system event handlers
      // ...
    }
  }

  // Return a cleanup function that calls all registered cleanup functions
  return () => {
    console.warn('Cleaning up Game System integration...');
    cleanupFunctions.forEach(cleanup => cleanup());
  };
}
```

### Event System Initialization

The Initialization System establishes core event infrastructure to enable communication between systems.

```typescript
// src/initialization/eventSystemInit.ts

/**
 * Initialize the event system
 */
export function initializeEventSystem(): () => void {
  console.warn('Initializing Event System...');

  // Initialize RxJS integration
  const rxjsCleanup = initializeRxJSIntegration();

  // Initialize system communications
  const eventSystemComm = getSystemCommunication('event-system');
  const _resourceSystemComm = getSystemCommunication('resource-system');
  const _moduleSystemComm = getSystemCommunication('module-system');

  // Register basic event handlers
  const unregisterSystemStartup = eventSystemComm.registerHandler('system-startup', message => {
    const payload = message.payload as { systemName: string };
    console.warn(`System startup message received: ${payload.systemName}`);
  });

  // Register module system event handlers
  const unregisterModuleEvents = _moduleSystemComm.registerHandler(
    'module-status-change',
    message => {
      const payload = message.payload as { moduleId: string; status: string };
      console.warn(`Module status change: ${payload.moduleId} is now ${payload.status}`);

      // Notify the event system about important module status changes
      if (payload.status === 'critical' || payload.status === 'offline') {
        eventSystemComm.sendMessage('broadcast', 'system-alert', {
          level: payload.status === 'critical' ? 'warning' : 'error',
          message: `Module ${payload.moduleId} is ${payload.status}`,
          timestamp: Date.now(),
        });
      }
    }
  );

  // Return cleanup function
  return () => {
    console.warn('Cleaning up Event System...');
    // Cleanup implementations...
  };
}
```

### Module Framework Initialization

The Initialization System establishes the module framework that serves as the foundation for the game's modular architecture.

```typescript
// src/initialization/moduleFrameworkInit.ts

/**
 * Initialize the module framework
 */
export function initializeModuleFramework(): void {
  console.warn('[Initialization] Setting up module framework...');

  // Register event handlers for resource integration
  registerResourceIntegration();

  // Initialize module upgrade system
  initializeModuleUpgradePaths(moduleUpgradeManager);

  // Initialize module status tracking
  initializeStatusTracking();

  // Initialize sub-module system
  initializeSubModuleSystem();

  console.warn('[Initialization] Module framework initialized successfully.');
}

/**
 * Register event handlers for resource integration
 */
function registerResourceIntegration(): void {
  // Handle module activation/deactivation for resource consumption
  moduleEventBus.subscribe('MODULE_ACTIVATED' as ModuleEventType, event => {
    const module = moduleManager.getModule(event?.moduleId);
    if (!module) {
      return;
    }

    // Get module config
    const configs = getModuleConfigs();
    const config = configs[module.type];
    if (!config || !config.resourceConsumption) {
      return;
    }

    // Register resource consumption
    for (const [resourceType, amount] of Object.entries(config.resourceConsumption)) {
      resourceManager.registerConsumption(`module-${module.id}`, {
        type: resourceType as ResourceType,
        amount: amount as number,
        interval: 60000, // 1 minute
        required: false,
      });
    }
  });
}
```

### Automation System Initialization

The Initialization System sets up automation routines for core game systems.

```typescript
// src/initialization/automationSystemInit.ts

/**
 * Initialize the automation system
 */
export function initializeAutomationSystem(): () => void {
  console.warn('Initializing Automation System...');

  // Set the automation manager in the global automation manager
  // NOTE: Using 'any' here is necessary because automationManager is a private property
  // that needs to be set during initialization. This is a special case where we need
  // to access a private property from outside the class.
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  (globalAutomationManager as any).automationManager = automationManager;

  // Initialize the global automation manager
  globalAutomationManager.initialize();

  // Register default routines
  registerDefaultRoutines();

  // Emit initialization event
  moduleEventBus.emit({
    type: 'AUTOMATION_STARTED' as ModuleEventType,
    moduleId: 'automation-system',
    moduleType: 'resource-manager',
    timestamp: Date.now(),
    data: {
      status: 'initialized',
      routineCount: globalAutomationManager.getAllRoutines().length,
    },
  });

  // Return cleanup function
  return () => {
    console.warn('Cleaning up Automation System...');
    // Cleanup implementations...
  };
}
```

### Module Upgrade Initialization

```typescript
// src/initialization/moduleUpgradeInit.ts

/**
 * Initialize the module upgrade system
 */
export function initializeModuleUpgradeSystem(): void {
  console.warn('[Initialization] Setting up module upgrade system...');

  // Register upgrade paths
  initializeModuleUpgradePaths(moduleUpgradeManager);

  console.warn('[Initialization] Module upgrade system initialized successfully.');
}
```

### Error Handling

The Initialization System includes robust error handling mechanisms to prevent fatal errors during startup.

```typescript
// From documentation: CodeBase_Docs/changelog/CodeBase_Modules/Initial_Integration/Errors_And_Linting/Game_Initialization_Error.md

// In ResourceManager.ts:
if (config.defaultResourceLimits) {
  Object.entries(config.defaultResourceLimits).forEach(([type, limits]) => {
    this.initializeResource(type as ResourceType, limits.min, limits.max);
  });
} else {
  console.warn('[ResourceManager] Warning: defaultResourceLimits is null or undefined in config');
}

// In AssetManager.ts:
if (assets) {
  Object.entries(assets).forEach(([name, asset]) => {
    this.loadedAssets.set(name, asset as PIXI.Texture | PIXI.Spritesheet);
  });
  resolve();
} else {
  console.warn('[AssetManager] Warning: loaded assets is null or undefined');
  resolve(); // Still resolve to avoid blocking game initialization
}
```

### Integration Patterns

The Initialization System follows several key integration patterns:

1. **Type-safe Service Registration**: Services are registered and accessed using strongly-typed interfaces.
2. **Dependency Injection**: Services and managers are injected into systems that need them.
3. **Event-based Communication**: Systems communicate via typed event channels.
4. **Cleanup Function Pattern**: Initialization functions return cleanup functions for proper resource management.
5. **Defensive Programming**: Null checks and type guards prevent initialization failures.

These patterns collectively ensure a predictable and reliable application startup sequence with proper error handling and system integration.

## EXPLORATION SYSTEM EXTENSION (#exploration_system_extension)

### Core Architecture

The Exploration System Extension provides a unified framework for galaxy exploration, mapping, and data analysis with an emphasis on performance optimization and modular design.

```typescript
// src/components/exploration/unified/index.ts

/**
 * Unified Exploration System
 *
 * This file exports all components of the unified exploration system.
 */

// Export core components
export * from './core';

// Export context
export { ExplorationProvider, useExploration } from './context/ExplorationContext';

// Export system components
export {
  default as GalaxyExplorationSystem,
  type GalaxyExplorationSystemProps,
} from './system/GalaxyExplorationSystem';
```

### Context System

The Exploration Context provides a central state management system for all exploration data.

```typescript
// src/components/exploration/unified/context/ExplorationContext.tsx

/**
 * ExplorationContext
 *
 * A unified context for exploration data management.
 * This context provides a central repository for all exploration-related data,
 * including sectors, systems, anomalies, resources, and analysis results.
 */

// Action types
enum ActionType {
  SET_LOADING = 'SET_LOADING',
  SET_ERROR = 'SET_ERROR',
  SET_SECTORS = 'SET_SECTORS',
  SET_SYSTEMS = 'SET_SYSTEMS',
  SET_PLANETS = 'SET_PLANETS',
  SET_RESOURCES = 'SET_RESOURCES',
  SET_ANOMALIES = 'SET_ANOMALIES',
  SET_TRADE_ROUTES = 'SET_TRADE_ROUTES',
  SET_ACTIVITIES = 'SET_ACTIVITIES',
  SET_ANALYSIS_RESULTS = 'SET_ANALYSIS_RESULTS',
  ADD_SECTOR = 'ADD_SECTOR',
  UPDATE_SECTOR = 'UPDATE_SECTOR',
  ADD_SYSTEM = 'ADD_SYSTEM',
  UPDATE_SYSTEM = 'UPDATE_SYSTEM',
  ADD_PLANET = 'ADD_PLANET',
  UPDATE_PLANET = 'UPDATE_PLANET',
  ADD_ANOMALY = 'ADD_ANOMALY',
  UPDATE_ANOMALY = 'UPDATE_ANOMALY',
  ADD_RESOURCE = 'ADD_RESOURCE',
  UPDATE_RESOURCE = 'UPDATE_RESOURCE',
  ADD_ANALYSIS_RESULT = 'ADD_ANALYSIS_RESULT',
  ADD_ACTIVITY = 'ADD_ACTIVITY',
}

// Reducer function
function explorationReducer(state: ExplorationState, action: Action): ExplorationState {
  switch (action.type) {
    case ActionType.SET_LOADING:
      return { ...state, loading: action.payload };

    case ActionType.SET_ERROR:
      return { ...state, error: action.payload };

    case ActionType.SET_SECTORS:
      return { ...state, sectors: action.payload };

    // Additional cases for other action types...
  }
}

// Provider component
export const ExplorationProvider: React.FC<ExplorationProviderProps> = ({
  children,
  initialData,
  dataFetcher,
}) => {
  const [state, dispatch] = useReducer(
    explorationReducer,
    createEmptyExplorationState()
  );

  // Implementation details...

  // Provide context value to children
  const contextValue = useMemo<ExplorationContextType>(
    () => ({
      state,
      getSectors: () => state.sectors,
      getSectorById: (id) => state.sectors.find((sector) => sector.id === id),
      updateSector: (sector) => dispatch({
        type: ActionType.UPDATE_SECTOR,
        payload: sector
      }),
      // Additional context methods...
    }),
    [state]
  );

  return (
    <ExplorationContext.Provider value={contextValue}>
      {children}
    </ExplorationContext.Provider>
  );
};

// Hook for using exploration context
export function useExploration(): ExplorationContextType {
  const context = useContext(ExplorationContext);
  if (!context) {
    throw new Error('useExploration must be used within an ExplorationProvider');
  }
  return context;
}
```

### Core Components

The Exploration System includes core base components that provide foundational functionality for different aspects of exploration.

#### BaseMap Component

```typescript
// src/components/exploration/unified/core/BaseMap.tsx

/**
 * BaseMap Component
 *
 * A unified base component for map visualizations in the exploration system.
 * This component provides core map functionality including:
 * - Panning and zooming
 * - Entity selection and highlighting
 * - Layer rendering system for different map elements
 * - Configurable visual settings
 */

// Map layer types
export type MapLayerType =
  | 'background'
  | 'grid'
  | 'sectors'
  | 'systems'
  | 'resources'
  | 'anomalies'
  | 'tradeRoutes'
  | 'factionBorders'
  | 'selection'
  | 'labels'
  | 'custom';

// Map layer definition
export interface MapLayer {
  id: string;
  type: MapLayerType;
  zIndex: number;
  visible: boolean;
  render: MapLayerRenderer;
}

export const BaseMap: React.FC<BaseMapProps> = ({
  width = 800,
  height = 600,
  initialViewport,
  visualSettings,
  layers = [],
  selection = [],
  onEntityClick,
  onMapClick,
  onViewportChange,
  className,
  allowPanning = true,
  allowZooming = true,
  id,
}) => {
  // Implementation details...
};
```

#### BaseAnalysisVisualizer Component

```typescript
// src/components/exploration/unified/core/BaseAnalysisVisualizer.tsx

/**
 * BaseAnalysisVisualizer Component
 *
 * A unified base component for visualization of analysis results.
 * This component provides:
 * - Standardized rendering of different analysis types
 * - Support for multiple visualization strategies
 * - Common layout and controls for analysis visualizations
 * - Memory optimization for large datasets
 */

// Visualization types
export type VisualizationType =
  | 'bar'
  | 'line'
  | 'scatter'
  | 'pie'
  | 'radar'
  | 'heatmap'
  | 'network'
  | 'table'
  | 'custom';

export const BaseAnalysisVisualizer: React.FC<BaseAnalysisVisualizerProps> = ({
  analysis,
  width = 800,
  height = 400,
  defaultVisualizationType = 'bar',
  availableVisualizationTypes,
  visualizationRenderers,
  defaultOptions = {},
  showInsightsPanel = true,
  showSummary = true,
  showControls = true,
  onInsightClick,
  className,
  additionalContent,
}) => {
  // Implementation details...
};
```

### Galaxy Exploration System

The GalaxyExplorationSystem is the main component that integrates all exploration functionality.

```typescript
// src/components/exploration/unified/system/GalaxyExplorationSystem.tsx

/**
 * GalaxyExplorationSystem Component
 *
 * A unified system for exploring and analyzing the galaxy.
 * This component integrates mapping, data analysis, and anomaly investigation
 * into a single coherent interface.
 */

// View mode for the system
export type ViewMode =
  | 'map' // Main map view
  | 'data-table' // Tabular data view
  | 'analysis' // Analysis view
  | 'split-view'; // Split view with map and data

// GalaxyExplorationSystem Props
export interface GalaxyExplorationSystemProps {
  /** Initial view mode */
  initialViewMode?: ViewMode;

  /** Initial data table view */
  initialDataTableView?: DataTableView;

  /** Initial layout mode */
  initialLayoutMode?: LayoutMode;

  /** Initial map viewport */
  initialViewport?: Partial<MapViewport>;

  /** Initial map visual settings */
  initialVisualSettings?: Partial<MapVisualSettings>;

  /** Whether to allow changing visual settings */
  allowVisualSettingsChange?: boolean;

  /** Whether to allow changing layout */
  allowLayoutChange?: boolean;

  /** Initial selection */
  initialSelection?: MapSelection[];

  /** Custom class name */
  className?: string;

  /** Width of the component */
  width?: number | string;

  /** Height of the component */
  height?: number | string;

  /** Whether to show the toolbar */
  showToolbar?: boolean;

  /** Whether to show the status bar */
  showStatusBar?: boolean;

  /** Custom toolbar content */
  customToolbarContent?: React.ReactNode;

  /** Custom status bar content */
  customStatusBarContent?: React.ReactNode;

  /** Optional data fetcher for exploration data */
  dataFetcher?: () => Promise<ExplorationData>;

  /** Initial exploration data */
  initialData?: ExplorationData;
}

// Container component wrapping with context provider
export const GalaxyExplorationSystem: React.FC<GalaxyExplorationSystemProps> = ({
  initialData,
  dataFetcher,
  ...props
}) => {
  return (
    <ExplorationProvider initialData={initialData} dataFetcher={dataFetcher}>
      <GalaxyExplorationSystemInner {...props} />
    </ExplorationProvider>
  );
};
```

### Type System

The Exploration System uses a comprehensive type system to ensure type safety and consistency.

```typescript
// src/types/exploration/unified/ExplorationTypes.ts

/**
 * Unified Exploration Types
 *
 * This file contains all type definitions used across the exploration system.
 * It provides a single source of truth for exploration-related types,
 * eliminating duplication and ensuring consistency across components.
 */

/**
 * Base exploration entity with common properties
 */
export interface ExplorationEntity {
  id: string;
  name: string;
  discoveredAt: number;
  coordinates: Coordinates;
  explorationStatus: ExplorationStatus;
}

/**
 * Status of an exploration entity
 */
export enum ExplorationStatus {
  UNDISCOVERED = 'undiscovered',
  DETECTED = 'detected',
  SCANNED = 'scanned',
  ANALYZED = 'analyzed',
  FULLY_EXPLORED = 'fully_explored',
}

/**
 * Sector in the galaxy map
 */
export interface Sector extends ExplorationEntity {
  type: 'sector';
  systems: StarSystem[];
  resources: ResourceDeposit[];
  anomalies: Anomaly[];
  tradeRoutes: TradeRoute[];
  factionControl?: FactionControl;
  dangerLevel: DangerLevel;
  environmentalConditions: EnvironmentalCondition[];
  accessibility: number; // 0-100 scale
}

// Additional types for exploration data...
```

### Data Analysis Integration

The Exploration System integrates with data analysis capabilities to process exploration data and generate insights.

```typescript
// src/types/exploration/unified/ExplorationTypes.ts (relevant section)

/**
 * Analysis result from exploring and processing data
 */
export interface AnalysisResult {
  id: string;
  name: string;
  type: AnalysisType;
  createdAt: number;
  data: Record<string, unknown>;
  entityIds: string[];
  insights: Insight[];
  summary: string;
  confidence: number; // 0-100 scale
}

/**
 * Types of analysis that can be performed
 */
export enum AnalysisType {
  COMPOSITION = 'composition',
  ENERGY = ResourceType.ENERGY,
  SPATIAL = 'spatial',
  TEMPORAL = 'temporal',
  RESOURCE = 'resource',
  STRATEGIC = 'strategic',
  PREDICTIVE = 'predictive',
}

/**
 * Insights derived from analysis
 */
export interface Insight {
  id: string;
  title: string;
  description: string;
  significance: number; // 0-100 scale
  actionable: boolean;
  recommendedActions: string[];
}
```

### Visualization Patterns

The Exploration System provides multiple visualization options for exploring and analyzing data.

```typescript
// src/components/exploration/unified/core/BaseAnalysisVisualizer.tsx (relevant section)

/**
 * Visualization types supported by the system
 */
export type VisualizationType =
  | 'bar'
  | 'line'
  | 'scatter'
  | 'pie'
  | 'radar'
  | 'heatmap'
  | 'network'
  | 'table'
  | 'custom';

/**
 * Renderer function for visualization types
 */
export type VisualizationRenderer = (
  data: Record<string, unknown>,
  width: number,
  height: number,
  options?: VisualizationOptions
) => React.ReactNode;

/**
 * Options for configuring visualizations
 */
export interface VisualizationOptions {
  colors?: string[];
  animate?: boolean;
  showLegend?: boolean;
  showTooltip?: boolean;
  showGrid?: boolean;
  memoryOptimized?: boolean;
  xAxis?: string;
  yAxis?: string;
  [key: string]: unknown;
}
```

### Integration Patterns

The Exploration System integrates with several other systems in the application:

1. **Resource System**: Links exploration discoveries to the resource system for extraction and management
2. **Faction System**: Incorporates faction territories and influence in exploration data
3. **Event System**: Emits events for exploration activities and discoveries
4. **Module System**: Connects with ship modules required for exploration activities

Key integration examples:

```typescript
// Event integration example
moduleEventBus.emit({
  type: 'EXPLORATION_DISCOVERY' as ModuleEventType,
  moduleId: 'exploration-system',
  moduleType: 'resource-manager',
  timestamp: Date.now(),
  data: {
    discoveryType: 'RESOURCE',
    resourceType: ResourceType.MINERALS,
    coordinates: { x, y },
    amount: resourceAmount,
  },
});

// Resource system integration example
export interface ResourceDeposit {
  id: string;
  type: ResourceType;
  amount: number;
  quality: number; // 0-100 scale
  accessibility: number; // 0-100 scale
  coordinates: Coordinates;
  explorationStatus: ExplorationStatus;
  discoveredAt?: number;
}
```

### Performance Optimizations

The Exploration System implements several performance optimizations for handling large datasets and complex visualizations:

1. **Virtualized Rendering**: Uses virtualized lists for rendering large datasets
2. **Layer-based Rendering**: Map implements a layer system for efficient rendering
3. **View Mode Selection**: Allows switching between different view modes based on performance needs
4. **Memory Optimization Options**: Visualization components include memory optimization options
5. **Detail Level Control**: Adjustable detail levels for balancing visual fidelity and performance

```typescript
// Detail level setting
export enum DetailLevel {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
  ULTRA = 'ultra',
}

// Memory optimization example
const renderVisualization = () => {
  const renderer =
    visualizationRenderers?.[visualizationType] || defaultRenderers[visualizationType];
  if (!renderer) return null;

  const currentOptions = {
    ...defaultOptions,
    ...options,
    memoryOptimized:
      analysis.data &&
      Array.isArray(analysis.data.points) &&
      (analysis.data.points as any[]).length > 5000,
  };

  return renderer(analysis.data, width, height - controlsHeight, currentOptions);
};
```

### System Integration Examples

```typescript
// GalaxyExplorationSystem.tsx (integration with other systems)

useEffect(() => {
  // Subscribe to relevant events from other systems
  const unsubscribe = moduleEventBus.subscribe(
    ['RESOURCE_DISCOVERED', 'ANOMALY_DETECTED', 'SECTOR_SCANNED'] as EventType[],
    (event: StandardizedEvent) => {
      // Update exploration data based on event
      if (event.type === 'RESOURCE_DISCOVERED') {
        const { resourceType, coordinates, amount } = event.data as {
          resourceType: ResourceType;
          coordinates: Coordinates;
          amount: number;
        };

        // Add resource to exploration system
        const resource: ResourceDeposit = {
          id: `resource-${Date.now()}`,
          type: resourceType,
          amount,
          quality: Math.random() * 100,
          accessibility: Math.random() * 100,
          coordinates,
          explorationStatus: ExplorationStatus.DETECTED,
          discoveredAt: Date.now(),
        };

        // Update exploration context
        addResource(resource);
      }

      // Handle other event types...
    }
  );

  return () => {
    unsubscribe();
  };
}, []);
```

## AI SYSTEM (#ai_system)

### Core Architecture

The AI System provides a comprehensive framework for entity decision-making, particularly focused on faction behavior, fleet management, and adaptive combat tactics.

```typescript
// src/hooks/factions/useFleetAI.ts

export function useFleetAI(fleetId: string, factionId: FactionId) {
  const [aiState, setAIState] = useState<FleetAIState>({
    // Initial state properties...
  });

  const adaptiveAI = useAdaptiveAI(fleetId, factionId);
  const factionBehavior = useFactionBehavior(factionId);

  useEffect(() => {
    const combatManager = getCombatManager();
    const faction = factionManager.getFactionState(factionId);
    const updateInterval = setInterval(() => {
      const fleet = combatManager.getFleetStatus(fleetId);

      if (!fleet || !faction) {
        return;
      }

      // Update AI state based on current situation
      const newState = updateFleetBehavior(fleet, faction, aiState, adaptiveAI, factionBehavior);

      setAIState(newState);

      // Apply decisions to update unit positions
      applyFleetFormation(fleet, newState.formation);
    }, 1000);

    return () => clearInterval(updateInterval);
  }, [fleetId, factionId, aiState, adaptiveAI, factionBehavior]);

  // Return AI state and debug data
  return {
    aiState,
    debugData: {
      fleetStrength: aiState.fleetStrength,
      threatAssessment: aiState.threatAssessment,
      formation: aiState.formation,
      visualFeedback: aiState.visualFeedback,
    },
  };
}
```

### Decision Processes

The AI System implements complex decision-making processes through a combination of predefined rules and adaptive learning.

```typescript
// src/hooks/factions/useFleetAI.ts (Decision Process Implementation)

function updateFleetBehavior(
  fleet: { units: CombatUnit[] },
  faction: {
    fleetStrength: number;
    specialRules?: FleetAIState['specialRules'];
  },
  currentState: FleetAIState,
  adaptiveAI: ReturnType<typeof useAdaptiveAI>,
  factionBehavior: ReturnType<typeof useFactionBehavior>
): FleetAIState & { visualFeedback: VisualFeedback } {
  // Calculate current fleet strength
  const fleetStrength = calculateFleetStrength(fleet);

  // Calculate threat level in the environment
  const threatLevel = calculateThreatLevel(fleet, faction);

  // Determine if formation should change based on situation
  const shouldChange = shouldChangeFormation(fleet, currentState, adaptiveAI);

  // Initialize new state with current values
  const newState = {
    ...currentState,
    fleetStrength,
    threatAssessment: threatLevel,
  };

  // Determine combat style based on faction behavior and adaptive AI
  newState.combatStyle = determineCombatStyle(
    factionBehavior.combatStyle,
    adaptiveAI.adaptations.combatStyle === 'aggressive'
      ? 0.7
      : adaptiveAI.adaptations.combatStyle === 'defensive'
        ? 0.3
        : 0.5,
    fleetStrength
  );

  // Change formation if needed
  if (shouldChange) {
    newState.formation = selectNewFormation(fleet, currentState, adaptiveAI, factionBehavior);
    newState.lastFormationChange = Date.now();
  }

  // Update engagement parameters
  updateEngagementParameters(newState, fleet, adaptiveAI);

  // Calculate positions for units in formation
  const formationPositions = calculateFormationPositions(fleet, newState.formation);
  newState.currentPositions = formationPositions;

  // Apply hangar bonuses if available
  const hangarBonus = calculateHangarBonus(newState.hangarStatus, fleet);

  // Update visual feedback for debugging
  const visualFeedback = generateVisualFeedback(
    fleet,
    newState,
    formationPositions,
    hangarBonus.strengthMultiplier
  );

  return {
    ...newState,
    visualFeedback,
  };
}
```

### Adaptive Learning System

The AI System includes an adaptive learning mechanism that improves decision-making based on past performance.

```typescript
// src/hooks/factions/useAdaptiveAI.ts

export function useAdaptiveAI(unitId: string, factionId: string) {
  const [aiState, setAIState] = useState<AdaptiveAIState>({
    learningRate: 0.1,
    experienceLevel: 0,
    adaptations: {
      combatStyle: 'balanced',
      preferredRange: 'medium',
      formationPreference: 'flexible',
      retreatThreshold: 0.3,
    },
    performance: {
      winRate: 0.5,
      survivalRate: 0.7,
      damageEfficiency: 0.6,
      objectiveCompletion: 0.5,
    },
  });

  useEffect(() => {
    const combatManager = getCombatManager();
    const updateInterval = setInterval(() => {
      const unit = combatManager.getUnitStatus(unitId) as unknown as CombatUnit;
      const faction = factionManager.getFactionState(factionId) as unknown as FactionUnit;

      if (!unit || !faction) {
        return;
      }

      // Update AI adaptations based on performance
      const newState = updateAdaptations(unit, faction, aiState);
      setAIState(newState);
    }, 5000);

    return () => clearInterval(updateInterval);
  }, [unitId, factionId, aiState]);

  return aiState;
}

function updateAdaptations(
  unit: CombatUnit,
  faction: FactionUnit,
  currentState: AdaptiveAIState
): AdaptiveAIState {
  const newState = { ...currentState };

  // Update experience level
  newState.experienceLevel = calculateExperience(unit, currentState.experienceLevel);

  // Update performance metrics
  newState.performance = calculatePerformance(unit, faction);

  // Adapt combat behavior based on performance
  adaptCombatStyle(newState);
  adaptRangePreference(newState);
  adaptFormation(newState);
  adaptRetreatThreshold(newState);

  return newState;
}
```

### Debugging Tools

The AI System includes specialized debugging tools to visualize AI decision-making processes.

```typescript
// src/components/debug/AIDebugOverlay.tsx

interface DebugState {
  aiState: {
    behaviorState: string;
    targetId?: string;
    fleetStrength: number;
    threatLevel: number;
  };
  formation?: {
    type: string;
    spacing: number;
    facing: number;
  };
  position: { x: number; y: number };
}

interface AIDebugOverlayProps {
  debugStates: Record<string, DebugState>;
  visible: boolean;
  onToggleVisibility: () => void;
}

export function AIDebugOverlay({ debugStates, visible, onToggleVisibility }: AIDebugOverlayProps) {
  if (!visible) {
    return null;
  }

  return (
    <div className="fixed right-4 top-4 w-96 rounded-lg border border-gray-700 bg-gray-900/95 shadow-xl backdrop-blur-sm">
      <div className="p-4">
        <div className="mb-4 flex items-center justify-between">
          <div className="flex items-center space-x-2">
            <Brain className="h-5 w-5 text-cyan-400" />
            <h3 className="text-lg font-medium text-white">AI Debug</h3>
          </div>
          <button onClick={onToggleVisibility} className="text-gray-400 hover:text-white">
            <Target className="h-5 w-5" />
          </button>
        </div>

        <div className="max-h-96 space-y-4 overflow-y-auto">
          {Object.entries(debugStates).map(([id, state]) => (
            <div key={id} className="rounded-lg bg-gray-800/50 p-3">
              <div className="mb-2 flex items-center justify-between">
                <span className="text-sm font-medium text-gray-300">Unit {id}</span>
                <span
                  className={`rounded-full px-2 py-1 text-xs ${
                    state.aiState.behaviorState === 'engaging'
                      ? 'bg-red-900/50 text-red-400'
                      : state.aiState.behaviorState === 'retreating'
                        ? 'bg-yellow-900/50 text-yellow-400'
                        : 'bg-blue-900/50 text-blue-400'
                  }`}
                >
                  {state.aiState.behaviorState}
                </span>
              </div>

              {/* AI State visualization - strength, threat, target */}
              {/* Formation information visualization */}
              {/* Position information visualization */}
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}
```

### Faction Behavior System

The AI System includes comprehensive faction behavior management for non-player factions.

```typescript
// src/managers/factions/FactionBehaviorManager.ts

/**
 * Faction behavior manager class that uses standardized types and events
 */
export class FactionBehaviorManager extends BaseTypedEventEmitter<FactionEvents> {
  private factions: Map<FactionId, FactionState> = new Map();

  /**
   * Constructor
   */
  constructor() {
    super();
  }

  /**
   * Get a faction's state
   * @param factionId The ID of the faction
   * @returns The faction state, or undefined if not found
   */
  public getFactionState(factionId: FactionId): FactionState | undefined {
    return this.factions.get(factionId);
  }

  /**
   * Change a faction's behavior
   * @param factionId The ID of the faction
   * @param newBehavior The new behavior
   * @returns True if the behavior was changed, false if the faction was not found
   */
  public changeBehavior(factionId: FactionId, newBehavior: FactionBehaviorType): boolean {
    const faction = this.factions.get(factionId);
    if (!faction) {
      return false;
    }

    const oldBehavior = faction.behavior;
    faction.behavior = newBehavior;
    this.factions.set(factionId, faction);

    this.emit('faction:behavior-changed', {
      factionId,
      oldBehavior,
      newBehavior,
      timestamp: Date.now(),
    });

    return true;
  }

  /**
   * Update a faction's combat tactics
   * @param factionId The ID of the faction
   * @param newTactics The new combat tactics
   * @returns True if tactics were updated, false if faction not found
   */
  public updateCombatTactics(factionId: FactionId, newTactics: FactionCombatTactics): boolean {
    const faction = this.factions.get(factionId);
    if (!faction) {
      return false;
    }

    faction.combatTactics = newTactics;
    this.factions.set(factionId, faction);

    this.emit('faction:combat-tactics-changed', {
      factionId,
      tactics: newTactics,
      timestamp: Date.now(),
    });

    return true;
  }
}
```

### Integration Patterns

The AI System integrates with several other systems in the application:

1. **Combat System**: AI makes tactical decisions during combat
2. **Faction System**: AI behavior is influenced by faction relationships and traits
3. **Resource System**: AI considers resource availability when making decisions
4. **Officer System**: Officers provide bonuses and influence AI behavior
5. **Ship System**: AI adapts to available ship capabilities and formations

Key integration examples:

```typescript
// Combat system integration example (from useFleetAI.ts)
const combatManager = getCombatManager();
const fleet = combatManager.getFleetStatus(fleetId);

// Faction system integration example (from FactionBehaviorManager.ts)
this.emit('faction:behavior-changed', {
  factionId,
  oldBehavior,
  newBehavior,
  timestamp: Date.now(),
});

// Officer system integration example (from useFleetAI.ts)
function calculateCommandBonus(
  commandStructure?: CommandHierarchy,
  fleet?: { units: CombatUnit[] }
): number {
  if (!commandStructure || !fleet || !commandStructure.primaryOfficer) {
    return 1.0; // Default multiplier with no bonus
  }

  // Calculate bonuses based on officer rank and command radius
  // Implementation details...

  return bonusMultiplier;
}
```

### Formation System

The AI System includes a sophisticated formation management system for optimal unit positioning.

```typescript
// src/hooks/factions/useFleetAI.ts (Formation Implementation)

interface FleetFormation {
  type: 'line' | 'wedge' | 'circle' | 'scattered' | 'arrow' | 'diamond' | 'shield' | 'spearhead';
  spacing: number;
  facing: number;
  pattern: 'defensive' | 'offensive' | 'balanced';
  adaptiveSpacing: boolean;
  transitionSpeed?: number;
  subFormations?: {
    type: FleetFormation['type'];
    units: string[];
  }[];
}

function calculateFormationPositions(
  fleet: { units: CombatUnit[] },
  formation: FleetFormation
): Array<{ x: number; y: number }> {
  const positions: Array<{ x: number; y: number }> = [];
  const centerPos = getFleetCenter(fleet);
  const facing = formation.facing;
  const spacing = formation.spacing;
  const unitCount = fleet.units.length;

  // Formation type determines how units are positioned
  switch (formation.type) {
    case 'line':
      // Position units in a line perpendicular to facing direction
      // Implementation details...
      break;

    case 'wedge':
      // Position units in V formation pointing toward facing direction
      // Implementation details...
      break;

    case 'circle':
      // Position units in a circle around the center
      // Implementation details...
      break;

    // Additional formation types...
  }

  return positions;
}
```

## PERFORMANCE MONITORING SYSTEM (#performance_monitoring_system)

### Core Architecture

The Performance Monitoring System provides a comprehensive framework for monitoring, analyzing, and visualizing application performance across various device capabilities and session durations.

```typescript
// src/components/performance/DeviceCapabilityReport.tsx

/**
 * DeviceCapabilityReport
 *
 * A component that provides detailed segmentation of performance metrics
 * based on device capabilities. Shows performance patterns across different
 * device types, capabilities, and hardware configurations.
 */

interface DeviceCapabilityData {
  category: string;
  count: number;
  avgFps: number;
  avgLoadTime: number; // in ms
  avgMemoryUsage: number; // in MB
  avgCpuUsage: number; // percentage
  avgResponseTime: number; // in ms
  errorRate: number; // percentage
}

interface DeviceSegmentationData {
  // Device types
  deviceTypes: DeviceCapabilityData[];

  // Memory capabilities
  memoryCapabilities: DeviceCapabilityData[];

  // CPU capabilities
  cpuCapabilities: DeviceCapabilityData[];

  // GPU capabilities
  gpuCapabilities: DeviceCapabilityData[];

  // Screen sizes
  screenSizes: DeviceCapabilityData[];

  // Touch capabilities
  touchCapabilities: DeviceCapabilityData[];

  // Platform data
  platforms: DeviceCapabilityData[];

  // Browser engines
  browserEngines: DeviceCapabilityData[];
}
```

### Device Capability Analysis

The Performance Monitoring System includes comprehensive device capability analysis to optimize application performance across different hardware configurations.

```typescript
// src/components/performance/DeviceCapabilityReport.tsx (Component Implementation)

const DeviceCapabilityReport: React.FC = () => {
  const [segmentData, setSegmentData] = useState<DeviceSegmentationData | null>(null);
  const [activeSegment, setActiveSegment] = useState<string>('deviceTypes');
  const [selectedCategory, setSelectedCategory] = useState<string | null>(null);
  const { sessionData } = useSessionPerformance();

  // Load segmentation data
  useEffect(() => {
    const loadData = async () => {
      try {
        // In a real implementation, this would load data from a service
        // For now, using sample data
        setSegmentData(SAMPLE_DEVICE_DATA);
      } catch (error) {
        console.error('Error loading device capability data:', error);
      }
    };

    loadData();
  }, [sessionData]);

  // Handlers
  const handleSegmentChange = (segment: string) => {
    setActiveSegment(segment);
    setSelectedCategory(null);
  };

  const handleCategorySelect = (category: string) => {
    setSelectedCategory(category);
  };

  const handleBackToOverview = () => {
    setSelectedCategory(null);
  };

  // Rendering
  if (!segmentData) {
    return <div className="p-4 text-center">Loading device capability data...</div>;
  }

  // Render UI components based on segmentData
  return (
    <div className="p-4">
      {/* UI implementation */}
    </div>
  );
};
```

### Long Session Memory Tracking

The Performance Monitoring System includes specialized memory tracking for detecting and visualizing memory usage patterns over extended application sessions.

```typescript
// src/utils/performance/longsession/LongSessionMemoryTracker.ts

/**
 * LongSessionMemoryTracker
 *
 * A utility for tracking memory usage over extended application sessions.
 * It helps identify memory leaks and gradual performance degradation that
 * only become apparent with prolonged application use.
 *
 * Features:
 * - Periodic memory snapshots
 * - Memory growth trend analysis
 * - Leak detection with statistical analysis
 * - Timeline visualization data
 * - Memory allocation and garbage collection tracking
 */

export interface MemorySnapshot {
  /** Timestamp when the snapshot was taken (ms since epoch) */
  timestamp: number;

  /** Used JavaScript heap size (MB) */
  usedHeapSizeMB: number;

  /** Total allocated JavaScript heap size (MB) */
  totalHeapSizeMB: number;

  /** Maximum JavaScript heap size limit (MB) */
  heapLimitMB: number;

  /** DOM node count (if available) */
  domNodeCount?: number;

  /** Number of detached DOM nodes (if available) */
  detachedDomNodes?: number;

  /** Event listeners count (if available) */
  eventListenerCount?: number;

  /** Active timers count (if available) */
  timerCount?: number;

  /** Active animation frames (if available) */
  animationFrameCount?: number;

  /** Number of large arrays (>10K elements) in memory (if available) */
  largeArrayCount?: number;

  /** Number of active XHR objects (if available) */
  xhrCount?: number;

  /** Number of active fetch requests (if available) */
  fetchCount?: number;

  /** Custom metadata for this snapshot */
  metadata?: Record<string, unknown>;
}

export class LongSessionMemoryTracker {
  private snapshots: MemorySnapshot[] = [];
  private startTime: number;
  private latestAnalysis: MemoryTrendAnalysis | null = null;
  private options: MemoryTrackerOptions;
  private isTracking = false;

  constructor(options: MemoryTrackerOptions = {}) {
    // Initialize with default options
    this.options = {
      snapshotIntervalMs: 60000, // 1 minute
      maxSnapshots: 1440, // 24 hours of data at 1-minute intervals
      detailedMemoryInfo: true,
      trackDomNodes: true,
      trackDetachedNodes: true,
      attemptGarbageCollection: false,
      reportToEventBus: true,
      reportIntervalMs: 300000, // 5 minutes
      leakThresholdMBPerMinute: 0.5,
      loggingLevel: 2,
      ...options,
    };
    this.startTime = Date.now();

    // Detect browser support for memory APIs
    this.detectBrowserSupport();
  }

  public startTracking(): void {
    if (this.isTracking) {
      return;
    }

    this.isTracking = true;
    this.takeSnapshot(); // Take initial snapshot

    // Set up periodic snapshots
    this.snapshotIntervalId = window.setInterval(
      () => this.takeSnapshot(),
      this.options.snapshotIntervalMs
    );

    // Set up periodic reports to event bus if enabled
    if (this.options.reportToEventBus) {
      this.reportIntervalId = window.setInterval(
        () => this.sendMemoryReport(),
        this.options.reportIntervalMs
      );
    }
  }

  public analyzeMemoryTrend(): MemoryTrendAnalysis {
    // Perform memory trend analysis
    // Implementation details...
    return this.latestAnalysis!;
  }
}
```

### Performance Visualization

The Performance Monitoring System provides comprehensive visualization components for analyzing performance metrics.

```typescript
// src/components/performance/LongSessionMemoryVisualizer.tsx

/**
 * LongSessionMemoryVisualizer Component
 *
 * A React component for visualizing long session memory tracking data.
 * Displays memory usage over time, detects potential memory leaks,
 * and provides insights for performance optimization.
 */

interface LongSessionMemoryVisualizerProps {
  /** Instance of the memory tracker to visualize */
  memoryTracker?: LongSessionMemoryTracker;

  /** Memory snapshots to visualize (alternative to providing a tracker) */
  snapshots?: MemorySnapshot[];

  /** Memory trend analysis to display (alternative to providing a tracker) */
  analysis?: MemoryTrendAnalysis;

  /** Whether to auto-update the visualization */
  autoUpdate?: boolean;

  /** Update interval in milliseconds (if autoUpdate is true) */
  updateIntervalMs?: number;

  /** Width of the visualization */
  width?: number;

  /** Height of the visualization */
  height?: number;

  /** Whether to show detailed metrics */
  showDetailedMetrics?: boolean;

  /** Whether to show the memory chart */
  showMemoryChart?: boolean;

  /** Whether to show leak detection information */
  showLeakDetection?: boolean;

  /** Whether to display session markers */
  showSessionMarkers?: boolean;

  /** Callback when a leak is detected */
  onLeakDetected?: (analysis: MemoryTrendAnalysis) => void;
}

const LongSessionMemoryVisualizer: React.FC<LongSessionMemoryVisualizerProps> = ({
  memoryTracker,
  snapshots: propSnapshots,
  analysis: propAnalysis,
  autoUpdate = true,
  updateIntervalMs = 5000,
  width = 800,
  height = 400,
  showDetailedMetrics = true,
  showMemoryChart = true,
  showLeakDetection = true,
  showSessionMarkers = true,
  onLeakDetected,
}) => {
  // State and render implementation...

  const renderMemoryChart = () => {
    // Rendering implementation
  };

  // Return the component's JSX
  return (
    <div className="memory-visualizer">
      {/* Component UI */}
    </div>
  );
};
```

### Multi-tab Performance Analysis

The Performance Monitoring System includes tools for analyzing performance across multiple tabs to detect cross-tab impacts.

```typescript
// src/components/performance/MultitabPerformanceLauncher.tsx

/**
 * MultitabPerformanceLauncher
 *
 * A component that launches multiple tabs for performance testing.
 * Used to test how the application performs when multiple instances are running.
 */
export function MultitabPerformanceLauncher() {
  const [testStatus, setTestStatus] = useState<'idle' | 'running' | 'complete'>('idle');
  const [numberOfTabs, setNumberOfTabs] = useState<number>(3);
  const [tabOptions, setTabOptions] = useState<{
    scenario: string;
    duration: number;
    dataSize: 'small' | 'medium' | 'large';
    renderMode: 'canvas' | 'svg' | 'dom';
  }>({
    scenario: 'colony-management',
    duration: 60,
    dataSize: 'medium',
    renderMode: 'canvas',
  });
  const [results, setResults] = useState<any[]>([]);

  const handleStartTest = () => {
    setTestStatus('running');
    launchTabs();
  };

  const launchTabs = () => {
    // Implementation details...
  };

  // Return component UI
  return (
    <div className="p-4">
      {/* Component UI */}
    </div>
  );
}
```

### Optimization Techniques

The Performance Monitoring System implements numerous optimization techniques for improving application performance:

1. **Memory Management**:

   - Leak detection and prevention
   - Automatic garbage collection triggers
   - DOM node tracking

2. **Rendering Optimization**:

   - D3 performance optimizations
   - Batched updates for visualization
   - Animation frame management

3. **Resource Usage Analysis**:
   - CPU profiling
   - Memory analysis
   - Rendering performance tracking

```typescript
// src/utils/performance/D3PerformanceOptimizations.ts

/**
 * Optimizes D3 operations for large datasets
 * @param data Large dataset that needs optimization
 * @param options Optimization options
 */
export function optimizeD3Operations<T>(
  data: T[],
  options: {
    decimationFactor?: number;
    useBatchedUpdates?: boolean;
    useMemoryOptimizedAccessors?: boolean;
    useWebWorker?: boolean;
    useAnimationFrameThrottling?: boolean;
  } = {}
): {
  optimizedData: T[];
  draw: (selection: any) => void;
  cleanup: () => void;
} {
  // Implementation details...

  return {
    optimizedData,
    draw,
    cleanup,
  };
}
```

### Integration Patterns

The Performance Monitoring System integrates with several other systems:

1. **Event System**: Emits performance telemetry events
2. **Resource System**: Monitors resource usage impact on performance
3. **Module System**: Tracks performance of individual modules
4. **Visualization System**: Provides visualization components for performance data

Key integration examples:

```typescript
// Event system integration example (from LongSessionMemoryTracker.ts)
private sendMemoryReport(): void {
  if (!this.latestAnalysis) {
    return;
  }

  // Send detailed memory report to the event bus
  moduleEventBus.emit({
    type: 'MEMORY_STATUS_REPORT',
    moduleId: 'memory-tracker',
    moduleType: 'performance' as ModuleType,
    timestamp: Date.now(),
    data: {
      analysis: this.latestAnalysis,
      latestSnapshot: this.snapshots[this.snapshots.length - 1],
      sessionDuration: this.getSessionDurationMs(),
    },
  });
}

// Module system integration example
export function useModulePerformance(moduleId: string) {
  // Implementation details...

  return {
    metrics,
    startProfiling,
    stopProfiling,
    getReport,
  };
}
```

## SERVICES INTEGRATION (#services_integration)

### Core Architecture

The Services Integration system provides a comprehensive framework for managing service registration, dependency injection, service lifecycle, and error handling.

```typescript
// src/components/providers/ServiceProvider.tsx

import * as React from 'react';
import { useEffect, useState } from 'react';
import { ServiceRegistry } from '../../lib/services/ServiceRegistry';
import { anomalyDetectionService } from '../../services/AnomalyDetectionService';
import { apiService } from '../../services/APIService';
import { componentRegistryService } from '../../services/ComponentRegistryService';
import { errorLoggingService } from '../../services/ErrorLoggingService';
import { eventPropagationService } from '../../services/EventPropagationService';
import { realTimeDataService } from '../../services/RealTimeDataService';
import { recoveryService } from '../../services/RecoveryService';
import { webglService } from '../../services/WebGLService';
import { workerService } from '../../services/WorkerService';

interface ServiceProviderProps {
  children: React.ReactNode;
}

/**
 * Provider component that initializes and manages core services
 */
export function ServiceProvider({ children }: ServiceProviderProps) {
  const [isInitialized, setIsInitialized] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    const initializeServices = async () => {
      try {
        const registry = ServiceRegistry.getInstance();

        // Register core services with dependencies and priorities
        registry.register('errorLogging', () => errorLoggingService, {
          priority: 100, // High priority as other services depend on it
        });

        registry.register('recovery', () => recoveryService, {
          dependencies: ['errorLogging'],
          priority: 90,
        });

        // Register additional services...

        // Initialize all services
        await registry.initialize();
        setIsInitialized(true);
      } catch (err) {
        setError(err as Error);
      }
    };

    initializeServices();

    // Cleanup on unmount
    return () => {
      const registry = ServiceRegistry.getInstance();
      registry.dispose().catch(console.error);
    };
  }, []);

  // Render loading/error states or children when initialized
  if (error) {
    return (
      <div className="flex h-screen w-screen items-center justify-center bg-red-50">
        <div className="rounded-lg bg-white p-6 shadow-lg">
          <h2 className="mb-4 text-xl font-bold text-red-600">Service Initialization Error</h2>
          <p className="text-gray-700">{error.message}</p>
        </div>
      </div>
    );
  }

  if (!isInitialized) {
    return (
      <div className="flex h-screen w-screen items-center justify-center bg-gray-50">
        <div className="text-center">
          <div className="mb-4 h-8 w-8 animate-spin rounded-full border-4 border-blue-600 border-t-transparent"></div>
          <p className="text-gray-600">Initializing services...</p>
        </div>
      </div>
    );
  }

  return <>{children}</>;
}
```

### Service Registry

The Services Integration system includes a centralized registry for managing service instances and dependencies.

```typescript
// src/lib/services/ServiceRegistry.ts

/**
 * Configuration for a service registration
 */
export interface ServiceConfig {
  /**
   * An array of service names that this service depends on
   */
  dependencies?: string[];

  /**
   * Whether the service should be lazy initialized (on first request)
   * Default: false
   */
  lazyInit?: boolean;

  /**
   * Priority for initialization (higher values initialized first within same dependency level)
   * Default: 0
   */
  priority?: number;

  /**
   * Whether the service is required for the application to function
   * Default: true
   */
  required?: boolean;
}

/**
 * Service factory function type
 */
export type ServiceFactory = (dependencies: Record<string, BaseService>) => BaseService;

/**
 * Service registry that manages service lifecycle and dependencies
 */
export class ServiceRegistry {
  private static instance: ServiceRegistry;
  private services: Map<string, ServiceRegistration> = new Map();
  private initializing: Set<string> = new Set();

  private constructor() {}

  /**
   * Get the singleton instance of the service registry
   */
  public static getInstance(): ServiceRegistry {
    if (!ServiceRegistry.instance) {
      ServiceRegistry.instance = new ServiceRegistry();
    }
    return ServiceRegistry.instance;
  }

  /**
   * Register a new service with the registry
   */
  public register(
    name: string,
    factory: ServiceFactory,
    config: Partial<ServiceConfig> = {}
  ): void {
    if (this.services.has(name)) {
      throw new Error(`Service ${name} is already registered`);
    }

    const defaultConfig: ServiceConfig = {
      dependencies: [],
      lazyInit: false,
      priority: 0,
      required: true,
    };

    this.services.set(name, {
      name,
      factory,
      config: { ...defaultConfig, ...config },
      initialized: false,
    });
  }

  /**
   * Initialize all registered services in dependency order
   */
  public async initialize(): Promise<void> {
    const sortedServices = this.sortServicesByDependencies();

    for (const service of sortedServices) {
      if (!service.config.lazyInit) {
        await this.initializeService(service.name);
      }
    }
  }

  /**
   * Get a service instance by name
   */
  public async getService<T extends BaseService>(name: string): Promise<T> {
    const registration = this.services.get(name);
    if (!registration) {
      throw new Error(`Service ${name} is not registered`);
    }

    if (!registration.initialized) {
      await this.initializeService(name);
    }

    return registration.instance as T;
  }
}
```

### Base Service Pattern

The Services Integration system implements a consistent base service pattern for all services.

```typescript
// src/lib/services/BaseService.ts

/**
 * Interface for service metadata
 */
export interface ServiceMetadata {
  name: string;
  version: string;
  status: 'initializing' | 'ready' | 'error' | 'disposed';
  lastError?: {
    type: ErrorType;
    message: string;
    timestamp: number;
  };
  metrics?: Record<string, number>;
}

/**
 * Base interface that all services should implement
 */
export interface BaseService {
  /**
   * Initialize the service with optional dependencies
   */
  initialize(dependencies?: Record<string, unknown>): Promise<void>;

  /**
   * Dispose of any resources used by the service
   */
  dispose(): Promise<void>;

  /**
   * Get metadata about the service's current state
   */
  getMetadata(): ServiceMetadata;

  /**
   * Check if the service is ready to handle requests
   */
  isReady(): boolean;

  /**
   * Handle errors that occur within the service
   */
  handleError(error: Error, context?: Record<string, unknown>): void;
}

/**
 * Abstract base class that provides common service functionality
 * Extends the Singleton pattern to ensure only one instance exists
 */
export abstract class AbstractBaseService
  extends Singleton<AbstractBaseService>
  implements BaseService
{
  protected metadata: ServiceMetadata;

  protected constructor(name: string, version: string) {
    super();
    this.metadata = {
      name,
      version,
      status: 'initializing',
    };
  }

  async initialize(dependencies?: Record<string, unknown>): Promise<void> {
    try {
      await this.onInitialize(dependencies);
      this.metadata.status = 'ready';
    } catch (error) {
      this.metadata.status = 'error';
      this.handleError(error as Error);
      throw error;
    }
  }

  async dispose(): Promise<void> {
    try {
      await this.onDispose();
      this.metadata.status = 'disposed';
    } catch (error) {
      this.handleError(error as Error);
      throw error;
    }
  }
}
```

### Service Discovery

The Services Integration system provides mechanisms for discovering and accessing services throughout the application.

```typescript
// src/utils/services/ServiceAccess.ts

import { BaseService } from '../lib/services/BaseService';
import { ServiceRegistry } from '../lib/services/ServiceRegistry';

/**
 * Get a service instance by name
 * @param name The name of the service to retrieve
 * @returns A promise that resolves to the service instance
 */
export async function getServiceAsync<T extends BaseService>(name: string): Promise<T> {
  const registry = ServiceRegistry.getInstance();
  return registry.getService<T>(name);
}

/**
 * Get a service instance by name (synchronous version)
 * This should only be used when you are certain the service is already initialized
 * @param name The name of the service to retrieve
 * @returns The service instance, or undefined if not found or not initialized
 */
export function getService<T extends BaseService>(name: string): T | undefined {
  const registry = ServiceRegistry.getInstance();
  const registration = registry.getServiceRegistration(name);

  if (!registration || !registration.initialized || !registration.instance) {
    return undefined;
  }

  return registration.instance as T;
}

/**
 * Check if a service is available and initialized
 * @param name The name of the service to check
 * @returns True if the service is available and initialized, false otherwise
 */
export function isServiceAvailable(name: string): boolean {
  const service = getService(name);
  return !!service && service.isReady();
}
```

### Dependency Management

The Services Integration system includes robust dependency management to ensure services are initialized in the correct order.

```typescript
// src/lib/services/ServiceRegistry.ts (Dependency Management)

/**
 * Sort services by dependencies to create initialization order
 */
private sortServicesByDependencies(): ServiceRegistration[] {
  const sorted: ServiceRegistration[] = [];
  const visited = new Set<string>();
  const temporaryMark = new Set<string>();

  // Depth-first topological sort function
  const visit = (name: string, path: Set<string>) => {
    // Check for circular dependencies
    if (path.has(name)) {
      const pathArray = Array.from(path);
      pathArray.push(name);
      throw new Error(`Circular dependency detected: ${pathArray.join(' -> ')}`);
    }

    // Skip if already visited
    if (visited.has(name)) {
      return;
    }

    // Mark temporarily for cycle detection
    path.add(name);
    temporaryMark.add(name);

    // Visit dependencies first
    const registration = this.services.get(name);
    if (registration) {
      for (const dependency of registration.config.dependencies || []) {
        if (!this.services.has(dependency)) {
          throw new Error(`Service ${name} depends on missing service ${dependency}`);
        }
        visit(dependency, new Set(path));
      }
    }

    // Add to sorted list
    path.delete(name);
    temporaryMark.delete(name);
    visited.add(name);

    const service = this.services.get(name);
    if (service) {
      sorted.push(service);
    }
  };

  // Sort by priority first (higher priority initialized first)
  const servicesByPriority = Array.from(this.services.values()).sort(
    (a, b) => (b.config.priority || 0) - (a.config.priority || 0)
  );

  // Visit each service to build dependency-ordered list
  for (const service of servicesByPriority) {
    if (!visited.has(service.name)) {
      visit(service.name, new Set<string>());
    }
  }

  return sorted;
}
```

### Error Handling

The Services Integration system includes comprehensive error handling for service lifecycle events.

```typescript
// src/services/ErrorLoggingService.ts

// Error severity levels
export enum ErrorSeverity {
  LOW = 'low', // Non-critical, doesn't affect core functionality
  MEDIUM = 'medium', // Affects some functionality but application can still operate
  HIGH = 'high', // Major feature is broken
  CRITICAL = 'critical', // Application cannot continue normal operation
}

// Error types for categorization
export enum ErrorType {
  UNKNOWN = 'unknown', // Uncategorized errors
  VALIDATION = 'validation', // Input validation errors
  NETWORK = 'network', // Network-related errors
  RESOURCE = 'resource', // Resource-related errors (e.g. missing files)
  PERMISSION = 'permission', // Permission-related errors
  CONFIGURATION = 'configuration', // Configuration-related errors
  DEPENDENCY = 'dependency', // Dependency-related errors
  INITIALIZATION = 'initialization', // Initialization-related errors
  RUNTIME = 'runtime', // Runtime errors
  INTEGRATION = 'integration', // Integration-related errors
}

class ErrorLoggingServiceImpl extends AbstractBaseService {
  private errorLog: ErrorLogEntry[] = [];
  private maxLogSize = 1000;

  public logError(
    error:
      | Error
      | {
          type: ErrorType;
          severity: ErrorSeverity;
          message: string;
          stack?: string;
        },
    metadata?: Record<string, unknown>
  ): void {
    // Log error implementation...
  }

  protected async onInitialize(): Promise<void> {
    // Setup global error listeners for uncaught exceptions
    // Implementation details...
  }
}
```

### Integration Patterns

The Services Integration system integrates with several other systems in the application:

1. **Component System**: Provides services to React components via context
2. **Error Handling System**: Centralizes error management for services
3. **Event System**: Enables service event propagation
4. **Performance Monitoring**: Tracks service performance metrics

Key integration examples:

```typescript
// React component integration example
import { useService } from '../hooks/services/useService';

function MyComponent() {
  const { service, isLoading, error } = useService('apiService');

  if (isLoading) {
    return <div>Loading service...</div>;
  }

  if (error || !service) {
    return <div>Error loading service: {error?.message || 'Unknown error'}</div>;
  }

  return (
    <div>
      <button onClick={() => service.fetchData()}>Fetch Data</button>
    </div>
  );
}

// Service implementation with performance monitoring
class APIServiceImpl extends AbstractBaseService {
  protected async onInitialize(dependencies?: Record<string, unknown>): Promise<void> {
    // Track performance metrics
    this.metadata.metrics = {
      requestCount: 0,
      averageResponseTime: 0,
      errorRate: 0,
    };

    // Subscribe to performance events
    const performanceMonitor = dependencies?.['performanceMonitor'] as PerformanceMonitorService;
    if (performanceMonitor) {
      performanceMonitor.registerService(this.metadata.name);
    }
  }

  async fetchData(): Promise<any> {
    const startTime = performance.now();

    try {
      this.metadata.metrics!.requestCount++;
      // Implementation details...

      const endTime = performance.now();
      this.updateResponseTime(endTime - startTime);

      return result;
    } catch (error) {
      this.metadata.metrics!.errorRate =
        (this.metadata.metrics!.errorRate * (this.metadata.metrics!.requestCount - 1) + 1) /
        this.metadata.metrics!.requestCount;

      this.handleError(error as Error);
      throw error;
    }
  }
}
```

## REACT INTEGRATION PATTERNS (#react_integration)

### Component Lifecycle Management

The application implements sophisticated component lifecycle management patterns to ensure optimal component initialization, updates, and cleanup.

```typescript
// src/hooks/ui/useComponentLifecycle.ts

import { useEffect, useLayoutEffect, useRef } from 'react';

/**
 * Hook for managing component lifecycle with precise timing
 *
 * @param componentId Unique identifier for the component
 * @param options Configuration options for lifecycle management
 */
export function useComponentLifecycle<T>(
  componentId: string,
  options: {
    onMount?: (componentRef: React.RefObject<T>) => void | (() => void);
    onBeforeUpdate?: () => void;
    onAfterUpdate?: () => void;
    onUnmount?: () => void;
    runEffectOnMount?: boolean;
    runEffectOnUpdate?: boolean;
    dependencies?: any[];
    registerWithManager?: boolean;
  } = {}
): React.RefObject<T> {
  // Create a ref for the component
  const componentRef = useRef<T>(null);

  // Execute mount effect
  useEffect(() => {
    // Call onMount handler
    const cleanup = options.onMount?.(componentRef);

    // Return cleanup function
    return () => {
      // Call onUnmount handler
      options.onUnmount?.();

      // Call cleanup function from onMount
      if (cleanup) {
        cleanup();
      }
    };
  }, []); // Empty dependency array means this runs only on mount and unmount

  // Execute update effects
  useLayoutEffect(() => {
    // Skip first render if not supposed to run on mount
    if (!options.runEffectOnMount && !useComponentLifecycle.isUpdated.current) {
      useComponentLifecycle.isUpdated.current = true;
      return;
    }

    // Call before update handler
    options.onBeforeUpdate?.();

    // Return function that calls after update handler
    return () => {
      options.onAfterUpdate?.();
    };
  }, options.dependencies || []);

  return componentRef;
}

// Static property to track updates
useComponentLifecycle.isUpdated = { current: false };
```

### State Management Approaches

The application implements multiple state management approaches depending on complexity and scope.

#### 1. Context-based State Management with Reducer Pattern

```typescript
// src/contexts/GameContext.tsx

/**
 * Game Action Types as an enum for type safety and intellisense
 */
export enum GameActionType {
  START_GAME = 'game/startGame',
  PAUSE_GAME = 'game/pauseGame',
  RESUME_GAME = 'game/resumeGame',
  STOP_GAME = 'game/stopGame',
  ADD_EVENT = 'game/addEvent',
  UPDATE_RESOURCES = 'game/updateResources',
  UPDATE_RESOURCE_RATES = 'game/updateResourceRates',
  UPDATE_SYSTEMS = 'game/updateSystems',
  UPDATE_GAME_TIME = 'game/updateGameTime',
  ADD_MISSION = 'game/addMission',
  UPDATE_MISSION_STATS = 'game/updateMissionStats',
  UPDATE_SECTOR = 'game/updateSector',
  UPDATE_SHIP = 'game/updateShip',
  SET_LOADING = 'game/setLoading',
  SET_ERROR = 'game/setError',
}

/**
 * Game State Interface
 */
interface GameState extends BaseState {
  isRunning: boolean;
  isPaused: boolean;
  gameTime: number;
  events: GameEvent[];
  resources: {
    minerals: number;
    energy: number;
    population: number;
    research: number;
  };
  // Additional state properties...
}

// Type-safe action creators
export const createUpdateResourcesAction = (
  resources: Partial<GameState['resources']>
): GameAction => ({
  type: GameActionType.UPDATE_RESOURCES,
  payload: resources,
});

// Reducer function
const gameReducer = (state: GameState, action: GameAction): GameState => {
  switch (action.type) {
    case GameActionType.START_GAME:
      return {
        ...state,
        isRunning: true,
        isPaused: false,
      };

    case GameActionType.UPDATE_RESOURCES:
      return {
        ...state,
        resources: {
          ...state.resources,
          ...action.payload,
        },
      };

    // Additional cases...

    default:
      return state;
  }
};

// Context Provider Component
export const GameProvider: React.FC<GameProviderProps> = ({
  children,
  manager = gameManager,
  initialGameState,
}) => {
  // Reducer initialization with default state
  const [state, dispatch] = useReducer(gameReducer, {
    ...DEFAULT_GAME_STATE,
    ...initialGameState,
  });

  // Context value memoization
  const contextValue = useMemo<GameContextType>(
    () => ({
      state,
      dispatch,
      manager,
    }),
    [state, manager]
  );

  // Event subscriptions
  useEffect(() => {
    // Subscribe to manager events
    const unsubscribeStarted = manager.on('started', event =>
      handleGameStarted(event, dispatch)
    );

    // Additional subscriptions...

    // Return cleanup function
    return () => {
      unsubscribeStarted();
      // Remove other subscriptions...
    };
  }, [manager]);

  // Provide context to children
  return <GameContext.Provider value={contextValue}>{children}</GameContext.Provider>;
};

// Custom selector hooks for efficient state access
export const useGameSelector = <T,>(selector: (state: GameState) => T): T => {
  const { state } = useContext(GameContext);
  return selector(state);
};

export const useResourcesState = () => useGameSelector(selectResources);
```

#### 2. Specialized Hooks for Feature-specific State

```typescript
// src/hooks/automation/useGlobalAutomation.ts

export function useGlobalAutomation(): GlobalAutomationHookResult {
  const [routines, setRoutines] = useState<GlobalRoutine[]>([]);
  const [activeRoutines, setActiveRoutines] = useState<GlobalRoutine[]>([]);
  const [isInitialized, setIsInitialized] = useState<boolean>(false);
  const [lastUpdate, setLastUpdate] = useState<number>(Date.now());

  // Initialize on mount
  useEffect(() => {
    const initialize = async () => {
      try {
        // Get automation manager
        const manager = globalAutomationManager;

        // Get routines
        const allRoutines = manager.getAllRoutines();
        const active = manager.getActiveRoutines();

        // Update state
        setRoutines(allRoutines);
        setActiveRoutines(active);
        setIsInitialized(true);
        setLastUpdate(Date.now());
      } catch (error) {
        console.error('Error initializing global automation:', error);
      }
    };

    initialize();
  }, []);

  // React to routine changes
  useEffect(() => {
    const handleRoutineChange = () => {
      setRoutines(globalAutomationManager.getAllRoutines());
      setActiveRoutines(globalAutomationManager.getActiveRoutines());
      setLastUpdate(Date.now());
    };

    // Subscribe to events
    globalAutomationManager.on('routineAdded', handleRoutineChange);
    globalAutomationManager.on('routineRemoved', handleRoutineChange);
    globalAutomationManager.on('routineEnabled', handleRoutineChange);
    globalAutomationManager.on('routineDisabled', handleRoutineChange);

    return () => {
      // Unsubscribe from events
      globalAutomationManager.off('routineAdded', handleRoutineChange);
      globalAutomationManager.off('routineRemoved', handleRoutineChange);
      globalAutomationManager.off('routineEnabled', handleRoutineChange);
      globalAutomationManager.off('routineDisabled', handleRoutineChange);
    };
  }, []);

  // Define memoized functions to avoid recreating them on every render
  const createRoutine = useCallback(
    (
      id: string,
      name: string,
      type: GlobalRoutineType,
      description: string,
      config: GlobalRoutineConfig
    ): GlobalRoutine | null => {
      try {
        const routine = globalAutomationManager.createRoutine(id, name, type, description, config);
        setRoutines(globalAutomationManager.getAllRoutines());
        setLastUpdate(Date.now());
        return routine;
      } catch (error) {
        console.error('Error creating routine:', error);
        return null;
      }
    },
    []
  );

  // Return the hook result
  return {
    routines,
    activeRoutines,
    isInitialized,
    lastUpdate,
    createRoutine,
    // Additional methods...
  };
}
```

### Component Communication Patterns

The application implements several patterns for component communication to maintain loose coupling while enabling coordinated behavior.

#### 1. Context-based Communication

```typescript
// src/contexts/ThresholdContext.tsx

// Define context with default values
export const ThresholdContext = createContext<ThresholdContextType>({
  thresholds: {},
  registerThreshold: () => false,
  unregisterThreshold: () => false,
  updateThreshold: () => false,
  getThreshold: () => null,
  checkThreshold: () => ({
    status: ThresholdStatus.NORMAL,
    currentValue: 0,
    threshold: { min: 0, max: 0 },
  }),
});

// Provider component for downstream access
export const ThresholdProvider: React.FC<ThresholdProviderProps> = ({
  children,
  initialThresholds = {},
}) => {
  // State to track all registered thresholds
  const [thresholds, setThresholds] = useState<Record<string, ThresholdConfig>>(initialThresholds);

  // Register a new threshold
  const registerThreshold = useCallback(
    (id: string, config: ThresholdConfig): boolean => {
      if (thresholds[id]) {
        return false;
      }

      setThresholds(prev => ({
        ...prev,
        [id]: config,
      }));

      return true;
    },
    [thresholds]
  );

  // Memoize the context value
  const contextValue = useMemo(
    () => ({
      thresholds,
      registerThreshold,
      unregisterThreshold,
      updateThreshold,
      getThreshold,
      checkThreshold,
    }),
    [thresholds, registerThreshold, unregisterThreshold, updateThreshold, getThreshold, checkThreshold]
  );

  return (
    <ThresholdContext.Provider value={contextValue}>
      {children}
    </ThresholdContext.Provider>
  );
};

// Custom hook for easy context access
export function useThreshold() {
  return useContext(ThresholdContext);
}
```

#### 2. Event-based Communication

```typescript
// src/hooks/events/useModuleEvents.ts

import { useCallback } from 'react';
import { moduleEventBus } from '../../lib/modules/ModuleEvents';
import { ModuleEventType } from '../../types/events/ModuleEventTypes';

export function useModuleEvents() {
  // Subscribe to events
  const subscribe = useCallback(
    <T extends object>(eventType: ModuleEventType, handler: (event: T) => void) => {
      return moduleEventBus.subscribe(eventType, handler);
    },
    []
  );

  // Unsubscribe from events
  const unsubscribe = useCallback(
    <T extends object>(eventType: ModuleEventType, handler: (event: T) => void) => {
      moduleEventBus.unsubscribe(eventType, handler);
    },
    []
  );

  // Emit events
  const emit = useCallback(<T extends object>(eventType: ModuleEventType, event: T) => {
    moduleEventBus.emit({
      ...event,
      type: eventType,
      timestamp: Date.now(),
    });
  }, []);

  return {
    subscribe,
    unsubscribe,
    emit,
  };
}
```

#### 3. Prop-based Communication

```typescript
// src/components/ui/buttons/AbilityButton.tsx

interface AbilityButtonProps {
  ability: {
    id: string;
    name: string;
    icon: React.ReactNode;
    cooldown: number;
    isActive: boolean;
    isEnabled: boolean;
  };
  onClick: (abilityId: string) => void;
  onHover?: (abilityId: string) => void;
  className?: string;
}

export function AbilityButton({
  ability,
  onClick,
  onHover,
  className,
}: AbilityButtonProps) {
  const handleClick = useCallback(() => {
    if (ability.isEnabled) {
      onClick(ability.id);
    }
  }, [ability.id, ability.isEnabled, onClick]);

  const handleHover = useCallback(() => {
    if (onHover) {
      onHover(ability.id);
    }
  }, [ability.id, onHover]);

  return (
    <button
      className={cn(
        'relative rounded-full p-2 transition-all duration-200',
        ability.isEnabled ? 'cursor-pointer' : 'cursor-not-allowed opacity-50',
        ability.isActive && 'ring-2 ring-cyan-400',
        className
      )}
      onClick={handleClick}
      onMouseEnter={handleHover}
      disabled={!ability.isEnabled}
    >
      {ability.icon}
      {ability.cooldown > 0 && (
        <div className="absolute inset-0 flex items-center justify-center rounded-full bg-black bg-opacity-50 text-xs font-bold text-white">
          {ability.cooldown}
        </div>
      )}
    </button>
  );
}
```

### Performance Optimizations

The application implements numerous React-specific performance optimizations.

#### 1. Component Profiling and Optimization

```typescript
// src/hooks/ui/useComponentProfiler.ts

/**
 * Hook for profiling component renders
 *
 * @param componentName The name of the component to profile
 * @param options Profiling options
 * @returns A component profiling result
 */
export function useComponentProfiler(
  componentName: string,
  options: Partial<ComponentProfilingOptions> = {}
): ComponentProfilingResult {
  // Create a ref to store the profiler
  const profilerRef = useRef<ComponentProfilingResult | null>(null);

  // Initialize the profiler if it doesn't exist
  if (!profilerRef.current) {
    profilerRef.current = createComponentProfiler(componentName, options);
  }

  // Get the profiler
  const profiler = profilerRef.current;

  // Update options when they change
  useEffect(() => {
    profiler.updateOptions(options);
  }, [profiler, options]);

  // Record render time
  const renderStartTime = useRef(performance.now());

  // Use layout effect to measure render time
  useEffect(() => {
    const renderTime = performance.now() - renderStartTime.current;

    // Update metrics
    profiler.metrics.renderCount++;
    profiler.metrics.lastRenderTime = renderTime;
    profiler.metrics.totalRenderTime += renderTime;
    profiler.metrics.averageRenderTime =
      profiler.metrics.totalRenderTime / profiler.metrics.renderCount;
    profiler.metrics.maxRenderTime = Math.max(profiler.metrics.maxRenderTime, renderTime);
    profiler.metrics.lastRenderTimestamp = Date.now();

    // Add to render history
    if (profiler.renderHistory.length >= (options?.maxRenderHistory || 100)) {
      profiler.renderHistory.shift();
    }

    profiler.renderHistory.push({
      timestamp: Date.now(),
      renderTime,
      wasted: false,
      changedProps: [],
    });

    // Log slow renders
    if (options?.logToConsole && renderTime > (options?.slowRenderThreshold || 16)) {
      console.warn(
        `Slow render detected in ${componentName}: ${renderTime.toFixed(2)}ms ` +
          `(threshold: ${options?.slowRenderThreshold || 16}ms)`
      );
    }

    // Reset render start time for next render
    renderStartTime.current = performance.now();
  });

  return profiler;
}
```

#### 2. Memoization Patterns

```typescript
// src/components/ui/resource/ResourceVisualization.tsx

const ResourceVisualization: React.FC<ResourceVisualizationProps> = ({
  resources,
  width = 800,
  height = 400,
  showLabels = true,
  colorScheme = 'default',
  onResourceClick,
}) => {
  // Memoize processed data to avoid recalculation on every render
  const processedData = useMemo(() => {
    // Expensive data processing
    return resources.map(resource => ({
      ...resource,
      normalizedValue: normalizeValue(resource.value, resource.max),
      color: getResourceColor(resource.type, colorScheme),
    }));
  }, [resources, colorScheme]); // Only recalculate when resources or colorScheme change

  // Memoize layout calculations
  const layout = useMemo(() => {
    return calculateLayout(processedData, width, height, showLabels);
  }, [processedData, width, height, showLabels]);

  // Memoize event handlers
  const handleResourceClick = useCallback(
    (resourceId: string) => {
      if (onResourceClick) {
        const resource = resources.find(r => r.id === resourceId);
        if (resource) {
          onResourceClick(resource);
        }
      }
    },
    [resources, onResourceClick]
  );

  // Render with memoized data
  return (
    <div className="resource-visualization" style={{ width, height }}>
      {processedData.map(resource => (
        <ResourceBar
          key={resource.id}
          resource={resource}
          layout={layout[resource.id]}
          onClick={() => handleResourceClick(resource.id)}
        />
      ))}
    </div>
  );
};

// Memoize the entire component
export default React.memo(ResourceVisualization);
```

#### 3. Virtualization for Large Data Sets

```typescript
// src/components/ui/resource/VirtualizedResourceList.tsx

import { useVirtualizer } from '@tanstack/react-virtual';

const VirtualizedResourceList: React.FC<VirtualizedResourceListProps> = ({
  resources,
  height = 400,
  rowHeight = 50,
  onResourceSelect,
}) => {
  const parentRef = useRef<HTMLDivElement>(null);

  // Create a virtualizer for efficient rendering
  const rowVirtualizer = useVirtualizer({
    count: resources.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => rowHeight,
    overscan: 5,
  });

  return (
    <div
      ref={parentRef}
      className="resource-list-container"
      style={{ height, width: '100%', overflow: 'auto' }}
    >
      <div
        className="resource-list-inner"
        style={{ height: `${rowVirtualizer.getTotalSize()}px`, width: '100%', position: 'relative' }}
      >
        {rowVirtualizer.getVirtualItems().map(virtualRow => {
          const resource = resources[virtualRow.index];
          return (
            <div
              key={resource.id}
              className="resource-list-item"
              style={{
                position: 'absolute',
                top: 0,
                left: 0,
                width: '100%',
                height: `${rowHeight}px`,
                transform: `translateY(${virtualRow.start}px)`,
              }}
              onClick={() => onResourceSelect?.(resource)}
            >
              <ResourceListItem resource={resource} />
            </div>
          );
        })}
      </div>
    </div>
  );
};

export default React.memo(VirtualizedResourceList);
```

### Integration Best Practices

The application follows several best practices for React integration:

1. **Component Composition**: Prefer composition over prop drilling
2. **Hook Extraction**: Extract reusable logic into custom hooks
3. **Controlled Components**: Maintain state in parent components
4. **Unidirectional Data Flow**: Data flows down, events flow up
5. **Immutable State Updates**: Never mutate state directly
6. **Performance Monitoring**: Measure and optimize component performance
7. **Lazy Loading**: Load components only when needed
8. **Code Splitting**: Split code into manageable chunks
9. **Type Safety**: Use TypeScript for component props and state

## FACTORY SYSTEM (#factory_system)

### Core Architecture

The Factory System provides a standardized approach for creating and configuring complex game entities using the Factory Pattern. The system leverages singleton factories with consistent instantiation patterns and robust type validation.

```typescript
// src/factories/ships/ShipClassFactory.ts

export class ShipClassFactory {
  private static instance: ShipClassFactory;

  // Private constructor ensures singleton pattern
  private constructor() {}

  // Static getter for the singleton instance
  public static getInstance(): ShipClassFactory {
    if (!ShipClassFactory.instance) {
      ShipClassFactory.instance = new ShipClassFactory();
    }
    return ShipClassFactory.instance;
  }

  // Factory methods for creating ship instances
  public createShip(
    shipClass: FactionShipClass,
    factionId: FactionId,
    position: Position,
    formation?: { type: 'offensive' | 'defensive' | 'balanced'; spacing: number; facing: number }
  ): CombatUnit {
    // Implementation details...
  }

  // Factory methods for creating collections of entities
  public createFleet(
    factionId: FactionId,
    shipClasses: FactionShipClass[],
    position: Position,
    formation: { type: 'offensive' | 'defensive' | 'balanced'; spacing: number; facing: number }
  ): CombatUnit[] {
    // Implementation details...
  }
}

// Exported instance for convenient access throughout the application
export const shipClassFactory = ShipClassFactory.getInstance();
```

### Factory Method Patterns

The system employs several factory method patterns to create entities with consistent configuration:

1. **Direct Entity Creation**: Methods that create individual game entities with properly initialized state.

```typescript
// Ship creation with proper initialization
public createShip(shipClass: FactionShipClass, factionId: FactionId, position: Position): CombatUnit {
  const stats = SHIP_STATS[shipClass];
  if (!stats) {
    throw new Error(`Invalid ship class: ${shipClass}`);
  }

  // Initialize components with proper state
  const initializedWeaponMounts = stats.weapons.map(mount => this._createWeaponMount(mount));

  // Return fully configured entity
  return {
    id: `${factionId}-${shipClass}-${Date.now()}`,
    type: shipClass,
    health: stats.health,
    // ...other properties
  };
}
```

2. **Entity Collection Creation**: Methods that create collections of related entities with proper spatial and relational configuration.

```typescript
// Fleet creation with formation logic
public createFleet(factionId: FactionId, shipClasses: FactionShipClass[], position: Position): CombatUnit[] {
  return shipClasses.map((shipClass, index) => {
    // Calculate position based on formation
    const shipPosition = calculateFormationPosition(position, index, formation);

    // Create individual ship with proper position
    return this.createShip(shipClass, factionId, shipPosition);
  });
}
```

3. **Hook Factory Pattern**: Factory functions that create specialized React hooks with pre-configured behaviors.

```typescript
// Factory function that creates data fetching hooks
export function createDataFetchHook<T, P extends any[] = []>(
  fetchFn: (...args: P) => Promise<T>,
  defaultOptions: DataFetchOptions = {}
): (...args: P) => DataFetchResult<T> {
  return (...args: P): DataFetchResult<T> => {
    // Hook implementation with standardized state management
    const [data, setData] = useState<T | null>(null);
    const [isLoading, setIsLoading] = useState<boolean>(defaultOptions.fetchOnMount !== false);
    // ...additional state and logic

    return {
      data,
      isLoading,
      // ...other return values
    };
  };
}
```

### Factory Creation Workflows

The system uses consistent patterns for factory creation and access:

1. **Singleton Factory Initialization**: Factories are implemented as singletons with private constructors and static getInstance methods.

```typescript
// Singleton pattern implementation
export class EntityFactory<T> {
  private static instance: EntityFactory<T>;

  private constructor() {}

  public static getInstance(): EntityFactory<T> {
    if (!EntityFactory.instance) {
      EntityFactory.instance = new EntityFactory<T>();
    }
    return EntityFactory.instance;
  }
}
```

2. **Factory Instance Export**: Factory instances are exported at the module level for convenient access.

```typescript
// Export singleton instance
export const shipClassFactory = ShipClassFactory.getInstance();
```

3. **Factory Method Chaining**: Factory methods support method chaining for complex entity creation.

```typescript
// Method chaining example
shipClassFactory
  .createShip(shipClass, factionId, position)
  .attachWeapons(weaponConfigs)
  .setAIBehavior(behaviorProfile);
```

### Integration Patterns

The Factory System integrates with other systems using these patterns:

1. **Configuration Integration**: Factories consume configuration objects to create properly configured entities.

```typescript
// Integration with configuration system
const stats = SHIP_STATS[shipClass];
```

2. **Type System Integration**: Factories leverage the type system for validation and entity structure.

```typescript
// Type validation through type system
export function createLifecycleHook<TProps = Record<string, unknown>>(
  options: LifecycleOptions<TProps>
): (props: TProps) => LifecycleResult {
  // Implementation details...
}
```

3. **Component System Integration**: UI component factories integrate with the React component system.

```typescript
// Chart component factory example
const CanvasChartFactory: React.FC<CanvasChartFactoryProps> = ({
  data,
  type,
  options,
  // ...other props
}) => {
  // Factory logic to create the appropriate chart component
  switch (type) {
    case ChartType.LINE:
      return <CanvasLineChart data={data} options={options} />;
    case ChartType.BAR:
      return <CanvasBarChart data={data} options={options} />;
    // Other chart types...
    default:
      throw new Error(`Unsupported chart type: ${type}`);
  }
};
```

## REGISTRY SYSTEM (#registry_system)

### Core Architecture

The Registry System provides a centralized repository for game data with type-safe access patterns, event-driven updates, and integration with multiple game systems. The system serves as a single source of truth for critical game data.

```typescript
// src/registry/ResourceRegistry.ts

export class ResourceRegistry {
  private static _instance: ResourceRegistry | null = null;

  // Storage for resource metadata
  private resourceMetadata: Map<ResourceType, ExtendedResourceMetadata> = new Map();

  // Indexes for efficient querying
  private resourcesByCategory: Map<ResourceCategory, Set<ResourceType>> = new Map();
  private resourcesByTag: Map<string, Set<ResourceType>> = new Map();
  private resourcesByQuality: Map<ResourceQuality, Map<ResourceType, number>> = new Map();

  // Relationship mapping
  private conversionRates: Map<ResourceType, Map<ResourceType, number>> = new Map();

  // Event handling
  private listeners: Map<RegistryEventType, Set<(data: RegistryEventData) => void>> = new Map();
  private eventEmitter: EventEmitter<ResourceRegistryEvent>;

  // Singleton access
  public static getInstance(): ResourceRegistry {
    if (!ResourceRegistry._instance) {
      ResourceRegistry._instance = new ResourceRegistry();
    }
    return ResourceRegistry._instance;
  }

  private constructor() {
    this.eventEmitter = new EventEmitter<ResourceRegistryEvent>();
    this.initializeRegistry();
  }

  // Other methods...
}
```

### Registry Patterns

The Registry System implements several core patterns for efficient data management:

1. **Centralized Data Storage**: The registry provides a unified interface for storing and retrieving data.

```typescript
// Accessing resource metadata
public getResourceMetadata(resourceType: ResourceType): ExtendedResourceMetadata | undefined {
  return this.resourceMetadata.get(resourceType);
}

// Retrieving all registered resource types
public getAllResourceTypes(): ResourceType[] {
  return Array.from(this.resourceMetadata.keys());
}
```

2. **Indexed Lookup**: The registry maintains multiple indexes for efficient data retrieval.

```typescript
// Retrieving resources by category
public getResourcesByCategory(category: ResourceCategory): ResourceType[] {
  const resourceSet = this.resourcesByCategory.get(category);
  return resourceSet ? Array.from(resourceSet) : [];
}

// Retrieving resources by tag
public getResourcesByTag(tag: string): ResourceType[] {
  const resourceSet = this.resourcesByTag.get(tag);
  return resourceSet ? Array.from(resourceSet) : [];
}
```

3. **Relationship Management**: The registry maintains relationships between entities.

```typescript
// Setting conversion rates between resources
public setConversionRate(sourceType: ResourceType, targetType: ResourceType, rate: number): void {
  if (!this.conversionRates.has(sourceType)) {
    this.conversionRates.set(sourceType, new Map());
  }

  this.conversionRates.get(sourceType)!.set(targetType, rate);

  // Emit event for subscribers
  this.emit('conversionRateChanged', {
    sourceType,
    targetType,
    rate
  });
}

// Getting all sources that can convert to a target resource
public findConversionSources(targetType: ResourceType): Map<ResourceType, number> {
  const sources = new Map<ResourceType, number>();

  for (const [sourceType, conversions] of this.conversionRates.entries()) {
    const rate = conversions.get(targetType);
    if (rate !== undefined) {
      sources.set(sourceType, rate);
    }
  }

  return sources;
}
```

### Registration Workflows

The Registry System provides consistent workflows for registration and management:

1. **Type-Safe Registration**: Registering new entities with type validation.

```typescript
// Registering a new resource
public registerResource(options: ResourceRegistrationOptions): boolean {
  const { metadata, overrideExisting = false } = options;
  const { type, category } = metadata;

  // Validate if resource already exists
  if (this.resourceMetadata.has(type) && !overrideExisting) {
    console.warn(`Resource type ${type} is already registered`);
    return false;
  }

  // Add to main registry
  this.resourceMetadata.set(type, metadata);

  // Update indexes
  if (!this.resourcesByCategory.has(category)) {
    this.resourcesByCategory.set(category, new Set());
  }
  this.resourcesByCategory.get(category)!.add(type);

  // Add to tag index
  for (const tag of metadata.tags) {
    if (!this.resourcesByTag.has(tag)) {
      this.resourcesByTag.set(tag, new Set());
    }
    this.resourcesByTag.get(tag)!.add(type);
  }

  // Emit event
  this.emit('resourceRegistered', { resourceType: type, metadata });

  return true;
}
```

2. **Metadata Updates**: Updating entity metadata with event notifications.

```typescript
// Updating resource metadata
public updateResourceMetadata(
  resourceType: ResourceType,
  updates: Partial<ExtendedResourceMetadata>
): boolean {
  const metadata = this.resourceMetadata.get(resourceType);
  if (!metadata) {
    return false;
  }

  // Apply updates
  Object.assign(metadata, updates);

  // Update indexes if necessary
  if (updates.category && updates.category !== metadata.category) {
    // Update category index
    // ...
  }

  // Emit event
  this.emit('resourceMetadataUpdated', { resourceType, updates });

  return true;
}
```

3. **Data Import/Export**: Serializing and deserializing registry data.

```typescript
// Exporting registry data
public exportRegistryData(): {
  resources: Record<string, ExtendedResourceMetadata>;
  conversionRates: Record<string, Record<string, number>>;
} {
  const resources: Record<string, ExtendedResourceMetadata> = {};
  const conversionRates: Record<string, Record<string, number>> = {};

  // Export resources
  for (const [type, metadata] of this.resourceMetadata.entries()) {
    resources[type] = { ...metadata };
  }

  // Export conversion rates
  for (const [sourceType, targets] of this.conversionRates.entries()) {
    conversionRates[sourceType] = {};
    for (const [targetType, rate] of targets.entries()) {
      conversionRates[sourceType][targetType] = rate;
    }
  }

  return { resources, conversionRates };
}
```

### Integration Patterns

The Registry System integrates with other systems through several patterns:

1. **Event-Driven Integration**: The registry uses events to notify subscribers of changes.

```typescript
// Subscribing to registry events
public subscribe(
  eventType: RegistryEventType,
  callback: (data: RegistryEventData) => void
): () => void {
  if (!this.listeners.has(eventType)) {
    this.listeners.set(eventType, new Set());
  }

  this.listeners.get(eventType)!.add(callback);

  // Return unsubscribe function
  return () => {
    const callbacks = this.listeners.get(eventType);
    if (callbacks) {
      callbacks.delete(callback);
    }
  };
}

// Emitting events to subscribers
private emit(eventType: RegistryEventType, data: RegistryEventData): void {
  const callbacks = this.listeners.get(eventType);
  if (callbacks) {
    callbacks.forEach(callback => {
      try {
        callback(data);
      } catch (error) {
        console.error(`Error in registry event handler for ${eventType}:`, error);
      }
    });
  }

  // Also emit through the event emitter
  this.eventEmitter.emit({
    type: eventType,
    data,
    timestamp: Date.now()
  });
}
```

2. **System Bridging**: Dedicated integration classes bridge between systems with different data models.

```typescript
// ResourceRegistryIntegration.ts
export class ResourceRegistryIntegration {
  private static _instance: ResourceRegistryIntegration | null = null;
  private registry: ResourceRegistry;

  // Singleton access
  public static getInstance(): ResourceRegistryIntegration {
    if (!ResourceRegistryIntegration._instance) {
      ResourceRegistryIntegration._instance = new ResourceRegistryIntegration();
    }
    return ResourceRegistryIntegration._instance;
  }

  // Synchronizing with other managers
  public syncResourceAvailability(resourceFlowManager: ResourceFlowManager): void {
    const resourceStates = resourceFlowManager.getAllResourceStates?.();
    if (!resourceStates) {
      return;
    }

    // Process and synchronize resource states
    // ...
  }

  // Translating between string-based and enum-based resource types
  public getResourceMetadata(resourceType: ResourceType | string): unknown {
    // Convert string to enum if needed
    const actualType =
      typeof resourceType === 'string'
        ? ResourceTypeConverter.convertToEnum(resourceType)
        : resourceType;

    return this.registry.getResourceMetadata(actualType);
  }
}
```

3. **Dependency Injection**: Registry instances are provided to dependent systems.

```typescript
// In a service or manager constructor
constructor(private registry: ResourceRegistry = ResourceRegistry.getInstance()) {
  // Subscribe to relevant events
  this.registry.subscribe('resourceRegistered', this.handleResourceRegistered);
  this.registry.subscribe('conversionRateChanged', this.handleConversionRateChanged);
}
```

## ENTITY POOLING SYSTEM (#entity_pooling_system)

### Core Architecture

The Entity Pooling System provides a memory-efficient approach to managing dynamic game entities through object pooling to reduce garbage collection and improve performance. The system pre-allocates and reuses entity instances instead of creating and destroying them.

```typescript
// src/lib/optimization/EntityPool.ts

export interface PooledEntity {
  reset(): void;
}

/**
 * Generic entity pool for efficient object reuse
 */
export class EntityPool<T extends PooledEntity> extends EventEmitter<PoolEvent<T>> {
  // Available entities ready for use
  private available: T[];

  // Currently active entities
  private inUse: Set<T>;

  // Factory function for creating new entities
  private factory: () => T;

  // Pool configuration
  private _maxSize: number;
  private _expandSize: number;

  constructor(
    factory: () => T,
    initialSize: number,
    maxSize: number = 1000,
    expandSize: number = 50
  ) {
    super();
    this.factory = factory;
    this._maxSize = maxSize;
    this._expandSize = expandSize;
    this.available = [];
    this.inUse = new Set();

    // Pre-allocate initial pool
    for (let i = 0; i < initialSize; i++) {
      this.available.push(factory());
    }
  }

  // Main pool methods...
}
```

### Object Pooling Patterns

The Entity Pooling System implements several core patterns for efficient memory management:

1. **Pre-allocation and Reuse**: The system pre-allocates entities and reuses them instead of creating new instances.

```typescript
// Get an entity from the pool
public acquire(): T | undefined {
  let entity: T;

  // Use an available entity if possible
  if (this.available.length > 0) {
    entity = this.available.pop()!;
  } else {
    // Check if we've reached the maximum pool size
    const totalEntities = this.getTotalCount();
    if (totalEntities >= this._maxSize) {
      console.warn(
        `[EntityPool] Maximum pool size (${this._maxSize}) reached, cannot create more entities`
      );
      return undefined;
    }

    // Expand the pool if necessary
    if (this.available.length === 0 && totalEntities < this._maxSize) {
      this.expandPool();
      entity = this.available.pop()!;
    }
  }

  // Mark as in use and return
  this.inUse.add(entity);

  // Emit event
  this.emit({
    type: 'entityActivated',
    data: { entity }
  });

  return entity;
}

// Return an entity to the pool
public release(entity: T): void {
  // Ensure entity is actually in use
  if (!this.inUse.has(entity)) {
    console.warn('[EntityPool] Attempted to release an entity not in use');
    return;
  }

  // Reset the entity and add back to available pool
  entity.reset();
  this.inUse.delete(entity);
  this.available.push(entity);

  // Emit event
  this.emit({
    type: 'entityDeactivated',
    data: { entity }
  });
}
```

2. **Dynamic Pool Expansion**: The system expands the pool size when needed while respecting memory constraints.

```typescript
// Expand the pool by creating new entities
private expandPool(): void {
  const totalEntities = this.getTotalCount();
  const expandSize = Math.min(this._expandSize, this._maxSize - totalEntities);

  console.warn(`[EntityPool] Expanding pool by ${expandSize} entities`);

  // Create new entities in batch
  for (let i = 0; i < expandSize; i++) {
    this.available.push(this.factory());
  }

  // Emit event for pool expansion
  this.emit({
    type: 'poolExpanded',
    data: { newSize: this.getTotalCount() }
  });
}
```

3. **Resource Tracking**: The system provides methods to monitor pool usage and status.

```typescript
// Get total number of entities (active + available)
public getTotalCount(): number {
  return this.inUse.size + this.available.length;
}

// Get number of active entities
public getActiveCount(): number {
  return this.inUse.size;
}

// Get number of available entities
public getAvailableCount(): number {
  return this.available.length;
}

// Get all active entities
public getActiveEntities(): T[] {
  return Array.from(this.inUse);
}
```

### Memory Optimization Techniques

The system employs several techniques to optimize memory usage and performance:

1. **Batch Allocation**: Entities are created in batches to reduce allocation overhead.

```typescript
// Pre-allocate entities in constructor
constructor(factory: () => T, initialSize: number) {
  // ...

  // Pre-allocate initial pool in a single batch
  for (let i = 0; i < initialSize; i++) {
    this.available.push(factory());
  }
}
```

2. **Pooled Entity Interface**: Entities implement a reset method to clear state between uses.

```typescript
// Required interface for pooled entities
export interface PooledEntity {
  reset(): void;
}

// Example asteroid implementation
class Asteroid implements PooledEntity {
  public position: { x: number; y: number };
  public velocity: { x: number; y: number };
  public active: boolean;

  constructor() {
    this.position = { x: 0, y: 0 };
    this.velocity = { x: 0, y: 0 };
    this.active = false;
  }

  // Reset the asteroid to its initial state
  public reset(): void {
    this.position.x = 0;
    this.position.y = 0;
    this.velocity.x = 0;
    this.velocity.y = 0;
    this.active = false;
  }
}
```

3. **Pool Size Management**: The system enforces maximum pool sizes to prevent unbounded memory growth.

```typescript
public acquire(): T | undefined {
  // ...

  // Check if we've reached the maximum pool size
  const totalEntities = this.getTotalCount();
  if (totalEntities >= this._maxSize) {
    console.warn(
      `[EntityPool] Maximum pool size (${this._maxSize}) reached, cannot create more entities`
    );
    return undefined;
  }

  // ...
}
```

### Performance Optimization Patterns

The Entity Pooling System incorporates several patterns to maximize runtime performance:

1. **Event-Based Monitoring**: The system emits events that can be used for monitoring and debugging.

```typescript
// Event types for entity pool
interface PoolEvents<T extends PooledEntity> {
  entityActivated: { entity: T };
  entityDeactivated: { entity: T };
  poolExpanded: { newSize: number };
  [key: string]: unknown;
}

// Emit an event when an entity is activated
this.emit({
  type: 'entityActivated',
  data: { entity },
});
```

2. **Type-Safe Implementation**: The system uses generics to provide type safety while maintaining flexibility.

```typescript
// Type-safe entity pool
export class EntityPool<T extends PooledEntity> extends EventEmitter<PoolEvent<T>> {
  // Implementation details...
}

// Type-specific pool instances
const asteroidPool = new EntityPool<Asteroid>(() => new Asteroid(), 100);
const bulletPool = new EntityPool<Bullet>(() => new Bullet(), 200);
```

3. **Resource Cleanup**: The system provides cleanup methods to release resources.

```typescript
// Clear the entire pool
public clear(): void {
  // Release all active entities
  this.inUse.forEach(entity => entity.reset());

  // Add them back to the available pool
  this.available.push(...Array.from(this.inUse));

  // Clear the in-use set
  this.inUse.clear();
}
```

### Integration Patterns

The Entity Pooling System integrates with other systems using these patterns:

1. **Factory Integration**: The system accepts a factory function to create new entities.

```typescript
// Creating a pool with a factory function
const bulletPool = new EntityPool<Bullet>(
  () => new Bullet(), // Factory function
  100 // Initial size
);
```

2. **Game Loop Integration**: The system integrates with the game update loop.

```typescript
// In game update loop
function update(deltaTime: number) {
  // Create new entities from pool as needed
  if (shouldCreateNewAsteroid()) {
    const asteroid = asteroidPool.acquire();
    if (asteroid) {
      initializeAsteroid(asteroid);
    }
  }

  // Update active entities
  for (const entity of asteroidPool.getActiveEntities()) {
    updateEntity(entity, deltaTime);

    // Return to pool if no longer needed
    if (!entity.active) {
      asteroidPool.release(entity);
    }
  }
}
```

3. **Component System Integration**: The pooling system integrates with the entity component system.

```typescript
// Creating a component manager with pooling
class ParticleComponentManager {
  private particlePool: EntityPool<Particle>;

  constructor(initialSize: number) {
    this.particlePool = new EntityPool<Particle>(() => new Particle(), initialSize);

    // Listen for pool events
    this.particlePool.on('poolExpanded', this.handlePoolExpanded);
  }

  // Create a new particle component
  public createParticle(position: Vector2): Particle | undefined {
    const particle = this.particlePool.acquire();
    if (particle) {
      particle.position.x = position.x;
      particle.position.y = position.y;
      particle.active = true;
    }
    return particle;
  }

  // Release a particle back to the pool
  public destroyParticle(particle: Particle): void {
    this.particlePool.release(particle);
  }
}
```

## Factions System (#faction_ships)

## Overview

The Factions System manages AI factions in the game, handling their behavior, relationships, and interactions with the player and each other. It consists of multiple interconnected managers that coordinate faction activities and decision-making.

## Components

### FactionManager

Manages faction state and activation based on player progression:

```typescript
interface FactionState {
  activeShips: number;
  territory: {
    center: { x: number; y: number };
    radius: number;
  };
  fleetStrength: number;
  relationshipWithPlayer: number; // -1 to 1
  lastActivity: number;
  isActive: boolean;
}

class FactionManager {
  private factionStates: Map<string, FactionState> = new Map();
  private playerTier: number = 1;
  private playerPower: number = 0;

  // Activate factions based on player progression
  public updatePlayerStatus(tier: number, power: number) {
    this.playerTier = tier;
    this.playerPower = power;
    this.checkFactionActivation();
  }

  private checkFactionActivation() {
    // Activates factions when player reaches required tier/power
  }

  // Faction behavior analysis
  public getFactionBehavior(factionId: string) {
    return {
      isHostile: this.isHostileToPlayer(factionId),
      willAttack: this.willInitiateAttack(factionId),
      expansionPriority: this.calculateExpansionPriority(factionId),
      reinforcementNeeded: state.fleetStrength < config.behavior.reinforcementThreshold,
    };
  }

  // Update faction state periodically
  public update() {
    // Updates fleet strength, territory expansion, and ship spawning
  }
}
```

### FactionBehaviorManager

Manages faction behavior using event-based patterns:

```typescript
export class FactionBehaviorManager extends BaseTypedEventEmitter<FactionEvents> {
  private factions: Map<FactionId, FactionState> = new Map();

  // Change faction behavior and emit events
  public changeBehavior(factionId: FactionId, newBehavior: FactionBehaviorType): boolean {
    const faction = this.factions.get(factionId);
    if (!faction) {
      return false;
    }

    const oldBehavior = faction.behavior;
    faction.behavior = newBehavior;
    this.factions.set(factionId, faction);

    this.emit('faction:behavior-changed', {
      factionId,
      oldBehavior,
      newBehavior,
      timestamp: Date.now(),
    });

    return true;
  }

  // Manage faction fleets
  public updateFleets(factionId: FactionId, fleets: FactionFleet[]): boolean {
    // Updates fleets and emits events
  }

  // Manage faction territory
  public updateTerritory(factionId: FactionId, territory: FactionTerritory): boolean {
    // Updates territory and emits events
  }

  // Manage faction relationships
  public updateRelationship(
    factionId: FactionId,
    targetFaction: FactionId,
    newValue: number
  ): boolean {
    // Updates relationships and emits events
  }

  // Manage faction resources
  public updateResources(
    factionId: FactionId,
    resourceType: ResourceType,
    newAmount: number
  ): boolean {
    // Updates resources and emits events
  }

  // Manage faction combat tactics
  public updateCombatTactics(factionId: FactionId, newTactics: FactionCombatTactics): boolean {
    // Updates combat tactics and emits events
  }
}

export interface FactionState {
  id: FactionId;
  name: string;
  behavior: FactionBehaviorType;
  fleets: FactionFleet[];
  territory: FactionTerritory;
  relationships: Record<FactionId, number>;
  resources: Record<ResourceType, number>;
  combatTactics: FactionCombatTactics;
}
```

### FactionRelationshipManager

Manages diplomatic relationships between factions:

```typescript
export class FactionRelationshipManager extends TypedEventEmitter<FactionEvents> {
  private relationships: Map<string, RelationshipState> = new Map();

  // Initialize relationships between all factions
  private initializeRelationships(): void {
    const factionIds = Object.keys(factionConfigs);
    // Setup initial relationships with predefined values
  }

  // Modify relationship values
  public modifyRelationship(
    factionId: FactionId,
    targetId: FactionId,
    change: number,
    reason: string
  ): void {
    // Change relationship values and emit events
  }

  // Update treaty status based on relationship
  private updateTreatyStatus(factionId: FactionId, targetId: FactionId): void {
    // Change treaty status based on relationship thresholds
  }

  // Record trade activity between factions
  public recordTrade(
    factionId: FactionId,
    targetId: FactionId,
    resourceType: ResourceType,
    amount: number
  ): void {
    // Record trade and improve relationship
  }

  // Record conflict between factions
  public recordConflict(
    factionId: FactionId,
    targetId: FactionId,
    type: 'attack' | 'territory' | 'trade',
    severity: number
  ): void {
    // Record conflict and damage relationship
  }

  // Handle diplomatic actions
  public handleDiplomaticAction(
    factionId: FactionId,
    targetId: FactionId,
    action: 'ceasefire' | 'tradeRoute' | 'alliance' | 'tribute',
    resources?: { type: string; amount: number }[]
  ): boolean {
    // Process diplomatic actions with requirements and outcomes
  }
}

interface RelationshipState {
  value: number; // -1 to 1
  lastUpdate: number;
  tradeCount: number;
  conflictCount: number;
  treatyStatus: 'none' | 'ceasefire' | 'trade' | 'alliance';
}
```

## Integration Patterns

- Faction managers use event-driven architecture to communicate state changes
- Factions interact with player progression systems to trigger activation
- Factions maintain relationships with other factions that influence behavior
- Treaty status is updated based on relationship thresholds
- Diplomatic actions require specific relationship levels and resource exchanges

## Behavior Tree System (#behavior_tree)

## Overview

The Behavior Tree System implements AI decision-making for ships and entities in the game. It uses task-based behavior patterns to manage entity actions and priorities.

## Components

### ShipBehaviorManager

Manages ship AI behavior using a task assignment system:

```typescript
interface ShipTask {
  id: string;
  type: 'salvage' | 'combat' | 'patrol' | 'mine';
  target?: {
    id: string;
    position: Position;
  };
  priority: number;
  assignedAt: number;
}

interface ShipBehaviorEvents {
  type: string;
  data: {
    taskAssigned?: { shipId: string; taskId: string; taskType: string };
    taskCompleted?: { shipId: string; taskId: string; success: boolean };
    shipAdded?: { shipId: string; category: ShipCategory };
    shipRemoved?: { shipId: string };
  };
}

class ShipBehaviorManagerImpl extends EventEmitter<ShipBehaviorEvents> {
  private tasks: Map<string, ShipTask> = new Map();
  private ships: Map<string, ShipWithPosition> = new Map();
  private salvageTargets: Map<string, string> = new Map(); // salvageId -> shipId

  // Assign a task to a ship
  public assignTask(task: ShipTask): void {
    if (!task.target) {
      return;
    }

    this.tasks.set(task.id, task);
    this.emit({
      type: 'taskAssigned',
      data: {
        taskAssigned: {
          shipId: task.id,
          taskId: task.id,
          taskType: task.type,
        },
      },
    });
  }

  // Register a ship for behavior management
  public registerShip(ship: ShipWithPosition): void {
    if (!ship.id) {
      return;
    }
    this.ships.set(ship.id, ship);
  }

  // Unregister a ship
  public unregisterShip(shipId: string): void {
    this.ships.delete(shipId);
    this.tasks.delete(shipId);
  }

  // Get a ship's current task
  public getShipTask(shipId: string): ShipTask | undefined {
    return this.tasks.get(shipId);
  }

  // Mark a task as completed
  public completeTask(shipId: string): void {
    const task = this.tasks.get(shipId);
    if (task) {
      if (task.type === 'salvage' && task.target) {
        this.salvageTargets.delete(task.target.id);
      }
      this.tasks.delete(shipId);
      this.emit({
        type: 'taskCompleted',
        data: {
          taskCompleted: {
            shipId,
            taskId: task.id,
            success: true,
          },
        },
      });
    }
  }
}
```

### ShipMovement

Handles ship movement behaviors:

```typescript
// Simplified representation of ship movement AI
class ShipMovementSystem {
  // Move towards target
  moveTowards(ship: ShipWithPosition, target: Position, speed: number): void {
    // Calculate direction and move ship
  }

  // Orbit around target
  orbitTarget(ship: ShipWithPosition, target: Position, radius: number): void {
    // Calculate orbital path and move ship
  }

  // Avoid obstacles
  avoidObstacles(ship: ShipWithPosition, obstacles: Position[]): void {
    // Calculate avoidance path
  }

  // Follow another ship
  followShip(ship: ShipWithPosition, targetShip: ShipWithPosition, distance: number): void {
    // Calculate follow path with maintained distance
  }
}
```

## Decision-Making Patterns

1. **Task Assignment**: Ships are assigned tasks with priorities that determine their behavior

2. **Task Execution Flow**:

   - Ship registers with behavior manager
   - Task is assigned based on ship capabilities and position
   - Ship executes task until completed or interrupted
   - On completion, ship reports back to behavior manager

3. **Priority-Based Decisions**:

   - Tasks have priority levels
   - Higher priority tasks can interrupt lower priority ones
   - Tasks can be reassigned based on changing conditions

4. **Event-Driven Behavior Changes**:
   - Environmental events trigger behavior changes
   - Faction directives alter ship priorities
   - Player actions may force behavior reevaluation

## Integration Patterns

- Behavior system uses event emission for task state changes
- Ships register with behavior manager to receive tasks
- Tasks are assigned based on ship capabilities and proximity
- Behavior system coordinates with faction AI for strategic decisions
- Events like combat or resource discovery trigger behavior changes

## Manager Registry System (#manager_registry)

## Overview

The Manager Registry System provides a centralized access point for game manager singletons, solving circular dependency issues and ensuring consistent access to manager instances throughout the codebase.

## Core Pattern

The system uses a factory function pattern to lazily instantiate and provide access to manager instances:

```typescript
/**
 * ManagerRegistry.ts
 *
 * Central registry for all manager singletons to avoid circular dependencies
 * and ensure consistent access to manager instances.
 */

import { CombatManager } from './combat/CombatManager';

// Singleton instances
let combatManagerInstance: CombatManager | null = null;

/**
 * Get the singleton instance of CombatManager
 * @returns The CombatManager instance
 */
export function getCombatManager(): CombatManager {
  if (!combatManagerInstance) {
    combatManagerInstance = new CombatManager();
  }
  return combatManagerInstance;
}

/**
 * Reset all manager instances - primarily used for testing
 */
export function resetManagers(): void {
  combatManagerInstance = null;
}

// Export manager classes for type usage
export { CombatManager };
```

## Manager Instantiation Pattern

For each manager in the system, the registry provides:

1. A private singleton instance variable
2. A getter function that lazily instantiates the manager
3. Export of the manager class for type usage

## Usage Pattern

To use a manager from the registry:

```typescript
import { getCombatManager } from '../managers/ManagerRegistry';

function someFunction() {
  const combatManager = getCombatManager();
  combatManager.initiateCombat(/* parameters */);
}
```

## Benefits

- **Avoids Circular Dependencies**: Instead of directly importing manager classes, code can reference the registry
- **Lazy Instantiation**: Managers are only created when first needed
- **Consistent Access**: Ensures single instance usage throughout the application
- **Testing Support**: Reset function allows test cases to start with clean manager state
- **Separation of Concerns**: Allows managers to focus on their domain without worrying about initialization order

## Integration Patterns

- Registry functions are used whenever manager access is needed
- Registry encapsulates creation logic and singleton management
- Multiple parts of the codebase can access managers without circular imports
- Registry pattern scales to incorporate new manager types as needed
- All managers follow a consistent access pattern

## Factions System (#faction_system)

## Overview

The Factions System manages AI factions in the game, handling their behavior, relationships, and interactions with the player and each other. It consists of multiple interconnected managers that coordinate faction activities and decision-making.

## Components

### FactionManager

Manages faction state and activation based on player progression:

```typescript
interface FactionState {
  activeShips: number;
  territory: {
    center: { x: number; y: number };
    radius: number;
  };
  fleetStrength: number;
  relationshipWithPlayer: number; // -1 to 1
  lastActivity: number;
  isActive: boolean;
}

class FactionManager {
  private factionStates: Map<string, FactionState> = new Map();
  private playerTier: number = 1;
  private playerPower: number = 0;

  // Activate factions based on player progression
  public updatePlayerStatus(tier: number, power: number) {
    this.playerTier = tier;
    this.playerPower = power;
    this.checkFactionActivation();
  }

  private checkFactionActivation() {
    // Activates factions when player reaches required tier/power
  }

  // Faction behavior analysis
  public getFactionBehavior(factionId: string) {
    return {
      isHostile: this.isHostileToPlayer(factionId),
      willAttack: this.willInitiateAttack(factionId),
      expansionPriority: this.calculateExpansionPriority(factionId),
      reinforcementNeeded: state.fleetStrength < config.behavior.reinforcementThreshold,
    };
  }

  // Update faction state periodically
  public update() {
    // Updates fleet strength, territory expansion, and ship spawning
  }
}
```

### FactionBehaviorManager

Manages faction behavior using event-based patterns:

```typescript
export class FactionBehaviorManager extends BaseTypedEventEmitter<FactionEvents> {
  private factions: Map<FactionId, FactionState> = new Map();

  // Change faction behavior and emit events
  public changeBehavior(factionId: FactionId, newBehavior: FactionBehaviorType): boolean {
    const faction = this.factions.get(factionId);
    if (!faction) {
      return false;
    }

    const oldBehavior = faction.behavior;
    faction.behavior = newBehavior;
    this.factions.set(factionId, faction);

    this.emit('faction:behavior-changed', {
      factionId,
      oldBehavior,
      newBehavior,
      timestamp: Date.now(),
    });

    return true;
  }

  // Manage faction fleets
  public updateFleets(factionId: FactionId, fleets: FactionFleet[]): boolean {
    // Updates fleets and emits events
  }

  // Manage faction territory
  public updateTerritory(factionId: FactionId, territory: FactionTerritory): boolean {
    // Updates territory and emits events
  }

  // Manage faction relationships
  public updateRelationship(
    factionId: FactionId,
    targetFaction: FactionId,
    newValue: number
  ): boolean {
    // Updates relationships and emits events
  }

  // Manage faction resources
  public updateResources(
    factionId: FactionId,
    resourceType: ResourceType,
    newAmount: number
  ): boolean {
    // Updates resources and emits events
  }

  // Manage faction combat tactics
  public updateCombatTactics(factionId: FactionId, newTactics: FactionCombatTactics): boolean {
    // Updates combat tactics and emits events
  }
}

export interface FactionState {
  id: FactionId;
  name: string;
  behavior: FactionBehaviorType;
  fleets: FactionFleet[];
  territory: FactionTerritory;
  relationships: Record<FactionId, number>;
  resources: Record<ResourceType, number>;
  combatTactics: FactionCombatTactics;
}
```

### FactionRelationshipManager

Manages diplomatic relationships between factions:

```typescript
export class FactionRelationshipManager extends TypedEventEmitter<FactionEvents> {
  private relationships: Map<string, RelationshipState> = new Map();

  // Initialize relationships between all factions
  private initializeRelationships(): void {
    const factionIds = Object.keys(factionConfigs);
    // Setup initial relationships with predefined values
  }

  // Modify relationship values
  public modifyRelationship(
    factionId: FactionId,
    targetId: FactionId,
    change: number,
    reason: string
  ): void {
    // Change relationship values and emit events
  }

  // Update treaty status based on relationship
  private updateTreatyStatus(factionId: FactionId, targetId: FactionId): void {
    // Change treaty status based on relationship thresholds
  }

  // Record trade activity between factions
  public recordTrade(
    factionId: FactionId,
    targetId: FactionId,
    resourceType: ResourceType,
    amount: number
  ): void {
    // Record trade and improve relationship
  }

  // Record conflict between factions
  public recordConflict(
    factionId: FactionId,
    targetId: FactionId,
    type: 'attack' | 'territory' | 'trade',
    severity: number
  ): void {
    // Record conflict and damage relationship
  }

  // Handle diplomatic actions
  public handleDiplomaticAction(
    factionId: FactionId,
    targetId: FactionId,
    action: 'ceasefire' | 'tradeRoute' | 'alliance' | 'tribute',
    resources?: { type: string; amount: number }[]
  ): boolean {
    // Process diplomatic actions with requirements and outcomes
  }
}

interface RelationshipState {
  value: number; // -1 to 1
  lastUpdate: number;
  tradeCount: number;
  conflictCount: number;
  treatyStatus: 'none' | 'ceasefire' | 'trade' | 'alliance';
}
```

## Integration Patterns

- Faction managers use event-driven architecture to communicate state changes
- Factions interact with player progression systems to trigger activation
- Factions maintain relationships with other factions that influence behavior
- Treaty status is updated based on relationship thresholds
- Diplomatic actions require specific relationship levels and resource exchanges

## Behavior Tree System (#behavior_tree)

## Overview

The Behavior Tree System implements AI decision-making for ships and entities in the game. It uses task-based behavior patterns to manage entity actions and priorities.

## Components

### ShipBehaviorManager

Manages ship AI behavior using a task assignment system:

```typescript
interface ShipTask {
  id: string;
  type: 'salvage' | 'combat' | 'patrol' | 'mine';
  target?: {
    id: string;
    position: Position;
  };
  priority: number;
  assignedAt: number;
}

interface ShipBehaviorEvents {
  type: string;
  data: {
    taskAssigned?: { shipId: string; taskId: string; taskType: string };
    taskCompleted?: { shipId: string; taskId: string; success: boolean };
    shipAdded?: { shipId: string; category: ShipCategory };
    shipRemoved?: { shipId: string };
  };
}

class ShipBehaviorManagerImpl extends EventEmitter<ShipBehaviorEvents> {
  private tasks: Map<string, ShipTask> = new Map();
  private ships: Map<string, ShipWithPosition> = new Map();
  private salvageTargets: Map<string, string> = new Map(); // salvageId -> shipId

  // Assign a task to a ship
  public assignTask(task: ShipTask): void {
    if (!task.target) {
      return;
    }

    this.tasks.set(task.id, task);
    this.emit({
      type: 'taskAssigned',
      data: {
        taskAssigned: {
          shipId: task.id,
          taskId: task.id,
          taskType: task.type,
        },
      },
    });
  }

  // Register a ship for behavior management
  public registerShip(ship: ShipWithPosition): void {
    if (!ship.id) {
      return;
    }
    this.ships.set(ship.id, ship);
  }

  // Unregister a ship
  public unregisterShip(shipId: string): void {
    this.ships.delete(shipId);
    this.tasks.delete(shipId);
  }

  // Get a ship's current task
  public getShipTask(shipId: string): ShipTask | undefined {
    return this.tasks.get(shipId);
  }

  // Mark a task as completed
  public completeTask(shipId: string): void {
    const task = this.tasks.get(shipId);
    if (task) {
      if (task.type === 'salvage' && task.target) {
        this.salvageTargets.delete(task.target.id);
      }
      this.tasks.delete(shipId);
      this.emit({
        type: 'taskCompleted',
        data: {
          taskCompleted: {
            shipId,
            taskId: task.id,
            success: true,
          },
        },
      });
    }
  }
}
```

### ShipMovement

Handles ship movement behaviors:

```typescript
// Simplified representation of ship movement AI
class ShipMovementSystem {
  // Move towards target
  moveTowards(ship: ShipWithPosition, target: Position, speed: number): void {
    // Calculate direction and move ship
  }

  // Orbit around target
  orbitTarget(ship: ShipWithPosition, target: Position, radius: number): void {
    // Calculate orbital path and move ship
  }

  // Avoid obstacles
  avoidObstacles(ship: ShipWithPosition, obstacles: Position[]): void {
    // Calculate avoidance path
  }

  // Follow another ship
  followShip(ship: ShipWithPosition, targetShip: ShipWithPosition, distance: number): void {
    // Calculate follow path with maintained distance
  }
}
```

## Decision-Making Patterns

1. **Task Assignment**: Ships are assigned tasks with priorities that determine their behavior

2. **Task Execution Flow**:

   - Ship registers with behavior manager
   - Task is assigned based on ship capabilities and position
   - Ship executes task until completed or interrupted
   - On completion, ship reports back to behavior manager

3. **Priority-Based Decisions**:

   - Tasks have priority levels
   - Higher priority tasks can interrupt lower priority ones
   - Tasks can be reassigned based on changing conditions

4. **Event-Driven Behavior Changes**:
   - Environmental events trigger behavior changes
   - Faction directives alter ship priorities
   - Player actions may force behavior reevaluation

## Integration Patterns

- Behavior system uses event emission for task state changes
- Ships register with behavior manager to receive tasks
- Tasks are assigned based on ship capabilities and proximity
- Behavior system coordinates with faction AI for strategic decisions
- Events like combat or resource discovery trigger behavior changes

## Manager Registry System (#manager_registry)

## Overview

The Manager Registry System provides a centralized access point for game manager singletons, solving circular dependency issues and ensuring consistent access to manager instances throughout the codebase.

## Core Pattern

The system uses a factory function pattern to lazily instantiate and provide access to manager instances:

```typescript
/**
 * ManagerRegistry.ts
 *
 * Central registry for all manager singletons to avoid circular dependencies
 * and ensure consistent access to manager instances.
 */

import { CombatManager } from './combat/CombatManager';

// Singleton instances
let combatManagerInstance: CombatManager | null = null;

/**
 * Get the singleton instance of CombatManager
 * @returns The CombatManager instance
 */
export function getCombatManager(): CombatManager {
  if (!combatManagerInstance) {
    combatManagerInstance = new CombatManager();
  }
  return combatManagerInstance;
}

/**
 * Reset all manager instances - primarily used for testing
 */
export function resetManagers(): void {
  combatManagerInstance = null;
}

// Export manager classes for type usage
export { CombatManager };
```

## Manager Instantiation Pattern

For each manager in the system, the registry provides:

1. A private singleton instance variable
2. A getter function that lazily instantiates the manager
3. Export of the manager class for type usage

## Usage Pattern

To use a manager from the registry:

```typescript
import { getCombatManager } from '../managers/ManagerRegistry';

function someFunction() {
  const combatManager = getCombatManager();
  combatManager.initiateCombat(/* parameters */);
}
```

## Benefits

- **Avoids Circular Dependencies**: Instead of directly importing manager classes, code can reference the registry
- **Lazy Instantiation**: Managers are only created when first needed
- **Consistent Access**: Ensures single instance usage throughout the application
- **Testing Support**: Reset function allows test cases to start with clean manager state
- **Separation of Concerns**: Allows managers to focus on their domain without worrying about initialization order

## Integration Patterns

- Registry functions are used whenever manager access is needed
- Registry encapsulates creation logic and singleton management
- Multiple parts of the codebase can access managers without circular imports
- Registry pattern scales to incorporate new manager types as needed
- All managers follow a consistent access pattern

## Visualization System (#visualization_system)

## Overview

The Visualization System provides flexible data visualization capabilities with multiple rendering strategies. It automatically selects the most appropriate rendering method based on data size and device capabilities, offering consistent API across different rendering techniques.

## Core Components

### Chart Component

The main React component that serves as the entry point for the visualization system:

```typescript
/**
 * Chart data point interface
 */
export interface ChartDataPoint {
  x: number | string | Date;
  y: number;
  [key: string]: unknown;
}

/**
 * Chart data interface
 */
export interface ChartData {
  datasets: {
    label: string;
    data: ChartDataPoint[];
    color?: string;
    [key: string]: unknown;
  }[];
  annotations?: {
    type: 'line' | 'box' | 'point';
    position: { x?: number | string | Date; y?: number };
    color?: string;
    label?: string;
    [key: string]: unknown;
  }[];
}

/**
 * Chart component props
 */
export interface ChartProps {
  data: ChartData;
  options?: Partial<ChartOptions>;
  type: ChartType;
  className?: string;
  onRender?: (renderer: ChartRenderer) => void;
  onError?: (error: Error) => void;
}

/**
 * Chart component that uses a strategy pattern for different rendering methods
 */
export const Chart: React.FC<ChartProps> = ({
  data,
  options = {},
  type,
  className = '',
  onRender,
  onError,
}) => {
  // Implementation uses strategy pattern to select renderer
  // based on data size and device capabilities
};
```

### Rendering Strategies

The system implements the Strategy pattern with multiple renderer implementations:

```typescript
/**
 * Chart renderer interface (Strategy interface)
 */
export interface ChartRenderer {
  render: (container: HTMLElement, data: ChartData, options: ChartOptions, type: ChartType) => void;
  update: (container: HTMLElement, data: ChartData, options: ChartOptions, type: ChartType) => void;
  destroy: () => void;
  getStatus: () => { isInitialized: boolean; lastRenderTime?: number };
}
```

#### CanvasRenderer

```typescript
/**
 * Canvas-based chart renderer implementation.
 * Uses the HTML Canvas API for efficient rendering of charts with large datasets.
 */
export class CanvasRenderer implements ChartRenderer {
  private canvas: HTMLCanvasElement | null = null;
  private ctx: CanvasRenderingContext2D | null = null;

  // Canvas-specific rendering methods for different chart types
  private renderLineChart(data: ChartData, options: ChartOptions, chartArea: ChartArea): void {
    // Canvas line chart implementation
  }

  private renderBarChart(data: ChartData, options: ChartOptions, chartArea: ChartArea): void {
    // Canvas bar chart implementation
  }

  private renderScatterChart(data: ChartData, options: ChartOptions, chartArea: ChartArea): void {
    // Canvas scatter chart implementation
  }

  // Other chart type implementations...
}
```

#### WebGLRenderer

```typescript
/**
 * WebGL-based chart renderer implementation.
 * Uses WebGL for high-performance rendering of charts with very large datasets.
 */
export class WebGLRenderer implements ChartRenderer {
  private canvas: HTMLCanvasElement | null = null;
  private gl: WebGLRenderingContext | null = null;
  private shaders: Map<string, ShaderProgram> = new Map();

  // WebGL-specific implementations for different chart types
  private renderLineChart(
    data: ChartData,
    options: ExtendedChartOptions,
    chartArea: ChartArea
  ): void {
    // WebGL line chart implementation with shader program
  }

  private renderScatterChart(
    data: ChartData,
    options: ExtendedChartOptions,
    chartArea: ChartArea
  ): void {
    // WebGL scatter chart implementation
  }

  // Other chart type implementations...
}
```

#### SVGRenderer

```typescript
/**
 * SVG-based chart renderer implementation.
 * Uses SVG for high-quality vector graphics suitable for smaller datasets and print.
 */
export class SVGRenderer implements ChartRenderer {
  private svg: SVGSVGElement | null = null;

  // SVG-specific rendering methods for different chart types
  private renderLineChart(data: ChartData, options: ChartOptions, chartArea: ChartArea): void {
    // SVG line chart implementation
  }

  private renderPieChart(data: ChartData, options: ChartOptions): void {
    // SVG pie chart implementation
  }

  // Other chart type implementations...
}
```

### WebGLShaderManager

A utility class for managing WebGL shaders used in advanced data visualizations:

```typescript
/**
 * Supported shader types for data visualization
 */
export enum DataVisualizationShaderType {
  HEATMAP = 'heatmap',
  CONTOUR = 'contour',
  POINT_CLUSTER = 'pointCluster',
  HIGHLIGHT = 'highlight',
  DENSITY = 'density',
  FLOW = 'flow',
  TRANSITION = 'transition',
  CUSTOM = 'custom',
}

/**
 * WebGL Shader Manager for data visualization effects
 */
export class WebGLShaderManager {
  private gl: WebGLRenderingContext | null = null;
  private programs: Map<string, WebGLProgram> = new Map();
  private shaders: Map<string, WebGLShader> = new Map();

  // Create and manage shader programs
  public renderDataVisualization(
    config: DataVisualizationShaderConfig,
    data: Float32Array,
    positions: Position[],
    width: number,
    height: number
  ): void {
    // Render visualization using appropriate shader
  }

  // Shader program creation and management
  private createDataVisualizationShader(
    config: DataVisualizationShaderConfig
  ): WebGLProgram | undefined {
    // Creates shader program based on configuration
  }

  // Animation loop for dynamic visualizations
  public startAnimationLoop(renderCallback: () => void): void {
    // Handles animation timing and rendering
  }
}
```

## Design Patterns

### Strategy Pattern

The Chart component uses the Strategy pattern to select the most appropriate renderer:

```typescript
const Chart: React.FC<ChartProps> = ({ data, options, type }) => {
  const [renderer, setRenderer] = useState<ChartRenderer | null>(null);
  const containerRef = useRef<HTMLDivElement>(null);

  // Strategy selection logic
  useEffect(() => {
    // Select renderer based on data size and options
    const createRenderer = () => {
      // Use WebGL for very large datasets
      if (dataSize > options.optimizationThreshold && options.renderer !== 'svg') {
        return new WebGLRenderer();
      }

      // Use Canvas as default for medium datasets
      if (options.renderer !== 'svg' && options.renderer !== 'webgl') {
        return new CanvasRenderer();
      }

      // Use SVG for smaller datasets or when vector quality is needed
      return new SVGRenderer();
    };

    setRenderer(createRenderer());
  }, [options.renderer, dataSize]);

  // Use the selected strategy to render
  useEffect(() => {
    if (renderer && containerRef.current) {
      renderer.render(containerRef.current, data, options, type);
    }
  }, [renderer, data, options, type]);

  return <div ref={containerRef} className={className} />;
};
```

### Observer Pattern

Chart components use the Observer pattern for event handling:

```typescript
const Chart: React.FC<ChartProps> = ({ data, options, onRender, onError }) => {
  // ...

  useEffect(() => {
    if (renderer && containerRef.current) {
      try {
        renderer.render(containerRef.current, data, options, type);
        // Notify observers
        if (onRender) {
          onRender(renderer);
        }
      } catch (error) {
        // Notify error observers
        if (onError && error instanceof Error) {
          onError(error);
        }
      }
    }
  }, [renderer, data, options, type, onRender, onError]);

  // ...
};
```

### Factory Method Pattern

WebGLShaderManager uses factory methods to create specialized shaders:

```typescript
export class WebGLShaderManager {
  // Factory method for creating visualization shaders
  private createDataVisualizationShader(
    config: DataVisualizationShaderConfig
  ): WebGLProgram | undefined {
    const type = config.type;

    // Generate shader source based on type
    const vertexSource = this.getDataVisualizationVertexShader(config);
    const fragmentSource = this.getDataVisualizationFragmentShader(config);

    return this.createShaderProgram(`${type}-shader`, vertexSource, fragmentSource);
  }

  // Factory methods for shader source generation
  private getDataVisualizationVertexShader(config: DataVisualizationShaderConfig): string {
    // Select or customize vertex shader based on config
    switch (config.type) {
      case DataVisualizationShaderType.HEATMAP:
        return /* heatmap vertex shader */;
      case DataVisualizationShaderType.CONTOUR:
        return /* contour vertex shader */;
      // Other cases...
    }
  }
}
```

## Integration Patterns

- **Renderer Selection**: Auto-selection of renderer based on dataset size and device capabilities
- **Unified API**: Consistent interface across all rendering strategies
- **Performance Optimization**: Automatic adjustments for large datasets
- **Theme Integration**: Support for light and dark theme modes
- **Animation Framework**: Built-in animation capabilities for transitions
- **Event Integration**: Standardized event system for interaction handling
- **Responsive Layout**: Automatic resizing and adaptation to container dimensions
- **Accessibility Support**: Keyboard navigation and screen reader compatibility
- **Memory Management**: Proper resource cleanup and optimization for large datasets

## Shader System (#shader_system)

### Overview

The Shader System provides WebGL-based GPU acceleration for data visualization and graphics rendering in the game. It manages shader programs, optimizes rendering performance, and offers a variety of visualization effects for displaying complex game data.

## Core Components

### WebGLShaderManager

A central manager class that handles WebGL context, shader compilation, and rendering:

```typescript
/**
 * Represents a WebGL shader uniform
 */
export interface ShaderUniform {
  type: 'float' | 'vec2' | 'vec3' | 'vec4' | 'int' | 'bool' | 'sampler2D';
  value: number | number[] | boolean | WebGLTexture | null;
}

/**
 * Supported shader types for data visualization
 */
export enum DataVisualizationShaderType {
  HEATMAP = 'heatmap',
  CONTOUR = 'contour',
  POINT_CLUSTER = 'pointCluster',
  HIGHLIGHT = 'highlight',
  DENSITY = 'density',
  FLOW = 'flow',
  TRANSITION = 'transition',
  CUSTOM = 'custom',
}

/**
 * Configuration for data visualization shaders
 */
export interface DataVisualizationShaderConfig {
  type: DataVisualizationShaderType;
  colors: string[];
  intensity?: number;
  resolution?: [number, number];
  animate?: boolean;
  animationSpeed?: number;
  highlightRange?: [number, number];
  dataRange?: [number, number];
  dataPoints?: Float32Array;
  customUniforms?: Record<string, ShaderUniform>;
  customVertexShader?: string;
  customFragmentShader?: string;
}

/**
 * WebGL Shader Manager for data visualization effects
 */
export class WebGLShaderManager {
  private gl: WebGLRenderingContext | null = null;
  private canvas: HTMLCanvasElement | null = null;
  private programs: Map<string, WebGLProgram> = new Map();
  private shaders: Map<string, WebGLShader> = new Map();
  private textures: Map<string, WebGLTexture> = new Map();
  private framebuffers: Map<string, WebGLFramebuffer> = new Map();
  private animationFrame: number | null = null;
  private _lastTimestamp: number = 0;

  // Initialize WebGL context with optimized settings
  public initialize(canvas: HTMLCanvasElement): boolean {
    this.canvas = canvas;
    this.gl = canvas.getContext('webgl', {
      alpha: true,
      premultipliedAlpha: false,
      antialias: true,
      powerPreference: 'high-performance',
    });

    // Initialize default shaders for each visualization type
    this.initializeDefaultShaders();

    return !!this.gl;
  }

  // Create and manage shader programs
  private createShaderProgram(
    name: string,
    vertexShaderSource: string,
    fragmentShaderSource: string
  ): WebGLProgram | undefined {
    // Shader program creation and linking
  }

  // Render data visualization using appropriate shader
  public renderDataVisualization(
    config: DataVisualizationShaderConfig,
    data: Float32Array,
    positions: Position[],
    width: number,
    height: number
  ): void {
    // Setup and draw visualization
  }

  // Animation loop management for continuous rendering
  public startAnimationLoop(renderCallback: () => void): void {
    // Setup animation loop with proper timing
  }

  // Resource cleanup
  public dispose(): void {
    // Clean up shaders, programs, textures and other WebGL resources
  }
}
```

### Shader Generation System

The manager dynamically generates shader code based on visualization type:

```typescript
/**
 * Get vertex shader source for data visualization
 */
private getDataVisualizationVertexShader(config: DataVisualizationShaderConfig): string {
  // Use custom vertex shader if provided
  if (config.type === DataVisualizationShaderType.CUSTOM && config.customVertexShader) {
    return config.customVertexShader;
  }

  // Default vertex shader with specialized code based on visualization type
  return `
    attribute vec2 a_position;
    attribute float a_data;

    uniform vec2 u_resolution;
    uniform float u_time;
    uniform float u_speed;
    uniform vec2 u_dataRange;
    uniform vec2 u_highlightRange;

    varying float v_data;
    varying vec2 v_position;
    varying float v_time;

    void main() {
      // Normalize data
      v_data = (a_data - u_dataRange.x) / (u_dataRange.y - u_dataRange.x);
      v_position = a_position;
      v_time = u_time * u_speed;

      // Set point size based on data
      float highlightFactor = 1.0;

      // Highlight range with pulsing effect
      if (v_data >= u_highlightRange.x && v_data <= u_highlightRange.y) {
        highlightFactor = 1.0 + 0.3 * sin(u_time * 3.0);
      }

      // Calculate point size based on visualization type
      float baseSize = 1.0;
      ${this.getPointSizeShaderCode(config)}

      // Position conversion
      vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;
      gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
    }
  `;
}
```

### Shader Effect Types

Different shader effects for various visualization needs:

```typescript
/**
 * Get fragment shader effects based on visualization type
 */
private getFragmentShaderEffects(config: DataVisualizationShaderType): string {
  switch (config.type) {
    case DataVisualizationShaderType.HEATMAP:
      return `
        float dist = length(gl_PointCoord - vec2(0.5));
        float fadeEdge = smoothstep(0.5, 0.35, dist);
        alpha *= fadeEdge;
      `;

    case DataVisualizationShaderType.CONTOUR:
      return `
        float contourBands = abs(fract(v_data * 10.0) - 0.5) * 2.0;
        float isContour = step(0.8, contourBands);
        alpha *= mix(0.3, 1.0, isContour);

        float dist = length(gl_PointCoord - vec2(0.5));
        alpha *= smoothstep(0.5, 0.0, dist);
      `;

    case DataVisualizationShaderType.FLOW:
      return `
        float dist = length(gl_PointCoord - vec2(0.5));

        vec2 dir = normalize(gl_PointCoord - vec2(0.5));
        float dirFactor = 0.5 + 0.5 * dot(dir, vec2(cos(v_time), sin(v_time)));

        alpha *= smoothstep(0.5, 0.0, dist) * dirFactor;
        color *= 0.8 + 0.2 * dirFactor;

        float streak = smoothstep(0.9, 0.0, abs(dot(dir, vec2(cos(v_time), sin(v_time)))));
        color += streak * 0.2 * vec3(1.0, 0.9, 0.7);
      `;

    // Other visualization types...
  }
}
```

## WebGL Optimization Techniques

### Memory Management

The system implements careful WebGL resource management to prevent memory leaks:

```typescript
/**
 * Dispose of WebGL resources
 */
public dispose(): void {
  // Stop any running animation
  this.stopAnimationLoop();

  // Clean up WebGL resources
  if (this.gl) {
    // Delete shaders
    this.shaders.forEach(shader => {
      this.gl?.deleteShader(shader);
    });
    this.shaders.clear();

    // Delete programs
    this.programs.forEach(program => {
      this.gl?.deleteProgram(program);
    });
    this.programs.clear();

    // Delete textures
    this.textures.forEach(texture => {
      this.gl?.deleteTexture(texture);
    });
    this.textures.clear();

    // Delete framebuffers
    this.framebuffers.forEach(framebuffer => {
      this.gl?.deleteFramebuffer(framebuffer);
    });
    this.framebuffers.clear();

    // Reset context
    this.gl = null;
    this.canvas = null;
  }
}
```

### Context Configuration

Optimized WebGL context setup for best performance:

```typescript
this.gl = canvas.getContext('webgl', {
  alpha: true,
  premultipliedAlpha: false,
  antialias: true,
  powerPreference: 'high-performance',
});
```

### Animation Optimization

The system uses requestAnimationFrame with proper timing:

```typescript
public startAnimationLoop(renderCallback: () => void): void {
  // Stop any existing animation loop
  this.stopAnimationLoop();

  // Animation frame handler with delta time calculation
  const animate = (timestamp: number) => {
    // Calculate delta time
    const deltaTime = this._lastTimestamp ? timestamp - this._lastTimestamp : 0;
    this._lastTimestamp = timestamp;

    // Call render callback
    renderCallback();

    // Request next frame
    this.animationFrame = requestAnimationFrame(animate);
  };

  // Start the animation loop
  this.animationFrame = requestAnimationFrame(animate);
}
```

### Buffer Management

Efficient handling of vertex and data buffers:

```typescript
private setupDataVisualizationBuffers(
  program: WebGLProgram,
  config: DataVisualizationShaderConfig,
  data: Float32Array,
  positions: Position[]
): void {
  // Optimize buffer creation and reuse
  const positionBuffer = this.gl.createBuffer();
  this.gl.bindBuffer(this.gl.ARRAY_BUFFER, positionBuffer);

  // Convert positions to flat array - optimize memory usage
  const positionArray = new Float32Array(positions.length * 2);
  positions.forEach((pos, index) => {
    positionArray[index * 2] = pos.x;
    positionArray[index * 2 + 1] = pos.y;
  });

  this.gl.bufferData(this.gl.ARRAY_BUFFER, positionArray, this.gl.STATIC_DRAW);

  // Setup vertex attributes efficiently
}
```

## Integration with Visualization System

The Shader System integrates with the Visualization System through the WebGLRenderer component:

```typescript
// In WebGLRenderer.tsx
export class WebGLRenderer implements ChartRenderer {
  private canvas: HTMLCanvasElement | null = null;
  private gl: WebGLRenderingContext | null = null;
  private shaderManager: WebGLShaderManager | null = null;

  private initializeWebGL(container: HTMLElement): boolean {
    // Create canvas element
    this.canvas = document.createElement('canvas');
    container.appendChild(this.canvas);

    // Initialize shader manager
    this.shaderManager = new WebGLShaderManager();
    const success = this.shaderManager.initialize(this.canvas);

    return success;
  }

  private renderScatterChart(
    data: ChartData,
    options: ExtendedChartOptions,
    chartArea: ChartArea
  ): void {
    if (!this.canvas || !this.shaderManager) return;

    // Convert chart data to format usable by shader system
    const positions: Position[] = [];
    const dataValues: number[] = [];

    // Extract data points
    data.datasets.forEach(dataset => {
      dataset.data.forEach(point => {
        positions.push({ x: point.x as number, y: point.y });
        dataValues.push(point.y);
      });
    });

    // Configure shader visualization
    const visualizationConfig: DataVisualizationShaderConfig = {
      type: DataVisualizationShaderType.POINT_CLUSTER,
      colors: ['#3366cc', '#dc3912', '#ff9900'],
      intensity: options.opacity || 0.8,
      animate: true,
    };

    // Render visualization with shader system
    this.shaderManager.renderDataVisualization(
      visualizationConfig,
      new Float32Array(dataValues),
      positions,
      this.canvas.width,
      this.canvas.height
    );
  }
}
```

## GPU Acceleration Techniques

### Parallel Processing

The shader system leverages GPU's parallel processing capabilities:

```typescript
// In Data Visualization Shaders
void main() {
  // Each vertex (data point) is processed in parallel on the GPU
  v_data = (a_data - u_dataRange.x) / (u_dataRange.y - u_dataRange.x);

  // All points are transformed simultaneously
  gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
}
```

### Offloading Calculations to GPU

Complex calculations are performed in shaders rather than JavaScript:

```typescript
// In Fragment Shader Effects
float contourBands = abs(fract(v_data * 10.0) - 0.5) * 2.0;
float isContour = step(0.8, contourBands);
alpha *= mix(0.3, 1.0, isContour);

// Complex vector math for flow visualization
vec2 dir = normalize(gl_PointCoord - vec2(0.5));
float dirFactor = 0.5 + 0.5 * dot(dir, vec2(cos(v_time), sin(v_time)));
```

### Texture-Based Data Storage

Using textures for efficient data storage and access:

```typescript
// In setUniform method
case 'sampler2D':
  if (uniform.value instanceof WebGLTexture) {
    gl.uniform1i(location, 0);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, uniform.value);
  }
  break;
```

## Integration Patterns

- **Visualization Integration**: The shader system provides GPU-accelerated rendering for the Chart component
- **Performance Optimization**: Automatically chooses visualization techniques based on data size
- **Memory Management**: Carefully manages WebGL resources to prevent leaks and reduce memory usage
- **Animation Support**: Provides high-performance animations using GPU acceleration
- **Customization**: Allows custom shaders for specialized visualization needs
- **Effect Library**: Includes pre-built visualization effects for common data visualization scenarios
- **Adaptive Rendering**: Adjusts rendering quality based on device capabilities
- **Seamless Fallback**: Integrates with Canvas and SVG renderers for devices without WebGL support

## Component Library System (#component_library)

### Overview

The Component Library System provides a comprehensive set of UI components for the application, organized in a hierarchical structure where specialized components are built on top of base components using composition. The system ensures consistency, flexibility, and accessibility while optimizing for performance.

## Core Principles

1. **Consistency**: All components share common styling patterns and behavior
2. **Composition**: Specialized components are built using base components
3. **Flexibility**: Components accept customization through props
4. **Accessibility**: Components are designed to be accessible by default
5. **Performance**: Components are optimized for render performance

## Component Organization

The component library follows a consistent organizational pattern:

```typescript
// Component Organization:
//
// - Button/            Base button and specialized buttons
//   - Button.tsx       Base button component
//   - variants/        Specialized button variants
//     - AbilityButton.tsx  Game ability button
//     - ...
// - Card/              Base card and specialized cards
//   - Card.tsx         Base card component
//   - variants/        Specialized card variants
//     - ModuleCard.tsx Ship module card
//     - ...
// - Badge/             Base badge and specialized badges
//   - Badge.tsx        Base badge component
//   - variants/        Specialized badge variants
//     - StatusBadge.tsx  Status indicator badge
//     - ...
```

## Base Components

### Button Component

A versatile button with multiple variants, sizes, and states:

```typescript
/**
 * Button variants
 */
export type ButtonVariant =
  | 'primary'
  | 'secondary'
  | 'tertiary'
  | 'danger'
  | 'success'
  | 'warning'
  | 'info'
  | 'ghost';

/**
 * Button sizes
 */
export type ButtonSize = 'xs' | 'sm' | 'md' | 'lg' | 'xl';

/**
 * Button props
 */
export interface ButtonProps extends Omit<ButtonHTMLAttributes<HTMLButtonElement>, 'prefix'> {
  /** Button variant */
  variant?: ButtonVariant;
  /** Button size */
  size?: ButtonSize;
  /** Whether the button is loading */
  loading?: boolean;
  /** Whether the button is full width */
  fullWidth?: boolean;
  /** Leading icon */
  leadingIcon?: ReactNode;
  /** Trailing icon */
  trailingIcon?: ReactNode;
  /** Whether the button has a border */
  bordered?: boolean;
  /** Custom focus ring color */
  focusRingColor?: string;
  /** Children */
  children?: ReactNode;
  /** Additional class names */
  className?: string;
}

/**
 * Base Button component
 */
export const Button = forwardRef<HTMLButtonElement, ButtonProps>(
  (
    {
      variant = 'primary',
      size = 'md',
      loading = false,
      fullWidth = false,
      leadingIcon,
      trailingIcon,
      bordered = false,
      focusRingColor,
      className,
      disabled,
      children,
      ...props
    },
    ref
  ) => {
    // Implementation with mapping between variants/sizes and class names
  }
);
```

### Card Component

A flexible card container with various display options:

```typescript
/**
 * Card variants
 */
export type CardVariant = 'default' | 'bordered' | 'elevated' | 'flat';

/**
 * Card props
 */
export interface CardProps extends HTMLAttributes<HTMLDivElement> {
  /** Card variant */
  variant?: CardVariant;
  /** Whether the card should have hover effects */
  hoverable?: boolean;
  /** Whether the card is selectable */
  selectable?: boolean;
  /** Whether the card is selected */
  selected?: boolean;
  /** Whether the card is disabled */
  disabled?: boolean;
  /** The card's header content */
  header?: ReactNode;
  /** The card's footer content */
  footer?: ReactNode;
  /** The card's title */
  title?: ReactNode;
  /** The card's subtitle */
  subtitle?: ReactNode;
  /** The card's main content */
  children?: ReactNode;
  /** The card's background color */
  background?: string;
  /** Whether the card has compact padding */
  compact?: boolean;
  /** Additional class names */
  className?: string;
}

/**
 * Card component
 */
export const Card = forwardRef<HTMLDivElement, CardProps>(
  (
    {
      variant = 'default',
      hoverable = false,
      selectable = false,
      selected = false,
      disabled = false,
      header,
      footer,
      title,
      subtitle,
      children,
      background,
      compact = false,
      className,
      ...props
    },
    ref
  ) => {
    // Implementation with conditional rendering of sections
  }
);
```

### Badge Component

A compact label component for displaying status, counts, or categories:

```typescript
/**
 * Badge variants
 */
export type BadgeVariant =
  | 'default'
  | 'primary'
  | 'secondary'
  | 'success'
  | 'warning'
  | 'danger'
  | 'info'
  | 'outline';

/**
 * Badge sizes
 */
export type BadgeSize = 'xs' | 'sm' | 'md' | 'lg';

/**
 * Badge props
 */
export interface BadgeProps extends HTMLAttributes<HTMLSpanElement> {
  /** Badge variant */
  variant?: BadgeVariant;
  /** Badge size */
  size?: BadgeSize;
  /** Whether the badge has a border */
  bordered?: boolean;
  /** Whether the badge is rounded */
  rounded?: boolean;
  /** Whether the badge has a dot indicator */
  withDot?: boolean;
  /** Dot color (only when withDot is true) */
  dotColor?: string;
  /** Whether the badge is interactive (has hover state) */
  interactive?: boolean;
  /** Children to render */
  children?: React.ReactNode;
  /** Additional class names */
  className?: string;
}

/**
 * Badge component
 */
export const Badge = forwardRef<HTMLSpanElement, BadgeProps>(
  (
    {
      variant = 'default',
      size = 'md',
      bordered = false,
      rounded = true,
      withDot = false,
      dotColor,
      interactive = false,
      className,
      children,
      ...props
    },
    ref
  ) => {
    // Implementation with conditional rendering and styling
  }
);
```

## Specialized Components

### AbilityButton Component

A game-specific button variant for abilities with cooldowns and resource costs:

```typescript
/**
 * Ability interface for game abilities
 */
export interface Ability {
  /** Unique ID of the ability */
  id: string;
  /** Display name of the ability */
  name: string;
  /** Description of what the ability does */
  description: string;
  /** URL or path to the ability's icon */
  iconUrl?: string;
  /** Whether the ability is passive (always active) */
  isPassive?: boolean;
  /** Whether the ability is unlocked */
  isUnlocked?: boolean;
  /** The ability's cooldown in seconds (0 means no cooldown) */
  cooldown: number;
  /** The ability's energy cost */
  energyCost?: number;
  /** The ability's mana cost */
  manaCost?: number;
  // Other ability properties...
}

/**
 * AbilityButton props
 */
export interface AbilityButtonProps extends Omit<ButtonProps, 'leadingIcon'> {
  /** The ability to display */
  ability: Ability;
  /** Current cooldown time remaining in seconds */
  cooldownRemaining?: number;
  /** Whether the player has enough resources to use this ability */
  hasResources?: boolean;
  /** Whether to show the cooldown timer */
  showCooldown?: boolean;
  // Other ability button properties...
}

/**
 * AbilityButton component
 *
 * A specialized button for displaying and activating game abilities,
 * with support for cooldowns, resource costs, and tooltips.
 */
export const AbilityButton = forwardRef<HTMLButtonElement, AbilityButtonProps>(
  (
    {
      ability,
      cooldownRemaining = 0,
      hasResources = true,
      showCooldown = true,
      // Other props...
    },
    ref
  ) => {
    // Implementation that extends the base Button component
    // with game-specific ability functionality
  }
);
```

### ModuleCard Component

A specialized card for displaying ship or station modules with status indicators:

```typescript
/**
 * Module status types
 */
export type ModuleStatus = 'active' | 'inactive' | 'damaged' | 'destroyed' | 'upgrading' | 'locked';

/**
 * Module type
 */
export interface Module {
  /** Unique ID of the module */
  id: string;
  /** Display name of the module */
  name: string;
  /** Description of what the module does */
  description: string;
  /** The module's current status */
  status: ModuleStatus;
  /** The module's current level (0 = not installed) */
  level: number;
  /** The module's maximum possible level */
  maxLevel: number;
  // Other module properties...
}

/**
 * ModuleCard props
 */
export interface ModuleCardProps extends Omit<CardProps, 'title' | 'subtitle'> {
  /** The module to display */
  module: Module;
  /** Whether to show the module level */
  showLevel?: boolean;
  /** Whether to show the module energy consumption */
  showEnergy?: boolean;
  // Other module card properties...
}

/**
 * ModuleCard component
 *
 * A specialized card for displaying ship or station modules,
 * with support for status indicators, resource I/O, and action buttons.
 */
export const ModuleCard = forwardRef<HTMLDivElement, ModuleCardProps>(
  (
    {
      module,
      showLevel = true,
      showEnergy = true,
      // Other props...
    },
    ref
  ) => {
    // Implementation that extends the base Card component
    // with game-specific module functionality
  }
);
```

## Design Patterns

### Component Composition

Components are composed using React's component composition pattern:

```typescript
// Example of composition in ModuleCard
return (
  <Card
    ref={ref}
    variant="bordered"
    selectable={selectable}
    selected={selected}
    className={cardClasses}
    onClick={handleClick}
    {...props}
  >
    {/* Module-specific content and layout */}
    <div className="flex items-center">
      {/* Module icon */}
      <div className="module-icon">...</div>

      {/* Module details */}
      <div className="module-details">...</div>
    </div>

    {/* Module actions */}
    <div className="module-actions">
      <Button variant="primary" onClick={handleUpgrade}>
        Upgrade
      </Button>
    </div>
  </Card>
);
```

### Prop Drilling with Defaults

Components expose numerous props with sensible defaults to allow customization without complexity:

```typescript
export const Badge = forwardRef<HTMLSpanElement, BadgeProps>(
  (
    {
      variant = 'default', // Default variant
      size = 'md', // Default size
      bordered = false, // Default border state
      rounded = true, // Default rounded state
      withDot = false, // Default dot indicator state
      // Other props with defaults...
    },
    ref
  ) => {
    // Implementation
  }
);
```

### Utility Classes

Components use utility functions for class name composition:

```typescript
// cn utility function for composing class names
const buttonClasses = cn(
  // Base styles
  'inline-flex items-center justify-center rounded-md font-medium transition-colors focus:outline-none',
  // Variant styles
  variantClasses[variant],
  // Size styles
  sizeClasses[size],
  // Width styles
  fullWidth ? 'w-full' : '',
  // Custom class names
  className
);
```

### Forward Refs

Components use React's forwardRef to allow parent components to access DOM nodes:

```typescript
export const Button = forwardRef<HTMLButtonElement, ButtonProps>(
  ({ /* props */ }, ref) => {
    // Implementation that uses the ref
    return <button ref={ref} className={buttonClasses} {...props}>
      {/* Button content */}
    </button>;
  }
);
```

## Integration Patterns

- **Centralized exports**: Components are exported from a central index.ts file for easy imports
- **Consistent prop interfaces**: Components follow consistent naming conventions and prop structures
- **Hierarchy-based organization**: Components are organized in directories by type with variants in subdirectories
- **Composition-based extension**: Specialized components extend base components through composition
- **Style system integration**: Components use a common utility for consistent styling across the application
- **Detailed TypeScript interfaces**: Type definitions ensure proper usage and provide IDE auto-completion
- **Accessibility built-in**: Components include aria attributes and keyboard navigation support
- **Documentation through comments**: Detailed JSDoc comments describe component props and usage patterns

## Data Processing System (#data_processing)

### Overview

The Data Processing System provides a comprehensive set of utilities for transforming, analyzing, and filtering data for visualization, analysis, and presentation. It's organized into three main categories that work together to support various data processing needs across the application.

## Core Components

### Chart Transformations

Utilities for preparing and transforming data for visualization components:

```typescript
/**
 * Chart Data Transformation Utilities
 *
 * This module provides standardized utilities for transforming data
 * for visualization components. It consolidates common patterns for
 * extracting, processing, and formatting chart data.
 */

// Type Guards
export function isNumber(value: unknown): value is number {
  return typeof value === 'number' && !isNaN(value);
}

export function isString(value: unknown): value is string {
  return typeof value === 'string';
}

export function isArray<T = unknown>(value: unknown): value is Array<T> {
  return Array.isArray(value);
}

export function isObject(value: unknown): value is Record<string, unknown> {
  return typeof value === 'object' && value !== null && !Array.isArray(value);
}

// Safe Data Extraction
export function safelyExtractNumber(
  obj: Record<string, unknown> | null | undefined,
  key: string,
  defaultValue = 0
): number {
  if (!obj) return defaultValue;
  const value = obj[key];
  return isNumber(value) ? value : defaultValue;
}

// Domain Calculations
export function calculateDomain(
  data: Record<string, unknown>[],
  key: string,
  padding = 0.05
): [number, number] {
  // Implementation details for finding min/max values with padding
}

// Color Utilities
export function createColorScale(
  domain: [number, number],
  range: string[]
): (value: number) => string {
  // Implementation of color interpolation
}

// Transformations for Chart Types
export function transformToScatterFormat(
  dataPoints: DataPoint[],
  valueMetric: string = 'amount'
): Array<{
  id: string;
  name: string;
  x: number;
  y: number;
  value: number;
  type: string;
  coordinates: { x: number; y: number };
}> {
  // Implementation details for scatter chart data transformation
}

export function transformToHeatMapFormat(
  gridCells: ResourceGridCell[],
  valueMetric: string = 'amount',
  selectedResourceType: string = 'all'
): Array<{
  x: number;
  y: number;
  value: number;
  resources: Array<{
    type: ResourceType;
    amount: number;
    quality?: number;
    accessibility?: number;
    estimatedValue?: number;
  }>;
}> {
  // Implementation details for heat map data transformation
}
```

### Scientific Transformations

Specialized utilities for scientific and statistical analysis:

```typescript
/**
 * Scientific Data Transformation Utilities
 *
 * This module provides specialized utilities for scientific data transformations
 * used in advanced analysis visualizations like prediction models, clustering, and
 * statistical analysis.
 */

// Time Series Analysis
export function transformTimeSeriesData(
  timePoints: number[] | string[],
  actualValues: number[],
  predictedValues?: number[],
  forecastValues?: number[]
): Array<{
  time: number | string;
  actual?: number;
  predicted?: number;
  forecast?: number;
}> {
  // Implementation details for time series transformation
}

export function calculateResiduals(actualValues: number[], predictedValues: number[]): number[] {
  // Calculate residuals (actual - predicted)
  const residuals: number[] = [];
  const minLength = Math.min(actualValues.length, predictedValues.length);

  for (let i = 0; i < minLength; i++) {
    residuals.push(actualValues[i] - predictedValues[i]);
  }

  return residuals;
}

// Statistical Analysis
export function calculateStatistics(
  data: Array<Record<string, unknown>>,
  variable: string
): {
  min: number;
  max: number;
  mean: number;
  median: number;
  standardDeviation: number;
  count: number;
  missing: number;
} {
  // Implementation details for statistical calculations
}

export function calculateCorrelationMatrix(
  data: Array<Record<string, unknown>>,
  variables: string[]
): Array<Array<number>> {
  // Implementation details for correlation matrix calculation
}

// Model Analysis
export function extractFeatureImportance(
  modelDetails: Record<string, unknown>,
  features: string[]
): Array<{ feature: string; importance: number }> {
  // Implementation details for extracting feature importance
}

export function isLinearRegressionModel(modelDetails: Record<string, unknown>): boolean {
  // Implementation details for identifying model type
}

// Clustering Analysis
export function calculateClusterCentroids(
  clusterPoints: Array<{
    cluster: number;
    features: Array<number | null>;
  }>,
  features: string[]
): Array<{
  cluster: number;
  centroid: number[];
  size: number;
}> {
  // Implementation details for calculating cluster centroids
}
```

### Filter Transformations

Utilities for filtering and transforming data for use in filter components:

```typescript
/**
 * Filter Transformation Utilities
 *
 * This module provides utilities for filtering and transforming data
 * for use in filter panels, search components, and data tables.
 */

// Filter Types
export type FilterOperator =
  | 'equals'
  | 'notEquals'
  | 'greaterThan'
  | 'lessThan'
  | 'contains'
  | 'notContains'
  | 'between'
  | 'in'
  | 'notIn'
  | 'exists'
  | 'notExists';

export interface Filter {
  field: string;
  operator: FilterOperator;
  value: string | number | boolean | string[] | [number, number];
}

export interface FilterGroup {
  type: 'and' | 'or';
  filters: Array<Filter | FilterGroup>;
}

// Filter Creation and Validation
export function createFilter(
  field: string,
  operator: FilterOperator,
  value: unknown
): Filter | null {
  // Implementation details for creating and validating filters
}

export function validateFilter(filter: unknown): filter is Filter {
  // Implementation details for validating filter objects
}

// Filter Formatting
export function formatFilterValue(
  value: string | number | boolean | string[] | [number, number]
): string {
  // Implementation details for formatting filter values for display
}

export function formatFilter(filter: Filter): string {
  // Implementation details for formatting entire filters
}

// Filtering Logic
export function applyFilter(item: Record<string, unknown>, filter: Filter): boolean {
  // Implementation details for applying a filter to an item
}

export function applyFilters(
  data: Array<Record<string, unknown>>,
  filters: Array<Filter>
): Array<Record<string, unknown>> {
  // Implementation details for applying multiple filters
}

export function applyComplexFilter(
  data: Array<Record<string, unknown>>,
  filterGroup: FilterGroup
): Array<Record<string, unknown>> {
  // Implementation details for applying complex filters with AND/OR logic
}

// Field Analysis
export function detectFieldTypes(
  data: Array<Record<string, unknown>>,
  sampleSize: number = 100
): Record<string, 'string' | 'number' | 'boolean' | 'date' | 'array' | 'object' | 'mixed'> {
  // Implementation details for detecting field types
}

export function getUniqueValues(
  data: Array<Record<string, unknown>>,
  field: string,
  limit: number = 100
): Array<string | number | boolean> {
  // Implementation details for getting unique values
}
```

## Common Transformation Patterns

### Safe Data Extraction Pattern

The system uses a consistent pattern for safely extracting values from potentially undefined objects:

```typescript
// Type guards ensure safe operations
if (isNumber(value)) {
  // It's safe to perform math operations
}

// Safe extraction functions with type guards and defaults
export function safelyExtractNumber(
  obj: Record<string, unknown> | null | undefined,
  key: string,
  defaultValue = 0
): number {
  if (!obj) return defaultValue;
  const value = obj[key];
  return isNumber(value) ? value : defaultValue;
}

// Safe nested path extraction
export function safelyExtractPath<T>(
  obj: Record<string, unknown> | null | undefined,
  path: string,
  defaultValue: T
): T {
  if (!obj) return defaultValue;

  const keys = path.split('.');
  let current: unknown = obj;

  for (const key of keys) {
    if (current === null || current === undefined || typeof current !== 'object') {
      return defaultValue;
    }
    current = (current as Record<string, unknown>)[key];
  }

  return current !== null && current !== undefined ? (current as T) : defaultValue;
}
```

### Data Transformation Pattern

The system follows a consistent pattern for transformations that convert from one data structure to another:

```typescript
// Step 1: Validate and extract source data
const sourceData = safelyExtractArray(result.data, 'items', []);

// Step 2: Process each item and map to new structure
const transformedData = sourceData.map(item => {
  return {
    // Extract and transform each required field
    id: safelyExtractString(item, 'id', ''),
    x: safelyExtractNumber(item, 'coordinates.x', 0),
    y: safelyExtractNumber(item, 'coordinates.y', 0),
    // Transform values as needed
    value: safelyExtractNumber(item, valueMetric, 0),
  };
});

// Step 3: Enrich with additional properties or metadata
return {
  transformedData,
  // Add metadata
  summary: safelyExtractString(result, 'summary', ''),
  metrics: safelyExtractObject(result, 'metrics', {}),
};
```

### Filter Application Pattern

The system implements a robust pattern for applying filters to data collections:

```typescript
// Single filter application
function applyFilter(item: Record<string, unknown>, filter: Filter): boolean {
  const value = safelyExtractPath(item, filter.field, null);

  // Apply operator-specific logic
  switch (filter.operator) {
    case 'equals':
      return value === filter.value;
    case 'greaterThan':
      return isNumber(value) && isNumber(filter.value) && value > filter.value;
    // Other operators...
  }
}

// Multiple filter application (AND logic)
function applyFilters(
  data: Array<Record<string, unknown>>,
  filters: Array<Filter>
): Array<Record<string, unknown>> {
  if (!filters.length) return data;

  return data.filter(item => {
    // All filters must pass (AND logic)
    return filters.every(filter => applyFilter(item, filter));
  });
}

// Complex filter application (AND/OR logic)
function applyFilterGroup(item: Record<string, unknown>, filterGroup: FilterGroup): boolean {
  if (filterGroup.type === 'and') {
    // AND logic - all filters must match
    return filterGroup.filters.every(filter => {
      if ('field' in filter) {
        return applyFilter(item, filter);
      } else {
        return applyFilterGroup(item, filter);
      }
    });
  } else {
    // OR logic - at least one filter must match
    return filterGroup.filters.some(filter => {
      if ('field' in filter) {
        return applyFilter(item, filter);
      } else {
        return applyFilterGroup(item, filter);
      }
    });
  }
}
```

## Integration Patterns

### Central Export Pattern

The system uses a centralized exports file to provide a clean API while maintaining code organization:

```typescript
// index.ts - Central exports with organized imports and exports

// Export all chart transformation utilities
export * from './chartTransforms';

// Export all scientific transformation utilities
export * from './scientificTransforms';

// Export all filter transformation utilities
export * from './filterTransforms';

// Re-export specific utilities with more descriptive names for discoverability
import { calculateDomain, calculateDomains } from './chartTransforms';
export { calculateDomain, calculateDomains };

// Color utilities
export { createColorScale, getResourceTypeColor, hexToRgb };

// Safe data extraction
import {
  safelyExtractArray,
  safelyExtractNumber,
  safelyExtractObject,
  safelyExtractPath,
  safelyExtractString,
} from './chartTransforms';
export {
  safelyExtractArray,
  safelyExtractNumber,
  safelyExtractObject,
  safelyExtractPath,
  safelyExtractString,
};
```

### Type-Safe Operations Pattern

The system implements robust type safety through type guards and generics:

```typescript
// Type guards for runtime type checking
export function isNumber(value: unknown): value is number {
  return typeof value === 'number' && !isNaN(value);
}

export function isString(value: unknown): value is string {
  return typeof value === 'string';
}

// Generic typing for better compiler integration
export function safelyExtractArray<T = unknown>(
  obj: Record<string, unknown> | null | undefined,
  key: string,
  defaultValue: T[] = []
): T[] {
  if (!obj) return defaultValue;
  const value = obj[key];
  return isArray<T>(value) ? value : defaultValue;
}
```

### Pipeline Pattern

The system allows for composing multiple transformations into data processing pipelines:

```typescript
// Example of transformation pipeline
function processAndVisualizeData(rawData) {
  // Step 1: Detect data types to inform transformations
  const fieldTypes = detectFieldTypes(rawData);

  // Step 2: Filter data to relevant subset
  const filteredData = applyFilters(rawData, [
    { field: 'type', operator: 'equals', value: 'energy' },
  ]);

  // Step 3: Calculate statistics for analysis
  const stats = calculateStatistics(filteredData, 'amount');

  // Step 4: Transform to visualization format
  const visualData = transformToScatterFormat(filteredData, 'amount');

  // Step 5: Calculate domains for axes
  const xDomain = calculateDomain(visualData, 'x');
  const yDomain = calculateDomain(visualData, 'y');

  // Return completed visualization data package
  return {
    data: visualData,
    domains: { x: xDomain, y: yDomain },
    stats,
  };
}
```

### Immutable Transformation Pattern

The system follows an immutable pattern where transformations create new data structures rather than modifying existing ones:

```typescript
// Immutable transformation example
export function calculateStatistics(data: Array<Record<string, unknown>>, variable: string) {
  // Extract values without modifying original data
  const values = data
    .map(item => safelyExtractNumber(item, variable, NaN))
    .filter(value => !isNaN(value));

  // Calculate statistics from extracted values
  const sum = values.reduce((acc, val) => acc + val, 0);
  const mean = sum / values.length;

  // Return new statistics object
  return {
    min: Math.min(...values),
    max: Math.max(...values),
    mean,
    median: calculateMedian(values),
    standardDeviation: calculateStandardDeviation(values, mean),
    count: values.length,
    missing: data.length - values.length,
  };
}
```

## Usage Patterns

- **Safe Data Handling**: All utilities handle null/undefined inputs gracefully
- **Consistent API**: Similar functions follow consistent naming and parameter patterns
- **Modular Architecture**: Split into specific domains (chart, scientific, filter) with focused functionality
- **Composable Functions**: Small, single-purpose functions that can be combined as needed
- **Generic Type Safety**: Generics and type guards ensure type safety throughout the system
- **Default Values**: All functions provide sensible defaults for optional parameters
- **Comprehensive Documentation**: JSDoc comments explain functionality and usage examples
- **Centralized Exports**: A unified API that organizes imports while maintaining clean code organization

## Effects System (#effects_system)

### Overview

The Effects System provides a comprehensive framework for creating, managing, and rendering visual effects, status effects, and combat effects within the game. It uses a modular approach with reusable components and utilities, ensuring consistent behavior and optimized rendering across different effect types.

## Core Components

### Effect Type Definitions

Central types that define the foundation of the effects system:

```typescript
/**
 * Base Effect Interface
 * Common properties for all effects in the game
 */
export interface BaseEffect extends Effect {
  /** Name of the effect */
  name: string;
  /** Description of what the effect does */
  description: string;
  /** Type of effect */
  type: EffectType;
}

/**
 * All possible effect types in the game
 */
export type EffectType =
  | CombatEffectType
  | StatusEffectType
  | VisualEffectType
  | EnvironmentalEffectType;

/**
 * Combat-related effect types
 */
export type CombatEffectType =
  | 'damage'
  | 'heal'
  | 'shield'
  | 'armor'
  | 'accuracy'
  | 'evasion'
  | 'critical'
  | 'resistance';

/**
 * Status-related effect types
 */
export type StatusEffectType =
  | 'stealth'
  | 'speed'
  | 'detection'
  | 'cloaking'
  | 'jamming'
  | 'scanning';

/**
 * Visual effect types
 */
export type VisualEffectType =
  | ResourceType.PLASMA
  | 'spark'
  | 'gauss'
  | 'explosive'
  | 'beam'
  | 'particle';

/**
 * Environmental effect types
 */
export type EnvironmentalEffectType = 'radiation' | 'emp' | 'gravity' | 'magnetic' | 'thermal';
```

### Visual Effect Base Class

Abstract class that all visual effects extend to ensure consistent behavior:

```typescript
export interface VisualEffectConfig {
  id?: string;
  position: Position;
  color?: string;
  duration?: number;
}

export abstract class VisualEffect {
  protected id: string;
  protected config: VisualEffectConfig;
  protected progress: number = 0;
  protected batchId: string | null = null;
  protected startTime: number;
  protected isComplete: boolean = false;

  constructor(config: VisualEffectConfig) {
    this.id = config.id || Math.random().toString(36).substring(7);
    this.config = config;
    this.startTime = Date.now();
  }

  public start(): void {
    this.onStart();
    console.warn(`[${this.getEffectType()}] Started effect ${this.id}`);
  }

  public update(): void {
    if (this.isComplete) return;

    const elapsed = Date.now() - this.startTime;
    const duration = this.config.duration || 1000;
    this.progress = Math.min(elapsed / duration, 1);

    this.onUpdate(this.progress);

    if (this.progress >= 1) {
      this.complete();
    }
  }

  public render(batcher: RenderBatcher): void {
    if (!this.batchId) {
      this.batchId = batcher.createBatch(this.getEffectType());
    }
    this.updateRendering(batcher);
  }

  public complete(): void {
    if (this.isComplete) return;
    this.isComplete = true;
    this.onComplete();
    console.warn(`[${this.getEffectType()}] Completed effect ${this.id}`);
  }

  protected abstract getEffectType(): string;
  protected abstract onStart(): void;
  protected abstract onUpdate(progress: number): void;
  protected abstract updateRendering(batcher: RenderBatcher): void;
  protected abstract onComplete(): void;
  protected abstract onReset(): void;
}
```

### Effect Utility Functions

Utilities for creating and managing effects:

```typescript
/**
 * Creates a new base effect with default values
 */
export function createEffect(
  id: string,
  name: string,
  type: EffectType,
  magnitude: number,
  description: string,
  options: Partial<BaseEffect> = {}
): BaseEffect {
  return {
    id,
    name,
    type,
    magnitude,
    description,
    active: true,
    duration: options?.duration ?? 0,
    ...options,
  };
}

/**
 * Creates a weapon effect from a base effect
 */
export function createWeaponEffect(
  baseEffect: BaseEffect,
  strength: number,
  type: 'damage' | 'area' | 'status' = 'damage',
  duration: number = 0
): WeaponEffect {
  return {
    ...baseEffect,
    type,
    strength,
    duration,
  };
}

/**
 * Adds an effect to a stack
 */
export function addEffect(stack: EffectStack, effect: BaseEffect): EffectStack {
  return {
    ...stack,
    effects: [...stack.effects, effect],
    history: [
      ...stack.history,
      {
        effectId: effect.id,
        timestamp: Date.now(),
        action: 'applied',
      },
    ],
  };
}

/**
 * Type guard for weapon effects
 */
export function isWeaponEffect(effect: BaseEffect | Effect): effect is WeaponEffect {
  return (
    'type' in effect &&
    (effect.type === 'damage' || effect.type === 'area' || effect.type === 'status') &&
    'strength' in effect &&
    typeof effect.strength === 'number'
  );
}
```

## Component Effect Types

The effects system includes various specialized effect components:

### Weapon Effects

Visual effects for different weapon types, including machine guns, railguns, lasers, and plasma weapons.

### Ship Effects

Effects for ship movement, thrusters, shields, and engine trails.

### Environmental Effects

Effects for world objects like habitable planets, resource processing, and exploration hubs.

### Combat Effects

Visual representations of combat actions, explosions, and shield impacts.

## Design Patterns

### Template Method Pattern

The VisualEffect base class uses the template method pattern to define the skeleton of an effect's lifecycle, with subclasses implementing specific behavior.

### Strategy Pattern

Different rendering strategies are selected based on the effect type, allowing for specialized rendering approaches.

### Factory Method Pattern

Utility functions act as factories to create different types of effects with consistent configuration.

### Composite Pattern

Effects can be composed into effect stacks, allowing multiple effects to be applied to a single target.

## Integration Patterns

### WebGL Integration

Effects use Three.js and WebGL for high-performance rendering, with specialized shaders for complex visual effects.

### Render Batching

Effects use a batching system to optimize rendering performance by grouping similar rendering operations.

### React Integration

Effects are provided as React components for easy integration within the UI component hierarchy.

## Usage Patterns

- **Effect Lifecycle**: Effects have consistent start, update, render, complete, and reset stages
- **Effect Stacking**: Multiple effects can be applied to a single target and managed as a stack
- **Polymorphic Rendering**: Different effect types can be rendered differently while sharing core logic
- **Performance Optimization**: Effects use render batching and WebGL for efficient rendering
- **CSS Integration**: Some effects use CSS animations for DOM-based visual effects

## Web Worker System (#web_worker)

### Overview

The Web Worker System provides a multi-threading architecture that offloads computationally intensive tasks from the main UI thread to background worker threads. This ensures the game remains responsive even when performing complex calculations on large datasets. The system implements structured message passing, task prioritization, and specialized workers for different domains.

## Core Components

### Base Worker Implementation

The foundational worker structure that defines common patterns:

```typescript
interface WorkerMessage {
  taskId: string;
  type: string;
  data: unknown;
}

interface TaskHandler {
  (data: unknown, reportProgress: (progress: number) => void): Promise<unknown>;
}

const taskHandlers = new Map<string, TaskHandler>();

// Register task handlers
taskHandlers.set('heavyComputation', async (data: unknown, reportProgress) => {
  // Example heavy computation task
  const iterations = (data as { iterations: number }).iterations;
  let result = 0;

  for (let i = 0; i < iterations; i++) {
    result += Math.sqrt(i);
    if (i % (iterations / 100) === 0) {
      reportProgress((i / iterations) * 100);
    }
  }

  return result;
});

// Handle messages from the main thread
self.onmessage = async (event: MessageEvent<WorkerMessage>) => {
  const { taskId, type, data } = event?.data;

  try {
    const handler = taskHandlers.get(type);
    if (!handler) {
      throw new Error(`Unknown task type: ${type}`);
    }

    // Execute task with progress reporting
    const result = await handler(data, (progress: number) => {
      self.postMessage({ taskId, type: 'progress', data: progress });
    });

    // Send result back to main thread
    self.postMessage({ taskId, type: 'result', data: result });
  } catch (error) {
    // Send error back to main thread
    self.postMessage({
      taskId,
      type: 'error',
      data: error instanceof Error ? error.message : String(error),
    });
  }
};
```

### Data Processing Worker

Specialized worker for handling data analysis and transformations:

```typescript
/**
 * Web Worker for handling intensive data processing operations
 *
 * This worker offloads computationally expensive operations from the main thread,
 * ensuring the UI remains responsive even when processing large datasets.
 */

// Message types for worker communication
export enum WorkerMessageType {
  PROCESS_CLUSTERING = 'PROCESS_CLUSTERING',
  PROCESS_PREDICTION = 'PROCESS_PREDICTION',
  PROCESS_RESOURCE_MAPPING = 'PROCESS_RESOURCE_MAPPING',
  TRANSFORM_DATA = 'TRANSFORM_DATA',
  DATA_SORTING = 'DATA_SORTING',
  DATA_FILTERING = 'DATA_FILTERING',
  CALCULATE_STATISTICS = 'CALCULATE_STATISTICS',
}

// Response interface
interface WorkerResponse {
  id: string;
  result: unknown;
  error?: string;
}

// Listen for messages from the main thread
self.addEventListener('message', (event: MessageEvent<WorkerMessage>) => {
  const { type, id, payload } = event?.data ?? {};

  try {
    let result;

    switch (type) {
      case WorkerMessageType.PROCESS_CLUSTERING:
        result = processClustering(payload);
        break;

      case WorkerMessageType.PROCESS_PREDICTION:
        result = processPrediction(payload);
        break;

      // Other processing methods...

      default:
        throw new Error(`Unknown message type: ${type}`);
    }

    // Send the successful result back to the main thread
    const response: WorkerResponse = {
      id,
      result,
    };

    self.postMessage(response);
  } catch (error) {
    // Send error back to main thread
    const response: WorkerResponse = {
      id,
      result: null,
      error: error instanceof Error ? error.message : String(error),
    };

    self.postMessage(response);
  }
});
```

### Combat Worker

Worker for processing combat simulations and related calculations:

```typescript
// Combat Web Worker
import { QuadTree } from '../lib/optimization/QuadTree';
import { CombatUnit } from '../types/combat/CombatTypes';
import { Hazard } from '../types/combat/HazardTypes';
import { Position } from '../types/core/GameTypes';

interface WorkerMessage {
  type: string;
  units: CombatUnit[];
  hazards: Hazard[];
  worldBounds: { width: number; height: number };
}

interface BatchedUpdate {
  weaponFires: Array<{
    weaponId: string;
    targetId: string;
    weaponType: string;
  }>;
  unitMoves: Array<{
    unitId: string;
    position: Position;
  }>;
}

// Combat state
let quadTree: QuadTree;
let lastUpdate = 0;
const UPDATE_INTERVAL = 16; // ~60fps
const BATCH_SIZE = 10;
let pendingUpdates: BatchedUpdate = {
  weaponFires: [],
  unitMoves: [],
};

// Handle combat calculations
self.onmessage = (e: MessageEvent<WorkerMessage>) => {
  const { type, units, hazards, worldBounds } = e.data;

  if (type === 'UPDATE') {
    const now = performance.now();
    if (now - lastUpdate < UPDATE_INTERVAL) {
      return; // Skip update if too soon
    }
    lastUpdate = now;

    // Initialize or clear quadtree
    if (!quadTree) {
      quadTree = new QuadTree({ x: 0, y: 0, width: worldBounds.width, height: worldBounds.height });
    } else {
      quadTree.clear();
    }

    // Insert units into quadtree
    units.forEach(unit => {
      quadTree.insert({
        id: unit.id,
        position: unit.position,
      });
    });

    // Process units in batches
    for (let i = 0; i < units.length; i += BATCH_SIZE) {
      const batch = units.slice(i, i + BATCH_SIZE);
      processBatch(batch, hazards);
    }

    // Send batched updates
    if (pendingUpdates.weaponFires.length > 0 || pendingUpdates.unitMoves.length > 0) {
      self.postMessage({
        type: 'BATCH_UPDATE',
        updates: pendingUpdates,
      });

      // Clear pending updates
      pendingUpdates = {
        weaponFires: [],
        unitMoves: [],
      };
    }
  }
};
```

### Resource Flow Worker

Worker for processing resource flow calculations:

```typescript
import { ResourceType } from './../types/resources/ResourceTypes';
/**
 * ResourceFlowWorker.ts
 *
 * Web Worker implementation for offloading resource flow calculations
 * This worker handles heavy computational tasks from the ResourceFlowManager
 * to prevent UI thread blocking for large resource networks.
 */

import {
  FlowConnection,
  FlowNode,
  ResourceState,
  ResourceTransfer,
} from '../types/resources/ResourceTypes';

// Message types for communication with the main thread
type WorkerMessageType =
  | 'OPTIMIZE_FLOWS'
  | 'BATCH_PROCESS'
  | 'CALCULATE_RESOURCE_BALANCE'
  | 'OPTIMIZE_FLOW_RATES'
  | 'CALCULATE_EFFICIENCY';

// Input data structure for worker tasks
interface WorkerInput {
  type: WorkerMessageType;
  data: unknown;
  taskId: string;
}

// Output data structure for worker results
interface WorkerOutput {
  type: WorkerMessageType;
  result: unknown;
  taskId: string;
  executionTimeMs: number;
  error?: string;
}

// Self reference for the worker context
const ctx: Worker = self as unknown as Worker;

// Handle messages from main thread
ctx.addEventListener('message', (event: MessageEvent<WorkerInput>) => {
  const { type, data, taskId } = event?.data;
  const startTime = Date.now();

  let result: unknown;

  try {
    switch (type) {
      case 'OPTIMIZE_FLOWS':
        // Implementation of flow optimization
        break;
      case 'BATCH_PROCESS':
        // Implementation of batch processing
        break;
      // Other cases...
    }

    // Send result back to main thread
    const output: WorkerOutput = {
      type,
      result,
      taskId,
      executionTimeMs: Date.now() - startTime,
    };

    ctx.postMessage(output);
  } catch (error) {
    // Send error back to main thread
    const output: WorkerOutput = {
      type,
      result: null,
      taskId,
      executionTimeMs: Date.now() - startTime,
      error: error instanceof Error ? error.message : String(error),
    };

    ctx.postMessage(output);
  }
});
```

## Communication Patterns

### Message Passing Protocol

The workers use a consistent message passing protocol with structured messages:

```typescript
// Request message format
interface WorkerMessage {
  taskId: string; // Unique ID to match request with response
  type: string; // Task type identifier
  data: unknown; // Task-specific payload
}

// Response message format
interface WorkerResponse {
  id: string; // Matching task ID from request
  result: unknown; // Result data
  error?: string; // Optional error message
}
```

### Type Safety Through Type Guards

The system implements type guards to ensure type safety between worker threads:

```typescript
function isOptimizeFlowsData(data: unknown): data is OptimizeFlowsData {
  return (
    typeof data === 'object' &&
    data !== null &&
    'nodes' in data &&
    'connections' in data &&
    'resourceStates' in data &&
    Array.isArray((data as OptimizeFlowsData).nodes) &&
    Array.isArray((data as OptimizeFlowsData).connections)
  );
}

// Usage in worker
if (!isOptimizeFlowsData(data)) {
  throw new Error('Invalid data format for optimize flows operation');
}
```

### Performance Optimization Techniques

The workers implement various optimization patterns:

```typescript
// Batched processing
for (let i = 0; i < units.length; i += BATCH_SIZE) {
  const batch = units.slice(i, i + BATCH_SIZE);
  processBatch(batch, hazards);
}

// Rate limiting
const now = performance.now();
if (now - lastUpdate < UPDATE_INTERVAL) {
  return; // Skip update if too soon
}
lastUpdate = now;

// Spatial indexing
quadTree = new QuadTree({ x: 0, y: 0, width: worldBounds.width, height: worldBounds.height });
units.forEach(unit => {
  quadTree.insert({
    id: unit.id,
    position: unit.position,
  });
});
```

### Progress Reporting

The system supports progress reporting for long-running tasks:

```typescript
const result = await handler(data, (progress: number) => {
  self.postMessage({ taskId, type: 'progress', data: progress });
});
```

## Integration Patterns

### Worker Manager Pattern

The system uses a manager class to coordinate worker interactions:

```typescript
export class WorkerManager {
  private workers: Map<string, Worker> = new Map();
  private pendingTasks: Map<
    string,
    {
      resolve: (value: unknown) => void;
      reject: (reason: unknown) => void;
      taskType: string;
    }
  > = new Map();

  private nextTaskId = 0;

  constructor() {
    this.initializeWorkers();
  }

  private initializeWorkers() {
    this.workers.set('data', new Worker(new URL('./DataProcessingWorker.ts', import.meta.url)));
    this.workers.set('combat', new Worker(new URL('./combatWorker.ts', import.meta.url)));
    this.workers.set('resource', new Worker(new URL('./ResourceFlowWorker.ts', import.meta.url)));

    // Set up message handlers
    this.workers.forEach((worker, key) => {
      worker.onmessage = this.handleWorkerMessage.bind(this);
    });
  }

  private handleWorkerMessage(event: MessageEvent) {
    const { taskId, type, data, error } = event.data;
    const pendingTask = this.pendingTasks.get(taskId);

    if (!pendingTask) return;

    if (type === 'error' || error) {
      pendingTask.reject(error || data);
    } else if (type === 'progress') {
      // Handle progress updates
    } else {
      pendingTask.resolve(data);
    }

    // Clean up completed tasks
    if (type !== 'progress') {
      this.pendingTasks.delete(taskId);
    }
  }

  public async runTask(workerType: string, taskType: string, data: unknown): Promise<unknown> {
    const worker = this.workers.get(workerType);
    if (!worker) {
      throw new Error(`No worker found for type: ${workerType}`);
    }

    const taskId = `task_${++this.nextTaskId}`;

    // Create promise for task completion
    const taskPromise = new Promise((resolve, reject) => {
      this.pendingTasks.set(taskId, { resolve, reject, taskType });
    });

    // Send task to worker
    worker.postMessage({ taskId, type: taskType, data });

    return taskPromise;
  }
}
```

### Worker Lifecycle Management

The system manages worker lifecycles efficiently:

```typescript
export class WebWorkerService {
  private workerPool: Worker[] = [];
  private taskQueue: Task[] = [];
  private isProcessing: boolean = false;

  constructor(private maxWorkers: number = navigator.hardwareConcurrency || 4) {
    // Initialize worker pool
  }

  public addTask(task: Task): Promise<unknown> {
    return new Promise((resolve, reject) => {
      this.taskQueue.push({
        ...task,
        resolve,
        reject,
      });

      this.processQueue();
    });
  }

  private processQueue() {
    if (this.isProcessing) return;
    this.isProcessing = true;

    while (this.taskQueue.length > 0 && this.workerPool.length < this.maxWorkers) {
      // Create additional workers when needed
      const worker = new Worker(new URL('./worker.ts', import.meta.url));
      this.workerPool.push(worker);
    }

    // Assign tasks to available workers
    // ...

    this.isProcessing = false;
  }

  public dispose() {
    // Terminate all workers when no longer needed
    this.workerPool.forEach(worker => worker.terminate());
    this.workerPool = [];
    this.taskQueue = [];
  }
}
```

## Multi-Threading Architecture

### Worker Specialization

The system uses different worker types specialized for specific computational domains:

1. **Data Processing Worker**: Handles data transformations, clustering, and statistics
2. **Combat Worker**: Processes real-time combat simulations and spatial calculations
3. **Resource Flow Worker**: Manages resource flow optimization and network analysis

### Shared Memory (Future Implementation)

```typescript
// Example of future SharedArrayBuffer implementation for high-performance data sharing
export class SharedMemoryWorker {
  private sharedBuffer: SharedArrayBuffer | null = null;
  private sharedArray: Float32Array | null = null;
  private worker: Worker | null = null;

  public initialize(size: number): void {
    // Create shared memory buffer
    this.sharedBuffer = new SharedArrayBuffer(size * Float32Array.BYTES_PER_ELEMENT);
    this.sharedArray = new Float32Array(this.sharedBuffer);

    // Initialize worker with shared memory reference
    this.worker = new Worker(new URL('./SharedMemoryWorker.ts', import.meta.url));
    this.worker.postMessage({
      type: 'INIT',
      buffer: this.sharedBuffer,
    });
  }

  public updateData(index: number, value: number): void {
    // Update shared memory directly
    if (this.sharedArray) {
      Atomics.store(this.sharedArray, index, value);
    }
  }
}
```

### Web Worker Limitations Management

```typescript
export class WorkerCapabilityManager {
  private hasSharedArrayBufferSupport: boolean;
  private maxWorkerCount: number;

  constructor() {
    // Detect platform capabilities
    this.hasSharedArrayBufferSupport = typeof SharedArrayBuffer !== 'undefined';
    this.maxWorkerCount = navigator.hardwareConcurrency || 4;
  }

  public createOptimalWorker<T>(url: string, fallbackImplementation: () => T): Worker | T {
    try {
      return new Worker(url);
    } catch (e) {
      // Fall back to main thread implementation if workers aren't supported
      return fallbackImplementation();
    }
  }
}
```

## Usage Patterns

- **Task Offloading**: Computationally intensive tasks are moved off the main thread to maintain UI responsiveness
- **Message-Based Communication**: Structured message passing for type-safe communication between threads
- **Batch Processing**: Large datasets are processed in manageable chunks to optimize performance
- **Progress Reporting**: Long-running tasks provide progress updates to the main thread
- **Error Handling**: Structured error reporting and recovery mechanisms
- **Spatial Optimization**: Combat calculations use spatial indexing via QuadTree for efficient neighbor finding
- **Rate Limiting**: Update frequencies are controlled to optimize performance
- **Resource Management**: Workers are created, reused, and terminated based on application needs
- **Type Safety**: TypeScript interfaces and type guards ensure type safety across thread boundaries

## FACTORY SYSTEM (#factory_system)

### Core Architecture

The Factory System provides a standardized approach for creating and configuring complex game entities using the Factory Pattern. The system leverages singleton factories with consistent instantiation patterns and robust type validation.

```typescript
// src/factories/ships/ShipClassFactory.ts

export class ShipClassFactory {
  private static instance: ShipClassFactory;

  // Private constructor ensures singleton pattern
  private constructor() {}

  // Static getter for the singleton instance
  public static getInstance(): ShipClassFactory {
    if (!ShipClassFactory.instance) {
      ShipClassFactory.instance = new ShipClassFactory();
    }
    return ShipClassFactory.instance;
  }

  // Factory methods for creating ship instances
  public createShip(
    shipClass: FactionShipClass,
    factionId: FactionId,
    position: Position,
    formation?: { type: 'offensive' | 'defensive' | 'balanced'; spacing: number; facing: number }
  ): CombatUnit {
    // Implementation details...
  }

  // Factory methods for creating collections of entities
  public createFleet(
    factionId: FactionId,
    shipClasses: FactionShipClass[],
    position: Position,
    formation: { type: 'offensive' | 'defensive' | 'balanced'; spacing: number; facing: number }
  ): CombatUnit[] {
    // Implementation details...
  }
}

// Exported instance for convenient access throughout the application
export const shipClassFactory = ShipClassFactory.getInstance();
```

### Factory Method Patterns

The system employs several factory method patterns to create entities with consistent configuration:

1. **Direct Entity Creation**: Methods that create individual game entities with properly initialized state.

```typescript
// Ship creation with proper initialization
public createShip(shipClass: FactionShipClass, factionId: FactionId, position: Position): CombatUnit {
  const stats = SHIP_STATS[shipClass];
  if (!stats) {
    throw new Error(`Invalid ship class: ${shipClass}`);
  }

  // Initialize components with proper state
  const initializedWeaponMounts = stats.weapons.map(mount => this._createWeaponMount(mount));

  // Return fully configured entity
  return {
    id: `${factionId}-${shipClass}-${Date.now()}`,
    type: shipClass,
    health: stats.health,
    // ...other properties
  };
}
```

2. **Entity Collection Creation**: Methods that create collections of related entities with proper spatial and relational configuration.

```typescript
// Fleet creation with formation logic
public createFleet(factionId: FactionId, shipClasses: FactionShipClass[], position: Position): CombatUnit[] {
  return shipClasses.map((shipClass, index) => {
    // Calculate position based on formation
    const shipPosition = calculateFormationPosition(position, index, formation);

    // Create individual ship with proper position
    return this.createShip(shipClass, factionId, shipPosition);
  });
}
```

3. **Hook Factory Pattern**: Factory functions that create specialized React hooks with pre-configured behaviors.

```typescript
// Factory function that creates data fetching hooks
export function createDataFetchHook<T, P extends any[] = []>(
  fetchFn: (...args: P) => Promise<T>,
  defaultOptions: DataFetchOptions = {}
): (...args: P) => DataFetchResult<T> {
  return (...args: P): DataFetchResult<T> => {
    // Hook implementation with standardized state management
    const [data, setData] = useState<T | null>(null);
    const [isLoading, setIsLoading] = useState<boolean>(defaultOptions.fetchOnMount !== false);
    // ...additional state and logic

    return {
      data,
      isLoading,
      // ...other return values
    };
  };
}
```

### Factory Creation Workflows

The system uses consistent patterns for factory creation and access:

1. **Singleton Factory Initialization**: Factories are implemented as singletons with private constructors and static getInstance methods.

```typescript
// Singleton pattern implementation
export class EntityFactory<T> {
  private static instance: EntityFactory<T>;

  private constructor() {}

  public static getInstance(): EntityFactory<T> {
    if (!EntityFactory.instance) {
      EntityFactory.instance = new EntityFactory<T>();
    }
    return EntityFactory.instance;
  }
}
```

2. **Factory Instance Export**: Factory instances are exported at the module level for convenient access.

```typescript
// Export singleton instance
export const shipClassFactory = ShipClassFactory.getInstance();
```

3. **Factory Method Chaining**: Factory methods support method chaining for complex entity creation.

```typescript
// Method chaining example
shipClassFactory
  .createShip(shipClass, factionId, position)
  .attachWeapons(weaponConfigs)
  .setAIBehavior(behaviorProfile);
```

### Integration Patterns

The Factory System integrates with other systems using these patterns:

1. **Configuration Integration**: Factories consume configuration objects to create properly configured entities.

```typescript
// Integration with configuration system
const stats = SHIP_STATS[shipClass];
```

2. **Type System Integration**: Factories leverage the type system for validation and entity structure.

```typescript
// Type validation through type system
export function createLifecycleHook<TProps = Record<string, unknown>>(
  options: LifecycleOptions<TProps>
): (props: TProps) => LifecycleResult {
  // Implementation details...
}
```

3. **Component System Integration**: UI component factories integrate with the React component system.

```typescript
// Chart component factory example
const CanvasChartFactory: React.FC<CanvasChartFactoryProps> = ({
  data,
  type,
  options,
  // ...other props
}) => {
  // Factory logic to create the appropriate chart component
  switch (type) {
    case ChartType.LINE:
      return <CanvasLineChart data={data} options={options} />;
    case ChartType.BAR:
      return <CanvasBarChart data={data} options={options} />;
    // Other chart types...
    default:
      throw new Error(`Unsupported chart type: ${type}`);
  }
};
```

// ... existing code ...

## REGISTRY SYSTEM (#registry_system)

### Core Architecture

The Registry System provides a centralized repository for game data with type-safe access patterns, event-driven updates, and integration with multiple game systems. The system serves as a single source of truth for critical game data.

```typescript
// src/registry/ResourceRegistry.ts

export class ResourceRegistry {
  private static _instance: ResourceRegistry | null = null;

  // Storage for resource metadata
  private resourceMetadata: Map<ResourceType, ExtendedResourceMetadata> = new Map();

  // Indexes for efficient querying
  private resourcesByCategory: Map<ResourceCategory, Set<ResourceType>> = new Map();
  private resourcesByTag: Map<string, Set<ResourceType>> = new Map();
  private resourcesByQuality: Map<ResourceQuality, Map<ResourceType, number>> = new Map();

  // Relationship mapping
  private conversionRates: Map<ResourceType, Map<ResourceType, number>> = new Map();

  // Event handling
  private listeners: Map<RegistryEventType, Set<(data: RegistryEventData) => void>> = new Map();
  private eventEmitter: EventEmitter<ResourceRegistryEvent>;

  // Singleton access
  public static getInstance(): ResourceRegistry {
    if (!ResourceRegistry._instance) {
      ResourceRegistry._instance = new ResourceRegistry();
    }
    return ResourceRegistry._instance;
  }

  private constructor() {
    this.eventEmitter = new EventEmitter<ResourceRegistryEvent>();
    this.initializeRegistry();
  }

  // Other methods...
}
```

### Registry Patterns

The Registry System implements several core patterns for efficient data management:

1. **Centralized Data Storage**: The registry provides a unified interface for storing and retrieving data.

```typescript
// Accessing resource metadata
public getResourceMetadata(resourceType: ResourceType): ExtendedResourceMetadata | undefined {
  return this.resourceMetadata.get(resourceType);
}

// Retrieving all registered resource types
public getAllResourceTypes(): ResourceType[] {
  return Array.from(this.resourceMetadata.keys());
}
```

2. **Indexed Lookup**: The registry maintains multiple indexes for efficient data retrieval.

```typescript
// Retrieving resources by category
public getResourcesByCategory(category: ResourceCategory): ResourceType[] {
  const resourceSet = this.resourcesByCategory.get(category);
  return resourceSet ? Array.from(resourceSet) : [];
}

// Retrieving resources by tag
public getResourcesByTag(tag: string): ResourceType[] {
  const resourceSet = this.resourcesByTag.get(tag);
  return resourceSet ? Array.from(resourceSet) : [];
}
```

3. **Relationship Management**: The registry maintains relationships between entities.

```typescript
// Setting conversion rates between resources
public setConversionRate(sourceType: ResourceType, targetType: ResourceType, rate: number): void {
  if (!this.conversionRates.has(sourceType)) {
    this.conversionRates.set(sourceType, new Map());
  }

  this.conversionRates.get(sourceType)!.set(targetType, rate);

  // Emit event for subscribers
  this.emit('conversionRateChanged', {
    sourceType,
    targetType,
    rate
  });
}

// Getting all sources that can convert to a target resource
public findConversionSources(targetType: ResourceType): Map<ResourceType, number> {
  const sources = new Map<ResourceType, number>();

  for (const [sourceType, conversions] of this.conversionRates.entries()) {
    const rate = conversions.get(targetType);
    if (rate !== undefined) {
      sources.set(sourceType, rate);
    }
  }

  return sources;
}
```

### Registration Workflows

The Registry System provides consistent workflows for registration and management:

1. **Type-Safe Registration**: Registering new entities with type validation.

```typescript
// Registering a new resource
public registerResource(options: ResourceRegistrationOptions): boolean {
  const { metadata, overrideExisting = false } = options;
  const { type, category } = metadata;

  // Validate if resource already exists
  if (this.resourceMetadata.has(type) && !overrideExisting) {
    console.warn(`Resource type ${type} is already registered`);
    return false;
  }

  // Add to main registry
  this.resourceMetadata.set(type, metadata);

  // Update indexes
  if (!this.resourcesByCategory.has(category)) {
    this.resourcesByCategory.set(category, new Set());
  }
  this.resourcesByCategory.get(category)!.add(type);

  // Add to tag index
  for (const tag of metadata.tags) {
    if (!this.resourcesByTag.has(tag)) {
      this.resourcesByTag.set(tag, new Set());
    }
    this.resourcesByTag.get(tag)!.add(type);
  }

  // Emit event
  this.emit('resourceRegistered', { resourceType: type, metadata });

  return true;
}
```

2. **Metadata Updates**: Updating entity metadata with event notifications.

```typescript
// Updating resource metadata
public updateResourceMetadata(
  resourceType: ResourceType,
  updates: Partial<ExtendedResourceMetadata>
): boolean {
  const metadata = this.resourceMetadata.get(resourceType);
  if (!metadata) {
    return false;
  }

  // Apply updates
  Object.assign(metadata, updates);

  // Update indexes if necessary
  if (updates.category && updates.category !== metadata.category) {
    // Update category index
    // ...
  }

  // Emit event
  this.emit('resourceMetadataUpdated', { resourceType, updates });

  return true;
}
```

3. **Data Import/Export**: Serializing and deserializing registry data.

```typescript
// Exporting registry data
public exportRegistryData(): {
  resources: Record<string, ExtendedResourceMetadata>;
  conversionRates: Record<string, Record<string, number>>;
} {
  const resources: Record<string, ExtendedResourceMetadata> = {};
  const conversionRates: Record<string, Record<string, number>> = {};

  // Export resources
  for (const [type, metadata] of this.resourceMetadata.entries()) {
    resources[type] = { ...metadata };
  }

  // Export conversion rates
  for (const [sourceType, targets] of this.conversionRates.entries()) {
    conversionRates[sourceType] = {};
    for (const [targetType, rate] of targets.entries()) {
      conversionRates[sourceType][targetType] = rate;
    }
  }

  return { resources, conversionRates };
}
```

### Integration Patterns

The Registry System integrates with other systems through several patterns:

1. **Event-Driven Integration**: The registry uses events to notify subscribers of changes.

```typescript
// Subscribing to registry events
public subscribe(
  eventType: RegistryEventType,
  callback: (data: RegistryEventData) => void
): () => void {
  if (!this.listeners.has(eventType)) {
    this.listeners.set(eventType, new Set());
  }

  this.listeners.get(eventType)!.add(callback);

  // Return unsubscribe function
  return () => {
    const callbacks = this.listeners.get(eventType);
    if (callbacks) {
      callbacks.delete(callback);
    }
  };
}

// Emitting events to subscribers
private emit(eventType: RegistryEventType, data: RegistryEventData): void {
  const callbacks = this.listeners.get(eventType);
  if (callbacks) {
    callbacks.forEach(callback => {
      try {
        callback(data);
      } catch (error) {
        console.error(`Error in registry event handler for ${eventType}:`, error);
      }
    });
  }

  // Also emit through the event emitter
  this.eventEmitter.emit({
    type: eventType,
    data,
    timestamp: Date.now()
  });
}
```

2. **System Bridging**: Dedicated integration classes bridge between systems with different data models.

```typescript
// ResourceRegistryIntegration.ts
export class ResourceRegistryIntegration {
  private static _instance: ResourceRegistryIntegration | null = null;
  private registry: ResourceRegistry;

  // Singleton access
  public static getInstance(): ResourceRegistryIntegration {
    if (!ResourceRegistryIntegration._instance) {
      ResourceRegistryIntegration._instance = new ResourceRegistryIntegration();
    }
    return ResourceRegistryIntegration._instance;
  }

  // Synchronizing with other managers
  public syncResourceAvailability(resourceFlowManager: ResourceFlowManager): void {
    const resourceStates = resourceFlowManager.getAllResourceStates?.();
    if (!resourceStates) {
      return;
    }

    // Process and synchronize resource states
    // ...
  }

  // Translating between string-based and enum-based resource types
  public getResourceMetadata(resourceType: ResourceType | string): unknown {
    // Convert string to enum if needed
    const actualType =
      typeof resourceType === 'string'
        ? ResourceTypeConverter.convertToEnum(resourceType)
        : resourceType;

    return this.registry.getResourceMetadata(actualType);
  }
}
```

3. **Dependency Injection**: Registry instances are provided to dependent systems.

```typescript
// In a service or manager constructor
constructor(private registry: ResourceRegistry = ResourceRegistry.getInstance()) {
  // Subscribe to relevant events
  this.registry.subscribe('resourceRegistered', this.handleResourceRegistered);
  this.registry.subscribe('conversionRateChanged', this.handleConversionRateChanged);
}
```

// ... existing code ...

## ENTITY POOLING SYSTEM (#entity_pooling_system)

### Core Architecture

The Entity Pooling System provides a memory-efficient approach to managing dynamic game entities through object pooling to reduce garbage collection and improve performance. The system pre-allocates and reuses entity instances instead of creating and destroying them.

```typescript
// src/lib/optimization/EntityPool.ts

export interface PooledEntity {
  reset(): void;
}

/**
 * Generic entity pool for efficient object reuse
 */
export class EntityPool<T extends PooledEntity> extends EventEmitter<PoolEvent<T>> {
  // Available entities ready for use
  private available: T[];

  // Currently active entities
  private inUse: Set<T>;

  // Factory function for creating new entities
  private factory: () => T;

  // Pool configuration
  private _maxSize: number;
  private _expandSize: number;

  constructor(
    factory: () => T,
    initialSize: number,
    maxSize: number = 1000,
    expandSize: number = 50
  ) {
    super();
    this.factory = factory;
    this._maxSize = maxSize;
    this._expandSize = expandSize;
    this.available = [];
    this.inUse = new Set();

    // Pre-allocate initial pool
    for (let i = 0; i < initialSize; i++) {
      this.available.push(factory());
    }
  }

  // Main pool methods...
}
```

### Object Pooling Patterns

The Entity Pooling System implements several core patterns for efficient memory management:

1. **Pre-allocation and Reuse**: The system pre-allocates entities and reuses them instead of creating new instances.

```typescript
// Get an entity from the pool
public acquire(): T | undefined {
  let entity: T;

  // Use an available entity if possible
  if (this.available.length > 0) {
    entity = this.available.pop()!;
  } else {
    // Check if we've reached the maximum pool size
    const totalEntities = this.getTotalCount();
    if (totalEntities >= this._maxSize) {
      console.warn(
        `[EntityPool] Maximum pool size (${this._maxSize}) reached, cannot create more entities`
      );
      return undefined;
    }

    // Expand the pool if necessary
    if (this.available.length === 0 && totalEntities < this._maxSize) {
      this.expandPool();
      entity = this.available.pop()!;
    }
  }

  // Mark as in use and return
  this.inUse.add(entity);

  // Emit event
  this.emit({
    type: 'entityActivated',
    data: { entity }
  });

  return entity;
}

// Return an entity to the pool
public release(entity: T): void {
  // Ensure entity is actually in use
  if (!this.inUse.has(entity)) {
    console.warn('[EntityPool] Attempted to release an entity not in use');
    return;
  }

  // Reset the entity and add back to available pool
  entity.reset();
  this.inUse.delete(entity);
  this.available.push(entity);

  // Emit event
  this.emit({
    type: 'entityDeactivated',
    data: { entity }
  });
}
```

2. **Dynamic Pool Expansion**: The system expands the pool size when needed while respecting memory constraints.

```typescript
// Expand the pool by creating new entities
private expandPool(): void {
  const totalEntities = this.getTotalCount();
  const expandSize = Math.min(this._expandSize, this._maxSize - totalEntities);

  console.warn(`[EntityPool] Expanding pool by ${expandSize} entities`);

  // Create new entities in batch
  for (let i = 0; i < expandSize; i++) {
    this.available.push(this.factory());
  }

  // Emit event for pool expansion
  this.emit({
    type: 'poolExpanded',
    data: { newSize: this.getTotalCount() }
  });
}
```

3. **Resource Tracking**: The system provides methods to monitor pool usage and status.

```typescript
// Get total number of entities (active + available)
public getTotalCount(): number {
  return this.inUse.size + this.available.length;
}

// Get number of active entities
public getActiveCount(): number {
  return this.inUse.size;
}

// Get number of available entities
public getAvailableCount(): number {
  return this.available.length;
}

// Get all active entities
public getActiveEntities(): T[] {
  return Array.from(this.inUse);
}
```

### Memory Optimization Techniques

The system employs several techniques to optimize memory usage and performance:

1. **Batch Allocation**: Entities are created in batches to reduce allocation overhead.

```typescript
// Pre-allocate entities in constructor
constructor(factory: () => T, initialSize: number) {
  // ...

  // Pre-allocate initial pool in a single batch
  for (let i = 0; i < initialSize; i++) {
    this.available.push(factory());
  }
}
```

2. **Pooled Entity Interface**: Entities implement a reset method to clear state between uses.

```typescript
// Required interface for pooled entities
export interface PooledEntity {
  reset(): void;
}

// Example asteroid implementation
class Asteroid implements PooledEntity {
  public position: { x: number; y: number };
  public velocity: { x: number; y: number };
  public active: boolean;

  constructor() {
    this.position = { x: 0, y: 0 };
    this.velocity = { x: 0, y: 0 };
    this.active = false;
  }

  // Reset the asteroid to its initial state
  public reset(): void {
    this.position.x = 0;
    this.position.y = 0;
    this.velocity.x = 0;
    this.velocity.y = 0;
    this.active = false;
  }
}
```

3. **Pool Size Management**: The system enforces maximum pool sizes to prevent unbounded memory growth.

```typescript
public acquire(): T | undefined {
  // ...

  // Check if we've reached the maximum pool size
  const totalEntities = this.getTotalCount();
  if (totalEntities >= this._maxSize) {
    console.warn(
      `[EntityPool] Maximum pool size (${this._maxSize}) reached, cannot create more entities`
    );
    return undefined;
  }

  // ...
}
```

### Performance Optimization Patterns

The Entity Pooling System incorporates several patterns to maximize runtime performance:

1. **Event-Based Monitoring**: The system emits events that can be used for monitoring and debugging.

```typescript
// Event types for entity pool
interface PoolEvents<T extends PooledEntity> {
  entityActivated: { entity: T };
  entityDeactivated: { entity: T };
  poolExpanded: { newSize: number };
  [key: string]: unknown;
}

// Emit an event when an entity is activated
this.emit({
  type: 'entityActivated',
  data: { entity },
});
```

2. **Type-Safe Implementation**: The system uses generics to provide type safety while maintaining flexibility.

```typescript
// Type-safe entity pool
export class EntityPool<T extends PooledEntity> extends EventEmitter<PoolEvent<T>> {
  // Implementation details...
}

// Type-specific pool instances
const asteroidPool = new EntityPool<Asteroid>(() => new Asteroid(), 100);
const bulletPool = new EntityPool<Bullet>(() => new Bullet(), 200);
```

3. **Resource Cleanup**: The system provides cleanup methods to release resources.

```typescript
// Clear the entire pool
public clear(): void {
  // Release all active entities
  this.inUse.forEach(entity => entity.reset());

  // Add them back to the available pool
  this.available.push(...Array.from(this.inUse));

  // Clear the in-use set
  this.inUse.clear();
}
```

### Integration Patterns

The Entity Pooling System integrates with other systems using these patterns:

1. **Factory Integration**: The system accepts a factory function to create new entities.

```typescript
// Creating a pool with a factory function
const bulletPool = new EntityPool<Bullet>(
  () => new Bullet(), // Factory function
  100 // Initial size
);
```

2. **Game Loop Integration**: The system integrates with the game update loop.

```typescript
// In game update loop
function update(deltaTime: number) {
  // Create new entities from pool as needed
  if (shouldCreateNewAsteroid()) {
    const asteroid = asteroidPool.acquire();
    if (asteroid) {
      initializeAsteroid(asteroid);
    }
  }

  // Update active entities
  for (const entity of asteroidPool.getActiveEntities()) {
    updateEntity(entity, deltaTime);

    // Return to pool if no longer needed
    if (!entity.active) {
      asteroidPool.release(entity);
    }
  }
}
```

3. **Component System Integration**: The pooling system integrates with the entity component system.

```typescript
// Creating a component manager with pooling
class ParticleComponentManager {
  private particlePool: EntityPool<Particle>;

  constructor(initialSize: number) {
    this.particlePool = new EntityPool<Particle>(() => new Particle(), initialSize);

    // Listen for pool events
    this.particlePool.on('poolExpanded', this.handlePoolExpanded);
  }

  // Create a new particle component
  public createParticle(position: Vector2): Particle | undefined {
    const particle = this.particlePool.acquire();
    if (particle) {
      particle.position.x = position.x;
      particle.position.y = position.y;
      particle.active = true;
    }
    return particle;
  }

  // Release a particle back to the pool
  public destroyParticle(particle: Particle): void {
    this.particlePool.release(particle);
  }
}
```

## Factions System (#faction_system)

### Overview

The Factions System is a comprehensive framework for managing NPC factions in the Galactic Sprawl game. It provides a complete implementation for faction behavior, relationships, territories, and AI decision-making. The system consists of several interconnected manager classes that handle different aspects of faction gameplay.

## Key Components

### Faction Types

```typescript
// src/types/ships/FactionTypes.ts
export type FactionId =
  | 'player'
  | 'enemy'
  | 'neutral'
  | 'ally'
  | 'space-rats'
  | 'lost-nova'
  | 'equator-horizon';

export type FactionBehaviorType =
  | 'aggressive'
  | 'defensive'
  | 'hit-and-run'
  | 'stealth'
  | 'balance';

export interface FactionBehaviorConfig {
  formation: string;
  behavior: FactionBehaviorType;
  target?: string;
}

export interface FactionConfig {
  id: FactionId;
  name: string;
  banner: {
    primaryColor: string;
    secondaryColor: string;
    sigil: string;
  };
  defaultBehavior: FactionBehaviorType;
  spawnConditions: {
    minThreatLevel: number;
    maxShipsPerFleet: number;
    territoryPreference: string[];
  };
}

export interface FactionState {
  id: FactionId;
  name: string;
  color: string;
  relations: {
    [key in FactionId]: number;
  };
  resources: {
    [key: string]: number;
  };
  territory: {
    systems: string[];
    outposts: string[];
    colonies: string[];
  };
  fleets: {
    [key: string]: {
      ships: string[];
      position: {
        x: number;
        y: number;
      };
      status: string;
    };
  };
  tech: {
    [key: string]: {
      level: number;
      progress: number;
    };
  };
}
```

### Faction Events

```typescript
// src/types/events/FactionEvents.ts
export enum FactionEventType {
  BEHAVIOR_CHANGED = 'behaviorChanged',
  FLEET_UPDATED = 'fleetUpdated',
  TERRITORY_CHANGED = 'territoryChanged',
  RELATIONSHIP_CHANGED = 'relationshipChanged',
  RESOURCES_UPDATED = 'resourcesUpdated',
  COMBAT_TACTICS_CHANGED = 'combatTacticsChanged',
  TREATY_STATUS_CHANGED = 'treatyStatusChanged',
  TRADE_ESTABLISHED = 'tradeEstablished',
  CONFLICT_RECORDED = 'conflictRecorded',
}

export interface FactionEvents extends Record<string, unknown> {
  relationshipChanged: {
    factionId: FactionId;
    targetFactionId: FactionId;
    oldValue: number;
    newValue: number;
  };
  treatyStatusChanged: {
    factionId: FactionId;
    targetFactionId: FactionId;
    oldStatus: string;
    newStatus: string;
  };
  tradeEstablished: {
    factionId: FactionId;
    targetFactionId: FactionId;
    resourceType: ResourceType;
    amount: number;
  };
  conflictRecorded: {
    factionId: FactionId;
    targetFactionId: FactionId;
    type: string;
    severity: number;
  };
}

export interface FactionCombatTactics {
  preferredRange: 'close' | 'medium' | 'long';
  formationStyle: 'aggressive' | 'defensive' | 'balanced';
  targetPriority: 'ships' | 'stations' | 'resources';
  retreatThreshold: number;
  reinforcementThreshold: number;
}

export interface FactionTerritory {
  center: {
    x: number;
    y: number;
  };
  radius: number;
  controlPoints: {
    x: number;
    y: number;
  }[];
  resources: Record<ResourceType, number>;
  threatLevel: number;
}
```

## Manager Classes

### Faction Manager

The core manager that tracks faction states and controls activation based on player progress:

```typescript
// src/managers/factions/factionManager.ts
class FactionManager {
  private factionStates: Map<string, FactionState> = new Map();
  private playerTier: number = 1;
  private playerPower: number = 0;

  constructor() {
    // Initialize faction states
    Object.values(factionConfigs).forEach((config: FactionConfig) => {
      this.factionStates.set(config.id, {
        activeShips: 0,
        territory: {
          center: { x: 0, y: 0 },
          radius: config.spawnConditions.territorySize,
        },
        fleetStrength: 1,
        relationshipWithPlayer: config.specialRules.alwaysHostile ? -1 : 0,
        lastActivity: Date.now(),
        isActive: false,
      });
    });
  }

  public updatePlayerStatus(tier: number, power: number) {
    this.playerTier = tier;
    this.playerPower = power;
    this.checkFactionActivation();
  }

  private checkFactionActivation() {
    // Activates factions based on player progress
  }

  public getFactionState(factionId: string): FactionState | undefined {
    return this.factionStates.get(factionId);
  }

  public getFactionBehavior(factionId: string) {
    // Returns behavior information
  }

  public update() {
    // Updates faction states on game loop
  }
}
```

### Faction Behavior Manager

Manages faction behaviors and their state changes with a typed event system:

```typescript
// src/managers/factions/FactionBehaviorManager.ts
export class FactionBehaviorManager extends BaseTypedEventEmitter<FactionEvents> {
  private factions: Map<FactionId, FactionState> = new Map();

  constructor() {
    super();
  }

  public getFactionState(factionId: FactionId): FactionState | undefined {
    return this.factions.get(factionId);
  }

  public setFactionState(factionId: FactionId, state: FactionState): void {
    this.factions.set(factionId, state);
  }

  public changeBehavior(factionId: FactionId, newBehavior: FactionBehaviorType): boolean {
    // Changes behavior and emits events
  }

  public updateFleets(factionId: FactionId, fleets: FactionFleet[]): boolean {
    // Updates fleets and emits events
  }

  public updateTerritory(factionId: FactionId, territory: FactionTerritory): boolean {
    // Updates territory and emits events
  }

  public updateRelationship(
    factionId: FactionId,
    targetFaction: FactionId,
    newValue: number
  ): boolean {
    // Updates relationships and emits events
  }

  public updateResources(
    factionId: FactionId,
    resourceType: ResourceType,
    newAmount: number
  ): boolean {
    // Updates resources and emits events
  }

  public updateCombatTactics(factionId: FactionId, newTactics: FactionCombatTactics): boolean {
    // Updates combat tactics and emits events
  }
}
```

### Faction Relationship Manager

Manages inter-faction relationships and diplomatic actions:

```typescript
// src/managers/factions/FactionRelationshipManager.ts
export class FactionRelationshipManager extends TypedEventEmitter<FactionEvents> {
  private relationships: Map<string, RelationshipState> = new Map();

  constructor() {
    super();
    this.initializeRelationships();
    this.setupEventListeners();
  }

  private initializeRelationships(): void {
    // Initialize relationships between all factions
  }

  public getRelationship(factionId: FactionId, targetId: FactionId): number {
    // Returns relationship value
  }

  public getTreatyStatus(
    factionId: FactionId,
    targetId: FactionId
  ): RelationshipState['treatyStatus'] {
    // Returns current treaty status
  }

  public modifyRelationship(
    factionId: FactionId,
    targetId: FactionId,
    change: number,
    reason: string
  ): void {
    // Changes relationship and may trigger treaty updates
  }

  public recordTrade(
    factionId: FactionId,
    targetId: FactionId,
    resourceType: ResourceType,
    amount: number
  ): void {
    // Records trade activity and improves relationships
  }

  public recordConflict(
    factionId: FactionId,
    targetId: FactionId,
    type: 'attack' | 'territory' | 'trade',
    severity: number
  ): void {
    // Records conflicts and decreases relationships
  }

  public handleDiplomaticAction(
    factionId: FactionId,
    targetId: FactionId,
    action: 'ceasefire' | 'tradeRoute' | 'alliance' | 'tribute',
    resources?: { type: string; amount: number }[]
  ): boolean {
    // Handles diplomatic actions between factions
  }

  public getAvailableDiplomaticActions(
    factionId: FactionId,
    targetId: FactionId
  ): {
    type: 'ceasefire' | 'tradeRoute' | 'alliance' | 'tribute';
    name: string;
    description: string;
    requirements: { type: string; value: number }[];
    available: boolean;
  }[] {
    // Returns available diplomatic actions between factions
  }
}
```

## Faction Behavior System

The faction behavior system controls how NPC factions behave in the game:

1. **Faction Types**: Each faction (Space Rats, Lost Nova, Equator Horizon) has unique behavior patterns
2. **Behavior States**: Factions can adopt different behavior states (aggressive, defensive, hit-and-run, stealth, balance)
3. **Event-Driven**: Behavior changes are event-driven and propagate through the event system
4. **Territorial**: Factions control territory which expands based on their behavior and player interactions
5. **Relationship-Based**: Faction relationships affect diplomatic options and combat decisions

## Faction Relationship Management

The system includes comprehensive relationship management:

1. **Numerical Values**: Relationships are tracked as numerical values (-1 to 1)
2. **Treaty States**: Factions can have treaties like ceasefire, trade, or alliance
3. **Event Recording**: Trade and conflict events are recorded and affect relationships
4. **Diplomatic Actions**: Factions can perform diplomatic actions depending on relationship status
5. **Event-Driven**: Relationship changes trigger events for UI updates and gameplay responses

## Integration With Game Systems

The Faction System integrates with other game systems:

1. **Combat System**: Faction hostility determines combat engagement
2. **Resource System**: Factions control and trade resources
3. **Territory System**: Factions own and expand territories
4. **Technology System**: Factions advance in technology based on gameplay
5. **UI System**: Faction status is displayed in the user interface

## Usage Example

```typescript
// Example: Using the faction managers
import { factionManager } from './managers/factions/factionManager';
import { FactionBehaviorManager } from './managers/factions/FactionBehaviorManager';
import { FactionRelationshipManager } from './managers/factions/FactionRelationshipManager';

// Create behavior and relationship managers
const behaviorManager = new FactionBehaviorManager();
const relationshipManager = new FactionRelationshipManager();

// Update player status to potentially activate factions
factionManager.updatePlayerStatus(2, 500);

// Get a faction's state
const spaceRats = factionManager.getFactionState('space-rats');

// Change faction behavior
if (spaceRats) {
  behaviorManager.changeBehavior('space-rats', 'aggressive');
}

// Check relationship and available diplomatic actions
const relationship = relationshipManager.getRelationship('player', 'space-rats');
const diplomaticOptions = relationshipManager.getAvailableDiplomaticActions('player', 'space-rats');

// Record a trade to improve relationships
relationshipManager.recordTrade('player', 'lost-nova', 'crystal', 100);

// Handle faction update on game loop
factionManager.update();
```

## Behavior Tree System (#behavior_tree)

### Overview

The Behavior Tree System provides a flexible framework for implementing AI decision-making in Galactic Sprawl. It uses a hierarchical tree structure to define and execute behavior patterns for different entities, particularly ships and faction units. This system is responsible for the sophisticated AI behaviors observed in combat, resource gathering, and faction-based decision making.

## Key Components

### BehaviorNode Interface

The foundation of the behavior tree system is the BehaviorNode interface, which defines the structure of each node in the tree:

```typescript
// src/managers/ai/BehaviorTreeManager.ts
interface BehaviorNode {
  id: string;
  type: 'sequence' | 'selector' | 'condition' | 'action';
  children?: BehaviorNode[];
  evaluate?: (context: BehaviorContext) => boolean;
  execute?: (context: BehaviorContext) => void;
}
```

### Context System

Behavior trees operate within a context that provides all the necessary information for decision making:

```typescript
interface BehaviorContext {
  unit: CombatUnit & { target?: string };
  factionId: FactionId;
  fleetStrength: number;
  threatLevel: number;
  nearbyEnemies: CombatUnit[];
  nearbyAllies: CombatUnit[];
  currentFormation: {
    type: 'offensive' | 'defensive' | 'balanced';
    spacing: number;
    facing: number;
  };
  lastAction?: string;
  cooldowns: Record<string, number>;
}
```

### Event System

The behavior tree manager uses a typed event system to communicate between components:

```typescript
export interface BehaviorEvents {
  nodeExecuted: { nodeId: string; success: boolean };
  treeCompleted: { unitId: string; success: boolean };
  actionStarted: { unitId: string; actionType: string };
  actionCompleted: { unitId: string; actionType: string };
  [key: string]: unknown;
}
```

## BehaviorTreeManager Implementation

The BehaviorTreeManager is implemented as a singleton that maintains and evaluates behavior trees:

```typescript
export class BehaviorTreeManager extends TypedEventEmitter<BehaviorEvents> {
  private static instance: BehaviorTreeManager;
  private trees: Map<string, BehaviorNode> = new Map();
  private contexts: Map<string, BehaviorContext> = new Map();

  private constructor() {
    super();
    this.initializeDefaultTrees();
  }

  public static getInstance(): BehaviorTreeManager {
    if (!BehaviorTreeManager.instance) {
      BehaviorTreeManager.instance = new BehaviorTreeManager();
    }
    return BehaviorTreeManager.instance;
  }

  // Core methods for tree evaluation
  public evaluateTree(unitId: string, treeId: string): boolean {
    const tree = this.trees.get(treeId);
    const context = this.contexts.get(unitId);

    if (!tree || !context) {
      return false;
    }

    return this.evaluateNode(tree, context);
  }

  // Methods to update context
  public updateContext(unitId: string, context: Partial<BehaviorContext>): void {
    const existingContext = this.contexts.get(unitId) || this.createDefaultContext();
    this.contexts.set(unitId, { ...existingContext, ...context });
  }
}

export const behaviorTreeManager = BehaviorTreeManager.getInstance();
```

## Tree Node Types

The behavior tree system uses four types of nodes to build complex behavior patterns:

### Sequence Nodes

Execute children in order, stopping if any child fails:

```typescript
private evaluateSequence(node: BehaviorNode, context: BehaviorContext): boolean {
  if (!node.children) {
    return true;
  }

  for (const child of node.children) {
    if (!this.evaluateNode(child, context)) {
      this.emit('nodeExecuted', { nodeId: node.id, success: false });
      return false;
    }
  }

  this.emit('nodeExecuted', { nodeId: node.id, success: true });
  return true;
}
```

### Selector Nodes

Execute children in order, stopping when any child succeeds:

```typescript
private evaluateSelector(node: BehaviorNode, context: BehaviorContext): boolean {
  if (!node.children) {
    return false;
  }

  for (const child of node.children) {
    if (this.evaluateNode(child, context)) {
      this.emit('nodeExecuted', { nodeId: node.id, success: true });
      return true;
    }
  }

  this.emit('nodeExecuted', { nodeId: node.id, success: false });
  return false;
}
```

### Condition Nodes

Evaluate a condition without changing the world state:

```typescript
// Example condition nodes
{
  id: 'check-health',
  type: 'condition',
  evaluate: context => context.unit.stats.health / context.unit.stats.maxHealth > 0.3,
}
```

### Action Nodes

Execute actions that change the world state:

```typescript
// Example action nodes
{
  id: 'approach-target',
  type: 'action',
  execute: context => this.moveTowardsTarget(context),
}
```

## Faction-Specific Behavior Trees

The system includes pre-configured behavior trees for each faction with distinctive behaviors:

### Space Rats (Pirates) - Aggressive Behavior

```typescript
this.trees.set('space-rats-combat', {
  id: 'space-rats-root',
  type: 'sequence',
  children: [
    {
      id: 'check-health',
      type: 'condition',
      evaluate: context => context.unit.stats.health / context.unit.stats.maxHealth > 0.3,
    },
    // More aggressive attack-focused nodes
  ],
});
```

### Lost Nova (Exiles) - Stealth Behavior

```typescript
this.trees.set('lost-nova-combat', {
  id: 'lost-nova-root',
  type: 'sequence',
  children: [
    {
      id: 'assess-threat',
      type: 'selector',
      children: [
        // Nodes focused on stealth and hit-and-run tactics
      ],
    },
  ],
});
```

### Equator Horizon - Balanced Behavior

```typescript
this.trees.set('equator-horizon-combat', {
  id: 'equator-horizon-root',
  type: 'sequence',
  children: [
    {
      id: 'assess-situation',
      type: 'selector',
      children: [
        // Nodes focused on balanced, coordinated actions
      ],
    },
  ],
});
```

## Ship Movement and Behavior Systems

The behavior tree system integrates with ship movement and behavior systems:

### Ship Behavior Manager

```typescript
// src/lib/ai/shipBehavior.ts
class ShipBehaviorManagerImpl extends EventEmitter<ShipBehaviorEvents> {
  private tasks: Map<string, ShipTask> = new Map();
  private ships: Map<string, ShipWithPosition> = new Map();
  private salvageTargets: Map<string, string> = new Map();

  // Methods for task assignment and management
  public assignTask(task: ShipTask): void {
    // Assigns tasks to ships
  }

  public registerShip(ship: ShipWithPosition): void {
    // Registers ships with the behavior system
  }
}
```

### Ship Movement Manager

```typescript
// src/lib/ai/shipMovement.ts
class ShipMovementManagerImpl extends EventEmitter<ShipMovementEvents> {
  private movementStates: Map<string, MovementState> = new Map();

  // Methods for movement control
  public moveToPosition(shipId: string, targetPosition: Position): void {
    // Moves ships to target positions
  }

  public update(deltaTime: number, shipPositions: Map<string, Position>): void {
    // Updates ship positions based on movement state
  }
}
```

## Integration with Game Systems

The behavior tree system integrates with other game systems:

1. **Combat System**: Behavior trees control attack patterns and tactics
2. **Movement System**: Trees trigger movement commands for tactical positioning
3. **Faction System**: Faction-specific trees implement distinct faction behaviors
4. **Resource System**: Trees include resource harvesting and management behaviors
5. **Event System**: Behaviors are updated in response to game events

## Usage Example

```typescript
// Example: Using the behavior tree system in a combat hook
import { behaviorTreeManager } from '../../managers/ai/BehaviorTreeManager';

function useCombatAI(unitId: string, factionId: FactionId) {
  useEffect(() => {
    // Subscribe to behavior tree events
    const unsubscribeNodeExecuted = behaviorTreeManager.on('nodeExecuted', handleNodeExecuted);

    // Update the AI context with current game state
    behaviorTreeManager.updateContext(unitId, {
      unit: combatUnit,
      factionId,
      fleetStrength: calculateFleetStrength(),
      threatLevel: calculateThreatLevel(),
      nearbyEnemies: getNearbyEnemies(),
      nearbyAllies: getNearbyAllies(),
      currentFormation: getCurrentFormation(),
    });

    // Evaluate the appropriate behavior tree
    const treeId = `${factionId}-combat`;
    const success = behaviorTreeManager.evaluateTree(unitId, treeId);

    return () => {
      unsubscribeNodeExecuted();
    };
  }, [unitId, factionId]);
}
```

## Manager Registry System (#manager_registry)

### Overview

The Manager Registry System provides a centralized mechanism for accessing manager instances across the application, preventing circular dependencies and ensuring consistent access to singleton manager instances. This system acts as a dependency injection container that standardizes how managers are instantiated, accessed, and potentially reset for testing purposes.

## Key Components

### ManagerRegistry Implementation

The core of the Manager Registry System is implemented in `ManagerRegistry.ts`:

```typescript
// src/managers/ManagerRegistry.ts
/**
 * ManagerRegistry.ts
 *
 * Central registry for all manager singletons to avoid circular dependencies
 * and ensure consistent access to manager instances.
 */

import { CombatManager } from './combat/CombatManager';

// Singleton instances
let combatManagerInstance: CombatManager | null = null;

/**
 * Get the singleton instance of CombatManager
 * @returns The CombatManager instance
 */
export function getCombatManager(): CombatManager {
  if (!combatManagerInstance) {
    combatManagerInstance = new CombatManager();
  }
  return combatManagerInstance;
}

/**
 * Reset all manager instances - primarily used for testing
 */
export function resetManagers(): void {
  combatManagerInstance = null;
}

// Export manager classes for type usage
export { CombatManager };
```

## Manager Instantiation Patterns

The codebase employs two main approaches to manager instantiation, both focused on the singleton pattern:

### Factory Function Pattern

Used by the Manager Registry to lazy-initialize manager instances:

```typescript
// Factory function for lazy initialization
export function getCombatManager(): CombatManager {
  if (!combatManagerInstance) {
    combatManagerInstance = new CombatManager();
  }
  return combatManagerInstance;
}
```

### Static Instance Pattern

Used by many manager classes directly:

```typescript
// Static instance pattern example
export class BehaviorTreeManager extends TypedEventEmitter<BehaviorEvents> {
  private static instance: BehaviorTreeManager;

  private constructor() {
    super();
    this.initializeDefaultTrees();
  }

  public static getInstance(): BehaviorTreeManager {
    if (!BehaviorTreeManager.instance) {
      BehaviorTreeManager.instance = new BehaviorTreeManager();
    }
    return BehaviorTreeManager.instance;
  }

  // ... class implementation
}

export const behaviorTreeManager = BehaviorTreeManager.getInstance();
```

## Circular Dependency Solutions

The Manager Registry specifically addresses circular dependency issues through several mechanisms:

### 1. Centralized Access Point

By providing a single point of access for manager instances, components don't need to import manager classes directly:

```typescript
// Instead of importing CombatManager directly
import { getCombatManager } from '../../managers/ManagerRegistry';

// Use the manager through the registry
const combatManager = getCombatManager();
```

### 2. Late Binding

The factory function approach enables late binding, which helps resolve circular dependencies by deferring manager creation:

```typescript
// Manager is only created when explicitly requested
function someMethod() {
  const combatManager = getCombatManager();
  // Use the manager
}
```

### 3. Export Type Information Separately

The registry exports manager classes for type information while handling instantiation separately:

```typescript
// Export for type usage, not instantiation
export { CombatManager };
```

## Integration with Component Lifecycle

The Registry system integrates with React component lifecycle through hooks:

```typescript
// Example from useCombatSystem.ts
import { getCombatManager } from '../../managers/ManagerRegistry';

export function useCombatSystem() {
  useEffect(() => {
    const combatManager = getCombatManager();

    // Subscribe to combat events
    const unsubscribe = combatManager.subscribe('combat:unit-spawned', handleUnitSpawned);

    return () => {
      unsubscribe();
    };
  }, []);
}
```

## Testing Support

The Manager Registry includes built-in support for testing through its reset functionality:

```typescript
// Reset all managers between tests
export function resetManagers(): void {
  combatManagerInstance = null;
}
```

## Usage Examples

### Accessing Managers in Components

```typescript
import { getCombatManager } from '../../managers/ManagerRegistry';

function CombatOverview() {
  const [units, setUnits] = useState<CombatUnit[]>([]);

  useEffect(() => {
    const combatManager = getCombatManager();
    const allUnits = combatManager.getAllUnits();
    setUnits(allUnits);

    const unsubscribe = combatManager.subscribe('combat:unit-spawned', () => {
      setUnits(combatManager.getAllUnits());
    });

    return () => unsubscribe();
  }, []);

  return (
    <div>
      <h2>Combat Units</h2>
      <ul>
        {units.map(unit => (
          <li key={unit.id}>{unit.type} ({unit.faction})</li>
        ))}
      </ul>
    </div>
  );
}
```

### Using Managers in Other Managers

```typescript
import { getCombatManager } from '../ManagerRegistry';

export class WarShipManagerImpl {
  // Method demonstrating manager interdependency
  public targetEnemy(shipId: string, enemyId: string): void {
    // Access combat manager through registry
    const combatManager = getCombatManager();

    // Use the combat manager's methods
    combatManager.engageTarget(shipId, enemyId);
  }
}
```

## Benefits and Design Considerations

1. **Dependency Inversion**: The registry inverts dependencies, making components depend on abstractions rather than concrete implementations.

2. **Lazy Initialization**: Managers are only created when needed, improving startup performance.

3. **Testability**: The reset functionality makes it easy to start with a clean slate between tests.

4. **Centralized Control**: All manager access flows through a single point, making it easier to introduce logging, metrics, or other cross-cutting concerns.

5. **Consistent Access Pattern**: Establishes a standard way to access manager instances throughout the application.

## Integration with Architecture

The Manager Registry is a foundational piece of the application's architecture, sitting between the business logic layer (managers) and the presentation layer (components). It establishes a clean separation of concerns by:

1. Preventing direct dependencies between components and managers
2. Allowing managers to be developed and tested independently
3. Providing a consistent way to access global state and functionality
4. Supporting a modular approach where components can be developed without knowledge of the specific manager implementations

## Visualization System (#visualization_system)

### Overview

The Visualization System provides a comprehensive framework for rendering charts, graphs, and data visualizations in the Galactic Sprawl game. It implements the Strategy Pattern to abstract rendering logic across multiple rendering technologies (SVG, Canvas, WebGL), offering optimal performance for different data sizes and device capabilities. The system ensures consistent visuals across the application while maximizing performance.

### Key Components

### Chart Component

The central component of the visualization system is the Chart component, which serves as a unified API for various visualization types:

```typescript
// src/visualization/Chart.tsx
export interface ChartProps {
  data: ChartData;
  options?: Partial<ChartOptions>;
  type: ChartType;
  className?: string;
  onRender?: (renderer: ChartRenderer) => void;
  onError?: (error: Error) => void;
}

export const Chart: React.FC<ChartProps> = ({
  data,
  options = {},
  type,
  className = '',
  onRender,
  onError,
}) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const rendererRef = useRef<ChartRenderer | null>(null);

  // Auto-select renderer based on data size and options
  const renderer = useMemo(() => {
    const dataSize = data.datasets.reduce((count, dataset) => count + dataset.data.length, 0);

    // Choose appropriate renderer based on data size and specified renderer
    if (options.renderer === 'webgl' || (!options.renderer && dataSize > 10000)) {
      return new WebGLRenderer();
    }

    if (options.renderer === 'canvas' || (!options.renderer && dataSize > 1000)) {
      return new CanvasRenderer();
    }

    return new SVGRenderer();
  }, [data, options.renderer]);

  // ... implementation
};
```

### Data Models

The system uses strongly typed data models to ensure consistency and type safety:

```typescript
// src/visualization/Chart.tsx
export interface ChartDataPoint {
  x: number | string | Date;
  y: number;
  [key: string]: unknown;
}

export interface ChartData {
  datasets: {
    label: string;
    data: ChartDataPoint[];
    color?: string;
    [key: string]: unknown;
  }[];
  annotations?: {
    type: 'line' | 'box' | 'point';
    position: { x?: number | string | Date; y?: number };
    color?: string;
    label?: string;
    [key: string]: unknown;
  }[];
}

export interface ChartOptions {
  width?: number | string;
  height?: number | string;
  renderer?: 'canvas' | 'svg' | 'webgl';
  responsive?: boolean;
  maintainAspectRatio?: boolean;
  axes?: ChartAxes;
  legend?: ChartLegend;
  tooltip?: ChartTooltip;
  animation?: ChartAnimation;
  backgroundColor?: string;
  padding?: {
    top?: number;
    right?: number;
    bottom?: number;
    left?: number;
  };
  enablePanning?: boolean;
  enableZooming?: boolean;
  theme?: 'light' | 'dark' | 'auto';
  memoryOptimized?: boolean;
  renderOptimization?: boolean;
  optimizationThreshold?: number;
}

export type ChartType = 'line' | 'bar' | 'scatter' | 'area' | 'pie' | 'radar' | 'heatmap';
```

### Renderer Interface

The system uses the Strategy Pattern through a common renderer interface:

```typescript
// src/visualization/Chart.tsx
export interface ChartRenderer {
  render: (container: HTMLElement, data: ChartData, options: ChartOptions, type: ChartType) => void;
  update: (container: HTMLElement, data: ChartData, options: ChartOptions, type: ChartType) => void;
  destroy: () => void;
  getStatus: () => { isInitialized: boolean; lastRenderTime?: number };
}
```

## Rendering Strategies

The system includes three rendering strategies, each optimized for different use cases:

### SVG Renderer

Provides high-quality, DOM-based, resolution-independent visualizations best for smaller datasets:

```typescript
// src/visualization/renderers/SVGRenderer.tsx
export class SVGRenderer implements ChartRenderer {
  private containerWidth: number;
  private containerHeight: number;
  private interactiveElements: SVGElement[] = [];
  private theme = {
    light: {
      backgroundColor: '#ffffff',
      textColor: '#333333',
      axisColor: '#cccccc',
      gridColor: '#eeeeee',
    },
    dark: {
      backgroundColor: '#333333',
      textColor: '#ffffff',
      axisColor: '#666666',
      gridColor: '#444444',
    },
  };

  constructor() {
    this.containerWidth = 0;
    this.containerHeight = 0;
  }

  public render(
    container: HTMLElement,
    data: ChartData,
    options: ChartOptions,
    type: ChartType
  ): void {
    // SVG-based rendering implementation
    // ...
  }

  // Additional methods for different chart types
  private renderLineChart(
    data: ChartData,
    options: ChartOptions,
    chartArea: ChartArea,
    chartGroup: SVGGElement
  ): void {
    // Line chart specific rendering
    // ...
  }

  // ... other methods
}
```

### Canvas Renderer

Provides bitmap-based rendering for medium to large datasets with better performance:

```typescript
// src/visualization/renderers/CanvasRenderer.tsx
export class CanvasRenderer implements ChartRenderer {
  private canvas: HTMLCanvasElement | null = null;
  private ctx: CanvasRenderingContext2D | null = null;
  private pixelRatio: number = 1;
  private lastRenderTime: number = 0;
  private isInitialized: boolean = false;
  private interactiveRegions: InteractiveRegion[] = [];

  public render(
    container: HTMLElement,
    data: ChartData,
    options: ChartOptions,
    type: ChartType
  ): void {
    // Canvas-based rendering implementation
    // ...
  }

  // Memory optimization techniques
  private optimizeForLargeDataset(data: ChartData, options: ChartOptions): ChartData {
    // Implement data downsampling, bucketing or other optimization techniques
    if (!options.memoryOptimized) {
      return data;
    }

    // Apply optimizations for large datasets
    // ...
  }

  // ... other methods
}
```

### WebGL Renderer

Utilizes GPU acceleration for handling very large datasets with complex visualizations:

```typescript
// src/visualization/renderers/WebGLRenderer.tsx
export class WebGLRenderer implements ChartRenderer {
  private canvas: HTMLCanvasElement | null = null;
  private gl: WebGLRenderingContext | null = null;
  private programCache: Map<string, WebGLProgram> = new Map();
  private bufferCache: Map<string, WebGLBuffer> = new Map();
  private lastRenderTime: number = 0;
  private isInitialized: boolean = false;

  public render(
    container: HTMLElement,
    data: ChartData,
    options: ChartOptions,
    type: ChartType
  ): void {
    // WebGL-based rendering implementation
    // ...
  }

  // Shader management for WebGL rendering
  private createShaderProgram(
    vertexShaderSource: string,
    fragmentShaderSource: string
  ): WebGLProgram | null {
    // Compile and link shaders
    // ...
  }

  // Specialized WebGL-optimized rendering for different chart types
  private renderLineChartWebGL(data: ChartData, options: ChartOptions, scales: any): void {
    // WebGL-specific line chart rendering
    // ...
  }

  // ... other methods
}
```

## Performance Optimization Techniques

The visualization system incorporates several performance optimization strategies:

### 1. Adaptive Renderer Selection

The system automatically selects the most efficient renderer based on data size:

```typescript
// Auto-select renderer based on data size and options
const renderer = useMemo(() => {
  const dataSize = data.datasets.reduce((count, dataset) => count + dataset.data.length, 0);

  // Choose appropriate renderer based on data size and specified renderer
  if (options.renderer === 'webgl' || (!options.renderer && dataSize > 10000)) {
    return new WebGLRenderer();
  }

  if (options.renderer === 'canvas' || (!options.renderer && dataSize > 1000)) {
    return new SVGRenderer();
  }

  return new SVGRenderer();
}, [data, options.renderer]);
```

### 2. Data Downsampling

For large datasets, the system implements intelligent downsampling:

```typescript
private downsampleData(data: ChartDataPoint[], maxPoints: number): ChartDataPoint[] {
  if (data.length <= maxPoints) {
    return data;
  }

  // Various downsampling strategies implemented here
  // (LTTB - Largest-Triangle-Three-Buckets, etc.)
  // ...
}
```

### 3. Memoization and Virtualization

The system uses React's memoization capabilities to prevent unnecessary recalculations:

```typescript
// Memoize expensive calculations
const scales = useMemo(() => calculateScales(data, options), [data, options]);

// Virtualize large datasets for rendering
const virtualizedData = useMemo(() => {
  if (data.datasets.some(d => d.data.length > options.optimizationThreshold)) {
    return applyVirtualization(data, visibleRange);
  }
  return data;
}, [data, visibleRange, options.optimizationThreshold]);
```

## Usage Example

The Chart component provides a simple, unified API for all visualization needs:

```typescript
import { Chart } from '../visualization';

function ResourceTrendsChart() {
  const resourceData = {
    datasets: [
      {
        label: 'Energy',
        data: energyHistory.map(point => ({ x: point.timestamp, y: point.value })),
        color: '#4e79a7'
      },
      {
        label: 'Minerals',
        data: mineralHistory.map(point => ({ x: point.timestamp, y: point.value })),
        color: '#f28e2c'
      }
    ]
  };

  const options = {
    axes: {
      x: { type: 'time', label: 'Time' },
      y: { type: 'linear', label: 'Resources' }
    },
    legend: { visible: true, position: 'top' },
    tooltip: { enabled: true, mode: 'nearest' },
    animation: { enabled: true, duration: 500 },
    memoryOptimized: true
  };

  return (
    <div className="resource-chart-container">
      <Chart
        data={resourceData}
        options={options}
        type="line"
        className="resource-chart"
        onError={error => console.error('Chart error:', error)}
      />
    </div>
  );
}
```

## Integration with Game Systems

The visualization system integrates with other game systems:

1. **Resource System**: Displays resource trends, production, and consumption
2. **Exploration System**: Visualizes discovery data and anomaly patterns
3. **Combat System**: Renders battle statistics and fleet compositions
4. **Tech Tree**: Displays research progress and dependencies
5. **Trading System**: Visualizes market trends and trade routes

## Design Considerations

The visualization system follows several key design principles:

1. **Separation of Concerns**: Clear separation between data, configuration, and rendering
2. **Progressive Enhancement**: Fallback mechanisms for different device capabilities
3. **Performance First**: Optimizations for handling large datasets efficiently
4. **Accessibility**: Support for keyboard navigation and screen readers
5. **Theming**: Consistent styling with light and dark mode support

## Shader System(#shader_system)

### Overview

The Shader System provides a comprehensive framework for GPU-accelerated data visualization using WebGL shaders. It enables high-performance rendering of complex visual effects for large datasets, allowing the application to visualize thousands of data points with smooth transitions and interactive effects. The system abstracts away the complexities of WebGL programming while providing a flexible API for advanced visualizations.

### Key Components

#### WebGLShaderManager

The core of the shader system is the WebGLShaderManager class:

```typescript
// src/lib/optimization/WebGLShaderManager.ts
export class WebGLShaderManager {
  private gl: WebGLRenderingContext | null = null;
  private canvas: HTMLCanvasElement | null = null;
  private programs: Map<string, WebGLProgram> = new Map();
  private shaders: Map<string, WebGLShader> = new Map();
  private textures: Map<string, WebGLTexture> = new Map();
  private framebuffers: Map<string, WebGLFramebuffer> = new Map();
  private animationFrame: number | null = null;
  private _lastTimestamp: number = 0;

  public initialize(canvas: HTMLCanvasElement): boolean {
    try {
      this.canvas = canvas;
      this.gl = canvas.getContext('webgl', {
        alpha: true,
        premultipliedAlpha: false,
        antialias: true,
        powerPreference: 'high-performance',
      });

      if (!this.gl) {
        console.error('[WebGLShaderManager] WebGL not supported');
        return false;
      }

      this.initializeDefaultShaders();
      console.warn('[WebGLShaderManager] Initialized successfully');
      return true;
    } catch (error) {
      console.error('[WebGLShaderManager] Initialization failed', error);
      return false;
    }
  }

  // Other methods...
}
```

#### Shader Types and Configuration

The system defines a set of standardized shader types for different visualization purposes:

```typescript
export enum DataVisualizationShaderType {
  HEATMAP = 'heatmap',
  CONTOUR = 'contour',
  POINT_CLUSTER = 'pointCluster',
  HIGHLIGHT = 'highlight',
  DENSITY = 'density',
  FLOW = 'flow',
  TRANSITION = 'transition',
  CUSTOM = 'custom',
}

export interface DataVisualizationShaderConfig {
  type: DataVisualizationShaderType;
  colors: string[];
  intensity?: number;
  resolution?: [number, number];
  animate?: boolean;
  animationSpeed?: number;
  highlightRange?: [number, number];
  dataRange?: [number, number];
  dataPoints?: Float32Array;
  customUniforms?: Record<string, ShaderUniform>;
  customVertexShader?: string;
  customFragmentShader?: string;
}
```

#### Shader Creation and Management

The WebGLShaderManager handles the complete lifecycle of shaders:

```typescript
private createShader(type: number, source: string): WebGLShader | undefined {
  if (!this.gl) return undefined;

  const shader = this.gl.createShader(type);
  if (!shader) return undefined;

  this.gl.shaderSource(shader, source);
  this.gl.compileShader(shader);

  if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
    console.error('An error occurred compiling the shaders:', this.gl.getShaderInfoLog(shader));
    this.gl.deleteShader(shader);
    return undefined;
  }

  return shader;
}

private createShaderProgram(
  name: string,
  vertexShaderSource: string,
  fragmentShaderSource: string
): WebGLProgram | undefined {
  // Implementation...
}

private createDataVisualizationShader(
  config: DataVisualizationShaderConfig
): WebGLProgram | undefined {
  const vertexShader = this.getDataVisualizationVertexShader(config);
  const fragmentShader = this.getDataVisualizationFragmentShader(config);

  return this.createShaderProgram(`data_${config.type}`, vertexShader, fragmentShader);
}
```

### GPU Acceleration Techniques

The system implements several GPU acceleration techniques to maximize performance:

#### 1. WebGL Context Optimization

The system configures the WebGL context for optimal performance:

```typescript
this.gl = canvas.getContext('webgl', {
  alpha: true,
  premultipliedAlpha: false,
  antialias: true,
  powerPreference: 'high-performance',
});
```

#### 2. Shader Program Caching

Programs are cached to avoid recompilation:

```typescript
// Get appropriate shader program
const programName = `data_${config.type}`;
let program = this.programs.get(programName);

// Create program if not exists
if (!program) {
  program = this.createDataVisualizationShader(config);
  if (!program) {
    console.error(`[WebGLShaderManager] Failed to create shader for ${config.type}`);
    return;
  }
}
```

#### 3. Buffer Management

The system efficiently manages WebGL buffers:

```typescript
private setupDataVisualizationBuffers(
  program: WebGLProgram,
  config: DataVisualizationShaderConfig,
  data: Float32Array,
  positions: Position[]
): void {
  if (!this.gl) return;

  // Create and set up position buffer
  const positionBuffer = this.gl.createBuffer();
  this.gl.bindBuffer(this.gl.ARRAY_BUFFER, positionBuffer);

  // Convert positions to flat array
  const positionArray = new Float32Array(positions.length * 2);
  positions.forEach((pos, index) => {
    positionArray[index * 2] = pos.x;
    positionArray[index * 2 + 1] = pos.y;
  });

  this.gl.bufferData(this.gl.ARRAY_BUFFER, positionArray, this.gl.STATIC_DRAW);

  // Set up attributes
  const positionAttribLocation = this.gl.getAttribLocation(program, 'a_position');
  this.gl.enableVertexAttribArray(positionAttribLocation);
  this.gl.vertexAttribPointer(positionAttribLocation, 2, this.gl.FLOAT, false, 0, 0);

  // Similar setup for data buffer
  // ...
}
```

#### 4. Animation Frame Management

The system includes efficient animation frame management:

```typescript
public startAnimationLoop(renderCallback: () => void): void {
  if (this.animationFrame !== null) {
    this.stopAnimationLoop();
  }

  const animate = (timestamp: number) => {
    // Calculate delta time for smooth animations
    const deltaTime = this._lastTimestamp ? (timestamp - this._lastTimestamp) / 1000 : 0;
    this._lastTimestamp = timestamp;

    // Execute render callback
    renderCallback();

    // Request next frame
    this.animationFrame = requestAnimationFrame(animate);
  };

  this.animationFrame = requestAnimationFrame(animate);
}

public stopAnimationLoop(): void {
  if (this.animationFrame !== null) {
    cancelAnimationFrame(this.animationFrame);
    this.animationFrame = null;
  }
}
```

### WebGL Optimization Patterns

The shader system employs several optimization patterns to maximize performance and quality:

#### 1. GLSL Shader Generation

The system dynamically generates GLSL shader code based on configuration:

```typescript
private getDataVisualizationVertexShader(config: DataVisualizationShaderConfig): string {
  // Use custom vertex shader if provided
  if (config.customVertexShader) {
    return config.customVertexShader;
  }

  // Generate shader based on visualization type
  const pointSizeCode = this.getPointSizeShaderCode(config);

  return `
    attribute vec2 a_position;
    attribute float a_value;

    uniform vec2 u_resolution;
    uniform float u_time;
    uniform float u_pointSize;
    uniform float u_intensity;

    varying float v_value;
    varying vec2 v_position;

    void main() {
      // Convert position from pixel space to clip space
      vec2 normalized = a_position / u_resolution * 2.0 - 1.0;
      gl_Position = vec4(normalized.x, -normalized.y, 0, 1);

      // Pass value to fragment shader
      v_value = a_value;
      v_position = a_position;

      // Calculate point size
      ${pointSizeCode}
    }
  `;
}
```

#### 2. Memory Management

The system carefully manages WebGL resources to prevent memory leaks:

```typescript
public dispose(): void {
  // Delete all shader programs
  this.programs.forEach(program => {
    if (this.gl && program) {
      this.gl.deleteProgram(program);
    }
  });
  this.programs.clear();

  // Delete all shaders
  this.shaders.forEach(shader => {
    if (this.gl && shader) {
      this.gl.deleteShader(shader);
    }
  });
  this.shaders.clear();

  // Delete all textures
  this.textures.forEach(texture => {
    if (this.gl && texture) {
      this.gl.deleteTexture(texture);
    }
  });
  this.textures.clear();

  // Delete all framebuffers
  this.framebuffers.forEach(framebuffer => {
    if (this.gl && framebuffer) {
      this.gl.deleteFramebuffer(framebuffer);
    }
  });
  this.framebuffers.clear();

  // Stop animation loop
  this.stopAnimationLoop();

  // Clear references
  this.gl = null;
  this.canvas = null;

  console.warn('[WebGLShaderManager] Resources disposed');
}
```

#### 3. Adaptive Rendering

The system adapts rendering techniques based on data characteristics:

```typescript
// Determine appropriate point size based on data density
private getPointSizeShaderCode(config: DataVisualizationShaderConfig): string {
  switch (config.type) {
    case DataVisualizationShaderType.HEATMAP:
      return `
        float dataIntensity = u_intensity * (0.5 + a_value * 0.5);
        gl_PointSize = u_pointSize * dataIntensity * (1.0 + sin(u_time) * 0.05);
      `;

    case DataVisualizationShaderType.POINT_CLUSTER:
      return `
        float dataIntensity = u_intensity * a_value;
        gl_PointSize = mix(u_pointSize * 0.5, u_pointSize * 2.0, dataIntensity);
      `;

    // More type-specific point size calculations

    default:
      return `gl_PointSize = u_pointSize;`;
  }
}
```

### Integration with React Components

The shader system integrates with React through specialized visualization components:

#### DataHighlightVisualization Component

```typescript
// src/components/ui/visualization/DataHighlightVisualization.tsx
export const DataHighlightVisualization: React.FC<DataHighlightVisualizationProps> = ({
  data,
  width,
  height,
  visualizationType = DataVisualizationShaderType.HIGHLIGHT,
  colors = ['#3366cc', '#dc3912', '#ff9900', '#109618', '#990099'],
  highlightRange = [0.7, 1.0],
  animate = true,
  animationSpeed = 1.0,
  intensity = 1.0,
  className = '',
  onDataPointClick,
  showLegend = false,
  shaderConfig,
}) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const shaderManagerRef = useRef<WebGLShaderManager | null>(null);
  const [isInitialized, setIsInitialized] = useState(false);

  // Initialize WebGL shader manager
  useEffect(() => {
    if (!canvasRef.current) return;

    const manager = new WebGLShaderManager();
    const success = manager.initialize(canvasRef.current);

    if (success) {
      shaderManagerRef.current = manager;
      setIsInitialized(true);
    }

    return () => {
      if (shaderManagerRef.current) {
        shaderManagerRef.current.dispose();
        shaderManagerRef.current = null;
      }
    };
  }, []);

  // Render logic...
};
```

#### CustomShaderVisualization Component

The system allows for custom shader definitions:

```typescript
// src/components/ui/visualization/CustomShaderVisualization.tsx
export interface CustomShaderDefinition {
  vertexShader?: string;
  fragmentShader?: string;
  uniforms?: Record<string, ShaderUniform>;
}

export const CustomShaderVisualization: React.FC<CustomShaderVisualizationProps> = ({
  data,
  width,
  height,
  shaderDefinition,
  baseVisualizationType = DataVisualizationShaderType.CUSTOM,
  animate = true,
  animationSpeed = 1.0,
  intensity = 1.0,
  className = '',
  onDataPointClick,
}) => {
  // Implementation...
};
```

### Visualization Types

The shader system supports multiple visualization types, each with unique GPU-accelerated visual effects:

#### 1. Heatmap Visualization

Heat-based density visualization using Gaussian kernels:

```typescript
case DataVisualizationShaderType.HEATMAP:
  return `
    void main() {
      // Calculate color based on value and gradient
      vec3 color = getGradientColor(v_value);

      // Apply heat intensity based on value
      float alpha = smoothstep(0.0, 1.0, v_value) * u_intensity;

      // Apply glow effect
      float glow = 0.0;
      if (u_animate) {
        glow = sin(u_time * u_animationSpeed) * 0.1 + 0.1;
      }

      gl_FragColor = vec4(color * (1.0 + glow), alpha);
    }
  `;
```

#### 2. Contour Visualization

Contour/level visualization for threshold boundaries:

```typescript
case DataVisualizationShaderType.CONTOUR:
  return `
    void main() {
      // Calculate contour lines based on value
      float contourWidth = 0.02;
      float contourSpacing = 0.1;
      float contourValue = mod(v_value, contourSpacing);
      float contourAlpha = smoothstep(0.0, contourWidth, contourValue) *
                          (1.0 - smoothstep(contourSpacing - contourWidth, contourSpacing, contourValue));

      // Get base color from gradient
      vec3 color = getGradientColor(v_value);

      // Apply animation effect
      if (u_animate) {
        contourAlpha *= 0.7 + sin(u_time * u_animationSpeed) * 0.3;
      }

      gl_FragColor = vec4(color, contourAlpha * u_intensity);
    }
  `;
```

#### 3. Data Highlighting

Selective highlighting of specific data ranges:

```typescript
case DataVisualizationShaderType.HIGHLIGHT:
  return `
    void main() {
      // Calculate highlight effect
      float inHighlightRange = step(u_highlightRange.x, v_value) * step(v_value, u_highlightRange.y);
      float highlightEffect = inHighlightRange * u_intensity;

      // Get color from gradient
      vec3 color = getGradientColor(v_value);

      // Apply pulsing effect to highlighted areas
      float pulse = 1.0;
      if (u_animate && inHighlightRange > 0.5) {
        pulse = 0.8 + sin(u_time * u_animationSpeed) * 0.2;
      }

      // Apply highlight effect
      color = mix(color * 0.5, color * pulse, highlightEffect);
      float alpha = mix(0.3, 0.9, highlightEffect);

      gl_FragColor = vec4(color, alpha);
    }
  `;
```

### Usage Example

The shader system can be used to create sophisticated data visualizations:

```tsx
import { DataHighlightVisualization, DataVisualizationPresets } from '../visualization';

function ResourceDensityMap() {
  const [resourceData, setResourceData] = useState<DataPoint[]>([]);

  useEffect(() => {
    // Fetch resource data...
    const data = fetchResourceDistributionData();
    setResourceData(data);
  }, []);

  return (
    <div className="resource-density-container">
      <h2>Resource Density Map</h2>

      <DataHighlightVisualization
        {...DataVisualizationPresets.heatmap({
          data: resourceData,
          width: 800,
          height: 600,
          intensity: 0.8,
          animate: true,
          animationSpeed: 0.5,
        })}
        onDataPointClick={point => {
          console.log(`Resource at (${point.x}, ${point.y}): ${point.value}`);
        }}
        showLegend={true}
      />

      <div className="visualization-controls">
        {/* Controls for adjusting visualization parameters */}
      </div>
    </div>
  );
}
```

### Benefits of GPU Acceleration

The shader system provides several key advantages:

1. **Performance**: GPU acceleration allows rendering thousands of data points at interactive frame rates
2. **Visual Quality**: Complex visual effects enhance data understanding
3. **Interactivity**: Real-time feedback and animations improve user experience
4. **Scalability**: Handles large datasets efficiently
5. **Flexibility**: Supports custom shaders for specialized visualization needs

## Component Library System(#component_library)

### Overview

The Component Library System provides a comprehensive framework for UI components in the Galactic Sprawl game. It implements a compositional architecture where specialized components are built on top of base components, ensuring consistency, reusability, and maintainability. The system follows a variant pattern, allowing for specialized components that extend base functionality while maintaining a consistent API and visual language.

### Key Components

#### Base Component Structure

The component library is organized into a hierarchical structure with base components and specialized variants:

```
src/ui/components/
├── Button/
│   ├── Button.tsx       # Base component
│   ├── variants/
│   │   └── AbilityButton.tsx  # Specialized variant
│   └── index.ts         # Exports
├── Card/
│   ├── Card.tsx         # Base component
│   ├── variants/
│   │   └── ModuleCard.tsx     # Specialized variant
│   └── index.ts         # Exports
└── Badge/
    ├── Badge.tsx        # Base component
    ├── variants/
    │   └── StatusBadge.tsx    # Specialized variant
    └── index.ts         # Exports
```

Each base component is designed to be extensible and implements a consistent pattern:

1. Type definitions for variants and sizes
2. Props interface extending HTML element attributes
3. Forwarded refs for accessibility
4. Configurable styling using utility classes
5. Compositional structure for nested elements

### Component Variant Pattern

#### Base Component Example

Base components define core functionality and styling options:

```typescript
// src/ui/components/Button/Button.tsx
export type ButtonVariant =
  | 'primary'
  | 'secondary'
  | 'tertiary'
  | 'danger'
  | 'success'
  | 'warning'
  | 'info'
  | 'ghost';

export type ButtonSize = 'xs' | 'sm' | 'md' | 'lg' | 'xl';

export interface ButtonProps extends Omit<ButtonHTMLAttributes<HTMLButtonElement>, 'prefix'> {
  /** Button variant */
  variant?: ButtonVariant;
  /** Button size */
  size?: ButtonSize;
  /** Whether the button is loading */
  loading?: boolean;
  /** Whether the button is full width */
  fullWidth?: boolean;
  /** Leading icon */
  leadingIcon?: ReactNode;
  /** Trailing icon */
  trailingIcon?: ReactNode;
  /** Whether the button has a border */
  bordered?: boolean;
  /** Custom focus ring color */
  focusRingColor?: string;
  /** Children */
  children?: ReactNode;
  /** Additional class names */
  className?: string;
}

export const Button = forwardRef<HTMLButtonElement, ButtonProps>(
  (
    {
      variant = 'primary',
      size = 'md',
      loading = false,
      fullWidth = false,
      leadingIcon,
      trailingIcon,
      bordered = false,
      focusRingColor,
      className,
      disabled,
      children,
      ...props
    },
    ref
  ) => {
    // Map variants to class names
    const variantClasses: Record<ButtonVariant, string> = {
      primary: 'bg-blue-600 text-white hover:bg-blue-700 active:bg-blue-800 disabled:bg-blue-400',
      // ... other variant classes
    };

    // Implementation...

    return (
      <button
        ref={ref}
        className={buttonClasses}
        disabled={disabled || loading}
        {...props}
      >
        {/* Button content */}
      </button>
    );
  }
);
```

#### Specialized Variant Example

Specialized variants extend base components for specific use cases:

```typescript
// src/ui/components/Button/variants/AbilityButton.tsx
export interface Ability {
  /** Unique ID of the ability */
  id: string;
  /** Display name of the ability */
  name: string;
  /** Description of what the ability does */
  description: string;
  // ... other properties
}

export interface AbilityButtonProps extends Omit<ButtonProps, 'leadingIcon'> {
  /** The ability to display */
  ability: Ability;
  /** Current cooldown time remaining in seconds */
  cooldownRemaining?: number;
  /** Whether the player has enough resources to use this ability */
  hasResources?: boolean;
  /** Whether to show the cooldown timer */
  showCooldown?: boolean;
  // ... other properties
}

export const AbilityButton = forwardRef<HTMLButtonElement, AbilityButtonProps>(
  (
    {
      ability,
      cooldownRemaining = 0,
      hasResources = true,
      showCooldown = true,
      // ... other props
    },
    ref
  ) => {
    // Specialized implementation...

    return (
      <Button
        ref={ref}
        className={cn(
          'relative group p-2 min-w-[56px] h-[56px]',
          isSelected && 'ring-2 ring-blue-500',
          className
        )}
        variant="secondary"
        disabled={isDisabled}
        onClick={handleClick}
        {...props}
      >
        {/* Specialized content */}
        {tooltipContent}
        {abilityIcon}
        {cooldownOverlay}
        {keybindingIndicator}
      </Button>
    );
  }
);
```

### Compositional UI Architecture

The component library implements a compositional architecture that follows several key principles:

#### 1. Composition Over Inheritance

Components are composed rather than extended through inheritance:

```typescript
// src/ui/components/Card/variants/ModuleCard.tsx
export const ModuleCard = forwardRef<HTMLDivElement, ModuleCardProps>(
  (props, ref) => {
    // Implementation...

    return (
      <Card
        ref={ref}
        variant="bordered"
        className={cardClasses}
        selectable={selectable}
        selected={selected}
        // Specialized props and content
        header={
          <div className="flex items-center justify-between">
            {/* Header content */}
          </div>
        }
        footer={
          <div className="flex items-center justify-between">
            {/* Footer content */}
          </div>
        }
        onClick={handleClick}
        {...otherProps}
      >
        {/* Card content */}
      </Card>
    );
  }
);
```

#### 2. Prop Extension Pattern

Specialized components extend the base component's props while adding or overriding specific properties:

```typescript
// Common pattern for extending props
export interface SpecializedProps extends Omit<BaseProps, 'overriddenProp'> {
  // Additional or replacement properties
  specializedProp: string;
  overriddenProp?: SpecializedType;
}
```

#### 3. Forwarded Refs

All components use the `forwardRef` pattern to ensure proper accessibility and integration:

```typescript
export const Component = forwardRef<HTMLElementType, ComponentProps>(
  (props, ref) => {
    // Implementation...
    return <element ref={ref} {...props} />;
  }
);
```

#### 4. Utility-First Styling

Components use a utility-first CSS approach with a helper function for combining classes:

```typescript
import { cn } from '../../../utils/cn';

// Inside component
const combinedClasses = cn('base-classes', condition && 'conditional-classes', props.className);
```

### Component Design Patterns

The component library implements several consistent design patterns:

#### 1. Variant System

Components provide a type-safe variant system:

```typescript
// Type definition
export type CardVariant = 'default' | 'bordered' | 'elevated' | 'flat';

// Mapping variants to styles
const variantClasses: Record<CardVariant, string> = {
  default: 'bg-white border border-gray-200',
  bordered: 'bg-white border-2 border-gray-300',
  elevated: 'bg-white border border-gray-200 shadow-md',
  flat: 'bg-gray-50',
};

// Usage in component
const classes = variantClasses[variant];
```

#### 2. Size System

Components support consistent sizing options:

```typescript
export type ButtonSize = 'xs' | 'sm' | 'md' | 'lg' | 'xl';

const sizeClasses: Record<ButtonSize, string> = {
  xs: 'text-xs py-1 px-2 h-6',
  sm: 'text-sm py-1 px-3 h-8',
  md: 'text-base py-2 px-4 h-10',
  lg: 'text-lg py-2 px-5 h-12',
  xl: 'text-xl py-3 px-6 h-14',
};
```

#### 3. State Management

Components handle interactive states consistently:

```typescript
// Interactive states in class composition
const classes = cn(
  'base-classes',
  hoverable && 'hover:shadow-lg hover:-translate-y-1',
  selectable && 'cursor-pointer',
  selected && 'ring-2 ring-blue-500',
  disabled && 'opacity-60 pointer-events-none'
);
```

#### 4. Conditional Rendering

Components use conditional rendering for optional elements:

```typescript
{showTitle && (
  <div className="title-container">
    <h3 className="text-lg font-bold">{title}</h3>
  </div>
)}

// Function-based approach for complex conditionals
const renderResources = () => {
  if (!showResources) return null;

  return (
    <div className="resource-display">
      {/* Resource content */}
    </div>
  );
};
```

### Integration With Game Systems

The component library integrates with other game systems:

#### 1. Game-Specific Components

Specialized components integrate with game mechanics:

```typescript
// Example: ModuleCard integrates with the module system
export interface Module {
  id: string;
  name: string;
  status: ModuleStatus;
  level: number;
  // ... other game-specific properties
}

export interface ModuleCardProps extends Omit<CardProps, 'title' | 'subtitle'> {
  module: Module;
  // ... other game-specific props
}
```

#### 2. Event Handling

Components handle game-specific events:

```typescript
// Handling game-specific events
const handleUpgrade = () => {
  if (onUpgrade && module) {
    onUpgrade(module);
  }
};

const handleRepair = () => {
  if (onRepair && module) {
    onRepair(module);
  }
};
```

#### 3. Visual Feedback

Components provide consistent visual feedback for game states:

```typescript
// Progress bars for module stats
const renderProgressBars = () => (
  <div className="grid grid-cols-1 gap-2 mt-3">
    {showEfficiency && (
      <div className="flex items-center">
        <span className="text-xs text-gray-500 w-24">Efficiency</span>
        <div className="flex-1 h-2 bg-gray-200 rounded-full overflow-hidden">
          <div
            className="h-full bg-blue-500 rounded-full"
            style={{ width: `${module.efficiency}%` }}
          />
        </div>
        <span className="text-xs ml-2">{module.efficiency}%</span>
      </div>
    )}
    {/* Other progress bars */}
  </div>
);
```

### Usage Example

The component library makes it easy to create consistent UI elements throughout the application:

```tsx
import { Button, AbilityButton, Card, ModuleCard } from 'ui/components';

function ShipControlPanel() {
  // Component state and handlers
  const [selectedModule, setSelectedModule] = useState<Module | null>(null);

  const handleModuleSelect = (module: Module) => {
    setSelectedModule(module);
  };

  const handleAbilityUse = (ability: Ability) => {
    console.log(`Using ability: ${ability.name}`);
    // Ability use logic
  };

  return (
    <div className="ship-control-panel">
      <h2 className="mb-4 text-xl font-bold">Ship Control</h2>

      <div className="grid grid-cols-2 gap-4">
        <Card title="Module Management" variant="elevated" className="p-4">
          {modules.map(module => (
            <ModuleCard
              key={module.id}
              module={module}
              selectable
              selected={selectedModule?.id === module.id}
              showUpgrade
              showRepair
              onSelect={handleModuleSelect}
              onUpgrade={handleModuleUpgrade}
              onRepair={handleModuleRepair}
            />
          ))}
        </Card>

        <Card title="Ship Abilities" variant="elevated" className="p-4">
          <div className="grid grid-cols-3 gap-2">
            {abilities.map(ability => (
              <AbilityButton
                key={ability.id}
                ability={ability}
                cooldownRemaining={cooldowns[ability.id] || 0}
                hasResources={checkResources(ability)}
                keybinding={keybindings[ability.id]}
                onUse={handleAbilityUse}
              />
            ))}
          </div>
        </Card>
      </div>
    </div>
  );
}
```

### Benefits of the Component Library System

1. **Consistency**: Ensures visual and behavioral consistency across the application
2. **Reusability**: Reduces duplication by providing reusable building blocks
3. **Maintainability**: Centralizes UI logic and styling for easier updates
4. **Type Safety**: Leverages TypeScript for type-safe props and variants
5. **Composition**: Enables building complex UI from simple components
6. **Extensibility**: Makes it easy to add new variants without modifying base components

## Data Processing System(#data_processing)

### Overview

The Data Processing System provides a comprehensive framework for handling data transformations, filtering, analysis, and scientific processing in the Galactic Sprawl game. It implements a modular approach with specialized utilities for different types of data operations, along with performance optimizations through web workers for intensive computations. The system ensures data consistency, type safety, and efficient processing across visualization components, analytics, and game features.

### Key Components

#### Data Transformation Modules

The system is organized into three main transformation modules, each handling specific types of data operations:

```
src/utils/dataTransforms/
├── index.ts             # Main export file
├── chartTransforms.ts   # Visualization data transformations
├── filterTransforms.ts  # Data filtering and search utilities
├── scientificTransforms.ts # Statistical and scientific analysis
└── README.md            # Documentation
```

###### Module Organization

The system uses a modular approach with clear separation of concerns:

```typescript
// src/utils/dataTransforms/index.ts
/**
 * Data Transformation Utilities
 *
 * This module exports consolidated utilities for transforming data
 * for visualization components, filtering, and scientific analysis.
 *
 * Each utility is organized by purpose to make it easier to find
 * and use the appropriate transformation functions.
 */

// Export all chart transformation utilities
export * from './chartTransforms';

// Export all scientific transformation utilities
export * from './scientificTransforms';

// Export all filter transformation utilities
export * from './filterTransforms';

// Re-export specific utilities with more descriptive names to improve discoverability

// Domain calculation
import { calculateDomain, calculateDomains } from './chartTransforms';
export { calculateDomain, calculateDomains };

// Color utilities
export { createColorScale, getResourceTypeColor, hexToRgb };

// ...more specific exports
```

### Chart Data Transformations

The chart transformation system handles data preparation for visualization components:

#### Type Guards

```typescript
// src/utils/dataTransforms/chartTransforms.ts
/**
 * Type guard to check if a value is a number
 */
export function isNumber(value: unknown): value is number {
  return typeof value === 'number' && !isNaN(value);
}

/**
 * Type guard to check if a value is a string
 */
export function isString(value: unknown): value is string {
  return typeof value === 'string';
}

/**
 * Type guard to check if a value is an array
 */
export function isArray<T = unknown>(value: unknown): value is Array<T> {
  return Array.isArray(value);
}

/**
 * Type guard to check if a value is an object
 */
export function isObject(value: unknown): value is Record<string, unknown> {
  return typeof value === 'object' && value !== null && !Array.isArray(value);
}
```

#### Safe Data Extraction

The system provides type-safe data extraction functions that handle missing or invalid values:

```typescript
/**
 * Safely extracts a number value from an object property
 */
export function safelyExtractNumber(
  obj: Record<string, unknown> | null | undefined,
  key: string,
  defaultValue = 0
): number {
  if (!obj) return defaultValue;
  const value = obj[key];
  return isNumber(value) ? value : defaultValue;
}

/**
 * Safely extracts a property from a nested object structure
 */
export function safelyExtractPath<T>(
  obj: Record<string, unknown> | null | undefined,
  path: string,
  defaultValue: T
): T {
  if (!obj) return defaultValue;

  const keys = path.split('.');
  let current: unknown = obj;

  for (const key of keys) {
    if (current === null || current === undefined || typeof current !== 'object') {
      return defaultValue;
    }
    current = (current as Record<string, unknown>)[key];
  }

  return current !== null && current !== undefined ? (current as T) : defaultValue;
}
```

#### Data Format Transformations

The system provides specialized transformations for different visualization needs:

```typescript
/**
 * Transforms data points to scatter plot format
 */
export function transformToScatterFormat(
  dataPoints: DataPoint[],
  valueMetric: string = 'amount'
): Array<{
  id: string;
  name: string;
  x: number;
  y: number;
  value: number;
  type: string;
  coordinates: { x: number; y: number };
}> {
  return dataPoints.map(point => ({
    id: point.id,
    name: point.name || `Point ${point.id}`,
    x: point.coordinates.x,
    y: point.coordinates.y,
    value: safelyExtractNumber(point.properties, valueMetric, 0),
    type: safelyExtractString(point.properties, 'type', 'unknown'),
    coordinates: point.coordinates,
  }));
}

/**
 * Transforms grid cells to heat map format
 */
export function transformToHeatMapFormat(
  gridCells: ResourceGridCell[],
  valueMetric: string = 'amount',
  selectedResourceType: string = 'all'
): Array<{
  x: number;
  y: number;
  value: number;
  resources: Array<{
    type: ResourceType;
    amount: number;
    quality?: number;
    accessibility?: number;
    estimatedValue?: number;
  }>;
}> {
  // Implementation details...
}
```

### Filter Transformations

The filter transformation system provides utilities for filtering and searching data:

#### Filter Types

```typescript
// src/utils/dataTransforms/filterTransforms.ts
/**
 * Supported filter operators
 */
export type FilterOperator =
  | 'equals'
  | 'notEquals'
  | 'greaterThan'
  | 'lessThan'
  | 'contains'
  | 'notContains'
  | 'between'
  | 'in'
  | 'notIn'
  | 'exists'
  | 'notExists';

/**
 * Filter definition
 */
export interface Filter {
  field: string;
  operator: FilterOperator;
  value: string | number | boolean | string[] | [number, number];
}

/**
 * Filter Group (for complex filtering with AND/OR logic)
 */
export interface FilterGroup {
  type: 'and' | 'or';
  filters: Array<Filter | FilterGroup>;
}
```

#### Filter Operations

The system provides comprehensive operations for creating, validating, and applying filters:

```typescript
/**
 * Creates a filter with type checking and validation
 */
export function createFilter(
  field: string,
  operator: FilterOperator,
  value: unknown
): Filter | null {
  // Validation logic...
}

/**
 * Validates a filter object
 */
export function validateFilter(filter: unknown): filter is Filter {
  // Validation logic...
}

/**
 * Applies a filter to a data item
 */
export function applyFilter(item: Record<string, unknown>, filter: Filter): boolean {
  const value = safelyExtractPath(item, filter.field, undefined);

  switch (filter.operator) {
    case 'equals':
      return value === filter.value;
    case 'notEquals':
      return value !== filter.value;
    case 'greaterThan':
      return isNumber(value) && isNumber(filter.value) && value > filter.value;
    case 'lessThan':
      return isNumber(value) && isNumber(filter.value) && value < filter.value;
    // More cases...
  }
}

/**
 * Applies a complex filter with AND/OR logic
 */
export function applyComplexFilter(
  data: Array<Record<string, unknown>>,
  filterGroup: FilterGroup
): Array<Record<string, unknown>> {
  return data.filter(item => applyFilterGroup(item, filterGroup));
}
```

### Scientific Transformations

The scientific transformation system provides advanced algorithms for data analysis:

#### Time Series Analysis

```typescript
// src/utils/dataTransforms/scientificTransforms.ts
/**
 * Transforms time series data for visualization
 */
export function transformTimeSeriesData(
  timePoints: number[] | string[],
  actualValues: number[],
  predictedValues?: number[],
  forecastValues?: number[]
): Array<{
  time: number | string;
  actual?: number;
  predicted?: number;
  forecast?: number;
}> {
  // Implementation details...
}

/**
 * Calculates residuals (actual - predicted)
 */
export function calculateResiduals(actualValues: number[], predictedValues: number[]): number[] {
  const residuals: number[] = [];
  const minLength = Math.min(actualValues.length, predictedValues.length);

  for (let i = 0; i < minLength; i++) {
    residuals.push(actualValues[i] - predictedValues[i]);
  }

  return residuals;
}
```

#### Statistical Analysis

```typescript
/**
 * Calculates correlation coefficients between variables
 */
export function calculateCorrelationMatrix(
  data: Array<Record<string, unknown>>,
  variables: string[]
): Array<Array<number>> {
  // Implementation details...
}

/**
 * Calculates statistical metrics for a variable
 */
export function calculateStatistics(
  data: Array<Record<string, unknown>>,
  variable: string
): {
  min: number;
  max: number;
  mean: number;
  median: number;
  standardDeviation: number;
  count: number;
  missing: number;
} {
  // Implementation details...
}
```

#### Model Analysis

```typescript
/**
 * Extracts feature importance from a trained model
 */
export function extractFeatureImportance(
  modelDetails: Record<string, unknown>,
  features: string[]
): Array<{ feature: string; importance: number }> {
  // Implementation details...
}

/**
 * Type guard for linear regression models
 */
export function isLinearRegressionModel(modelDetails: Record<string, unknown>): boolean {
  return safelyExtractString(modelDetails, 'type', '') === 'linearRegression';
}
```

### Web Worker Integration

The system uses web workers for intensive data processing operations to ensure UI responsiveness:

```typescript
// src/workers/DataProcessingWorker.ts
export enum WorkerMessageType {
  PROCESS_CLUSTERING = 'PROCESS_CLUSTERING',
  PROCESS_PREDICTION = 'PROCESS_PREDICTION',
  PROCESS_RESOURCE_MAPPING = 'PROCESS_RESOURCE_MAPPING',
  TRANSFORM_DATA = 'TRANSFORM_DATA',
  DATA_SORTING = 'DATA_SORTING',
  DATA_FILTERING = 'DATA_FILTERING',
  CALCULATE_STATISTICS = 'CALCULATE_STATISTICS',
}

// Message handling
self.addEventListener('message', (event: MessageEvent<WorkerMessage>) => {
  const { type, id, payload } = event?.data ?? {};

  try {
    let result;

    switch (type) {
      case WorkerMessageType.PROCESS_CLUSTERING:
        result = processClustering(payload);
        break;

      case WorkerMessageType.PROCESS_PREDICTION:
        result = processPrediction(payload);
        break;

      // More cases...
    }

    // Send result back to main thread
    self.postMessage({
      id,
      result,
    } as WorkerResponse);
  } catch (error) {
    // Send error back to main thread
    self.postMessage({
      id,
      result: null,
      error: error instanceof Error ? error.message : String(error),
    } as WorkerResponse);
  }
});
```

#### Worker-Based Data Operations

The worker implements various computationally intensive operations:

```typescript
/**
 * Sort data in a worker thread
 */
function sortData(payload: SortingPayload): Record<string, unknown>[] {
  const { data, key, order } = payload;

  return [...data].sort((a, b) => {
    const valueA = safelyExtractPath(a, key, null);
    const valueB = safelyExtractPath(b, key, null);

    // Handle nulls
    if (valueA === null && valueB === null) return 0;
    if (valueA === null) return order === 'asc' ? -1 : 1;
    if (valueB === null) return order === 'asc' ? 1 : -1;

    // Compare based on type
    if (typeof valueA === 'number' && typeof valueB === 'number') {
      return order === 'asc' ? valueA - valueB : valueB - valueA;
    }

    // Default string comparison
    const strA = String(valueA);
    const strB = String(valueB);
    return order === 'asc' ? strA.localeCompare(strB) : strB.localeCompare(strA);
  });
}

/**
 * Calculate statistics in a worker thread
 */
function calculateStatistics(payload: StatisticsPayload): StatisticsResult {
  const { data, operations } = payload;
  const result: StatisticsResult = {};

  // Skip empty datasets
  if (!data || data.length === 0) {
    return result;
  }

  // Calculate requested operations
  for (const op of operations) {
    switch (op) {
      case 'mean':
        result.mean = data.reduce((sum, value) => sum + value, 0) / data.length;
        break;

      case 'median':
        const sorted = [...data].sort((a, b) => a - b);
        const mid = Math.floor(sorted.length / 2);
        result.median = sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];
        break;

      // More cases...
    }
  }

  return result;
}
```

### Data Transformation Patterns

The system implements several consistent patterns for data transformations:

#### 1. Type Safety with Guards

All data transformations use type guards to ensure type safety:

```typescript
// Before performing operations, check types
if (isNumber(value)) {
  // Safely perform numerical operations
  return value * 2;
}

// Use type guards to ensure correct handling
return isArray(value) ? value.length : 0;
```

#### 2. Null/Undefined Handling

The system consistently handles null/undefined values:

```typescript
// Use nullish coalescing for defaults
const value = obj?.property ?? defaultValue;

// Use safe extraction functions
const count = safelyExtractNumber(data, 'count', 0);
```

#### 3. Immutable Transformations

Transformations don't modify input data:

```typescript
// Create new arrays rather than modifying inputs
return data.map(item => ({
  ...item,
  transformedValue: processValue(item.value),
}));

// Sort by creating new array
return [...data].sort((a, b) => a.value - b.value);
```

#### 4. Worker Offloading

Intensive operations are offloaded to web workers:

```typescript
// In UI component
const processData = async largeDataset => {
  setLoading(true);

  try {
    const result = await workerService.sendMessage({
      type: WorkerMessageType.CALCULATE_STATISTICS,
      payload: {
        data: largeDataset,
        operations: ['mean', 'median', 'stdDev'],
      },
    });

    setStatistics(result);
  } finally {
    setLoading(false);
  }
};
```

### Integration With Game Systems

The data processing system integrates with other game systems:

#### 1. Exploration System

```typescript
// Used in exploration components for analysis
import { transformResourceMappingData } from '../../utils/dataTransforms';

function ResourceMapComponent() {
  useEffect(() => {
    // Transform exploration data for visualization
    const transformedData = transformResourceMappingData(analysisResult);
    setMapData(transformedData);
  }, [analysisResult]);

  // Render map with transformed data
}
```

#### 2. Resource System

```typescript
// Used in resource management for filtering and analysis
import { applyFilters, calculateStatistics } from '../../utils/dataTransforms';

function ResourceAnalytics() {
  // Filter resources based on criteria
  const criticalResources = applyFilters(allResources, [
    { field: 'amount', operator: 'lessThan', value: 100 },
    { field: 'type', operator: 'in', value: ['energy', 'minerals'] },
  ]);

  // Calculate resource statistics
  const stats = calculateStatistics(allResources, 'amount');

  // Render analytics dashboard
}
```

#### 3. Scientific Analysis

```typescript
// Used in research components for predictions
import { transformTimeSeriesData, calculateResiduals } from '../../utils/dataTransforms';

function ResearchPredictionComponent() {
  // Transform time series data for prediction charts
  const timeSeriesData = transformTimeSeriesData(
    timePoints,
    actualProduction,
    predictedProduction,
    forecastProduction
  );

  // Calculate prediction accuracy
  const residuals = calculateResiduals(actualProduction, predictedProduction);
  const accuracy =
    1 -
    Math.abs(residuals.reduce((sum, val) => sum + val, 0)) /
      actualProduction.reduce((sum, val) => sum + val, 0);

  // Render prediction visualization
}
```

### Usage Example

The data processing system provides a clean API for data transformations:

```tsx
import {
  transformToScatterFormat,
  calculateStatistics,
  applyFilters,
} from '../../utils/dataTransforms';

function ResourceExplorationDashboard() {
  const [resources, setResources] = useState<ResourceData[]>([]);
  const [filteredResources, setFilteredResources] = useState<ResourceData[]>([]);
  const [statistics, setStatistics] = useState<StatisticsResult | null>(null);

  useEffect(() => {
    // Fetch resource data
    const fetchResources = async () => {
      const data = await resourceService.getResourceData();
      setResources(data);

      // Transform data for visualization
      const scatterData = transformToScatterFormat(data, 'quantity');
      setScatterData(scatterData);

      // Calculate statistics
      setStatistics(calculateStatistics(data, 'quantity'));
    };

    fetchResources();
  }, []);

  // Apply filters when criteria changes
  useEffect(() => {
    const filtered = applyFilters(resources, [
      { field: 'type', operator: 'equals', value: selectedResourceType },
      { field: 'quality', operator: 'greaterThan', value: minQuality },
    ]);

    setFilteredResources(filtered);
  }, [resources, selectedResourceType, minQuality]);

  return (
    <div className="resource-dashboard">
      <ResourceStatistics statistics={statistics} />
      <ResourceScatterPlot data={scatterData} />
      <ResourceFilterPanel
        onFilterChange={setFilterCriteria}
        resourceTypes={getUniqueValues(resources, 'type')}
      />
      <ResourceTable data={filteredResources} />
    </div>
  );
}
```

### Benefits of the Data Processing System

1. **Type Safety**: Ensures type-safe operations through guards and safe extraction
2. **Performance**: Offloads intensive operations to web workers for UI responsiveness
3. **Reusability**: Provides a common set of utilities used across the application
4. **Maintainability**: Centralizes data transformation logic for easier maintenance
5. **Consistency**: Ensures consistent handling of data across the application
6. **Extensibility**: Modular design makes it easy to add new transformations
